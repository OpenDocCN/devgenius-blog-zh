<html>
<head>
<title>Sealed Secret in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯的秘密</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sealed-secret-in-kubernetes-d10fed2da964?source=collection_archive---------2-----------------------#2022-09-16">https://blog.devgenius.io/sealed-secret-in-kubernetes-d10fed2da964?source=collection_archive---------2-----------------------#2022-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="61e1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="22a9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Kubernetes 中，我们使用秘密在 Kubernetes 集群中存储敏感数据。但是你把它们存放在哪里呢？如果我们想把它们保存在 SCM(源代码管理)工具中，这就成了一个安全威胁。</p><p id="0e0f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Kubernetes 中的 Secret 用于存储敏感信息，如密码、ssh 密钥、证书、令牌等。机密以 base64 编码，不加密，当它们附加到 pod 时会自动解码。</p><p id="fef2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这些数据是“唯一”编码的，因此如果用户有权访问您的机密，他可以简单地执行 base64 decode 命令来查看您的敏感数据(ku bectl get secret my-secret-o JSON path = " { . data . password } " | base64--decode)。</p><p id="7a7b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因为它没有被加密，所以将它们提交给你的源代码管理(SCM)是不安全的。如果我们要在单片机中存储这些秘密，就会出现安全问题。为了避免所有这些问题，我们可以使用密封机密。</p><h1 id="6572" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">密封的秘密</h1><p id="0248" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">密封机密允许对您的 Kubernetes 机密进行“单向”加密，并且只能由在您的目标集群中运行的密封机密控制器解密。这种机制基于公钥加密，这是一种由公钥和私钥对组成的加密形式。一个密钥可用于加密，只有另一个密钥可用于解密加密的内容。控制器将生成密钥对，将公钥证书发布到日志中，并通过 HTTP API 请求公开它。</p><p id="3928" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这些加密的秘密也可以通过使用 kubectl 等工具，使用普通的工作流部署到 Kubernetes 集群。</p><h1 id="3db2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">先决条件:</h1><ol class=""><li id="5bf3" class="ll lm in kk b kl km kp kq kt ln kx lo lb lp lf lq lr ls lt bi translated">Kubernetes 集群已经启动并运行。</li><li id="e880" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">创建一个名称空间，您可以在其中部署您的机密。对于本教程，我们将使用“<strong class="kk io"> demo </strong>名称空间。</li></ol><h1 id="a730" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">安装:-</h1><p id="702f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们假设您已经具备了所有的先决条件，现在可以在 Kubernetes 集群上使用 SealedSecret 了。</p><p id="d37c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">安装密封的秘密包含 2 个步骤:-</p><ol class=""><li id="2750" class="ll lm in kk b kl lg kp lh kt lz kx ma lb mb lf lq lr ls lt bi translated">在本地机器上安装 Kubeseal CLI。</li><li id="b26c" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">为 SealedSecret 安装自定义控制器。</li></ol><h1 id="c60c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">在本地机器上安装 Kubeseal CLI。</h1><p id="9a9d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们使用 Kubeseal CLI 工具来生成一个公钥证书，以在一个密封的秘密中加密我们的秘密。Kubeseal 可以通过 Kubernetes API 服务器与控制器通信，并在运行时检索加密秘密所需的公钥。公钥也可以从控制器下载并保存在本地以供离线使用。</p><p id="02cc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">可以按照下面提到的步骤将客户端工具安装到/usr/local/bin 中</p><p id="2755" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，我们需要通过运行以下命令下载 kubeseal tar 文件:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="77ea" class="ml jl in mh b gy mm mn l mo mp">wget <a class="ae mq" href="https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/kubeseal-0.18.0-linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/kubeseal-0.18.0-linux-amd64.tar.gz</a></span></pre><p id="d5d6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下载 tar 文件后，使用下面提到的命令提取该 tar 文件:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="059d" class="ml jl in mh b gy mm mn l mo mp">tar -xfz kubeseal-0.18.0-linux-amd64.tar.gz</span></pre><p id="963d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们可以在/usr/local/bin/kubeseal 位置安装 kubeseal，使用下面提到的命令:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3dc5" class="ml jl in mh b gy mm mn l mo mp">sudo install -m 755 kubeseal /usr/local/bin/kubeseal</span></pre><p id="38db" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要检查 kubeseal 是否已安装，请运行以下命令:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7795" class="ml jl in mh b gy mm mn l mo mp">kubeseal --version</span></pre><h1 id="ff5a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为 SealedSecret 安装自定义控制器和 CRD</h1><p id="403a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，我们将在 kube-system 名称空间中安装控制器和 SealedSecret 自定义资源定义。sealed secrets 控制器将在集群中启用 Sealed Secrets 的生命周期操作。</p><p id="0e2f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要部署 sealed-secret 控制器，请遵循以下步骤</p><p id="14c6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，我们需要下载控制器，使用下面提到的命令下载控制器清单。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c8a4" class="ml jl in mh b gy mm mn l mo mp">wget <a class="ae mq" href="https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml</a></span></pre><p id="79f5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下载控制器后，使用下面提到的命令将其部署在 Kubernetes 集群上</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8153" class="ml jl in mh b gy mm mn l mo mp">kubectl apply -f controller.yaml</span></pre><p id="9d60" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以使用以下命令检查部署的状态</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="59bd" class="ml jl in mh b gy mm mn l mo mp">kubectl get pods -n kube-system | grep sealed-secrets-controller</span></pre><p id="2013" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以通过运行以下命令来查看包含 YAML 格式的公钥/私钥对的秘密内容:-</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="dcff" class="ml jl in mh b gy mm mn l mo mp">kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml</span></pre><p id="5d07" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">输出:- </strong></p><figure class="mc md me mf gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/36a0341d0d806d2bde12da62bb23270d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*SW7yU9oXPQMsohAa"/></div></figure><p id="a2f7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在您的控制器已经部署好了。</p><h1 id="2c02" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">保守秘密</h1><p id="96f7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们创建一个名为 secret.yaml 的秘密文件。您可以使用下面提到的示例，也可以创建自己的 secret.yaml 文件。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9e10" class="ml jl in mh b gy mm mn l mo mp">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  creationTimestamp: null<br/>  name: my-secret<br/>  namespace: demo<br/>data:<br/>  user: YWRtaW4=<br/>  password: TXlTZWNyZXREZW1vRmlsZQ==</span></pre><p id="f4c5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有两种方法来创建密封的秘密:-</p><ul class=""><li id="d632" class="ll lm in kk b kl lg kp lh kt lz kx ma lb mb lf mv lr ls lt bi translated">没有证书文件(在线)。</li><li id="cc3e" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf mv lr ls lt bi translated">使用证书文件(脱机)。</li></ul><ol class=""><li id="3e68" class="ll lm in kk b kl lg kp lh kt lz kx ma lb mb lf lq lr ls lt bi translated"><strong class="kk io">在线(无证书文件)。</strong></li></ol><p id="4ed5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，让我们使用这个 secret.yaml 文件通过 kubeseal 创建 SealedSecret YAML 清单。</p><p id="a478" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在执行以下命令之前，请确保您能够访问目标 Kubernetes 集群，并且能够对目标 Kubernetes 集群运行 kubectl 命令。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3f81" class="ml jl in mh b gy mm mn l mo mp">kubeseal --format=yaml &lt; secret.yaml &gt; sealed-secret.yaml</span></pre><p id="6a64" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">成功运行该命令后，您将获得一个名为 sealed-secret.yaml 的文件</p><p id="7391" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> 2。脱机(使用证书文件)。</strong></p><p id="a1bd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">另一种方法是从控制器获取公钥，并离线使用它来密封您的秘密。</p><p id="354a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">只需要访问 Kubernetes 集群来获取 pem 文件。完成后，您可以使用该 pem 文件为目标集群密封您的秘密，防止任何安装了 kubeseal 的机器访问。</p><p id="626c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">此命令将获取证书文件，并以 public-key-cert.pem 的名称将其保存在您的本地计算机中</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="923a" class="ml jl in mh b gy mm mn l mo mp">kubeseal --fetch-cert &gt; public-key-cert.pem</span></pre><p id="0cff" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在可以使用这个命令创建 sealed-secret.yaml</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7270" class="ml jl in mh b gy mm mn l mo mp">kubeseal --cert=public-key-cert.pem --format=yaml &lt; secret.yaml &gt; sealed-secret.yaml</span></pre><p id="f7bc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">该命令还将创建一个 sealed-secret.yaml 文件。</p><p id="9d8c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以检查这两个文件(secret.yaml 和 sealed-secret.yaml)</p><ul class=""><li id="5002" class="ll lm in kk b kl lg kp lh kt lz kx ma lb mb lf mv lr ls lt bi translated"><strong class="kk io"> Secret.yaml 文件</strong></li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="aa0b" class="ml jl in mh b gy mm mn l mo mp">cat secret.yaml</span></pre><p id="f179" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">输出</strong> : -</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8706" class="ml jl in mh b gy mm mn l mo mp">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  creationTimestamp: null<br/>  name: my-secret<br/>  namespace: demo<br/>data:<br/>  user: YWRtaW4=<br/>  password: TXlTZWNyZXREZW1vRmlsZQ==</span><span id="f732" class="ml jl in mh b gy mw mn l mo mp">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  creationTimestamp: null<br/>  name: my-secret<br/>  namespace: demo<br/>data:<br/>  user: YWRtaW4=<br/>  password: TXlTZWNyZXREZW1vRmlsZQ==</span></pre><ul class=""><li id="d61b" class="ll lm in kk b kl lg kp lh kt lz kx ma lb mb lf mv lr ls lt bi translated"><strong class="kk io"> sealed-secret.yaml </strong></li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="77a1" class="ml jl in mh b gy mm mn l mo mp">cat sealed-secret.yaml</span></pre><p id="a5ba" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">输出:- </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ea08" class="ml jl in mh b gy mm mn l mo mp">apiVersion: bitnami.com/v1alpha1<br/>kind: SealedSecret<br/>metadata:<br/>  creationTimestamp: null<br/>  name: my-secret<br/>  namespace: demo<br/>spec:<br/>  encryptedData:<br/>    password: AgB/XlNUiGvhKT25K(…)bOtCIIDAid<br/>    user: AgAI9gJiQt0NHULDqdWw4(…)SSlw==<br/> template:<br/>   data: null<br/>   metadata:<br/>     creationTimestamp: null<br/>     name: my-secret<br/>     namespace: demo</span></pre><p id="4f8d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">注意，原始秘密中的密钥，即用户和密码，在 SealedSecret 中没有加密，只有它们的值被加密。</p><p id="8200" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们可以在我们的 Kubernetes 集群中部署密封的秘密。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="60e2" class="ml jl in mh b gy mm mn l mo mp">kubectl apply -f sealed-secret.yaml</span></pre><p id="f344" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果您检查在 kube-system 名称空间中运行的密封控制器的日志，您将看到刚刚部署的 SealedSecret 定制资源。</p><p id="b416" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">kubectl logs-n kube-system sealed-secrets-controller-7 bdbc 75d 47–5 wxvf</p><p id="39f7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">输出:</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2ccb" class="ml jl in mh b gy mm mn l mo mp">2022/08/30 07:54:49 Updating demo/my-secret<br/>2022/08/30 07:54:49 Event(v1.ObjectReference{Kind:”SealedSecret”, Namespace:”demo”, Name:”my-secret”, UID:”330bcf2a-9433–4696–8784-a00190758b86", APIVersion:”bitnami.com/v1alpha1", ResourceVersion:”221612", FieldPath:””}): type: ‘Normal’ reason: ‘Unsealed’ SealedSecret unsealed successfully</span></pre><h1 id="73da" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试</h1><p id="8211" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将部署一个应用程序，在这个部署中，我们将把新创建的秘密作为<strong class="kk io"> ENV </strong>变量传递。然后，我们将检查我们是否能够从吊舱内部访问这些秘密。</p><p id="4948" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于测试，您可以部署自己的应用程序，也可以使用下面提到的清单进行测试。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9aec" class="ml jl in mh b gy mm mn l mo mp">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: demo<br/>  namespace: demo<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: demo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: demo<br/>    spec:<br/>      containers:<br/>      - name: demo<br/>        image: sagar27/testing:latest<br/>        ports:<br/>        - containerPort: 80<br/>        env:<br/>        - name: KUBE_USER<br/>          valueFrom:<br/>            secretKeyRef:<br/>              name: my-secret<br/>              key: user<br/>        - name: KUBE_PASS<br/>          valueFrom:<br/>            secretKeyRef:<br/>              name: my-secret<br/>              key: password</span></pre><p id="8416" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">正如你在上面的清单中看到的，我们已经创建了两个变量<strong class="kk io">KUBE _ 用户</strong>和<strong class="kk io">KUBE _ 通行证</strong>，我们将使用这个 env 变量映射秘密存储的值。用名称<strong class="kk io"> deploy.yaml </strong>保存这个文件。</p><p id="f79c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用命令部署这个清单，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4250" class="ml jl in mh b gy mm mn l mo mp">Kubectl apply -f deploy.yaml</span></pre><p id="3b04" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">等待几分钟，然后运行下面提到的命令。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="61be" class="ml jl in mh b gy mm mn l mo mp">kubectl get po -n demo</span></pre><p id="2b07" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">你会得到这样的输出。</p><figure class="mc md me mf gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/a1596058ad37156e2a6d852434631622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjoNLOtOMzXYwpGbCDUHBQ.png"/></div></div></figure><p id="e89c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">通过使用下面提到的命令，复制 pod 名称并获取这个 pod 的 shell。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="af29" class="ml jl in mh b gy mm mn l mo mp">kubectl exec -it demo-d8745c657-l6d42 bash -n demo</span></pre><p id="d6e6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，您可以通过运行下面提到的命令来检查变量的值。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="edcf" class="ml jl in mh b gy mm mn l mo mp">root@demo-d8745c657-l6d42:/# echo $KUBE_USER<br/>admin<br/>root@demo-d8745c657-l6d42:/# echo $KUBE_PASS<br/>MySecretDemoFile</span></pre><p id="1b1a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">属于 SealedSecret 的 yaml 文件 sealed-secret.yaml 可以安全地与属于其他 Kubernetes 资源(如 DaemonSets、Deployments、ConfigMaps 等)的 YAML 清单一起存储在 Git 存储库中。部署在集群中。</p></div></div>    
</body>
</html>