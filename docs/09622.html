<html>
<head>
<title>Kotlin Sealed Class is so practical, how to use it in Java 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 密封类这么实用，Java 8 怎么用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-sealed-class-is-so-practical-how-to-use-it-in-java-8-218991cab2f3?source=collection_archive---------10-----------------------#2022-09-01">https://blog.devgenius.io/kotlin-sealed-class-is-so-practical-how-to-use-it-in-java-8-218991cab2f3?source=collection_archive---------10-----------------------#2022-09-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6afaa852b8950e5741d741b5f9164e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OwrfSWhboIhcp6Fv.jpg"/></div></div></figure><p id="6d9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免分发过程中数据被恶意篡改，Kotlin 可以将 SealedClass 的参数设置为 val，</p><p id="641a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java 17 以下版本没有引入 SealedClass，如果达到 Kotlin val 同样的效果，样板代码会瞬间爆炸很多，这意味着在解决数据一致性的同时，会产生更多的一致性问题，比如以后修改一个字段，忘记配置结构方法等等。</p><p id="853e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想了想，SealedClass4Java 应运而生，通过注释自动生成 SealedClass，像 Kotlin 一样使用 SealedClass。</p><p id="82bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">献给喜欢 Kotlin 但又要维护老 Java 项目的朋友。</p><h1 id="4aef" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><a class="ae lr" href="https://github.com/KunMinX/SealedClass4Java" rel="noopener ugc nofollow" target="_blank"> Github:SealedClass4Java </a></h1><h1 id="5648" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用</h1><p id="7a22" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">1.创建一个接口，添加 SealedClass 注释，接口名以 _ 下划线开头，</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="926e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.编译生成一个目标类，比如 TestEvent，然后可以像 Kotlin 一样使用它:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="345c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">高级用法</h1><p id="ec4e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这个框架是在<a class="ae lr" href="https://github.com/KunMinX/MVI-Dispatcher" rel="noopener ugc nofollow" target="_blank">MVI-调度员</a>项目的优化过程中诞生的工具，目的是为了消除“消息分发场景的最终样板代码”，所以让我们以 MVI-调度员的使用场景为例:</p><blockquote class="md me mf"><p id="c3b6" class="jv jw mg jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated"><em class="in">注:“消息、事件、意图”，不同的场景，不同的名称，但本质上指的是同一个东西，即“可消费的一次性数据”。</em></p></blockquote><h1 id="f495" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">A.纯消息分发场景</h1><p id="bb66" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">1.定义一个接口，比如 _Messages，在方法列表中定义一个不带参数的纯消息，定义完成后生成对应的 Messages 类。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2f17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.发送消息。MVI 视图中的纯消息</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="58e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.MVI 模型中的转发消息</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="416b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.在 MVI 视图中回复消息</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="c493" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">B.带参数的意向分布方案</h1><p id="82ea" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这种情况很常见。例如，页面从后台请求数据，通过意向传递参数，在后台处理结果，将结果注入意向，然后将其发送回页面。</p><p id="8852" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在这个场景中，intent 将携带“参数”和“结果”，在发送场景中只需要注入参数，在推回场景中只需要注入结果。</p><p id="6b15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，使用方法是，</p><p id="afa7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.定义接口，向参数添加@Param 注释，</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="705a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">build 生成的静态方法，如 AddNote 方法，只提供“参数”列表，不提供结果列表，结果字段被赋予默认值，以满足意向发送场景的使用。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7b07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.发送通知意向。AddNote(注意)MVI 视图中的意图，</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="59e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.在 MVI 模型中处理业务逻辑，注入结果并推回意图。</p><p id="70f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于不能修改意图来保证“数据一致性”，在注入结果的场景下，可以通过 copy 方法复制一个新的意图，copy 方法的输入参数是“结果”列表，符合的意图推回场景用法。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="fdd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.回应 MVI 视图中的意图</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="c390" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">C.无参数的事件分布场景</h1><p id="f0f9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">即没有初始值参数，仅用于结果分布的情况。</p><p id="f121" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种场景和“带参数意图的分布场景”通常是重叠和互补的，所以它们在使用上实际上是相似的。</p><p id="cb82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.定义接口，方法没有用@Param 注释。在这种情况下，NoteIntent。GetNotes 静态方法提供了两种类型:无参数和有参数。我们通常不使用参数，即事件的结果在创建时被赋予一个默认值。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ba5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.发送通知意向。MVI 视图中的 GetNotes()事件，</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b821" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.在 MVI 模型中处理业务逻辑，注入结果并推回意图。</p><p id="31f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于不能修改意图来保证“数据一致性”，在注入结果的场景下，可以通过 copy 方法复制一个新的意图，copy 方法的输入参数是“结果”列表，符合的意图推回场景用法。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b72b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.回应 MVI 事件-查看</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="c5ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lr" href="https://github.com/KunMinX/SealedClass4Java" rel="noopener ugc nofollow" target="_blank"> Github:SealedClass4Java </a></p></div></div>    
</body>
</html>