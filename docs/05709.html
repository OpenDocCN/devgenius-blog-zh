<html>
<head>
<title>Jest and SonarQube of unit tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试的笑话和笑话</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/jest-and-sonarqube-of-unit-tests-d19abbe233a8?source=collection_archive---------2-----------------------#2021-10-09">https://blog.devgenius.io/jest-and-sonarqube-of-unit-tests-d19abbe233a8?source=collection_archive---------2-----------------------#2021-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c9df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想法和解决方案我站在角度测试的前面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8e37d883de0ea2f6a017795547cc9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eZF8txwEzKjsU7eZXSbpw.png"/></div></div></figure><p id="b923" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从语法上看，Jasmine Karma和Jest框架没有太大区别。它们之间有很多逻辑上的差异。但是它们非常相似，尽管Jest比Karma测试快3倍，因为Jest使用命令行来运行测试，而不是web浏览器。</p><p id="dee5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原则上，我更喜欢使用Jest框架，这篇文章是基于Jest的，但是Jasmine Karma是它的前身……很多项目仍然在使用它。</p><p id="6f52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在开始时定义一些常数:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="63e3" class="kz la in kv b gy lb lc l ld le">beforeEach(() =&gt; {<br/>  fixture = TestBed.createComponent(MyComponent);<br/>  component = fixture.componentInstance;<br/>  element = fixture.nativeElement;<br/>  fixture.detectChanges();<br/>});</span></pre><p id="3a96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常单元测试的通用结构由3部分组成:</p><ol class=""><li id="1612" class="lf lg in jm b jn jo jr js jv lh jz li kd lj kh lk ll lm ln bi translated">首先，我们定义对象</li><li id="55d8" class="lf lg in jm b jn lo jr lp jv lq jz lr kd ls kh lk ll lm ln bi translated">然后我们调用一个服务或方法来调用一些实现</li><li id="d3f7" class="lf lg in jm b jn lo jr lp jv lq jz lr kd ls kh lk ll lm ln bi translated">并且至少检查预期值和接收值</li></ol><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="f179" class="kz la in kv b gy lb lc l ld le"><strong class="kv io"><em class="lt">it</em></strong>("should find the item", () =&gt; {<br/>  // given<br/>  const input: HTMLInputElement = element.querySelector("#search");<br/>  input.value = "test";<br/>  input.dispatchEvent(new <strong class="kv io"><em class="lt">Event</em></strong>("blur"));<br/>  fixture.detectChanges();</span><span id="aab0" class="kz la in kv b gy lu lc l ld le">  // when calls for real method of Angular<br/>  component.triggerSearch();</span><span id="3281" class="kz la in kv b gy lu lc l ld le">  // then compare received and expected data<br/>  <strong class="kv io"><em class="lt">expect</em></strong>(component.search).not.toBeNull();<br/>});</span></pre><p id="3964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">角度测试框架有一些特定的方法来以同步和异步的方式工作。</p><p id="2c2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Async — </strong>方法<strong class="jm io"> </strong>，当这个测试函数中的所有异步调用完成时，该方法将自动完成。</p><p id="d7fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在测试中的异步调用期间，我们在异步调用完成之前等待真正的方法完成。我们经常需要检查呼叫完成时的状态。使用whenStable()，然后:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="ec84" class="kz la in kv b gy lb lc l ld le">it(‘should show result after async wait’, async(() =&gt; { <br/>  // here define some variables...<br/>  const input: HTMLInputElement =<br/>    element.querySelector("input[id='number-of-sales'] input");</span><span id="741c" class="kz la in kv b gy lu lc l ld le">  input.value = "11";<br/>  input.dispatchEvent(new <strong class="kv io"><em class="lt">Event</em></strong>("input"));</span><span id="0ebf" class="kz la in kv b gy lu lc l ld le">  // when<br/>  fixture.detectChanges(); // call for ngOnInit()<br/>  component.applyLeadTimeValues();</span><span id="cdce" class="kz la in kv b gy lu lc l ld le">  //then<br/>  fixture.whenStable().then(() =&gt; {<br/>    fixture.detectChanges();<br/><strong class="kv io"><em class="lt">    expect</em></strong>(component.numberOfSalesComponent.value).toEqual("11");<br/>  });<br/>}));</span></pre><p id="2a63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Async + whenStable — </strong>给出夹具稳定时解决的<code class="fe lv lw lx kv b">Promise</code>。</p><p id="d5e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常我们需要触发变更事件，因为这不会自动发生。<code class="fe lv lw lx kv b">Fixture.whenStable()</code>返回一个在任务队列变空时解决的承诺。我们只需要异步等待。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="72c9" class="kz la in kv b gy lb lc l ld le">it('should click Apply button', async(() =&gt; {<br/>  const btn = fixture.debugElement.query(By.css('.apply'));<br/>    <br/>  spyOn(component, 'Apply');<br/>  // when<br/>  fixture.detectChanges();<br/>  btn.triggerEventHandler('click', null);</span><span id="902a" class="kz la in kv b gy lu lc l ld le">  //then<br/>  fixture.whenStable().then(() =&gt; {<br/>    expect(component.Apply).toHaveBeenCalled();<br/>  });<br/>}));</span></pre><p id="349a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是很难读懂。语法可能包含许多嵌套对象，这些对象监听一些新的变化:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="01cd" class="kz la in kv b gy lb lc l ld le">fixture.whenStable().then(() =&gt; {<br/>  expect(component.value).toEqual('0');</span><span id="3b3e" class="kz la in kv b gy lu lc l ld le">  dispatchEvent(select.nativeElement, 'change');<br/>  fixture.detectChanges();</span><span id="1c66" class="kz la in kv b gy lu lc l ld le">  fixture.whenStable().then(() =&gt; {<br/>    btn.triggerEventHandler('click', null);</span><span id="adb1" class="kz la in kv b gy lu lc l ld le">    fixture.detectChanges();<br/>    expect(component.value).toEqual('1');<br/>  })<br/>})</span></pre><p id="72f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> tick()方法——fixture . when stable()的替代方法</strong></p><p id="f5c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它提供了以同步方式工作的能力。原则上，单元测试源代码看起来是同步的。有时它对提高可读性很有用。tick()只能在<code class="fe lv lw lx kv b">fakeAsync </code>区域内使用。Tick()也可以不带参数使用，在这种情况下，它会一直等到所有的微任务都完成。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="5203" class="kz la in kv b gy lb lc l ld le">it(‘should’, fakeAsync(() =&gt; {<br/> spyOn(component, ‘MyComponent’);</span><span id="6d96" class="kz la in kv b gy lu lc l ld le"> let btn=fixture.debugElement.nativeElement.querySelector(‘button’);<br/> button.click();<br/> tick();<br/> expect(component.MyComponent).toHaveBeenCalled();<br/>}));</span></pre><p id="e11a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> fakeAsync — </strong>一切都是同步调用的，所以断言不可能不被调用。没有HTTP调用时使用。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="3752" class="kz la in kv b gy lb lc l ld le">it(‘should click on button’, fakeAsync(() =&gt; {<br/>  spyOn(component, ‘goToPrice’);</span><span id="bc6b" class="kz la in kv b gy lu lc l ld le">  const btn: HTMLInputElement =<br/>    element.querySelector(“button[label=’Price’] button”);<br/>  btn.click();<br/>  tick(500);</span><span id="a3d8" class="kz la in kv b gy lu lc l ld le">  expect(component.goToPrice).toHaveBeenCalled();</span><span id="4be7" class="kz la in kv b gy lu lc l ld le">  // sometimes such imitation also could be helpful, but looks awful<br/>  let flag = false;<br/>  setTimeout(() =&gt; {<br/>    flag = true;<br/>  }, 1000);<br/>  expect(flag).toBe(true);<br/>}));</span></pre><p id="d465" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> waitForAcync() </strong> —有HTTP调用时使用</p><p id="296d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lv lw lx kv b">async()</code>方法已被替换为<code class="fe lv lw lx kv b">waitForAsync()</code>中的角度10。不再需要手动调用方法done()。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="b116" class="kz la in kv b gy lb lc l ld le"><strong class="kv io"><em class="lt">it</em></strong>("Should apply changes when click on button", waitForAsync(() =&gt; {<br/>  fixture.detectChanges();<br/><br/>  spyOn(component, "applyChanges").and.stub();<br/>  const btn: HTMLElement = fixture.debugElement.nativeElement.querySelector(".button");</span><span id="1ba2" class="kz la in kv b gy lu lc l ld le">  btn.click();</span><span id="dc0c" class="kz la in kv b gy lu lc l ld le">  fixture.whenStable().then(() =&gt; {<br/>    <strong class="kv io"><em class="lt">expect</em></strong>(component.applyChanges).toHaveBeenCalledTimes(1);<br/>  });<br/>}));</span></pre><p id="9158" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> done()方法— </strong>不带参数调用表示代码完成。</p><p id="06cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在<code class="fe lv lw lx kv b">then </code>之后调用<code class="fe lv lw lx kv b">done() </code>来告知测试完成并且没有错误发生时。异步任务已完成，并将解析的数据传递给done。</p><p id="b874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原则上，最好不要使用done()方法。这种方法已经过时了。用<code class="fe lv lw lx kv b">fakeAsync() </code>代替，模拟一切都是同步的。</p><p id="bbe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用该方法的另一个有用的方法是:您已经发现了方法applyChanges并将其存根化。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="074f" class="kz la in kv b gy lb lc l ld le">it("should check when done", (done) =&gt; {<br/>  // given<br/>  // when<br/>  // then<br/>  myEventAction().then(() =&gt; {<br/>    expect(component.value).toBeTruthy();<br/>    done();<br/>  });<br/>});</span><span id="4e38" class="kz la in kv b gy lu lc l ld le">it('should render correctly, stupid sample simulation', (done) =&gt; {<br/>  component.calculate();<br/>  spyOn(component, "applyChanges").and.stub();</span><span id="fb86" class="kz la in kv b gy lu lc l ld le">  setTimeout(() =&gt; {<br/>    expect(component.applyChanges).toHaveBeenCalled();<br/>    done();<br/>  }, 1000);<br/>});</span></pre><p id="8c3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> spyOn() — </strong>用它来嘲弄方法。</p><p id="584d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在函数依赖于执行的情况下，比如调用HTTP请求，对函数使用<code class="fe lv lw lx kv b">spyOn</code>非常有用。我们可以绕过这些依赖项，测试要调用的方法。</p><p id="287b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lv lw lx kv b">spyOn </code>提供了一些选项来返回对被拦截的方法调用的响应。您可以使用stub抑制方法调用，使用<code class="fe lv lw lx kv b">returnValue</code>方法返回值，还可以使用callFake返回一个可观察值。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="ac38" class="kz la in kv b gy lb lc l ld le">it(“should set mock and returnValue”, fakeAsync(() =&gt; {<br/>  const response: Customers[] = [];<br/>  spyOn(userService, ‘getUsers’).and.returnValue(of(response))</span><span id="af42" class="kz la in kv b gy lu lc l ld le">  // when<br/>  homeComponent.getUsers();<br/>  tick();</span><span id="d787" class="kz la in kv b gy lu lc l ld le">  // then<br/>  expect(homeComponent.listOfUsers).toEqual(response);<br/>}));<br/></span><span id="5233" class="kz la in kv b gy lu lc l ld le">it('should call 3 variants of spyOn', () =&gt; {<br/>  // we mock the method and return the mock value<br/>  spyOn(component, "calculate").and.returnValue("999");<br/>  expect(component.calculate).toEqual("999");</span><span id="3e83" class="kz la in kv b gy lu lc l ld le">  // we define call the method and stubbed it<br/>  spyOn(component, "applyChanges").and.stub();<br/>  expect(component.applyChanges).toHaveBeenCalled()</span><span id="3a9d" class="kz la in kv b gy lu lc l ld le">  // mocked the service call using callFake to return an observable.<br/>  spyOn(service, 'setData').and.callFake( () =&gt;<br/>    service.isDataSet = true);</span><span id="725f" class="kz la in kv b gy lu lc l ld le">  expect(service.setData).toHaveBeenCalledWith(true);<br/>});</span></pre><p id="fb1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> mockImplementation() </strong> —从不调用原始函数。</p><p id="e769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原始函数从未被真正调用过。这意味着jest方面的行为似乎是正确的。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="67b8" class="kz la in kv b gy lb lc l ld le">it('should call for service to get list of persons', async(() =&gt; {<br/>  <!-- -->const mockResponse = "test";</span><span id="2975" class="kz la in kv b gy lu lc l ld le">  jest.spyOn(service, 'listPerson').mockImplementation(() =&gt;<br/>    Promise.resolve([<!-- -->mockResponse<!-- -->]);<br/>    console.log('mock function');<br/>  );<br/>  fixture.detectChanges();</span><span id="052d" class="kz la in kv b gy lu lc l ld le">  const result = service.listPerson();<br/>  expect(result).toEqual([<!-- -->mockResponse<!-- -->]);<br/>}));</span></pre><p id="fd7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者只是简单的计数来检查测试</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="10c4" class="kz la in kv b gy lb lc l ld le">it('should set real mock date', () =&gt; {<br/>  jest.spyOn(Date, 'now').mockImplementation(() =&gt; 1001);<br/>  expect(Date.now()).toBe(1001);<br/>});<br/>it('does not call the mocked function', () =&gt; {<br/>  let originalCount = 0;<br/>  let fakeCount = 0;<br/>  const obj = {fn: () =&gt; originalCallCount++};</span><span id="c0cc" class="kz la in kv b gy lu lc l ld le">  jest.spyOn(obj, 'fn').mockImplementation(() =&gt; fakeCount++);</span><span id="9aa5" class="kz la in kv b gy lu lc l ld le">  obj.fn();<br/>  expect(originalCount).toBe(0);<br/>  expect(fakeCount).toBe(1);<br/>});</span></pre><p id="2ab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">sonar cube—自动化单元测试</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/2d59357d8ee033ef217460045265345f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHgiB2Ya4m0CQtGx5vNz-w.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">每个项目的声纳统计样本</figcaption></figure><p id="cfa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> detectChanges()和SonarQube统计</strong></p><p id="54fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Sonar提供了一种有趣的方法来测试代码并计算测试覆盖了多少源代码的百分比。他使用正面和负面的场景来经历if/else条件。但问题是，如果我们用一个未定义的值调用某个对象，应用程序组件将无法初始化和正常工作。</p><p id="61e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此我们可以用正确的mySelected调用组件，然后调用<code class="fe lv lw lx kv b">detectChanges()</code>,之后用mySelected = undefined检查组合。它将涵盖所有可能的情况，声纳将感到满意。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="8f0c" class="kz la in kv b gy lb lc l ld le">it("check myTariff in hasMainPropertySelected for undefined", ()=&gt; {<br/>  // given<br/>  const tariffs : Tariffs = generateTariffs();<br/>  component.myTariffs = [tariffs, tariffs];</span><span id="22d5" class="kz la in kv b gy lu lc l ld le">  // when<br/>  fixture.detectChanges();<br/>  component.myTariffs = undefined;<br/>  const mySelected : boolean = component.hasMainPropertySelected();</span><span id="e2c3" class="kz la in kv b gy lu lc l ld le">  // then<br/>  expect(mySelected).toBeFalsy();<br/>  expect(mySelected).toEqual(undefined);<br/>  expect(component.myTariffs).toBeUndefined();<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/f7dab9ae9f9238e3a2ea74387c73d0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8thBWwyps4_mNjRNO_WOUQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">带有突出显示错误的常见SonarQube语法示例</figcaption></figure><p id="cb9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="5deb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我刚刚写了一些我的经验，因为在过去的几个月里做了这么多的测试。它几乎看起来像一个测试驱动的开发，产生如此多的单元测试，以至于覆盖了源代码的所有方法。此外，SonarQube允许我们查看哪一行代码没有被测试覆盖，以及已经通过的条件的数量。</p><p id="1948" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="me mf gp gr mg mh"><a href="https://codeburst.io/setup-sonarqube-for-angular-application-locally-in-three-easy-steps-8f31e339ac19" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">用三个简单的(！idspnonenote)在本地设置Sonarqube用于角度应用。？！)步骤</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">这是我在本地开发环境和it环境中为我们的Angular应用程序设置Sonarqube的个人经验…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">codeburst.io</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ks mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://jestjs.io/ru/docs/mock-function-api" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">mock-функции·杰斯特</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">模拟函数也被称为“间谍”，因为它们让您监视一个名为…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">jet js . io</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv ks mh"/></div></div></a></div></div></div>    
</body>
</html>