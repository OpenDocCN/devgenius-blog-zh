<html>
<head>
<title>Queues in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/queues-in-go-89b2cc9d7ff9?source=collection_archive---------3-----------------------#2022-06-06">https://blog.devgenius.io/queues-in-go-89b2cc9d7ff9?source=collection_archive---------3-----------------------#2022-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4b44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到<em class="ki">Go</em>中的数据结构介绍！在本帖中，我们将关注队列。我们在现实生活中经常听到“队列”这个词。买电影票的队伍很长。伙计，这场联赛排队排得太久了。对于我们大多数人来说，队列是一个熟悉的概念。</p><h1 id="a3b5" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">作为数据结构的队列</h1><p id="cbbf" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">队列是一个特殊的列表，就像堆栈一样。然而，与堆栈不同，队列是众所周知的 FIFO 数据结构。这意味着先进入的项目先出来。你可以想象一个公共汽车的队列，队列中的第一个人将首先上车，而其他人必须等到轮到他们的时候。队列是一个简单的列表，你只能在尾部(后面)插入，在头部(前面)弹出。</p><p id="b908" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以对队列执行的常见操作包括:</p><ul class=""><li id="532d" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated"><strong class="jm io">插入</strong>，又名<strong class="jm io">推动</strong>或<strong class="jm io">插入</strong></li><li id="472c" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm io">出清</strong>，又名<strong class="jm io">弹出</strong>或<strong class="jm io">删除</strong></li><li id="144e" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">前面</li><li id="8949" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">IsEmpty 或 IsFull</li></ul><h1 id="37cd" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">在 Go 中写入</h1><p id="2603" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们从定义类型开始。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fe75" class="mj kk in mf b gy mk ml l mm mn">type Queue struct {<br/>    items []int<br/>}</span></pre><p id="3276" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单，我们需要做的就是定义某个数据类型的切片。</p><p id="9bd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在介绍两个最重要的方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="580d" class="mj kk in mf b gy mk ml l mm mn">func (q *Queue) Enqueue(data int) {<br/>    q.items = append(q.items, data)<br/>}</span><span id="e51e" class="mj kk in mf b gy mo ml l mm mn">func (q *Queue) Dequeue() {<br/>    q.items = q.items[1:]<br/>}</span></pre><p id="08af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些也很简单。通过使用<code class="fe mp mq mr mf b">append</code>，我们正在向<code class="fe mp mq mr mf b">q.items</code>的尾端插入新元素。当出列时，我们只是从第一个元素到最后一个元素取一部分<code class="fe mp mq mr mf b">q.items</code>。请记住，我们在编程中从 0 开始计数，因此第 0 个元素是列表中的第一个元素。</p><p id="517d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一些有用的帮助方法，会让我们的生活更轻松。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1f43" class="mj kk in mf b gy mk ml l mm mn">func (q *Queue) Front() (int, error) {<br/>    if len(q.items) == 0 {<br/>        return 0, fmt.Errorf("queue is empty")<br/>    }</span><span id="498a" class="mj kk in mf b gy mo ml l mm mn">    return q.items[0], nil<br/>}</span><span id="8838" class="mj kk in mf b gy mo ml l mm mn">func (q *Queue) IsEmpty() bool {<br/>    if len(q.items) == 0 {<br/>        return true<br/>    } else {<br/>        return false<br/>    }<br/>}</span><span id="7858" class="mj kk in mf b gy mo ml l mm mn">func (q *Queue) Print() {<br/>    for _, item := range q.items {<br/>        fmt.Print(item, " ")<br/>    }<br/>    fmt.Println()<br/>}</span></pre><p id="2acb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果队列为空，将返回一个错误，否则将返回列表中的第 0 个元素。</p><p id="8bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">IsEmpty</code>检查我们的队列长度是否为 0，如果是，返回<code class="fe mp mq mr mf b">true</code>。</p><p id="140d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">Print</code>遍历我们的项目并打印每一项。</p><p id="d07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们试试用吧！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2d49" class="mj kk in mf b gy mk ml l mm mn">func main() {<br/>    myQueue := Queue{[]int{}}<br/>    myQueue.Print()<br/>    fmt.Println(myQueue.IsEmpty())</span><span id="6fa9" class="mj kk in mf b gy mo ml l mm mn">    myQueue.Enqueue(1)<br/>    myQueue.Enqueue(2)<br/>    myQueue.Enqueue(3)</span><span id="b715" class="mj kk in mf b gy mo ml l mm mn">    myQueue.Print()<br/>    myQueue.Dequeue()<br/>    myQueue.Print()<br/>}</span><span id="6684" class="mj kk in mf b gy mo ml l mm mn">Output:</span><span id="c80f" class="mj kk in mf b gy mo ml l mm mn">true<br/>1 2 3<br/>2 3</span></pre><h1 id="94be" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">优先级队列</h1><p id="437b" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这很简单。既然我们已经了解了普通队列是如何工作的，我们就可以讨论优先级队列了。优先级队列是特殊类型的队列，每个项目分配有不同的优先级。想象你在一个机场，等待你的航班。空服员通知人们他们马上就要开始了。你匆忙收拾好行李，排在队伍的第一位。你先登机吗？通常不会。他们会先让老兵和老人进去，然后是头等舱的乘客。你在他们之后登机。</p><p id="0339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">优先级队列的工作方式略有不同。从优先级队列中出列时，优先级最高的项目将首先出列。当你调用<code class="fe mp mq mr mf b">Front</code>时，你会得到一个优先级最高的物品。</p><p id="d95e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何在 Go 中写这个。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="615d" class="mj kk in mf b gy mk ml l mm mn">type Item struct {<br/>    data     int<br/>    priority int<br/>}</span><span id="4b1b" class="mj kk in mf b gy mo ml l mm mn">type PriorityQueue struct {<br/>    items []Item<br/>}</span></pre><p id="8b41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们如何定义优先级队列和其中的项目。一个条目包含两条信息:实际存储的数据和它的优先级。优先级队列存储一片<code class="fe mp mq mr mf b">Item</code>对象。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="912d" class="mj kk in mf b gy mk ml l mm mn">func (pq *PriorityQueue) Sort() {<br/>    sort.Slice(pq.items, func(i, j int) bool {<br/>        return pq.items[i].priority &lt; pq.items[j].priority<br/>    })<br/>}</span></pre><p id="9860" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">Sort</code>大概是我们优先级排队最重要的方法。顾名思义，<code class="fe mp mq mr mf b">Sort</code>按照优先级从高到低的顺序对优先级队列中的项目进行排序。优先级用一个<code class="fe mp mq mr mf b">int</code>值表示，值越小意味着优先级越高。第一，第二，第三。</p><p id="5bf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">Sort</code>使用 Go 内置的<code class="fe mp mq mr mf b">sort</code>包。<code class="fe mp mq mr mf b">sort.Slice</code>接受任意类型的切片和确定如何排列项目的任意函数。在这种情况下，我们将比较第 I 项和第 j 项的优先级。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9ae9" class="mj kk in mf b gy mk ml l mm mn">func (pq *PriorityQueue) Enqueue(data Item) {<br/>    pq.items = append(pq.items, data)<br/>    pq.Sort()<br/>}</span><span id="325e" class="mj kk in mf b gy mo ml l mm mn">func (pq *PriorityQueue) Dequeue() {<br/>    pq.Sort()<br/>    pq.items = pq.items[1:]<br/>}</span><span id="10a2" class="mj kk in mf b gy mo ml l mm mn">func (pq *PriorityQueue) Front() (Item, error) {<br/>    if len(pq.items) == 0 {<br/>        return Item{}, fmt.Errorf("queue is empty")<br/>    }</span><span id="7cac" class="mj kk in mf b gy mo ml l mm mn">    pq.Sort()<br/>    return pq.items[0], nil<br/>}</span></pre><p id="96c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">Enqueue</code>、<code class="fe mp mq mr mf b">Dequeue</code>和<code class="fe mp mq mr mf b">Front</code>基本保持不变，除了它们都调用<code class="fe mp mq mr mf b">Sort</code>这个事实。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3d17" class="mj kk in mf b gy mk ml l mm mn">func (pq *PriorityQueue) IsEmpty() bool {<br/>    if len(pq.items) == 0 {<br/>        return true<br/>    } else {<br/>        return false<br/>    }<br/>}</span><span id="dc24" class="mj kk in mf b gy mo ml l mm mn">func (pq *PriorityQueue) Print() {<br/>    for _, item := range pq.items {<br/>        fmt.Print(item, " ")<br/>    }<br/>    fmt.Println()<br/>}</span></pre><p id="ec42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr mf b">IsEmpty</code>和<code class="fe mp mq mr mf b">Print</code>保持不变。</p><p id="baf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们试试用吧！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="96f2" class="mj kk in mf b gy mk ml l mm mn">func main() {<br/>    myQueue := PriorityQueue{[]Item{}}<br/>    myQueue.Print()<br/>    fmt.Println(myQueue.IsEmpty())</span><span id="8167" class="mj kk in mf b gy mo ml l mm mn">    myQueue.Enqueue(Item{0, 1})<br/>    myQueue.Enqueue(Item{1, 4})<br/>    myQueue.Enqueue(Item{2, 3})<br/>    myQueue.Enqueue(Item{3, 0})<br/>    myQueue.Enqueue(Item{4, 2})</span><span id="0680" class="mj kk in mf b gy mo ml l mm mn">    myQueue.Print()<br/>    myQueue.Dequeue()<br/>    myQueue.Print()<br/>}</span><span id="e055" class="mj kk in mf b gy mo ml l mm mn">Output:</span><span id="ad4c" class="mj kk in mf b gy mo ml l mm mn">true<br/>{3 0} {0 1} {4 2} {2 3} {1 4} <br/>{0 1} {4 2} {2 3} {1 4}</span></pre><p id="cb0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意我们是如何按照从 0 到 4 的升序添加项目的，但是之后会按照优先级排序。</p><h1 id="74a4" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="7737" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">感谢您的阅读！这是对队列和优先级队列的简单介绍。如果你想了解更高级的概念，网上有更多的资源。希望你在这个过程中学到了一些东西！</p><p id="334f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae ms" href="https://dev.to/jpoly1219/queues-in-go-22i9" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae ms" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank"> my personal site </a>上阅读这篇文章。</p></div></div>    
</body>
</html>