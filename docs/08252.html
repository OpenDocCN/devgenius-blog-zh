<html>
<head>
<title>Making Sense of Compose Magic (Deep Dive)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解作曲魔术(深入探讨)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/making-sense-of-compose-magic-deep-dive-b03873910a67?source=collection_archive---------5-----------------------#2022-05-30">https://blog.devgenius.io/making-sense-of-compose-magic-deep-dive-b03873910a67?source=collection_archive---------5-----------------------#2022-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9a67b6bce4572ff8fb136294583c5b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tltvwP_2cNtFrInuIiPKhQ.png"/></div></div></figure><p id="7e71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您更改一个状态值，compose 如何自动更新 UI 几乎是不可思议的，但是它是如何做到的呢？让我们找出答案。</p><h1 id="408e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">想法</h1><p id="c293" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在 jetpack compose 中，如果你想让一些值存活下来<a class="ae lw" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">重组</strong> </a>你就把它传入，记住在<code class="fe lx ly lz ma b">mutableStateOf()</code>中换行</p><p id="e704" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">ex — val enabled = remember{ mutableStateOf(false)}</code>但是它是如何工作的呢？</p><p id="9656" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mb">让我们深潜</em> </strong></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="dc7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，<code class="fe lx ly lz ma b">mutableStateOf()</code>定义了两个参数，第一个是<code class="fe lx ly lz ma b">value:T</code>，它是它所保存的对象，第二个是<code class="fe lx ly lz ma b">policy:SnapShotMutationPolicy </code>，我们通常不关心它，因为它有一个默认值，但我们一会儿会深入讨论它。</p><p id="aa3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">合成运行时跟踪当前合成中的<code class="fe lx ly lz ma b"><strong class="jx io">MutableState</strong></code> <strong class="jx io"> </strong>对象，这意味着如果您更改由<code class="fe lx ly lz ma b"><strong class="jx io">MutableState</strong></code>保存的值，合成运行时将注意到该更改，并调度一个<a class="ae lw" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">重组</strong> </a>，这是第二个参数<code class="fe lx ly lz ma b">policy</code>出现的地方，合成使用它来检查值是否更改。</p><p id="1c8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mb">让我们深潜</em> </strong></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b06f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见<code class="fe lx ly lz ma b">stucuralEqualityPolicy()</code>返回<code class="fe lx ly lz ma b">SnapshotMutationPolicy&lt;T&gt;</code>它有一个<code class="fe lx ly lz ma b">equivalent()</code>方法，该方法接收值<code class="fe lx ly lz ma b">a</code>和<code class="fe lx ly lz ma b">b</code>，其中一个是我们正在设置的新值，另一个是由<code class="fe lx ly lz ma b">MutableState&lt;T&gt;</code>保存的旧值，这些值有望由 Compose 运行时提供。</p><p id="f41e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">equivalent()</code>仅检查<code class="fe lx ly lz ma b">a == b</code>是否<code class="fe lx ly lz ma b">true</code>编写将调度重组，否则不调度。这也意味着你的<strong class="jx io">数据类型</strong>的<code class="fe lx ly lz ma b">equals()</code>方法应该是一致的(<em class="mb">如果你使用数据类，这不是一个问题，虽然</em>)如果出于某种原因，你没有使用<strong class="jx io">数据类</strong>，你可以通过实现那个接口覆盖 equals 或者提供你自己的<code class="fe lx ly lz ma b">SanpShotMutationPolicy</code>。</p><p id="0439" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是关于重组，但只有重组不起作用，改变<code class="fe lx ly lz ma b">State&lt;T&gt;</code>对象导致重组，但没有提供新值，我们的<code class="fe lx ly lz ma b">State&lt;T&gt;</code>将再次初始化为旧值，就像什么都没发生一样。</p><h1 id="6833" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们记住一些事情</h1><p id="4f09" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">原来<strong class="jx io">组件</strong>可以有自己的内存，所以在重新编译时，它们可以选择保存在内存中的旧值并使用它。</p><p id="0120" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要让 compose 跟踪您的值并保存在<strong class="jx io"> composables </strong>内存中，您需要使用<code class="fe lx ly lz ma b">State&lt;T&gt;</code>和<code class="fe lx ly lz ma b">remember{}</code>。</p><p id="1042" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">ex — val enabled = remember{ mutableStateOf(false)}</code></p><p id="69cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mb">让我们深潜</em> </strong></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="64f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">remember()</code>将计算作为 lambda，然后使用<code class="fe lx ly lz ma b">currentComposer</code>引用 Composer 的实例。这个接口是 Compose Kotlin 编译器插件的目标，由代码生成助手使用。您不应该直接调用它，因为运行库假定调用是由编译器生成的，因此不包含太多的验证逻辑。<code class="fe lx ly lz ma b">cache()</code>是 Composer 的扩展功能。它在组合的组合数据中存储一个值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8712" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然这就是记忆值的来源，<code class="fe lx ly lz ma b">rememberedValue()</code>函数返回一个保存在 composable 上的缓存中的值，这里它们主要检查我们是否已经有了那个值，如果没有，那么只进行计算，值得到更新，否则返回旧值。</p><p id="ecae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">更多好奇</strong></p><p id="8c05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想多深潜？阅读以下文章</p><div class="mi mj gp gr mk ml"><a href="https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">了解 Jetpack 撰写—第 1 部分，共 2 部分</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">使用 Compose 构建更好的 UI</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jt ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">在 Jetpack Compose 的引擎盖下—第 2 部分，共 2 部分</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">在作曲的引擎盖下</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="na l mw mx my mu mz jt ml"/></div></div></a></div><p id="4de0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">谢谢</strong></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>