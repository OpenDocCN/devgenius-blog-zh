<html>
<head>
<title>Make &amp; Makefiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作和制作文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-makefiles-e17015cf5b56?source=collection_archive---------6-----------------------#2022-04-02">https://blog.devgenius.io/make-makefiles-e17015cf5b56?source=collection_archive---------6-----------------------#2022-04-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f2c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如维基百科所说，<strong class="jm io"> Make </strong>是一个<a class="ae ki" href="https://en.wikipedia.org/wiki/Build_automation" rel="noopener ugc nofollow" target="_blank">构建自动化</a>工具，它通过读取指定如何派生目标程序的<a class="ae ki" href="https://en.wikipedia.org/wiki/File_(computing)" rel="noopener ugc nofollow" target="_blank">文件</a>称为<em class="kj"> Makefiles </em>，自动<a class="ae ki" href="https://en.wikipedia.org/wiki/Software_build" rel="noopener ugc nofollow" target="_blank">从<a class="ae ki" href="https://en.wikipedia.org/wiki/Source_code" rel="noopener ugc nofollow" target="_blank">源代码</a>构建</a>和<a class="ae ki" href="https://en.wikipedia.org/wiki/Library_(software)" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="556b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为什么需要构建系统？</strong></p><ul class=""><li id="bcd4" class="kk kl in jm b jn jo jr js jv km jz kn kd ko kh kp kq kr ks bi translated">简化管理大量程序文件的过程</li><li id="db66" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">仅编译已更改的文件(节省时间和资源)</li><li id="750a" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">自动链接和编译文件</li></ul><blockquote class="ky kz la"><p id="05f5" class="jk jl kj jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">我将考虑一个基于 C/C++的项目，同样的想法适用于所有语言</p></blockquote><p id="324c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上下文中，考虑一个非常大的项目，包含许多文件，每个文件又依赖于许多其他文件。一个显而易见的方法是开发代码的模块化结构，这样，单独的组件被放置在单独的文件中，然而，这些文件需要协调工作。在非 makefile 方法中，每次构建可执行文件都需要编译。c/。c++文件给对象文件并链接所有这些。这是一个非常痛苦的过程，并且可以自动化和简化。这是构建可执行文件的明智之举。</p><blockquote class="ky kz la"><p id="708a" class="jk jl kj jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">用 c++创建可执行文件的步骤</p></blockquote><ol class=""><li id="704e" class="kk kl in jm b jn jo jr js jv km jz kn kd ko kh le kq kr ks bi translated">预处理:#include 和#define 被解析。这意味着头文件的内容放在文件中，而#define 引用的值按原样放在代码中。</li><li id="9034" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh le kq kr ks bi translated">编译器:将 cpp 文件转换成汇编代码。</li><li id="697b" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh le kq kr ks bi translated">汇编程序:下一步是从汇编代码中创建目标代码</li><li id="f5e9" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh le kq kr ks bi translated">链接:链接目标文件以创建可执行文件</li></ol><p id="cd8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 C++中，目标文件是通过以下方式创建的:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e9c5" class="lo lp in lk b gy lq lr l ls lt">gcc -c name-of-file.cpp</span></pre><p id="4766" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">各种目标文件可以如下链接以创建可执行文件，这里 final-exec 是最终的可执行文件</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6eeb" class="lo lp in lk b gy lq lr l ls lt">gcc obj-file1.o obj-file2.o -o finalexecutable</span></pre><blockquote class="ky kz la"><p id="bbe9" class="jk jl kj jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">生成文件</p></blockquote><p id="d58b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Makefile 以下列格式编写:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="27b9" class="lo lp in lk b gy lq lr l ls lt">target: dependencies<br/>     action #needs to be preceeded by a tab NOT spaces</span></pre><p id="70be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标表示正在构建什么，依赖项表示目标依赖于依赖项，而操作指的是为了从依赖项中获得目标必须做什么</p><blockquote class="ky kz la"><p id="8472" class="jk jl kj jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">Makefile 示例</p></blockquote><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="42da" class="lo lp in lk b gy lq lr l ls lt"># -*- MakeFile -*- (for comments)</span><span id="0810" class="lo lp in lk b gy lu lr l ls lt"># target: dependecies</span><span id="2a17" class="lo lp in lk b gy lu lr l ls lt">#   action (after a tab only)</span><span id="646d" class="lo lp in lk b gy lu lr l ls lt"># final executable created (only has a target and dependencies)</span><span id="f63a" class="lo lp in lk b gy lu lr l ls lt">all: finalexec</span><span id="3872" class="lo lp in lk b gy lu lr l ls lt"># final exec depends on the object files file1.o an file2.o</span><span id="efe7" class="lo lp in lk b gy lu lr l ls lt">finalexec: file1.o file2.o</span><span id="1449" class="lo lp in lk b gy lu lr l ls lt"># action needed to create finalexec</span><span id="fae8" class="lo lp in lk b gy lu lr l ls lt">g++ file1.o file2.o -o finalexec<br/></span><span id="c614" class="lo lp in lk b gy lu lr l ls lt"># object file of file1 depends on file1.c++</span><span id="a48b" class="lo lp in lk b gy lu lr l ls lt">file1.o: file1.c++</span><span id="b03f" class="lo lp in lk b gy lu lr l ls lt">g++ -c file1.c++</span><span id="3827" class="lo lp in lk b gy lu lr l ls lt"># object file of file2 depends on file2.c++</span><span id="6fcc" class="lo lp in lk b gy lu lr l ls lt">file2.o: file2.c++</span><span id="ad19" class="lo lp in lk b gy lu lr l ls lt">g++ -c file2.c++<br/></span><span id="b876" class="lo lp in lk b gy lu lr l ls lt"># removes the object files, can be run as make clean</span><span id="1fa8" class="lo lp in lk b gy lu lr l ls lt">clean:</span><span id="af8f" class="lo lp in lk b gy lu lr l ls lt">rm -rf *.o</span></pre><p id="cfc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里创建了一个依赖图，要执行的第一条指令不依赖于任何其他文件，例如:这里指令 file1.o 和 file2.o 是目标，可以首先执行，因为它们没有任何依赖关系。</p><figure class="lf lg lh li gt lw gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/b780c0408591def8807d7903220989f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*eMDMaOd-TCQNVzvEnmiupA.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">不同目标的依赖关系图</figcaption></figure><p id="cfbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某种意义上，指令在 Makefile 中的执行顺序可以由依赖关系和目标的<strong class="jm io">拓扑排序</strong>(如维基百科所定义的，在计算机科学中，有向图的拓扑排序或拓扑排序是其顶点的<strong class="jm io">线性排序，使得对于从顶点 u 到顶点 v 的每个有向边 uv，在排序中 u 在 v 之前)来确定，额外考虑的是，只有对于文件中有变化的指令，才会重新编译其直接和间接连接。在依赖树中，考虑到可执行文件处于最高级别，时间戳的概念用于决定哪个分支应该重新编译，哪个不应该。</strong></p><p id="0856" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住:依赖图中较低层次的文件在较高层次之前编译(可执行文件是最后创建的)。如果一个文件的编译或最后一次创建时间晚于它上面的一个文件，那么这意味着该文件已经被改变，因此该分支将需要重新编译。</p><p id="944e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间戳被称为<strong class="jm io">系统时间。</strong> <br/>维基百科说:例如，<a class="ae ki" href="https://en.wikipedia.org/wiki/Unix" rel="noopener ugc nofollow" target="_blank"> Unix </a>和<a class="ae ki" href="https://en.wikipedia.org/wiki/POSIX" rel="noopener ugc nofollow" target="_blank"> POSIX </a>兼容的系统将系统时间(<a class="ae ki" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank">Unix time</a>)<strong class="jm io">编码为自</strong><a class="ae ki" href="https://en.wikipedia.org/wiki/Unix_epoch" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Unix epoch</strong></a><strong class="jm io">1970 年 1 月 1 日 00:00:00</strong><a class="ae ki" href="https://en.wikipedia.org/wiki/Universal_Time" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">UT</strong></a><strong class="jm io">开始所经过的秒数</strong></p><figure class="lf lg lh li gt lw gh gi paragraph-image"><div class="gh gi md"><img src="../Images/3926754deb13f00ca98f01fc98e3139c.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*mgVNJVPuV4stAYCpUwt9Bw.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">运行“make”命令时执行指令的顺序</figcaption></figure><p id="77d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是可能存在循环依赖性，其中目标文件 f1 具有对文件 f2 的依赖性，而目标文件 f2 具有对文件 f1 的依赖性(不确定这是如何解决的，可能引发了警报)</p><p id="d457" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考资料</strong><br/>-<a class="ae ki" href="https://www.youtube.com/watch?v=DtGrdB8wQ_8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=DtGrdB8wQ_8</a>-<a class="ae ki" href="https://www.youtube.com/watch?v=GExnnTaBELk&amp;t=1s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=GExnnTaBELk&amp;t = 1s</a><br/>-<a class="ae ki" href="https://www.youtube.com/watch?v=upX8WjCITXg&amp;list=PLalVdRk2RC6rektqao7a6_mMQJAZPbERk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=upX8WjCITXg&amp;list = plalvdrk 2 RC 6 rektqao 7 a 6 _ mMQJAZPbERk</a></p><p id="cb3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上都是超级有用的参考！<br/> -</p></div></div>    
</body>
</html>