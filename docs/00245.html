<html>
<head>
<title>Interface Segregation Principle | SOLID as a Rock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">界面分离原理|坚如磐石</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/interface-segregation-principle-solid-as-a-rock-da0dde41f9a9?source=collection_archive---------12-----------------------#2020-05-26">https://blog.devgenius.io/interface-segregation-principle-solid-as-a-rock-da0dde41f9a9?source=collection_archive---------12-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/f82ac9a3f5603a0e5f1d8c2038d62b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*xfbBGJasSJH0MU1iOK8Giw.jpeg"/></div></figure><p id="9d30" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">I</strong>interface<strong class="jt io">S</strong>egradiation<strong class="jt io">P</strong>principle 在 C++中是第四个&amp;迄今为止最简单的一系列坚如磐石的设计原则。坚实的设计原则集中于开发易于维护、可重用和可扩展的软件。在本文中，我们将看到一个违反 ISP 的代码，一个相同代码的解决方案，指南&amp;ISP 的好处。</p><blockquote class="kp kq kr"><p id="c891" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kw" href="http://www.vishalchovatiya.com/category/design-patterns/" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">。</em></p></blockquote><p id="8943" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句，如果你还没有浏览过我以前关于设计原则的文章，下面是快速链接:</p><ol class=""><li id="d144" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> S </strong> RP —单一责任原则</a></li><li id="edb4" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> O </strong> CP —开启/关闭原理</a></li><li id="638e" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">T23】LSP—利斯科夫替代原理</a></li><li id="9820" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/interface-segregation-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> I </strong> SP —界面偏析原理</a></li><li id="583c" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> D </strong> IP —依赖反转原理</a></li></ol><p id="98c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ll lm ln lo b">override</code>、<code class="fe ll lm ln lo b">final</code>、<code class="fe ll lm ln lo b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大多数时候)在单一标准屏幕尺寸。我也更喜欢<code class="fe ll lm ln lo b">struct</code>而不是<code class="fe ll lm ln lo b">class</code>，只是为了节省代码行，有时不写<code class="fe ll lm ln lo b">public:</code>，也故意忽略<a class="ae kw" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae kw" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ll lm ln lo b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="293d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="ks">注:</em> </strong></p><ul class=""><li id="2f0b" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae kw" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>第一，哪怕是微不足道的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="192b" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">您在这一系列文章中遇到的所有代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 的现代 C++特性)。因此，如果你没有最新的编译器，你可以使用已经预装了 boost 库的 https://wandbox.org/。</li></ul><h1 id="5b58" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目的</h1><blockquote class="kp kq kr"><p id="b2cd" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">不应该强迫客户依赖他们不使用的接口。</p></blockquote><ul class=""><li id="ebb5" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">界面分离原则与单一责任原则密切相关。它真正的意思是，您应该总是以这样一种方式设计您的抽象，即使用公开方法的客户不必得到整个饼。把实现他们实际上不需要的方法的负担强加给客户。</li></ul><h1 id="ccf2" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">违反界面分离原则</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="66cd" class="mw lr in lo b gy mx my l mz na">struct Document;</span><span id="6c58" class="mw lr in lo b gy nb my l mz na">struct IMachine {<br/>    virtual void print(Document &amp;doc) = 0;<br/>    virtual void fax(Document &amp;doc) = 0;<br/>    virtual void scan(Document &amp;doc) = 0;<br/>};</span><span id="50be" class="mw lr in lo b gy nb my l mz na">struct MultiFunctionPrinter : IMachine {      // OK<br/>    void print(Document &amp;doc) override { }<br/>    void fax(Document &amp;doc) override { }<br/>    void scan(Document &amp;doc) override { }<br/>};</span><span id="231c" class="mw lr in lo b gy nb my l mz na">struct Scanner : IMachine {                   // Not OK<br/>    void print(Document &amp;doc) override { /* Blank */ }<br/>    void fax(Document &amp;doc) override { /* Blank */ }<br/>    void scan(Document &amp;doc) override {  <br/>        // Do scanning ...<br/>    }<br/>};</span></pre><ul class=""><li id="f929" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如你所见，就<code class="fe ll lm ln lo b">MultiFunctionPrinter</code>而言，实现由<code class="fe ll lm ln lo b">IMachine</code>接口执行的<code class="fe ll lm ln lo b">print()</code>、<code class="fe ll lm ln lo b">fax()</code> &amp; <code class="fe ll lm ln lo b">scan()</code>方法是可以的。</li><li id="c7ed" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">但是如果你只需要一个<code class="fe ll lm ln lo b">Scanner</code>或者<code class="fe ll lm ln lo b">Printer</code>，一些开发者仍然继承了<code class="fe ll lm ln lo b">IMachine</code> &amp;将不必要的方法留空或者抛出<code class="fe ll lm ln lo b">NotImplemented</code>异常，无论哪种方式，你都做错了。</li></ul><h1 id="cae5" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">界面分离原理示例</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="3b32" class="mw lr in lo b gy mx my l mz na">/* -------------------------------- Interfaces ----------------------------- */<br/>struct IPrinter {<br/>    virtual void print(Document &amp;doc) = 0;<br/>};</span><span id="7801" class="mw lr in lo b gy nb my l mz na">struct IScanner {<br/>    virtual void scan(Document &amp;doc) = 0;<br/>};<br/>/* ------------------------------------------------------------------------ */</span><span id="5754" class="mw lr in lo b gy nb my l mz na">struct Printer : IPrinter {<br/>    void print(Document &amp;doc) override;<br/>};</span><span id="6f99" class="mw lr in lo b gy nb my l mz na">struct Scanner : IScanner {<br/>    void scan(Document &amp;doc) override;<br/>};</span><span id="efa9" class="mw lr in lo b gy nb my l mz na">struct IMachine : IPrinter, IScanner { };</span><span id="1fb3" class="mw lr in lo b gy nb my l mz na">struct Machine : IMachine {<br/>    IPrinter&amp;   m_printer;<br/>    IScanner&amp;   m_scanner;</span><span id="4425" class="mw lr in lo b gy nb my l mz na">    Machine(IPrinter &amp;p, IScanner &amp;s) : printer{p}, scanner{s} { }</span><span id="d2f7" class="mw lr in lo b gy nb my l mz na">    void print(Document &amp;doc) override { printer.print(doc); }<br/>    void scan(Document &amp;doc) override { scanner.scan(doc); }<br/>};</span></pre><ul class=""><li id="fa6d" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">这使得客户可以灵活地组合他们认为合适的抽象，并在没有不必要的负担的情况下提供实现。</li><li id="1be9" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">如<a class="ae kw" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">中所解释的单一责任原则</a>。你应该避免具有多重职责的类&amp;接口。因为它们经常变化，使你的软件难以维护。你应该试着<strong class="jt io"> <em class="ks">基于角色</em> </strong>将接口拆分成多个接口。</li></ul><h1 id="aed3" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">利益</h1><h1 id="7b6d" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;更快的编译</h1><ul class=""><li id="5292" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">如果你违反了 ISP 即在接口中把方法塞在一起，当方法签名改变时，你需要重新编译所有的派生类。这对于一些编译语言来说是一个重要的方面，比如 C++ ，它以<a class="ae kw" href="https://stackoverflow.com/questions/318398/why-does-c-compilation-take-so-long" rel="noopener ugc nofollow" target="_blank">缓慢的编译</a>而闻名。而另一种方式是自我解释。</li></ul><h1 id="7434" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可重用性</h1><ul class=""><li id="e022" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank"> Martin </a>还提到<strong class="jt io"> <em class="ks">“胖接口”——带有额外无用方法</em> </strong>的接口——会导致类之间的无意耦合。因此，有经验的开发人员知道耦合是可重用性的祸根。</li></ul><h1 id="a906" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可维护性</h1><ul class=""><li id="f374" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">ISP 更普遍的好处是，通过避免不必要的依赖，系统变得更容易理解；测试更轻；&amp;更换更快。</li><li id="edef" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">类似地，对于你的代码的读者来说，从类声明行中了解你的类是做什么的会更加困难。因此，如果 dev 只看到一个继承了其他接口的 god 接口，这可能并不明显。比较</li></ul><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="53d5" class="mw lr in lo b gy mx my l mz na">MyMachine : IMachine</span></pre><p id="b5e5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">到</p><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="1bcf" class="mw lr in lo b gy mx my l mz na">MyMachine : IPrinter, IScanner, IFaxer</span></pre><ul class=""><li id="46c7" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">后者告诉你很多，前者最多让你猜测。</li></ul><h1 id="833a" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">尺度对工艺界面分离原理友好的软件</h1><ul class=""><li id="5a7e" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">当你开始通过识别参与你的领域的主要角色来分解你的问题空间时，这个原则就自然而然地出现了。因此，它从来都不是一个机械动作。</li><li id="a8e4" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">问自己一个问题可能有助于你修正设计:</li></ul><blockquote class="kp kq kr"><p id="4c3a" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">我需要我正在使用的这个接口上的所有方法吗？</p></blockquote><h1 id="3172" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结束语</h1><p id="47c3" class="pw-post-body-paragraph jr js in jt b ju nc jw jx jy nd ka kb kc nh ke kf kg ni ki kj kk nj km kn ko ig bi translated">尽管大接口是一个潜在的问题，ISP 并不关心接口的大小。相反，它是关于类是否使用它们所依赖的接口的方法。所以 ISP 在设计软件的时候是很差的指导，但却是它是否健康的绝佳指标。</p><p id="5598" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe ll lm ln lo b"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>