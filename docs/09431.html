<html>
<head>
<title>Python Fundamentals — Memory Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 基础—内存池</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-fundamentals-memory-pool-839014e92b38?source=collection_archive---------6-----------------------#2022-08-20">https://blog.devgenius.io/python-fundamentals-memory-pool-839014e92b38?source=collection_archive---------6-----------------------#2022-08-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="d697" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Python 内存池简介</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/0e1cf5def74b8c5713e85b9399a8c4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e50O1w5g8OAOnt045adogg.png"/></div></div></figure><p id="1241" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">由于 Python 中的一切都是对象，所以 Python 的存储问题就是对象的存储问题。事实上，对于每个对象，Python 都会分配一块内存来存储它。</p><p id="d7c8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么 python 是如何分配内存、管理内存、释放内存的呢？</p><p id="a727" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">概括起来有几个方面:引用计数，垃圾收集，内存池机制。在我以前的文章中，我已经谈到了<a class="ae lo" href="https://medium.com/geekculture/python-reference-e6458a9a0582" rel="noopener"> Python 引用和垃圾收集</a>，在这篇文章中，让我们探索一下“内存池”。</p><h1 id="cd44" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">Python 内存池</h1><p id="8f28" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">在 Python 中，很多时候请求的内存是一小块内存。这些小块内存应用后，很快就会被释放。</p><p id="03d0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在创建大量消耗小内存的对象时，频繁调用<code class="fe mm mn mo mp b">new/malloc</code>会造成大量内存碎片，导致效率降低。</p><p id="1733" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在实际应用中，我们确实在做这样的事情，尤其是小整数的使用，比如<code class="fe mm mn mo mp b">1</code>、<code class="fe mm mn mo mp b">2</code>、<code class="fe mm mn mo mp b"> 5</code>，这些<code class="fe mm mn mo mp b">int</code>类型的数据，几乎每次使用 for 循环的时候都会用到。所以下面的情景经常发生:</p><ol class=""><li id="02fd" class="mq mr ir ku b kv kw ky kz lb ms lf mt lj mu ln mv mw mx my bi translated">小整数使用频繁，销毁频繁</li><li id="3e32" class="mq mr ir ku b kv mz ky na lb nb lf nc lj nd ln mv mw mx my bi translated">频繁地创建对象和销毁对象会导致内存碎片</li></ol><p id="a247" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">内存池的概念是预先在内存中申请一定数量的大小相等的内存块，留作备用</strong>。当有新的内存需求时，它会先从内存池中分配内存给这个需求，内存不够时再申请新的。</p><p id="93c7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这样做最显著的好处就是可以减少内存碎片，提高效率。</p><h1 id="160b" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">小整数对象</h1><p id="d03e" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">如果没有特殊的机制，小整数的频繁创建和销毁会影响系统的性能。</p><p id="a34e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以 Python 提供了<strong class="ku is">对象池技术</strong>。<code class="fe mm mn mo mp b">int</code>类型数据是不可变的对象，这意味着它可以被共享。Python 启动后，会在内存中申请一块内存，在这里存放常用的小整数。</p><p id="2830" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在整个程序运行期间，这些小整数总是存在的，不会被破坏，它们的使用只会增加它们的引用计数。</p><p id="80fb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你可能会问，缓存了多少个整数？这个范围很小，[-5，257]。你可能不同意小整数的范围。但是每个人对常用的小整数都有自己的理解，所以，如果你希望扩大这个范围，你可以修改 python 源代码并重新编译，但是这非常费力。</p><p id="2efa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以验证这个小整数缓冲池确实存在于 python 交互式解释器中</p><pre class="kh ki kj kk gu ne mp nf ng aw nh bi"><span id="3793" class="ni lq ir mp b gz nj nk l nl nm">&gt;&gt;&gt; a = 256 <br/>&gt;&gt;&gt; b = 256 <br/>&gt;&gt;&gt; id(a) <br/>4511188896 <br/>&gt;&gt;&gt; id(b) <br/>4511188896 <br/>&gt;&gt;&gt; a = 257 <br/>&gt;&gt;&gt; b = 257 <br/>&gt;&gt;&gt; id(a) <br/>4515645744 <br/>&gt;&gt;&gt; id(b) <br/>4515645840</span></pre><p id="5d19" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们来观察两个变量<code class="fe mm mn mo mp b">a</code>和<code class="fe mm mn mo mp b">b</code>的内存地址。当它们都被分配 256 时，它们的存储器地址是相同的，而当它们都被分配 257 时，存储器地址是不同的。小整数缓冲池的范围正好是[-5，257]。</p><h1 id="05d1" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">字符串驻留</h1><p id="1510" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">对于字符串的使用，也存在内存问题。假设有 100 个变量，全部赋值为“<code class="fe mm mn mo mp b">python</code>”，我们真的要在内存中创建 100 个 string 对象，它们的值完全一样吗！</p><p id="c4e7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">显然我们不能这样做，这是对内存的浪费。为此，Python 提供了实习生机制。简单来说，Python 内部维护了一个字典(<code class="fe mm mn mo mp b">interned</code>)。</p><p id="caee" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当一个字符串需要驻留时，到<code class="fe mm mn mo mp b">interned</code>检查该字符串是否已经存在。如果存在，增加字符串的引用计数。如果不存在，则增加字符串的引用计数。放进字典里。</p><p id="0908" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">使用派驻技术有以下两个好处:</p><ul class=""><li id="6fe1" class="mq mr ir ku b kv kw ky kz lb ms lf mt lj mu ln nn mw mx my bi translated">节省内存</li><li id="3474" class="mq mr ir ku b kv mz ky na lb nb lf nc lj nd ln nn mw mx my bi translated">比较字符串时，常驻字符串比非常驻字符串快得多</li></ul><p id="a94d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">注意，驻留发生在编译时，不驻留在运行时</strong>。让我们看看下面的例子:</p><pre class="kh ki kj kk gu ne mp nf ng aw nh bi"><span id="9bb0" class="ni lq ir mp b gz nj nk l nl nm">s1 = 'py' + 'thon' <br/>print(s1 is 'python')  </span><span id="ca1a" class="ni lq ir mp b gz no nk l nl nm">a = 'py' <br/>b = 'thon' <br/>print(a+b is 'python')</span></pre><p id="4978" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">输出是</p><pre class="kh ki kj kk gu ne mp nf ng aw nh bi"><span id="75d9" class="ni lq ir mp b gz nj nk l nl nm">True<br/>False</span></pre><p id="d137" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe mm mn mo mp b">s1</code>的值在编辑阶段计算，因此驻留，而<code class="fe mm mn mo mp b">a+b</code>仅在运行阶段计算，因此<strong class="ku is">没有驻留</strong>发生。</p><p id="2162" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">默认情况下，空字符串和长度为<code class="fe mm mn mo mp b">1</code>的字符串将存在。Python 认为这样的字符串是经常使用的字符串。</p><h2 id="7de4" class="ni lq ir bd lr np nq dn lv nr ns dp lz lb nt nu mb lf nv nw md lj nx ny mf nz bi translated">使用 sys.intern 指定居住地</h2><p id="71ef" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">您可以使用<code class="fe mm mn mo mp b">sys.intern</code>来指定居住地，例如:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/54ca01dc47cef14322e9ed1bc5c17456.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*dhpuvYQnDtbsLUVSQJK82A.png"/></div></figure><p id="2845" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">并且不使用<code class="fe mm mn mo mp b">intern</code>:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ob"><img src="../Images/6fc50768f740c837ad0887bd2f3c04f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*qRMFCEGLOe0UPko_OduL2g.png"/></div></figure><h2 id="4fbf" class="ni lq ir bd lr np nq dn lv nr ns dp lz lb nt nu mb lf nv nw md lj nx ny mf nz bi translated">乘以(*)得到的字符串</h2><p id="1268" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">这部分是比较复杂的规则，我们先来看乘数为<code class="fe mm mn mo mp b">1</code>的情况。</p><ol class=""><li id="ee73" class="mq mr ir ku b kv kw ky kz lb ms lf mt lj mu ln mv mw mx my bi translated">如果字符串只包含下划线、数字、字母，则默认情况下驻留。</li><li id="2e1a" class="mq mr ir ku b kv mz ky na lb nb lf nc lj nd ln mv mw mx my bi translated">如果字符串的长度小于或等于 1，则它驻留在</li></ol><pre class="kh ki kj kk gu ne mp nf ng aw nh bi"><span id="c6b2" class="ni lq ir mp b gz nj nk l nl nm">&gt;&gt;&gt; s1 = 'uwesdfwe'<br/>&gt;&gt;&gt; s2 = s1*1<br/>&gt;&gt;&gt; s1 is s2<br/>True</span></pre><p id="362c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果乘数大于或等于 2，规则如下:</p><ol class=""><li id="92e8" class="mq mr ir ku b kv kw ky kz lb ms lf mt lj mu ln mv mw mx my bi translated">该字符串仅包含下划线、数字、字母，长度小于或等于 20，默认情况下驻留</li><li id="762e" class="mq mr ir ku b kv mz ky na lb nb lf nc lj nd ln mv mw mx my bi translated">当包含其他字符时，无论长度如何，它都不会驻留</li></ol><pre class="kh ki kj kk gu ne mp nf ng aw nh bi"><span id="c715" class="ni lq ir mp b gz nj nk l nl nm">&gt;&gt;&gt; s1 = 'pythonpythonpython' <br/>&gt;&gt;&gt; s2 = 'python'*3 <br/>&gt;&gt;&gt; s1 is s2<br/>True <br/>&gt;&gt;&gt; s1 = '&amp;&amp;&amp;' <br/>&gt;&gt;&gt; s2 = '&amp;'*3 <br/>&gt;&gt;&gt; s1 is s2 <br/>False</span></pre></div></div>    
</body>
</html>