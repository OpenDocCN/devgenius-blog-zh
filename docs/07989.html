<html>
<head>
<title>Kafka on Kubernetes: Using Strimzi — Part 4 (Scalability)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 上的卡夫卡:使用 Strimzi —第 4 部分(可伸缩性)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kafka-on-kubernetes-using-strimzi-part-4-scalability-59da50575fec?source=collection_archive---------4-----------------------#2022-05-09">https://blog.devgenius.io/kafka-on-kubernetes-using-strimzi-part-4-scalability-59da50575fec?source=collection_archive---------4-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="aff7" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">这是博客系列的第四部分，<strong class="jn io">库伯内特上的卡夫卡:使用</strong> <a class="ae kj" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jn io"> Strimzi </strong> </a> <strong class="jn io">。</strong>在<a class="ae kj" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-2-71a8ba8e9605" rel="noopener">第 2 部分</a>中，我们讨论了如何使用 Strimzi 设置 Kafka，在<a class="ae kj" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-3-configuration-options-f8aa027e9ba0" rel="noopener">第 3 部分</a>中，我们看到了生产就绪的 Kafka 配置及其对集群性能的影响。在这一部分中，我们将看到如何自动调整使用者以获得更好的吞吐量和资源可用性。</p><p id="4f89" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">首先，让我们试着理解什么是可伸缩性—<br/><strong class="jn io">可伸缩性</strong> —假设我们的应用程序有一个服务 1000 个请求/秒的硬性限制，但是在繁忙的一天，请求/秒的数量增加了 1000 多个。如果我们的应用程序仍然能够以同样的效率满足这些请求，我们就可以说我们的应用程序是可伸缩的。<br/> Kafka 提供了一个高度可扩展的系统，具有横向扩展，无限扩展的优势。</p><p id="9785" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">分区是 Kafka 提供冗余和可伸缩性的一种方式。每个分区可以托管在不同的服务器上，这意味着单个主题可以跨多个服务器进行水平扩展，以提供远远超出单个服务器能力的性能。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/405810a83e91baee251d4d03f689fef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AMLMlKIPintn2n8foBOVQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">主题使用分区的可伸缩性</figcaption></figure><p id="3c72" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">好了，我们已经创建了分区等于 100 的主题，现在我们放松了，我们可以获得比 1 个分区好 100 倍的吞吐量。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi la"><img src="../Images/6c0cf3e13de114aecb5211c9de6ea15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*LvBI8yYr_UrKSL98UypH4w.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae kj" href="https://www.google.com/imgres?imgurl=https%3A%2F%2Fi.chzbgr.com%2Ffull%2F8489388288%2Fh9A761FAD%2Fahhhhh-what-a-relief&amp;imgrefurl=https%3A%2F%2Fcheezburger.com%2F8489388288%2Fahhhhh-what-a-relief&amp;tbnid=_G9c0Nrtzee2tM&amp;vet=12ahUKEwjZ2pLR3NL3AhW7gGMGHVhmCK8QMygAegUIARDAAQ..i&amp;docid=ZUlh3K6hdGjfXM&amp;w=500&amp;h=374&amp;q=what%20a%20relief%20funny%20image&amp;safe=active&amp;ved=2ahUKEwjZ2pLR3NL3AhW7gGMGHVhmCK8QMygAegUIARDAAQ" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="626c" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">事实并非如此，即使我们有多个可以并行使用的分区，我们仍然需要一样东西，那就是<a class="ae kj" href="https://docs.confluent.io/platform/current/clients/consumer.html" rel="noopener ugc nofollow" target="_blank">消费者</a>。在继续讨论如何扩展消费者之前，让我们先了解一下共享消息队列和<a class="ae kj" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅系统</a>。</p><p id="9216" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><strong class="jn io">共享消息队列</strong>——共享消息队列系统允许消息流从生产者到达单个消费者。一旦一个消费者提取了一条消息，它就会从队列中删除。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/f3a45cebaf52ce31d20e4f930c55a8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*ZutErNyjpfdAmbjyCYlptQ.png"/></div></figure><p id="d82f" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">考虑上面的场景，如果消息 m1 被消费者 C1 消费，那么它将不可用于其他消费者。</p><p id="3765" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><strong class="jn io">发布-订阅系统</strong>——发布-订阅模型允许多个发布者发布消息到由多个订阅者订阅的代理托管的主题。消息因此被广播给主题的所有订户。这里的消息可供所有消费者使用。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/b2ed789e0613a0ed037703d76b793fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*j00Fh7OZYatW1SmLhcEYSQ.png"/></div></figure><p id="a2ff" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><strong class="jn io"> Kafka 利用消息队列系统的优势构建了发布-订阅模型</strong>。这是通过-</p><ul class=""><li id="217e" class="ld le in jn b jo jp js jt jw lf ka lg ke lh ki li lj lk ll bi translated">消费群体的使用</li><li id="581d" class="ld le in jn b jo lm js ln jw lo ka lp ke lq ki li lj lk ll bi translated"><a class="ae kj" href="https://docs.confluent.io/platform/current/installation/configuration/topic-configs.html#topicconfigs_retention.ms" rel="noopener ugc nofollow" target="_blank">消息由经纪人保留</a></li></ul><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/a0f55a7e7dac371604481d0533018d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*dYFuRIIrvZElbQGpLQUjtw.png"/></div></figure><p id="2ae8" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">消费者群体给了 Kafka 灵活性，可以同时拥有消息队列和发布-订阅模式的优点。</p><ul class=""><li id="e9c2" class="ld le in jn b jo jp js jt jw lf ka lg ke lh ki li lj lk ll bi translated">一个组中的消费者通过确定每个分区仅由该组中的单个消费者消费来在他们之间尽可能公平地划分主题分区。如果所有的消费者都来自同一个组，Kafka 模型就像传统的消息队列一样工作。</li><li id="25d0" class="ld le in jn b jo lm js ln jw lo ka lp ke lq ki li lj lk ll bi translated">当存在多个消费者群体时，数据消费模型的流程与传统的发布-订阅模型一致。这些消息被广播给所有的消费者群体。</li></ul><p id="b0b2" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">现在，我们了解了消费者和消费者群体，让我们看看如何使用<a class="ae kj" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank"> KEDA </a> (Kubernetes 事件驱动的自动伸缩)根据负载轻松扩展消费者。KEDA 提供各种缩放器，可以轻松地纵向扩展以提供更好的吞吐量，或者纵向扩展以有效利用可用资源。它提供<a class="ae kj" href="https://keda.sh/docs/1.4/scalers/apache-kafka/" rel="noopener ugc nofollow" target="_blank"> Kafka 缩放器</a>来自动缩放 Kafka 消费者。</p><p id="4456" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">考虑没有自动伸缩可用的场景，当生产者发送更少的消息时一切都很好。但是，如果它开始发送更多的信息，消费者将会不知所措，它将有很大的滞后。我们可以在下图中看到，当生产者开始每秒发送 100 条消息时，与每秒 10 条消息相比，消费者不能足够快地处理消息，并且它落后于生产者服务。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ls"><img src="../Images/44d9731669376320345db8bc461a7369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2zGZ5Vgflh0J51_rXbTAg.png"/></div></div></figure><p id="3f9b" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">我们可以使用 KEDA 的 Kafka 自动缩放器轻松处理它。我们需要根据生产者服务产生的流量调整消费者实例的数量。偏移滞后值不能超过所需的阈值。如果我们增加生产者端的流量，KEDA 应该增加消费者实例的数量。因此，如果我们降低生产者流量率，那么消费者实例的数量也会相应减少</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lt"><img src="../Images/80286933a58809f470c86b045a869a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDUpXH4hagRQWebX0LvpzQ.png"/></div></div></figure><p id="7d44" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><strong class="jn io">在 KEDA 设置和配置 Kafka 自动缩放器的步骤:</strong></p><p id="66d8" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">我们已经在<a class="ae kj" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-2-71a8ba8e9605" rel="noopener"> Part-2 </a>中设置了 Kafka 集群，现在让我们配置 KEDA 操作符和一个简单的消费者来验证自动缩放。</p><p id="1553" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">1-创建 keda 名称空间:</p><p id="386c" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><code class="fe lu lv lw lx b">kubectl create namespace keda</code></p><p id="fee4" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">2-部署 keda 操作员:</p><pre class="kl km kn ko gt ly lx lz ma aw mb bi"><span id="2f4d" class="mc md in lx b gy me mf l mg mh">a. helm repo add kedacore https://kedacore.github.io/charts<br/>b. helm repo update<br/>c. helm install keda kedacore/keda --namespace keda</span></pre><p id="c0c0" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">3-部署消费者应用程序:</p><pre class="kl km kn ko gt ly lx lz ma aw mb bi"><span id="a288" class="mc md in lx b gy me mf l mg mh">a. kubectl apply -f consumer-service.yml -n keda<br/>b. kubectl apply -f consumer-deployment.yml -n keda</span></pre><p id="11d4" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">4-部署科达缩放对象:<br/> <code class="fe lu lv lw lx b">kubectl apply -f keda.yaml -n keda</code></p><p id="63ae" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">下面是带有 Kafka scaler 的 keda.yaml 示例。它的延迟阈值为 10，所以当消息延迟达到 10 时，Keda 将产生一个新的消费者。</p><pre class="kl km kn ko gt ly lx lz ma aw mb bi"><span id="13e1" class="mc md in lx b gy me mf l mg mh">apiVersion: keda.sh/v1alpha1                 <br/>kind: ScaledObject<br/>metadata:                                   <br/>  name: consumer-scaler<br/>  namespace: keda<br/>spec:<br/>  scaleTargetRef:<br/>    name: consumer                  <br/>  pollingInterval: 1            <br/>  cooldownPeriod:  10         <br/>  minReplicaCount: 0             <br/>  maxReplicaCount: 10<br/>  triggers:<br/>    - type: kafka<br/>      metadata:<br/>        topic: my-topic<br/>        bootstrapServers: kafka-kafka-bootstrap.kafka:9092<br/>        consumerGroup: keda-consumer<br/>        <strong class="lx io">lagThreshold: '10'</strong><br/>        offsetResetPolicy: earliest</span></pre><p id="6f18" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">5- Run 卡夫卡制作人:<br/> <code class="fe lu lv lw lx b">kubectl -n kafka run kafka-producer -ti --image=quay.io/strimzi/kafka:0.28.0-kafka-3.1.0 --rm=true --restart=Never -- bin/kafka-console-producer.sh --bootstrap-server kafka-kafka-bootstrap:9092 --topic my-topic</code></p><p id="778d" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">6-制作一些信息，看看消费者群体是否正在扩大</p><p id="d802" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">你可以在 GitHub 的这里找到这些步骤<a class="ae kj" href="https://github.com/AmarendraSingh88/kafka-on-kubernetes" rel="noopener ugc nofollow" target="_blank">所需的资源。您可以使用这个存储库来设置和验证这个<strong class="jn io"> KafkaOnKubernetes </strong>博客系列的概念。</a></p><p id="c070" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><strong class="jn io">结论</strong> —这一部分涵盖了我们如何轻松扩展消费群体以获得期望的吞吐量。显然，为了提高吞吐量，我们需要相同或更多数量的分区，因为我们只能将一个消费者(在同一个消费者组中)连接到一个分区。因此，如果我们的消费者数量超过了分区的数量，那么这些消费者就会闲置。</p><p id="bfd5" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">在下一节中，我们将看到如何使用 Strimzi 保护 Kafka 集群。</p></div></div>    
</body>
</html>