<html>
<head>
<title>3 Good Java Practices to End Bad Code Reviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3 个良好的 Java 实践来结束糟糕的代码审查</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-good-java-practices-to-end-bad-code-reviews-388be94015f9?source=collection_archive---------3-----------------------#2021-07-11">https://blog.devgenius.io/3-good-java-practices-to-end-bad-code-reviews-388be94015f9?source=collection_archive---------3-----------------------#2021-07-11</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="e0aa" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">以下是获得更好的代码审查的实践</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/bd6df2097cf786bfc427acb976fefab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOH4r7L681rRCB0fcWWnrA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae kw" href="https://www.pexels.com/photo/man-person-people-woman-6914348/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄——作者编辑</figcaption></figure><p id="6538" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">你的团队只和你最弱的评审员一样好。——</em></strong><a class="lu lv ep" href="https://medium.com/u/4262f02e25a6?source=post_page-----388be94015f9--------------------------------" rel="noopener" target="_blank"><strong class="kz is"><em class="lt">乔尔肯普</em> </strong> </a></p><p id="621a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">大多数开发人员讨厌代码评审。我们不喜欢进行可怕的讨论，也不喜欢在评论上浪费时间。</p><p id="d602" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们需要改进我们的代码以获得更好的评论。<em class="lt">开发人员每小时审查超过 200 行代码，导致源代码质量降低。</em></p><p id="dc6a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一般来说，频繁的代码审查者比其他人写出更好的代码。他们看到更多的代码——他们知道更多。改进您的代码，并鼓励其他人这样做。</p><p id="3886" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里有一些你可以用来改进你的代码以获得更好的评论的东西。</p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="7c46" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">1.使用更多的泛型</h1><p id="59bb" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated">泛型让你的代码更简洁，更易读，更易维护。简洁的代码作为类属只显示接口。更容易阅读，因为<code class="fe na nb nc nd b">Collection&lt;T&gt;</code>比<code class="fe na nb nc nd b">Collection&lt;MyCustomType&gt;</code>更好。随着您变得更加冗长，创建更好的接口，以及创建特定的实现，它是可维护的。</p><p id="7e2b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Joshua 认为泛型会导致编译时问题。像这样使用泛型:</p><ul class=""><li id="c493" class="ne nf ir kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated">使用<code class="fe na nb nc nd b">Set&lt;String&gt;</code>而不是<code class="fe na nb nc nd b">Set</code></li><li id="eaa9" class="ne nf ir kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">使用<code class="fe na nb nc nd b">Set&lt;E&gt;</code>超过<code class="fe na nb nc nd b">Set&lt;Object&gt;</code></li><li id="0e31" class="ne nf ir kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">使用有界通配符，<code class="fe na nb nc nd b">Set&lt;? extends E&gt;</code></li><li id="629d" class="ne nf ir kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe na nb nc nd b">lvalue</code>应该比<code class="fe na nb nc nd b">rvalue</code>更通用，例如<code class="fe na nb nc nd b"> Set&lt;YourObject&gt; objectsSet = new HashSet&lt;&gt;();</code></li></ul><p id="04f7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">你不该对泛型做什么？避免同时使用数组和泛型。</em>那些对<code class="fe na nb nc nd b">Lists</code>胜过<code class="fe na nb nc nd b">Arrays</code>的好处一无所知的人，把两者混为一谈。比起数组，我更喜欢列表，因为它们更容易操作。Joshua 建议，当你发现它们在一起时，选择列表而不是数组。</p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><p id="2357" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里还有一些关于为什么你应该使用泛型的理由:</p><ul class=""><li id="9b8f" class="ne nf ir kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated">编译时更强的类型检查。</li></ul><p id="0922" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Java 编译器对泛型代码应用强类型检查，如果代码违反了类型安全，就会发出错误。修复编译时错误比修复运行时错误更容易，运行时错误很难发现。</p><ul class=""><li id="6a03" class="ne nf ir kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated">消除管型。</li><li id="afb8" class="ne nf ir kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">使程序员能够实现通用算法。</li></ul><p id="c06f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过使用泛型，程序员可以实现泛型算法，这些算法可以在不同类型的集合上工作，可以自定义，并且是类型安全的，更易于阅读。</p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="0bba" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">偷我的电子书</h1><p id="5982" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated">我发现了很多高质量评论的技巧。你可以在这里偷到它们<a class="ae kw" href="https://zivce.gumroad.com/l/become-high-quality-code-reviewer" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="dce3" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">2.使用<code class="fe na nb nc nd b">varargs for array-like arguments</code></h1><p id="036f" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated">当你需要传递一个参数数组时，使用<code class="fe na nb nc nd b">varargs</code>。Varargs 接受零个或多个参数。瓦拉格斯有一个<code class="fe na nb nc nd b">variable arity</code>。<code class="fe na nb nc nd b">variable arity</code>表示参数的数量是可变的。</p><p id="1c30" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt"/><code class="fe na nb nc nd b"><em class="lt">varargs</em></code><em class="lt">为什么好？</em>使用<code class="fe na nb nc nd b">varargs</code>传递一组参数轻而易举。如果没有<code class="fe na nb nc nd b">varargs</code>,你需要创建一个数组并将其作为参数传递。用<code class="fe na nb nc nd b">varargs</code>、<em class="lt">减少代码增加了未来代码评审的质量。</em></p><p id="a2d9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">你不该拿</em> <code class="fe na nb nc nd b"><em class="lt">varargs</em></code> <em class="lt">做什么？</em>不要把泛型和<code class="fe na nb nc nd b">varargs</code>混在一起。如果您将两者混合使用，就需要解决未检查的警告。Joshua Bloch 和 Maurice 深入探讨了这一主题。要点是数组创建受到未检查的强制转换的影响。当混合使用<code class="fe na nb nc nd b">varargs</code>和泛型时，你需要确保类型安全。混合泛型和<code class="fe na nb nc nd b">varargs</code>增加了更多的编译时问题，给评审者带来了困难。</p><p id="97b2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">什么时候不该用</em> <code class="fe na nb nc nd b"><em class="lt">varargs</em></code> <em class="lt">？</em> Joshua 建议为<code class="fe na nb nc nd b">varargs</code>创建数组会降低性能。需要性能的时候不要滥用<code class="fe na nb nc nd b">varargs</code>。<em class="lt">代码评审可以吃亏，性能不能吃亏。</em></p><p id="22ca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/2925153/can-i-pass-an-array-as-arguments-to-a-method-with-variable-arguments-in-java" rel="noopener ugc nofollow" target="_blank"> <em class="lt">如何将一个数组传递给变量 arguments 方法</em> </a> <em class="lt">？</em>你可以使用<code class="fe na nb nc nd b">Object…</code>和<code class="fe na nb nc nd b">Object[]</code>，因为它们在幕后是一样的。你不应该去掉<code class="fe na nb nc nd b">varargs</code>，来满足这个方法的参数。可变参数使我们的代码更加甜美，因此更容易理解。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ns nt l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://stackoverflow.com/questions/2925153/can-i-pass-an-array-as-arguments-to-a-method-with-variable-arguments-in-java/2926653#2926653" rel="noopener ugc nofollow" target="_blank">工作示例</a></figcaption></figure></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="52cc" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">3.改进您的错误处理</h1><p id="537a" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated"><em class="lt">对可恢复条件使用检查异常，对编程错误使用运行时异常。</em></p><p id="7625" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用检查异常意味着您的系统可以恢复。一个例子是<code class="fe na nb nc nd b">RetryLaterException</code>。你需要重新安排你的任务，并继续执行。使用这些异常进行更可靠的错误处理。</p><p id="fdea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">“未检查的异常对您的开发人员体验有什么影响？查明您需要解决的故障点。有助于调试，因为您获得了堆栈跟踪。通过适当的日志记录查明持续的故障。”——</em><a class="ae kw" href="https://medium.com/javarevisited/5-advantages-of-java-exceptions-java-developers-should-know-29412f2fd330" rel="noopener"><em class="lt">来源</em> </a></p><p id="50e0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">运行时异常应该指示不可恢复的错误。最臭名昭著的是<code class="fe na nb nc nd b">NullPointerException</code>。创建自己的运行时异常，记录环境，并停止执行。运行时错误可能是来自客户端的错误请求。由于关键部分通常会引起注意，所以审阅者会格外注意错误处理。</p><p id="f400" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">什么时候不该使用异常？当您可以使用简单的错误处理实践时。使用自定义错误代码、空集合、可选值或布尔值。当这些足以表明错误时，使用它们。比起异常，更喜欢简单的错误处理。</em></p><p id="f0da" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">“当通常疯狂的事情发生时，软件幸存下来。”——詹姆斯·高斯林对</em> <a class="ae kw" href="https://web.archive.org/web/20060407124657/http://www.artima.com/intv/solid2.html" rel="noopener ugc nofollow" target="_blank"> <em class="lt">异常</em> </a></p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="5596" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">外卖食品</h1><p id="420a" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated">好的评审导致更少的错误、更多的专业知识和知识转移。改进您的代码以结束糟糕的代码审查。</p><p id="165a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用更通用的解决方案。Java 中的泛型实现了所有这些功能，而且没有任何成本。泛型简化了您的代码，使其可读性更好。</p><p id="cfe0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">尽可能使用<code class="fe na nb nc nd b">varargs</code>。可变参数有助于减少样板文件。减少代码行数可以改进代码审查。</p><p id="e3ac" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">修改您的错误处理。争取更简单的错误处理，但也要改进您的异常处理。错误处理吸引了很多评论，你应该尽力让它更简单。</p></div><div class="ab cl lw lx hv ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ik il im in io"><h1 id="52bd" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">参考</h1><p id="6e6e" class="pw-post-body-paragraph kx ky ir kz b la mv js lc ld mw jv lf lg mx li lj lk my lm ln lo mz lq lr ls ik bi translated">[1] <a class="ae kw" href="https://sail.cs.queensu.ca/Downloads/EMSE_AnEmpiricalStudyOfTheImpactOfModernCodeReviewPracticesOnSoftwareQuality.pdf" rel="noopener ugc nofollow" target="_blank">代码评审研究</a></p><p id="3149" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">[2]Joshua Bloch 的《有效的 Java》</p><p id="cd93" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">[3] Java 泛型和集合，作者 Maurice Naftalin 和 Philip Wadler</p><p id="bf0b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">[4]麦金托什，谢恩等人，“现代代码评审实践对软件质量影响的实证研究。”</p></div></div>    
</body>
</html>