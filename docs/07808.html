<html>
<head>
<title>Monitoring logins to a server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控服务器登录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/monitoring-logins-to-a-server-4cbd1515a4b9?source=collection_archive---------11-----------------------#2022-04-24">https://blog.devgenius.io/monitoring-logins-to-a-server-4cbd1515a4b9?source=collection_archive---------11-----------------------#2022-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0292" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">斯诺登向美国国家安全局和全世界展示了<strong class="jm io">监控你的资产和保护它们一样重要</strong>。因此，在这篇文章中，我们将看到如何监控登录到 Linux 服务器，并在每次成功登录后发送电子邮件。</p><p id="36d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我在 https://github.com/BenjaminGuzman/login-monitor<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor" rel="noopener ugc nofollow" target="_blank">创建了一个 GitHub 库，在那里你可以找到这里提到的所有脚本和代码。</a></p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="ff89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我假设你使用的是基于 RHEL 的发行版，并且你知道一些关于 PAM(查看<a class="ae ki" href="https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Deployment_Guide-en-US/ch-pam.html" rel="noopener ugc nofollow" target="_blank"> RHEL 文档</a>)和 audit(查看<a class="ae ki" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls" rel="noopener ugc nofollow" target="_blank"> RHEL 文档</a>)的知识，以及像 JSON、非对称加密、CLI 用法等基础知识。然而，我的 GiHub repo 包含了各种脚本，可以帮助你，使它不那么困难。</p><p id="7b53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简单起见，这篇文章分为三个部分:</p><ol class=""><li id="7d40" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">服务器配置</li><li id="6690" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">发送带有系统信息的加密和签名电子邮件的脚本配置，以供进一步分析</li><li id="c46d" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">PAM 配置，以便在任何成功登录后执行脚本</li></ol><h1 id="c652" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">服务器配置</h1><p id="11ab" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">(我假设服务器已经有了用户、SSH、权限等的基本配置。互联网上有大量的文档)</p><p id="67f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要安装<code class="fe mh mi mj mk b"><a class="ae ki" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/auditing-the-system_security-hardening" rel="noopener ugc nofollow" target="_blank">audit</a></code>来记录服务器中的活动，安装<code class="fe mh mi mj mk b">gnupg2</code>是因为我们需要管理密钥来签名和加密我们的数据</p><p id="e408" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mh mi mj mk b">sudo dnf install audit gnupg2 &amp;&amp; sudo systemctl enable --now auditd</code></p><p id="49d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在将源代码下载并解压到一个临时位置，例如<code class="fe mh mi mj mk b">/tmp</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1a79" class="mt lf in mk b gy mu mv l mw mx">curl -L -O <a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/archive/refs/tags/v0.1-alpha.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/BenjaminGuzman/login-monitor/archive/refs/tags/v0.4.tar.gz</a> &amp;&amp; tar xf v0.4.tar.gz &amp;&amp; cd login-monitor-0.4</span></pre><p id="d932" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(请务必下载最新的稳定版本，即将<code class="fe mh mi mj mk b">v0.4</code>替换为可用的最新版本)</p><h2 id="8f11" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">审计规则配置</h2><p id="207b" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">默认情况下<code class="fe mh mi mj mk b">audit</code>记录基本信息，所以如果你想记录更具体的事件，你需要编写新的规则。脚本<code class="fe mh mi mj mk b"><a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/blob/master/download-audit-rules.sh" rel="noopener ugc nofollow" target="_blank">download-audit-rules.sh</a></code>下载一些常用的。要了解有关审计规则的更多信息，请参见附录 A 和<a class="ae ki" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls" rel="noopener ugc nofollow" target="_blank"> RHEL 文件</a>。</p><p id="ab82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该脚本不接收任何参数，并且需要 root 权限，因为规则保存在<code class="fe mh mi mj mk b">/etc/audit/rules.d</code>中</p><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nj"><img src="../Images/747b56bff6d3c17907215b1395c86234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYV1sZA9sA8vP6Zkicl4gg.png"/></div></div></figure><p id="3ce9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">建议您<strong class="jm io">阅读下载的规则</strong>，并根据需要进行修改。完成后，<strong class="jm io">重启</strong>机器。</p><h2 id="c556" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">PGP 密钥配置</h2><p id="3602" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">让我们下载所需的收件人密钥来加密电子邮件(因为它可能包含敏感信息)，并为服务器生成一个 PGP 密钥对，以便对电子邮件进行签名(在这种情况下需要不可否认性)。如果你不知道 PGP 是什么，就去查<a class="ae ki" href="https://protonmail.com/blog/what-is-pgp-encryption/" rel="noopener ugc nofollow" target="_blank">这个</a>帖子。</p><p id="de65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">脚本<code class="fe mh mi mj mk b"><a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/blob/v0.1-alpha/gpg-keys.sh" rel="noopener ugc nofollow" target="_blank">gpg-keys.sh</a></code>将帮助我们做到这一点。它接收作为位置参数的 URL，从这些 URL 可以下载公钥，并且可以提供<code class="fe mh mi mj mk b">--gen-key</code>来生成新的密钥对。</p><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nr"><img src="../Images/cc2abcdeecb7e2fee1e47f171ab3b426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQdvTUvmv_W9e5snXTel7g.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">为服务器生成的公钥以黄色突出显示</figcaption></figure><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nj"><img src="../Images/d2fbda3fa356eb970d9990b3c569f81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSFdGXXHpj-tx7NaJYM0Kw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">密码文件以黄色突出显示</figcaption></figure><p id="f79d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您需要记住<strong class="jm io">密码文件位置</strong>和<strong class="jm io">密钥 id </strong>，因为我们稍后会用到。</p><p id="97a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在将生成的公钥<strong class="jm io"> </strong>导入到您的<strong class="jm io">个人</strong>钥匙圈(从您将打开电子邮件的机器)中，以便您可以验证电子邮件签名。</p><p id="7ea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="nw">注</em> </strong>:雷鸟等一些邮件客户端无法处理单收件人加密邮件，所以你需要为两个或两个以上的收件人加密邮件，即使你只发给一个。所以我下载了两个公钥。</p><h1 id="de8b" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">发送电子邮件的脚本</h1><p id="56a3" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">我不会深入脚本的细节，因为我宁愿解释它的配置。但是，当然，你可以查看<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="6a25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">建议将所有配置文件保存在<code class="fe mh mi mj mk b">/root/.login-monitor</code>目录下。这可能看起来很奇怪，因为它违反了最小特权原则，但这样做是因为您不会手动运行脚本，相反，PAM 将使用 uid=0 (root 用户)来运行它。</p><h2 id="b54e" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">脚本配置</h2><p id="fc36" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">您可以在<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/blob/v0.1-alpha/schema.json" rel="noopener ugc nofollow" target="_blank"> schema.json </a>中检查所有的配置选项。我将使用以下配置并将其存储在<code class="fe mh mi mj mk b">config.json</code>中</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7d14" class="mt lf in mk b gy mu mv l mw mx">{<br/>  "$schema": "https://raw.githubusercontent.com/BenjaminGuzman/login-monitor/master/schema.json",<br/>  "sender": {<br/>    "email": "bg@benjaminguzman.dev",<br/>    "pgpKeyId": "0xB7C40612F9CCDB49"<br/>  },<br/>  "recipient": {<br/>    "email": "bg@benjaminguzman.dev",<br/>    "pgpKeyId": "bg@benjaminguzman.dev"<br/>  },<br/>  "cc": [{<br/>    "email": "",<br/>    "pgpKeyId": "benja@kobd.io"<br/>  }],<br/>  "subject": "New login on %h at %t RFC822Z t%",<br/>  "textMessage": "./message.txt",<br/>  "htmlMessage": "./message.html",<br/>  "senderPassFile": "/root/localhost.localdomain-17687.txt",<br/>  "attachments": ["/var/log/audit"]<br/>}</span></pre><p id="917b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有几件事值得注意:</p><ul class=""><li id="9d81" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh nx kw kx ky bi translated">发送者的<code class="fe mh mi mj mk b">pgpKeyId</code>是我们之前生成的密钥的 id。这可能会导致问题，因为电子邮件<em class="nw"> bg@benjaminguzman.dev </em>与该键没有关联。我找到的唯一解决方法是<a class="ae ki" href="https://docs.github.com/en/authentication/managing-commit-signature-verification/associating-an-email-with-your-gpg-key" rel="noopener ugc nofollow" target="_blank">编辑 pgp 密钥</a>并添加真实的发件人邮件。</li><li id="060f" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">0xB7C40612F9CCDB49</code>是我们之前用<code class="fe mh mi mj mk b">gpg-keys.sh</code>脚本生成的密钥的 id。</li><li id="d8a8" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated">抄送收件人电子邮件为空，这表明该电子邮件将对<em class="nw"> bg@benjaminguzman.dev </em>和<em class="nw"> benja@kobd.io </em>进行加密，但该电子邮件实际上将只发送到<em class="nw"> bg@benjaminguzman.dev </em>。当然，如果你设置了抄送收件人的邮箱，那个人也会收到邮件。</li><li id="246d" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated">在主题字符串<code class="fe mh mi mj mk b">New login on %h at %t RFC822Z t%</code>中，<code class="fe mh mi mj mk b">%h</code>是主机名的占位符，<code class="fe mh mi mj mk b">%t RFC822Z t%</code>是当前时间的占位符(将根据<code class="fe mh mi mj mk b">RFC822Z</code>格式化，查看<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/blob/master/helpers.go#L38" rel="noopener ugc nofollow" target="_blank">源代码</a>了解更多)</li><li id="f59d" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">/root/localhost.localdomain-17687.txt</code>是之前为我们生成的密码文件。</li><li id="2641" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated">因为<code class="fe mh mi mj mk b">attachments</code>中的唯一条目指向一个目录，所以<code class="fe mh mi mj mk b">/var/log/audit</code>中的所有文件都将被附加到电子邮件中。</li></ul><p id="1453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mh mi mj mk b">message.txt</code>的内容有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7c56" class="mt lf in mk b gy mu mv l mw mx">New login on %h at %t RFC822Z t%.<br/>Details are provided as attachments.<br/>Remember this information is confidential and please, RESPECT THE PRIVACY of other users<br/>System users:<br/>%f /etc/passwd f%</span></pre><p id="3751" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mh mi mj mk b">message.html</code>的内容有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3695" class="mt lf in mk b gy mu mv l mw mx">&lt;html lang="es"&gt;<br/>    &lt;body&gt;<br/>        &lt;p&gt;New login on &lt;b&gt;%h&lt;/b&gt; at &lt;b&gt;%t RFC822Z t%&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;<br/>        &lt;p&gt;Details are provided as attachments&lt;/p&gt;&lt;br/&gt;<br/>        &lt;p&gt;&lt;i&gt;Remember this information is confidential and please, RESPECT THE PRIVACY of other users&lt;/i&gt;&lt;/p&gt;<br/>        &lt;p&gt;System users:&lt;/p&gt;<br/>        &lt;pre&gt;%f /etc/passwd f%&lt;/pre&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="22b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能已经注意到，您可以在消息中包含占位符，例如用<code class="fe mh mi mj mk b">%h</code>表示主机名，<code class="fe mh mi mj mk b">%f &lt;filename&gt; %f</code>表示文件内容，或者<code class="fe mh mi mj mk b">%t &lt;format&gt; %t</code>表示当前时间。</p><h2 id="d8b5" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">Gmail 客户端配置</h2><p id="e7fe" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">这段代码的一个优点是它使用了<strong class="jm io">策略模式</strong>来发送电子邮件。因此，很容易改变发送电子邮件的实际服务(Gmail、SendGrid、postfix 等)。</p><p id="b7e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我更喜欢使用 Gmail，因为它是免费的(当然，就像免费啤酒一样)，设置有点简单，它有很好的声誉，它经过了很好的测试，因此它的交付问题较少。</p><p id="1cb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说了这么多，还是先从配置说起吧。</p><ol class=""><li id="7e58" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">打开 https://console.cloud.google.com/projectcreate<a class="ae ki" href="https://console.cloud.google.com/projectcreate" rel="noopener ugc nofollow" target="_blank">并创建一个项目</a></li><li id="92ab" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">启用 Gmail API(菜单&gt; API 和服务&gt;启用的 API 和服务&gt;启用 API 和服务，搜索 Gmail 并启用它)</li></ol><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ny"><img src="../Images/e07b6ea4442bd7c33640633ce334bbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKgAgdQlUXBqCbFZdUjQBg.png"/></div></div></figure><p id="3dae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们创建脚本将用来访问 Gmail API 的凭证。我试着用一个服务账号，但是好像不行(<a class="ae ki" href="https://github.com/googleapis/google-api-go-client/issues/645" rel="noopener ugc nofollow" target="_blank">相关 GitHub 问题</a>)。因此，我们必须使用 OAuth2 凭据。</p><p id="3554" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.配置 OAuth2 同意屏幕(菜单&gt; API 和服务&gt; OAuth 同意屏幕)。配置由你决定，只需考虑<a class="ae ki" href="https://developers.google.com/identity/protocols/oauth2#expiration" rel="noopener ugc nofollow" target="_blank">令牌过期原因</a>。</p><p id="3821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.创建 OAuth2 凭据(菜单&gt; API 和服务&gt;凭据&gt;创建凭据&gt; OAuth 客户端 ID)。选择“网络应用”作为应用类型，并将<a class="ae ki" href="https://developers.google.com/oauthplayground" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/oauthplayground</a>添加到“授权重定向 URIs”中。</p><p id="72f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建 OAuth2 凭据后，将出现一个包含您的客户端 id、客户端密码和下载按钮的弹出窗口。点击下载，将文件保存为配置目录<code class="fe mh mi mj mk b">/root/.login-monitor</code>中的<code class="fe mh mi mj mk b">oauth2-config.json</code>。</p><p id="89c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.前往<a class="ae ki" href="https://developers.google.com/oauthplayground" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/oauthplayground</a>创建您的代币。</p><p id="ca9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.1.单击配置按钮(绿色)并填写步骤 4 中的信息(黄色)。</p><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nz"><img src="../Images/16b4e26c04236ef5bf9cbdc79338a7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WQTAdIXOa4DAiIf77AVZg.png"/></div></div></figure><p id="b82a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.2.在“选择&amp;授权 API”下选择<a class="ae ki" href="https://www.googleapis.com/auth/gmail.send" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/gmail.send</a>，点击授权 API，并在同意屏幕中给出您的同意。</p><p id="47cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.3.现在转到“步骤 2 用授权码交换令牌”并获得两个令牌，一个刷新令牌和一个访问令牌。</p><p id="da42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.4.将您的令牌保存在名为<code class="fe mh mi mj mk b">oauth2-token.json</code>的文件中。它应该是这样的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2801" class="mt lf in mk b gy mu mv l mw mx">{<br/>  "refresh_token": "&lt;the refresh token you obtained previously&gt;",<br/>  "access_token": "&lt;the access token you obtained previously&gt;",<br/>  "token_type": "Bearer",<br/>  "expiry": "2022-04-17T15:48:25.348449415-05:00"<br/>}</span></pre><p id="0bdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而且…我们<strong class="jm io">快完成了</strong>。也许这是更繁琐/困难的一步，但这里的优点是只需做一次，即使你想监控各种机器。</p><h2 id="b43d" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">脚本测试</h2><p id="9685" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">现在，配置目录<code class="fe mh mi mj mk b">/root/.login-monitor</code>应该包含:</p><ul class=""><li id="f251" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">config.json</code>:脚本配置</li><li id="5a1d" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">message.txt</code>:文本/纯文本格式的电子邮件</li><li id="4dc1" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">message.html</code>:文本/html 格式的电子邮件</li><li id="0b19" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">oauth2-config.json</code> : Gmail API OAuth2 客户端配置</li><li id="ea68" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">oauth2-token.json</code> : Gmail API OAuth2 令牌</li></ul><p id="1a07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是运行脚本所需的所有配置。现在我们需要完成大部分魔术的编译二进制文件。</p><p id="5829" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以通过编译源代码(需要安装<code class="fe mh mi mj mk b">go</code>或者从<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/releases/download/v0.4/login-monitor" rel="noopener ugc nofollow" target="_blank"> GitHub 版本</a>下载预编译的二进制文件来获得(前提是你信任我。我向你保证这不是恶意软件)。</p><p id="1766" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论以何种方式获得可执行文件，都必须将它移动到配置目录<code class="fe mh mi mj mk b">/root/.login-monitor</code>(一旦运行，所有者和权限将自动改变)。</p><p id="81b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们测试一下是否一切正常。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e20d" class="mt lf in mk b gy mu mv l mw mx">./login-monitor --config config.json --gmail-oauth2-config oauth2-config.json --gmail-oauth2-token oauth2-token.json --log-level debug</span></pre><p id="2281" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查你的电子邮件。您应该会收到如下所示的电子邮件。</p><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nz"><img src="../Images/18edaa34ceb7ec6c74b5666e70389388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX_8tvn0d5UO3g9_e9H-sw.png"/></div></div></figure><p id="45b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，几乎一切正常，占位符被替换(忽略服务器的异常用户)，附件被附加，电子邮件被加密，但签名似乎有问题。</p><p id="2083" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为在<code class="fe mh mi mj mk b">config.json</code>中，发件人的电子邮件与发件人的 pgpKeyId 没有关联。要解决这个问题，你可以将电子邮件与该键相关联，或者在电子邮件中“伪造”来自的<em class="nw">标题(我试过，但 Gmail 不允许，并覆盖了该标题。如果您使用另一个提供商，您可以尝试在您的配置中设置<code class="fe mh mi mj mk b">fakeSender</code>。</em></p><h2 id="fb19" class="mt lf in bd lg my mz dn lk na nb dp lo jv nc nd ls jz ne nf lw kd ng nh ma ni bi translated">解决纷争</h2><p id="77c1" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated"><strong class="jm io">用户的委托被拒绝</strong></p><p id="16ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您遇到这样的错误</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fe1a" class="mt lf in mk b gy mu mv l mw mx">Delegation denied for &lt;user&gt;@&lt;gmail/google workspace&gt;, forbidden</span></pre><p id="0623" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能是因为发件人与链接到您的 GCP(谷歌云平台)帐户的电子邮件不同，或者如消息所示，您拒绝了<a class="ae ki" href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation" rel="noopener ugc nofollow" target="_blank">委托</a>(仅适用于谷歌工作区用户)。</p><p id="8851" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在我的例子中，我输入发件人<em class="nw"> bg@benjaminguzman.dev </em>，但是我有一个链接到我的 GCP 的 gmail.com 电子邮件，所以我得到了那个错误。要解决这个问题，只需将发件人的电子邮件替换为链接到你的 GCP 的电子邮件(就我而言，就是我的 gmail.com 电子邮件)。</p><p id="c39b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">邮件已发送，但无法解密</strong></p><p id="0faf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您收到了电子邮件，但是您的电子邮件客户端说<em class="nw">解密此邮件所需的密钥不可用</em>但是您的钥匙圈中有密钥。</p><p id="0c61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能是因为您的电子邮件客户端无法处理它(例如，如果这是一封为单个收件人加密的电子邮件)。不过不用担心，如果你取邮件源，提取 PGP 消息，用<code class="fe mh mi mj mk b">gpg</code>手动解密，还是可以看到解密的邮件。</p><h1 id="2040" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">PAM 配置</h1><p id="8fd5" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">现在我们已经看到了这个脚本的神奇之处，让我们配置 PAM 在成功登录后执行它。</p><p id="c749" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">配置实际上非常简单，因为我们唯一要做的就是运行脚本。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="402e" class="mt lf in mk b gy mu mv l mw mx">sudo ./pam-config.sh --optional --config-path /etc/pam.d/sshd "--config config.json --gmail-oauth2-config oauth2-config.json --gmail-oauth2-token oauth2-token.json"</span></pre><p id="b2f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的案例中，我提供了以下论据:</p><ul class=""><li id="4a64" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">--optional</code>:所以不需要成功退出 pam_exec.so 模块就可以登录(即即使可执行文件失败，用户也可以登录)</li><li id="c752" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">--config-path /etc/pam.d/sshd</code>:我只想监控 ssh 登录</li><li id="7393" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">"--config config.json ..."</code>:这些都是提供给<code class="fe mh mi mj mk b">login-monitor</code>的相同论据。</li></ul><p id="570f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查<a class="ae ki" href="https://github.com/BenjaminGuzman/login-monitor/blob/master/pam-config.sh" rel="noopener ugc nofollow" target="_blank">源代码</a>或提供<code class="fe mh mi mj mk b">--help</code>标志以了解更多关于配置选项的信息。</p><p id="2ff4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们完成了，当任何人通过 ssh 🥳.登录时，您应该会收到一封电子邮件您只需重新启动系统即可应用更改。</p><h1 id="fe46" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">附录 A:添加审计规则</h1><p id="143c" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">假设我想审计用<code class="fe mh mi mj mk b">sudo</code>运行的所有命令。为此，我可以通过使用命令<code class="fe mh mi mj mk b"><a class="ae ki" href="https://linux.die.net/man/8/auditctl" rel="noopener ugc nofollow" target="_blank">auditctl</a></code>(临时更改)或者将该命令将接收到的相同参数写入文件<code class="fe mh mi mj mk b">/etc/audit/audit.rules</code>(持久更改)来添加审计规则。因为我需要持久规则，所以我将把下面的内容添加到审计规则文件中。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1371" class="mt lf in mk b gy mu mv l mw mx">-a exit,always -F arch=b64 -F euid=0 -S execve<br/>-a exit,always -F arch=b32 -F euid=0 -S execve</span></pre><p id="1cec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们看看这意味着什么:</p><ul class=""><li id="60d4" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">-a exit,always</code>:添加一个规则，在每次系统调用退出时创建一个审计事件。</li><li id="1b1c" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">-F arch=b64/b32</code>:审计 x86 (32 位)和 x86_64 (64 位)的系统调用。</li><li id="dc35" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">-F euid=0</code>:只审计 root 调用的系统调用(用<code class="fe mh mi mj mk b">sudo</code>运行的命令 euid = 0)。阅读<a class="ae ki" href="https://mudongliang.github.io/2020/09/17/ruid-euid-suid-usage-in-linux.html" rel="noopener ugc nofollow" target="_blank">本</a>了解更多信息)。</li><li id="db91" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh nx kw kx ky bi translated"><code class="fe mh mi mj mk b">-S execve</code>:只审计系统调用<code class="fe mh mi mj mk b">execve</code>。它是一个系统调用，程序使用它来实际执行一个命令(更多信息请参见附录 B)</li></ul><p id="78fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">详细的解释超出了这篇文章的范围。我只是想简单介绍一下如何添加审计规则，以备不时之需。如果你想了解更多，我推荐你阅读<a class="ae ki" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing" rel="noopener ugc nofollow" target="_blank"> RHEL 文件</a>。</p><h1 id="5e07" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">附录 B: execve 和 execveat</h1><p id="93ae" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">在阅读<a class="ae ki" href="https://github.com/sudo-project/sudo/blob/967bcab4dbfa79bc7b47233861b97710841d82c5/src/exec_common.c#L112" rel="noopener ugc nofollow" target="_blank"> sudo </a>的源代码时，我发现它可能会调用类似于<code class="fe mh mi mj mk b">execve</code>或<code class="fe mh mi mj mk b"><a class="ae ki" href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/fexecve.c.html#43" rel="noopener ugc nofollow" target="_blank">fexecv</a></code>的 C 函数，而这些函数又可能会使用<code class="fe mh mi mj mk b">execveat</code>或<code class="fe mh mi mj mk b">execve</code>系统调用，这些系统调用实际上是执行给定命令的。</p><p id="4ff5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以似乎也应该增加一个审计<code class="fe mh mi mj mk b">execveat</code>的规则(或者至少我是这么想的)。但实际上并不需要。尝试执行以下 C 代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a1d7" class="mt lf in mk b gy mu mv l mw mx">#include &lt;unistd.h&gt;<br/><br/><em class="nw">int </em>main() {<br/>       <em class="nw">char</em>* args[] = {"/usr/bin/echo", "Hello World!", <strong class="mk io">NULL</strong>};<br/>       <em class="nw">if </em>(fork() == 0)<br/>              execve(args[0], args, <strong class="mk io">NULL</strong>);<br/>       execveat(0, args[0], args, <strong class="mk io">NULL</strong>, <strong class="mk io">NULL</strong>); <em class="nw">//dirfd is ignored<br/>       return </em>0;<br/>}</span></pre><p id="94c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将看到审计记录了这两个呼叫。所以我想审计<code class="fe mh mi mj mk b">execve</code>的单一规则就足够了。尽管如此，您已经知道如何添加审计规则，但是要注意性能，为了提高效率，我建议您在一个规则中添加多个系统调用。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="f4d1" class="le lf in bd lg lh oa lj lk ll ob ln lo lp oc lr ls lt od lv lw lx oe lz ma mb bi translated">结论</h1><p id="87f7" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">现在，您可以监控您的服务器登录，但请记住<strong class="jm io">您可以定制此配置以服务于其他目的</strong>，例如，您可以为每次不成功的登录尝试发送电子邮件，在每次特定用户从服务器注销时发送短信，等等……这由您决定。</p><p id="ff1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是，我想重申两件重要的事情:</p><ol class=""><li id="1dba" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">使用该脚本时要小心，因为在发送用户信息(IP 地址、SSH 客户端信息等)时，您可能会侵犯用户的隐私。)通过电子邮件。此外，发送大文件时要小心，因为你可能会超过配额限制或类似的限制。使用某种形式的日志旋转。</li><li id="5878" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">保持合法和尊重。正如简介中所说，斯诺登教给我们的一件重要事情是要意识到内部威胁，但我们也学到了重要的是要有<strong class="jm io">道德</strong>，不要在用户背后做任何事情，更不要说没有他们的同意。所以，<strong class="jm io">只有当用户知道你在使用这个工具的时候才使用它</strong>。</li></ol><p id="c339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有任何疑问或想给我反馈，请随时留下评论，我很乐意。</p></div></div>    
</body>
</html>