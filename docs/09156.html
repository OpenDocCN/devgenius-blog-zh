<html>
<head>
<title>OpenTelemetry for Go: Three Ways to Send Data to an OTLP Observability Back-end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenTelemetry for Go:向 OTLP 可观测性后端发送数据的三种方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/opentelemetry-to-lightstep-3-ways-in-golang-7dfcf2892003?source=collection_archive---------12-----------------------#2022-08-02">https://blog.devgenius.io/opentelemetry-to-lightstep-3-ways-in-golang-7dfcf2892003?source=collection_archive---------12-----------------------#2022-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ba131f4b0dde26870a7880ab8010c977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bYfPih0SoTP5H_7o"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">帝王蝶给紫色小花授粉。阿德里·维勒拉的照片</figcaption></figure><p id="6d02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的几周里，我花了大量时间寻找不同的方式向 Lightstep 发送<a class="ae jz" href="https://lightstep.com/blog/opentelemetry.io" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry (OTel) </a>数据。</p><p id="4f7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这个超级明显的标题还没有给你提示，有三种不同的方法可以做到:</p><ol class=""><li id="fc22" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">直接来自应用程序</li><li id="34f5" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" href="https://opentelemetry.io/docs/collector" rel="noopener ugc nofollow" target="_blank">打开遥测采集器</a></li><li id="7a50" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">启动器(通过收集器或直接从应用程序)</li></ol><p id="ef6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将详细探究这三种方法，用代码片段解释如何将数据放入<a class="ae jz" href="https://lightstep.com/blog/app.lightstep.com" rel="noopener ugc nofollow" target="_blank"> Lightstep Observability </a>中。我们开始吧！</p><blockquote class="lm ln lo"><p id="fbd3" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="in">如果你正在寻找完整的代码清单，不要惊慌！你可以在 Lightstep </em> <a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/tree/main/go" rel="noopener ugc nofollow" target="_blank"> <em class="in"> OTel 范例库中看到它们</em> </a> <em class="in">。</em></p></blockquote><p id="1cd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们继续之前，这里有一些你需要的东西:</p><ul class=""><li id="1c8b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">对<a class="ae jz" href="https://go.dev/doc/tutorial/getting-started" rel="noopener ugc nofollow" target="_blank"> Golang </a>的基本了解</li><li id="10fc" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">基本了解<a class="ae jz" href="https://lightstep.com/blog/observability-mythbusters-how-hard-is-it-to-get-started-with-opentelemetry#otel-collector-101" rel="noopener ugc nofollow" target="_blank">开放式遥测采集器</a></li></ul><p id="1cda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想运行完整的代码示例，您还需要:</p><ul class=""><li id="91a2" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">一个<a class="ae jz" href="https://app.lightstep.com/signup/developer?signup_source=docs" rel="noopener ugc nofollow" target="_blank">光步可观测性账户</a></li><li id="862d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">一个<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>告诉 Lightstep 将你的跟踪发送到哪个项目</li><li id="f3e4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">一个本地 Golang 开发环境</li><li id="93a4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">(我们将需要它来本地运行 OTel 收集器)</li></ul><p id="f2a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Lightstep 可观测性支持本机<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md" rel="noopener ugc nofollow" target="_blank">开放式遥测协议(OTLP) </a>。它可以通过<a class="ae jz" href="https://opentelemetry.io/docs/concepts/glossary/#http" rel="noopener ugc nofollow" target="_blank"> HTTP </a>或<a class="ae jz" href="https://opentelemetry.io/docs/concepts/glossary/#grpc" rel="noopener ugc nofollow" target="_blank"> gRPC </a>接收 OTLP 格式的数据。您需要指定您希望在代码中使用的方法，我们将在接下来的代码片段中看到这一点。</p><p id="eecd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你对使用 gRPC 和 HTTP 进行 OpenTelemetry 感到好奇，请查看这些文档。</p><blockquote class="lm ln lo"><p id="7a13" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注:</strong> <em class="in">其他支持 OTLP 的可观测性工具还有</em> <a class="ae jz" href="https://www.honeycomb.io/blog/all-in-on-opentelemetry" rel="noopener ugc nofollow" target="_blank"> <em class="in">蜂巢</em></a><em class="in"/><a class="ae jz" href="https://grafana.com/blog/2021/04/13/how-to-send-traces-to-grafana-clouds-tempo-service-with-opentelemetry-collector" rel="noopener ugc nofollow" target="_blank"><em class="in">格拉法纳</em></a><em class="in"/><a class="ae jz" href="https://medium.com/jaegertracing/introducing-native-support-for-opentelemetry-in-jaeger-eb661be8183c" rel="noopener"><em class="in">耶格</em> </a> <em class="in">。</em></p></blockquote><h1 id="e049" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">直接来自应用程序</h1><p id="25ce" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">如果您开始使用 OpenTelemetry 为您的应用程序提供工具，这可能是大多数初学者最常走的路线。顾名思义，我们直接从应用程序代码向给定的可观察性后端发送数据。</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/57712609ab1cf002934e51d93f30e6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zl6nhfAtLLa8Y1AONFiWBg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">应用程序将 OpenTelemetry 数据直接发送到 Lightstep。图由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>绘制。</figcaption></figure><p id="8c22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们必须做到以下几点:</p><ul class=""><li id="48da" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">安装所需的 OpenTelemetry 包，并导入它们</li><li id="a5a1" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">配置导出器</li><li id="553c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">配置 TracerProvider</li><li id="da84" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">初始化导出器和 TracerProvider 以向 Lightstep 发送数据</li></ul><p id="d9f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你不知道这一切意味着什么，不要惊慌。我们很快就会开始挖掘。</p><blockquote class="lm ln lo"><p id="5656" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注:</strong> <em class="in">这里</em>  <em class="in">可以看到通过 OTLP 越过 gRPC </em> <a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/opentelemetry/otlp/server/server.go" rel="noopener ugc nofollow" target="_blank"> <em class="in">直接发送 OTel 数据到 Lightstep 的完整例子。HTTP 版可以在这里找到</em></a><a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/opentelemetry/otlp/server/server-http.go" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">。</em></p></blockquote><h2 id="335d" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">它是如何工作的</h2><p id="9a27" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated"><strong class="kc io"> 1-安装所需的 OTel 库</strong></p><p id="9399" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些是<strong class="kc io"> <em class="lp">将数据发送到可观察性后端(如 Lightstep) </em> </strong>所需的库。</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fea7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的应用程序代码中，我们需要导入相同的库:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3533" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您希望使用 HTTP 而不是 gRPC，请用<code class="fe nq nr ns nt b">otlptracehttp</code>替换<code class="fe nq nr ns nt b">otlptracegrpc</code>。</p><p id="b95f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-配置导出器</strong></p><p id="a8e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">导出器是我们向 OpenTelemetry 发送数据的方式。正如我前面提到的，Lightstep 接受 OTLP 格式的数据，所以我们需要定义一个 OTLP 导出器。</p><blockquote class="lm ln lo"><p id="c611" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="in">有些厂商不接受 OTLP 格式的数据，这意味着您需要使用一个</em> <a class="ae jz" href="https://opentelemetry.io/registry/?language=go&amp;component=exporter" rel="noopener ugc nofollow" target="_blank"> <em class="in">特定于厂商的导出器</em> </a> <em class="in">来向他们发送数据。</em></p></blockquote><p id="029b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们这样配置我们的导出器:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e52d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="c21a" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">将<code class="fe nq nr ns nt b">endpoint</code>设置为<code class="fe nq nr ns nt b">ingest.lightstep.com:443</code>，指向 Lightstep 的公共微卫星池。如果您使用的是内部卫星池，请查看这些文档。</li><li id="feb9" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">您必须用自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank">光步访问令牌</a>为<code class="fe nq nr ns nt b">&lt;LS_ACCESS_TOKEN&gt;</code>提供一个值。</li><li id="17ca" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">我们正在通过 gRPC 向 Lightstep 发送数据。如果您希望使用 HTTP 而不是 gRPC，您的客户端连接将类似于下面的代码片段。请注意我们是如何添加额外的配置选项<code class="fe nq nr ns nt b">WithURLPath</code>的。这个配置选项允许我们<a class="ae jz" href="https://pkg.go.dev/go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp#WithURLPath" rel="noopener ugc nofollow" target="_blank">覆盖发送跟踪的默认 URL 路径</a>。<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/exporter.md#endpoint-urls-for-otlphttp" rel="noopener ugc nofollow" target="_blank">默认值为</a><code class="fe nq nr ns nt b">/v1/traces</code>；但是，对于 HTTP 连接，Lightstep 期望这个值是<code class="fe nq nr ns nt b">traces/otlp/v0.9</code>。</li></ul><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="afd0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3-配置 TracerProvider </strong></p><p id="e6f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个<code class="fe nq nr ns nt b">TracerProvider</code>作为 OpenTelemetry API 的入口点。它提供对<code class="fe nq nr ns nt b">Tracer</code> s 的访问。A <code class="fe nq nr ns nt b">Tracer</code>负责创建一个<a class="ae jz" href="https://opentelemetry.io/docs/concepts/observability-primer/#spans" rel="noopener ugc nofollow" target="_blank"> Span </a>来跟踪给定的操作。</p><p id="e03c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们这样配置我们的 TracerProvider:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1dd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="c0c0" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">我们定义了一个<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/sdk.md" rel="noopener ugc nofollow" target="_blank">资源</a>来为 OpenTelemetry 提供一系列标识我们服务的信息。这包括像<code class="fe nq nr ns nt b">serviceName</code>和<code class="fe nq nr ns nt b">serviceVersion</code>这样的东西，都是 Lightstep 需要设置的。顾名思义，<code class="fe nq nr ns nt b">serviceName</code>是您正在检测的微服务的名称。</li><li id="9b03" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated"><code class="fe nq nr ns nt b">sdktrace.WithBatcher</code>告诉 OpenTelemetry 使用<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#batching-processor" rel="noopener ugc nofollow" target="_blank"> BatchSpanProcessor </a>。就是说批量导出数据。出于这个例子的目的，我们并没有做什么特别的事情。</li></ul><p id="bc9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4-初始化导出器和 TracerProvider 向 Lightstep </strong>发送数据</p><p id="b3db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们终于准备好向 Lightstep 发送数据了！我们通过从我们的<code class="fe nq nr ns nt b">main</code>函数调用上面的<code class="fe nq nr ns nt b">newExporter</code>和<code class="fe nq nr ns nt b">newTraceProvider</code>函数来做到这一点:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="84e3" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">试试看！</h2><p id="ee02" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">让我们来看看运行中的代码示例。在这个例子中，我们将运行一个带有<code class="fe nq nr ns nt b">/ping</code>端点的<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/opentelemetry/otlp/server/server.go" rel="noopener ugc nofollow" target="_blank">服务器</a>。服务器将 OTel 数据通过 gRPC 经由 OTLP 直接发送给 Lightstep。我们将使用<code class="fe nq nr ns nt b">curl</code>到达终点。</p><p id="61e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1-克隆回购</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="a08d" class="nc lv in nt b gy ny nz l oa ob">git clone git@github.com:lightstep/opentelemetry-examples.git</span></pre><p id="5fcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-打开终端窗口并运行服务器程序</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="b49b" class="nc lv in nt b gy ny nz l oa ob">cd opentelemetry-examples/go/opentelemetry/otlp/server export LS_ACCESS_TOKEN = &lt;your_access_token&gt; <br/>go run server.go</span></pre><p id="6b93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保用您自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>替换<code class="fe nq nr ns nt b">&lt;your_access_token&gt;</code></p><p id="7356" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3-打开一个新的终端窗口并点击端点</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="4597" class="nc lv in nt b gy ny nz l oa ob">curl http://localhost:8081/ping</span></pre><p id="2c1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器输出和<code class="fe nq nr ns nt b">curl</code>命令的并列示例输出:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/ec1f86a0f7684fbd83f1e2ffaddaca7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7woY67mnHATw0kDsXHOrsQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">server.go 和 curl 输出的屏幕截图。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><p id="c175" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4-在 Lightstep </strong>中查看</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/d5133cf954293211cc8ca6f0fba32924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXiEh-36FrCCBoE6HCxftA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Lightstep 中我们服务的示例输出。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><blockquote class="lm ln lo"><p id="89dc" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="in">想运行 HTTP 版？将步骤 2 中的</em> <code class="fe nq nr ns nt b"><em class="in">go run server.go</em></code> <em class="in">替换为</em> <code class="fe nq nr ns nt b"><em class="in">go run server-http.go</em></code> <em class="in">。</em></p></blockquote><h1 id="66e6" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">打开遥测收集器</h1><p id="e2e1" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">向可观测性后端发送数据的下一种方法是通过<a class="ae jz" href="https://opentelemetry.io/docs/collector" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry Collector </a>。对于非开发设置，这是将 OpenTelemetry 数据发送到可观测性后端的推荐方法。</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/0a16930c8e671a29831684860195bb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgPYdMooFV9gm-CXZv2maw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">应用程序通过 OTel 收集器向 Lightstep 发送 OpenTelemetry 数据。由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener">阿德里·维莱拉</a>绘制。</figcaption></figure><p id="5e08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要通过收集器将测量数据发送到可观察性后端，我们必须执行以下操作:</p><ul class=""><li id="9fe2" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">让 OpenTelemetry Collector 实例在某个地方运行(在本地运行它是最简单的)</li><li id="529f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">安装所需的 OpenTelemetry 包，并导入它们</li><li id="a085" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">配置导出器</li><li id="7524" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">配置 TracerProvider</li><li id="cae3" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">初始化导出程序和跟踪程序提供程序</li></ul><p id="baab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来和直接进场差不多，不是吗？<em class="lp">差不多</em> …</p><p id="1e25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们很快会谈到不同之处。</p><h2 id="0d8d" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">它是如何工作的</h2><p id="217b" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated"><strong class="kc io"> 1-安装所需的 OTel 库</strong></p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7529" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些是<strong class="kc io"> <em class="lp">将数据发送到可观察性后端(如 Lightstep) </em> </strong>所需的库。</p><p id="a5cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的应用程序代码中，我们需要导入相同的库:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0a99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您希望使用 HTTP 而不是 gRPC，请用<code class="fe nq nr ns nt b">otlptracehttp</code>替换<code class="fe nq nr ns nt b">otlptracegrpc</code>。</p><p id="b657" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-配置导出器</strong></p><p id="1ce1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在直接示例中看到的，我们通过 OTLP 导出我们的数据(查看返回类型如何是<code class="fe nq nr ns nt b">otlptrace.Exporter</code>)。不同之处在于，我们不是将数据直接导出到 Lightstep，而是将数据导出到 OTel 收集器，OTel 收集器也会以 OTLP 格式从我们的应用程序中获取 OTel 数据。</p><p id="45af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的直接例子中，在我们可以创建一个新的导出器之前，我们首先需要创建一个新的跟踪客户端(<code class="fe nq nr ns nt b">otlptracegrpc.NewClient</code>)，这样我们就可以告诉 OpenTelemetry <em class="lp">如何</em>向 Lightstep 发送数据。当我们使用收集器时，我们不需要这样做，因为收集器会使用<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/collector/vanilla/collector.yml" rel="noopener ugc nofollow" target="_blank">收集器配置 YAML </a>中的信息在后台为我们创建一个跟踪客户端。</p><p id="009b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们这样配置我们的导出器:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a311" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="d2ea" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated"><code class="fe nq nr ns nt b">endpoint</code>是你收藏者的网址。</li><li id="0147" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">在下面的例子中，收集器<code class="fe nq nr ns nt b">endpoint</code>被设置为<code class="fe nq nr ns nt b">localhost:4317</code>，这意味着 OpenTelemetry 收集器<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/collector/vanilla/readme.md" rel="noopener ugc nofollow" target="_blank">在本地运行，使用 Docker </a>，监听 gRPC 端口<code class="fe nq nr ns nt b">4317</code>。</li><li id="475c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">您不需要提供<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>作为此配置的一部分，因为该值已在<a class="ae jz" href="https://lightstep.com/blog/observability-mythbusters-how-hard-is-it-to-get-started-with-opentelemetry#running-the-webstore-app-locally" rel="noopener ugc nofollow" target="_blank"> OTel 收集器的</a>配置<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/collector/vanilla/collector.yml" rel="noopener ugc nofollow" target="_blank"> YAML 文件</a>中设置。</li><li id="01fe" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">请注意<code class="fe nq nr ns nt b">WithInsecure</code>选项已设置。如果您正在使用收集器，并且仅当收集器中未配置证书时，这是必需的。(那是改天的博文。😜)</li></ul><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b3bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3-配置 TracerProvider </strong></p><p id="2225" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe nq nr ns nt b">TracerProvider</code>与我们在直接示例中配置的相同:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="49c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4-初始化导出器和 TracerProvider 向 Lightstep 发送数据</strong></p><p id="6763" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们终于准备好向 Lightstep 发送数据了！我们通过从我们的<code class="fe nq nr ns nt b">main</code>函数调用上面的<code class="fe nq nr ns nt b">newExporter</code>和<code class="fe nq nr ns nt b">newTraceProvider</code>函数来做到这一点:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="292f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，这与我们在直接示例中看到的相同。只有<code class="fe nq nr ns nt b">newExporter</code>函数中的底层代码不同。</p><h2 id="0379" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">试试看！</h2><p id="3ab9" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">让我们来看看运行中的代码示例。在这个例子中，我们将运行一个具有<code class="fe nq nr ns nt b">/ping</code>端点的<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/opentelemetry/collector/server/server.go" rel="noopener ugc nofollow" target="_blank">服务器</a>。服务器将通过收集器，在 gRPC 上向 Lightstep 发送 OTel 数据。我们将使用<code class="fe nq nr ns nt b">curl</code>到达终点。</p><p id="fe6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1-克隆回购</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="0443" class="nc lv in nt b gy ny nz l oa ob">git clone git@github.com:lightstep/opentelemetry-examples.git</span></pre><p id="43db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-运行收集器</strong></p><p id="d0eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开一个新的终端窗口。首先，您需要编辑<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/collector/vanilla/collector.yml" rel="noopener ugc nofollow" target="_blank"> collector.yaml </a>文件。请务必用您自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>替换<code class="fe nq nr ns nt b">${LIGHTSTEP_ACCESS_TOKEN}</code>。</p><p id="421c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在您可以启动收集器了:</p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="454b" class="nc lv in nt b gy ny nz l oa ob">cd opentelemetry-examples/collector/vanilla<br/>docker run -it --rm -p 4317:4317 -p 4318:4318 \<br/>    -v $(pwd)/collector.yaml:/otel-config.yaml \<br/>    --name otelcol otel/opentelemetry-collector-contrib:0.53.0  \<br/>    "/otelcol-contrib" \<br/>    "--config=otel-config.yaml"</span></pre><blockquote class="lm ln lo"><p id="be73" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意</strong> <em class="in">:如果是第一次提取收集器图像，这可能需要一点时间。</em></p></blockquote><p id="e048" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">样本输出:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/8eea9c2783ab77d91ada2ce4b612d118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8jtE7T4j3rDxy4sjhLC5w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">OTel 收集器启动序列。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><p id="6b3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开一个新的终端窗口并运行服务器程序</p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="21c9" class="nc lv in nt b gy ny nz l oa ob">cd opentelemetry-examples/go/opentelemetry/collector/server<br/>go run server.go</span></pre><p id="a248" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4-打开第三个终端窗口并点击端点</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="238b" class="nc lv in nt b gy ny nz l oa ob">curl http://localhost:8081/ping</span></pre><p id="f98b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器输出和<code class="fe nq nr ns nt b">curl</code>命令的并列示例输出:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/da5ecb22876c27d6e97d89efae0fef6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*winnhZ6NBStT40NZe3sQ7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">server.go 和 curl 输出的屏幕截图。图片由 Adri Villela 提供。</figcaption></figure><p id="0fcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的收集器输出应该如下所示:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/e03d64158c960ee9a1a73d67ddeeb7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLfyZcp6qMUGgv-dbaKL1w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">样本收集器输出。图片由 Adri Villela 提供。</figcaption></figure><p id="1dc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 5-在 Lightstep </strong>中查看</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/4e819d545b6593cf24e77fc62aaa7457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfLFg904w8oStgN2NdJesw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Lightstep 中我们服务的示例输出。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><h1 id="9211" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">发射者</h1><p id="f62f" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">我们今天要探索的最后一种方法是启动器。如果你已经通读了<a class="ae jz" href="https://lightstep.com/blog/opentelemetry.io/docs" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry docs </a>并且没有看到任何地方提到发射器，那是因为它们本身不是 OTel 的一部分。</p><p id="c5e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以将启动器视为 OTel SDKs 的包装器。发射器最初是由这里的一些天才工程师在<a class="ae jz" href="https://lightstep.com/blog/lightstep.com" rel="noopener ugc nofollow" target="_blank"> Lightstep </a>创建的，以提供一种封装 OpenTelemetry 设置和配置的方法。简而言之，发布者是因为厌倦了复制 SDK 设置代码而诞生的。再一次，开发商懒惰为赢！(郑重声明，我坚信开发人员的懒惰造就了伟大的软件。我们只是讨厌重复！)启动器还增加了一层验证，让用户更好地理解所有必需的参数。关于发射器的更多信息，请查看<a class="ae jz" href="https://lightstep.com/blog/opentelemetry-launchers-what-they-solve-and-why-we-need-them" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，作者<a class="ae jz" href="https://twitter.com/tedsuo" rel="noopener ugc nofollow" target="_blank">泰德·杨</a>。</p><p id="af5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们目前有用于<a class="ae jz" href="https://github.com/lightstep/otel-launcher-go" rel="noopener ugc nofollow" target="_blank"> Go </a>、<a class="ae jz" href="https://github.com/lightstep/otel-launcher-python" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae jz" href="https://github.com/lightstep/otel-launcher-java" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae jz" href="https://github.com/lightstep/otel-launcher-node" rel="noopener ugc nofollow" target="_blank"> Node 的启动器。JS </a>。</p><p id="09cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了……现在我们明白了为什么存在启动器，让我们看看如何使用它们向 Lightstep 发送 OTel 数据。</p><p id="1925" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们必须做到以下几点:</p><ul class=""><li id="b29c" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">安装所需的 OpenTelemetry 和启动器包，并导入它们</li><li id="1954" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">配置启动器</li><li id="2413" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">初始化启动器</li></ul><p id="cc92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来和其他两个例子有点不同，不是吗？如您所见，启动器负责配置和初始化导出器和 TracerProvider。</p><p id="75c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们开始吃吧。</p><blockquote class="lm ln lo"><p id="7ab5" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><em class="in">你可以在 gRPC </em> <a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/launcher/server/server.go" rel="noopener ugc nofollow" target="_blank"> <em class="in">这里</em> </a> <em class="in">看到使用 Go 启动器通过收集器向 Lightstep 发送 OTel 数据的完整示例。直接(通过发射器)版本可以在</em> <a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/launcher/server/server-otlp.go" rel="noopener ugc nofollow" target="_blank"> <em class="in">这里</em> </a> <em class="in">找到。</em></p></blockquote><h2 id="8076" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">它是如何工作的</h2><p id="cf1b" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated"><strong class="kc io"> 1-安装所需的 OTel 库</strong></p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="422b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的应用程序代码中，我们需要导入相同的库:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="118a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哼…需要安装和导入的包更少了！</p><p id="99a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-配置启动器</strong></p><p id="a305" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们正在配置启动器，类似于我们配置导出器和 TracerProvider 时所做的。除了它都被封装在这个可爱的<code class="fe nq nr ns nt b">launcher.ConfigureOpentelemetry</code>！超级酷。😎</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7ba8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="b4f1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">将<code class="fe nq nr ns nt b">endpoint</code>设置为<code class="fe nq nr ns nt b">ingest.lightstep.com:443</code>，指向 Lightstep 的公共微卫星池。如果您使用的是内部卫星池，请查看这些文档。</li><li id="705f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">您必须用自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>为<code class="fe nq nr ns nt b">&lt;LS_ACCESS_TOKEN&gt;</code>提供一个值。</li><li id="ce6c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">启动器仅使用 gRPC。老实说，不是交易破坏者。</li></ul><p id="c1de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">啊…这很好，但是如果你想用一个收集器呢？我不是说过这是非开发人员设置的首选方法吗？是的，我确实做了！不用担心，因为您可以使用启动器将 OTel 数据发送到收集器，而不是直接发送到 Lightstep。为此，您只需:</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="02ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3-初始化启动器</strong></p><p id="ca19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们所需要做的就是调用我们的<code class="fe nq nr ns nt b">newLauncher</code>函数，我们就完成了！</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3660" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总的来说，与其他两种 sans-Launcher 方法相比，Launcher 方法需要较少的代码。</p><h2 id="691b" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">试试看！</h2><p id="9f91" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">让我们来看看运行中的代码示例。在这个例子中，我们将运行一个具有<code class="fe nq nr ns nt b">/ping</code>端点的<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/go/launcher/server/server.go" rel="noopener ugc nofollow" target="_blank">服务器</a>。服务器将使用 Go 启动器通过收集器，在 gRPC 上向 Lightstep 发送 OTel 数据。我们将使用<code class="fe nq nr ns nt b">curl</code>到达终点。</p><p id="ee00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1-克隆回购</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="10da" class="nc lv in nt b gy ny nz l oa ob">git clone <a class="ae jz" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:lightstep/opentelemetry-examples.git</span></pre><p id="75a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2-运行收集器</strong></p><p id="f138" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开一个新的终端窗口。首先，你需要编辑<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/collector/vanilla/collector.yaml" rel="noopener ugc nofollow" target="_blank"> collector.yaml </a>文件。确保用自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>替换<code class="fe nq nr ns nt b">${LIGHTSTEP_ACCESS_TOKEN}</code>。</p><p id="6891" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在您可以启动收集器了:</p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="3b48" class="nc lv in nt b gy ny nz l oa ob">cd opentelemetry-examples/collector/vanilla<br/>docker run -it --rm -p 4317:4317 -p 4318:4318 \<br/>    -v $(pwd)/collector.yaml:/otel-config.yaml \<br/>    --name otelcol otel/opentelemetry-collector-contrib:0.53.0  \<br/>    "/otelcol-contrib" \<br/>    "--config=otel-config.yaml"</span></pre><blockquote class="lm ln lo"><p id="da55" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意</strong> <em class="in">:如果你是第一次绘制收集器图像，这可能需要一点时间。</em></p></blockquote><p id="3fdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">样本输出:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/8eea9c2783ab77d91ada2ce4b612d118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8jtE7T4j3rDxy4sjhLC5w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">OTel 收集器启动序列。图片由 Adri Villela 提供。</figcaption></figure><p id="db1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3-打开一个新的终端窗口并运行服务器程序</strong></p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="436e" class="nc lv in nt b gy ny nz l oa ob">cd opentelemetry-examples/go/launcher/server<br/>go run server.go</span></pre><h2 id="3f9f" class="nc lv in bd lw nd ne dn ma nf ng dp me kl nh ni mi kp nj nk mm kt nl nm mq nn bi translated">4-打开第三个终端窗口并点击端点</h2><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="0dca" class="nc lv in nt b gy ny nz l oa ob">curl http://localhost:8081/ping</span></pre><p id="20b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器输出和<code class="fe nq nr ns nt b">curl</code>命令的并列示例输出:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/92d4cddcc88e2ea66c6696c31078b98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYXyvHaJsbND5gMWI9ch2A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">server.go 和 curl 输出的屏幕截图。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><p id="2f7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的收集器输出应该如下所示:</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/e03d64158c960ee9a1a73d67ddeeb7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLfyZcp6qMUGgv-dbaKL1w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">样本收集器输出。图片由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener"> Adri Villela </a>提供。</figcaption></figure><blockquote class="lm ln lo"><p id="7956" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="in">想用启动器运行直接版？只需跳过第 2 步。在步骤 3 中设置</em> <code class="fe nq nr ns nt b"><em class="in">LS_ACCESS_TOKEN</em></code> <em class="in">环境变量:</em> <code class="fe nq nr ns nt b"><em class="in">export LS_ACCESS_TOKEN=&lt;your_access_token&gt;</em></code> <em class="in">，其中</em> <code class="fe nq nr ns nt b"><em class="in">&lt;your_access_token&gt;</em></code> <em class="in">是自己的</em><a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"><em class="in">light Step Access Token</em></a><em class="in">，并将</em> <code class="fe nq nr ns nt b"><em class="in">go run server.go</em></code> <em class="in">替换为</em> <code class="fe nq nr ns nt b"><em class="in">go run server-otlp.go</em></code> <em class="in">。</em></p></blockquote><p id="2e62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我尝试这三种方法时，我遇到了一些问题，所以我想在这里分享一下。</p><p id="fc33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">gRPC 是我存在的祸根。尤其是看到那个可爱的<code class="fe nq nr ns nt b">context deadline exceeded</code>消息的时候。它使我热血沸腾。幸运的是，我在 Lighstep 的 OTel 朋友告诉了我两个漂亮的小旗，它们使 gRPC 调试变得稍微容易一些:</p><p id="db61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设置这些美丽的东西，如果您不能连接到您的 gRPC 端点，您将相对快速地知道。成功的连接看起来是这样的:</p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="8cb7" class="nc lv in nt b gy ny nz l oa ob">2022/07/26 16:28:36 Using default LS endpoint ingest.lightstep.com:443 2022/07/26 16:28:36 INFO: [core] [Channel #1] Channel created 2022/07/26 16:28:36 INFO: [core] [Channel #1] original dial target is: "ingest.lightstep.com:443" 2022/07/26 16:28:36 INFO: [core] [Channel #1] parsed dial target is: {Scheme:ingest.lightstep.com Authority: Endpoint:443 URL:{Scheme:ingest.lightstep.com Opaque:443 User: Host: Path: RawPath: ForceQuery:false RawQuery: Fragment: RawFragment:}} 2022/07/26 16:28:36 INFO: [core] [Channel #1] fallback to scheme "passthrough" 2022/07/26 16:28:36 INFO: [core] [Channel #1] parsed dial target is: {Scheme:passthrough Authority: Endpoint:ingest.lightstep.com:443 URL:{Scheme:passthrough Opaque: User: Host: Path:/ingest.lightstep.com:443 RawPath: ForceQuery:false RawQuery: Fragment: RawFragment:}} 2022/07/26 16:28:36 INFO: [core] [Channel #1] Channel authority set to "ingest.lightstep.com:443" 2022/07/26 16:28:36 INFO: [core] [Channel #1] Resolver state updated: { "Addresses": [ { "Addr": "ingest.lightstep.com:443", "ServerName": "", "Attributes": null, "BalancerAttributes": null, "Type": 0, "Metadata": null } ], "ServiceConfig": null, "Attributes": null } (resolver returned new addresses) 2022/07/26 16:28:36 INFO: [core] [Channel #1] Channel switches to new LB policy "pick_first" 2022/07/26 16:28:36 INFO: [core] [Channel #1 SubChannel #2] Subchannel created 2022/07/26 16:28:36 Using default service name test-go-client-grpc 2022/07/26 16:28:36 Using default service version 0.1.0 2022/07/26 16:28:36 Using default environment dev 2022/07/26 16:28:36 INFO: [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to CONNECTING 2022/07/26 16:28:36 INFO: [core] [Channel #1 SubChannel #2] Subchannel picks a new address "ingest.lightstep.com:443" to connect 2022/07/26 16:28:36 INFO: [core] pickfirstBalancer: UpdateSubConnState: 0x14000380100, {CONNECTING &lt;nil&gt;} 2022/07/26 16:28:36 INFO: [core] [Channel #1] Channel Connectivity change to CONNECTING Get "http://localhost:8081/ping": dial tcp [::1]:8081: connect: connection refused 2022/07/26 16:28:37 INFO: [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to READY 2022/07/26 16:28:37 INFO: [core] pickfirstBalancer: UpdateSubConnState: 0x14000380100, {READY &lt;nil&gt;} 2022/07/26 16:28:37 INFO: [core] [Channel #1] Channel Connectivity change to READY</span></pre><p id="cd27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在使用启动器，并且您的 Spans 不知道显示在 Lightstep 中，您可以在运行代码之前设置<code class="fe nq nr ns nt b">OTEL_LOG_LEVEL</code>标志:</p><p id="6a1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的调试输出如下所示:</p><pre class="my mz na nb gt nu nt nv nw aw nx bi"><span id="c634" class="nc lv in nt b gy ny nz l oa ob">2022/07/26 15:39:10 debug logging enabled 2022/07/26 15:39:10 configuration 2022/07/26 15:39:10 { "SpanExporterEndpoint": "localhost:4317", "SpanExporterEndpointInsecure": true, "ServiceName": "test-go-client-launcher", "ServiceVersion": "0.1.0", "Headers": null, "MetricExporterEndpoint": "localhost:4317", "MetricExporterEndpointInsecure": true, "MetricExporterTemporalityPreference": "cumulative", "MetricsEnabled": true, "LogLevel": "debug", "Propagators": [ "tracecontext", "baggage" ], ... }</span></pre><p id="1422" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我在 2021 年第一次开始 OTel 之旅时(在我的光步之前的日子里)，我通过<a class="ae jz" href="https://storiesfromtheherd.com/unpacking-observability-the-observability-stack-93d4733e2a72" rel="noopener ugc nofollow" target="_blank"> OTel 收集器</a>将 OTel 数据发送到我的可观测性后端。对我来说，这是显而易见的，因为收藏家可以:</p><ul class=""><li id="3522" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">从多个来源接收数据(包括应用程序和基础架构指标)</li><li id="4706" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">添加/移除元数据</li><li id="ba29" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">分离数据</li><li id="a635" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">抽样资料</li><li id="b0e7" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">同时向多个后端发送数据(如果您正在评估不同的供应商或者从一个供应商过渡到另一个供应商，这非常好)</li></ul><p id="2e1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我个人是收集器的忠实粉丝，我认为在 Pre-Prod/Prod 环境中运行 OTel 收集器以将 OpenTelemetry 数据发送到可观测性后端是一种很好的做法。</p><p id="b3d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是……我不得不承认，我更多的是从运营的角度考虑这个问题，而不是从开发者的角度。</p><p id="fa6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实是，当你开始使用 OTel 时，很可能是从零开始。也就是说，你已经必须弄清楚这整个仪器的事情了。压力已经够大了。再加上试图在这一切之上建立一个收集器，你已经有了太多的移动部件，并且很可能<em class="lp">非常</em>不堪重负的开发人员…即使你用最简单的配置运行它(即，通过 Docker 在本地运行)。还有，当你只是做本地开发的时候，你<em class="lp">真的</em>需要运行一个收集器吗？很可能是得不偿失。</p><p id="c5b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是…我也从个人经验中了解到，通过直接方法连接到可观察性后端是一件极其痛苦的事情。文献非常稀少。例子不完整。不用说，这是一次非常艰难的旅程。我很难同时使用 HTTP 和 gRPC。</p><p id="b4c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以这就引出了一个问题——有什么好的、简单的方法来检测你的代码并将其发送到可观测性后端？这就是发射器发挥作用的地方！因为他们给你两个世界最好的东西。您可以直接连接到您的 Observability 后端，或者您可以通过 OTel 收集器连接。此外，启动程序不限制您使用 Lightstep 作为您的可观察性后端，因为:</p><ol class=""><li id="6839" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">如果您从启动器连接到收集器，收集器会自动为您提供发送到多个可观察性后端的能力</li><li id="b3b4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果你选择直接连接到一个<a class="ae jz" href="https://github.com/lightstep/otel-launcher-go#configure" rel="noopener ugc nofollow" target="_blank">非光步可观测性后端</a>，它接受来自启动器的 OTLP 格式的 OTel 数据</li></ol><p id="3776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不得不承认，在我使用 Go Launcher 之前，我对它是相当怀疑的。毕竟，它不是香草 OTel，这让我想到…“啊哦…供应商锁定！这不正是 OTel 想要避免的吗？”</p><p id="1ac7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是两件事改变了我的想法。首先，事实上你并不局限于一个特定的供应商(见上文)。其次，我们在 Honeycomb 的朋友一直致力于将发射器带到社区中，正如这里所做的工作<a class="ae jz" href="https://github.com/honeycombio/otel-launcher-go/pull/1#issuecomment-1191243498" rel="noopener ugc nofollow" target="_blank">一样</a>，所以发射器可能是(vanilla) OTel 的未来！</p><p id="b57c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的结论是:与同类产品相比，Launcher 由于其灵活性和整体简单性而胜出。</p><p id="539a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经了解了如何通过三种不同的方式向 Lightstep 发送 OTel 数据:</p><ul class=""><li id="7b21" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx lt le lf lg bi translated">直接来自我们的应用程序</li><li id="7913" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">通过 OTel 收集器</li><li id="f125" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx lt le lf lg bi translated">使用启动器，可以将数据直接发送到 Lightstep 或通过收集器发送</li></ul><p id="f93a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在非开发设置中，使用收集器是将数据发送到可观察性后端的首选方式；然而，如果您刚刚开始使用 OTel，将 OTel 数据直接发送到您的可观测性后端是最有意义的，因为您必须处理更少的移动部件。</p><p id="f2d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，使用 vanilla OTel 来做上面的任何一项可能会有点儿力不从心，这就是启动器的用武之地，因为它们抽象了一堆连接性的东西，因此更容易将数据发送到您的可观测性后端，无论是直接发送还是通过收集器发送。</p><p id="77bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">咻！这是一个需要思考和理解的问题！给自己一个鼓励，因为我们已经做了很多！现在，请欣赏这张山羊的照片。</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/67905675029b19040e847d522b6372b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bURbRy-wHXHM8unGPyL3MA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">山羊在加拿大安大略省蓝山吃草。Adri Villela 的照片。</figcaption></figure><p id="2623" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和平、爱和准则。🦄 🌈 💫</p><p id="2e92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关于 Golang OTel 仪器的问题吗？联系我们！通过<a class="ae jz" href="mailto:devrel@lightstep.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或<a class="ae jz" href="https://twitter.com/adrianamvillela" rel="noopener ugc nofollow" target="_blank">推特</a>联系我们。希望收到你们的来信！</p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><p id="b42e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多关于可观察性的文章，请查看我的拆包可观察性系列:</p><div class="os ot gp gr ou"><div role="button" tabindex="0" class="ab bv gv cb fp ov ow bn ox jt ex"><div class="oy l"><div class="ab q"><div class="l di"><img alt="Adri Villela" class="l de bw oz pa fe" src="../Images/e70eedd2981b8eb48ebfa3602f42bc0f.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*rW45is0FCLsRpWvdMdSWpA@2x.jpeg"/><div class="fb bw l oz pa fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">阿德里·维莱拉</p></div></div><div class="pd pe gw l"><h2 class="bd io uk ky fp ul fr fs um fu fw im bi translated">拆包可观察性</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi un au uo up uq qz ur an eh ei us ut uu el em eo de bk ep" href="https://adri-v.medium.com/list/unpacking-observability-be1835c6dd23?source=post_page-----7dfcf2892003--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uv l fo"><span class="bd b dl z dk">18 stories</span></div></div></div><div class="pq dh pr fp ab ps fo di"><div class="di pi bv pj pk"><div class="dh l"><img alt="The image shows an adorable hand drawn cow looking though a telescope right at the reader. The cow is white with brown spots and the background is a cool teal." class="dh" src="../Images/5aef9c378ae90e96cc6cd9f39ac35e30.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*LyzUnNxwRZQQOQFHoeMgkA@2x.jpeg"/></div></div><div class="di pi bv pl pm pn"><div class="dh l"><img alt="" class="dh" src="../Images/b8fc7dec6f2edfa356fab506c8d60c52.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*o5doa7Uuzq22wxoBk88y2A.jpeg"/></div></div><div class="di bv po pp pn"><div class="dh l"><img alt="Brick wall with the words “Look up to the starts” written on it." class="dh" src="../Images/cd448d901f7a1ff196c5ead536c0dac9.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*VEKi7Snzf8J6NfOUdHLmXg.png"/></div></div></div></div></div></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><p id="9072" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lp">最初发表于</em><a class="ae jz" href="https://lightstep.com/blog/observability-mythbusters-send-opentelemetry-data-to-lightstep-3-ways-golang" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://lightstep.com</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>