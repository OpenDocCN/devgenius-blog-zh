<html>
<head>
<title>How To Predict Customer Lifetime Value using Machine Learning in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用 Python 中的机器学习预测客户终身价值</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-predict-customer-lifetime-value-using-machine-learning-in-python-4066344d0ab0?source=collection_archive---------1-----------------------#2022-08-18">https://blog.devgenius.io/how-to-predict-customer-lifetime-value-using-machine-learning-in-python-4066344d0ab0?source=collection_archive---------1-----------------------#2022-08-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0940" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 python、pandas 和 scikit-learn 和 RFM 分析的深入教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c48d0b62dfea50d489eb4b7055304f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A80ZGzZH85ZOWwNZ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">詹·西奥多在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="e57a" class="la lb in bd lc ld le lf lg lh li lj lk jt ll ju lm jw ln jx lo jz lp ka lq lr bi translated"><strong class="ak">简介</strong></h1><p id="50c2" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm mn ig bi translated">你有没有遇到过一大堆顾客，却不知道该怎么对待他们？</p><p id="5e2d" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">了解你的顾客的行为对于充分利用他们的惠顾是必不可少的。今天，我们可以利用大量可用的数据来预测每个客户在某段时间内会给公司带来多少价值。</p><p id="8dd8" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">预测客户未来价值的能力在以下方面很有用:</p><ul class=""><li id="4c7f" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">提供数据驱动的客户级指标，帮助实施将影响业务的前瞻性决策。</li><li id="cc71" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">通过添加另一个维度来执行客户细分，从而丰富客户数据库。</li><li id="5ecd" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">可以进一步预测客户在不同产品类别上的花费。</li><li id="0dbc" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">让企业更多地了解客户的偏好，让他们在技术上更好地迎合他们。</li></ul><p id="3841" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">在本教程中，使用在此处找到的<a class="ae ks" href="https://www.kaggle.com/datasets/marian447/retail-store-sales-transactions" rel="noopener ugc nofollow" target="_blank">、</a>ka ggle 数据集，我们将采取以下步骤:</p><ul class=""><li id="3c8b" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">收集并整合我们的数据。</li><li id="8025" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">使用一种称为递归 RFM(近期-频率-货币值)的技术将我们的数据集转换为丰富的要素。</li><li id="f07e" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">拟合一个可以根据这些数据进行预测的模型。</li></ul><p id="5b58" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">我用来做教程的笔记本可以在这里<a class="ae ks" href="https://colab.research.google.com/drive/1vmb2SxEhotciv6agNqSBVjGfcQCt1rVn?usp=sharing" rel="noopener ugc nofollow" target="_blank">找到</a>。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="4e05" class="la lb in bd lc ld le lf lg lh li lj lk jt ll ju lm jw ln jx lo jz lp ka lq lr bi translated"><strong class="ak">步骤 1:收集数据</strong></h1><p id="f6e3" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm mn ig bi translated">对于我们的客户数据，我们基本上只需要 3 列:客户标识符、交易日期/时间和交易值，我们也可以引入其他功能，但您应该确保在功能工程步骤中按客户聚集它们。我们可以使用日期来提取星期几、月份、小时和所有与每笔交易相关的基于时间的特征。如果有不同类别的交易，也可以引入这些列。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="9b1c" class="nm lb in ni b gy nn no l np nq">import pandas as pd</span><span id="345d" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Load transaction data from CSV</strong><br/>df = pd.read_csv(data_path) # path to your data</span><span id="eee3" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Convert Date column to date-time object</strong><br/>df.Date = pd.to_datetime(df.Date)</span><span id="b007" class="nm lb in ni b gy nr no l np nq">df.head(10)</span></pre><p id="b0ea" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated"><strong class="lu io">输出</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fc76a702cfcd25a74384dc5bb7d21387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*ebI7ZfZ2r6lTLoiZARllQQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">输出</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="5e0c" class="la lb in bd lc ld le lf lg lh li lj lk jt ll ju lm jw ln jx lo jz lp ka lq lr bi translated">步骤 2:特征工程</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/9f912f75867fe59d6db1614f1f95af80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3IhZsM4IRrY_6XIq.png"/></div></div></figure><h2 id="506e" class="nm lb in bd lc nu nv dn lg nw nx dp lk mb ny nz lm mf oa ob lo mj oc od lq oe bi translated">新近性、频率和货币价值(RFM)</h2><p id="d893" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm mn ig bi translated"><a class="ae ks" href="https://farapaper.com/wp-content/uploads/2018/08/Fardapaper-Discovering-recency-frequency-and-monetary-RFM.pdf" rel="noopener ugc nofollow" target="_blank"> RFM </a>是一种以有意义的方式量化客户的方法，在对客户特定的交易数据进行任何分析时，可以作为一个很好的基准。</p><p id="1254" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated"><em class="of">最近度</em>、<em class="of">频率</em>和<em class="of">货币价值</em>捕捉客户最近一次交易的时间、他们返回业务的频率以及每位客户的平均销售额。我们可以通过使用任何其他可用特征(如毛利润、年龄、成本保持)或其他预测特征(流失风险或情绪分析)来增加这一点。我们将在下面讨论如何计算每一项。</p><p id="7551" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">其工作方式是，我们可以将训练数据拆分为一个<strong class="lu io"> <em class="of">观测</em> </strong>期和一个<strong class="lu io"> <em class="of">未来</em> </strong>期。如果我们想预测一个客户在一年中会花多少钱，我们会将<strong class="lu io"><em class="of"/></strong>期的长度设置为一年，其余的时间将归入<strong class="lu io"><em class="of"/></strong><em class="of">(如下所示)。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/f111d109fad452276d4a8b96f1616d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWpxEnyXpTZ6SwEdcRDccA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">观察到的/未来的分裂</figcaption></figure><p id="9ddf" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">这允许我们使用在<strong class="lu io"><em class="of"/></strong>期间计算的特征来拟合模型，以回归在<strong class="lu io"> <em class="of">未来</em> </strong>期间花费的金额。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="dbd6" class="nm lb in ni b gy nn no l np nq"><strong class="ni io"># Data before cut off</strong><br/><strong class="ni io">observed</strong> = df[df[date_col] &lt; cut_off</span><span id="fa01" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Data after cut off</strong><br/><strong class="ni io">future</strong> = df[<br/>(df[date_col] &gt; cut_off) &amp;<br/>(df[date_col] &lt; cut_off + pd.Timedelta(label_period_days, unit='D'))]</span></pre><p id="2fe6" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">这里我们引入截止值的概念。这就是<strong class="lu io"> <em class="of">观察到的</em> </strong>周期结束的地方，并定义了我们应该在什么日期之前计算我们的特征。</p><ul class=""><li id="14ea" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu io">最近:</strong>自最近交易以来的时间(小时/天/周)。我们需要设定一个截止值来计算最近的时间。比如:<em class="of">截止日期后多少天他们做了一笔交易？</em></li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="37f0" class="nm lb in ni b gy nn no l np nq"><strong class="ni io"># Copy transactions</strong><br/>cut_off = df.Date.max()<br/>recency = df[df.Date &lt; cut_off].copy()</span><span id="e2f5" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Group customers by latest transaction</strong><br/>recency = recency.groupby(customer_id_column)[date_column].max()</span><span id="158b" class="nm lb in ni b gy nr no l np nq">recency = (max_date - recency).dt.days).reset_index().rename(<br/>columns={date_column:'recency'})</span></pre><ul class=""><li id="83e0" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu io">频率:</strong>客户进行交易的不同时间段的数量。这将使我们能够跟踪客户进行了多少交易，以及交易发生的时间。我们还可以保留从截止日期开始计算这些指标的做法，因为这在以后会很方便。</li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="b8c7" class="nm lb in ni b gy nn no l np nq"><strong class="ni io"># Copy transactions</strong><br/>cut_off = df.Date.max()<br/>frequency = df[df.Date &lt; cut_off].copy()</span><span id="e734" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Set date column as index</strong><br/>frequency.set_index(date_column, inplace=True)<br/>frequency.index = pd.DatetimeIndex(frequency.index)</span><span id="48f0" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Group transactions by customer key and by distinct period<br/># and count transactions in each period</strong><br/>frequency = frequency.groupby([customer_id_column, pd.Grouper(freq="M", level=date_column)]).count()</span><span id="22f0" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># (Optional) Only count the number of distinct periods a transaction # occurred. Else, we will be calculating total transactions in each # period instead.</strong><br/>frequency[value_column] = 1 # Store all distinct transactions</span><span id="0f21" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Sum transactions</strong><br/>frequency = frequency.groupby(customer_id_column).sum().reset_index().rename(<br/>columns={value_column : 'frequency'})</span></pre><ul class=""><li id="ee1a" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu io">货币价值</strong>:平均销售额。这里我们简单地计算每个客户所有交易的平均销售额。我们可以通过在最后一步中取<strong class="lu io"><em class="of"/></strong>的总和而不是<strong class="lu io"> <em class="of">的平均值</em> </strong>来额外添加一个“TotalAmountSpent”特征。</li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="dc58" class="nm lb in ni b gy nn no l np nq"><strong class="ni io"># Copy transactions</strong><br/>cut_off = df.Date.max()<br/>value = df[df.Date &lt; cut_off].copy()</span><span id="b2e4" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Set date column as index</strong><br/>value.set_index(date_column, inplace=True)<br/>value.index = pd.DatetimeIndex(value.index)</span><span id="2d75" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Get mean or total sales amount for each customer</strong><br/>value = value.groupby(customer_id_column[value_column].mean().reset_index()<br/>.rename(columns={value_column : 'value'})</span></pre><ul class=""><li id="69f5" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu io">年龄:</strong>第一次交易后的时间。对于此功能，我们只需找到每个客户第一次交易后的天数。同样，我们需要一个截止日期来计算截止日期和第一笔交易之间的时间。</li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="1111" class="nm lb in ni b gy nn no l np nq">cut_off = df.Date.max()<br/>age = df[df.Date &lt; cut_off].copy()</span><span id="5b37" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Get date of first transaction</strong><br/>first_purchase = age.groupby(customer_id_column)[date_column].min().reset_index()</span><span id="a180" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Get number of days between cut off and first transaction</strong><br/>first_purchase['age'] = (cut_off - first_purchase[date_column]).dt.days</span></pre><p id="ddc0" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">我们可以用下面的函数将所有这些函数包装在一起:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="6e67" class="nm lb in ni b gy nn no l np nq"><strong class="ni io">def customer_rfm(data, cut_off, date_column, customer_id_column, value_column, freq='M'):</strong></span><span id="d719" class="nm lb in ni b gy nr no l np nq">cut_off = pd.to_datetime(cut_off)</span><span id="6442" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Compute Recency</strong><br/>recency = customer_recency(data, cut_off, date_column, customer_id_column)</span><span id="5a1c" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Compute Frequency</strong><br/>frequency = customer_frequency(data, cut_off, date_column, customer_id_column, value_column, freq=freq)</span><span id="552f" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Compute average value</strong><br/>value = customer_value(data, cut_off, date_column, customer_id_column, value_column)</span><span id="89d5" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Compute age</strong><br/>age = customer_age(data, cut_off, date_column, customer_id_column)</span><span id="6d41" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Merge all columns</strong><br/>return recency.merge(frequency, on=customer_id_column).merge(<br/>on=customer_id_column).merge(age, on=customer_id_column)</span></pre><p id="884d" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">理想情况下，这可以在特定时间段内捕获关于客户保持度<em class="of">的信息。这可能看起来像这样:</em></p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="87f7" class="nm lb in ni b gy nn no l np nq"><strong class="ni io">Customer_ID   recency    frequency            value       age</strong>                                     1                 131            1         8.145000       131                      2                  69            1         7.770000        69                       3                 121            1         3.640000       121                      5                   4            4        14.672500       100</span></pre><p id="0448" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">对于标签，我们只需合计每个客户在<strong class="lu io"> <em class="of">未来</em> </strong>期间的消费金额。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="763d" class="nm lb in ni b gy nn no l np nq">labels = future.groupby(id_col)[value_col].sum()</span></pre><p id="1b97" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">在某些情况下，对整个数据集执行一次这种操作并拟合一个模型来预测标签可以产生可容忍的准确性。但是，如果你仔细观察，你可能会问:<em class="of">如果在观察期间发生了有趣的事情呢？</em>问哪个问题才是正确的。简单地对数据集进行一次这样的操作会忽略数据中的所有季节性，并且只查看一个特定的标签时段。这里我们介绍一下我所说的，<strong class="lu io">递归 RFM </strong>。</p><p id="c30a" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated"><strong class="lu io">递归 RFM </strong></p><p id="51dd" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">预测客户在某段时间内的终身价值的问题可以简化为简单地预测他们在未来<strong class="lu io"><em class="of"/></strong>期间将花费多少。让我们应用到目前为止我们所知道的 RFM，并通过数据集进行循环。</p><p id="9147" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">假设数据在年初从左边开始。我们将选择一个频率(例如，一个月)并遍历数据集，从<strong class="lu io"><em class="of">【o】</em></strong>计算我们的特征，并从<strong class="lu io"> <em class="of">未来(f)生成我们的标签。这个想法是递归地计算这些特征，以便模型了解客户的行为如何随时间变化。</em></strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/1d56e2045cc854cef1d98ba1dadb4581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QjVIhBsvs-GzYkioXywbLw.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">观察的(o)，未来的(f)</figcaption></figure><p id="cb38" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">对于算法的这一部分，我们将首先获取数据集跨度中每个间隔的日期，并使用这些日期中的每个日期作为计算 RFM 要素和标注的截止日期。再次重申，在我们的示例中，我们选择了 1 个月的频率。</p><p id="6362" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">对于每个截止日期(<strong class="lu io"> co </strong>):</p><ul class=""><li id="64ca" class="mt mu in lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">计算截止前(<strong class="lu io"> i </strong> → <strong class="lu io"> co </strong>)所有行的 RFM 特征</li><li id="ebe8" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">计算截止日期和截止日期后一个月之间(<strong class="lu io"> i </strong>)行的标签(<strong class="lu io">co</strong>→<strong class="lu io">I</strong>→<strong class="lu io">co</strong>+<strong class="lu io">频率</strong>)</li><li id="2c01" class="mt mu in lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu io">外部连接</strong>基于客户 ID 创建数据集的功能和标签，以填充未进行任何交易的客户。</li></ul><p id="9c79" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">连接循环中的所有数据集。</p><p id="14ff" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">这在下面的代码中实现:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="b1bd" class="nm lb in ni b gy nn no l np nq"><strong class="ni io">def recursive_rfm(data, date_col, id_col, value_col, freq='M', start_length=30, label_period_days=30):</strong></span><span id="1a02" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Resultant list of datasets</strong><br/>dset_list = []</span><span id="bd60" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Get start and end dates of dataset</strong><br/>start_date = data[date_col].min() + pd.Timedelta(start_length, unit="D")</span><span id="fe36" class="nm lb in ni b gy nr no l np nq">end_date = data[date_col].max() - pd.Timedelta(label_period_days, unit="D")</span><span id="e1e7" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Get dates at desired interval</strong><br/>dates = pd.date_range(<br/>start=start_date, end=end_date, freq=freq<br/>data[date_col] = pd.to_datetime(data[date_col]<br/>)</span><span id="5a77" class="nm lb in ni b gy nr no l np nq">for cut_off in dates:<br/><strong class="ni io">   # split by observed / futur</strong>e<br/>   observed = data[data[date_col] &lt; cut_off<br/>   future = data[<br/>                  (data[date_col] &gt; cut_off) &amp;<br/>                  (data[date_col] &lt; cut_off + pd.Timedelta(<br/>                   label_period_days,  unit='D'))<br/>                ]<br/><strong class="ni io">   # Get relevant columns</strong><br/>   rfm_columns = [date_col, id_col, value_col]<br/>   _observed = observed[rfm_columns] </span><span id="dd51" class="nm lb in ni b gy nr no l np nq"><strong class="ni io">   # Compute features from observed</strong><br/>   rfm_features = customer_rfm(<br/>        _observed, cut_off, date_col, id_col, value_col<br/>   )</span><span id="59cb" class="nm lb in ni b gy nr no l np nq"><strong class="ni io">   # Compute labels from future</strong><br/>   labels = future.groupby(id_col)[value_col].sum()</span><span id="8ec7" class="nm lb in ni b gy nr no l np nq"><strong class="ni io">   # Outer join features with labels to ensure customers <br/>   # not in observed are still recorded with a label of 0<br/>   </strong>dset = rfm_features.merge(<br/>        labels, on=id_col, how='outer'<br/>   ).fillna(0)<br/>   dset_list.append(dset)</span><span id="525f" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Concatenate all datasets</strong><br/>full_dataset = pd.concat(dset_list, axis=0)<br/>res = full_dataset[full_dataset.recency != 0].dropna(axis=1, how='any')</span><span id="36ac" class="nm lb in ni b gy nr no l np nq">return res</span><span id="98be" class="nm lb in ni b gy nr no l np nq">rec_df = recursive_rfm(data_for_rfm, 'Date', 'Customer_ID', 'Sales_Amount')</span></pre><p id="95fa" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">既然我们已经生成了数据集，我们就可以开始建模和预测了！我们现在需要做的就是对我们的结果数据进行洗牌和执行训练/测试分割。我们将 80%用于培训，20%用于测试。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="29d2" class="nm lb in ni b gy nn no l np nq">from sklearn.model_selection import train_test_split</span><span id="c674" class="nm lb in ni b gy nr no l np nq">rec_df = rec_df.sample(frac=1) <strong class="ni io"># Shuffle</strong></span><span id="2e72" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Set X and y</strong><br/>X = rec_df[['recency', 'frequency', 'value', 'age']]<br/>y = rec_df[['Sales_Amount']].values.reshape(-1)</span><span id="c301" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Set test ratio and perform train / test split</strong><br/>test_size = 0.2<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=42, shuffle=True)</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="22f2" class="la lb in bd lc ld le lf lg lh li lj lk jt ll ju lm jw ln jx lo jz lp ka lq lr bi translated"><strong class="ak">第三步:模型</strong></h1><p id="83af" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm mn ig bi translated">当谈到数据科学时，机器学习(及其包含的所有内容)只是一种用于估计变量之间关系的技术。为您的数据找到合适的模型是为您的用例获得最佳结果的另一个旅程。数据科学的真正价值在于使用这些技术在现实世界中做出明智的决策。</p><p id="d469" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">对于这个例子，我们将尝试一个随机森林回归器，因为它们的实现是即插即用的，所以很容易直接尝试。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="403e" class="nm lb in ni b gy nn no l np nq">from sklearn.ensemble import RandomForestRegressor</span><span id="dd64" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Initialize and fit model on train dataset</strong><br/>rf = RandomForestRegressor().fit(X_train, y_train)</span></pre><p id="5795" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">一旦拟合，我们可以在数据框架中查看我们对测试集的预测。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="6b95" class="nm lb in ni b gy nn no l np nq">from sklearn.metrics import mean_squared_error</span><span id="3dd3" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Create Dataframe and populate with predictions and actuals<br/># Train set</strong><br/>predictions = pd.DataFrame()<br/>predictions['true'] = y_train<br/>predictions['preds'] = rf.predict(X_train)</span><span id="7edc" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Test set</strong><br/>predictions_test = pd.DataFrame()<br/>predictions_test['true'] = y_test<br/>predictions_test['preds'] = rf.predict(X_test)</span><span id="5bb8" class="nm lb in ni b gy nr no l np nq"><strong class="ni io"># Compute error</strong><br/>train_rmse = mean_squared_error(predictions.true, predictions.preds)**0.5</span><span id="c239" class="nm lb in ni b gy nr no l np nq">test_rmse = mean_squared_error(predictions_test.true, predictions_test.preds)**0.5</span><span id="b389" class="nm lb in ni b gy nr no l np nq">print(f"Train RMSE: {train_rmse}, Test RMSE: {test_rmse}")</span></pre><p id="cc10" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">输出:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="a1b7" class="nm lb in ni b gy nn no l np nq"><strong class="ni io">Train RMSE</strong>: 10.608368028113563, <strong class="ni io">Test RMSE</strong>: 28.366171873961612</span></pre><p id="0794" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">由于我们有一个回归任务，让我们使用均方根误差(RMSE)作为我们的误差度量，它将分别针对训练数据和测试数据的预测进行计算。这通过以下公式计算:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/32f8db6e695b684cb943e3b73458e389.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/0*LOa0NnZjjTP2eGCv.jpg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">均方根误差方程</figcaption></figure><p id="21fa" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">测试 RMSE 约为 28.4，这意味着我们对未知数据的预测误差约为 28.40 美元。此外，我们的列车 RMSE 明显低于我们的测试 RMSE，表明过度拟合。换句话说，它过于依赖训练数据来进行预测，并且正在努力根据它以前从未见过的数据进行预测。对于一个人来说，这类似于“封闭思维”，他需要学会在数据中寻找关系，这些关系可以概括为看不见的数据。绘制出我们的结果，我们可以看到有一些改进的余地。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/dc4bc1c07e9afde96a82265c934c0715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*hUOcbwRFKPI_laMDBYSmbw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">预计支出与实际支出</figcaption></figure><p id="b325" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">在这个阶段，我们可能会执行一些超参数调优，或者尝试不同的模型，看看什么对我们的数据表现最好。像 H2O 汽车公司这样的工具可以让你为一项任务尝试 10 种甚至 100 种车型。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="7553" class="la lb in bd lc ld le lf lg lh li lj lk jt ll ju lm jw ln jx lo jz lp ka lq lr bi translated">结论</h1><p id="1cb4" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm mn ig bi translated">尽管如此，我们发现了一种以有意义的方式量化客户的方法，这种方法也可以用于其他任务，包括客户细分或流失风险。我们能够在工程数据上拟合一个机器学习模型，以预测客户在给定时间段内的支出。这只是使用客户数据来提高客户参与度和忠诚度的众多方法之一，尤其是在与上述任务一起使用的情况下。</p><p id="cba2" class="pw-post-body-paragraph ls lt in lu b lv mo jo lx ly mp jr ma mb mq md me mf mr mh mi mj ms ml mm mn ig bi translated">非常感谢您阅读我的文章，请务必关注我，了解我即将发布的文章。我正在计划一个完整的系列，强调以有洞察力和强有力的方式利用客户数据的不同方式。</p></div></div>    
</body>
</html>