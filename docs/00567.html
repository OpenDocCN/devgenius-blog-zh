<html>
<head>
<title>Implicit and Explicit Operators — C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐式和显式运算符— C#</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implicit-and-explicit-operators-c-30d28fb573e0?source=collection_archive---------2-----------------------#2020-06-11">https://blog.devgenius.io/implicit-and-explicit-operators-c-30d28fb573e0?source=collection_archive---------2-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d4b1ebe3c262dd8277c25266b517b92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Htv4TmiVQ6KAXNek"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@rosiefoto13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗西·斯泰格勒斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="ec26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左边还是右边？你总是有比看得见的更多的选择。有时您需要将一些对象转换为另一种类型。例如，当您想要将一个域实体映射到它的 DTO(数据传输对象)时。假设您有 30 个域实体和另外 30 个 DTO 实体，每个域实体一个。每种类型的实体都有一个方法将这些对象转换成它的 DTO。这是我会想到的第一个选择。</p><h1 id="46cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果我们有办法自动完成这种转换会怎么样？</h1><p id="5582" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">会很棒的，对吧？是的。我向您展示 C#的<strong class="kf ir">隐式</strong>和<strong class="kf ir">显式</strong>运算符。他们的目标是简化一个类的转换过程。让我们看一些代码。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4514" class="mn lc iq mj b gy mo mp l mq mr">public class MessageTableEntity<br/>{<br/>    public Guid Id { get; set; }<br/>    public string Message { get; set; }<br/>    public string CreatedBy { get; set; }<br/>}</span><span id="4d9f" class="mn lc iq mj b gy ms mp l mq mr">public class MessageDto<br/>{<br/>    public string Id { get; set; }<br/>    public string Message { get; set; }<br/>}</span></pre><p id="8496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以 DTO 类不需要看到谁创建了消息，假设这是私有信息，我们不想让它可见。对于表实体和 DTO 之间的任何转换，我们将进行如下操作:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6edc" class="mn lc iq mj b gy mo mp l mq mr">public MessageDto ConvertToDto(MessageTableEntity tableEntity)<br/>{<br/>    MessageDto dto = new MessageDto<br/>    {<br/>        Id = tableEntity.Id.ToString(),<br/>        Message = tableEntity.Message<br/>     };<br/>    return dto;<br/>}</span></pre><p id="d4a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们需要对具有多个属性的类进行多次这样的操作，这将是一项非常枯燥的工作。不需要有几个方法来进行类之间的映射。</p><h1 id="7192" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们如何定义隐式和显式运算符？</h1><p id="23b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这种情况下，我将在<code class="fe mt mu mv mj b">MessageTableEntity</code> <strong class="kf ir"> </strong>和<code class="fe mt mu mv mj b">MessageDto</code>之间进行转换，但是不要忘记，您可以定义这个操作符来从 DTO 转换到表实体。</p><h2 id="2bb0" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">含蓄的</h2><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="66d0" class="mn lc iq mj b gy mo mp l mq mr">public class MessageTableEntity<br/>{<br/>    public Guid Id { get; set; }<br/>    public string Message { get; set; }<br/>    public string CreatedBy { get; set; }</span><span id="44e5" class="mn lc iq mj b gy ms mp l mq mr"><strong class="mj ir">    public static implicit operator MessageDto(<br/>                                       MessageTableEntity entity)<br/>    {<br/>        return new MessageDto<br/>        {<br/>            Id = entity.Id.ToString(),<br/>            Message = entity.Message<br/>        };<br/>    }</strong><br/>}</span></pre><h2 id="9a04" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">明确的</h2><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="01be" class="mn lc iq mj b gy mo mp l mq mr">public class MessageTableEntity<br/>{<br/>    public Guid Id { get; set; }<br/>    public string Message { get; set; }<br/>    public string CreatedBy { get; set; }</span><span id="fe00" class="mn lc iq mj b gy ms mp l mq mr">    <strong class="mj ir">public static explicit operator MessageDto(<br/>                                       MessageTableEntity entity)<br/>    {<br/>        return new MessageDto<br/>        {<br/>            Id = entity.Id.ToString(),<br/>            Message = entity.Message<br/>        };<br/>    }</strong><br/>}</span></pre><p id="a539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码基本相同，唯一的变化是所用操作符的名称。</p><h1 id="bc88" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何使用？</h1><p id="ee61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设我们有下面的<code class="fe mt mu mv mj b">MessageTableEntity</code>实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f491" class="mn lc iq mj b gy mo mp l mq mr">MessageTableEntity tableEntity = new MessageTableEntity<br/>{<br/>    Id = Guid.NewGuid(),<br/>    Message = "Test message",<br/>    CreatedBy = "User_ABC"<br/>};</span></pre><h2 id="0410" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">使用隐式运算符</h2><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8c17" class="mn lc iq mj b gy mo mp l mq mr">MessageDto dto = tableEntity;</span></pre><h2 id="5c08" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">使用显式运算符</h2><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e472" class="mn lc iq mj b gy mo mp l mq mr">MessageDto dto = (MessageDto)tableEntity;</span></pre><p id="72ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显式转换类似于强制转换操作。我们使我们要将对象转换成的类型可见。隐式运算符，如果你不知道存在一个隐式定义，就不太容易理解。</p><h1 id="f488" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我可以同时定义两个运算符吗？</h1><p id="1c14" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不可以。您只能定义一个运算符。如果定义了<strong class="kf ir">显式操作符</strong>，那么<strong class="kf ir">只能显式转换对象</strong>。然而，如果你定义了<strong class="kf ir">隐式操作符</strong>，你可以用两种方式<strong class="kf ir">使用它，隐式和显式</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3d95" class="mn lc iq mj b gy mo mp l mq mr">MessageDto dto = tableEntity;<br/>MessageDto dto = (MessageDto)tableEntity;</span></pre><p id="81ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子，<strong class="kf ir">这是可能的，因为我们在<code class="fe mt mu mv mj b">MessageTableEntity</code>和<code class="fe mt mu mv mj b">MessageDto</code>之间定义了隐式操作符</strong>。现在是你的选择了，你可以选择你认为最适合你的情况的方法。</p><h1 id="4c59" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果我有一个不同类的转换怎么办？</h1><p id="5dd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">是的，有可能。给定了<code class="fe mt mu mv mj b">MessageTableEntiy</code>类，假设我们也想要一个到<code class="fe mt mu mv mj b">string</code>的隐式转换。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27e2" class="mn lc iq mj b gy mo mp l mq mr">public class MessageTableEntity<br/>{<br/>    public Guid Id { get; set; }<br/>    public string Message { get; set; }<br/>    public string CreatedBy { get; set; }</span><span id="5b71" class="mn lc iq mj b gy ms mp l mq mr"><strong class="mj ir">    </strong>public static implicit operator MessageDto(<br/>                                       MessageTableEntity entity)<br/>    {<br/>        return new MessageDto<br/>        {<br/>            Id = entity.Id.ToString(),<br/>            Message = entity.Message<br/>        };<br/>    }</span><span id="ce72" class="mn lc iq mj b gy ms mp l mq mr">    <strong class="mj ir">public static implicit operator string(<br/>                                       MessageTableEntity entity)<br/>    {<br/>        return entity.Message;<br/>    }</strong><br/>}</span></pre><p id="9422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以进行以下转换:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3080" class="mn lc iq mj b gy mo mp l mq mr">MessageDto dto = tableEntity;<br/>MessageDto dto = (MessageDto)tableEntity;<br/><strong class="mj ir">string message = tableEntity;</strong></span></pre><h1 id="b8c7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e85f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们有一个解决方案，其中类之间的转换通常要进行多次时，这些操作符为我们提供了一个新的选择。含蓄也好，明示也好，都没关系，这是你自己的喜好。记住隐式操作符为您提供的多功能性，也不要忘记显式操作符为您提供的最佳控制，因为转换类的代码更加清晰可见。</p></div></div>    
</body>
</html>