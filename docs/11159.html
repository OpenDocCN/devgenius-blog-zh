<html>
<head>
<title>Top 5 SQL Commands for Data engineers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程师的 5 大 SQL 命令</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-5-sql-commands-for-data-engineers-5258afd936dd?source=collection_archive---------16-----------------------#2022-12-21">https://blog.devgenius.io/top-5-sql-commands-for-data-engineers-5258afd936dd?source=collection_archive---------16-----------------------#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="180b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你需要在 2022 年掌握</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/073b7382d53146e681bfb414abd30981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSfz0KKgf1JFHq4sNVycBA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">《穿越红海》创世纪人工对抗 NFT <a class="ae kv" href="https://artspaces.kunstmatrix.com/en/exhibition/10702025/genesis-artificial-adversarial-network-gaan" rel="noopener ugc nofollow" target="_blank">系列</a>菲利普·布阿齐兹</figcaption></figure><p id="791c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">作为数据工程师，SQL(结构化查询语言)是管理和操作存储在关系数据库管理系统(RDBMS)中的数据的重要工具。</span></p><p id="5382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQL 是一种概念性语言，用于处理存储在数据库中的数据。在我们的例子中，SQLite 是具体的实现。在这个用户案例中，我们将使用 SQLLite 来编写查询。数据表设计是使用数据库时的一个关键步骤。在许多情况下，数据库被分成许多存储在不同位置的表。</p><p id="d147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我们将介绍对数据工程师最有用的五个 SQL 命令:</p><p id="7344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。选择</strong></p><p id="05ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令用于从数据库中检索数据。它允许您指定要检索的列和行，并应用各种过滤器和条件来优化结果。</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="ba4e" class="mg mh iq mc b be mi mj l mk ml">#Imports<br/><br/>import pandas as pd <br/>import sqlite3<br/>import matplotlib.pyplot as plt<br/><br/>#Insert path here<br/><br/>path = "../input/"  <br/>database = path + 'database.sqlite'</span></pre><p id="708d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询很简单，我们需要创建一个到数据库的连接，并按如下方式检查表:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="afc6" class="mg mh iq mc b be mi mj l mk ml">db = sqlite3.connect(database)<br/><br/>tables = pd.read_sql("""SELECT *<br/>                        FROM sqlite_master<br/>                        WHERE type='table';""", db)<br/>tables</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/37c268a4379ae716d5f20689ed7e66df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wb40EYWbkb5iRml_ldEaPA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联赛表(图片由作者提供)</figcaption></figure><p id="26b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以检查我们的数据集，您可以在这里找到关于这个<a class="ae kv" href="https://opendatacommons.org/licenses/odbl/1-0/" rel="noopener ugc nofollow" target="_blank">开源</a>数据集<a class="ae kv" href="https://www.kaggle.com/datasets/hugomathien/soccer" rel="noopener ugc nofollow" target="_blank">的更多细节</a>:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="cd99" class="mg mh iq mc b be mi mj l mk ml">countries = pd.read_sql("""SELECT *<br/>                        FROM Country;""", db)<br/>countries</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/1bc98c16715406ff27670c64bace7ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZaV47jej-E9tuvCwfKR1g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联盟国家(图片由作者提供)</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="f2e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。加入</strong></p><p id="c839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 SQL 中，联接是一种基于两个或多个表之间的相关列来组合它们中的行的方法。SQL 中有几种可用的连接类型，包括:</p><p id="d789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">a.内部连接:这种连接只返回两个表中匹配的行。例如,“customers”表和“orders”表之间的“customer_id”列的内部联接将只返回两个表中都存在“customer_id”的行。</p><p id="7376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">b.外部联接:这种类型的联接返回两个表中的所有行，包括在另一个表中不匹配的任何行。有三种类型的外部联接:左联接、右联接和完全外部联接。</p><p id="345a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">c.交叉连接:这种类型的连接返回两个表中行的所有可能的组合。它也称为笛卡尔连接。</p><p id="48d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是 SQL 中内部联接的一个示例:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="f3d0" class="mg mh iq mc b be mi mj l mk ml">SELECT c.*, o.*<br/>FROM customers c<br/>INNER JOIN orders o<br/>ON c.customer_id = o.customer_id</span></pre><p id="ccf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将返回“customers”和“orders”表中“customer_id”列匹配的所有行。结果表将包括“客户”和“订单”表中的所有列。</p><p id="3322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们尝试一个更复杂的“足球”数据集:</p><p id="d124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的用户案例中，最常见的是:</p><ul class=""><li id="6780" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">(内部)联接-仅保留两个表中符合条件(on 之后)的记录，以及两个表中的记录</li><li id="fd6a" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">左连接-保留第一个(左)表中的所有值，以及右表中的匹配行。右表中的列，如果在左表中没有匹配的值，就会有空值。</li><li id="40f8" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">指定用于连接表的公共值(在这种情况下是国家的 ID)。</li><li id="c9ef" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">在我们的例子中，它是 country . id。league . country _ id 不是唯一的，每个国家可以有多个联赛。</li></ul><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="dbf6" class="mg mh iq mc b be mi mj l mk ml">leagues = pd.read_sql("""SELECT *<br/>                        FROM League<br/>                        JOIN Country ON Country.id = League.country_id;""", db)<br/>leagues</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/ef8fcf317c89042f98b19f0e2eac9053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ft_yZGgBw3GrOLprXAiGA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联赛新表格(图片由作者提供)</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="5dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。排序依据</strong></p><p id="1f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQL 中的 ORDER BY 子句用于按升序或降序对 SELECT 语句的结果进行排序。默认情况下，ORDER BY 子句按升序对结果进行排序。要按降序对结果进行排序，可以使用 DESC 关键字。</p><p id="52ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在 SQL 中使用 ORDER BY 子句的示例:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="4d91" class="mg mh iq mc b be mi mj l mk ml">SELECT *<br/>FROM customers<br/>ORDER BY last_name ASC, first_name ASC</span></pre><p id="bd0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将返回“customers”表中按“last_name”列升序排序，然后按“first_name”列升序排序的所有行。</p><p id="3105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以在 SELECT 语句中指定一个特定位置，用作排序键。例如:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="4a32" class="mg mh iq mc b be mi mj l mk ml">SELECT last_name, first_name<br/>FROM customers<br/>ORDER BY 1 ASC, 2 ASC</span></pre><p id="8833" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将从“customers”表中返回“last_name”和“first_name”列，先按“last_name”列升序排序，然后再按“first_name”列升序排序。</p><p id="d064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以将 ORDER BY 子句与 LIMIT 子句结合使用，以返回按特定顺序排序的一定数量的行。</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="5f5f" class="mg mh iq mc b be mi mj l mk ml">SELECT *<br/>FROM customers<br/>ORDER BY last_name DESC<br/>LIMIT 10</span></pre><p id="b271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将返回“customers”表中按“last_name”列降序排序的前 10 行。</p><p id="0ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在下面的代码中尝试使用我们的足球联盟数据集:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="ca9b" class="mg mh iq mc b be mi mj l mk ml">teams = pd.read_sql("""SELECT *<br/>                        FROM Team<br/>                        ORDER BY team_long_name<br/>                        LIMIT 5;""", db)<br/>teams</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/abbc065b004f7102564f5c74b18a3818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgqTRBtcz3vSLWRwQ3CasQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联赛按功能排序(图片由作者提供)</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="be29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。作为</strong></p><p id="8a79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 SQL 中，AS 关键字用于为列或表达式提供一个临时名称。这通常用于使结果表更易于阅读，或者为复杂的表达式起一个更有意义的名字。</p><p id="4334" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在 SQL 中使用 AS 关键字的示例:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="7670" class="mg mh iq mc b be mi mj l mk ml">SELECT c.first_name || ' ' || c.last_name AS full_name, o.order_date<br/>FROM customers c<br/>JOIN orders o<br/>ON c.customer_id = o.customer_id</span></pre><p id="aa80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此示例中，AS 关键字用于为表达式“c.first_name || ' ' || c.last_name”提供临时名称“full_name”。结果表将包括“全名”和“订单日期”列。</p><p id="57b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以使用 AS 关键字在 SELECT 语句中重命名列:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="66ca" class="mg mh iq mc b be mi mj l mk ml">SELECT c.customer_id AS id, c.first_name, c.last_name<br/>FROM customers c</span></pre><p id="460e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此示例中，AS 关键字用于将“customer_id”列重命名为“id”。</p><p id="99f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，AS 关键字在大多数 SQL 方言中是可选的。只需指定临时名称或新列名称，而不使用 AS 关键字，就可以获得相同的结果。但是，使用 AS 关键字可以使您的 SQL 语句更易读、更容易理解。让我们尝试重命名足球数据集中的一些列:</p><p id="5400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们需要把关于两个不同值的信息(home_team_api_id，away_team_api_id)连接到同一个表中。</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="584c" class="mg mh iq mc b be mi mj l mk ml">dt_matches = pd.read_sql("""SELECT Match.id, <br/>                                        Country.name AS country_name, <br/>                                        League.name AS league_name, <br/>                                        season, <br/>                                        stage, <br/>                                        date,<br/>                                        HT.team_long_name AS  home_team,<br/>                                        AT.team_long_name AS away_team,<br/>                                        home_team_goal, <br/>                                        away_team_goal                                        <br/>                                FROM Match<br/>                                JOIN Country on Country.id = Match.country_id<br/>                                JOIN League on League.id = Match.league_id<br/>                                LEFT JOIN Team AS HT on HT.team_api_id = Match.home_team_api_id<br/>                                LEFT JOIN Team AS AT on AT.team_api_id = Match.away_team_api_id<br/>                                WHERE country_name = 'Spain'<br/>                                ORDER by date<br/>                                LIMIT 5;""", db)<br/>dt_matches</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/338d89fe4e4afb955b5721ed4aadbf90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSKKygQ2MFozeihDkCMx5A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联赛的功能(图片由作者提供)</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="8159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5。分组依据</strong></p><p id="aa10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 SQL 中，GROUP BY 子句用于按一列或多列对 SELECT 语句的结果进行分组。GROUP BY 子句通常与 COUNT、AVG、SUM 和 MAX 等聚合函数结合使用，对分组数据执行计算。</p><p id="f0b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在 SQL 中使用 GROUP BY 子句的示例:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="b30b" class="mg mh iq mc b be mi mj l mk ml">SELECT COUNT(*), customer_id<br/>FROM orders<br/>GROUP BY customer_id</span></pre><p id="17ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将返回每个 customer_id 的所有订单的计数。结果表将包括两列:“COUNT(*)”和“customer_id”。</p><p id="b57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以对多列使用 GROUP BY 子句:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="0f4d" class="mg mh iq mc b be mi mj l mk ml">SELECT COUNT(*), customer_id, order_date<br/>FROM orders<br/>GROUP BY customer_id, order_date</span></pre><p id="6896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此示例中，结果将按“customer_id”和“order_date”列进行分组。</p><p id="ab79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以将 HAVING 子句与 GROUP BY 子句结合使用，根据指定的条件筛选分组结果。</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="6059" class="mg mh iq mc b be mi mj l mk ml">SELECT COUNT(*), customer_id<br/>FROM orders<br/>GROUP BY customer_id<br/>HAVING COUNT(*) &gt; 5</span></pre><p id="2172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将返回每个 customer_id 的所有订单的计数，但仅针对下了 5 个以上订单的客户。</p><p id="b7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，GROUP BY 子句必须用在 SELECT 和 WHERE 子句之后，ORDER BY 子句之前。</p><p id="8744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将这些知识应用到我们的足球分析数据集:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="700b" class="mg mh iq mc b be mi mj l mk ml">leages_by_season = pd.read_sql("""SELECT Country.name AS country_name, <br/>                                        League.name AS league_name, <br/>                                        season,<br/>                                        count(distinct stage) AS number_of_stages,<br/>                                        count(distinct HT.team_long_name) AS number_of_teams,<br/>                                        avg(home_team_goal) AS avg_home_team_scors, <br/>                                        avg(away_team_goal) AS avg_away_team_goals, <br/>                                        avg(home_team_goal-away_team_goal) AS avg_goal_dif, <br/>                                        avg(home_team_goal+away_team_goal) AS avg_goals, <br/>                                        sum(home_team_goal+away_team_goal) AS total_goals                                       <br/>                                FROM Match<br/>                                JOIN Country on Country.id = Match.country_id<br/>                                JOIN League on League.id = Match.league_id<br/>                                LEFT JOIN Team AS HT on HT.team_api_id = Match.home_team_api_id<br/>                                LEFT JOIN Team AS AT on AT.team_api_id = Match.away_team_api_id<br/>                                WHERE country_name in ('Spain', 'Germany', 'France', 'Italy', 'England')<br/>                                GROUP BY Country.name, League.name, season<br/>                                HAVING count(distinct stage) &gt; 10<br/>                                ORDER BY Country.name, League.name, season DESC<br/>                                ;""", db)<br/>leages_by_season</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/35e71b0d5dce8bea0c4d7c47ef810b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCD3oy2Nw-M8jQHCnkj2rA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联赛分组和功能(图片由作者提供)</figcaption></figure><p id="1fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解这个新数据集，我们来做一些分析:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="49d7" class="mg mh iq mc b be mi mj l mk ml">df = pd.DataFrame(index=np.sort(leages_by_season['season'].unique()), columns=leages_by_season['country_name'].unique())<br/><br/>df.loc[:,'Spain']   = list(leages_by_season.loc[leages_by_season['country_name']=='Spain','avg_goals'])<br/>df.loc[:,'France']   = list(leages_by_season.loc[leages_by_season['country_name']=='France','avg_goals'])<br/>df.loc[:,'Italy']   = list(leages_by_season.loc[leages_by_season['country_name']=='Italy','avg_goals'])<br/>df.loc[:,'England']   = list(leages_by_season.loc[leages_by_season['country_name']=='England','avg_goals'])<br/><br/>df.plot(figsize=(14,10),title='The Average Numbers of  Goals per Game')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/1c60b36ed5a341b87c725adabcbf7601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYOrdOEdz-Ne371jrJZXtQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">足球联盟分析(图片由作者提供)</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="0cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">总结</strong></p><p id="2400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是每个 SQL 子句最常见顺序的简要总结:</p><ol class=""><li id="f4aa" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr nn nb nc nd bi translated">SELECT:SELECT 子句用于指定要从数据库中检索的列。</li><li id="c8f6" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">FROM:FROM 子句用于指定要从中检索数据的一个或多个表。</li><li id="2066" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">JOIN:JOIN 子句用于根据两个或多个表之间的相关列来组合它们的行。SQL 中有几种类型的连接，包括内部连接、外部连接和交叉连接。</li><li id="198b" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">WHERE:WHERE 子句用于对 SELECT 语句的结果应用过滤器。它允许您指定要将某一行包含在结果中所必须满足的条件。</li><li id="fac3" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">GROUP BY:GROUP BY 子句用于按一列或多列对 SELECT 语句的结果进行分组。它通常与 COUNT、AVG、SUM 和 MAX 等聚合函数结合使用。</li><li id="2f7a" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">HAVING:HAVING 子句用于根据指定的条件过滤 SELECT 语句的分组结果。它与 GROUP BY 子句一起使用。</li><li id="2af3" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">ORDER BY:ORDER BY 子句用于按升序或降序对 SELECT 语句的结果进行排序。</li><li id="2116" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nn nb nc nd bi translated">LIMIT:LIMIT 子句用于限制 SELECT 语句返回的行数。它通常与 ORDER BY 子句结合使用，以返回按特定顺序排序的一定数量的行。</li></ol><p id="8ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要定义 SQL 中经常使用的子查询:</p><p id="efa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> SQL 子查询</strong></p><p id="4994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQL 中，子查询是嵌套在另一个 SELECT、INSERT、UPDATE、DELETE 或 SET 语句中的 SELECT 语句。子查询通常用于从多个表中检索数据，或者对返回的数据执行计算。</p><p id="e115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是 SQL 中子查询的一个示例:</p><pre class="kg kh ki kj gt mb mc md bn me mf bi"><span id="f12f" class="mg mh iq mc b be mi mj l mk ml">SELECT *<br/>FROM customers<br/>WHERE customer_id IN (SELECT customer_id<br/>                     FROM orders<br/>                     WHERE order_date &gt; '2022-01-01')</span></pre><p id="73a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此示例中，子查询“SELECT customer_id FROM orders WHERE order_date &gt; ' 2022–01–01 '”用于从 order _ date 在 2022 年之后的“orders”表中检索所有 customer _ id 值。然后，外部查询使用 IN 运算符，根据子查询结果中是否存在 customer_id 来筛选“customers”表中的行。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="33f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论</strong></p><p id="e26e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQL(结构化查询语言)是处理数据库的强大而必要的工具。它允许您创建、修改和查询数据库中的数据，以及控制对该数据的访问。从小型个人数据库到大型企业系统，SQL 被广泛应用。无论您是初学者还是有经验的数据库专家，学习和掌握 SQL 都是一项重要的技能。通过练习和坚持，您可以精通 SQL，并使用它来有效地管理和分析数据。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="cc84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如有任何问题，欢迎在下方留言，继续探索:-)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0be7315f4f249877cb9fe00e360d390e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*3YE8txJMb1XsbLFIjsEfpQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Philippe Bouaziz (Pele)的“ArtemisMoonSuite”NFT<a class="ae kv" href="https://opensea.io/collection/opensuite-project" rel="noopener ugc nofollow" target="_blank">系列</a>(图片由作者提供)</figcaption></figure><p id="f052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想支持请购买我的<a class="ae kv" href="https://opensea.io/collection/opensuite-project" rel="noopener ugc nofollow" target="_blank"> nft 的</a>或<a class="ae kv" href="https://www.redbubble.com/people/PeleB/shop?asc=u" rel="noopener ugc nofollow" target="_blank">产品</a>，关注并分享:-)</p></div></div>    
</body>
</html>