<html>
<head>
<title>Making a modern JS library in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年打造现代JS图书馆</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/making-a-modern-js-library-in-2020-8718b086fa59?source=collection_archive---------3-----------------------#2020-11-05">https://blog.devgenius.io/making-a-modern-js-library-in-2020-8718b086fa59?source=collection_archive---------3-----------------------#2020-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e40705b7c341c0b97737a974e82b9c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kHitXQXbC4mHFoAE.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">回购现代hello world</figcaption></figure><p id="60a1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最近，我被分配了一个任务，创建一个新的JS库来替换已经发布了近8年的过时的库。这是一个相当艰巨的任务，因为我也被允许尝试一切新的东西，使这个项目更加稳健。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="7c4d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="le">最初发表于</em><a class="ae lf" href="https://pitayan.com/posts/modernest-lib-hello-world/" rel="noopener ugc nofollow" target="_blank"><em class="le">【https://pitayan.com】</em></a><em class="le">。</em></p><div class="lg lh gp gr li lj"><a href="https://pitayan.com/posts/modernest-lib-hello-world/?ref=medium" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">打造2020年的现代JS图书馆——皮塔扬</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">最近，我被分配了一个任务，创建一个新的JS库来替换已经发布的过时的JS库…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">pitayan.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jt lj"/></div></div></a></div></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="9da9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我想到的第一件事是让自己有一个复杂但很棒的“开发环境”,它准确而生动地解释了为什么我是DX的第一个开发者。</p><p id="fd9e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我将展示我是如何用一个小小的“hello-world”repo实现它的。</p><p id="fa52" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为什么大惊小怪？值得吗？</p><p id="400d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设你在打仗，大队长只给你刺刀和敌人战斗。当你的敌人使用机枪时，你认为你敢向前冲锋吗？我敢打赌，我们99%的人都没有足够的勇气这么做(请不要告诉我你愿意为荣耀而死)。</p><p id="c407" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么，如果营长给了你最致命的武器，只需轻轻一击就能击败你的敌人，就像灭霸的弹指一样，那又会怎样呢？我想现在你有勇气对抗敌人了。</p><p id="0398" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">无论如何，我想成为那个为我的队友提供致命武器的大队长，以消除我们开发中的痛苦部分。当我们的发展成为一种快乐的体验时，我相信来回移动东西的忙乱绝对是值得的。</p><p id="f0e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，这是我的演示回购的链接:</p><p id="21ca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae lf" href="https://github.com/daiyanze/modern-hello-world" rel="noopener ugc nofollow" target="_blank">https://github.com/daiyanze/modern-hello-world</a></p><h1 id="555e" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">灵感</h1><p id="3bb7" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">为了让我们伟大的新图书馆成为一个真正的现代图书馆，我一直在研究各种现代JS repos。</p><p id="61fe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我发现所有这些库都有一个共同点:</p><blockquote class="nb nc nd"><p id="9797" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">他们都碰巧将Jest或Mocha/Chai作为他们的测试套件。</em></p></blockquote><p id="c9c6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">事实上，Jest和Mocha/Chai已经在市场上存在多年了，它们相当稳固。即使有一些像Ava.js这样的新来者，但他们仍然不能取代目前有更大社区的人。</p><p id="e677" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">选择社区较大的图书馆已经是一个常识。因为他们的代码正在被许多其他人测试，并且有更多的错误修正。一句话:几乎没有人有足够的勇气去使用那些没有经过彻底测试的库。</p><blockquote class="nb nc nd"><p id="d463" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">如何知道一个图书馆是否有很大的社区？</em></p></blockquote><p id="9b6e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单，只要查查他们有没有很多Github明星或者问题。“Stars”通常意味着这个库是合格的，并且被开发人员所接受。“问题”在一定程度上反映了社区的互动性和图书馆的活跃性。这两个指标对于我们的技术选择应该非常可靠。</p><p id="0c2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我会从Github中选择那些有很多明星和问题的工具作为我们的devDependencies。</p><h1 id="98c9" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">依赖性特征</h1><p id="d0bd" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">以下是我们新项目的一些mayjor(“必须”)特性。在我看来，这些特性已经成为2020年新的JS库的技术选择标准。</p><h2 id="1d35" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">1.以打字打的文件</h2><p id="19b9" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">编写没有类型的代码实际上是一件痛苦的事情，如果我们没有提前考虑我们的数据类型，“类型错误”肯定会出现。所以现在，因为Typescript已经成为几乎所有新诞生的JS库的标准或约定。毫无疑问，这个特性对我们的项目来说是“必须的”。</p><h2 id="3b5c" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">2.玩笑</h2><p id="9fb6" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">测试是JS项目不可或缺的另一个东西。我相信没有一个团队领导会选择一项甚至自己都没有测试过的技术。所以Jest肯定是我们测试所需要的工具，正如你所知道的，他们有一个很大的社区。</p><h2 id="c98d" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">3.较美丽</h2><p id="5121" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">统一团队的编码风格可以节省时间。当你拜访你的队友时，这是最重要的。</p><p id="26ce" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一次看到这个工具是2017年。当时，公开市场上几乎没有JS代码格式化程序。嗯，更漂亮的使它可用。您可以按照您希望的方式格式化代码。</p><p id="d7d4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更重要的是，在ESlinter或TSlinter的帮助下，编辑器可以成为JS开发人员非常酷的东西。</p><p id="453a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">采用这些工具的原因很简单，因为:</p><blockquote class="nb nc nd"><p id="7599" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated">他们给你提示！</p></blockquote><p id="56c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">只要看看7年前创建的<a class="ae lf" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb的javascript风格指南</a>，你就会知道代码风格有多重要。</p><h2 id="089b" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">4.哈士奇和传统-变更日志</h2><p id="ac3b" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">我想每个人都有以下贪得无厌的愿望。</p><blockquote class="nb nc nd"><p id="3a17" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">我希望我的项目能自动吐出变更日志。我希望提交格式可以统一。祝… </em></p></blockquote><p id="786b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些工具对你来说可能听起来很陌生。但是它们实际上是一个很好的组合，可以基于git提交消息自动生成稳定的变更日志。Angular project正在使用这种方法来创建更好的变更日志。</p><p id="cc13" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看看Angular的美丽日志:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="cd1c" class="nh lz in ny b gy oc od l oe of">11.0.0-next.3 (2020-09-23)</span><span id="db21" class="nh lz in ny b gy og od l oe of">Bug Fixes</span><span id="c51e" class="nh lz in ny b gy og od l oe of">common: add params and reportProgress options to HttpClient.put() overload (#37873) (dd8d8c8), closes #23600<br/>compiler-cli: generate let statements in ES2015+ mode (#38775) (123bff7)<br/>core: ensure TestBed is not instantiated before override provider (#38717) (c8f056b)<br/>forms: type NG_VALUE_ACCESSOR injection token as array (#29723) (2b1b718), closes #29351<br/>Features</span><span id="296c" class="nh lz in ny b gy og od l oe of">common: Add ISO week-numbering year formats support to formatDate (#38828) (984ed39)<br/>compiler: Parse and recover on incomplete opening HTML tags (#38681) (6ae3b68), closes #38596<br/>router: add migration to update calls to navigateByUrl and createUrlTree with invalid parameters (#38825) (7849fdd), closes #38227<br/>service-worker: add the option to prefer network for navigation requests (#38565) (a206852), closes #38194<br/>BREAKING CHANGES</span><span id="b53c" class="nh lz in ny b gy og od l oe of">core: If you call TestBed.overrideProvider after TestBed initialization, provider overrides are not applied. This behavior is consistent with other override methods (such as TestBed.overrideDirective, etc) but they throw an error to indicate that, when the check was missing in the TestBed.overrideProvider function. Now calling TestBed.overrideProvider after TestBed initialization also triggers an error, thus there is a chance that some tests (where TestBed.overrideProvider is called after TestBed initialization) will start to fail and require updates to move TestBed.overrideProvider calls before TestBed initialization is completed.</span></pre><blockquote class="nb nc nd"><p id="6c8f" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated">不要自己写变更日志就好。让机器来处理它们。</p></blockquote><p id="1e4b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，这4个工具基本上是我作为一个“DX-first”开发者非常非常渴望的特性。当然，还有其他一些不错的功能，但我认为目前已经足够了。毕竟，新的更多的工具将增加我们每个成员的学习时间。</p><h1 id="120b" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">“汇总”</h1><p id="e13a" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">当我在构建我的存储库的原型时，我从未想过汇总会是对我最大的挑战。Rollup有一个很棒的文档，只要看一下例子，你就会明白它希望你立即做什么。但是真正的问题在于我应该如何处理我的输出文件。</p><p id="2557" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为我的输出是一个库，所以我需要将所有的源代码汇总到一个可以在浏览器中使用的JS文件中(或者Node.js)。这可以很容易地用一些插件完成。我对这个神奇的工具相当陌生，这个工具已经为Vue和React等最著名的框架提供了动力。</p><p id="a4a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">坦白说，我不太清楚自己下一步该怎么走。</p><p id="c462" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了省去来回移动的步骤，我放弃了探索汇总配置。可以想象，一个“菜鸟”不可能从零开始创造出“伟大”的东西。</p><p id="fc45" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那好吧。让我试试另一种方法。</p><blockquote class="nb nc nd"><p id="23f8" class="jz ka le kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated">如果我不知道怎么做，那么别人应该知道。</p></blockquote><p id="db3d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Vue和React已经把功课做好了，剩下的就是我抄袭他们了:d .(很自豪自己是个抄袭者~)</p><p id="ed1a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我选择<a class="ae lf" href="https://github.com/vuejs/vue-next" rel="noopener ugc nofollow" target="_blank"> Vue 3.0 </a>作为我的目标回购，因为这是一个相当新的项目。而Vue目前拥有非常高的人气。</p><p id="abdb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它的配置有点复杂，但仍然非常容易理解。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="6ab5" class="nh lz in ny b gy oc od l oe of">// Part of rollup.config.js in Vue-next repo</span><span id="6975" class="nh lz in ny b gy og od l oe of">import path from 'path'<br/>import ts from 'rollup-plugin-typescript2'<br/>import replace from '<a class="ae lf" href="http://twitter.com/rollup/plugin-replace" rel="noopener ugc nofollow" target="_blank">@rollup/plugin-replace</a>'<br/>import json from '<a class="ae lf" href="http://twitter.com/rollup/plugin-json" rel="noopener ugc nofollow" target="_blank">@rollup/plugin-json</a>'</span><span id="3eb1" class="nh lz in ny b gy og od l oe of">if (!process.env.TARGET) {<br/>  throw new Error('TARGET package must be specified via --environment flag.')<br/>}</span><span id="9305" class="nh lz in ny b gy og od l oe of">const masterVersion = require('./package.json').version<br/>const packagesDir = path.resolve(__dirname, 'packages')<br/>const packageDir = path.resolve(packagesDir, process.env.TARGET)<br/>const name = path.basename(packageDir)<br/>const resolve = p =&gt; path.resolve(packageDir, p)<br/>const pkg = require(resolve(`package.json`))<br/>const packageOptions = pkg.buildOptions || {}</span><span id="6c6e" class="nh lz in ny b gy og od l oe of">// ensure TS checks only once for each build<br/>let hasTSChecked = false</span><span id="c52e" class="nh lz in ny b gy og od l oe of">const outputConfigs = {<br/>  'esm-bundler': {<br/>    file: resolve(`dist/${name}.esm-bundler.js`),<br/>    format: `es`<br/>  },<br/>  ...<br/>}<br/>...</span></pre><p id="20a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在探索了<a class="ae lf" href="https://github.com/vuejs/vue-next" rel="noopener ugc nofollow" target="_blank"> Vue 3.0 </a>配置文件<code class="fe oh oi oj ny b">rollup.config.js</code>之后，我发现它只做了3件事:</p><ul class=""><li id="d2e7" class="ok ol in kb b kc kd kg kh kk om ko on ks oo kw op oq or os bi translated">通过另一个脚本接收命令行参数</li><li id="cd2b" class="ok ol in kb b kc ot kg ou kk ov ko ow ks ox kw op oq or os bi translated">为不同类型的生成生成配置列表</li><li id="8598" class="ok ol in kb b kc ot kg ou kk ov ko ow ks ox kw op oq or os bi translated">导出配置列表</li></ul><p id="c589" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">仅仅通过复制和粘贴，我就创建了一个具有上述特性的自定义汇总配置文件。但我更换了一个汇总插件，因为我个人更喜欢官方包。</p><p id="27df" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Vue提供了各种类型的构建，我认为这是明智之举，因为用户会有不同的开发目的和环境。</p><p id="e46d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们可以看到Vue基于JS代码的输出格式提供了以下类型的构建输出(<code class="fe oh oi oj ny b">es</code> &amp; <code class="fe oh oi oj ny b">cjs</code> &amp; <code class="fe oh oi oj ny b">iife</code>)。文件名中带有<code class="fe oh oi oj ny b">prod</code>的文件用于生产目的:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="5522" class="nh lz in ny b gy oc od l oe of">vue.cjs.js <br/>vue.cjs.prod.js <br/>vue.d.ts <br/>vue.esm-browser.js <br/>vue.esm-browser.prod.js <br/>vue.esm-bundler.js <br/>vue.global.js <br/>vue.global.prod.js <br/>vue.runtime.esm-browser.js <br/>vue.runtime.esm-browser.prod.js <br/>vue.runtime.esm-bundler.js <br/>vue.runtime.global.js <br/>vue.runtime.global.prod.js</span></pre><p id="353f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望这种方法可以应用在我们的项目中。类似但不同的是，文件名中带有<code class="fe oh oi oj ny b">dev</code>的构建输出是用于开发的。</p><p id="35ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更重要的是，我们并不像Vue那样通过判断是否是<code class="fe oh oi oj ny b">runtime</code>来区分不同的版本。所以下面的输出是最终目标。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="dd4a" class="nh lz in ny b gy oc od l oe of">helloworld.cjs.js <br/>helloworld.cjs.dev.js <br/>helloworld.d.ts <br/>helloworld.esm.js <br/>helloworld.esm.dev.js <br/>helloworld.js <br/>helloworld.dev.js <br/>helloworld.modern.js <br/>helloworld.modern.dev.js</span></pre><p id="f0ee" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里是<code class="fe oh oi oj ny b">rollup.config.js</code> : <a class="ae lf" href="https://github.com/daiyanze/modern-hello-world/blob/master/rollup.config.js" rel="noopener ugc nofollow" target="_blank"> modern-hello-wrold汇总配置</a>的链接。</p><p id="c5b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe oh oi oj ny b">TLDR;</code>...但是要有耐心:p。</p><h1 id="9a00" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">我的汇总配置的一些问题</h1><h2 id="225b" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">1.类型检查问题</h2><p id="5c06" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">似乎即使我希望一次只构建一个包，Typescript也会检查monorepo中的所有包，不管它们是否依赖于构建目标。</p><p id="e6da" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，在构建多个包时，类型检查可能会发生多次。我能听到我的粉丝在制作过程中很忙。(这完全没有必要)</p><p id="c139" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Vue 3.0使用了一个标志来禁用重复类型检查，而我没有。我不太确定这是不是一个好方法。但它肯定会影响我们的开发甚至生产构建。</p><h2 id="c8c3" class="nh lz in bd ma ni nj dn me nk nl dp mi kk nm nn mm ko no np mq ks nq nr mu ns bi translated">2.报关出口问题</h2><p id="4e36" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">我的helloworld使用相同的工具(API-Extractor)和Vue配置从源代码中提取类型声明。我使用的是不同的Typescript插件。重新升级建筑声明输出，我需要将<code class="fe oh oi oj ny b">tsconfig.json</code>参数<code class="fe oh oi oj ny b">declaration</code>传递给那个插件。</p><p id="bf01" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很明显，不是我干的。因为我固执地认为没有<code class="fe oh oi oj ny b">declaration</code>的建筑会稍微快一点。这可能是个错误的想法。无论如何，我应该稍后优化这一部分。</p><h1 id="b93a" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">“构建”脚本</h1><p id="03c0" class="pw-post-body-paragraph jz ka in kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw ig bi translated">我认为Vue project在“构建”过程中相当聪明。他们直接使用命令和<a class="ae lf" href="https://github.com/sindresorhus/execa" rel="noopener ugc nofollow" target="_blank"> execa </a>来避免使用可编程API。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="92bd" class="nh lz in ny b gy oc od l oe of">execa(<br/>  'rollup',<br/>  [<br/>    '-wc',<br/>    '--environment',<br/>    [<br/>      `NODE_ENV:development`,<br/>      ...<br/>    ]<br/>      .filter(Boolean)<br/>      .join(','),<br/>  ],<br/>  {<br/>    stdio: 'inherit',<br/>  }<br/>);</span></pre><p id="2436" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">execa给了我们直接使用这些farmiliar命令的经验，只要把这些片段重新组合在一起。依我看，这让事情变得简单多了。</p><p id="12f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我曾经考虑过使用Rollup APIs来处理构建。但看了一下官方文件后，我意识到这是一个愚蠢的想法。这让我感觉像是强迫一个只会弹3个和弦的吉他新手在大型音乐会上打节奏。</p><p id="18c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简而言之:有时候，妥协是一个让事情变得更简单的好主意。</p><p id="1186" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为我希望使它成为一个“Monorepo”，<code class="fe oh oi oj ny b">packages/</code>文件夹包含了所有必要的内置模块。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="458c" class="nh lz in ny b gy oc od l oe of"># In the demo repo, we have 2 modules in total<br/>packages/<br/>  helloworld/<br/>    src/<br/>      index.ts<br/>    index.js<br/>    package.json<br/>  shared/<br/>    src/<br/>      print.ts<br/>    index.js<br/>    package.json</span></pre><p id="e4b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe oh oi oj ny b">shared</code>模块就像普通repo中的<strong class="kb io">助手</strong>或<strong class="kb io">实用程序</strong>，但是它是作为一个包使用的，所以我可以像使用第三方库一样导入它。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="01f6" class="nh lz in ny b gy oc od l oe of">import { print } from '<a class="ae lf" href="http://twitter.com/helloworld/shared" rel="noopener ugc nofollow" target="_blank">@helloworld/shared</a>'</span><span id="7a4d" class="nh lz in ny b gy og od l oe of">function helloWorld() {<br/>  if (__DEV__) {<br/>    print("It's under development")<br/>  }<br/>  print('hello world')<br/>}</span></pre><p id="03d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我个人倾向于在包前加上前缀<code class="fe oh oi oj ny b">@&lt;global_module_name&gt;</code>的命名约定。这使得我所有的模块看起来非常统一。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="09e1" class="nh lz in ny b gy oc od l oe of">{<br/>  "name": "<a class="ae lf" href="http://twitter.com/helloworld/shared" rel="noopener ugc nofollow" target="_blank">@helloworld/shared</a>"<br/>  ...<br/>}</span></pre><p id="90d2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我发现<a class="ae lf" href="https://github.com/vuejs/vue-next" rel="noopener ugc nofollow" target="_blank"> Vue 3.0 </a> repo使用<code class="fe oh oi oj ny b">NODE_ENV</code>来定义目标commonjs模块(因为<code class="fe oh oi oj ny b">require</code>上下文通常会忽略节点环境)。这将有助于用户相应地包含正确的脚本。</p><p id="522d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在每个模块的根目录中，我复制并粘贴了<a class="ae lf" href="https://github.com/vuejs/vue-next" rel="noopener ugc nofollow" target="_blank"> Vue 3.0 </a>如何通过添加一个新的入口文件来处理它的commonjs模块。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="6733" class="nh lz in ny b gy oc od l oe of">// packages/helloworld/index.js<br/>'use strict'</span><span id="7ba0" class="nh lz in ny b gy og od l oe of">if (process.env.NODE_ENV === 'production') {<br/>  module.exports = require('./dist/helloworld.cjs.js')<br/>} else {<br/>  module.exports = require('./dist/helloworld.cjs.dev.js')<br/>}</span></pre><p id="a89d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我的例子中，<code class="fe oh oi oj ny b">helloworld.cjs.js</code>和<code class="fe oh oi oj ny b">helloworld.cjs.dev.js</code>的区别在于它是否包含下面的代码块，这些代码块只为开发脚本服务。(不得不说，Rollup“摇树”让我大开眼界)</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="94ad" class="nh lz in ny b gy oc od l oe of">...<br/>// "if (__DEV__)" is treeshaked by Rollup</span><span id="5165" class="nh lz in ny b gy og od l oe of">{<br/>  print('It\'s under development')<br/>}<br/>...</span></pre><p id="6261" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这几个星期对Vue 3.0库的调查中，我想我已经发现了足够多的新鲜事物来学习。没有他们那些聪明的想法，我最近的任务不会轻易开始。</p><p id="a07c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我的项目成功发布了。当我看到我的队友在“深思熟虑的知识库”中玩得开心时，我觉得我的努力真的很值得。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="094b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="le">原载于</em><a class="ae lf" href="https://pitayan.com/posts/modernest-lib-hello-world/" rel="noopener ugc nofollow" target="_blank"><em class="le">https://pitayan.com</em></a><em class="le">。</em></p><div class="lg lh gp gr li lj"><a href="https://pitayan.com/posts/modernest-lib-hello-world/?ref=medium" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">2020年打造现代JS图书馆——皮塔扬</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">最近，我被分配了一个任务，创建一个新的JS库来替换已经发布的过时的JS库…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">pitayan.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jt lj"/></div></div></a></div></div></div>    
</body>
</html>