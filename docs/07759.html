<html>
<head>
<title>Leetcode 212: Word Search II | Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 212:单词搜索 II | Golang</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-212-word-search-ii-golang-a509ad9f3316?source=collection_archive---------6-----------------------#2022-04-21">https://blog.devgenius.io/leetcode-212-word-search-ii-golang-a509ad9f3316?source=collection_archive---------6-----------------------#2022-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="350e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个由字符组成的<strong class="jm io"> m x n </strong> <strong class="jm io">棋盘</strong>和一列字符串<strong class="jm io">单词</strong>，返回棋盘上的所有单词。</p><p id="e202" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个单词必须由顺序相邻单元的字母构成，其中相邻单元水平或垂直相邻。同一个字母单元格在一个单词中不能使用多次。</p><p id="cd28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f9951d35009116d13f44bfdfd3d37597.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*nROsHt_gE13KNYHO.jpg"/></div></figure><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="7e1d" class="kv kw in kr b gy kx ky l kz la"><strong class="kr io">Input:</strong> board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]<br/><strong class="kr io">Output:</strong> ["eat","oath"]</span></pre></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><p id="03af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个测试你的 DFS 技能和应用 Trie 数据结构概念的好问题。我将在 Go 中展示解决方案，但是通过通读本文，同样的内容可以很容易地用其他编程语言编写。</p><p id="b618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">思维过程</strong></p><ul class=""><li id="b70b" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">我得到了一个单词列表，如果需要的话，可以很容易地将它转换成一个数据结构，比如 hash map 或 set。通过使用哈希映射，我可以快速测试特定的单词是否存在于给定的单词输入列表中。Golang 有一个内置的类型来处理哈希映射，但是没有现成的。所以，我将继续使用术语“散列映射/映射”来代替集合。</li><li id="7580" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">我可以使用 DFS 来探索电路板。基于问题中提到的约束，我可以找到与给定单元格水平或垂直相邻的相邻单元格。这意味着从当前单元最多有 4 种可能性可以探索。我已经在下图中展示了这一点。当前单元格包含字母“a”。从这里开始，4 个箭头表示可以到达的相邻小区。对于在边界上的单元，相邻单元的数量小于 4。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/59991dd04f57aa7cfbd3d44b7331a1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*i7wuH8Eem5DpOk9evANooQ.jpeg"/></div></figure><ul class=""><li id="d037" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">一般来说，从初始单元启动 DFS 可能无法浏览整个电路板。因此，从之前的 DFS 遍历中未涉及的单元再次启动 DFS 是一种常见的技术</li><li id="fc4c" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">但是在这个具体的问题中，我想从每个单元开始 DFS。为什么？原因是从特定单元(即，从该单元中提到的特定初始字符)开始 DFS 将提供以该初始字符开始的所有可能的单词。为了找到以第二个单元格中提到的字符开头的所有可能的单词，我从这个单元格开始再次运行 DFS。类似的论点适用于在板中的所有单元启动 DFS。</li><li id="0896" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">问题中提到的另一个约束是，在查找一个单词时，每个单元(即与每个单元相关联的字符)不能使用多次。考虑下面的板和显示的输入单词列表。由于这种限制,“停止”不应该是输出的一部分。在代码中，这可以直接转化为维护某个概念，即该单元已经被访问过，这是 DFS/BFS 类问题中的标准技术。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/85a81abe1e7ab2179ab9c9202124d681.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*EVa7m4-H1kvtcIHZxmVyOg.jpeg"/></div></figure><ul class=""><li id="b2f9" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">在浏览白板时，可能会多次找到同一个单词，但是我们不应该在输出中提供重复的答案。考虑下面的板和输入单词列表。你可以看到“猫”这个词可以从不同的路径生成。为了在输出中避免这些重复，我可以将 DFS 期间获得的结果收集到一个哈希映射中，并在返回最终输出之前将这个映射转换成一个列表</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/2312a3664ec43979a0d98b030de07b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*0qvLq7ffECNBdKcC_E-RPg.jpeg"/></div></figure><ul class=""><li id="94ec" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">在这一点上，我有所有的信息和清晰度来解决这个问题。然而，由于一个原因，它是低效的——如果在 DFS 遍历期间的部分路径对于扩展是无用的，那么通过挑选相邻的邻居来继续 DFS 是没有意义的。没有根据输入单词列表验证部分单词的检查将导致许多不必要的 DFS 调用，并可能导致 Leetcode 上的 TLE(超过时间限制)。</li><li id="f5aa" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">如何检查到目前为止构造的部分单词是否有效？我可以检查输入单词列表，看看是否有以这个部分单词开头的单词。如果没有这样的话，我可以在这个单元格中脱离 DFS(从而避免许多不必要的 DFS 调用)。这提出了一个新问题。如何有效地检查是否有以给定前缀开头的单词？</li><li id="5f17" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">哈希表还是一个好的选择吗？我最初选择它是因为我希望能够快速检查给定单词的存在。但现在我发现我需要的不止这些。我还希望能够快速测试是否有任何以给定前缀开头的单词。这就是 Trie 数据结构有用的地方</li><li id="18dc" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">我将使用至少有 4 种方法的 Trie 数据结构来解决这个问题——创建一个新的 Trie，将新单词插入 Trie，在 Trie 中搜索完整的单词，并检查是否有以前缀开头的单词</li></ul><p id="65ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码片段</strong></p><ol class=""><li id="f15d" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh lz lo lp lq bi translated">将一段文字转换成地图或者将地图转换成一段文字很容易。这个可以快速编码。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b4e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.从每个单元启动 DFS 非常简单。编码时间:&lt; 1 分钟</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a8e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.确定 DFS 的参数。这可以在 2 到 3 分钟内完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="af1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.决定如何维护“已访问”的信息。可以保持一个单独的 2d 阵列来跟踪是否已经访问了一个单元。但是我可以在这个问题上利用一个小技巧，避免使用单独的 2d 阵列/切片。假设棋盘只包含小写字母，我可以用一个特殊字符更新单元格的内容，以表明它已经被访问过了。在此单元的 DFS 完成后，我将对此进行恢复。编码时间:&lt; 1 分钟</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b03b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.对于一个给定的单元格，最多有 4 个相邻的单元格—左、右、上、下。对于边界上的单元，相邻单元的数量小于 4。因此，在启动 DFS 之前，我需要检查相邻单元是否有效。我可以将这个检查卸载到一个简单的函数中，如下所示。编码时间&lt; 1 分钟</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="93b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.检查到目前为止构造的部分单词是否是输入单词列表中的有效单词。如果有，就存储在结果映射中。编码时间&lt; 1min</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7aa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7. Check if the Trie contains any words with a given prefix. If the answer is no, then there is no need to continue DFS from the current cell any further. Coding time &lt; 1min</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7387" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8. Construct a Trie with. Coding time 10 mins. I have shown this in the final solution below.</p><p id="3e87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最终解</strong></p><p id="4180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的解决方案如下所示。如您所见，如果我们对如何解决问题有一个清晰的想法，我们可以在 20 到 25 分钟的时间内轻松地编写出整个解决方案(包括 Trie 的实现)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事情到此为止。如果你喜欢，我希望得到一些掌声。</p></div></div>    
</body>
</html>