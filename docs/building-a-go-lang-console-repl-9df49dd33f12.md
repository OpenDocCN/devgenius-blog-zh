# 构建 Go(lang)控制台/REPL

> 原文：<https://blog.devgenius.io/building-a-go-lang-console-repl-9df49dd33f12?source=collection_archive---------7----------------------->

![](img/55c50a816ac63bddf3c25f5fa9759935.png)

REPL 是一种允许用户探索编程语言的计算机环境。在 REPL 环境中，代码由解释器输入和评估。评估后，输出将显示给用户。因为 Go 程序是编译的，所以这种语言没有提供 REPL 环境。最接近的选择是操场，它允许开发者立即运行他们的 Go 代码。我想建造，或者至少模拟一个 REPL 的环境。在这篇文章中，我将尝试构建一个 Go REPL/控制台，并强调我所做的一些设计决策。

# 回声“你好世界”

我构建环境的方法是生成一个 Go 文件。该文件将包括用户定义的代码，以及构建程序所需的其他代码。一旦代码生成，它就作为一个程序被执行，并且输出被记录回用户。这类似于 Go playground 的运行方式，只是支持代码是隐藏的。

我将实现一个递归调用的函数，直到程序终止。每次调用该函数时，都会提示用户进行输入。程序将等待输入。一旦输入，文本数据将被记录到控制台。这将是环境的基础，因为程序现在可以读取和打印。代码将如下所示:

![](img/a974412e95f7114ec1223b049476d1c1.png)

控制台功能有 3 个参数。我把它们放在那里是为了跟踪包导入、变量和用户输入的行。这个函数看起来很混乱，运行之后，传递的数组没有持久化。每次调用后数组都会重置。为了解决可读性问题，我定义了一个自定义的结构类型来跟踪所有这些数据。请记住，我选择为 struct 方法使用指针来保存数组值。代码将如下所示:

![](img/fab71cbec907fd8027f0134969ec36d0.png)

我将函数`Process`实现为一个 struct 方法。该过程将检测用户输入的命令，并确定要采取的行动。switch 语句用于评估输入。未知的用户输入将在默认情况下被处理，因为我们不能可靠地确定它。switch 语句还将使我能够方便地添加更多的动作。如果你注意到了，我保存了一个用户指定的导入列表。该数组在构建时作为一个字符串连接，并写入将被执行以模拟代码评估的文件中。下一步将是更新控制台函数，以使用类型 Terminal。

![](img/806dab9cb02d473fc9831854559a8e9f.png)

通过添加终端类型，我减少了函数所需的参数数量。对我来说，它使函数更容易使用。既然存储机制已经存在，是时候为控制台添加新命令了。

# 模拟命令

该程序将有 4 个命令。第一个是`import`，`import`会给`iCache`增加一个新条目。第二个命令的工作方式不同于 import。该命令将扫描输入行的等号，一旦检测到，它将把用户指定的行添加到`vCache`中。`vCache`在构建时被连接形成一个代码块，这个代码块被放置在生成的 Go 代码文件的 main 函数内。这将允许开发人员指定和存储变量以供进一步评估。第三个命令是`clear`，该命令将删除`iCache`和`vCache`中的所有值。将列出第四个命令。列表将显示`iCache`和`vCache`中的所有值。任何未知命令都将被视为 Go 代码并进行评估。评估包括将用户代码放在生成的 Go 源文件中并执行它。这是函数`Process`的最终版本:

![](img/5df10a71b8b36502b100636ef2ed5bf3.png)

变量标记出现了一个错误，带有 clear 的命令不能被识别。命令必须是“全部清除”才能工作

下一个要处理的函数是构建函数。我首先编写了一个函数，可以显示从终端实例生成的源代码。源代码是`vCache`和`iCache`数组的结果。下面是用于生成 Go 代码源的模板字符串:

![](img/a551c106796d6315c1ce16cdb946a8b4.png)

填充和显示模板字符串的初始函数:

![](img/d5ee7f90628ff6ca510b20ad354b7439.png)

现在是时候添加构建和运行代码的代码块了。我决定用命令`go run`执行这个文件。这个命令将构建并执行源代码，为我减少了一个步骤。为了将命令与 REPL 程序集成，我使用了包`os/exec`。我用 exec 包函数`Command`实例化了一个命令。我用函数`CombinedOutput`提取了输出。这确保了该命令发出的任何行文本都会报告给用户。方法`Output`返回的错误对象只有退出状态代码，对我来说这似乎是无用的信息。下面是完整的构建函数:

![](img/11b8ec5d57eebed6c7abd57e127f0541.png)

就这样，我有了一个基本的 Go 代码评估器。下面是运行中的控制台的屏幕截图:

![](img/11abbc71c3e659e6eae7faae7f643a21.png)

记住上面的输出，您可以看到一些设计决策是如何反映在控制台的行为中的。未知命令被视为 Go 代码进行评估。这是它是如何建成的，现在，这里有一个解决方案实施的评论家。在此之前，再来一张控制台截图:

![](img/c6f7e8ac7318d8f7d7bbdf46c1d94c14.png)

# 批评家们

我将从您可能已经想到的一个问题开始，为什么要为静态编译语言构建 REPL？这个博客的目标是尝试新的想法。Go playground 也证明了 Go 开发者喜欢测试代码的环境。带来了一系列的限制。箭头键输入被记录为字符，导致控制台没有实际的文本光标。读者返回的文本有多余的字符。这将导致预处理输入，以防止意外的行为。这个解决方案有一个学习曲线。必须告诉用户如何导入包。与其他 REPL 环境不同，这个环境需要调用打印函数来显示输出。这个问题以及更多的批评都可以通过更好的编程来解决。事实上，有一些开源项目提供了有效的 Go 解释器。

# 结论

正如用 Yaegi 演示的那样，做一个 Go 解释器是可能的。这篇文章中的程序被精简到基本组件。我想让读者发现我构建围棋控制台的方法。用复杂的代码很难表达这些观点，所以我选择了简单但有限的实现。希望这些概念可以进一步打磨，落实到自己的使用中。

来源

 [## medium _ examples/goconsole at main cheikh shift/medium _ examples

### 中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。

github.com](https://github.com/cheikhshift/medium_examples/tree/main/goconsole) [](https://github.com/traefik/yaegi) [## GitHub - traefik/yaegi: Yaegi 是另一个优雅的 Go 解释器

### Yaegi 是另一个优雅的围棋翻译家。它支持可执行的 Go 脚本和插件，在嵌入式解释器或…

github.com](https://github.com/traefik/yaegi)