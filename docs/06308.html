<html>
<head>
<title>Service-to-service Spring 5 + OAuth2 integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务到服务的Spring 5 + OAuth2集成</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/service-to-service-spring-5-oauth2-integration-1fcdcec55a39?source=collection_archive---------4-----------------------#2021-12-29">https://blog.devgenius.io/service-to-service-spring-5-oauth2-integration-1fcdcec55a39?source=collection_archive---------4-----------------------#2021-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b3395ebb0435b22e134fd8ffbabc52b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4oBWQRWgcS5RYrzAf1jFw.png"/></div></div></figure><p id="074b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在为我的一个宠物项目寻找正确的方法来保护深层后端的微服务。在考虑了多种技术后，我决定选择总部位于JWT的OAuth2。然而，互联网上的大多数指南和教程都涉及一个用户——要么是客户，要么是员工，但在后端，我们通常没有用户，我们有服务相互交谈。我花了几天时间研究，又花了几天时间构建了一个简约的原型，现在我很高兴与更多的观众分享。</p><p id="0b4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将构建基于Spring5的微服务，它既是OAuth2 (OIDC)客户端，也是资源服务器。作为OIDC提供商，我使用Keycloak。</p><p id="ca25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">免责声明:</em> </strong>该系统尚未投入生产，开发仅用于演示目的。使用时风险自担。我试图只保留所需的最少代码，因此性能优化、高级设计、测试、被动调用和其他技巧不在讨论范围之内。我还假设你知道OAuth2、OICD和春天这些术语，否则，我很惊讶你还在读🤔。</p><p id="6c1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">需求:</em> </strong> Java 17(可以降级到8但你得改几行代码)运行你的Spring Boot服务，Docker(可选)运行Keycloak的实例，cURL(可选)。</p><p id="df6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们在建造什么。</strong> <br/>我们正在构建三种通用的Spring Boot微服务。在现实世界中，它们可能是API网关或常规服务，但在这个演示中，这些只是空的样板服务。每一个都有需要保护的资源API。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/6b0d42a155d7ef69742164ecf6ea3b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*GTpw6COi_T4dST8Fv_PWzA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">系统结构</figcaption></figure><p id="4921" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会问，为什么要提供三种服务。因为这样更有趣。请参见访问控制模型。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/687277275affa21fba4235e9e6460562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWc95FDs2xbv5US9DAZzsw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">访问控制模型</figcaption></figure><p id="5f7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它的意思是:我们有<em class="kt">服务1 </em>，它可以从<em class="kt">服务2 </em>中获取<em class="kt">资源2 </em>，但不能从<em class="kt">资源1 </em>中获取。每个资源都是一个简单的REST API端点。</p><p id="f9c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">设置OIDC提供商— Keycloak </strong> <br/>没有特别的原因，我为什么选择了<a class="ae le" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>。有多家供应商提供不同的许可证、价格和功能。Keycloak是<a class="ae le" href="https://github.com/keycloak/keycloak/blob/main/LICENSE.txt" rel="noopener ugc nofollow" target="_blank">阿帕奇-2.0 </a>并且极其强大。但是从理论上讲，您可以毫不费力地用您选择的授权服务交换Keycloak。首先，默认选项是用docker启动它。在这种情况下，您将系统部署在您的<em class="kt">本地主机</em>端口<em class="kt"> 8080 </em>上，用户名和密码为<em class="kt"> admin/admin </em>:</p><pre class="kv kw kx ky gt lf lg lh li aw lj bi"><span id="995e" class="lk ll in lg b gy lm ln l lo lp">docker run -p 8080:8080 -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin quay.io/keycloak/keycloak:16.1.0</span></pre><p id="bae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创造一个新的境界。我把我的领域命名为<strong class="jx io"> <em class="kt"> demo </em> </strong>。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/13df9d4c80013ebc2d491a11f53b2a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*E-mf7e1znJ0fslm-fI820g.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">创建领域</figcaption></figure><p id="0c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建范围。对于每个受保护的资源，我都有一个个人范围。于是，我有了这些:<em class="kt"> service1:resource1 </em>，<em class="kt"> service1:resource2 </em>，<em class="kt"> … </em>，<em class="kt"> service3:resource3 </em> —一共六个。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/853ada229d3891260c41d55f6f117bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtrR8lcUGg0GWzrMN5CF6A.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">创建客户端范围</figcaption></figure><p id="fe9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要创建一个客户端。从<em class="kt"> service1 </em>开始，我们需要将其保密，启用OAuth2中的服务帐户<a class="ae le" href="https://oauth.net/2/grant-types/client-credentials/" rel="noopener ugc nofollow" target="_blank">“客户端凭证授予”</a>，并从上表中设置可访问的范围。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/1f2a97194473e815b9efe441e4b82eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lkGlccO3rks1TCy0vzOeg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">配置客户端</figcaption></figure><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/c4a728e8a24f0d6e9abab3f568d19f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEgArwwkVrE0wmrYZ5nU_g.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">为服务分配客户端范围</figcaption></figure><p id="2dc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对<em class="kt">服务2 </em>和<em class="kt">服务3 </em>进行同样的操作。之后，Keycloak应该就可以使用了。要测试它，获取您的客户机ID和密码(在Credentials选项卡上)，并发出cURL请求:</p><pre class="kv kw kx ky gt lf lg lh li aw lj bi"><span id="0222" class="lk ll in lg b gy lm ln l lo lp">curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d 'grant_type=client_credentials&amp;client_id=<strong class="lg io"><em class="kt">&lt;your_id&gt;</em></strong>&amp;client_secret=<strong class="lg io"><em class="kt">&lt;your_secret&gt;</em></strong>' "<a class="ae le" href="http://localhost:8080/auth/realms/demo/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/auth/realms/<strong class="lg io"><em class="kt">demo</em></strong>/protocol/openid-connect/token</a>"</span></pre><p id="f2ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切顺利，你应该会得到一个带有访问令牌的响应，你可以在https://jwt.io/的<a class="ae le" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">查看:</a></p><pre class="kv kw kx ky gt lf lg lh li aw lj bi"><span id="fc4c" class="lk ll in lg b gy lm ln l lo lp">{“access_token”:”<strong class="lg io"><em class="kt">eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJxcmttSWVET2YzQVlmcGRUZHJGVG52QjBMbjd3WkVMMmthZWprTkpuTVd3In0.eyJleHAiOjE2NDA3NTYyNDgsImlhdCI6MTY0MDc1NTk0OCwianRpIjoiZjI0ZTU2MWItY2E2Ny00NDdiLWE4OWMtNjczNjY3NjdhOWEzIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL2F1dGgvcmVhbG1zL2RlbW8iLCJzdWIiOiJhNjNjMTFiOC1iN2FkLTQwNjktYTU3YS05NmQ4YzA0MDcyNmEiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJzZXJ2aWNlMSIsImFjciI6IjEiLCJzY29wZSI6InNlcnZpY2UyOnJlc291cmNlMiBzZXJ2aWNlMzpyZXNvdXJjZTIiLCJjbGllbnRJZCI6InNlcnZpY2UxIiwiY2xpZW50SG9zdCI6IjE3Mi4xNy4wLjEiLCJjbGllbnRBZGRyZXNzIjoiMTcyLjE3LjAuMSJ9.Bb_i9FR23cvxIFmUwb_-AQQxCP35baSTVcROoSlJ1NyGWDcirz2BRY4UdFEldYQ02Gro3dwfErr-g-4blE4sYkYuQcj-TJSq-QAgvCQvtZ-J_sC-06pyFqFC3St1EVYKNyEWdnJGjCooe0YtWYUERQpdltHifQ23fOlAQbE3lwg0n5nCuypAzUpb7SFEyD0vOHyiYYMEUJiW8gF8Fw_ygsgbmUt8stHfFYd-oLjiQvrnk5G-dv8vhv4e4Z9DzeNAorwR59OhfxV8Mc30H1SRX4he8trcCuZL_HPglnN0pvLKFhP2kxGLIrv0r5ShMx4Pihjx7Q-e-R2aR-0cwTL14Q</em></strong>”,”expires_in”:300,”refresh_expires_in”:0,”token_type”:”Bearer”,”not-before-policy”:0,”scope”:”service2:resource2 service3:resource2"}</span></pre><p id="99cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Spring应用</strong> <br/>你可以在我的Github库看一下<a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo" rel="noopener ugc nofollow" target="_blank">。这三个服务中的每一个都是相同的服务。<em class="kt">服务1 </em>的代码与注释</a>一起提供给<a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/tree/main/service1" rel="noopener ugc nofollow" target="_blank">。在运行它之前，您必须用您的客户端ID、密码和域名更新<code class="fe lu lv lw lg b"><a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/service1/src/main/resources/application.yaml" rel="noopener ugc nofollow" target="_blank">application.yaml</a></code>属性。</a><a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/README.md" rel="noopener ugc nofollow" target="_blank"> Readme </a>文件解释了如何启动服务和运行简单的集成测试。代码本身非常简单，但是我将解释一些细节。</p><p id="670b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，它是一个通用的Spring Boot应用程序。<a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/service1/build.gradle" rel="noopener ugc nofollow" target="_blank">依赖关系</a> <code class="fe lu lv lw lg b">org.springframework.boot:spring-boot-starter-oauth2-client</code>和<code class="fe lu lv lw lg b">org.springframework.boot:spring-boot-starter-oauth2-resource-server</code>表示服务将被用作客户端和资源服务器。创建REST端点需要依赖关系【the web客户端执行对其他服务的HTTP调用需要<code class="fe lu lv lw lg b">org.springframework.boot:spring-boot-starter-webflux</code>。</p><p id="9c51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lu lv lw lg b">application.yaml</code>文件包含服务器端口和提供者配置片段和端点。<strong class="jx io"> <em class="kt">注意:</em> </strong> <em class="kt">您的提供者端点可能不同，尤其是如果您使用了不同的领域名。</em></p><p id="a145" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类<code class="fe lu lv lw lg b"><a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/service1/src/main/java/com/test/service1/config/OAuth2LoginSecurityConfig.java" rel="noopener ugc nofollow" target="_blank">OAuth2LoginSecurityConfig</a></code>是对<code class="fe lu lv lw lg b">WebSecurityConfigurerAdapter</code>的扩展，指定了web端点的行为。为了让它工作，你需要用<code class="fe lu lv lw lg b">@EnableWebSecurity</code>注释这个类。我还用<code class="fe lu lv lw lg b">@EnableGlobalMethodSecurity(prePostEnabled = true)</code>对它进行了注释，这将启用<code class="fe lu lv lw lg b">@PreAuthorize(“…”)</code>注释的用法，您将在控制器中看到。这并不重要，但更像是“生活质量”的特征。</p><p id="5b46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类<code class="fe lu lv lw lg b"><a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/service1/src/main/java/com/test/service1/config/CustomConfigs.java" rel="noopener ugc nofollow" target="_blank">CustomConfigs</a></code>只为<code class="fe lu lv lw lg b">WebClient</code> bean而存在。如前所述，<code class="fe lu lv lw lg b">WebClient</code>只是一个HTTP客户端来执行对其他服务的调用。我选择它主要是因为它提供了与OAuth2客户端最简单的集成，但是人们可以用他们选择的HTTP客户端替换它。</p><p id="27fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而最后一个类是用<code class="fe lu lv lw lg b">@RestController</code>标注的<code class="fe lu lv lw lg b"><a class="ae le" href="https://github.com/1petr0v/service-to-service-oidc-demo/blob/main/service1/src/main/java/com/test/service1/controller/EndpointController.java" rel="noopener ugc nofollow" target="_blank">EndpointController</a></code>。该类有两个资源方法，每个都用<code class="fe lu lv lw lg b">@GetMapping</code>和<code class="fe lu lv lw lg b">@PreAuthorize(“hasAuthority(‘SCOPE_…’)”)</code>进行了注释。还记得吗，我们在Keycloak中创建了<em class="kt"> service1:resource1 </em>？这些是这些资源的范围。我还添加了一个完全允许的API方法<code class="fe lu lv lw lg b">/public/jump/{toService}/{toResource}</code>，它仅用于演示目的。该调用与<code class="fe lu lv lw lg b">http://service1/public/jump/service2/resource1</code>一样，将代表<em class="kt">服务1 </em>调用<em class="kt">服务2:资源1 </em>，其中<em class="kt">服务1 </em>必须被授权调用<em class="kt">服务2:资源1 </em>。</p><p id="c382" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且…差不多就是这样。我希望你喜欢读这篇文章。请在下面的评论区告诉我你的想法。</p><p id="fc8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢大家！</p></div></div>    
</body>
</html>