<html>
<head>
<title>Server-Side Development with Hapi.js — Tokens, JWT, and Secrets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Hapi.js 进行服务器端开发——令牌、JWT 和秘密</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/server-side-development-with-hapi-js-tokens-jwt-and-secrets-8f79ab5b7d92?source=collection_archive---------1-----------------------#2021-03-01">https://blog.devgenius.io/server-side-development-with-hapi-js-tokens-jwt-and-secrets-8f79ab5b7d92?source=collection_archive---------1-----------------------#2021-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d680687c496482d3e883cb700bfe23b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*buylQk7MjFpLljxU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯蒂安·埃斯科瓦尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a1e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Hapi.js 是一个用于开发后端 web 应用程序的小型节点框架。</p><p id="af85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用 Hapi.js 创建后端应用程序。</p><h1 id="66c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建令牌</h1><p id="6966" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">@hapi/iron</code>模块创建令牌。</p><p id="9c3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f350" class="mq lc iq mh b gy mr ms l mt mu">const Hapi = require('@hapi/hapi');<br/>const iron = require('@hapi/iron')</span><span id="f7f4" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: [3, 4, 5],<br/>  d: {<br/>      e: 'f'<br/>  }<br/>};</span><span id="6498" class="mq lc iq mh b gy mv ms l mt mu">const password = 'passwordpasswordpasswordpassword';</span><span id="1c6a" class="mq lc iq mh b gy mv ms l mt mu">const init = async () =&gt; {  <br/>  const server = new Hapi.Server({<br/>    port: 3000,<br/>    host: '0.0.0.0'<br/>  });</span><span id="f21d" class="mq lc iq mh b gy mv ms l mt mu">  server.route({<br/>    method: 'GET',<br/>    path: '/',<br/>    async handler(request, h) {    <br/>      try {<br/>        const sealed = await iron.seal(obj, password, iron.defaults);<br/>        return sealed<br/>      } catch (err) {<br/>        console.log(err);<br/>      }                    <br/>    }<br/>  });</span><span id="1603" class="mq lc iq mh b gy mv ms l mt mu">  await server.start();<br/>  console.log('Server running at:', server.info.uri);<br/>};<br/>  <br/>process.on('unhandledRejection', (err) =&gt; {<br/>  console.log(err);<br/>  process.exit(1);<br/>});<br/>init();</span></pre><p id="e279" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用想要加密的对象调用<code class="fe me mf mg mh b">iron.seal</code>方法，用<code class="fe me mf mg mh b">password</code>访问加密的对象，还有设置，也就是<code class="fe me mf mg mh b">iron.defaults</code>。</p><p id="7e2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们的<code class="fe me mf mg mh b">sealed</code>字符串是字符串形式的对象的混乱版本。</p><p id="e1f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为了解封它，我们调用<code class="fe me mf mg mh b">iron.unseal</code>方法。</p><p id="4dd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="930c" class="mq lc iq mh b gy mr ms l mt mu">const Hapi = require('@hapi/hapi');<br/>const iron = require('@hapi/iron')</span><span id="af1d" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: [3, 4, 5],<br/>  d: {<br/>      e: 'f'<br/>  }<br/>};</span><span id="cebc" class="mq lc iq mh b gy mv ms l mt mu">const password = 'passwordpasswordpasswordpassword';</span><span id="efe6" class="mq lc iq mh b gy mv ms l mt mu">const init = async () =&gt; {  <br/>  const server = new Hapi.Server({<br/>    port: 3000,<br/>    host: '0.0.0.0'<br/>  });</span><span id="27d2" class="mq lc iq mh b gy mv ms l mt mu">  server.route({<br/>    method: 'GET',<br/>    path: '/',<br/>    async handler(request, h) {    <br/>      try {<br/>        const sealed = await iron.seal(obj, password, iron.defaults);<br/>        const unsealed = await iron.unseal(sealed, password, iron.defaults);<br/>        return unsealed<br/>      } catch (err) {<br/>        console.log(err);<br/>      }                    <br/>    }<br/>  });</span><span id="b13e" class="mq lc iq mh b gy mv ms l mt mu">  await server.start();<br/>  console.log('Server running at:', server.info.uri);<br/>};<br/>  <br/>process.on('unhandledRejection', (err) =&gt; {<br/>  console.log(err);<br/>  process.exit(1);<br/>});<br/>init();</span></pre><p id="cf4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用同样的<code class="fe me mf mg mh b">password</code>用<code class="fe me mf mg mh b">iron.unseal</code>方法解密加密的字符串。</p><h1 id="16a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSON Web 令牌</h1><p id="87ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">@hapi/jwt</code>模块创建和验证 JSON web 令牌。</p><p id="274a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:“</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a548" class="mq lc iq mh b gy mr ms l mt mu">const Hapi = require('@hapi/hapi');<br/>const Jwt = require('@hapi/jwt');<br/>const jwt = require('jsonwebtoken');</span><span id="2928" class="mq lc iq mh b gy mv ms l mt mu">const init = async () =&gt; {  <br/>  const server = new Hapi.Server({<br/>    port: 3000,<br/>    host: '0.0.0.0'<br/>  });</span><span id="3409" class="mq lc iq mh b gy mv ms l mt mu">  await server.register(Jwt);</span><span id="4b94" class="mq lc iq mh b gy mv ms l mt mu">  server.auth.strategy('my_jwt_stategy', 'jwt', {<br/>    keys: 'some_shared_secret',<br/>    verify: {<br/>      aud: 'urn:audience:test',<br/>      iss: 'urn:issuer:test',<br/>      sub: false,<br/>      nbf: true,<br/>      exp: true,<br/>      maxAgeSec: 14400,<br/>      timeSkewSec: 15<br/>    },<br/>    validate: (artifacts, request, h) =&gt; {<br/>      return {<br/>        isValid: true,<br/>        credentials: { user: artifacts.decoded.payload.user }<br/>      };<br/>    }<br/>  });</span><span id="3372" class="mq lc iq mh b gy mv ms l mt mu">  server.route({<br/>    method: 'GET',<br/>    path: '/',<br/>    config: {<br/>      handler(request, h) {    <br/>        const token = jwt.sign({ <br/>          aud: 'urn:audience:test',<br/>          iss: 'urn:issuer:test',<br/>          sub: false,<br/>          maxAgeSec: 14400,<br/>          timeSkewSec: 15<br/>        }, 'some_shared_secret');   <br/>        return token;             <br/>      },</span><span id="478f" class="mq lc iq mh b gy mv ms l mt mu">}<br/>  });</span><span id="f6d6" class="mq lc iq mh b gy mv ms l mt mu">  server.route({<br/>    method: 'GET',<br/>    path: '/secret',<br/>    config: {<br/>      handler(request, h) {    <br/>        return 'secret';             <br/>      },<br/>      auth: {<br/>        strategy: 'my_jwt_stategy',        <br/>      }<br/>    }<br/>  });</span><span id="3e5d" class="mq lc iq mh b gy mv ms l mt mu">  await server.start();<br/>  console.log('Server running at:', server.info.uri);<br/>};<br/>  <br/>process.on('unhandledRejection', (err) =&gt; {<br/>  console.log(err);<br/>  process.exit(1);<br/>});<br/>init();</span></pre><p id="4fdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe me mf mg mh b">jsonwebtoken</code>模块来创建令牌。</p><p id="e28c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">server.auth.strategy</code>来添加 JWT 认证策略。</p><p id="b75d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">keys</code>有我们用来验证令牌的密钥。</p><p id="a6c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">verify</code>有我们要验证的字段。</p><p id="c0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">validate</code>有一个函数返回<code class="fe me mf mg mh b">isValid</code>来表明令牌是有效的。</p><p id="de56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">credentials</code>拥有来自解码令牌的数据。</p><p id="3bfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">jwt.sign</code>来签署<code class="fe me mf mg mh b">/</code>路由处理器中的令牌。</p><p id="5dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">/secret</code>路由中，我们有<code class="fe me mf mg mh b">auth.strategy</code>属性来设置授权策略。</p><h1 id="f0ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="45a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建各种令牌，并用哈比神插件验证它们。</p></div></div>    
</body>
</html>