<html>
<head>
<title>Validating MongoDB Documents in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Spring Boot 验证 MongoDB 文档</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/validating-mongodb-documents-in-spring-boot-fe4ed5ff3368?source=collection_archive---------20-----------------------#2022-04-11">https://blog.devgenius.io/validating-mongodb-documents-in-spring-boot-fe4ed5ff3368?source=collection_archive---------20-----------------------#2022-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="25cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 MongoDB 有两种<strong class="jm io">方法来验证存储在 Spring Boot 应用程序中的文档</strong>。在前一篇文章中描述了这样一个应用程序的基本结构<a class="ae ki" href="https://bootify.io/mongodb/setup-spring-boot-mongodb.html" rel="noopener ugc nofollow" target="_blank">之后，本文将把重点放在<strong class="jm io">特定的验证问题</strong>上。</a></p><p id="1a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MongoDB 允许在任何时候持久化任何数据结构的任何集合。然而，对于一个打算长期用于生产的应用程序，并且其他应用程序也可能访问数据库，<strong class="jm io">一个显式定义的数据库模式是一个优势</strong>。这样，开发人员就知道会发生什么，编程也就简化了。</p><h2 id="3eeb" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">通过约束进行验证</h2><p id="4fd0" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">一种方法是将来自<code class="fe lh li lj lk b">javax.validation</code>包的字段验证直接添加到我们的应用程序包含的文档中。为了激活这些约束，我们首先需要<strong class="jm io">包含一个依赖项</strong>，这在 Spring Boot 中是默认不存在的:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="5997" class="kj kk in lk b gy lt lu l lv lw">implementation('org.springframework.boot:spring-boot-starter-validation')</span></pre><p id="b86a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还需要<strong class="jm io">扩展我们的配置类</strong>，以便我们的持久层实际执行验证。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="f1dd" class="kj kk in lk b gy lt lu l lv lw">@Configuration<br/>@EnableMongoRepositories("io.bootify.mongo.repos")<br/>public class MongoConfig {<br/><br/>    // ...<br/><br/>    @Bean<br/>    public ValidatingMongoEventListener validatingMongoEventListener(<br/>            final LocalValidatorFactoryBean factory) {<br/>        return new ValidatingMongoEventListener(factory);<br/>    }<br/><br/>}</span></pre><p id="3343" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lx">将 ValidatingMongoEventListener 作为 bean 提供</em></p><p id="ed2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以<strong class="jm io">使用众所周知的注释来确保我们字段的有效性</strong>。以下文件中列出了几个例子，如<code class="fe lh li lj lk b">@NotNull</code>(必填字段)或<code class="fe lh li lj lk b">@Size</code>(字符串长度)。现在将在保存前检查这些内容。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="61ea" class="kj kk in lk b gy lt lu l lv lw">@Document<br/>public class Address {<br/><br/>    // ...<br/><br/>    @NotNull<br/>    @Size(max = 510)<br/>    private String address1;<br/><br/>    @Pattern(regexp = "[0-9]{5}")<br/>    private String postalCode;<br/><br/>}</span></pre><p id="6725" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lx">向我们的地址文档添加约束</em></p><h2 id="670f" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">通过 JSON 模式进行验证</h2><p id="ffd0" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">MongoDB 提供了为集合指定一个<strong class="jm io">显式 JSON 模式的可能性。这将检查为所有保存的文档定义的限制，因此这些限制也适用于希望在数据库中存储数据的其他应用程序。在我们的例子中，我们检查必填字段和数据类型。</strong></p><figure class="ll lm ln lo gt lz gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/d48cba47adc156fe0f740441e4c82095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*y7-4HW_7QO1kdNCQ.png"/></div></figure><p id="039e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lx">一个带有基本 JSON 模式的 MongoDB 集合</em></p><p id="d87f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了创建这样一个模式，使用 Mongock 执行的 ChangeLog 是一个好主意。当我们的应用程序启动时，这会用定义的模式初始化集合。因为在事务中创建集合是不可能的，所以我们在这里使用了<code class="fe lh li lj lk b">@BeforeExecution</code>钩子。下一篇文章将解释如何设置 Mongock。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="f3b1" class="kj kk in lk b gy lt lu l lv lw">@ChangeUnit(id = "init-address", order = "001", author = "bootify")<br/>public class InitCollectionsChangeLog {<br/><br/>    @BeforeExecution<br/>    public void beforeExecution(final MongoTemplate mongoTemplate) {<br/>        mongoTemplate.createCollection("address", CollectionOptions.empty()<br/>                .validator(Validator.schema(MongoJsonSchema.builder()<br/>                        .required("address1", "city")<br/>                        .properties(<br/>                                JsonSchemaProperty.int64("id"),<br/>                                JsonSchemaProperty.string("firstName"),<br/>                                JsonSchemaProperty.string("lastName"),<br/>                                JsonSchemaProperty.string("address1"),<br/>                                JsonSchemaProperty.string("postalCode"),<br/>                                JsonSchemaProperty.string("city")).build())));<br/>    }<br/><br/>    // @RollbackBeforeExecution, @Execution, @RollbackExecution<br/><br/>}</span></pre><p id="bb59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lx">用附加选项初始化我们的地址集合的变更日志</em></p><p id="615f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Bootify 的免费计划中，Spring Boot 应用程序可以配置自定义数据库模式。当选择 MongoDB 作为数据库时，会生成<strong class="jm io">文档以及它们的约束</strong>。在专业计划中，Mongock 是一个额外的选项<strong class="jm io">用一个基本的 JSON 模式</strong>初始化集合。</p><p id="9aaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://bootify.io/quickstart.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">了解更多</strong> </a></p><h2 id="4ea6" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">进一步阅读</h2><p id="d4de" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><a class="ae ki" href="https://docs.mongodb.com/manual/core/schema-validation/" rel="noopener ugc nofollow" target="_blank"> MongoDB 模式验证</a> <br/> <a class="ae ki" href="https://docs.oracle.com/javaee/7/api/javax/validation/constraints/package-summary.html" rel="noopener ugc nofollow" target="_blank"> javax.validation 约束</a></p></div></div>    
</body>
</html>