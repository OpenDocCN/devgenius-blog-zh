<html>
<head>
<title>Prerender routes in Express server for Angular — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于 Angular 的 Express server 中的 Prerender 路由—第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/prerender-routes-in-express-server-for-angular-part-i-bc8a9988ae82?source=collection_archive---------8-----------------------#2022-09-20">https://blog.devgenius.io/prerender-routes-in-express-server-for-angular-part-i-bc8a9988ae82?source=collection_archive---------8-----------------------#2022-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0291" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">角度预渲染</h2></div><p id="3fe9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多理由需要 prerender，也有许多理由不需要。每个应用程序都找到自己的用例来预渲染，而静态站点生成则完全是预渲染，像 stackoverflow 这样的大型网站避免了这一点。Angular 最近添加了用于预渲染的通用生成器，但在这个系列中，我想研究其他方法。</p><p id="ee33" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在进行我们自己的预渲染时，我想检查两种方法。</p><ol class=""><li id="e0ae" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">好的 ol' Express 服务器</li><li id="7d68" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">Angular prerender builder 的分拆</li></ol><p id="e32d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在服务器上也有使用 Angular <code class="fe lm ln lo lp b">RenderModule</code>的，但这是多余的。</p><p id="f5a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我们将构建我们的<strong class="ke io"> Express server </strong>来预呈现页面，下周我们将讨论创建一个<a class="ae lq" href="https://garage.sekrab.com/posts/alternative-way-to-localize-in-angular" rel="noopener ugc nofollow" target="_blank">单构建多语言 Angular app </a>的不同方面，这是我们之前提到的。</p><h2 id="fdab" class="lr ls in bd lt lu lv dn lw lx ly dp lz kl ma mb mc kp md me mf kt mg mh mi mj bi translated">关于 StackBlitz 项目的几点注记</h2><blockquote class="mk ml mm"><p id="8b69" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated">我创建了一个简单的<a class="ae lq" href="https://stackblitz.com/edit/angular-express-prerender" rel="noopener ugc nofollow" target="_blank"> StackBlitz 项目</a>来构建一个 SSR 应用程序，但不幸的是它在客户端创建<code class="fe lm ln lo lp b">index.html</code>时失败了。如果你运行<code class="fe lm ln lo lp b">npm run build:ssr</code>，它可能会卡在<code class="fe lm ln lo lp b">index.html</code>上。取消该步骤，继续，并自己修补索引。我确实在 StackBlitz 中修补了这个文件，但是这意味着为根生成一个预先呈现的索引文件不会产生正确的结果。管他呢，斯塔克布里兹！</p><p id="ba3b" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated">这个项目展示了一个简单的 Express 服务器，我们<a class="ae lq" href="https://garage.sekrab.com/posts/loading-external-configurations-in-angular-universal" rel="noopener ugc nofollow" target="_blank">在之前</a>隔离服务器的时候谈到过。</p><p id="068e" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated">提供的节点版本不支持<code class="fe lm ln lo lp b">fetch</code>，这就是为什么我们使用<code class="fe lm ln lo lp b">node-fetch</code>库，而不是<code class="fe lm ln lo lp b">commonjs</code>，所以解决方案(根据文档)是这样导入的:</p></blockquote><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="d7fd" class="lr ls in lp b gy mz na l nb nc">const fetch = (...args) =&gt; import('node-fetch')<br/>	.then(({ default: fetch }) =&gt; fetch(...args));</span></pre><h1 id="cfb7" class="nd ls in bd lt ne nf ng lw nh ni nj lz jt nk ju mc jw nl jx mf jz nm ka mi nn bi translated">运行本地 Express 服务器</h1><p id="ab68" class="pw-post-body-paragraph kc kd in ke b kf no jo kh ki np jr kk kl nq kn ko kp nr kr ks kt ns kv kw kx ig bi translated">最简单直接的方法是建立一个本地 Express 服务器，并在 Node 中使用一个简单的<code class="fe lm ln lo lp b">fetch</code>。<code class="fe lm ln lo lp b">fetch</code>从节点版本 17 开始可用，在那之前，你可以使用<code class="fe lm ln lo lp b">node-fetch</code>库。</p><p id="6ef8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当前设置如下:</p><ul class=""><li id="2ad9" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx nt le lf lg bi translated"><code class="fe lm ln lo lp b">src</code>文件夹中有角度模块，包括<code class="fe lm ln lo lp b">app.server.module</code></li><li id="96ff" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">Building 在<code class="fe lm ln lo lp b">host/client</code>下创建客户端文件，在<code class="fe lm ln lo lp b">host/server/main.js</code>下创建 SSR</li><li id="c8c8" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><code class="fe lm ln lo lp b">host/server.js</code>有一个独立的 Express 服务器，在本地端口上运行 Angular。</li><li id="bf6f" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><code class="fe lm ln lo lp b">host/server/routes.js</code>有进口角<code class="fe lm ln lo lp b">ngExpressEngine</code>出口角<code class="fe lm ln lo lp b">app.server.module</code>的航线</li><li id="d172" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">我们的新获取文件在<code class="fe lm ln lo lp b">host/prerender/fetch.js</code>下</li></ul><p id="ee28" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，首先让我们创建预渲染获取模块:</p><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="ea2d" class="lr ls in lp b gy mz na l nb nc">// host/prerender/fetch.js file<br/>async function renderToHtml(route, port) {<br/>	// run url in localhost<br/>  // do something with returned text<br/>	// return<br/>}<br/>// export some function here:<br/>module.exports = async (port) =&gt; {<br/>  // generate /client/static/route/index.html<br/>  // my static routes, example routes<br/>  const routes = ['', 'projects', 'projects/1'];</span><span id="e951" class="lr ls in lp b gy nu na l nb nc">  for (const route of routes) {<br/>    await renderToHtml(route, port);<br/>  }<br/>};</span></pre><p id="6358" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果设置了环境变量，我们调整我们的服务器来做一些事情，如下所示:</p><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="a099" class="lr ls in lp b gy mz na l nb nc">// host/server.js<br/>// ...<br/>// just when you start listening:</span><span id="4d61" class="lr ls in lp b gy nu na l nb nc">const port = process.env.PORT || 1212;</span><span id="a82a" class="lr ls in lp b gy nu na l nb nc">// assign a server to be able to close later<br/>// turn function to async to allow an await statement<br/>const server = app.listen(port, async function (err) {<br/>  console.log('started to listen to port: ' + port);<br/>  if (err) {<br/>    console.log(err);<br/>    return;<br/>  }<br/>  // if process.env.PRERENDER, then run this and close<br/>    if (process.env.PRERENDER) {<br/>      const prerender = require('./prerender/fetch');<br/>			// await fetch before you close here<br/>			// pass the port to reuse it<br/>			await prerender(port);<br/>			server.close();<br/>    }<br/>});</span></pre><p id="3c48" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在 prerender 模式下运行，我们在<strong class="ke io">主机</strong>文件夹的根目录下创建一个快速<code class="fe lm ln lo lp b">npm</code>脚本。</p><p id="5c26" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lm ln lo lp b">"prerender": "SET PRERENDER=true &amp;&amp; node server"</code></p><p id="3c81" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者在 Windows 之外的其他地方(比如 StackBlitz，在根包中找到脚本，首先是<code class="fe lm ln lo lp b">cd host</code>)</p><p id="0163" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lm ln lo lp b">"prerender": "PRERENDER=true node server”</code></p><p id="905e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">功能<code class="fe lm ln lo lp b">renderToHtml</code>，应该执行以下操作:</p><ul class=""><li id="795c" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx nt le lf lg bi translated">在 SSR 环境中提取路线</li><li id="1b08" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">将输出字符串保存到一个<code class="fe lm ln lo lp b">index.html</code>文件中</li><li id="3109" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">将文件放在与路径匹配的路径中</li><li id="8c9a" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">把它保存在一个容易找到的地方，不仅仅是为了快速，也是为了火焰，网络和浪涌。所以目的地应该在<code class="fe lm ln lo lp b">client</code>文件夹里面(云主机的公共文件夹)。</li></ul><p id="379d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们将使用节点的<code class="fe lm ln lo lp b">fs/promises</code>包，这允许我们在完成后关闭端口。我现在选择将它们放在<code class="fe lm ln lo lp b">/client/static</code>文件夹中。在 Express 中，这很容易管理。在其他主机中，比如 Netlify，将它们放在 root <code class="fe lm ln lo lp b">/client</code>上会更容易。</p><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="09f8" class="lr ls in lp b gy mz na l nb nc">// host/prerender/fetch.js<br/>const fs = require('fs/promises');</span><span id="1aca" class="lr ls in lp b gy nu na l nb nc">// this should be part of a config passed down from server listener<br/>// client/static for Express, or simply client for cloud hosts<br/>const prerenderOut = './client/static/';</span><span id="168c" class="lr ls in lp b gy nu na l nb nc">async function renderToHtml(route, port, outFolder) {<br/>	// fetch it<br/>  const response = await fetch(`http://localhost:${port}/${route}`);<br/>  if (response.ok) {<br/>    const text = await response.text();<br/>		// the output folder is ./client/static/{route}, relative to root server file<br/>    const d = outFolder + route;<br/>		// mkdir recursive, creates the folder structure<br/>    await fs.mkdir(d, {recursive: true});<br/>		// create index.html, and write text to it.<br/>    await fs.writeFile(d + '/index.html', text);<br/>		// loggin success<br/>    console.log('ok', route, text.length);<br/>  } else {<br/>		// log errores<br/>    console.log('not ok', route, response.status);<br/>  }</span><span id="2173" class="lr ls in lp b gy nu na l nb nc">}</span><span id="96f4" class="lr ls in lp b gy nu na l nb nc">module.exports = async (port) =&gt; {<br/>	// generate /client/static/route/index.html<br/>  // my static routes, example routes (you could run an API call to get all paths)<br/>  const routes = ['', 'projects', 'projects/1'];</span><span id="1218" class="lr ls in lp b gy nu na l nb nc">  for (const route of routes) {<br/>    await renderToHtml(route, port, prerenderOut);<br/>  }<br/>}</span></pre><p id="e6b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要改进的一点是，在我们开始创建静态文件夹之前删除它，以确保我们每次构建它时都有一个新的副本。在云主机中，情况会有所不同。</p><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="5997" class="lr ls in lp b gy mz na l nb nc">// prerender/fetch.js<br/>module.exports = async (port) =&gt; {<br/>	// ...<br/>  // remove static folder first<br/>  await fs.rm(prerenderOut, {recursive: true, force: true});<br/>	// ...<br/>}</span></pre><p id="d7cc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行脚本，观察文件的创建过程。注意:Angular universal packages 的酷之处在于，它还会为每个路径创建内嵌的关键 CSS。</p><h1 id="4143" class="nd ls in bd lt ne nf ng lw nh ni nj lz jt nk ju mc jw nl jx mf jz nm ka mi nn bi translated">快速路线</h1><p id="f4f5" class="pw-post-body-paragraph kc kd in ke b kf no jo kh ki np jr kk kl nq kn ko kp nr kr ks kt ns kv kw kx ig bi translated">为了在 Express 中提供这些静态文件，创建了一个新的静态适配器，将<code class="fe lm ln lo lp b">/client/static</code>的内容暴露给根，因此在<code class="fe lm ln lo lp b">routes.js</code>文件中(包含到 Express 中服务器 Angular SSR 的必要路径):</p><pre class="mr ms mt mu gt mv lp mw mx aw my bi"><span id="fd83" class="lr ls in lp b gy mz na l nb nc">// host/server/routes.js<br/>// this should be part of a config file passed down from server listener<br/>const rootPath = path.normalize(__dirname + '/../');</span><span id="d1cd" class="lr ls in lp b gy nu na l nb nc">module.exports = function (app) {<br/>	// expose static folder<br/>  app.use('/', express.static(rootPath + 'client/static'));<br/>	// ... other routes<br/>}</span></pre><p id="28ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了测试这一点，首先我们进入主机文件夹，并运行<code class="fe lm ln lo lp b">node server</code>。然后浏览到<code class="fe lm ln lo lp b">localhost:1212</code>，为了区分静态文件和角度服务文件，我们执行以下操作:</p><ul class=""><li id="a240" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx nt le lf lg bi translated">将静态文件的标题改为我们能够识别的名称，比如“静态…”</li><li id="e2c2" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated">在浏览中禁用 JavaScript</li></ul><p id="3729" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们看到标题改变了，那么静态页面就被提供了。当然，JavaScript 在启用时会水化，Angular 客户端会取而代之。</p><h1 id="0608" class="nd ls in bd lt ne nf ng lw nh ni nj lz jt nk ju mc jw nl jx mf jz nm ka mi nn bi translated">单一多语言版本</h1><p id="89ae" class="pw-post-body-paragraph kc kd in ke b kf no jo kh ki np jr kk kl nq kn ko kp nr kr ks kt ns kv kw kx ig bi translated">在<strong class="ke io">扭曲角度定位</strong>的罪恶中进一步沉沦，让我们在相同的构建中为不同的语言创建静态文件，为此，休息一下，下周再回来。😴</p><p id="25dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢你阅读这篇简短的介绍，如果你开始看到替身，请告诉我。</p><h1 id="508d" class="nd ls in bd lt ne nf ng lw nh ni nj lz jt nk ju mc jw nl jx mf jz nm ka mi nn bi translated">资源</h1><ul class=""><li id="b0bb" class="ky kz in ke b kf no ki np kl nv kp nw kt nx kx nt le lf lg bi translated"><a class="ae lq" href="https://angular.io/guide/prerendering" rel="noopener ugc nofollow" target="_blank">角度—预渲染</a></li><li id="7764" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-express-prerender" rel="noopener ugc nofollow" target="_blank"> StackBlitz 项目</a></li><li id="be03" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://expressjs.com/en/4x/api.html" rel="noopener ugc nofollow" target="_blank"> Express API </a></li><li id="da81" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank"> NodeJs 文件系统</a></li><li id="7606" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" rel="noopener ugc nofollow" target="_blank"> MDN 获取</a></li><li id="751a" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank">节点取库</a></li></ul><h1 id="ecb4" class="nd ls in bd lt ne nf ng lw nh ni nj lz jt nk ju mc jw nl jx mf jz nm ka mi nn bi translated">相关职位</h1><ul class=""><li id="8171" class="ky kz in ke b kf no ki np kl nv kp nw kt nx kx nt le lf lg bi translated"><a class="ae lq" href="https://garage.sekrab.com/posts/alternative-way-to-localize-in-angular" rel="noopener ugc nofollow" target="_blank">角度定位的替代方式</a></li><li id="1148" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx nt le lf lg bi translated"><a class="ae lq" href="https://garage.sekrab.com/posts/loading-external-configurations-in-angular-universal" rel="noopener ugc nofollow" target="_blank">在角度通用中加载外部配置</a></li></ul><div class="ny nz gp gr oa ob"><a href="https://garage.sekrab.com/posts/prerender-routes-in-express-server-for-angular-part-i" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">Angular - Part I，Angular - Sekrab 车库的 Express 服务器中的预呈现程序路线</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在进行我们自己的预渲染时，我想检查两种方法。好的 ol' Express 服务器附带的 Angular…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">garage.sekrab.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op oq ob"/></div></div></a></div></div></div>    
</body>
</html>