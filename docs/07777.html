<html>
<head>
<title>Improving React application performance using code splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用代码分割提高 React 应用程序的性能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/code-splitting-in-react-js-c68dcb4e153b?source=collection_archive---------10-----------------------#2022-04-22">https://blog.devgenius.io/code-splitting-in-react-js-c68dcb4e153b?source=collection_archive---------10-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/84cc44be235e8bb95898733d947e1cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4igdK3O6ky2hDiRRijyxg.png"/></div></div></figure><div class=""/><p id="2f48" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大量 React JS 应用程序由许多组件、方法和库构建而成。尽管它们非常有用，但最终会使您的应用程序变得非常庞大。如果你不优化代码或者选择只显示需要的代码，将会严重影响应用程序的性能。</p><p id="a2f0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="kt">注:</em> </strong> <em class="kt">本文需要 React 和 components 的先验知识。</em></p><p id="d42d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们该怎么做才能避免这种情况？答案是<strong class="jx iz">代码拆分</strong>。它的原始文档是<a class="ae ku" href="https://reactjs.org/docs/code-splitting.html#code-splitting" rel="noopener ugc nofollow" target="_blank">这里是</a>。它的简单解释是，它可以帮助你“延迟加载”用户当前需要的东西，这可以大大提高你的应用程序的性能。</p><h1 id="a333" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">首先，什么是捆绑销售？</h1><blockquote class="lt lu lv"><p id="60bf" class="jv jw kt jx b jy jz ka kb kc kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ks ig bi translated">这是导入文件并将其捆绑到单个文件中的过程，捆绑 Webpack、Rollup 和 merging，使用这些是为了将我们的代码捆绑成缩小的格式，但这并不保证这一点。</p></blockquote><p id="5bfe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么我们如何保证？</p><p id="f053" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用的概念叫做<strong class="jx iz">延迟加载。</strong></p><blockquote class="lt lu lv"><p id="c37e" class="jv jw kt jx b jy jz ka kb kc kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ks ig bi translated">我们只是拆分代码，这样我们就可以知道在什么时候加载哪个特定的组件，从而优化我们的网站性能。</p></blockquote><h1 id="905b" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">延迟加载组件</h1><p id="9e59" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">为了理解延迟加载，我制作了一个简单的应用程序，我们将使用它来检查代码分割应用程序之前和之后的结果。</p><p id="96d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用一个<strong class="jx iz">食品车</strong>应用程序来跟踪这个主题，并给出一个例子。</p><h1 id="05b2" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">示例:添加到购物车应用程序</h1><p id="611e" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">它的后端是用 node.js 做的，把数据给我们的前端。我们的前端由 React.js 组成，分为屏幕和组件。这个例子上传在<a class="ae ku" href="https://github.com/ahmadrazach/Javascript-Challanges/tree/main/food-cart" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。我们的应用程序结构如下:</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8f0a22979d774101043f8271b252352d.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*SUNgFXGXTi7D3-AxmlWk4w.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">食品车应用结构</figcaption></figure><p id="09f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过进入文件夹并在终端上运行命令来运行它:</p><pre class="mf mg mh mi gt mn mo mp mq aw mr bi"><span id="4010" class="ms kw iy mo b gy mt mu l mv mw">npm run dev</span></pre><p id="449f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您将看到下面的应用程序。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ab31a65db4ec9b0ebda3b50399af865f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*hUcxCwzK70zfZzykloFHmw.gif"/></div></figure><p id="4113" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从主页中选择一个产品，并将其添加到购物车中。转到购物车页面查看所有选中的产品，并查看它们的总价。</p><h1 id="e12b" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">应用程序性能</h1><p id="e724" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">现在让我们来看看下载我们的应用程序 Lighthouse 信息的应用程序的性能。我们将比较对应用程序应用代码分割前后的性能。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi my"><img src="../Images/83150ec0ca929c75e031d49ca2e43c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*xk_vFjyK40zgL3miVKE6Iw.png"/></div></figure><p id="b1aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Homescreen.js </em></p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="56cf" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">React.lazy()</h1><p id="9e72" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">因此，我们想添加一些东西，当我们的应用程序从 API 加载产品数据时，我们可以显示这些东西。我们将在产品组件上使用<em class="kt"> React.lazy() </em>并像这样导入它:</p><pre class="mf mg mh mi gt mn mo mp mq aw mr bi"><span id="bb02" class="ms kw iy mo b gy mt mu l mv mw">//in HomeScreen.js<br/>import React from 'react';</span><span id="b5e1" class="ms kw iy mo b gy nb mu l mv mw">const Product=React.lazy(()=&gt;import ('../components/Product'))</span></pre><h1 id="c8a4" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">悬疑成分</h1><p id="a696" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">很简单！我们必须将惰性组件包装在悬念组件中，以便在惰性组件准备工作时显示一些后备组件。</p><p id="cbb0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">懒惰组件应该在<a class="ae ku" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">悬念</strong> </a> <strong class="jx iz">组件</strong>中呈现，以提供一个<strong class="jx iz">回退</strong>。在回退中，我们将告诉应用程序在惰性组件准备时应该做什么。现在我需要给一些东西，这样它可以在我准备好的时候被加载！</p><p id="6acd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们提供了<strong class="jx iz">加载器组件</strong>和一个 h3 标题“获取产品…”。</p><p id="f5d7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Homescreen.js </em></p><pre class="mf mg mh mi gt mn mo mp mq aw mr bi"><span id="2af3" class="ms kw iy mo b gy mt mu l mv mw">&lt;Suspense fallback=(</span><span id="7a84" class="ms kw iy mo b gy nb mu l mv mw">&lt;&gt;</span><span id="dc65" class="ms kw iy mo b gy nb mu l mv mw">&lt;Loader/&gt;</span><span id="492c" class="ms kw iy mo b gy nb mu l mv mw">&lt;h3&gt; Fetching Products ...&lt;/h3&gt;</span><span id="942a" class="ms kw iy mo b gy nb mu l mv mw">&lt;/&gt;</span><span id="6cea" class="ms kw iy mo b gy nb mu l mv mw">}&gt;</span><span id="bfd3" class="ms kw iy mo b gy nb mu l mv mw">&lt;Row&gt;</span><span id="8c7a" class="ms kw iy mo b gy nb mu l mv mw">{</span><span id="4234" class="ms kw iy mo b gy nb mu l mv mw">products.map((product,key)=&gt;(</span><span id="5f6e" class="ms kw iy mo b gy nb mu l mv mw">&lt;Col sm={12} md={6} lg={4} xl={3} key={key}&gt;</span><span id="55f2" class="ms kw iy mo b gy nb mu l mv mw">&lt;Product product={product}/&gt;</span><span id="2485" class="ms kw iy mo b gy nb mu l mv mw">&lt;/Col&gt;</span><span id="f582" class="ms kw iy mo b gy nb mu l mv mw">))</span><span id="47a3" class="ms kw iy mo b gy nb mu l mv mw">}</span><span id="396f" class="ms kw iy mo b gy nb mu l mv mw">&lt;/Row&gt;</span><span id="1750" class="ms kw iy mo b gy nb mu l mv mw">&lt;/Suspense&gt;</span></pre><p id="4060" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">添加代码拆分后，我们的<em class="kt"> Homescreen.js </em>文件如下:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3af3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，它将在主屏幕前端给出以下结果</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/c180d0206e46dbd56659fd3975e563e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RM_vbozfIVw-HIz1x_tVyg.gif"/></div></div></figure><p id="ad59" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们的应用程序加载产品时，我们看到了一个加载器和获取产品的标题。因此，这里的悬念是说，当你[产品组件]正在加载懒惰，我得到了你，并定义一些显示，当你准备好了。</p><p id="470b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">耶！所以我们得到了一切！对吗？实际上不是，这是个圈套！</p><p id="7bd6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们显示一段时间的回退，并等待加载[Products Component]惰性组件。如果过一会儿出现错误，无法加载，该怎么办？当然，我们不希望用户等待一段时间后看到一个危险的错误页面，对吗？</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/03c4fe5daa48ce43b2d4f94b400bdeb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HmkIe9t2rU5eMlFj7qJ1Q.png"/></div></div></figure><p id="97fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个叫做误差边界的概念。</p><h1 id="00f4" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">误差边界</h1><p id="7dfd" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">去错误边界<a class="ae ku" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">文档</a>看更多，但是很简单:</p><blockquote class="lt lu lv"><p id="4b28" class="jv jw kt jx b jy jz ka kb kc kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ks ig bi translated"><strong class="jx iz">如果模块加载失败，将触发错误。错误边界让我们可以像专家一样处理错误，并展示良好的用户体验。</strong></p></blockquote><p id="438e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">它们捕捉子组件树中任何地方的 JavaScript 错误，记录这些错误并显示一个后备 UI </strong></p><p id="6a96" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，那太好了。怎么做？</p><p id="00b0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您必须使用 ErrorBoundary 组件，并将其包装在包装 lazy 组件的悬念组件上。耶！</p><p id="204b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用一个<a class="ae ku" href="https://www.npmjs.com/package/react-error-boundary?activeTab=dependencies" rel="noopener ugc nofollow" target="_blank"> npm 包</a>作为错误边界，用它包装我们的暂记组件，并给出我们的后备组件。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0a27" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们的产品组件出现内部错误时，它将触发<strong class="jx iz">回退组件</strong>或<strong class="jx iz">错误边界</strong>，在我们的情况下，这是 h3 标题，显示<strong class="jx iz">“加载错误，请刷新”。这只是一个展示其工作原理的例子。</strong></p><p id="2786" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们刚刚讨论了组件的代码分割，以提高性能和视觉效果。干得好！</p><p id="3181" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看基于路由的代码分割技术。</p><h1 id="c736" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">基于路由的代码拆分</h1><p id="37dd" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">我们不希望我们的应用程序在开始时加载所有的路线页面。它只加载我们在页面上使用的数据块！就这么简单！</p><p id="bd7b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照我们的例子，我们可以看到我们的应用程序在开始时加载了所有的屏幕(在我们的例子中是 2 个)。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/87b77b2ae75852bf00e5c1045b040c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*yREbS0amErNhEnJ0GDFlLA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">没有路由分割</figcaption></figure><p id="0ef1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了添加路线分割，我们将只使用暂记组件包装我们的路线组件，给出一个回退值，在我们的例子中是文本“正在加载…”！</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e8749214d98c2ee7bdebbc55027f0a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*0ZTFuQ25x5-AGbp_jSXhRQ.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">当我们在 HomeScree.js 上时进行路线分割</figcaption></figure><p id="9463" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看应用程序的性能提高了多少。我们再次下载我们的灯塔报告。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/50a50b8f32d4a2c3efcf3fc590441d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*Ru6yzJxxOWMjrsSh0P1qKw.png"/></div></figure><p id="969a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">这一次，我们的性能提高了 35 %,这非常好，因为我们仅通过添加代码分割就将性能提高了 7%。</strong></p><h1 id="aba2" class="kv kw iy bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论:</h1><p id="6da5" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">代码分割是优化应用程序性能的一个很好的方法，可以减少与应用程序交互所需的数据，并增强用户体验。应用程序不同部分的物理分离，并能够决定浏览器何时加载它们。</p><p id="c95d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">这只是我发表的第一篇文章，所以请给出你最好的建议。我肯定会喜欢的。谢谢你陪我走了这么远！</em></p></div></div>    
</body>
</html>