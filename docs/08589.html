<html>
<head>
<title>React 18 — Automatic Batching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18 —自动配料</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-18-automatic-batching-dc0de5eb6165?source=collection_archive---------10-----------------------#2022-06-26">https://blog.devgenius.io/react-18-automatic-batching-dc0de5eb6165?source=collection_archive---------10-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ac06" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解 React 自动批处理状态更新</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/057fd1251016b7458ed872fdde3d0146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWtb1OSCvzG8cp0q5K0E8g.png"/></div></div></figure><h1 id="98d0" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React 17 发生了什么？</h1><p id="783e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React17 只支持<strong class="li io"><em class="mc"/></strong>对浏览器事件(如点击)进行批处理</p><p id="d498" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">考虑下面的片段。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/39136a8bd2332a2ec25a1ae276d380d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LISIPMW8XqZE1g8oerHNw.png"/></div></div></figure><p id="4781" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">当您按下按钮时。作为函数体<code class="fe mj mk ml mm b">handleOnClick </code>将执行并尝试更新两个状态的<strong class="li io"> <em class="mc">计数器</em> </strong>和<strong class="li io">isE<em class="mc">enable</em></strong>。如果你检查控制台。您只会在看到一次来自<code class="fe mj mk ml mm b">Logger component</code>的信息。这就是批处理。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/6a2d5ca961175848c79bb1353fb1fb4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dK6VmQY-Sjy3-4j1HhS53g.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">记录器组件仅重新呈现 1 次，即使更新了 2 个状态</figcaption></figure><p id="f3e8" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">正如我提到的，React17 将只批处理<em class="mc">浏览器事件</em>，但是一旦数据被获取，更新状态又如何呢？让我们看看控制台上有多少渲染消息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/7f2cefe07fcdbcc37f859f68f63bcab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozNJpmIBz1BIDYhY8zktKA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">完成承诺后更新状态。</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/95b3bc57b6e40b019fab31fb731cb021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VijE8UtNZR6Rda8T--YE1w.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">在这种情况下，记录器重新渲染 2 次</figcaption></figure><p id="d40c" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">总共 2 个渲染。你可能会想，<strong class="li io"> <em class="mc">“嗯，它只要渲染两次；</em> </strong>这不会对性能影响不大的🧐</p><p id="10f6" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">不要，一旦你的应用程序开始增长，有很多嵌套的组件。重新呈现父组件时，性能可能会受到影响，因为每次状态更新时，整个组件树都会重新呈现。</p><p id="a265" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><a class="ae mt" href="https://codesandbox.io/s/react17-batching-state-update-example-zw27ix" rel="noopener ugc nofollow" target="_blank">React 17 批处理状态更新示例的沙盒。</a></p><h1 id="b880" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React 18 中的批处理是什么？</h1><p id="7050" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当您迁移到 React 版本 18 时，<strong class="li io"> <em class="mc">组件的所有状态更新，不管它们来自哪里，都将被批处理。</em> </strong></p><p id="91e4" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">正如我提到的，<em class="mc">状态更新无论是承诺、事件处理程序、超时还是任何其他事件都将批处理</em> <strong class="li io"> <em class="mc">，与 React 事件</em> </strong> <em class="mc">内部的更新方式相同。可怕的🤩</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/0e57fa71e026025be12ffdc5896c1607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6SzZW9M7WPzNzruAfRusQ.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/9918b287c8043e730135adffd9ea1193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AG8dooW-LDyAW4kCHR_nwg.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/3ee01b9a3e6d5bad8d32dc322e38e90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rG-AAKsYosoPveUqSRFscQ.png"/></div></div></figure><p id="4dbc" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><a class="ae mt" href="https://codesandbox.io/s/react-18-batching-state-update-kni7n2?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">React 18 自动批处理示例的沙盒</a></p><h1 id="ba98" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">如何防止自动批处理？</strong></h1><p id="f743" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">自动批处理非常有助于将一组状态更新到一个渲染中，但是有一种方法可以阻止这种行为。您可以使用<strong class="li io">中的<strong class="li io"> flushSync </strong>和<strong class="li io"> react-dom </strong>包<strong class="li io"> </strong>来退出批处理。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/ca0586186c24233b11888d1f94078173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9vMTN_bxVqwFVAy-8Ua2w.png"/></div></div></figure><p id="83c7" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">我们包装了用<strong class="li io"> flushSync 更新状态的函数。</strong>在这种情况下，<strong class="li io"><em class="mc">setCounter</em>T5<strong class="li io">和<em class="mc">setIsEnable</em>T9】。一旦每个功能被执行。记录器将重新绘制<strong class="li io"> 2 次。</strong></strong></strong></p><h1 id="efff" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">结论</strong></h1><p id="499e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React 18 将多个状态更新组合成一个单一的重新呈现，而不管它们来自哪里(承诺、超时、事件处理程序等)。)以获得更少的组件重新渲染和更好的性能。然而，如果你不需要这种行为。React 为批处理的退出选项提供了<strong class="li io"> flushSync </strong></p><p id="f039" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">希望您了解 React 18 的自动配料是怎么回事。感谢阅读👋🏼</p></div></div>    
</body>
</html>