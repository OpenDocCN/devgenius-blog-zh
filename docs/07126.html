<html>
<head>
<title>Predicting Churn Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习预测客户流失</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/predicting-churn-using-machine-learning-383dcbc8dd67?source=collection_archive---------7-----------------------#2022-02-28">https://blog.devgenius.io/predicting-churn-using-machine-learning-383dcbc8dd67?source=collection_archive---------7-----------------------#2022-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/828037d4ad3bd4e1e05016a302901513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmI41EHgKQ1bnhWYI3KkhQ.png"/></div></div></figure><p id="7a84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">客户流失是指客户停止使用一家公司的服务。因此，流失预测可以识别出有可能取消合同的客户。如果公司能够预测到这一点，他们可以在这些服务上提供折扣来留住客户。为了预测客户流失，我将使用机器学习。为了创建一个机器学习模型，我将使用来自<a class="ae kt" href="https://www.kaggle.com/blastchar/telco-customer-churn" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的顾客数据。在此基础上，我将建立一个模型来识别即将流失的现有客户。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="0724" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据剖析</h1><h2 id="5769" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">导入数据</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="aba2" class="lz lc in mq b gy mu mv l mw mx">#DATA PROFILING<br/>#Importing Data<br/>import pandas as pd<br/>pd.set_option('display.max_columns',None)<br/>df = pd.read_csv('Telco Customer Churn.csv')</span></pre><p id="7b5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是初始化库，使用<strong class="jx io">熊猫</strong>、<strong class="jx io">T5】将数据集导入 Python，并将其赋值为<strong class="jx io"> df </strong>。从 Kaggle 下载的数据将被保存为<strong class="jx io">‘Telco Customer churn . CSV’。</strong></strong></p><h2 id="3768" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">显示数据的长度</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="29c4" class="lz lc in mq b gy mu mv l mw mx">#Showing The Length of The Data<br/>print("\nThe Length of The Data: ", len(df))</span></pre><p id="0be3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二步是使用<strong class="jx io"> len() </strong>显示数据集中有多少数据。结果是这个数据的大小是<strong class="jx io"> 7043 </strong>。</p><h2 id="17a6" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">显示数据的形状</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8d0f" class="lz lc in mq b gy mu mv l mw mx">#Showing The Shape of The Data<br/>print("\nThe Shape of The Data: ", df.shape)</span></pre><p id="6d5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三步是使用<strong class="jx io">显示数据的形状。形状</strong>。结果是该数据有<strong class="jx io"> 7043 行和 21 列</strong>。</p><h2 id="26f4" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">显示数据的信息</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1871" class="lz lc in mq b gy mu mv l mw mx">#Showing The Information of The Data<br/>print("\nThe Information of The Data: ")<br/>print(df.info())</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/edfe1a4d4111bbf5b385b309912b2bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*we0tnxE49Lx_36hBaCPHVw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图一。</strong>数据的信息</figcaption></figure><p id="c615" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第四步是使用<strong class="jx io">从数据中获取信息。info() </strong></p><h2 id="f1e2" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">显示统计计算</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9694" class="lz lc in mq b gy mu mv l mw mx">#Showing The Statistical Calculations<br/>print("\nThe Statistical Calculations: ")<br/>print(df.describe().T)</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/30f74f4d4e2176bcea60cf0ec6d45d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*cx9f5s7pRrUU-44XpM0xWQ.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图二。</strong>统计计算的结果</figcaption></figure><p id="5078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第五步是使用<strong class="jx io">显示数据的统计分析。</strong>形容()。</p><h2 id="41c0" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">显示唯一的数据</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5610" class="lz lc in mq b gy mu mv l mw mx">#Showing The Unique Data<br/>print("\nThe Unique Data: ")<br/>print(df.nunique())</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/70d13e06b86595432c5ff28677a3db57.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*901_iwB6uewu-WxuuNt0-Q.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图三。</strong>每列中具有唯一值的数据量</figcaption></figure><p id="2de8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据分析的第六步是使用函数<strong class="jx io">显示每一列的唯一数据。努尼克()</strong>。</p><h2 id="58c3" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">更改列名</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1bd1" class="lz lc in mq b gy mu mv l mw mx">#Changing The Column's Name<br/>df.rename(columns={'customerID': 'CustomerID',<br/>                   'gender': 'Gender',<br/>                   'tenure': 'Tenure'}, inplace=True)</span></pre><h2 id="2a58" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">寻找相关性</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="567c" class="lz lc in mq b gy mu mv l mw mx">#Looking For A Correlation<br/>import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>plt.figure(figsize=(17, 15))<br/>corr_mask = np.triu(df.corr())<br/>h_map = sns.heatmap(df.corr(), mask=corr_mask, annot=True, cmap='Blues')<br/>plt.yticks(rotation=360)<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/6e703bc0b206cfa40018dfb91f95bfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygw8rT78MzISHtRzFxpt5A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 4。</strong>热图关联</figcaption></figure><p id="d8df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据分析的最后一步是通过可视化来寻找每个数据的相关性。这部分我就用<strong class="jx io"> Seaborn </strong>、<strong class="jx io"> Matplotlib </strong>和<strong class="jx io"> Numpy </strong>。</p><h1 id="a8ca" class="lb lc in bd ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly bi translated">数据清理</h1><h2 id="7934" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">寻找每一列中缺少的值</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a3bf" class="lz lc in mq b gy mu mv l mw mx">#DATA CLEANSING<br/>#Looking For The Missing Value in Each Column<br/>print("\nLooking For The Missing Value in Each Column: ")<br/>print(df.isnull().sum())</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/124965ed3bd54755b3610355a8f83942.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*K5knAyr2xgoTv73iaq1yAA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 5。</strong>每列中缺失值的数量</figcaption></figure><p id="1b21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我正在使用<strong class="jx io"> isnull() </strong>和<strong class="jx io"> sum() </strong>来找出缺少的值是多少。结果表明该数据集中没有缺失值。</p><h2 id="c86b" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">删除不必要的列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5d6c" class="lz lc in mq b gy mu mv l mw mx">#Removing Unnecessary Column<br/>df = df.drop(['CustomerID'], axis=1)<br/>print("\nThe Shape of The Data: ", df.shape)</span></pre><h2 id="26a5" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查性别栏</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8554" class="lz lc in mq b gy mu mv l mw mx">#Checking The Gender Column<br/>print("\nChecking The Gender Column")<br/>sns.countplot(x=df['Gender'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/befef27105c24fe48c13bcd5bf9f1727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIv6_i1VWGlwrwDUla9-4Q.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 6。</strong>性别栏的可视化</figcaption></figure><p id="484c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该列包含客户是男性还是女性。</p><h2 id="f499" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查高级定制列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2c37" class="lz lc in mq b gy mu mv l mw mx">#Checking The SeniorCitizen Column<br/>print("\nChecking The SeniorCitizen Column")<br/>sns.countplot(x=df['SeniorCitizen'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/143257b5a975cf121d9e3a27b2645c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKiDaL3WyyxyqEiPylYejw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 7。</strong>老年人列的可视化</figcaption></figure><p id="fd6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该列包含客户是否是老年人(1 =是，0 =否)。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ee4b" class="lz lc in mq b gy mu mv l mw mx">mask_sc = {<br/>    0   :'No',<br/>    1   :'Yes'}<br/>df['SeniorCitizen'] = df['SeniorCitizen'].map(mask_sc)<br/>sns.countplot(x=df['SeniorCitizen'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/063414093c3e9b92fb935093c79f3c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y0wR8ignt9hxuwPz0CDmA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 8。</strong>更改值后高级定制列的可视化</figcaption></figure><h2 id="07a0" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查合作伙伴列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ca62" class="lz lc in mq b gy mu mv l mw mx">#Checking The Partner Column<br/>print("\nChecking The Partner Column")<br/>sns.countplot(x=df['Partner'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/eea11906468f6e7afe93a35d3b86f1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYdmONvdXYOGO5tMEQW00Q.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图九。</strong>合作伙伴栏的可视化</figcaption></figure><p id="c02b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有合作伙伴(是，否)。</p><h2 id="a6c6" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查从属列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7a47" class="lz lc in mq b gy mu mv l mw mx">#Checking The Dependents Column<br/>print("\nChecking The Dependents Column")<br/>sns.countplot(x=df['Dependents'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/ed84e14999c165649b779dfd0a041f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cL8chaSDcX7IFyDZJplxQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 10。</strong>家属列的可视化</figcaption></figure><p id="f90e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有家属(是，否)。</p><h2 id="0a9e" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查任期列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f5d7" class="lz lc in mq b gy mu mv l mw mx">#Checking The Tenure Column<br/>print("\nChecking The Tenure Column")<br/>sns.countplot(x=df['Tenure'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/1d7250eb6fa7e0296af2e8f83fab87b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsqQofVWKDFYF7fJ0hbgXw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 11。</strong>任期列的可视化</figcaption></figure><p id="1469" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户在该公司的月数。</p><h2 id="e8bd" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查电话服务列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a409" class="lz lc in mq b gy mu mv l mw mx">#Checking The PhoneService Column<br/>print("\nChecking The PhoneService Column")<br/>sns.countplot(x=df['PhoneService'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/0b65300a674b0740ab90a265faa20297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYTRbGkx7aC60m8QTqz9qw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 12。</strong>电话服务列的可视化</figcaption></figure><p id="1bfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有电话服务(是，否)。</p><h2 id="ed74" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查多行列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4243" class="lz lc in mq b gy mu mv l mw mx">#Checking The MultipleLines Column<br/>print("\nChecking The MultipleLines Column")<br/>sns.countplot(x=df['MultipleLines'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/c35064f4c736751f2bb1eb777d9a69a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBpwrL_j47Tiqkhv2Fx0Pw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 13。</strong>多线列的可视化</figcaption></figure><p id="9b98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有多条线路(是、否、无电话服务)。</p><h2 id="ba66" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查 InternetService 列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="75b0" class="lz lc in mq b gy mu mv l mw mx">#Checking The InternetServiceColumn<br/>print("\nChecking The InternetServiceColumn")<br/>sns.countplot(x=df['InternetService'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/44f8edfc1b8b5fce3680c527780a7e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hl75EWiAyB_9w9rR-vqAKw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 14。</strong>互联网服务栏目的可视化</figcaption></figure><p id="188e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此栏包含客户的互联网服务提供商(DSL、光纤、否)。</p><h2 id="9f60" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查 OnlineSecurity 列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1aca" class="lz lc in mq b gy mu mv l mw mx">#Checking The OnlineSecurity Column<br/>print("\nChecking The OnlineSecurity Column")<br/>sns.countplot(x=df['OnlineSecurity'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/7c2f3c751cd8968f861d06b530589455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFdBidxmvFC9sRGZnYyVqw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 15。</strong>在线安全列的可视化</figcaption></figure><p id="02c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否拥有在线安全(是、否、无互联网服务)。</p><h2 id="b1a7" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查 OnlineBackup 列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="36ac" class="lz lc in mq b gy mu mv l mw mx">#Checking The OnlineBackup Column<br/>print("\nChecking The OnlineBackup Column")<br/>sns.countplot(x=df['OnlineBackup'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/e582d37d26b45eb6e9bef517197bd9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nntWe8axwKPepGoA5BMsw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 16。</strong>在线备份列的可视化</figcaption></figure><p id="4efe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有在线备份(是、否、无互联网服务)。</p><h2 id="42bd" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查设备保护列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6a49" class="lz lc in mq b gy mu mv l mw mx">#Checking The DeviceProtection Column<br/>print("\nChecking The DeviceProtection Column")<br/>sns.countplot(x=df['DeviceProtection'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f4da6fd16c931b85e76758c0784fa0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxv1wjNaVYCfiGFlaS0zOA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 17。</strong>设备保护栏的可视化</figcaption></figure><p id="c230" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有设备保护(是、否、无互联网服务)。</p><h2 id="1ac8" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查技术支持栏</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="812f" class="lz lc in mq b gy mu mv l mw mx">#Checking The TechSupport Column<br/>print("\nChecking The TechSupport Column")<br/>sns.countplot(x=df['TechSupport'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/5090e828234ef87443d17c3cd254c162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ae0p5Aj1iM2h8pRhP84w9Q.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 18。</strong>技术支持专栏的可视化</figcaption></figure><p id="88c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有技术支持(是、否、无互联网服务)。</p><h2 id="2d2a" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查 StreamingTV 列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b913" class="lz lc in mq b gy mu mv l mw mx">#Checking The StreamingTV Column<br/>print("\nChecking The StreamingTV Column")<br/>sns.countplot(x=df['StreamingTV'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f41c0e61135a905770222c94dc09461b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ol1kFwPdYwACX8NY6ZMr9g.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 19。</strong>流媒体电视栏目的可视化</figcaption></figure><p id="9f66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有流媒体电视(是、否、无互联网服务)。</p><h2 id="e873" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查串流电影栏</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ed24" class="lz lc in mq b gy mu mv l mw mx">#Checking The StreamingMovies Column<br/>print("\nChecking The StreamingMovies Column")<br/>sns.countplot(x=df['StreamingMovies'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/a2356357658f5816c2658a0b4b7371ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek4HSui_TwGrUMSBXLjg5g.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 20。</strong>流电影列的可视化</figcaption></figure><p id="9d6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此列包含客户是否有流媒体电影(是，否，无互联网服务)。</p><h2 id="dea7" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查合同栏</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6645" class="lz lc in mq b gy mu mv l mw mx">#Checking The Contract Column<br/>print("\nChecking The Contract Column")<br/>sns.countplot(x=df['Contract'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/e5ca3d130d708445eca9761d0cadc14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCLhkBAt1b5WIe9wOUg5PQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 21。</strong>合同栏的可视化</figcaption></figure><p id="7086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此栏包含客户的合同期限(逐月、一年、两年)。</p><h2 id="ca60" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查无纸账单列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6723" class="lz lc in mq b gy mu mv l mw mx">#Checking The PaperlessBilling Column<br/>print("\nChecking The PaperlessBilling Column")<br/>sns.countplot(x=df['PaperlessBilling'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/fd8088a5684c474f3144d120d8d90108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olbhC5DTT5zrJJq6G9w7Qg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 22。</strong>无纸化账单栏的可视化</figcaption></figure><p id="c3b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本栏包含客户是否有无纸化账单(是，否)。</p><h2 id="da74" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查 PaymentMethod 列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5c59" class="lz lc in mq b gy mu mv l mw mx">#Checking The PaymentMethod Column<br/>print("\nChecking The PaymentMethod Column")<br/>sns.countplot(x=df['PaymentMethod'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/0f3410a52addea50a30f9a750a9d4933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyQVDrPkAIwgiee7SKhoKQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 22。</strong>支付方式列的可视化</figcaption></figure><p id="731b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此栏包含客户的付款方式(电子支票、邮寄支票、银行转账(自动)、信用卡(自动))。</p><h2 id="e67a" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查总费用列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8cfd" class="lz lc in mq b gy mu mv l mw mx">#Checking The TotalCharges Column<br/>print("\nChecking The TotalCharges Column")<br/>df["TotalCharges"] = pd.to_numeric(df["TotalCharges"],errors='coerce')</span></pre><p id="a8e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io">图 1 </strong>中，TotalCharges 列有一个“对象”类型。同时，TotalCharges 列的内容是向客户收取的总金额。所以我要把这种类型的列转换成数值型。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f1b2" class="lz lc in mq b gy mu mv l mw mx">print("\nLooking For The Missing Value in Each Column After Changing The TotalCharges Column: ")<br/>print(df.isnull().sum())</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c075f949bdb8069cbe889f2779a7f7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*pG-AmI1Gs0OD0UAqL6YTvw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 23。</strong>更改 TotalCharges 列后，每列中缺少的值的数量</figcaption></figure><p id="cd19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将 TotalCharges 列转换为数字后，我将在每一列中查找缺失值，以确保数据集中没有缺失值。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="18f4" class="lz lc in mq b gy mu mv l mw mx">df = df.loc[(df['TotalCharges'].notnull())]<br/>print("\nLooking For The Missing Value in Each Column After Removing Missing Values: ")<br/>print(df.isnull().sum())</span></pre><p id="40bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果是 TotalCharges 列中缺少 11 个值，正如您在图 23 中看到的。在下一步中，我将从数据集中删除这个缺失的值。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/14b9823b42febba295d59992e72da14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*FnNXQthSeiBV8c4Z_4tLaw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 24。</strong>删除缺失值后每列中缺失值的数量</figcaption></figure><h2 id="973c" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">检查流失列</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c370" class="lz lc in mq b gy mu mv l mw mx">#Checking The Churn Column<br/>print("\nChecking Label Distribution Using .groupby() And .size() Functions")<br/>mask_churn = {<br/>    'No'    : 0,<br/>    'Yes'   : 1}<br/>df['Churn'] = df['Churn'].map(mask_churn)<br/>print(df.groupby('Churn').size())<br/>sns.countplot(x=df['Churn'], palette='flare')<br/>plt.show()</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/540ea9a8f90fbb38126491c2f34e1432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-31kUu4PrSqRrvoolCSxYg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 25。</strong>流失列的可视化</figcaption></figure><p id="e467" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此栏包含客户是否搅拌过(是或否)。搅动(1)的客户数是 1869，而未搅动(0)的客户数是 5163。<br/> <br/>为什么了解标签分布很重要？如果标签分布不平衡，模型将很难学习模式，并且结果可能具有误导性。如果我仍然使用不平衡的数据集，最有可能的是，模型将倾向于识别新的观察结果为非变动。</p><h2 id="fc00" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">删除重复数据</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1919" class="lz lc in mq b gy mu mv l mw mx">#Removing Duplicated Data<br/>print("\nRemoving Duplicated Data")<br/>df.drop_duplicates(inplace=True)<br/>print('The Shape of The Data After Removing The Duplicated Data: ', df.shape)</span></pre><p id="a80a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一部分，我将删除重复的数据。删除重复数据后，该数据有<strong class="jx io"> 7010 行和</strong>20 列。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="2096" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据集上标签转换</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="642a" class="lz lc in mq b gy mu mv l mw mx">#Label Conversion on The Dataset<br/>print("\nLabel Conversion on The Dataset")<br/>Gender = pd.get_dummies(df['Gender'], drop_first=True)<br/>SeniorCitizen = pd.get_dummies(df['SeniorCitizen'], drop_first=True)<br/>Partner = pd.get_dummies(df['Partner'], drop_first=True)<br/>Dependents = pd.get_dummies(df['Dependents'], drop_first=True)<br/>PhoneService = pd.get_dummies(df['PhoneService'], drop_first=True)<br/>MultipleLines = pd.get_dummies(df['MultipleLines'], drop_first=True)<br/>InternetService = pd.get_dummies(df['InternetService'], drop_first=True)<br/>OnlineSecurity = pd.get_dummies(df['OnlineSecurity'], drop_first=True)<br/>OnlineBackup = pd.get_dummies(df['OnlineBackup'], drop_first=True)<br/>DeviceProtection = pd.get_dummies(df['DeviceProtection'], drop_first=True)<br/>TechSupport = pd.get_dummies(df['TechSupport'], drop_first=True)<br/>StreamingTV = pd.get_dummies(df['StreamingTV'], drop_first=True)<br/>StreamingMovies = pd.get_dummies(df['StreamingMovies'], drop_first=True)<br/>Contract = pd.get_dummies(df['Contract'], drop_first=True)<br/>PaperlessBilling = pd.get_dummies(df['PaperlessBilling'], drop_first=True)<br/>PaymentMethod = pd.get_dummies(df['PaymentMethod'], drop_first=True)<br/><br/>df = df.drop(['Gender',<br/>              'SeniorCitizen',<br/>              'Partner',<br/>              'Dependents',<br/>              'PhoneService',<br/>              'MultipleLines',<br/>              'InternetService',<br/>              'OnlineSecurity',<br/>              'OnlineBackup',<br/>              'DeviceProtection',<br/>              'TechSupport',<br/>              'StreamingTV',<br/>              'StreamingMovies',<br/>              'Contract',<br/>              'PaperlessBilling',<br/>              'PaymentMethod'], axis=1)<br/><br/>df = pd.concat([Gender,<br/>                SeniorCitizen,<br/>                Partner,<br/>                Dependents,<br/>                PhoneService,<br/>                MultipleLines,<br/>                InternetService,<br/>                OnlineSecurity,<br/>                OnlineBackup,<br/>                DeviceProtection,<br/>                TechSupport,<br/>                StreamingTV,<br/>                StreamingMovies,<br/>                Contract,<br/>                PaperlessBilling,<br/>                PaymentMethod,<br/>                df], axis=1)</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="3e0a" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分离特征和标签</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b23f" class="lz lc in mq b gy mu mv l mw mx">#Separating Features and Labels<br/>X = df.drop('Churn', axis=1)<br/>y = df['Churn']<br/>print("\nX Dataset: ", X.shape)<br/>print("y Dataset: ", y.shape)</span></pre><p id="fee3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一部分中，我将创建两个变量:<strong class="jx io"> X </strong>只包含特性(7010 行 30 列)和<strong class="jx io"> y </strong>只包含标签(7010 行 1 列)。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="f6ca" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理不平衡的数据集</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="295f" class="lz lc in mq b gy mu mv l mw mx">#Handling The Imbalanced Dataset<br/>#Over-Sampling<br/>from imblearn.over_sampling import RandomOverSampler<br/>upsampling = RandomOverSampler(random_state=42)<br/>X_sampling, y_sampling = upsampling.fit_resample(X, y)<br/>print("\nX Dataset After Resampling: ", X_sampling.shape)<br/>print("y Dataset After Resampling: ", y_sampling.shape)</span></pre><p id="ae69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理不平衡后，该数据集包含<strong class="jx io"> 10306 行和 30 列</strong>。以前，这个数据集有 7010 行和 30 列。数字的增加是因为我在做一个<strong class="jx io">过采样。</strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="c305" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">准备培训、测试和验证数据集</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c12d" class="lz lc in mq b gy mu mv l mw mx">#Preparing Training, Testing, And Validating Dataset<br/>from sklearn.model_selection import train_test_split</span><span id="7ac5" class="lz lc in mq b gy no mv l mw mx">X_train_full, X_test, y_train_full, y_test = train_test_split(X_sampling, y_sampling, test_size=0.2, random_state=42)</span><span id="b2cb" class="lz lc in mq b gy no mv l mw mx">X_train, X_val, y_train, y_val = train_test_split(X_train_full, y_train_full, test_size=0.2, random_state=42)</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="fb88" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">建立一个机器学习模型</h1><p id="2feb" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">下一步是建立一个机器学习模型。我将对<strong class="jx io">逻辑回归</strong>、<strong class="jx io">决策树分类器</strong>、<strong class="jx io">随机森林分类器</strong>和<strong class="jx io">近邻分类器</strong>进行比较。</p><h2 id="9eb8" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">逻辑回归</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5f26" class="lz lc in mq b gy mu mv l mw mx">#Build a Machine Learning Model Logistic Regression<br/>print("\nBuild a Machine Learning Model Logistic Regression")<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.linear_model import LogisticRegression<br/>parameter = {<br/>    'solver'    : ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga']<br/>}<br/>clf = GridSearchCV(LogisticRegression(random_state=42),<br/>                   param_grid=parameter,<br/>                   cv=5,<br/>                   return_train_score=False)<br/>clf.fit(X_train, y_train)<br/>print(clf.best_estimator_)<br/>model_logreg = clf.best_estimator_<br/>model_logreg = model_logreg.fit(X_train, y_train)<br/>y_pred_logreg = model_logreg.predict(X_test)<br/><br/>#Evaluating Model Performance<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score<br/>cm = confusion_matrix(y_test, y_pred_logreg)<br/>fig, ax = plt.subplots(figsize=(5, 5))<br/>ax.matshow(cm, cmap=plt.cm.Oranges, alpha=0.3)<br/>for i in range(cm.shape[0]):<br/>    for j in range(cm.shape[1]):<br/>        ax.text(x=j, y=i, s=cm[i, j], va='center', ha='center', size='xx-large')<br/>plt.xlabel('Predictions', fontsize=18)<br/>plt.ylabel('Actuals', fontsize=18)<br/>plt.title('Confusion Matrix Logistic Regression', fontsize=18)<br/>plt.show()<br/>print('Precision: %.3f' % precision_score(y_test, y_pred_logreg))<br/>print('Recall: %.3f' % recall_score(y_test, y_pred_logreg))<br/>print('Accuracy: %.3f' % accuracy_score(y_test, y_pred_logreg))<br/>print('F1 Score: %.3f' % f1_score(y_test, y_pred_logreg))</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/e5650a8cf2a5fa4f84d0416f312d019e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aa7oo2IX4bas3QawyqZEzA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 26。</strong>逻辑回归混淆矩阵的可视化</figcaption></figure><h2 id="7918" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">决策树分类器</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="16f6" class="lz lc in mq b gy mu mv l mw mx">#Build a Machine Learning Model Decision Tree Classifier<br/>print("\nBuild a Machine Learning Model Decision Tree Classifier")<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.tree import DecisionTreeClassifier<br/>parameter = {<br/>    'criterion'    : ['gini', 'entropy']<br/>}<br/>clf = GridSearchCV(DecisionTreeClassifier(random_state=42),<br/>                   param_grid=parameter,<br/>                   cv=5,<br/>                   return_train_score=False)<br/>clf.fit(X_train, y_train)<br/>print(clf.best_estimator_)<br/>model_dtc = clf.best_estimator_<br/>model_dtc = model_dtc.fit(X_train, y_train)<br/>y_pred_dtc = model_dtc.predict(X_test)<br/><br/>#Evaluating Model Performance<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score<br/>cm = confusion_matrix(y_test, y_pred_dtc)<br/>fig, ax = plt.subplots(figsize=(5, 5))<br/>ax.matshow(cm, cmap=plt.cm.Oranges, alpha=0.3)<br/>for i in range(cm.shape[0]):<br/>    for j in range(cm.shape[1]):<br/>        ax.text(x=j, y=i, s=cm[i, j], va='center', ha='center', size='xx-large')<br/>plt.xlabel('Predictions', fontsize=18)<br/>plt.ylabel('Actuals', fontsize=18)<br/>plt.title('Confusion Matrix Decision Tree Classifier', fontsize=18)<br/>plt.show()<br/>print('Precision: %.3f' % precision_score(y_test, y_pred_dtc))<br/>print('Recall: %.3f' % recall_score(y_test, y_pred_dtc))<br/>print('Accuracy: %.3f' % accuracy_score(y_test, y_pred_dtc))<br/>print('F1 Score: %.3f' % f1_score(y_test, y_pred_dtc))</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/9010eec00b0c5ddac74641660e1f656f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bwKcfmBBrcPwqN2FNEY9A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 27。</strong>来自决策树分类器的混淆矩阵的可视化</figcaption></figure><h2 id="7ff0" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">随机森林分类器</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4e06" class="lz lc in mq b gy mu mv l mw mx">#Build a Machine Learning Model Random Forest Classifier<br/>print("\nBuild a Machine Learning Model Random Forest Classifier")<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.ensemble import RandomForestClassifier<br/>parameter = {<br/>    'criterion'    : ['gini', 'entropy']<br/>}<br/>clf = GridSearchCV(RandomForestClassifier(random_state=42),<br/>                   param_grid=parameter,<br/>                   cv=5,<br/>                   return_train_score=False)<br/>clf.fit(X_train, y_train)<br/>print(clf.best_estimator_)<br/>model_rfc = clf.best_estimator_<br/>model_rfc = model_rfc.fit(X_train, y_train)<br/>y_pred_rfc = model_rfc.predict(X_test)<br/><br/>#Evaluating Model Performance<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score<br/>cm = confusion_matrix(y_test, y_pred_rfc)<br/>fig, ax = plt.subplots(figsize=(5, 5))<br/>ax.matshow(cm, cmap=plt.cm.Oranges, alpha=0.3)<br/>for i in range(cm.shape[0]):<br/>    for j in range(cm.shape[1]):<br/>        ax.text(x=j, y=i, s=cm[i, j], va='center', ha='center', size='xx-large')<br/>plt.xlabel('Predictions', fontsize=18)<br/>plt.ylabel('Actuals', fontsize=18)<br/>plt.title('Confusion Matrix Random Forest Classifier', fontsize=18)<br/>plt.show()<br/>print('Precision: %.3f' % precision_score(y_test, y_pred_rfc))<br/>print('Recall: %.3f' % recall_score(y_test, y_pred_rfc))<br/>print('Accuracy: %.3f' % accuracy_score(y_test, y_pred_rfc))<br/>print('F1 Score: %.3f' % f1_score(y_test, y_pred_rfc))</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/65c991a2250b7a13a7d54ea937e33307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AGmJuEoHeIEEFLL1kLK7A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 28。</strong>来自随机森林分类器的混淆矩阵的可视化</figcaption></figure><h2 id="774c" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">k 近邻分类器</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e9d4" class="lz lc in mq b gy mu mv l mw mx">#Build a Machine Learning Model K-Neighbors Classifier<br/>print("\nBuild a Machine Learning Model K-Neighbors Classifier")<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.neighbors import KNeighborsClassifier<br/>parameter = {<br/>    'algorithm'    : ['ball_tree', 'kd_tree', 'brute']<br/>}<br/>clf = GridSearchCV(KNeighborsClassifier(),<br/>                   param_grid=parameter,<br/>                   cv=5,<br/>                   return_train_score=False)<br/>clf.fit(X_train, y_train)<br/>print(clf.best_estimator_)<br/>model_knc = clf.best_estimator_<br/>model_knc = model_knc.fit(X_train, y_train)<br/>y_pred_knc = model_knc.predict(X_test)<br/><br/>#Evaluating Model Performance<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score<br/>cm = confusion_matrix(y_test, y_pred_knc)<br/>fig, ax = plt.subplots(figsize=(5, 5))<br/>ax.matshow(cm, cmap=plt.cm.Oranges, alpha=0.3)<br/>for i in range(cm.shape[0]):<br/>    for j in range(cm.shape[1]):<br/>        ax.text(x=j, y=i, s=cm[i, j], va='center', ha='center', size='xx-large')<br/>plt.xlabel('Predictions', fontsize=18)<br/>plt.ylabel('Actuals', fontsize=18)<br/>plt.title('Confusion Matrix K-Neighbors Classifier', fontsize=18)<br/>plt.show()<br/>print('Precision: %.3f' % precision_score(y_test, y_pred_knc))<br/>print('Recall: %.3f' % recall_score(y_test, y_pred_knc))<br/>print('Accuracy: %.3f' % accuracy_score(y_test, y_pred_knc))<br/>print('F1 Score: %.3f' % f1_score(y_test, y_pred_knc))</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/33591b294c2477af5d814899d3753c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23IJFJibVoEq-AoobNdt4g.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">图 29。</strong>来自 K 近邻分类器的混淆矩阵的可视化</figcaption></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="6d3b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">评估机器学习模型</h1><p id="3ca1" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">建立机器学习模型后的下一个阶段是评估该模型。我会在这个评估过程中查看<strong class="jx io">召回分数和 F1-分数</strong>。我将采用<strong class="jx io">最高回忆分数和 F1 分数</strong>来决定哪个型号更好。我使用回忆分数是因为我宁愿有一个假阳性而不是一个假阴性。在客户流失的情况下，该模型检测客户流失的趋势，即使它没有检测到，也被认为比它没有检测到流失要好，但它确实是流失了。我使用 F1-Score 是因为数据集的假阴性和假阳性数量不相等。</p><h2 id="88e6" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">逻辑回归</h2><p id="ccca" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">使用逻辑回归的结果是<strong class="jx io">召回分数是 0.793，F1 分数是 0.769。</strong></p><h2 id="68f4" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">决策树分类器</h2><p id="170a" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">使用决策树分类器的结果是<strong class="jx io">召回分数是 0.913，F1 分数是 0.864。</strong></p><h2 id="9548" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">随机森林分类器</h2><p id="63d4" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">使用随机森林分类器的结果是<strong class="jx io">召回分数是 0.917，F1 分数是 0.875。</strong></p><h2 id="7180" class="lz lc in bd ld ma mb dn lh mc md dp ll kg me mf lp kk mg mh lt ko mi mj lx mk bi translated">k 近邻分类器</h2><p id="04e3" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">使用 K 近邻分类器的结果是<strong class="jx io">召回分数是 0.792，F1 分数是 0.757。</strong></p><p id="7f9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从这个评价来看，使用随机森林分类器的机器学习模型具有最高的召回分数和 F1 分数。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="e238" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">验证机器学习模型</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a51a" class="lz lc in mq b gy mu mv l mw mx">#Validating The Machine Learning Model<br/>for i in range(10):<br/>    real = y_val.iloc[i]<br/>    pred = model_rfc.predict(X_val.iloc[i].to_frame().T)[0]<br/>    print(f'Real Value      -----&gt;&gt;&gt;&gt;&gt; {real}\n'<br/>          f'Predicted Value -----&gt;&gt;&gt;&gt;&gt; {pred}')<br/>    print()<br/>pred = model_rfc.predict(X_val)<br/>print('Precision: %.3f' % precision_score(y_val, pred))<br/>print('Recall: %.3f' % recall_score(y_val, pred))<br/>print('Accuracy: %.3f' % accuracy_score(y_val, pred))<br/>print('F1 Score: %.3f' % f1_score(y_val, pred))</span></pre><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/efd822a1d1f6fd095c06cc2f9f51fe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*NXvpQB68memaHle5LCGHew.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="bd ld">表 1</strong>验证机器学习模型随机森林分类器的结果</figcaption></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="f032" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a5a9" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">使用随机森林分类器的机器学习模型具有更好的结果<strong class="jx io">测试召回分数= 0.917，测试 F1 分数= 0.875，验证召回分数= 0.918，验证 F1 分数= 0.867 </strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="c4aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我说的就是这些。如果你对这个项目有任何批评、建议或问题，可以联系我。谢谢你，我真的很感谢你花时间来阅读这一点。</p></div></div>    
</body>
</html>