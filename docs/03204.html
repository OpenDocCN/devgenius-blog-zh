<html>
<head>
<title>iOS UITableViewCell with Multiple Actions — A Clean Approach using Closures.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有多个动作的 iOS UITableViewCell 使用闭包的简洁方法。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ios-uitableviewcell-with-multiple-actions-a-clean-approach-using-closures-e75abc4816f1?source=collection_archive---------3-----------------------#2020-10-12">https://blog.devgenius.io/ios-uitableviewcell-with-multiple-actions-a-clean-approach-using-closures-e75abc4816f1?source=collection_archive---------3-----------------------#2020-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f2765c529f6a0205cf16590fa275cf97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTVZ4nYTQS6gXANC"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">克里斯蒂安·威迪格在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5407" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名<strong class="kc io"> iOS 开发者</strong>，你肯定会遇到对 UITableView 的需求。这是一个在<strong class="kc io"> UIKit </strong>中提供的出色组件。</p><p id="b2a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">UITableView 的是显示列表的有用组件。<strong class="kc io"> UIKit </strong>为处理<strong class="kc io"> UITableView </strong>提供了更好的架构。但是开发人员经常面临<strong class="kc io">开箱即用</strong> <strong class="kc io">需求</strong>的挑战，我们被迫去思考<strong class="kc io">开箱即用</strong>的解决方案<strong class="kc io">。</strong></p><p id="b6b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，用户交互可以用<strong class="kc io"> UITableView 的委托</strong>来处理。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="138f" class="lh li in ld b gy lj lk l ll lm">func tableView(_ tableView: <a class="ae jz" href="https://developer.apple.com/documentation/uikit/uitableview" rel="noopener ugc nofollow" target="_blank">UITableView</a>, <br/>         didSelectRowAt indexPath: <a class="ae jz" href="https://developer.apple.com/documentation/foundation/indexpath" rel="noopener ugc nofollow" target="_blank">IndexPath</a>)</span></pre><p id="7fce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">didSelectRowAt</strong><strong class="kc io">index path</strong>，返回被点击项目的<strong class="kc io">索引</strong>。对于一个简单的实现，这个委托很好。</p><p id="13cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑一个<strong class="kc io"> UITableView </strong>实现，如下所示。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/eb3f51e2a14e29220b841402ba3e35c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*dZY3rsKiE_MpZShw1RdBkQ.png"/></div></figure><p id="d7a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查找用户与哪个索引进行了交互，并从<strong class="kc io">数据源</strong>数组中获取详细信息，这是一件轻而易举的事情。</p><p id="2dc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们考虑另一个<strong class="kc io"> UITableView </strong>，它有多个选项供用户交互。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/125a338a802d3d072e8c15cd87458c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75uMMhSkr5e07q2uUFe6pA.png"/></div></div></figure><p id="2cef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，用户可以点击喜欢，评论或只是单元格。我们如何区分这些事件？</p><ol class=""><li id="497b" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx lu lv lw lx bi translated">设定<strong class="kc io">按钮</strong> a <strong class="kc io">标记</strong>值，并检查<strong class="kc io">按钮动作</strong>中的标记值。</li><li id="dcf3" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated">为<strong class="kc io"> UITableViewCell </strong>设置一个<strong class="kc io">委托</strong>，从 Cell 类返回不同的事件。</li></ol><p id="a32d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管上面的方法产生了我们想要的结果，但是代码库将会以<strong class="kc io">丛生</strong>结束，并变成<strong class="kc io">紧密耦合</strong>。我们需要一种方法，代码应该清晰并且易于维护。</p><p id="2d85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">为你解围！</strong></p><p id="da5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将解释处理这种情况的一种更好的方法。</p><p id="9516" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将遵循闭包法，以高效紧凑的方式解决这个问题。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="9b89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">后续步骤:</strong></p><ol class=""><li id="0891" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx lu lv lw lx bi translated">创建一个<strong class="kc io"> UITableView 单元格</strong>类，并设计单元格布局。</li><li id="f7c7" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated">在<strong class="kc io"> UITableViewCell </strong> <strong class="kc io">布局</strong>上有两个<strong class="kc io">ui button</strong>并将<strong class="kc io"> touchUpInside </strong>事件拉至 Cell 类。(本教程结束时，您可以从 UITableViewCell 中处理更多操作)。</li><li id="3829" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated">您在<strong class="kc io"> UITableViewCell </strong>上的<strong class="kc io"> UIButtons </strong>应该已经连接到 Cell 类中的两个 IBActions，如下所示。</li></ol><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4f42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从简单的闭包回调开始，因为这篇介绍会让你从一个清晰的方法开始，这个方法可以扩展到更复杂的回调。</p><p id="1778" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先为我们的回调声明一个<strong class="kc io"> typealias </strong>,</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="585e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个闭包能够返回一个整数变量。</p><p id="ebe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">声明一个类似的回调，它可以返回一个“<strong class="kc io"> String </strong>”类型。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d87f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有<strong class="kc io">回调 1 </strong>和<strong class="kc io">回调 2 </strong>闭包，可以分别返回 Int 和 String 类型。</p><p id="5bac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在在我们的<strong class="kc io"> UITableViewCell </strong>类中声明<strong class="kc io">两个</strong> <strong class="kc io">变量</strong>，类型为“回调 1”&amp;“回调 2”。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="76e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要一个函数来设置这些闭包变量，它可以在 UITableView 运行时产生结果。在 UITableViewCell 类中实现该函数。这个函数得到一个<strong class="kc io">索引</strong>变量和两个闭包变量，然后可以将它们分配给单元格的变量。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0ad9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，是时候初始化这些变量了。但是这些应该在什么时候初始化呢？</p><p id="63c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> UITableView </strong>单元格的设计方式是在上下滚动时让<strong class="kc io">重用</strong>。，这意味着当 UITableView 滚动时，<strong class="kc io"> UITableViewCell 的</strong>将会丢失<strong class="kc io">其初始化的变量。保持单元格变量的状态是开发人员的责任。</strong></p><p id="6312" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">初始化闭包对象的正确方法是在创建单元格的时候。，即</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5e12" class="lh li in ld b gy lj lk l ll lm">func tableView(_ tableView: <a class="ae jz" href="https://developer.apple.com/documentation/uikit/uitableview" rel="noopener ugc nofollow" target="_blank">UITableView</a>, <br/>  cellForRowAt indexPath: <a class="ae jz" href="https://developer.apple.com/documentation/foundation/indexpath" rel="noopener ugc nofollow" target="_blank">IndexPath</a>) -&gt; <a class="ae jz" href="https://developer.apple.com/documentation/uikit/uitableviewcell" rel="noopener ugc nofollow" target="_blank">UITableViewCell</a></span></pre><p id="29ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建单元后，立即初始化闭包，并给它分配单元的闭包变量。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7811" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，忘记<strong class="kc io"> UITableView 的</strong> <strong class="kc io"> didSelectRowAt </strong>方法，因为我们已经为单元格操作创建了紧凑的操作块。现在是触发关闭的时候了。但是在哪里？</p><p id="c69e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 UIButton 的 IBAction 上！</p><p id="6076" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">能力越大责任越大，</strong>检查单元格上的闭包变量是否不为零，并调用块。为了避免<strong class="kc io">运行时</strong> <strong class="kc io">致命</strong> <strong class="kc io">崩溃</strong>，确实需要检查零情况。</p><p id="d1f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的<strong class="kc io"> UITableViewCell </strong>类应该如下所示。,</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3a2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了便于理解，我使用了简单的返回类型。您可以根据需要实时扩展它。一旦你开始实施封闭的方法，你会上瘾的，相信我！</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="13c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看这个！，如果您面临任何问题，请不要犹豫发表评论！</p><p id="a710" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">我的 Github 账号:</strong></p><div class="mm mn gp gr mo mp"><a href="https://github.com/bharathi91/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">bharathi91 -概述</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">北极代码库贡献者解散在 GitHub 上注册你自己的个人资料，托管代码，管理…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jt mp"/></div></div></a></div><p id="9ae9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">电子邮件:</strong></p><p id="92d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">bharathi91m@gmail.com</p></div></div>    
</body>
</html>