<html>
<head>
<title>Shortest path algorithms — Dijkstra &amp; Bellman-Ford</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短路径算法— Dijkstra &amp; Bellman-Ford</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shortest-path-algorithms-dijkstra-bellman-ford-3b640bdb0449?source=collection_archive---------11-----------------------#2022-07-20">https://blog.devgenius.io/shortest-path-algorithms-dijkstra-bellman-ford-3b640bdb0449?source=collection_archive---------11-----------------------#2022-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/32b148e8319693faf315b7a3093dc1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB8TU3VE632HcLXPBlsKiQ.png"/></div></div></figure><div class=""/><p id="9b68" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图遍历算法系列第二部分。阅读<a class="ae kt" href="https://medium.com/nerd-for-tech/dfs-bfs-introduction-26a65fca2344" rel="noopener">第一部分</a>和<a class="ae kt" href="https://asrathore08.medium.com/shortest-path-algorithm-floyd-warshall-johnsons-632fd7a9f8c7" rel="noopener">第三部分</a></p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ku"><img src="../Images/93df60aa08a307945aa61871c2d2df02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abax_FD79eCfMo5SLdmPWA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">加权图中的最短路径</figcaption></figure><h1 id="0b19" class="ld le iy bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">吉克斯特拉</h1><p id="4ac0" class="pw-post-body-paragraph jv jw iy jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">Djikstra 的是一种图形遍历算法，用于查找源和目的地之间的最短路径。类似于 Prim 的 MST 算法，这也是一个贪婪算法。在 Djikstra 中，我们维护两个集合，一个集合包含最短路径树(SPT)中包含的顶点，另一个集合包含剩余的顶点。在每一次迭代中，我们从第二个(剩余的节点)集合中找到一个离源距离最小的顶点。Dijkstra 算法的核心思想是不断消除源节点和所有可能目的地之间的较长路径。</p><p id="618e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是 Dijkstra 算法中使用的详细步骤:</p><ul class=""><li id="c745" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">创建一个跟踪最短路径树中包含的顶点的 SPT 集。最初，这个集合是空的。</li><li id="e8b4" class="mg mh iy jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">用无限距离值初始化输入图中的所有顶点。将源顶点的距离值指定为 0，以便首先拾取它。</li><li id="b57c" class="mg mh iy jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">而 SPT <em class="mu"> </em>不包括所有顶点:1。选择一个顶点 u，它不在 SPT <em class="mu"> </em>中，并且有一个最小距离值。2.在<em class="mu"> </em> SPT 中包含 u。3.更新 u 的所有相邻顶点的距离值。要更新距离值，请遍历所有相邻顶点。对于每个相邻顶点 v，如果距离值 u(距源)和边的权重 u-v 之和小于距离值 v，则更新距离值 v。这个过程称为边松弛。在 DAG 中，我们使用拓扑顺序来放松边。</li></ul><p id="9e03" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们正在添加边的权重来寻找最短路径，Dijkstra 的算法只能处理权重为<strong class="jx iz">正</strong>的图。</p><h2 id="9fea" class="mv le iy bd lf mw mx dn lj my mz dp ln kg na nb lr kk nc nd lv ko ne nf lz ng bi translated">代码实现</h2><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="a88d" class="mv le iy ni b gy nm nn l no np">import math<br/>from heapq import heappop, heappush<br/> <br/>class Node:<br/>    def __init__(self, vertex, weight=0):<br/>        self.vertex = vertex<br/>        self.weight = weight</span><span id="5c6d" class="mv le iy ni b gy nq nn l no np">    def __lt__(self, other):<br/>        return self.weight &lt; other.weight<br/> <br/>class Graph:<br/>    def __init__(self, edges, n):<br/>        self.adjList = [[] for _ in range(n)]<br/>        for (source, dest, weight) in edges:<br/>            self.adjList[source].append((dest, weight))</span><span id="11af" class="mv le iy ni b gy nq nn l no np">def get_route(prev, i, route):<br/>    if i &gt;= 0:<br/>        get_route(prev, prev[i], route)<br/>        route.append(i)<br/> <br/>def dijkstra(graph, source, n):<br/>    pq = []<br/>    heappush(pq, Node(source))<br/>    dist = [math.inf] * n<br/>    dist[source] = 0</span><span id="0a76" class="mv le iy ni b gy nq nn l no np">    processed = [False] * n<br/>    processed[source] = True<br/>    prev = [-1] * n<br/> <br/>    while pq:<br/>        node = heappop(pq)<br/>        u = node.vertex<br/>        for (v, weight) in graph.adjList[u]:<br/>            if not processed[v] and (dist[u] + weight) &lt; dist[v]: <br/>                dist[v] = dist[u] + weight<br/>                prev[v] = u<br/>                heappush(pq, Node(v, dist[v]))<br/>        processed[u] = True<br/> <br/>    route = []<br/>    for i in range(n):<br/>        if i != source and dist[i] != math.inf:<br/>            get_route(prev, i, route)<br/>            print(f'Path ({source} —&gt; {i}): Minimum cost = {dist[i]}, Route = {route}')<br/>            route.clear()</span><span id="3813" class="mv le iy ni b gy nq nn l no np">if __name__ == '__main__':<br/>    n = 5<br/>    edges = [<br/>        (0, 1, 10), <br/>        (0, 4, 3), <br/>        (1, 2, 2), <br/>        (1, 4, 4), <br/>        (2, 3, 9), <br/>        (3, 2, 7),<br/>        (4, 1, 1), <br/>        (4, 2, 8), <br/>        (4, 3, 2)<br/>        ]</span><span id="f010" class="mv le iy ni b gy nq nn l no np">    graph = Graph(edges, n)<br/>    for source in range(n):<br/>        dijkstra(graph, source, n)</span></pre><p id="4e20" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该算法的时间复杂度为<code class="fe nr ns nt ni b">O(|E|+|V|log|V|)</code>。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nu"><img src="../Images/1ac22d7ff5176edd7dc896aeda9bd4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVs8G29ejE4H_AEm6ThmrA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">负权重的最短路径</figcaption></figure><h1 id="3398" class="ld le iy bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">贝尔曼·福特算法</h1><p id="83ea" class="pw-post-body-paragraph jv jw iy jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">贝尔曼-福特算法是自底向上动态编程的一个例子。它从一个起始顶点开始，计算一条边可以到达的其他顶点的距离。然后，它继续寻找具有两条边的路径，以此类推。该算法也适用于边权重为负的图。</p><ul class=""><li id="e538" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">将到源的距离初始化为<code class="fe nr ns nt ni b">0</code>，将所有其他节点的距离初始化为<code class="fe nr ns nt ni b">INFINITY</code>。</li><li id="c6ef" class="mg mh iy jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">对于所有边，如果到目的地的距离可以通过取边来缩短，则距离会更新为新的较低值。</li><li id="6ac0" class="mg mh iy jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">在扫描边的每次迭代<code class="fe nr ns nt ni b">i</code>中，该算法找到最长<code class="fe nr ns nt ni b">i</code>边的所有最短路径。由于没有循环的最长可能路径可能是<code class="fe nr ns nt ni b">V-1</code>边，所以必须扫描这些边<code class="fe nr ns nt ni b">V-1</code>次，以确保为所有节点找到最短路径。</li><li id="a27e" class="mg mh iy jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">对所有边进行最终扫描，如果更新了任何距离，则发现了长度为<code class="fe nr ns nt ni b">|V|</code>边的路径，这只有在图中存在至少一个负循环时才会发生。</li></ul><h2 id="4a83" class="mv le iy bd lf mw mx dn lj my mz dp ln kg na nb lr kk nc nd lv ko ne nf lz ng bi translated">代码实现</h2><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="cf77" class="mv le iy ni b gy nm nn l no np">import math</span><span id="1db4" class="mv le iy ni b gy nq nn l no np">def getPath(parent, vertex):<br/>    if vertex &lt; 0:<br/>        return []<br/>    return getPath(parent, parent[vertex]) + [vertex]</span><span id="e857" class="mv le iy ni b gy nq nn l no np">def bellmanFord(edges, source, n):<br/>    distance = [math.inf] * n<br/>    parent = [-1] * n<br/>    distance[source] = 0<br/>    <br/>    for k in range(n - 1):<br/>        for (u, v, w) in edges:<br/>            if distance[u] != math.inf and distance[u] + w &lt; distance[v]:<br/>                distance[v] = distance[u] + w<br/>                parent[v] = u<br/>    <br/>    for (u, v, w) in edges:<br/>        if distance[u] != math.inf and distance[u] + w &lt; distance[v]:<br/>            return<br/>    <br/>    for i in range(n):<br/>        if i != source and distance[i] &lt; math.inf:<br/>            print(f'The distance of vertex {i} from vertex {source}, using path {getPath(parent, i)}, is {distance[i]}.')</span><span id="1b0c" class="mv le iy ni b gy nq nn l no np">if __name__ == '__main__':<br/>    edges = [<br/>        (0, 1, -1),<br/>        (0, 2, 4),<br/>        (1, 2, 3),<br/>        (1, 3, 2),<br/>        (1, 4, 2), <br/>        (3, 2, 5), <br/>        (3, 1, 1), <br/>        (4, 3, -3)<br/>    ]</span><span id="84f2" class="mv le iy ni b gy nq nn l no np">    n = 5</span><span id="0125" class="mv le iy ni b gy nq nn l no np">    for source in range(n):<br/>        bellmanFord(edges, source, n)</span></pre><p id="fff0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其时间复杂度为<code class="fe nr ns nt ni b">O(VE)</code>。</p><p id="4085" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">二选一？</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/a216154ad5a5d79ea5103a856a6de1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Q7g1k3HaIYqNhO3iUNWZQ.png"/></div></div></figure><p id="6085" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐学习！！！</p></div></div>    
</body>
</html>