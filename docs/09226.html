<html>
<head>
<title>LeetCode — Combination Sum II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —组合和 II</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-combination-sum-ii-305f61e214de?source=collection_archive---------16-----------------------#2022-08-07">https://blog.devgenius.io/leetcode-combination-sum-ii-305f61e214de?source=collection_archive---------16-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="b385" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题陈述</h1><p id="4571" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">给定一组候选号码<em class="lg">(候选号码)</em>和一个目标号码<em class="lg">(目标号码)</em>，找出<em class="lg">候选号码</em>中所有唯一的组合，其中候选号码总和为<em class="lg">目标号码</em>。</p><p id="6abe" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><em class="lg">候选</em>中的每个数字在组合中只能使用<strong class="kk io">一次</strong>。</p><p id="891f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">注意</strong>:解决方案集合不能包含重复的组合。</p><p id="542d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">例 1: </strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="17eb" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [10, 1, 2, 7, 6, 1, 5], target = 8<br/>Output:<br/>[<br/>[1, 1, 6],<br/>[1, 2, 5],<br/>[1, 7],<br/>[2, 6]<br/>]</span></pre><p id="94ab" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">例 2: </strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e6c7" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2, 5, 2, 1, 2], target = 5<br/>Output:<br/>[<br/>[1, 2, 2],<br/>[5]<br/>]</span></pre><p id="e0e5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">约束:</strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f780" class="lv jl in lr b gy lw lx l ly lz">- 1 &lt;= candidates.length &lt;= 100<br/>- 1 &lt;= candidates[i] &lt;= 50<br/>- 1 &lt;= target &lt;= 30</span></pre><h1 id="54ad" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">说明</h1><h2 id="8f29" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">追踪</h2><p id="b67a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个问题可以用我们在上一篇博客<a class="ae ml" href="https://alkeshghorpade.me/post/leetcode-combination-sum" rel="noopener ugc nofollow" target="_blank">组合求和</a>中使用的类似方法来解决。唯一不同的是<em class="lg">候选</em>中的每个元素只能用<strong class="kk io">一次</strong>。每个元素只使用一次，可以通过递归调用函数时跳到下一个索引来实现。</p><p id="9922" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">另一个区别是，我们的解决方案集不能包含重复的组合。问题陈述没有提到数组是排序的。为了避免重复的结果集，我们需要对数组进行排序，并避免使用相同的元素。</p><p id="194c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们先检查一下算法。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d450" class="lv jl in lr b gy lw lx l ly lz">- initialize the result as a 2D array<br/>  initialize current as an array</span><span id="359d" class="lv jl in lr b gy mm lx l ly lz">  // n = index, at start it will be 0.<br/>  // sumTillNow = sum of the current elements in the array, at the start it will be 0<br/>  // current = current list of elements in the array, at the start it will be an empty array []<br/>- call combinationSum2Util(result, candidates, current, n, sumTillNow, target)</span><span id="bef4" class="lv jl in lr b gy mm lx l ly lz">- return result</span><span id="864e" class="lv jl in lr b gy mm lx l ly lz">// combinationSum2Util function<br/>- if sumTillNow == target<br/>  // append current to result<br/>  - result.push_back(current)</span><span id="8c3b" class="lv jl in lr b gy mm lx l ly lz">- if sumTillNow &gt; target<br/>  - return</span><span id="7229" class="lv jl in lr b gy mm lx l ly lz">- set prev = -1</span><span id="1735" class="lv jl in lr b gy mm lx l ly lz">- loop for i = n; i &lt;= candidates.size() - 1; i++<br/>  - if prev != candidates[i]<br/>    // append candidates array ith element to the current array<br/>    - current.push_back(candidates[i])</span><span id="e285" class="lv jl in lr b gy mm lx l ly lz">    - sumTillNow += candidates[i]</span><span id="e863" class="lv jl in lr b gy mm lx l ly lz">    // call the function recursively<br/>    - combinationSumUtil(result, candidates, i, target, sumTillNow, current)</span><span id="1098" class="lv jl in lr b gy mm lx l ly lz">    - sumTillNow -= current[current.size() - 1]</span><span id="48ba" class="lv jl in lr b gy mm lx l ly lz">    // remove the last element from the array<br/>    - current.pop_back()</span><span id="2254" class="lv jl in lr b gy mm lx l ly lz">    - prev = candidates[i]<br/>  - end of if</span></pre><p id="6242" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们来看看我们在<strong class="kk io"> C++ </strong>、<strong class="kk io"> Golang </strong>和<strong class="kk io"> Javascript </strong>中的解决方案。</p><h2 id="3da3" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">C++解决方案</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a680" class="lv jl in lr b gy lw lx l ly lz">class Solution {<br/>public:<br/>    void combinationSum2Util(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; current, int index, int sumTillNow, int target) {<br/>        if(sumTillNow == target) {<br/>            result.push_back(current);<br/>            return;<br/>        }</span><span id="9924" class="lv jl in lr b gy mm lx l ly lz">        if(sumTillNow &gt; target) {<br/>            return;<br/>        }</span><span id="9a1f" class="lv jl in lr b gy mm lx l ly lz">        int prev = -1;</span><span id="886d" class="lv jl in lr b gy mm lx l ly lz">        for(int i = index; i &lt;= candidates.size() - 1; i++) {<br/>            if(prev != candidates[i]) {<br/>                current.push_back(candidates[i]);<br/>                sumTillNow += candidates[i];</span><span id="20ae" class="lv jl in lr b gy mm lx l ly lz">                combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target);<br/>                sumTillNow -= current[current.size() - 1];</span><span id="fde8" class="lv jl in lr b gy mm lx l ly lz">                current.pop_back();<br/>                prev = candidates[i];<br/>            }<br/>        }<br/>    }</span><span id="298b" class="lv jl in lr b gy mm lx l ly lz">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {<br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/>        vector&lt;int&gt; current;</span><span id="2e96" class="lv jl in lr b gy mm lx l ly lz">        sort(candidates.begin(), candidates.end());<br/>        combinationSum2Util(result, candidates, current, 0, 0, target);<br/>        return result;<br/>    }<br/>};</span></pre><h2 id="1fa4" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">戈朗溶液</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b2a3" class="lv jl in lr b gy lw lx l ly lz">func combinationSum2Util(result *[][]int, candidates, current []int, index, sumTillNow, target int) {<br/>    if sumTillNow == target {<br/>        *result = append(*result, append([]int{}, current...))<br/>        return<br/>    }</span><span id="0a02" class="lv jl in lr b gy mm lx l ly lz">    if sumTillNow &gt; target {<br/>        return<br/>    }</span><span id="f053" class="lv jl in lr b gy mm lx l ly lz">    prev := -1</span><span id="3632" class="lv jl in lr b gy mm lx l ly lz">    for i := index; i &lt; len(candidates); i++ {<br/>        if prev != candidates[i] {<br/>            current = append(current, candidates[i])<br/>            sumTillNow += candidates[i]</span><span id="c15e" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            sumTillNow -= current[len(current) - 1]<br/>            current = current[:len(current) - 1]<br/>            prev = candidates[i]<br/>        }<br/>    }<br/>}</span><span id="cf71" class="lv jl in lr b gy mm lx l ly lz">func combinationSum2(candidates []int, target int) [][]int {<br/>    result := make([][]int, 0)</span><span id="e12f" class="lv jl in lr b gy mm lx l ly lz">    sort.Ints(candidates)<br/>    combinationSum2Util(&amp;result, candidates, []int{}, 0, 0, target)</span><span id="0e4b" class="lv jl in lr b gy mm lx l ly lz">    return result<br/>}</span></pre><h2 id="f127" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">Javascript 解决方案</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3639" class="lv jl in lr b gy lw lx l ly lz">var combinationSum2 = function(candidates, target) {<br/>    let result = [];<br/>    candidates.sort(function(a, b){ return a - b });</span><span id="021b" class="lv jl in lr b gy mm lx l ly lz">    const combinationSum2Util = (candidates, current, index, sumTillNow, target) =&gt; {<br/>        if( sumTillNow == target ) {<br/>            result.push([...current]);<br/>            return;<br/>        }</span><span id="a2de" class="lv jl in lr b gy mm lx l ly lz">        if( sumTillNow &gt; target ) {<br/>           return;<br/>        }</span><span id="cf11" class="lv jl in lr b gy mm lx l ly lz">        let prev = -1;</span><span id="5ba7" class="lv jl in lr b gy mm lx l ly lz">        for(let i = index; i &lt; candidates.length; i++) {<br/>            if(prev != candidates[i]) {<br/>                current.push(candidates[i]);<br/>                sumTillNow += candidates[i];</span><span id="0e20" class="lv jl in lr b gy mm lx l ly lz">                combinationSum2Util(candidates, current, i + 1, sumTillNow, target);</span><span id="46e7" class="lv jl in lr b gy mm lx l ly lz">                sumTillNow -= current[current.length - 1];<br/>                current.pop();</span><span id="6755" class="lv jl in lr b gy mm lx l ly lz">                prev = candidates[i];<br/>            }<br/>        }<br/>    }</span><span id="36ac" class="lv jl in lr b gy mm lx l ly lz">    combinationSum2Util(candidates, [], 0, 0, target);</span><span id="a88d" class="lv jl in lr b gy mm lx l ly lz">    return result;<br/>};</span></pre><p id="60b1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们试运行一下我们的算法。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7aa6" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2, 5, 2, 1, 2]<br/>       target = 5</span><span id="8cd9" class="lv jl in lr b gy mm lx l ly lz">// combinationSum function<br/>Step 1: vector&lt;vector&lt;int&gt;&gt; result<br/>        vector&lt;int&gt; current</span><span id="7b19" class="lv jl in lr b gy mm lx l ly lz">Step 2: sort(candidates.begin(), candidates.end()<br/>        [1, 2, 2, 2, 5]</span><span id="4dd7" class="lv jl in lr b gy mm lx l ly lz">Step 3: combinationSum2Util(result, candidates, current, 0, 0, target)</span><span id="abd9" class="lv jl in lr b gy mm lx l ly lz">// combinationSum2Util function<br/>Step 4: if sumTillNow == target<br/>           0 == 5<br/>           false</span><span id="5199" class="lv jl in lr b gy mm lx l ly lz">        if sumTillNow &gt; target<br/>           0 &gt; 5<br/>           false</span><span id="404b" class="lv jl in lr b gy mm lx l ly lz">        prev = -1</span><span id="50e8" class="lv jl in lr b gy mm lx l ly lz">        loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 0<br/>          0 &lt;= 5 - 1<br/>          true</span><span id="cc10" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[i]<br/>               -1 != 1<br/>               true</span><span id="12a8" class="lv jl in lr b gy mm lx l ly lz">            current.push_back(candidates[i])<br/>            current.push_back(candidates[0])<br/>            current.push_back(1)<br/>            current = [1]</span><span id="71c1" class="lv jl in lr b gy mm lx l ly lz">            sumTillNow += candidates[i]<br/>                        = sumTillNow + candidates[0]<br/>                        = 0 + 1<br/>                        = 1</span><span id="7cf4" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            combinationSum2Util([][], [1, 2, 2, 2, 5], [1], 1, 1, 5)</span><span id="dbaf" class="lv jl in lr b gy mm lx l ly lz">Step 5: if sumTillNow == target<br/>           1 == 5<br/>           false</span><span id="ca5c" class="lv jl in lr b gy mm lx l ly lz">        if sumTillNow &gt; target<br/>           1 &gt; 5<br/>           false</span><span id="28e7" class="lv jl in lr b gy mm lx l ly lz">        prev = -1</span><span id="43ce" class="lv jl in lr b gy mm lx l ly lz">        loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 1<br/>          1 &lt;= 5 - 1<br/>          true</span><span id="a745" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[i]<br/>               -1 != 2<br/>               true</span><span id="4da3" class="lv jl in lr b gy mm lx l ly lz">            current.push_back(candidates[i])<br/>            current.push_back(candidates[1])<br/>            current.push_back(2)<br/>            current = [1, 2]</span><span id="03fe" class="lv jl in lr b gy mm lx l ly lz">            sumTillNow += candidates[i]<br/>                        = sumTillNow + candidates[1]<br/>                        = 1 + 2<br/>                        = 3</span><span id="2846" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            combinationSum2Util([][], [1, 2, 2, 2, 5], [1, 2], 3, 3, 5)</span><span id="57d5" class="lv jl in lr b gy mm lx l ly lz">Step 6: if sumTillNow == target<br/>           3 == 5<br/>           false</span><span id="5248" class="lv jl in lr b gy mm lx l ly lz">        if sumTillNow &gt; target<br/>           3 &gt; 5<br/>           false</span><span id="1d78" class="lv jl in lr b gy mm lx l ly lz">        prev = -1</span><span id="1a18" class="lv jl in lr b gy mm lx l ly lz">        loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 2<br/>          2 &lt;= 5 - 1<br/>          true</span><span id="22c4" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[i]<br/>               -1 != 2<br/>               true</span><span id="6e40" class="lv jl in lr b gy mm lx l ly lz">            current.push_back(candidates[i])<br/>            current.push_back(candidates[1])<br/>            current.push_back(2)<br/>            current = [1, 2, 2]</span><span id="b333" class="lv jl in lr b gy mm lx l ly lz">            sumTillNow += candidates[i]<br/>                        = sumTillNow + candidates[1]<br/>                        = 3 + 2<br/>                        = 5</span><span id="352c" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            combinationSum2Util([][], [1, 2, 2, 2, 5], [1, 2, 2], 3, 5, 5)</span><span id="cd62" class="lv jl in lr b gy mm lx l ly lz">Step 7: if sumTillNow == target<br/>           5 == 5<br/>           true</span><span id="6cad" class="lv jl in lr b gy mm lx l ly lz">           result.push_back(current)<br/>           result = [[1, 2, 2]]</span><span id="2900" class="lv jl in lr b gy mm lx l ly lz">           return</span><span id="7c1a" class="lv jl in lr b gy mm lx l ly lz">           we backtrack to step 6 and continue</span><span id="967d" class="lv jl in lr b gy mm lx l ly lz">Step 8: combinationSumUtil([][], [1, 2, 2, 2, 5], [1, 2, 2], 3, 5, 5)<br/>        sumTillNow = sumTillNow - current[current.size() - 1]<br/>                   = 5 - current[3 - 1]<br/>                   = 5 - current[2]<br/>                   = 5 - 2<br/>                   = 3</span><span id="2ded" class="lv jl in lr b gy mm lx l ly lz">        current.pop_back()<br/>        current = [1, 2]</span><span id="a84f" class="lv jl in lr b gy mm lx l ly lz">        prev = candidates[i]<br/>             = candidates[2]<br/>             = 2</span><span id="f29e" class="lv jl in lr b gy mm lx l ly lz">        i++<br/>        i = 3</span><span id="cd8b" class="lv jl in lr b gy mm lx l ly lz">        loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 3<br/>          3 &lt;= 5 - 1<br/>          true</span><span id="1863" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[3]<br/>               2 != 2<br/>               false</span><span id="e1a8" class="lv jl in lr b gy mm lx l ly lz">        i++<br/>        i = 4</span><span id="fb70" class="lv jl in lr b gy mm lx l ly lz">        loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 3<br/>          4 &lt;= 5 - 1<br/>          true</span><span id="b1bb" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[4]<br/>               2 != 5<br/>               true</span><span id="814a" class="lv jl in lr b gy mm lx l ly lz">            current.push_back(candidates[i])<br/>            current.push_back(candidates[4])<br/>            current.push_back(5)<br/>            current = [1, 2, 5]</span><span id="660c" class="lv jl in lr b gy mm lx l ly lz">            sumTillNow += candidates[i]<br/>                        = sumTillNow + candidates[4]<br/>                        = 3 + 5<br/>                        = 8</span><span id="7b23" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            combinationSum2Util([][], [1, 2, 2, 2, 5], [5], 5, 8, 5)</span><span id="87fe" class="lv jl in lr b gy mm lx l ly lz">Step 9: if sumTillNow == target<br/>           8 == 5<br/>           false</span><span id="1f3e" class="lv jl in lr b gy mm lx l ly lz">        if sumTillNow &gt; target<br/>           8 &gt; 5<br/>           true<br/>           return</span><span id="3b04" class="lv jl in lr b gy mm lx l ly lz">        we backtrack to step 5 and continue</span><span id="3d97" class="lv jl in lr b gy mm lx l ly lz">Step 10: combinationSum2Util([][], [1, 2, 2, 2, 5], [1, 2], 3, 3, 5)<br/>         sumTillNow = sumTillNow - current[current.size() - 1]<br/>                   = 3 - current[2 - 1]<br/>                   = 3 - current[1]<br/>                   = 3 - 2<br/>                   = 1</span><span id="d4eb" class="lv jl in lr b gy mm lx l ly lz">         current.pop_back()<br/>         current = [1]</span><span id="ad95" class="lv jl in lr b gy mm lx l ly lz">         prev = candidates[i]<br/>              = candidates[1]<br/>              = 2</span><span id="933e" class="lv jl in lr b gy mm lx l ly lz">         i++<br/>         i = 2</span><span id="15f7" class="lv jl in lr b gy mm lx l ly lz">         loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 2<br/>          2 &lt;= 5 - 1<br/>          true</span><span id="b8be" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[3]<br/>               2 != 2<br/>               false</span><span id="0585" class="lv jl in lr b gy mm lx l ly lz">         i++<br/>         i = 3</span><span id="93c0" class="lv jl in lr b gy mm lx l ly lz">         loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 3<br/>          3 &lt;= 5 - 1<br/>          true</span><span id="ddd4" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[3]<br/>               2 != 2<br/>               false</span><span id="86ee" class="lv jl in lr b gy mm lx l ly lz">         i++<br/>         i = 4</span><span id="f8bf" class="lv jl in lr b gy mm lx l ly lz">         loop for int i = index; i &lt;= candidates.size() - 1<br/>          i = 4<br/>          4 &lt;= 5 - 1<br/>          true</span><span id="b629" class="lv jl in lr b gy mm lx l ly lz">          - if prev != candidates[4]<br/>               2 != 5<br/>               true</span><span id="a703" class="lv jl in lr b gy mm lx l ly lz">            current.push_back(candidates[i])<br/>            current.push_back(candidates[4])<br/>            current.push_back(5)<br/>            current = [1, 5]</span><span id="1263" class="lv jl in lr b gy mm lx l ly lz">            sumTillNow += candidates[i]<br/>                        = sumTillNow + candidates[4]<br/>                        = 1 + 5<br/>                        = 6</span><span id="5993" class="lv jl in lr b gy mm lx l ly lz">            combinationSum2Util(result, candidates, current, i + 1, sumTillNow, target)<br/>            combinationSum2Util([][], [1, 2, 2, 2, 5], [1, 5], 5, 6, 5)</span><span id="8e93" class="lv jl in lr b gy mm lx l ly lz">Step 11: if sumTillNow == target<br/>           6 == 5<br/>           false</span><span id="80ac" class="lv jl in lr b gy mm lx l ly lz">         if sumTillNow &gt; target<br/>            6 &gt; 5<br/>            true<br/>            return</span><span id="941c" class="lv jl in lr b gy mm lx l ly lz">         we backtrack to step 4 and continue</span><span id="eccb" class="lv jl in lr b gy mm lx l ly lz">We similarly iterate from index 2, backtrack, and then reach the last index.</span><span id="08c6" class="lv jl in lr b gy mm lx l ly lz">We return the answer as<br/>[<br/>  [1, 2, 2],<br/>  [5]<br/>]</span></pre></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="548e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><em class="lg">原载于</em><a class="ae ml" href="https://alkeshghorpade.me/post/leetcode-combination-sum-ii" rel="noopener ugc nofollow" target="_blank"><em class="lg">https://alkeshghorpade . me</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>