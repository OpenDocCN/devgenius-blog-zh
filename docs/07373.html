<html>
<head>
<title>How to secure your GraphQL API (Part 2, the Typetta way)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护您的 GraphQL API(第 2 部分，Typetta 方式)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-secure-your-graphql-api-part-2-the-typetta-way-70cd7e7f04f2?source=collection_archive---------8-----------------------#2022-03-19">https://blog.devgenius.io/how-to-secure-your-graphql-api-part-2-the-typetta-way-70cd7e7f04f2?source=collection_archive---------8-----------------------#2022-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6d9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第 1 部分中，我们讨论了<strong class="jm io">保护 GraphQL API </strong>的问题。我们引入了一个安全模型，在定义数据模型的同时定义了 ACL 策略，以便将所有的安全检查要求到负责加载和合成数据的层。</p><p id="4858" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二部分中，我们将使用<a class="ae ki" href="https://twinlogix.github.io/typetta/" rel="noopener ugc nofollow" target="_blank"> Typetta </a>探索这种方法的实现，这是一个现代的 TypeScript ORM 库，它提供了定义这种安全模型的可能性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/97a1a0daec7287729706d13e918b0a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuadyBsno1jBrDYJsCM6PQ.png"/></div></div></figure><h1 id="05c7" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是泰佩塔？</h1><p id="eedf" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><a class="ae ki" href="https://twinlogix.github.io/typetta/" rel="noopener ugc nofollow" target="_blank"> Typetta </a>是一个用 TypeScript 编写的<strong class="jm io">开源 ORM </strong>，旨在允许所有主要的<strong class="jm io"> SQL 数据库</strong> (MySQL、PostgreSQL、Microsoft SQL Server、SQLLite3、CockroachDB、MariaDB、Oracle e Amazon Redshift)以及 NoSQL 数据库<strong class="jm io"> MongoDB </strong>以类型化的方式无缝访问数据。</p><p id="0485" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 Typetta，一切都围绕着数据模型、描述应用程序域的实体以及它们之间的所有底层关系。这个模型用标准的 GraphQL 描述，使用了所有的基本概念(标量、类型、枚举等)和一些自定义指令。</p><p id="6a56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面你可以看到一个用户的简单定义，包括名字和姓氏。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="ca5d" class="md kw in lz b gy me mf l mg mh">type User @entity @mongo {<br/> id: ID! @id<br/> firstName: String<br/> lastName: String<br/>}</span></pre><p id="01b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及如何使用 Typetta 生成的数据访问层与数据库进行交互。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="e74f" class="md kw in lz b gy me mf l mg mh">const user1 = await daoContext.user.insertOne({<br/> record: {<br/>  firstName: “Mattia”,<br/>  lastName: “Minotti”<br/> }<br/>});</span><span id="1ed9" class="md kw in lz b gy mi mf l mg mh">const user2 = await daoContext.user.insertOne({<br/> record: {<br/>  firstName: “Edoardo”,<br/>  lastName: “Barbieri”<br/> }<br/>});</span><span id="8d7b" class="md kw in lz b gy mi mf l mg mh">const users = await daoContext.user.findAll();</span><span id="aa74" class="md kw in lz b gy mi mf l mg mh">users.forEach(user =&gt; <br/> console.log(`${user.firstName} ${user.lastName}`)<br/>);</span></pre><p id="36d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta 的核心是一个为数据模型定制的<strong class="jm io">类型安全的、自生成的查询构建器</strong>。每次修改数据模型时，您都可以执行提供的生成器，该生成器创建并更新所有的 TypeScript 类型、一个<em class="mj"> DAOContext </em>类和所有相关的<em class="mj">Dao</em>。</p><p id="e469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mj"> DAOContext </em>是所谓的<em class="mj">Dao</em>的容器，这些数据访问对象允许你在数据模型的实体上执行所有操作。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="368e" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">安全框架</h1><p id="989d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">DAOContext 的默认行为是不应用任何安全策略，让 Typetta 用户拥有完全控制权。但是，如果您打算在 Typetta 中管理安全性，您可以通过正确配置<em class="mj"> DAOContext </em>来启用这个特性:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="c24f" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  <strong class="lz io">defaultPermissions: PERMISSION.DENY</strong><br/> }<br/>})</span></pre><p id="fdb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以这种方式，上下文被告知，除非另外指定，否则对每个实体的访问是完全禁止的。通过这样做，本质上，对数据模型的任何实体的操作都没有被授权。</p><p id="c192" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了<em class="mj">拒绝</em>，本库还提供了其他方便的权限配置，特别是:<em class="mj">允许</em>，<em class="mj">拒绝</em>，<em class="mj">只读</em>，<em class="mj">仅创建</em>，<em class="mj">仅更新</em>，<em class="mj">仅删除</em>。但是，您可以通过指定允许的单个操作来获得最大的灵活性，如下例所示:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="9fb8" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  defaultPermissions: <strong class="lz io">{<br/>   create: true,<br/>   read: true,<br/>   update: true,<br/>   delete: false<br/>  }</strong><br/> }<br/>})</span></pre><p id="28de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了为整个上下文指定默认权限之外，还可以为每个实体定义不同的权限，这种情况更常见。下面是一个简单的例子，引用了本博客第一部分中定义的数据模型:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="4050" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  policies: {<br/>   <strong class="lz io">user: { defaultPermission: PERMISSION.READ_ONLY },<br/>   userPermission: { defaultPermission: PERMISSION.READ_ONLY },<br/>   post: { defaultPermission: PERMISSION.ALLOW },</strong><br/>  }<br/>  defaultPermissions: PERMISSION.DENY<br/> }<br/>})</span></pre><p id="5b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，这些基本上是演示性的配置展示了 Typetta 在安全管理方面的简单性，但并没有涵盖很多真实的案例。实际上，在上面的定义中，对资源的访问权限是固定的，并且不依赖于调用身份。</p><p id="9f5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的部分中，我们将讨论如何处理这些更复杂的情况。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="a1f4" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">实体投影的权限</h1><p id="1a36" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我们之前已经看到了如何将单个操作限制到一个资源，明确指定创建、读取、更新和删除的能力。</p><p id="328d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读取操作通常需要在权限和限制的定义中有更大的粒度。特别是，经常需要为资源的各个字段或部分表示不同的权限。</p><p id="c254" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta 通过提供在 read 参数中指定受影响实体的任何投影的能力来支持这种需求。假设您为用户实体编写了一个安全策略，那么您可以只限制对<em class="mj"> id </em>、<em class="mj"> firstName </em>和<em class="mj"> lastName </em>字段的读访问。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="3285" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  policies: {<br/>   user: {<br/>    <strong class="lz io">read: {<br/>     id: true,<br/>     firstName: true,<br/>     lastName: true,<br/>    },</strong><br/>    write: false,<br/>    update: false,<br/>    delete: false<br/>   },<br/>  }<br/> }<br/>})</span></pre></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="48e3" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">权限和安全策略</h1><p id="5134" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了对不同的<strong class="jm io">身份</strong>施加不同的限制，添加<strong class="jm io">权限</strong>的概念是非常有用的，它能够对各种资源的访问规则进行分组和重用。</p><p id="9f06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以定义一个<em class="mj"> DAOContext </em>，其中对各个实体的访问策略取决于用户的权限:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="726c" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>   // context is generated by authorisation<br/>   <strong class="lz io">context: [‘MANAGE_POSTS’, ‘VIEW_POSTS’],</strong><br/>   policies: {<br/>    user: { defaultPermission: PERMISSION.READ_ONLY },<br/>    userPermission: { defaultPermission: PERMISSION.READ_ONLY },<br/>    post: {<br/>     <strong class="lz io">permissions: {<br/>      MANAGE_POSTS: PERMISSION.ALLOW,<br/>      VIEW_POSTS: PERMISSION.READ_ONLY,<br/>     },</strong><br/>     defaultPermissions: PERMISSION.DENY,<br/>    },<br/>   },<br/>   defaultPermissions: PERMISSION.DENY<br/> }<br/>})</span></pre><p id="ccb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请特别注意上下文字段的定义，通常在认证过程中加载的呼叫者身份许可将被放置在该字段中。相应地，post 实体的<strong class="jm io">安全策略</strong>包含几个权限，这些权限根据调用身份来实施。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="6f11" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">安全域</h1><p id="5002" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io">安全域</strong>代表一组资源，由一个或多个字段中的一组值来标识。它用于以更大的粒度限制权限的应用。</p><p id="e965" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用安全域，您必须:</p><ul class=""><li id="d213" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nb nc nd ne bi translated">定义一个安全上下文，在该上下文中，为每个当前身份权限指定其应用的域。</li><li id="4f8f" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated">定义每个安全策略应该适用的域。</li></ul><p id="4001" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以前面例子中的数据模型为例。它定义了一个 post 实体，该实体通过一个<em class="mj"> userId </em>字段链接到用户实体。一个用户通常只被允许在他们自己的帖子上执行每个操作，也就是说，那些有一个与他们的 Id 相同的<em class="mj"> userId </em>的帖子。所有拥有他们的<em class="mj">用户 Id </em>的帖子构成一个安全域。</p><p id="0313" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个如何配置<em class="mj"> DAOContext </em>的示例，这样用户就可以只对自己的帖子拥有<em class="mj"> MANAGE_POSTS </em>权限，而对所有其他帖子拥有<em class="mj"> VIEW_POSTS </em>权限:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="10c7" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  // context is generated by authorisation<br/>  context: {<br/>   permissions: {<br/><strong class="lz io">    ‘MANAGE_POSTS’: [{ userId: 2}]</strong><br/>    ‘VIEW_POSTS’: true<br/>   }<br/>  },<br/>  policies: {<br/>   post: {<br/>    permissions: {<br/>     MANAGE_POSTS: PERMISSION.ALLOW,<br/>     VIEW_POSTS: PERMISSION.READ_ONLY,<br/>    },<br/>    defaultPermissions: PERMISSION.DENY,<br/>   },<br/>  }<br/>  defaultPermissions: PERMISSION.DENY<br/> }<br/>})</span></pre><p id="4328" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，在这种情况下，安全上下文不仅是一个权限数组，而且是一个映射，可以在其中为每个权限限制应用程序域。规格说明<em class="mj">MANAGE _ POSTS:[{ userId:2 }]</em>应理解为:当前身份拥有对<em class="mj"> userId </em>字段等于 2 的所有资源的权限<em class="mj"> MANAGE_POSTS </em>。值<em class="mj"> true </em>表示特定权限没有域限制。</p><p id="36f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，给定这种配置，系统将授权用户对他们的帖子执行任何操作，而只对所有其他帖子执行读取操作。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="8310" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">操作安全域</h1><p id="ab2b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">每当执行一个指定了安全配置的<em class="mj"> DAOContext </em>操作时，Typetta 就会应用上述所有规则来确定该操作是被允许还是被禁止。</p><p id="c23f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在对于不同的安全域存在不同的安全策略的情况下，不知道哪个安全域将是操作的目标，库应用为所讨论的实体提供的所有安全策略之间的交集。交集意味着只有在所有安全策略中都允许的操作(或可见字段)才被允许。</p><p id="82e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设我们有两个帖子的可见性级别，一个允许阅读整个帖子(<em class="mj"> VIEW_POSTS </em>)，另一个允许您只阅读内容而不阅读作者(<em class="mj"> VIEW_POSTS_CONTENT </em>)。然后，我们假设用户在不同的安全域上拥有这两种权限。下面是 DAOContext 的定义:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="1618" class="md kw in lz b gy me mf l mg mh">const daoContext = new DAOContext({<br/> security: {<br/>  // context is generated by authorisation<br/>  context: {<br/>   permissions: {<br/>    ‘VIEW_POSTS’: [{ userId: 2}],<br/>    ‘VIEW_POSTS_CONTENT’: true<br/>   }<br/>  },<br/>  policies: {<br/>   post: {<br/>    permissions: {<br/>     VIEW_POSTS: PERMISSION.READ_ONLY,<br/>     VIEW_POSTS_CONTENT: {<br/>      read: {<br/>       id: true,<br/>       content: true,<br/>      }<br/>     },<br/>    },<br/>    defaultPermissions: PERMISSION.DENY,<br/>   },<br/>  },<br/>  defaultPermissions: PERMISSION.DENY<br/> }<br/>})</span></pre><p id="11fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定这种配置，通过在 post 实体的<em class="mj"> DAO </em>上执行简单的<em class="mj"> findAll </em>操作，系统应用<em class="mj"> VIEW_POSTS_CONTENT </em>权限，因为在没有显式安全域的情况下，它是最受限制的。因此，以下操作:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="b577" class="md kw in lz b gy me mf l mg mh">const posts = dao.post.findAll();</span></pre><p id="3193" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成禁止访问错误，因为用户无权访问所有帖子的 userId 字段。相反，以下是允许的，因为无论安全域如何都是允许的:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="b519" class="md kw in lz b gy me mf l mg mh">const posts = dao.post.findAll({<br/> projection: {<br/>  id: true,<br/>  content: true,<br/> }<br/>});</span></pre><p id="e0dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要执行<em class="mj"> findAll </em>操作而不将请求限制到某些字段，您必须将请求限制到安全域<em class="mj"> userId = 2 </em>。为此，Typetta 使用元数据操作机制，允许您为请求指定附加数据:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="e2fd" class="md kw in lz b gy me mf l mg mh">const posts = dao.post.findAll({<br/> metadata: {<br/>  userId: [2]<br/> }<br/>});</span></pre><p id="16a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个请求不会产生任何错误，相反，它会返回用户 2 的所有帖子，以及这些帖子中由<em class="mj"> VIEW_POSTS </em>权限允许的所有字段。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><h1 id="3036" class="kv kw in bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">结论</h1><p id="9f2c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在这篇博客中，我们展示了如何使用 Typetta 库创建一个安全的数据层，这是一个非常有前途的开发 GraphQL API 的工具。如果你有兴趣了解更多关于这个库的信息，你可以在官方文档中找到所有种类的细节。</p><p id="c460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，在这两篇文章中，我们试图定义一种方法来帮助开发人员保护他们的 GraphQL APIs，不仅在他们的系统边缘工作，而且在设计数据模型的同时设计安全性。</p><p id="15c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请继续关注我们，了解更多有趣的高级编码方法，如果你喜欢这个博客<strong class="jm io">，请为它鼓掌</strong>。</p></div></div>    
</body>
</html>