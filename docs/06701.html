<html>
<head>
<title>Multilevel Redis Caching to improve performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高性能的多级 Redis 缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multilevel-redis-caching-to-improve-performance-8603f0ea146f?source=collection_archive---------8-----------------------#2022-01-26">https://blog.devgenius.io/multilevel-redis-caching-to-improve-performance-8603f0ea146f?source=collection_archive---------8-----------------------#2022-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="761d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">让我们想象一下，我们正在建立一个电影维基网站，它会根据电影的类型改变外观和感觉。我们从 Oracle 数据库中获取所有电影数据。</em></p><p id="6832" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将讨论如何改善当有人搜索电影或直接在 URL 中输入电影名称时获取电影类型的延迟。</p><p id="68bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种简单的方法可以提高性能。</p><ol class=""><li id="f487" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">首先是创建一个索引:在我们的例子中，搜索关键字是电影名称，所以我们可以在电影名称列上创建一个索引，这将使我们的查询更快。</li><li id="34bf" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">其次是缓存:最简单的方法是将电影名称作为键，将电影细节作为值进行缓存。</li></ol><p id="d355" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们仍然可以通过引入第二级缓存来做进一步的改进。让我们首先了解流程图/架构，然后我们将通过实施。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/bb4a713e255bd3f5640505e159eeef9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQPES6sbKNVxt94RWmeeMg.jpeg"/></div></div></figure><p id="c326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里需要注意几件事:</p><ol class=""><li id="8b08" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">一级缓存是微不足道的。但是我们不会存储所有的细节，而是只缓存电影类型。对我们来说，电影类型是主要的障碍，因为我们正在加载使用它。详细信息，我们可以稍后在后台获得，因为网站懒惰加载。</li><li id="bbd6" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">然后我们引入了第二个层次，在<code class="fe lj lk ll lm b">getMovieMap</code>键下缓存整个电影和流派的散列表。(我们将它存储为 HashMap 而不是 list，以获得 O(1)的搜索时间复杂度。我们只是存储流派，以便 HashMap 的大小最小。)</li><li id="a4aa" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">电影类型在特定电影的生命周期中不会改变，因此我们不需要刷新一级缓存。但是新电影会不断出现，所以为了刷新我们的数据，我们会将 TTL(生存时间)作为<code class="fe lj lk ll lm b">getMovieMap</code>键的 1 天。</li></ol><p id="d60e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来看一下实现。</p><pre class="ky kz la lb gt ln lm lo lp aw lq bi"><span id="f799" class="lr ls in lm b gy lt lu l lv lw">/**<br/> * MovieMapService class<br/> *<br/> */<br/>@Slf4j<br/>@Service<br/>public class MovieMapService {<br/> <br/>    @Autowired<br/>    private MovieDao movieDao;</span><span id="ec26" class="lr ls in lm b gy lx lu l lv lw">    /**<br/>     * Get the map of all movie name and genre<br/>     * <br/>     * @return Map&lt;String, String&gt; - toolMap<br/>     */<br/>    @Cacheable(cacheNames = "movieWiki", key="#root.methodName")<br/>    Map&lt;String, String&gt; getMovieMap() {<br/>        // In the DAO method we can use <br/>        // <a class="ae ly" href="http://twitter.com/MapKey" rel="noopener ugc nofollow" target="_blank">@MapKey</a> annotation to get the HashMap of <br/>        // movie name and genre directly.<br/>        return movieDao.getMovieMap();<br/>    }</span><span id="fee8" class="lr ls in lm b gy lx lu l lv lw">}</span><span id="756d" class="lr ls in lm b gy lx lu l lv lw">/**<br/> * Movie genre service class<br/> */<br/>@Service<br/>public class MovieGenreService {<br/> <br/>    @Autowired<br/>    private MovieMapService movieMapService;<br/>    <br/>    /**<br/>     * Get the movie genre<br/>     * <br/>     * @param movie String - movie name<br/>     * @return String - movie genre<br/>     */<br/>    @Cacheable(cacheNames = "movieWiki", <br/>         key="#movie", unless =  "#result == null")<br/>    String getMovieGenre(final String movie) {<br/>        Map&lt;String, String&gt; movieMap =  movieMapService.<br/>            getMovieMap();<br/>        return movieMap.get(movie);<br/>    }<br/>}</span></pre><ol class=""><li id="4b3a" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><em class="ki">结帐本</em> <a class="ae ly" href="https://pratiyush.medium.com/one-common-mistake-which-we-should-avoid-while-using-async-and-cacheable-in-spring-boot-a967cea27d55" rel="noopener"> <em class="ki">条</em> </a> <em class="ki">如果你想了解更多，为什么我们需要对每一个方法都有单独的类。</em></li><li id="74d5" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><em class="ki">查看这篇</em> <a class="ae ly" href="https://programmer.help/blogs/mybatis-returns-the-case-of-map-key-value-to-data-key-value.html" rel="noopener ugc nofollow" target="_blank"> <em class="ki">博客</em> </a> <em class="ki">了解如何使用@MapKey 注释直接从 mybatis 获取 HashMap。</em></li></ol></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="2794" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要阅读更多关于 spring boot 中缓存的内容，您可以浏览这些。</p><ul class=""><li id="1f87" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh mg kp kq kr bi translated"><a class="ae ly" href="https://www.baeldung.com/spring-cache-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-cache-tutorial</a></li><li id="eb3b" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh mg kp kq kr bi translated"><a class="ae ly" href="https://spring.io/guides/gs/caching/" rel="noopener ugc nofollow" target="_blank">https://spring.io/guides/gs/caching/</a></li></ul></div></div>    
</body>
</html>