<html>
<head>
<title>Data Repository Layer in iOS MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS MVVM 中的数据存储层</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-repository-layer-in-ios-mvvm-562541b46f91?source=collection_archive---------1-----------------------#2020-06-04">https://blog.devgenius.io/data-repository-layer-in-ios-mvvm-562541b46f91?source=collection_archive---------1-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f239356419b008300781304683099875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*glDgq34NjmC5IaZB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@mr_fresh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yura Fresh </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="327c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 iOS 应用程序开发中，我们必须从 API、数据库和其他数据源(物联网设备数据)中检索不同类型的数据</p><p id="b532" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着越来越多的开发人员开始应用 MVVM 架构，数据层显得杂乱无章。当构建代码库时，ViewModel 必须保存大量关于不同数据类型的数据源客户端。</p><p id="9e02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论 MVVM 架构中的数据存储层，以了解如何正确处理第三方数据。</p><p id="c39d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这个应用程序的要求:应用程序必须在连接到互联网时从 API 获取数据，并在没有互联网时从数据库中检索数据。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="0a0d" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">1、总体结构</h2><p id="150d" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">从下图中我们可以看到:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6c69e80566beb11dd75fb837a7a93e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*M9wK2seNbsZeofcGh0sHvg.png"/></div></figure><p id="0404" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">视图:UIView + ViewController。UIView 拥有 ViewController 拥有的所有静态视图代码。ViewController 协调 UIView 和 ViewModels。</p><p id="575e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ViewModel:处理所有逻辑，将可观察值绑定并公开给 ViewController。在 ViewModel 中进行的更新将自动显示在 ViewController 中。</p><p id="86d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据存储库:包装所有数据库、网络和其他数据源处理逻辑。这仅向视图模型公开了必要的公共函数。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="6b26" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">2、数据仓库层</h2><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1:这是我们在视图层提出的协议。</p><p id="9784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2: apiClient 是处理所有网络请求的网络客户端。</p><p id="cb42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3:数据库容器包含数据库操作。</p><p id="833b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4:在 init()函数中，我们初始化网络客户端、数据库容器和其他数据源。</p><p id="09f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5:这些是私有数据库函数，处理数据获取和保存操作。</p><p id="7494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6:呈现给视图模型层的协议函数。基本上这个函数会首先调用 API。如果它获取数据成功，它将发送数据；否则，它将从数据库中检索并发送回 ViewModel 层。</p><p id="d2ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加数据存储层的优点:</p><ul class=""><li id="ff10" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated"><strong class="kf ir">隐藏逻辑:</strong>上层隐藏了取数据逻辑。ViewModel 初始化请求，不需要关心数据来自哪里。</li><li id="d647" class="mn mo iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">易于测试:您所要做的就是创建一个模拟数据存储库，并根据需要模拟公共函数，仅此而已。</li><li id="feb3" class="mn mo iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><strong class="kf ir">易于更新:</strong>如果您想要更新 ORM 模型层或更新逻辑，您不必对 ViewModel 逻辑进行更改，因为数据存储库协议不会改变</li></ul><p id="b300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了上述内容，您还可以阅读本文，使数据存储库通用化，以适应不同类型的视图模型</p><div class="nb nc gp gr nd ne"><a href="https://medium.com/@pererikbergman/repository-design-pattern-e28c0f3e4a30" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">知识库设计模式</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">存储库模式是目前比较流行的模式之一。我喜欢它，它跟随固体…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jw ne"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="397a" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">3、视图模型层</h2><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9bd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1:我们有 DataRepositoryProtocol 类型的 dataRepo，这意味着我们只在这个视图模型中公开 initFetch()函数</p><p id="ede8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2:有了这两个，我们就能够将数据绑定到视图层。当变量的值改变时，它将调用绑定到视图层的 didSet()中的闭包函数来执行一些视图操作。还有，我们可以用 RxSwift BehaviorRelay 和 Combine 来替换这些代码。</p><p id="1815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3:这是一个典型的依赖注入，我们将数据存储库注入到视图模型中。通过这样做，我们分离了数据层和视图模型层。逻辑功能更容易测试。</p><p id="1058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">initFetch 函数暴露给 ViewController，在这个函数中，我们调用 DataRepositoryProtocol 中的 iniFetch()来获取和处理数据。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="b856" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">4、结论</h2><p id="4415" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">如果你理解设计模式，你就会知道这是开发人员总是用来隐藏复杂细节和向外界暴露统一接口的门面模式。</p><p id="3b1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与从可编码模型访问数据相比，这更符合 MVVM，因为我们只向逻辑发送必要的数据。</p><p id="cfc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你能从这篇文章中学到一些东西，这里是我在<a class="ae kc" href="https://github.com/lee197/MeteoriteRecordApp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的源代码，请不吝赐教。</p></div></div>    
</body>
</html>