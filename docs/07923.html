<html>
<head>
<title>A Simple Introduction to Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的简单介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-simple-introduction-to-microservices-ecd031973117?source=collection_archive---------12-----------------------#2022-05-03">https://blog.devgenius.io/a-simple-introduction-to-microservices-ecd031973117?source=collection_archive---------12-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0563" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><blockquote class="km kn ko"><p id="28af" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">任何设计系统的组织都会产生一个设计，其结构是组织的沟通结构的复制。<br/> —康威定律</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/3fa9716295518e5ef76f5d1e3330ef2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQuhKf_9IWxi2nOF4-yqPA.jpeg"/></div></div></figure><p id="5a54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在软件工程中,<strong class="jp ir"> monolith </strong>是一个单层应用程序，其中用户界面、业务逻辑和数据层都被合并到一个实体中，这意味着软件的所有功能都被捆绑在一起。</p><p id="98df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当产品处于早期阶段，工程师团队非常小，团队中的每个成员共享前端和后端的知识和责任时，通常使用这种类型的架构。</p><p id="3e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，在高绩效组织中，通常会发现多个团队，每个团队都是<strong class="jp ir">长期团队</strong>、<strong class="jp ir">自治团队</strong>和<strong class="jp ir">跨职能团队</strong>。</p><p id="ad8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，由松散耦合的团队组成的组织需要松散耦合的架构，这就是所谓的<strong class="jp ir">微服务架构</strong>。</p><p id="3c43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，微服务架构背后的想法是将一个单片应用程序分解成松散耦合的组件，每个组件被称为 T21 服务，每个服务满足一个非常具体的业务需求，例如:处理支付方式、发送电子邮件或管理客户账户。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><div class="ku kv kw kx gt lm"><a href="https://www.youtube.com/channel/UCct07fMiEnBP2AER50uTaHw/videos" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">拉兹万·卢多萨努</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">👋嗨，我是拉兹万！我是法国巴黎的高级软件工程师。我分解计算机科学和后端…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">www.youtube.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma ld lm"/></div></div></a></div></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="cc19" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">松耦合</h1><p id="7e2c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">松散耦合意味着并意味着一些事情。</p><p id="bc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一件事是，通过共享一个组件对另一个组件的最小程度的直接知识，组件在最少的可行程度上相互依赖。</p><p id="5020" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与整体架构不同，一个组件或微服务不应该知道另一个组件的内部工作方式——它需要知道的只是如何使用它的<strong class="jp ir"> API </strong>调用它。</p><p id="9fc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实很有意义，因为它不是代码内部调用代码，而是服务通过诸如 HTTP 或 AMQP 之类的协议调用其他服务。</p><p id="2195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正因为如此，偶尔用通过相同接口提供相同服务的替代实现替换组件变得相当容易，几乎不会引入对代码库的破坏性更改。</p><p id="7e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，我们可以说松耦合:</p><ul class=""><li id="7473" class="ne nf iq jp b jq jr ju jv jy ng kc nh kg ni kk nj nk nl nm bi translated">使系统更加高效和灵活。</li><li id="8684" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">允许断开或重新配置组件之间的关系。</li><li id="0f7e" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">在压力过大的情况下，通过生成一个或多个服务实例来帮助应对负载，而不必纵向扩展整个基础架构。</li><li id="0fda" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">通过让开发人员为每个服务选择正确的技术栈或框架，促进新模式的实现。</li></ul><p id="2953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于微服务，您可以在同一个系统中使用 Python 编写一个运行 Flask 的服务，使用 Node.js 编写另一个运行 Express.js 的服务，而使用单一方法，不同的技术不可能混合使用，因为每个组件都是同一个代码库的一部分。</p><h1 id="be32" class="mb mc iq bd md me ns mg mh mi nt mk ml mm nu mo mp mq nv ms mt mu nw mw mx my bi translated">隔离</h1><p id="dfeb" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我在介绍中提到的微服务的第二个属性是<strong class="jp ir">隔离</strong>的概念，可以分为以下四个维度。</p><h2 id="9f94" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated"><strong class="ak">隔离空间</strong></h2><p id="01e3" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><strong class="jp ir"> <em class="kp"> </em> </strong> <em class="kp">空间隔离</em>意味着微服务被独立部署并在一个单独的进程中执行——比如在 Docker 上，每个服务都在自己的容器中运行。</p><p id="e85b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它允许单独管理每个服务，这意味着启动、停止、重新部署或扩展，而不必关闭整个基础架构，而且可以更快地推出生产功能和修复，因为事实上，更新通常涉及少数服务，而不是整个代码库。</p><h2 id="d825" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated"><strong class="ak">隔离状态</strong></h2><p id="ac05" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">状态的<em class="kp">隔离意味着微服务对其存储的数据完全负责，这意味着两件事。</em></p><p id="82f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从外部对这些数据的任何访问都是通过服务的 API 专门执行的，从而创建了一个防火墙，防止数据在服务不知道更改的情况下被修改。</p><p id="753d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过扩展，服务因此可以自由选择使用哪种技术来持久化状态，而不必适应它们的消费者——例如，一个服务可以将其数据存储在 Postgres 数据库中，另一个存储在 MongoDB 中。</p><h2 id="afe8" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated"><strong class="ak">隔离时间</strong></h2><p id="936c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><em class="kp">时间隔离</em>意味着微服务可以将其同步调用仅限于快速响应的服务。</p><p id="9e31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于组件不在同一个进程中，通过 RabbitMQ 或 Amazon MQ 这样的消息代理异步进行耗时的调用，调用者可以通过一次启动几个调用(而不是顺序启动)来避免空闲等待时间，最终提高资源利用率。</p><h2 id="0853" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated"><strong class="ak">故障隔离</strong></h2><p id="eb25" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">最后，<em class="kp">故障隔离</em>也称为<em class="kp">弹性</em>意味着即使一个或多个微服务由于某种原因崩溃，应用程序的其余部分仍将运行。</p><p id="6e94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，在整体架构中，如果错误处理不当，单个失败的组件会导致整个应用程序崩溃是很常见的。</p><p id="430b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，由于微服务运行在不同的进程上，如果一个崩溃，它将对其他用户不可用，而不会将错误传播到整个系统。</p><h1 id="15c3" class="mb mc iq bd md me ns mg mh mi nt mk ml mm nu mo mp mq nv ms mt mu nw mw mx my bi translated">复杂性</h1><p id="db1f" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">所有这些优势都是有代价的，这就是复杂性。</p><p id="eb03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不涉及太多细节的情况下，让我简要概述一下与这种架构相关的挑战。</p><h2 id="2a3c" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated">技术传播</h2><p id="5fae" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">虽然每个微服务都有一个更小的代码库，本质上也更简单，但是现在有一个潜在的需求，为每个微服务维护多个技术栈、多个项目和多个文档。</p><h2 id="2901" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated">CI/CD</h2><p id="75c7" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">随之而来的事实是，我们需要确保每个服务都正确地连接到自己的部署管道，以实现持续集成和持续开发。</p><h2 id="7308" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated">测试</h2><p id="863f" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">测试变得更具挑战性，尤其是当服务之间存在许多依赖关系时——与大多数调用都是内部调用的 monolith 相比——现在这些相同的调用是通过网络远程进行的。</p><h2 id="818d" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated">网络</h2><p id="1683" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">谈到网络，网络延迟也是一个新问题，因为我们现在必须在服务之间插入额外的通信机制，无论是无状态的(如 HTTP)还是异步的(如 AMQP)。</p><p id="ec92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不仔细设计，每个网络调用的每个延迟都会使系统完全失去平衡。</p><h2 id="99b4" class="nx mc iq bd md ny nz dn mh oa ob dp ml jy oc od mp kc oe of mt kg og oh mx oi bi translated">数据完整性</h2><p id="e85c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">对应用程序执行的一些操作可能需要调用多个服务，这些服务将执行多个业务事务，从而导致执行多个数据库操作…这需要数据的最终一致性或复杂的回滚机制，以确保系统始终处于一致的状态。</p><h1 id="ea6c" class="mb mc iq bd md me ns mg mh mi nt mk ml mm nu mo mp mq nv ms mt mu nw mw mx my bi translated">下一步是什么？</h1><p id="b958" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">不要忘记👏🏻x50 如果你喜欢读我的作品！</p><p id="6c3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👉你喜欢这种内容？请在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《T2】 <strong class="jp ir">构建分层微服务</strong> 一书，了解如何使用 Express framework 构建生产就绪的分层认证微服务，从第一行代码到最后一行文档，该服务符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>