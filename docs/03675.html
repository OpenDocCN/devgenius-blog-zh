<html>
<head>
<title>Python Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-inheritance-7e84be118c60?source=collection_archive---------14-----------------------#2020-12-01">https://blog.devgenius.io/python-inheritance-7e84be118c60?source=collection_archive---------14-----------------------#2020-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="bb20" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">概观</h1><p id="03fd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">继承是面向对象编程(OOP)的四大支柱之一。继承允许类从另一个类继承所有方法和属性。父类是被继承的类，也称为基类。子类是从另一个类继承的类。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/bfddb7820b4821d68738e80b9d544316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0SEGwacnqgPBy4T"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="f651" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">父类</h1><p id="5100" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">父类是一个典型的类，它只需要有将被继承的方法和属性。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="cec9" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    self.name = name<br/><br/>  def printName(self):<br/>    print(self.name)</span></pre><h1 id="3dd2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">子类别</h1><p id="7da3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">子类可以是一个典型的类，但是你只需要把父类放在子类后面的括号中。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="62f8" class="mc jl in ly b gy md me l mf mg">class Child(Parent):<br/>  pass</span><span id="8f2c" class="mc jl in ly b gy mh me l mf mg">x = Child("Mike")<br/>x.printName()</span><span id="9451" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Mike</span></pre><p id="e2aa" class="pw-post-body-paragraph ki kj in kk b kl mi kn ko kp mj kr ks kt mk kv kw kx ml kz la lb mm ld le lf ig bi translated">当类没有任何方法或属性时，使用<em class="mn"> pass </em>关键字。</p><h1 id="e421" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">__init__()</h1><p id="531a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">每次创建类时都会调用<em class="mn"> __init__() </em>函数。当子类从父类继承时，父类<em class="mn"> __init__() </em>函数被子类 __init__()函数覆盖。这意味着只有孩子的<em class="mn"> __init__() </em>函数会被调用，而不是父母或两者。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="5c6b" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name<br/><br/>  def printName(self):<br/>    print(self.name)</span><span id="e40c" class="mc jl in ly b gy mh me l mf mg">class Child(Parent):<br/>  def __init__(self, name):<br/>    print("Child")<br/>    self.name = name</span><span id="7ac6" class="mc jl in ly b gy mh me l mf mg">x = Child("Mike")<br/>x.printName()</span><span id="1733" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Child<br/>&gt;&gt; Mike</span></pre><h1 id="66c2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">超级()</h1><p id="6ef9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="mn"> super() </em>函数引用了从继承而来的父类，这使您可以访问父类的属性和方法。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="0f4c" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name<br/><br/>  def printName(self):<br/>    print(self.name)</span><span id="c969" class="mc jl in ly b gy mh me l mf mg">class Child(Parent):<br/>  def __init__(self, name):<br/>    print("Child")<br/>    self.name = name</span><span id="f426" class="mc jl in ly b gy mh me l mf mg">x = Child("Mike")<br/>x.printName()</span><span id="33fe" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Parent<br/>&gt;&gt; Mike</span></pre><h1 id="f63f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">新属性</h1><p id="c853" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当子类从父类继承时，可以向子类添加父类没有的属性。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="f32b" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name</span><span id="ac5d" class="mc jl in ly b gy mh me l mf mg">def printName(self):<br/>    print(self.name)</span><span id="3ccd" class="mc jl in ly b gy mh me l mf mg">class Child(Parent):<br/>  def __init__(self, name, age):<br/>    print("Child")<br/>    self.name = name<br/>    self.age = age<br/>  def getAge(self):<br/>    print(self.age)</span><span id="d1f0" class="mc jl in ly b gy mh me l mf mg">x = Child("Mike", 9)<br/>x.printName()<br/>print(x.age)</span><span id="e5d1" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Parent<br/>&gt;&gt; Mike<br/>&gt;&gt; 9</span></pre><h1 id="0c07" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">新方法</h1><p id="212a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">子类继承父类时可以有自己的方法。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="bce7" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name<br/>  def printName(self):<br/>    print(self.name)<br/>    <br/>class Child(Parent):<br/>  def __init__(self, name, age):<br/>    print("Child")<br/>    self.name = name<br/>    self.age = age<br/>  def getAge(self):<br/>    print(self.age)<br/>    <br/>x = Child("Mike", 9)<br/>x.printName()<br/>x.getAge()</span><span id="6e2f" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Child<br/>&gt;&gt; Mike<br/>&gt;&gt; 9</span></pre><p id="ae4a" class="pw-post-body-paragraph ki kj in kk b kl mi kn ko kp mj kr ks kt mk kv kw kx ml kz la lb mm ld le lf ig bi translated">如果子类与父类有相同的方法名，它将覆盖父类的方法。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="a3ed" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name<br/>  def printName(self):<br/>    print(self.name)<br/>    <br/>class Child(Parent):<br/>  def __init__(self, name, age):<br/>    print("Child")<br/>    self.name = name<br/>    self.age = age<br/>  def getAge(self):<br/>    print(self.age)<br/>  def printName(self):<br/>    print("Child " + self.name)<br/>   <br/>x = Child("Mike", 9)<br/>x.printName()<br/>x.getAge()</span><span id="319b" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Child<br/>&gt;&gt; Child Mike<br/>&gt;&gt; 9</span></pre><p id="deb3" class="pw-post-body-paragraph ki kj in kk b kl mi kn ko kp mj kr ks kt mk kv kw kx ml kz la lb mm ld le lf ig bi translated">要调用被覆盖的父类方法，您必须使用<em class="mn"> super() </em>方法。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="2f86" class="mc jl in ly b gy md me l mf mg">class Parent:<br/>  def __init__(self, name):<br/>    print("Parent")<br/>    self.name = name<br/>  def printName(self):<br/>    print("Parent " + self.name)<br/>    <br/>class Child(Parent):<br/>  def __init__(self, name, age):<br/>    print("Child")<br/>    self.name = name<br/>    self.age = age<br/>  def getAge(self):<br/>    print(self.age)<br/>  def printName(self):<br/>    super().printName()<br/>   <br/>x = Child("Mike", 9)<br/>x.printName()<br/>x.getAge()</span><span id="4210" class="mc jl in ly b gy mh me l mf mg">&gt;&gt; Child<br/>&gt;&gt; Parent Mike<br/>&gt;&gt; 9</span></pre><h1 id="cf50" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="c865" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">继承有助于表示真实世界的关系。它通过减少代码来帮助提高可重用性。如果多个类将使用相同的属性和方法，您可以有一个父类和多个从父类继承的子类。继承也是可传递的，所以如果一个类从父类继承的子类继承，那么这个类从子类和父类获得方法和属性。</p></div></div>    
</body>
</html>