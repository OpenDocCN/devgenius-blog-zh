<html>
<head>
<title>Building a WIFI Queuing system Console using LARAVEL and ESP32 Arduino Board.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 LARAVEL 和 ESP32 Arduino 板构建 WIFI 排队系统控制台。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-awifi-queuing-system-console-using-laravel-and-esp32-android-board-968831794a79?source=collection_archive---------9-----------------------#2022-12-30">https://blog.devgenius.io/building-awifi-queuing-system-console-using-laravel-and-esp32-android-board-968831794a79?source=collection_archive---------9-----------------------#2022-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="96bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个项目中，我必须为一个客户建立排队系统控制台。事实上，客户有点固执，不同意在 pc 机上安装网络控制台，他要求为排队系统安装一个单独的设备。所以我必须找到一个解决方案，用另一个设备取代下面的网络控制台。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c76d2f34885a9e916d3ccb79537b753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vF4f_kFihM-OAZvTXvNIMQ.png"/></div></div></figure><p id="7dc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">于是，我经过一番研究，找到了这个漂亮的小板子<a class="ae ku" href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/" rel="noopener ugc nofollow" target="_blank"> ESP32 </a>。其同时兼容 arduino 编程并具有嵌入式 WIFI 卡。我还需要一个 1.77 英寸的小有机发光二极管屏幕和两个按钮来选择柜台号码，呼叫或召回排队的顾客。在控制台的完整组件下面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kv"><img src="../Images/9361fa3d5da7b0dff83dc59f47f9efbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mXAQU4okkzDA-lbafUJCw.jpeg"/></div></div></figure><p id="bca7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将有机发光二极管屏幕连接到 ESP32 卡很容易，只需遵循下图。对于按钮，将一个按钮引脚连接到 ESP32 板的<strong class="jm io"> GND </strong>引脚，将另一个引脚连接到支持 ESP32 板中数据输入的任何引脚就足够了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/ea588812713137a18bd2a84d6ae4dd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*UsQsctubXjNnkzVytTdW6g.png"/></div></figure><p id="ce71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">蓝色按钮将用于选择计数器号码(从属按钮)，绿色按钮(主按钮)将用于呼叫下一位顾客。</p><p id="dec3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当代理按下绿色按钮时，ESP32 板应该调用一个 LARAVEL REST API url 来调用下一个客户。因此，让我们创建新的 Laravel 控制器 Esp32Controller，并在其上添加三个动作:<strong class="jm io">刷新()</strong>、<strong class="jm io">调用()</strong>和<strong class="jm io">召回()</strong>。<strong class="jm io"> refresh() </strong>动作将用于定期刷新有机发光二极管屏幕中等待自定义的数量。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="8e4e" class="lc ld in ky b be le lf l lg lh">php artisan make:controller Esp32Controller</span></pre><pre class="li kx ky kz bn la lb bi"><span id="2eb5" class="lc ld in ky b be le lf l lg lh">class Esp32Controller extends Controller<br/>{<br/><br/>public function refresh(Request $request){  <br/> /** return waiting customers number **/  <br/>}<br/><br/>public function call(Request $request){    <br/>/** return next customer ticket number **/ <br/>}<br/><br/>public function recall(Request $request){ <br/>/** recall current customer ticket number **/    <br/>}<br/><br/>}</span></pre><p id="5849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那些已经编写过 android 板的人都知道，任何 arduino 程序都由两部分组成:</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="074d" class="lc ld in ky b be le lf l lg lh">void setup() {<br/><br/><br/>}<br/><br/>void loop() {<br/><br/><br/>}</span></pre><p id="9d14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个函数 setup()将被调用一次，用于初始化所用的硬件。然而，只要 ESP32 板通电，就会无限期调用如其名称所示的 loop()函数。</p><p id="25d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 arduino 代码中，我们将使用几个库:</p><p id="5681" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">EasyButton.h:将用于处理按钮按下事件。</p><p id="bb34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">WiFi.h:将用于处理 WiFi 连接和重新连接。</p><p id="ae73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">HTTPClient.h:将用于发送 http 请求并从 Esp32Contoller 获取 json 响应。</p><p id="27c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TFT_eSPI.h:用于在有机发光二极管屏幕上显示文本。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="a2b9" class="lc ld in ky b be le lf l lg lh">#include &lt;TFT_eSPI.h&gt;<br/>#include &lt;SPI.h&gt;<br/>#include &lt;EasyButton.h&gt;<br/>#include &lt;WiFi.h&gt;<br/>#include &lt;HTTPClient.h&gt;<br/>#include &lt;ArduinoJson.h&gt;<br/><br/><br/>#define VERSION "1.0.0"<br/><br/>#define DELAY 1000<br/><br/>#define master_BTN_PIN 33<br/>#define slave_BTN_PIN 14<br/><br/>const char* wifi_ssid = "*****";<br/>const char* wifi_password = "****";<br/>int wifi_channel             = 6;<br/>int wifi_ssid_hidden         = 0;<br/><br/><br/><br/>EasyButton masterButton(master_BTN_PIN);<br/>EasyButton slaveButton(slave_BTN_PIN);<br/><br/>TFT_eSPI tft = TFT_eSPI();  // Invoke library<br/><br/><br/>/** *** *******************************/<br/>/*    Init TFT display                 */<br/>/**************************************/<br/>void tft_init(){  <br/>   tft.init(); <br/>   tft.setRotation(3);<br/>   tft.fillScreen(TFT_BLACK);<br/>   tft.drawCentreString("WIFI CONSOLE v"+ String(VERSION), 80,20, 2);<br/>   delay(DELAY);<br/>}<br/><br/>/** *** *******************************/<br/>/*  WIFI Connected Event              */<br/>/**************************************/<br/><br/>void WiFiStationConnected(WiFiEvent_t event, WiFiEventInfo_t info){<br/>  Serial.println("Connected to AP successfully!");<br/>}<br/><br/>/** *** *******************************/<br/>/*  WIFI GET IP Event              */<br/>/**************************************/<br/>void WiFiGotIP(WiFiEvent_t event, WiFiEventInfo_t info){  <br/>  <br/>  Serial.println("WiFi connected");<br/>  Serial.println("IP address: ");  <br/>  Serial.println(WiFi.localIP());<br/><br/>}<br/><br/>/** *** *******************************/<br/>/*  WIFI Disconnected  Event          */<br/>/**************************************/<br/>void WiFiStationDisconnected(WiFiEvent_t event, WiFiEventInfo_t info){  <br/>    WiFi.begin(wifi_ssid, wifi_password,wifi_channel);  <br/>}<br/><br/><br/>** *** *******************************/<br/>/*  Master  button click event        */<br/>/**************************************/<br/>void onMasterButtonPressed() {<br/>  Serial.println("master button has been pressed!");  <br/>  //call(); <br/>}<br/><br/>/** *** *******************************/<br/>/*  Slave button click event        */<br/>/**************************************/<br/>void onSlaveButtonPressed() {<br/>  Serial.println("slave button has been pressed!"); <br/> //recall();<br/>}<br/><br/>void setup() {<br/>  <br/>   Serial.begin(115200);<br/>   <br/>   /** tft init **/<br/>   tft_init(); <br/><br/>   /** buttons init **/<br/>   masterButton.begin();<br/>   slaveButton.begin();<br/><br/>   masterButton.onPressed(onMasterButtonPressed);<br/>   slaveButton.onPressed(onSlaveButtonPressed);<br/><br/><br/>   /** init wifi **/<br/>   deloldconfig();<br/>   WiFi.onEvent(WiFiStationConnected, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_CONNECTED);<br/>   WiFi.onEvent(WiFiGotIP,  WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_GOT_IP);<br/>   WiFi.onEvent(WiFiStationDisconnected, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED);<br/><br/>   Serial.println();<br/>   Serial.println();<br/>   Serial.println("Wait for WiFi... ");<br/>   <br/>   WiFi.begin(wifi_ssid, wifi_password,wifi_channel);<br/><br/>}<br/><br/>void loop() {<br/> <br/>  masterButton.read();<br/>  slaveButton.read(); <br/>  <br/>   unsigned long currentMillis = millis();<br/>   if(currentMillis - refresh_previousMillis &gt; refresh_timerDelay) {<br/>      refresh_previousMillis = currentMillis;       <br/>      if((wifi_is_connected==1)){  <br/>      // refresh();<br/>      }     <br/>  }<br/><br/>}</span></pre><p id="d5a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是全部，如果你有意见或问题，欢迎你。</p></div></div>    
</body>
</html>