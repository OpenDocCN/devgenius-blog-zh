<html>
<head>
<title>Using MongoDB with Mongoose — Discriminators and Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB和mongose——鉴别器和钩子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-mongodb-with-mongoose-discriminators-and-hooks-482de1614a26?source=collection_archive---------1-----------------------#2021-01-29">https://blog.devgenius.io/using-mongodb-with-mongoose-discriminators-and-hooks-482de1614a26?source=collection_archive---------1-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4cf30aede0819cd83649d3000c97c427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hz6ZhL3YTFYWlVCw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@veverkolog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杜安·斯美塔纳</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2255" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化MongoDB数据库操作，我们可以使用mongose NPM包来简化MongoDB数据库的操作。</p><p id="0b19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Mongoose来操作我们的MongoDB数据库。</p><h1 id="5a15" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">鉴别器和查询</h1><p id="a507" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">查询足够聪明，可以考虑鉴别符。</p><p id="33e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="038e" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };<br/>  const eventSchema = new Schema({ time: Date }, options);<br/>  const Event = db.model('Event', eventSchema);</span><span id="61de" class="mn lc iq mj b gy ms mp l mq mr">  const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    new Schema({ url: String }, options));</span><span id="59f6" class="mn lc iq mj b gy ms mp l mq mr">  const SignedUpEvent = Event.discriminator('SignedUp',<br/>    new Schema({ user: String }, options));</span><span id="94b3" class="mn lc iq mj b gy ms mp l mq mr">  const event1 = new Event({ time: Date.now() });<br/>  const event2 = new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  const event3 = new SignedUpEvent({ time: Date.now(), user: 'mongodbuser' });<br/>  await Promise.all([event1.save(), event2.save(), event3.save()]);<br/>  const clickedLinkEvent =  await ClickedLinkEvent.find({});<br/>  console.log(clickedLinkEvent);<br/>}<br/>run();</span></pre><p id="6e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe mt mu mv mj b">ClickedLinkEvent.find</code>方法。</p><p id="5b5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将获得所有的<code class="fe mt mu mv mj b">ClickedLinkEvent</code>实例。</p><h1 id="70f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">识别器前后挂钩</h1><p id="4471" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以给用鉴别器创建的模式添加前置和后置挂钩。</p><p id="2552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5786" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };<br/>  const eventSchema = new Schema({ time: Date }, options);<br/>  const Event = db.model('Event', eventSchema);</span><span id="6513" class="mn lc iq mj b gy ms mp l mq mr">  const clickedLinkSchema = new Schema({ url: String }, options)<br/>  clickedLinkSchema.pre('validate', (next) =&gt; {<br/>    console.log('validate click link');<br/>    next();<br/>  });<br/>  const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    clickedLinkSchema);</span><span id="745c" class="mn lc iq mj b gy ms mp l mq mr">  const event1 = new Event({ time: Date.now() });<br/>  const event2 = new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  await event2.validate();<br/>}<br/>run();</span></pre><p id="187e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">clickedLinkSchema</code>上增加一个用于<code class="fe mt mu mv mj b">validate</code>操作的预钩。</p><h1 id="1940" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理Custom _id字段</h1><p id="c185" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果在基础模式上设置了一个<code class="fe mt mu mv mj b">_id</code>字段，那么它将总是覆盖鉴别器的<code class="fe mt mu mv mj b">_id</code>字段。</p><p id="1da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a114" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };</span><span id="f43c" class="mn lc iq mj b gy ms mp l mq mr">  const eventSchema = new Schema({ _id: String, time: Date },<br/>    options);<br/>  const Event = db.model('BaseEvent', eventSchema);</span><span id="063d" class="mn lc iq mj b gy ms mp l mq mr">  const clickedLinkSchema = new Schema({<br/>    url: String,<br/>    time: String<br/>  }, options);</span><span id="46b7" class="mn lc iq mj b gy ms mp l mq mr">  const ClickedLinkEvent = Event.discriminator('ChildEventBad',<br/>    clickedLinkSchema);</span><span id="6026" class="mn lc iq mj b gy ms mp l mq mr">  const event1 = new ClickedLinkEvent({ _id: 'custom id', time: '12am' });<br/>  console.log(typeof event1._id);<br/>  console.log(typeof event1.time);<br/>}<br/>run();</span></pre><p id="25a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志中，我们可以看到<code class="fe mt mu mv mj b">event1</code>的<code class="fe mt mu mv mj b">_id</code>和<code class="fe mt mu mv mj b">time</code>字段都是字符串。</p><p id="5c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此<code class="fe mt mu mv mj b">_id</code>字段与<code class="fe mt mu mv mj b">eventSchema</code>字段相同，但是<code class="fe mt mu mv mj b">ClickedLinkEvent</code>字段与<code class="fe mt mu mv mj b">clickedLinkSchema</code>字段的类型相同。</p><h1 id="14c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对Model.create()使用鉴别器</h1><p id="8ff2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe mt mu mv mj b">Model.create</code>方法使用鉴别器。</p><p id="d81b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d1b2" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const shapeSchema = new Schema({<br/>    name: String<br/>  }, { discriminatorKey: 'kind' });</span><span id="dbfa" class="mn lc iq mj b gy ms mp l mq mr">  const Shape = db.model('Shape', shapeSchema);</span><span id="4d4f" class="mn lc iq mj b gy ms mp l mq mr">  const Circle = Shape.discriminator('Circle',<br/>    new Schema({ radius: Number }));<br/>  const Square = Shape.discriminator('Square',<br/>    new Schema({ side: Number }));</span><span id="08ac" class="mn lc iq mj b gy ms mp l mq mr">  const shapes = [<br/>    { name: 'Test' },<br/>    { kind: 'Circle', radius: 5 },<br/>    { kind: 'Square', side: 10 }<br/>  ];<br/>  const [shape1, shape2, shape3] = await Shape.create(shapes);<br/>  console.log(shape1 instanceof Shape);<br/>  console.log(shape2 instanceof Circle);<br/>  console.log(shape3 instanceof Square);<br/>}<br/>run();</span></pre><p id="66b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">discriminator</code>方法为形状创建了3个模式。</p><p id="81f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用一组不同形状的对象调用<code class="fe mt mu mv mj b">Shape.create</code>。</p><p id="5eae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">kind</code>属性指定了类型，因为我们将它设置为鉴别器键。</p><p id="d556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在控制台日志中，它们应该都记录了<code class="fe mt mu mv mj b">true</code>，因为我们指定了每个条目的类型。</p><p id="189b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有指定，那么它具有基本类型。</p><h1 id="6985" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e9e5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将钩子添加到由鉴别器创建的模式中。</p><p id="6eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">_id</code>字段的处理方式不同于其他鉴别器字段。</p><p id="9b93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用带有鉴别器的<code class="fe mt mu mv mj b">create</code>方法。</p></div></div>    
</body>
</html>