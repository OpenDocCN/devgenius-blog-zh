<html>
<head>
<title>Listening to Multiple Channels in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go 中收听多个频道</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/listening-to-multiple-channels-in-go-11a1c6cd3a21?source=collection_archive---------0-----------------------#2022-09-05">https://blog.devgenius.io/listening-to-multiple-channels-in-go-11a1c6cd3a21?source=collection_archive---------0-----------------------#2022-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8148" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到这个系列！今天我们来看看同时收听多个频道的方法。之前的指南帮助您开始使用 Go 中的并发性。尽管简单的方法通常是最好的方法，但是您可能一直在尝试实现更复杂的行为。阅读本指南后，您将能够使您的并发代码更加灵活。</p><h1 id="a8eb" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">选择关键字</h1><p id="d785" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们可以使用<code class="fe ll lm ln lo b">select</code>关键字同时收听多个 goroutines。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="d7a0" class="lx kj in lo b gy ly lz l ma mb">package main</span><span id="ed99" class="lx kj in lo b gy mc lz l ma mb">import (<br/>    "fmt"<br/>    "time"<br/>)</span><span id="5ae4" class="lx kj in lo b gy mc lz l ma mb">func main() {<br/>    c1 := make(chan string)<br/>    c2 := make(chan string)</span><span id="f562" class="lx kj in lo b gy mc lz l ma mb">    go func() {<br/>        time.Sleep(1 * time.Second)<br/>        c1 &lt;- time.Now().String()<br/>    }()</span><span id="9cad" class="lx kj in lo b gy mc lz l ma mb">    go func() {<br/>        time.Sleep(2 * time.Second)<br/>        c2 &lt;- time.Now().String()<br/>    }()</span><span id="7c3c" class="lx kj in lo b gy mc lz l ma mb">    for i := 0; i &lt; 2; i++ {<br/>        select {<br/>        case res1 := &lt;-c1:<br/>            fmt.Println("from c1:", res1)<br/>        case res2 := &lt;-c2:<br/>            fmt.Println("from c2:", res2)<br/>        }<br/>    }<br/>}</span><span id="e57d" class="lx kj in lo b gy mc lz l ma mb">from c1: 2022-09-04 14:30:39.4469184 -0400 EDT m=+1.000172801<br/>from c2: 2022-09-04 14:30:40.4472699 -0400 EDT m=+2.000524401</span></pre><p id="33bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码展示了<code class="fe ll lm ln lo b">select</code>关键字是如何工作的。</p><ul class=""><li id="4dbf" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">我们首先创建两个频道<code class="fe ll lm ln lo b">c1</code>和<code class="fe ll lm ln lo b">c2</code>来听。</li><li id="4660" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">然后我们生成两个 goroutines，每个都将当前时间发送给<code class="fe ll lm ln lo b">c1</code>和<code class="fe ll lm ln lo b">c2</code>。</li><li id="1300" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">在 for 循环中，我们创建了一个<code class="fe ll lm ln lo b">select</code>语句并定义了两种情况:第一种情况是当我们可以从<code class="fe ll lm ln lo b">c1</code>接收时，第二种情况是当我们可以从<code class="fe ll lm ln lo b">c2</code>接收时。</li></ul><p id="1e39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到<code class="fe ll lm ln lo b">select</code>语句在设计上与<code class="fe ll lm ln lo b">switch</code>语句非常相似。两者都定义了不同的情况，并在遇到特定情况时运行各自的代码。另外，我们可以看到<code class="fe ll lm ln lo b">select</code>语句正在阻塞。也就是说，它会一直等到满足其中一种情况。</p><p id="8159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们对循环迭代两次，因为只有两个 goroutines 要听。更确切地说，每个 goroutine 都是一个“一劳永逸”的 goroutine，这意味着它们在返回之前只向一个频道发送一次。因此，这段代码中始终最多有两条消息，我们只需要选择两次。</p><h1 id="1cbc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如果我们不知道工作什么时候会结束呢？</h1><p id="7a8a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">有时候我们不知道有多少工作。在这种情况下，将<code class="fe ll lm ln lo b">select</code>语句放在 while 循环中。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="546d" class="lx kj in lo b gy ly lz l ma mb">package main</span><span id="cddb" class="lx kj in lo b gy mc lz l ma mb">import (<br/>    "fmt"<br/>    "math/rand"<br/>    "time"<br/>)</span><span id="7ac7" class="lx kj in lo b gy mc lz l ma mb">func main() {<br/>    c1 := make(chan string)<br/>    rand.Seed(time.Now().UnixNano())</span><span id="a72f" class="lx kj in lo b gy mc lz l ma mb">    for i := 0; i &lt; rand.Intn(10); i++ {<br/>        go func() {<br/>            time.Sleep(1 * time.Second)<br/>            c1 &lt;- time.Now().String()<br/>        }()<br/>    }</span><span id="cd63" class="lx kj in lo b gy mc lz l ma mb">    for {<br/>        select {<br/>        case res1 := &lt;-c1:<br/>            fmt.Println("from c1:", res1)<br/>        }<br/>    }<br/>}</span></pre><p id="e676" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们让随机数量的 goroutines 运行，所以我们不知道有多少个作业。幸运的是，底部封装 select 语句的 for 循环将捕获每个输出。让我们看看运行这段代码会发生什么。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="4a93" class="lx kj in lo b gy ly lz l ma mb">from c1: 2022-09-04 14:48:47.5145341 -0400 EDT m=+1.000257801<br/>from c1: 2022-09-04 14:48:47.5146126 -0400 EDT m=+1.000336201<br/>from c1: 2022-09-04 14:48:47.5146364 -0400 EDT m=+1.000359901<br/>fatal error: all goroutines are asleep - deadlock!</span><span id="d6d9" class="lx kj in lo b gy mc lz l ma mb">goroutine 1 [chan receive]:<br/>main.main()<br/>        /home/jacob/blog/testing/listening-to-multiple-channels-in-go/main.go:22 +0x128<br/>exit status 2</span></pre><p id="e955" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，select 语句按预期收到了三次，但是程序由于死锁而出错。为什么会这样呢？</p><p id="56f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，在没有任何条件的情况下，Go 中的 for 循环将永远运行。这意味着 select 语句将永远尝试接收。但是，要运行的作业数量有限。即使没有更多的作业，select 语句仍将尝试接收。</p><p id="8b74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得在本系列的第一篇文章中，我说过如果你在发送者没有准备好的时候试图从一个无缓冲的通道接收，你的程序将会陷入死锁吗？这正是我们例子中的情况。</p><p id="c714" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们如何解决这个问题呢？我们可以结合使用前几篇文章中提到的概念:出口通道和等待组。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="2e62" class="lx kj in lo b gy ly lz l ma mb">package main</span><span id="b37a" class="lx kj in lo b gy mc lz l ma mb">import (<br/>    "fmt"<br/>    "math/rand"<br/>    "sync"<br/>    "time"<br/>)</span><span id="a963" class="lx kj in lo b gy mc lz l ma mb">func main() {<br/>    c1 := make(chan string)<br/>    exit := make(chan struct{})<br/>    rand.Seed(time.Now().UnixNano())<br/>    var wg sync.WaitGroup</span><span id="cd1c" class="lx kj in lo b gy mc lz l ma mb">    go func() {<br/>        numJob := rand.Intn(10)<br/>        fmt.Println("number of jobs:", numJob)<br/>        for i := 0; i &lt; numJob; i++ {<br/>            wg.Add(1)<br/>            go func() {<br/>                defer wg.Done()<br/>                time.Sleep(1 * time.Second)<br/>                c1 &lt;- time.Now().String()<br/>            }()<br/>        }<br/>        wg.Wait()<br/>        close(exit)<br/>    }()</span><span id="f0ba" class="lx kj in lo b gy mc lz l ma mb">    for {<br/>        select {<br/>        case res1 := &lt;-c1:<br/>            fmt.Println("from c1:", res1)<br/>        case &lt;-exit:<br/>            return<br/>        }<br/>    }<br/>}</span><span id="8607" class="lx kj in lo b gy mc lz l ma mb">3<br/>from c1: 2022-09-04 15:09:08.6936976 -0400 EDT m=+1.000287801<br/>from c1: 2022-09-04 15:09:08.6937788 -0400 EDT m=+1.000369101<br/>from c1: 2022-09-04 15:09:08.6937949 -0400 EDT m=+1.000385101</span></pre><ul class=""><li id="29f7" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">我们创建一个退出通道和一个等待组。</li><li id="ee6c" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">每次运行的作业数量是随机的。很多次，我们发射 goroutines。为了等待作业完成，我们将它们添加到<code class="fe ll lm ln lo b">wg</code>。当一项工作完成时，我们从<code class="fe ll lm ln lo b">wg</code>中减去一。</li><li id="bfb6" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">一旦所有工作完成，我们关闭出口通道。</li><li id="2b73" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">我们将上述部分包装在一个 goroutine 中，因为我们希望所有部分都是非阻塞的。如果我们不把它包在 goroutine 中，<code class="fe ll lm ln lo b">wg.Wait()</code>会等到任务完成。这会阻塞代码，不让底层的 for-select 语句运行。</li><li id="72f1" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">此外，因为<code class="fe ll lm ln lo b">c1</code>是一个无缓冲通道，等待所有 goroutines 将消息发送到<code class="fe ll lm ln lo b">c1</code>将导致许多消息被发送到<code class="fe ll lm ln lo b">c1</code>，而没有 for-select 语句来接收它们。这会导致死锁，因为发送方准备好了，而接收方却没有准备好。</li></ul><h1 id="9766" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如何使选择无阻塞</h1><p id="49d7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">默认情况下,<code class="fe ll lm ln lo b">select</code>语句是阻塞的。我们如何使它不阻塞？很简单——我们只需添加一个默认案例。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="fb0c" class="lx kj in lo b gy ly lz l ma mb">package main</span><span id="77ab" class="lx kj in lo b gy mc lz l ma mb">import (<br/>    "fmt"<br/>    "math/rand"<br/>    "sync"<br/>    "time"<br/>)</span><span id="62cc" class="lx kj in lo b gy mc lz l ma mb">func main() {<br/>    ashleyMsg := make(chan string)<br/>    brianMsg := make(chan string)<br/>    exit := make(chan struct{})<br/>    rand.Seed(time.Now().UnixNano())<br/>    var wg sync.WaitGroup</span><span id="1a66" class="lx kj in lo b gy mc lz l ma mb">    go func() {<br/>        numJob := rand.Intn(10)<br/>        fmt.Println("number of jobs:", numJob)<br/>        for i := 0; i &lt; numJob; i++ {<br/>            wg.Add(2)<br/>            go func() {<br/>                defer wg.Done()<br/>                time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)<br/>                ashleyMsg &lt;- "hi"<br/>            }()<br/>            go func() {<br/>                defer wg.Done()<br/>                time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)<br/>                brianMsg &lt;- "what's up"<br/>            }()<br/>        }<br/>        wg.Wait()<br/>        close(exit)<br/>    }()</span><span id="e70c" class="lx kj in lo b gy mc lz l ma mb">    for {<br/>        select {<br/>        case res1 := &lt;-ashleyMsg:<br/>            fmt.Println("ashley:", res1)<br/>        case res2 := &lt;-brianMsg:<br/>            fmt.Println("brian:", res2)<br/>        case &lt;-exit:<br/>            fmt.Println("chat ended")<br/>            return<br/>        default:<br/>            fmt.Println("...")<br/>            time.Sleep(time.Millisecond)<br/>        }<br/>    }<br/>}</span><span id="99da" class="lx kj in lo b gy mc lz l ma mb">...<br/>number of jobs: 4<br/>brian: what's up<br/>...<br/>ashley: hi<br/>...<br/>...<br/>brian: what's up<br/>ashley: hi<br/>ashley: hi<br/>brian: what's up<br/>...<br/>...<br/>ashley: hi<br/>...<br/>brian: what's up<br/>...<br/>chat ended</span></pre><p id="3a8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抛开蹩脚的对话，我们可以看看违约案例是如何运作的。我们可以在没有接收聊天信息的渠道时做一些事情，而不是等待聊天信息的到来。在这个例子中，我们只是打印出了椭圆，但是你可以做任何你想做的事情。</p><h1 id="4cb4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="4252" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这个帖子到此为止！现在，您可以同时收听多个频道，这在您开发个人项目时是一笔巨大的财富。感谢阅读，我们下次再见。</p><p id="f17d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae mr" href="https://dev.to/jpoly1219/listening-to-multiple-channels-in-go-152e" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae mr" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>