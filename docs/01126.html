<html>
<head>
<title>More Node.js App Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多Node.js应用程序最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/more-node-js-app-best-practices-a68f3f978a78?source=collection_archive---------37-----------------------#2020-06-24">https://blog.devgenius.io/more-node-js-app-best-practices-a68f3f978a78?source=collection_archive---------37-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/322ade6f99e0503e7307b62bb891b02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7jFcneXyCnq8rBfj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Lukasz Szmigiel 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3d84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，节点应用程序也必须编写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些节点最佳实践。</p><h1 id="934a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不推荐使用的API</h1><p id="d3cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有许多我们应该避免使用的不推荐使用的API。</p><p id="ace7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe me mf mg mh b">assert</code>模块有一些方法，如<code class="fe me mf mg mh b">deepEqual</code>、<code class="fe me mf mg mh b">equal</code>等。不推荐使用的。</p><p id="8880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">crypto</code>也有一些弃用的模块。</p><p id="c903" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fs</code>也有一些不赞成使用的方法。</p><p id="e4b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有很多没有在这里列出。</p><p id="ee10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该避免使用它们，因为它们将来会被删除。</p><h1 id="3393" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回调返回</h1><p id="dc06" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当回调在主函数体之外被触发时，回调都应该有一个<code class="fe me mf mg mh b">return</code>语句。</p><p id="818a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可能会多次完成某个动作。</p><p id="bfcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06a4" class="mq lc iq mh b gy mr ms l mt mu">const doWork = (err, callback) =&gt; {<br/>  if (err) {<br/>    return callback(err);<br/>  }<br/>  callback();<br/>}</span></pre><p id="c9f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当<code class="fe me mf mg mh b">err</code>被定义时，我们停止运行函数。</p><p id="6816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在最后一行只在<code class="fe me mf mg mh b">err</code>未定义时运行。</p><h1 id="57af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">导出样式</h1><p id="6379" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该一致地使用<code class="fe me mf mg mh b">module.exports</code>或<code class="fe me mf mg mh b">exports</code>。</p><p id="f148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会困惑了。</p><p id="d051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该坚持:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db48" class="mq lc iq mh b gy mr ms l mt mu">module.exports = {<br/>  foo: 'bar'<br/>}</span></pre><p id="6e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="64c4" class="mq lc iq mh b gy mr ms l mt mu">exports.bar = 'baz';</span></pre><p id="ef63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很容易混淆这两者，因为它们的行为不同，我们很容易出错。</p><h1 id="5fa5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">导入中的文件扩展名</h1><p id="6b7b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们导入一个模块时，我们不需要添加文件扩展名。</p><p id="a7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27ef" class="mq lc iq mh b gy mr ms l mt mu">import foo from "./path/to/a/file.js" <br/>export * from "./path/to/a/file.js"</span></pre><p id="5c65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fe22" class="mq lc iq mh b gy mr ms l mt mu">import foo from "./path/to/a/file" <br/>export * from "./path/to/a/file"</span></pre><p id="db1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将解析为一个<code class="fe me mf mg mh b">.js</code>或<code class="fe me mf mg mh b">.json</code>文件。</p><h1 id="3419" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全局需求</h1><p id="7b6e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在顶级模块范围内进行<code class="fe me mf mg mh b">require</code>调用。</p><p id="b4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以在模块的任何地方使用它们。</p><p id="697a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2561" class="mq lc iq mh b gy mr ms l mt mu">if (condition) {<br/>  const fs = require("fs");<br/>}</span></pre><p id="20af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f6b" class="mq lc iq mh b gy mr ms l mt mu">const fs = require("fs");</span></pre><p id="dbf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6模块必须在顶部导入，所以我们不会有这个问题。</p><h1 id="71fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无混合要求</h1><p id="819a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在同一行中有多个<code class="fe me mf mg mh b">require</code>。</p><p id="e6ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe me mf mg mh b">require</code>和赋值放在不同的行会更清楚。</p><p id="23d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6152" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs'),        <br/>    async = require('async'), <br/>    foo = require('./foo'),   <br/>    bar = require(name()),  <br/>    baz = 42,                  <br/>    bam;</span></pre><p id="4773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在同一行中既有require语句又有变量赋值。</p><p id="5421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于一些人来说肯定是困惑的。</p><p id="2785" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2fc4" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const async = require('async');<br/>const foo = require('./foo');<br/>const bar = require(name()); <br/>const baz = 42;<br/>let bam;</span></pre><h1 id="b972" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">过程环境</h1><p id="940f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可能希望在整个代码中停止使用<code class="fe me mf mg mh b">proecess.env</code>。</p><p id="c7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们把环境变量都放在一个地方，然后引用它。</p><p id="9ebc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e37" class="mq lc iq mh b gy mr ms l mt mu">const config = require("./config");</span><span id="39b6" class="mq lc iq mh b gy mv ms l mt mu">if(config.env === "development") {<br/>    //...<br/>}</span></pre><p id="5444" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从文件中导入<code class="fe me mf mg mh b">config</code>，这样我们就不必使用<code class="fe me mf mg mh b">process.env</code>。</p><p id="ca6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，一些像<code class="fe me mf mg mh b">dotenv </code>这样的图书馆可能会使用<code class="fe me mf mg mh b">process.env</code>，所以这个规则可能不适用。</p><h1 id="839c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">限制进口</h1><p id="8758" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可能想要限制不想让人们使用的模块的进口。</p><p id="fa74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们只能使用允许的库。</p><p id="6e35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用eslint-plugin-node插件做到这一点。</p><h1 id="b740" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">限制要求</h1><p id="641d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像导入一样，我们可以用eslint-plugin-node插件来限制需求。</p><h1 id="4080" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不使用同步功能</h1><p id="465b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在编写应用程序，那么我们不应该使用同步函数。</p><p id="57c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为一个同步操作会阻止程序的其余部分运行。</p><p id="2f5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们的应用程序的性能就会受到影响。</p><p id="6b39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于脚本和命令行实用程序来说，使用同步函数是可以的。</p><p id="8234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对于其他任何东西，我们都不应该使用它们。</p><p id="f30e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们正在编写一个web应用程序，那么我们不应该使用像<code class="fe me mf mg mh b">fs.existsSync()</code>这样的方法。</p><h1 id="443b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用全局缓冲或需要缓冲模块</h1><p id="d436" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们要么使用<code class="fe me mf mg mh b">Buffer</code>全局变量，要么始终需要<code class="fe me mf mg mh b">buffer</code>模块。</p><p id="9891" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们要么处处用<code class="fe me mf mg mh b">Buffer</code>，要么处处用<code class="fe me mf mg mh b">require(“buffer”).Buffer</code>。</p><h1 id="e7b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用全局控制台对象或需要控制台模块</h1><p id="ad9f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">节点有<code class="fe me mf mg mh b">console</code>模块和<code class="fe me mf mg mh b">console</code>全局对象。</p><p id="5aa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以坚持其中任何一个，并坚持它的一致性。</p><p id="440e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们要么写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7573" class="mq lc iq mh b gy mr ms l mt mu">console</span></pre><p id="263b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c663" class="mq lc iq mh b gy mr ms l mt mu">const console = require("console");</span></pre><h1 id="3df1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用全局流程对象或需要流程模块</h1><p id="7eaf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像<code class="fe me mf mg mh b">console</code>一样，<code class="fe me mf mg mh b">process</code>也作为一个全局对象或模块出现。</p><p id="d110" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b934" class="mq lc iq mh b gy mr ms l mt mu">process</span></pre><p id="4443" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4f69" class="mq lc iq mh b gy mr ms l mt mu">const process = require("process");</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5297be7f76fd0a35f07898aee37ed284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wE7Iqk8ZRKQit4zI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@maritafox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marita Kavelashvili </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b498" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ab51" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在我们的节点应用程序中坚持一种做事方式。</p><p id="c9af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，同步方法只适用于脚本和命令行程序。</p></div></div>    
</body>
</html>