<html>
<head>
<title>Frolics — An Offline, Lightweight, Full-Text Search Library For Frontend Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">frolics——一个用于前端应用程序的离线、轻量级全文搜索库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/frolics-an-offline-lightweight-full-text-search-library-for-frontend-applications-121d029f5d9c?source=collection_archive---------11-----------------------#2022-08-24">https://blog.devgenius.io/frolics-an-offline-lightweight-full-text-search-library-for-frontend-applications-121d029f5d9c?source=collection_archive---------11-----------------------#2022-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f6f2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="d25b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">本文是对我自制的打字稿包“Frolics”的介绍，其灵感来源于 Elasticsearch、Solr 等现代全文搜索库。</p><p id="1b7f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我的目标是为前端应用程序创建一个轻量级的离线库。你可以在<a class="ae ll" href="https://www.npmjs.com/package/frolics" rel="noopener ugc nofollow" target="_blank"> NPM 页面</a>找到这个包。</p><p id="2fbd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这里省略了 Frolics 下的实现。相反，我将介绍现代搜索库如何收集原始数据，并将其转化为字典，以提高搜索效率。</p><p id="0720" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最后但同样重要的是，我将在 ReactJS 中提供一个实际的例子来演示 Frolics 是如何工作的，并展示它在应用于您的项目时的灵活性和友好性。</p><p id="243b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果你对开源贡献感兴趣，请随时打开一个问题或公关。感谢每一个反馈。</p><p id="9b0b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果你觉得这个包有用，请在我的<a class="ae ll" href="https://github.com/IMingGarson/Frolics" rel="noopener ugc nofollow" target="_blank">回购</a>里留个星，它对我意义重大。谢谢你。</p><p id="7896" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们开始吧。</p><h1 id="1de1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数据预处理</h1><p id="6c9d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在我们进行搜索之前，不可避免地要处理无组织的原始数据。一般来说，将杂乱的数据转化为我们想要的东西需要两个主要的动作:</p><ol class=""><li id="86b6" class="lm ln in kk b kl lg kp lh kt lo kx lp lb lq lf lr ls lt lu bi translated">标记化—将文档拆分成几个标记，并排除停用词(如果有)。</li><li id="b312" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated">词干化—根据相似性聚合令牌以节省空间。</li></ol><h2 id="0a7a" class="ma jl in bd jm mb mc dn jq md me dp ju kt mf mg jy kx mh mi kc lb mj mk kg ml bi translated">标记化</h2><p id="fc21" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 JavaScript 中，我们可以像这样用空格分割文档:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ca11" class="ma jl in mr b gy mv mw l mx my">let words = words.split(' ');</span></pre><p id="67ec" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">将文档分割成标记不仅有助于我们更好地分析其组成，而且，由于停用词的存在，还能让我们洞察标记在每个文档中的重要性。</p><p id="6b95" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是为什么呢？这里有一个无害的剧透警告——我们将计算所有文档中令牌的<code class="fe mz na nb mr b">weight</code>值。通过这样做，我们对原始数据进行分类和排序，以便在搜索时获得最相关的结果。</p><p id="0efb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是 Frolics 使用的带有正则表达式的简单标记器，它只允许英文字母:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7599" class="ma jl in mr b gy mv mw l mx my">let words = [...new Set(words.filter((v) =&gt; /^\w+$/.test(v)))];</span></pre><p id="c02a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这里我使用了<code class="fe mz na nb mr b">Set</code>来删除重复的令牌。</p><h2 id="e4ac" class="ma jl in bd jm mb mc dn jq md me dp ju kt mf mg jy kx mh mi kc lb mj mk kg ml bi translated"><strong class="ak">停止字</strong></h2><p id="9d81" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">停用词是通常用于语法目的的通用词。这些词在大多数文档中会出现多次，以至于在搜索时变得无关紧要。比如:<code class="fe mz na nb mr b">the</code>、<code class="fe mz na nb mr b">will</code>、<code class="fe mz na nb mr b">and</code>……等等。</p><p id="60fc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请记住，没有通用的停用词列表，Frolics 使用 Elasticsearch 提供的停用词。</p><p id="d0d6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个过程很容易完成，如下所示:</p><figure class="mm mn mo mp gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="efed" class="ma jl in bd jm mb mc dn jq md me dp ju kt mf mg jy kx mh mi kc lb mj mk kg ml bi translated"><strong class="ak">词干</strong></h2><p id="ae37" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一些单词由于它们的变形或起源而具有相似的结构。典型地，为了节省空间，利用<strong class="kk io">词干</strong>对相似的词进行分类。</p><p id="689f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">例如，像<code class="fe mz na nb mr b">develop</code>、<code class="fe mz na nb mr b">developer</code>、<code class="fe mz na nb mr b">development</code>和<code class="fe mz na nb mr b">developing</code>这样的单词可以有相同的词干<code class="fe mz na nb mr b">develop</code>。为了简单起见，我们可以将这 4 个单词视为一个条目，并建立一个字典。</p><p id="8d0e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Frolics 使用波特斯特梅尔算法实现词干提取，这里是<a class="ae ll" href="https://tartarus.org/martin/PorterStemmer/js.txt" rel="noopener ugc nofollow" target="_blank">源代码链接</a>。</p><h1 id="9cee" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">重量计算</h1><p id="074f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦我们将文档转换成多个令牌，我们就可以计算它们的<code class="fe mz na nb mr b">weights</code>。权重是一个数值，它表示一个标记在给定文档中有多重要。</p><p id="2366" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">TF-IDF 和 BM25 是获得这种数值统计的广泛使用的算法，后者被认为是前者的优化版本。</p><p id="ff8d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Frolics 用 BM25 计算重量，我们来看看它的方程式:</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/5a2d9fe75143ae9a7e00e8bec4b7bde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvTqEcCDkFhmqwybGSj0qA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">BM25 方程</figcaption></figure><p id="d386" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mz na nb mr b">k1</code>和<code class="fe mz na nb mr b">b</code>是默认常量，在 Frolics 中分别为 1.2 和 0.75。</p><h2 id="c4e4" class="ma jl in bd jm mb mc dn jq md me dp ju kt mf mg jy kx mh mi kc lb mj mk kg ml bi translated">深入 BM25</h2><p id="b9b1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">先说<code class="fe mz na nb mr b">IDF(qi)</code>吧:</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/2316bb068feabb32c22e454d59b4867c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F1yOgwdnTNiQnIWTQ77Uw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">IDF 方程</figcaption></figure><p id="f72c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">IDF，或逆文档频率，<strong class="kk io">测量一个术语在所有文档中出现的频率，并“惩罚”常见的术语。</strong></p><p id="79fc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在 IDF 等式中，<code class="fe mz na nb mr b">docCount</code>表示第<strong class="kk io">个文档，</strong>和<strong class="kk io"> </strong> <code class="fe mz na nb mr b">f(qi)</code> <strong class="kk io"> </strong>表示包含第 I 个查询词的<strong class="kk io"/><strong class="kk io">个文档。</strong></p><p id="5012" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">从上面的等式我们可以了解到，一个术语出现的<strong class="kk io">越高，它的得分</strong>就越少。</p><p id="e83f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">例如，我们有 4 个文档和两个单词<code class="fe mz na nb mr b">A</code>和<code class="fe mz na nb mr b">B</code>以及<code class="fe mz na nb mr b">f(A) = 2</code>和<code class="fe mz na nb mr b">f(B) = 4</code>。我们可以这样计算它们的重量:</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/8cd9a4df119061c1bb566a39aa11e3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqxWOzYVWhLhxydDoXCKHA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">A 的加权值</figcaption></figure><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/997c5658968b1a5f47cf4b62a6916c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPTng1wWVSjYVYo5t45Ftg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">B 的加权值</figcaption></figure><p id="205a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">由于<code class="fe mz na nb mr b">B</code>出现的次数更多，所以在搜索的时候，它的重要性就不那么关键了，也就是说，你可能很容易就找到很多包含<code class="fe mz na nb mr b">B</code>的文档。为了确保搜索术语时的准确性，我们<strong class="kk io">惩罚高频术语</strong>和<strong class="kk io">查找包含术语</strong>的特定文档，而不是大多数文档。</p><p id="ca0b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">IDF 大概是 BM25 最重要的部分。如果你对整个故事感兴趣，我在参考部分提供了 Elasticsearch 官方网站的链接。强烈推荐看一看。</p><p id="cee9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这就是 IDF 和 BM25 的游戏:</p><figure class="mm mn mo mp gt nc"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">重量值计算</figcaption></figure><h1 id="670e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">倒排索引</h1><p id="a1f2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们有了令牌、文档和重量值。下一步是为搜索创建一个有效的数据结构。也就是——倒排索引。</p><p id="0279" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">倒排索引是一种数据库索引，其关键字可以是字符串或数值，值是文档集。</p><p id="e7b1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">例如:</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dfc51398eb292771ad617896dec2301f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*XZcu7wrRqbs692okk7CETg.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">倒排索引示例</figcaption></figure><p id="fea6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">通常我们要搜索最相关的文档，所以文档是按权重值排序的。</p><p id="0da9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这可以很容易地用 JavaScript 实现，如下所示:</p><figure class="mm mn mo mp gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="b178" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">摘要</h1><p id="a90c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是我在网上发布的第一个包。我真的很喜欢开发它，希望人们可以发现嬉戏不仅有用，而且鼓舞人心。</p><p id="52d7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这里有一个在<a class="ae ll" href="https://github.com/IMingGarson/ReactJS-Frolics-example" rel="noopener ugc nofollow" target="_blank"> ReactJS </a>中的实际例子。请给我留下一颗星和任何反馈。谢谢你。</p><h1 id="67fc" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">参考</strong></h1><div class="nr ns gp gr nt nu"><a href="https://medium.com/@tusharsri/nlp-a-quick-guide-to-stemming-60f1ca5db49e" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">NLP:词干快速指南</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">词干提取基本上就是去掉一个单词的后缀，把它简化成它的词根。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi nk nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://www.elastic.co/blog/practical-bm25-part-2-the-bm25-algorithm-and-its-variables" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">实用 BM25 -第 2 部分:BM25 算法及其变量</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">这是由三部分组成的 BM25 实用系列的第二篇关于相似性排名(相关性)的文章。如果你只是…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.elastic.co</p></div></div><div class="od l"><div class="oj l of og oh od oi nk nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://stackoverflow.com/questions/33929377/what-exactly-does-the-data-structure-of-the-inverted-index-in-solr-looks-like" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">SOLR 倒排索引的数据结构到底是什么样的</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">请原谅我，我刚刚开始学习如何与 SOLR 共事。强大的 SE。我已经知道倒置…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">stackoverflow.com</p></div></div><div class="od l"><div class="ok l of og oh od oi nk nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://github.com/IMingGarson/ReactJS-Frolics-example" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">GitHub-IMingGarson/ReactJS-Frolics-example:这是 react js 中的 Frolics 示例</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">这个项目是用 Create React App 引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="ol l of og oh od oi nk nu"/></div></div></a></div></div></div>    
</body>
</html>