<html>
<head>
<title>Kotlin Magic Functions — Everything You Need To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin神奇功能——你需要知道的一切</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-magic-functions-everything-you-need-to-know-63e9957eea11?source=collection_archive---------0-----------------------#2020-08-27">https://blog.devgenius.io/kotlin-magic-functions-everything-you-need-to-know-63e9957eea11?source=collection_archive---------0-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将看看Kotlin中函数最常见的<strong class="jp ir">【魔法】</strong>用法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5c39093b4b9f8f056af8577f65869588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_1-YDWMIGLi2CLPE"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@louis993546?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易·蔡</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6a3e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">扩展功能</h1><p id="cc1e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">先说简单的:<em class="mf">无继承扩展类</em>。我们可以在不改变类<code class="fe mg mh mi mj b">String</code>和所有使用它的包的情况下，通过添加新的方法或属性(字段)来扩展这个类。让我们有一个方法<code class="fe mg mh mi mj b">deleteSpaces()</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c9d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以像使用类<code class="fe mg mh mi mj b">String</code>的一部分一样使用这个方法。用户将会看到这样的内容:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译后，这个方法看起来会是这样的(部分代码已经简化，以便于您理解其本质):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e4e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由此我们可以得出结论，在方法<code class="fe mg mh mi mj b">deleteSpaces()</code>中，我们只能访问该类的公共字段和方法，因此封装不会被破坏。</p><p id="79a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以此类推，除了Kotlin中的扩展函数之外，还可以有扩展属性:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="57de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kotlin中函数和lambdas的大多数“神奇”用法，就像这个一样，无非是语法糖，但是多么方便啊！</p><h1 id="ba98" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">λ函数和匿名函数</h1><p id="037e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在Kotlin中，匿名函数和lambda函数是没有名字的函数，但它们也可以作为对象使用。它们可以直接写在表达式中，绕过单独的声明。</p><p id="e79e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">lambda表达式的语法是:</p><pre class="km kn ko kp gt mm mj mn mo aw mp bi"><span id="97a4" class="mq ld iq mj b gy mr ms l mt mu">{ arguments -&gt; returned_type<br/>    function_body<br/>}</span></pre><p id="27d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明匿名函数的语法与声明常规函数的语法完全相同，但是第一个函数没有名字。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a8a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后将讨论这些类型的函数之间的语义差异，但现在我们将考虑将lambdas与高阶函数一起使用的示例。</p><h1 id="0ec7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">高阶函数</h1><p id="f8cf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">高阶函数是将另一个函数作为其参数之一的函数，包括lambda或匿名函数。使用这种函数的一个突出例子是回调。</p><p id="a8b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个高阶函数<code class="fe mg mh mi mj b">longWork()</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="97ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将一个函数作为参数<code class="fe mg mh mi mj b">callback()</code>，但是只在函数<code class="fe mg mh mi mj b">doSomething()</code>之后调用它。使用此功能:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="cdb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们调用函数<code class="fe mg mh mi mj b">longWork()</code>并把一个lambda函数作为参数传递给它，它稍后会调用这个函数。如果lambda是函数的最后一个参数，Koltin允许您将它放在括号外，如果lambda是唯一的参数，也可以完全删除括号。此外，在大多数情况下，如果不使用参数，可以删除返回类型并用<code class="fe mg mh mi mj b">_</code>替换它们。以下是一个更简短的版本:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="849f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从表面上看，这并不像一个高阶函数，而是一个语言结构，例如，Java中的<code class="fe mg mh mi mj b">synchronized</code>。顺便说一下，<code class="fe mg mh mi mj b">synchronized</code>在Kotlin中，它是作为一个高阶函数来构建的。</p><p id="90c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于创建所谓的DSL(特定于领域的语言)——特定于领域的语言非常方便。Kotlin最流行的DSL<strong class="jp ir">有<strong class="jp ir"> Anko </strong> <em class="mf">(直接在Kotlin中的Android UI，同时保留了XML标记的便利)</em>、<strong class="jp ir">Gradle kot Lin DSL</strong><em class="mf">(kot Lin上的Gradle脚本)</em>、<strong class="jp ir">kotlinx.html</strong><em class="mf">(与Anko类似)</em>。</strong></p><p id="3bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，考虑一个Kotlin HTML页面:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f8a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将打印到标准输出:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种DSL的主要优点是，与声明式HTML不同，Kotlin具有可用于生成动态页面的变量。这比通过许多字符串的连接生成传统页面要漂亮和方便得多。实际上，其他方法也可以用来生成HTML标记，这只是Kotlin中DSL的一个例子。</p><p id="74b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用高阶函数的另一个例子类似于Java中的Streams API:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="cade" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">更复杂的lambdas</h1><p id="a418" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们看一些示例代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="938b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用语言标准库中更复杂的高阶函数，您可以将上面的代码变成以下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="185b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，方法<code class="fe mg mh mi mj b">apply()</code>允许你不用写几次<code class="fe mg mh mi mj b">builder.append()</code>，这要感谢下面的方法原型:</p><p id="dbe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T</code></p><p id="9f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，lambda函数<code class="fe mg mh mi mj b">block</code>是类型<code class="fe mg mh mi mj b">T</code>的扩展方法，在这里是<code class="fe mg mh mi mj b">StringBuilder</code>的扩展方法。lambda <code class="fe mg mh mi mj b">block</code>中的<code class="fe mg mh mi mj b">append()</code>是<code class="fe mg mh mi mj b">this.append()</code>，其中<code class="fe mg mh mi mj b">this</code>是类<code class="fe mg mh mi mj b">StringBuilder</code>的实例。</p><p id="a140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<code class="fe mg mh mi mj b">let()</code>以类似的方式工作，只接受稍微不同的lambda:</p><p id="e631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R</code></p><p id="4206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，对象引用不是作为一个质量<code class="fe mg mh mi mj b">this</code>传递的，而是作为一个显式的方法参数，但是我们没有指定它。在这种情况下，编译器会自动将lambda函数的第一个参数命名为“it”。</p><h1 id="706f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于未说出口的一点</h1><p id="ef09" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，与Java不同，Kotlin重载了操作符。例如，如果一个类有一个方法<code class="fe mg mh mi mj b">plus()</code>，那么它可以被一个操作符<code class="fe mg mh mi mj b">+</code>调用，而一个方法可以被一个操作符<code class="fe mg mh mi mj b">[]</code>调用<code class="fe mg mh mi mj b">get()</code>。</p><p id="1713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，Kotlin中的函数可以显式标记为<code class="fe mg mh mi mj b">inline</code>或<code class="fe mg mh mi mj b">noinline</code>。这个修饰符告诉编译器是否内联函数来提高性能。但是这里有一个问题:不同的行为<code class="fe mg mh mi mj b">return</code>在<code class="fe mg mh mi mj b">inline</code>和<code class="fe mg mh mi mj b">noinline</code>函数中。</p><p id="6a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mg mh mi mj b">inline</code>函数中，它<code class="fe mg mh mi mj b">return</code>将从范围内最近的<code class="fe mg mh mi mj b">noinline</code>函数中产生。b<code class="fe mg mh mi mj b">noinline</code>——来自函数本身。命名解决方案解决了这个问题<code class="fe mg mh mi mj b">return</code>。</p><p id="6b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使<code class="fe mg mh mi mj b">return</code>从我们在上面例子中传递的lambda到<code class="fe mg mh mi mj b">apply()</code>，你可以使用<code class="fe mg mh mi mj b">return@apply</code>。</p><p id="bd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命名不仅可以是<code class="fe mg mh mi mj b">return</code>，还可以是<code class="fe mg mh mi mj b">break</code>、<code class="fe mg mh mi mj b">continue</code>。您也可以创建自己的标签:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，还有一个函数修饰符<code class="fe mg mh mi mj b">tailrec</code>告诉编译器，如果函数是以返回if-then-else函数格式编写的，就用循环替换函数中的递归。示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="df5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三，如果一个方法需要一个对象作为参数，它必须用一个抽象方法从一个类/接口继承，那么一个lambda或一个匿名函数可以传递给这个函数，编译器本身将创建一个匿名类，用我们的lambda覆盖抽象方法。例如，Android标准库有一个方法<code class="fe mg mh mi mj b">public void setOnClickListener(View.OnClickListener l)</code>，其中<code class="fe mg mh mi mj b">OnClickListener</code>是一个具有单个方法<code class="fe mg mh mi mj b">onClick(View v)</code>的接口。</p><p id="19e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图<code class="fe mg mh mi mj b">setOnClickListener { doSomething() }</code>中传递的lambda将被编译成实现接口<code class="fe mg mh mi mj b">OnClickListener</code>的匿名类，其中我们的lambda将变成方法<code class="fe mg mh mi mj b">onClick(View v)</code>。</p><h1 id="ffd2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结果</h1><p id="6efd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这远不是Kotlin中所有的函数，只是最常用的。凭借其<strong class="jp ir">、【魔法】、</strong>功能，Kotlin让编写代码变得更加容易，最重要的是，让阅读代码变得更加容易。易于编写和安全性是Kotlin和Java之间的两个最重要的区别，早在<strong class="jp ir"> 1995年(！).</strong>那个时候，代码的便捷和安全是做梦都想不到的。</p><h1 id="b498" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">阅读更多</h1><p id="0f21" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><em class="mf">如果您觉得本文有帮助，请单击💚或者👏按钮或分享关于脸书的文章，这样你的朋友也可以从中受益。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv ml l"/></div></figure></div></div>    
</body>
</html>