<html>
<head>
<title>Explore API Priority and Fairness to Ease the Load of the APIServer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索 API 优先级和公平性，以减轻 APIServer 的负载</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/explore-api-priority-and-fairness-to-ease-the-load-of-the-apiserver-a4fe9c4e7174?source=collection_archive---------4-----------------------#2022-06-22">https://blog.devgenius.io/explore-api-priority-and-fairness-to-ease-the-load-of-the-apiserver-a4fe9c4e7174?source=collection_archive---------4-----------------------#2022-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f271" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 APF 完成事故补救</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36418a40c5c5c95404933d131c78a379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uUki5S2AL9TamT_Q"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自 Unsplash，<a class="ae kv" href="https://unsplash.com/photos/_8rjlHwN4uk" rel="noopener ugc nofollow" target="_blank"> @aaroncwu </a></figcaption></figure><p id="3e21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes 用它的特性大大减轻了我们处理成千上万个节点的服务的负担，其中一个特性是它可以自动将资源从故障恢复到最终的一致性，也就是说，在一些 Pods 或其他资源暂时不可用的场景下，Kubernetes 支持它们保持协调，直到它们最终恢复正常。</p><p id="7de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于 Kubernetes 的<a class="ae kv" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">控制器机制</a>不断与 APIServer 和<code class="fe ls lt lu lv b">etcd</code>交互，运维压力得到缓解。然而，如果使用不当，它会将集群推向“悬崖”,例如通过不断地列出/查询资源来拖垮 APIServer，最终引发一场<a class="ae kv" href="https://en.wikipedia.org/wiki/Thundering_herd_problem" rel="noopener ugc nofollow" target="_blank">雷鸣般的群体</a>风暴。</p><p id="0572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一个 APIServer 错误请求监控感受一下“悬崖”:APIServer 在某一点上不堪重负，对大量请求返回 5xx，4xx。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/4c8411a04f384bb8283e4db496f525ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GY1ZzOt8VdXa_mV0"/></div></div></figure><p id="a87d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是什么引发了这一事件？</p><p id="0f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根是命名空间范围的运算符的升级。集群中有 5000 多个名称空间，每个名称空间都有一个对应的 Pod，因此运营商的升级会重启所有 Pod 并触发不间断的协调，发出大量的<code class="fe ls lt lu lv b">List</code>请求，最终重创 APIServer。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/3f446e4d05549a8629cd87ceb157ad20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J9CYvAWFkPyygihT"/></div></div></figure><h1 id="9a82" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">Kubernetes 限速解决方案</h1><p id="7c92" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">为了避免这样的突发事件，Kubernetes 提供了一些保证 APIServer 可用性的方法，即<strong class="ky ir">限速</strong>。</p><ul class=""><li id="dda8" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><a class="ae kv" href="https://pkg.go.dev/k8s.io/kubernetes/pkg/apiserver#MaxInFlightLimit" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">maxinfolightlimit</strong></a>。通过设置并发请求的最大值来限制 APIServer 的整体流量:在启动 APIServer 时设置<code class="fe ls lt lu lv b">--max-requests-inflight</code>和<code class="fe ls lt lu lv b">--max-mutating-requests-inflight</code>标志。</li><li id="48a5" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><a class="ae kv" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#eventratelimit" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">EventRateLimit</strong></a>，只限制事件。在<a class="ae kv" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#eventratelimit" rel="noopener ugc nofollow" target="_blank"> 1.13 </a>中引入，应用 webhook 来限制用户、命名空间等事件操作。</li></ul><pre class="kg kh ki kj gt nj lv nk nl aw nm bi"><span id="22f0" class="nn lz iq lv b gy no np l nq nr"><strong class="lv ir">apiVersion</strong>: eventratelimit.admission.k8s.io/v1alpha1<br/><strong class="lv ir">kind</strong>: Configuration<br/><strong class="lv ir">limits</strong>:<br/>- <strong class="lv ir">type</strong>: Namespace<br/>  <strong class="lv ir">qps</strong>: 50<br/>  <strong class="lv ir">burst</strong>: 100<br/>  <strong class="lv ir">cacheSize</strong>: 2000<br/>- <strong class="lv ir">type</strong>: User<br/>  <strong class="lv ir">qps</strong>: 10<br/>  <strong class="lv ir">burst</strong>: 50</span></pre><ul class=""><li id="2ad6" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><strong class="ky ir">客户费率控制。</strong>客户端，限制速率。例如，默认的 client-go <a class="ae kv" href="https://github.com/kubernetes/client-go/blob/acab036eff5706db06b4eb79253165cf4be0d9c5/util/workqueue/default_rate_limiters.go#L43" rel="noopener ugc nofollow" target="_blank">速率限制</a>是 10 qps 和 100 桶大小。当然，服务器不能受到影响，如果集群中有 100 多个 client-go 工具，这将会失去控制。</li><li id="4ab3" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> API 优先级和公平性</strong> </a> <strong class="ky ir"> </strong> (APF)，支持更细粒度的流量控制。是 1.18 新增的，是<strong class="ky ir">maxinfolightlimit</strong>的升级版。</li></ul><h1 id="4818" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">耐酸地板（acid proof floor 的缩写）</h1><p id="910b" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">APF 弥补了<code class="fe ls lt lu lv b">MaxInFlightLimit</code>的不足，它可能会触发速率限制，并因为单个控制器错误而削弱整个集群的能力。</p><p id="ea67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建议书<a class="ae kv" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness" rel="noopener ugc nofollow" target="_blank">KEP-1040:API 服务器请求的优先级和公平性</a>详细介绍了 APF 的优势，可以概括为三点。</p><ul class=""><li id="56d0" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">支持更细粒度的限速和隔离。</li><li id="c3a7" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">支持公平队列分发，避免一个操作符拖垮整个 APIServer。</li><li id="cd35" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">支持设置队列容量，提高 APIServer 应对突发流量的能力。</li></ul><h2 id="c30c" class="nn lz iq bd ma ns nt dn me nu nv dp mi lf nw nx mk lj ny nz mm ln oa ob mo oc bi translated">有源电力滤波器原理</h2><p id="2da2" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">APF 主要通过<code class="fe ls lt lu lv b">FlowSchema</code>和<code class="fe ls lt lu lv b">PriorityLevelConfiguration</code>两种资源进行配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/d911b97df0644352d689b15ac82bef76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RrxDm2olpg40M25u"/></div></div></figure><ul class=""><li id="2d8f" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.w3cub.com/kubernetes/reference/kubernetes-api/cluster-resources/flow-schema-v1beta2/index" rel="noopener ugc nofollow" target="_blank">FlowSchema</a></code> (FS)代表每个请求分类组，一个 FS 可以包含多个流。</li><li id="e2d0" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.w3cub.com/kubernetes/reference/kubernetes-api/cluster-resources/priority-level-configuration-v1beta2/index" rel="noopener ugc nofollow" target="_blank">Priority Level</a></code>意为请求的轻重缓急不同。不同优先级的资源被隔离以避免相互竞争。并且可以首先处理特定(高)优先级的请求。</li><li id="b897" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">一个优先级可以映射到多个流模式。优先级有一个<code class="fe ls lt lu lv b">QueueSet</code>来缓存不能及时处理的请求。通过这种方式，请求不会因为超过 PL 并发限制而被丢弃，队列中的请求将根据 Shuffle-sharing 算法进行分配。</li></ul><p id="a3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">shuffle-sharing 是一种非常强大的分配算法，在<a class="ae kv" href="https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/" rel="noopener ugc nofollow" target="_blank"> AWS </a>中也被广泛使用。回顾上面提到的事件，你会发现如果我们使用 APF 进行隔离，升级后的操作员(rainbow)的请求只会影响 25%的 APIServer 性能，其他大部分资源仍然可以正常工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/0dd401585b11ced040192f5551b9de6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L6y-FmEnuwWB4yBs"/></div></div></figure><h2 id="0524" class="nn lz iq bd ma ns nt dn me nu nv dp mi lf nw nx mk lj ny nz mm ln oa ob mo oc bi translated">使用 APF</h2><p id="e417" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">在 GKE，APF 默认启用。而对于自己安装的 APIServer，可以通过下面的标志来启用它。</p><pre class="kg kh ki kj gt nj lv nk nl aw nm bi"><span id="27b3" class="nn lz iq lv b gy no np l nq nr">--feature-gates=APIPriorityAndFairness=true <br/>--runtime-config=flowcontrol.apiserver.k8s.io/v1alpha1=true</span></pre><p id="38e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GKE 已经添加了许多默认的<code class="fe ls lt lu lv b">FlowSchema</code>和<code class="fe ls lt lu lv b">PriorityLevelConfiguration</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/83bd36c79f804005ef91febe9e3356e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zU1lLf2N7VHYfM9J"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/7e82c35c253e234038f49041d734633a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y5AZsE5PNem2cQDo"/></div></div></figure><p id="1d0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过研究现有的默认配置，我们可以找到问题的解决方案。以下配置包含在<code class="fe ls lt lu lv b">kube-scheduler</code>的<code class="fe ls lt lu lv b">FlowSchema</code>和相应的<code class="fe ls lt lu lv b">PriorityLevelConfiguration.</code>中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="78c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来解释一下这条规则:</p><p id="936a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于集群中的<code class="fe ls lt lu lv b">kube-scheduler</code>名称空间中的<code class="fe ls lt lu lv b">system:kube-scheduler</code>用户发起的所有请求(资源或非资源),最多可以并行发送 40 个，超过的请求将被放入队列中。队列数量为 128，每个队列的大小为 6 * 50( <code class="fe ls lt lu lv b">handsize * queueLen</code>)。</p><p id="ca9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回顾上面的事件并检查默认的<code class="fe ls lt lu lv b">FlowSchema</code>。可以看出，运营商发起的请求没有被归类到任何<code class="fe ls lt lu lv b">FlowSchema</code>中，也没有被放入任何队列中，因此它们没有从 APIServer 获得保护。</p><p id="2986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们似乎找到了出路。添加一个合理的<code class="fe ls lt lu lv b">FlowSchema</code>，并将其连接到一个<code class="fe ls lt lu lv b">PriorityLevelConfiguration</code>或创建一个新的。</p><p id="0b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于所有请求都来自 operator 名称空间下的 pod，并且每个 pod 都由相应的 SA 运行，因此配置非常简单:</p><p id="9da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">将</em> <code class="fe ls lt lu lv b"><em class="oj">FlowSchema</em></code> <em class="oj">匹配到该名称空间下的所有服务协议，包含所有请求，默认使用全局默认</em> <code class="fe ls lt lu lv b"><em class="oj">PriorityLevelConfiguration</em></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很高兴看到我们的集群恢复工作，并且能够影响其他用户的请求。此外，运营商的未来升级仍然会导致一定数量的失败请求，尽管它们都在并发限制内，不会对 APIServer 的能力造成损害。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/4db5949f0b96a22ebe0cd75a5ca6d7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Htoo2H37erLfzkv4"/></div></div></figure><p id="bd26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过在 grafana 中设置相关指标来监控 APF，从而完成事件补救。</p><ul class=""><li id="80f7" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">piserver_flowcontrol_rejected_requests_total</code>，APF 拒绝的请求数。</li><li id="0090" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_dispatched_requests_total</code>，已经处理的请求数。</li><li id="f44b" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_current_inqueue_requests</code>，队列中待处理请求的数量。</li><li id="0236" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_current_executing_requests</code>，处理中的请求数。</li><li id="2877" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_request_queue_length_after_enqueue</code>，实时队列中的请求数。</li><li id="32c1" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_request_concurrency_limit</code>，每个 plc 的并行限制。</li><li id="3605" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_request_wait_duration_seconds</code>，请求处理排队所需时间，请求处理失败次数。</li><li id="36f4" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">apiserver_flowcontrol_request_execution_seconds</code>，请求执行时间。</li></ul><h2 id="6645" class="nn lz iq bd ma ns nt dn me nu nv dp mi lf nw nx mk lj ny nz mm ln oa ob mo oc bi translated">APF 源</h2><p id="45e0" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">阅读源代码总能帮助您理解实现，所以让 Kubernetes 的源代码告诉您 APF 是如何实现的。</p><p id="cba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，像<code class="fe ls lt lu lv b">FlowSchema</code>这样的资源定义都在这个<a class="ae kv" href="https://github.com/kubernetes/kubernetes/tree/9c147baa70c31afc966329df73302e9b52d8e432/staging/src/k8s.io/client-go/applyconfigurations/flowcontrol" rel="noopener ugc nofollow" target="_blank">流控包</a>下，其中 f <a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/9c147baa70c31afc966329df73302e9b52d8e432/staging/src/k8s.io/client-go/applyconfigurations/flowcontrol/v1beta2/flowschema.go#L41%5C" rel="noopener ugc nofollow" target="_blank"> lowschema.go </a>，f <a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/9c147baa70c31afc966329df73302e9b52d8e432/staging/src/k8s.io/client-go/applyconfigurations/flowcontrol/v1beta2/flowschemaspec.go#L32" rel="noopener ugc nofollow" target="_blank"> lowschemaspec.go </a>，<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/9c147baa70c31afc966329df73302e9b52d8e432/staging/src/k8s.io/client-go/applyconfigurations/flowcontrol/v1beta2/flowschemastatus.go#L29" rel="noopener ugc nofollow" target="_blank"> flowschemastatus.go </a>，<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/9c147baa70c31afc966329df73302e9b52d8e432/staging/src/k8s.io/client-go/applyconfigurations/flowcontrol/v1beta2/flowschemacondition.go#L38" rel="noopener ugc nofollow" target="_blank"> flowschemacondition.go </a>是针对<code class="fe ls lt lu lv b">FlowSchema</code>的。整个<code class="fe ls lt lu lv b">FlowSchema</code>是使用各种<code class="fe ls lt lu lv b">Withxxx</code> ( <a class="ae kv" href="https://medium.com/codex/builder-pattern-in-go-15b400fd4b1e" rel="noopener">构建器模式</a>)方法创建的。</p><p id="a6d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后是同样处于控制器模式的整个 APF 操作。在<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/2b14fd9fb133a28cf7295986b93d350af77695c5/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/apf_controller.go#L311" rel="noopener ugc nofollow" target="_blank"> apf_controller.go </a>中，这个控制器非常巨大，我们来咬一口。</p><p id="b5b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/2b14fd9fb133a28cf7295986b93d350af77695c5/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/apf_controller.go#L803" rel="noopener ugc nofollow" target="_blank">startRequest</a></code>函数将<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/2b14fd9fb133a28cf7295986b93d350af77695c5/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/apf_controller.go#L812" rel="noopener ugc nofollow" target="_blank">匹配</a>当前请求，试图找到相关的<code class="fe ls lt lu lv b">FlowSchema</code>，仅在<code class="fe ls lt lu lv b">numQueues &gt; 1</code>时用公平算法分配<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/2b14fd9fb133a28cf7295986b93d350af77695c5/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/apf_controller.go#L848" rel="noopener ugc nofollow" target="_blank">computeFlowDistinguisher</a></code>，最后调用<code class="fe ls lt lu lv b">QueueSet</code>中的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/2b14fd9fb133a28cf7295986b93d350af77695c5/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/apf_controller.go#L857" rel="noopener ugc nofollow" target="_blank">startRequest</a></code>。有详细的注释解释了请求的调度，值得深入挖掘。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/3b1d48860dbc2283f0b64018c3f2743f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RQKrtS4SEt01Y7s6"/></div></div></figure><p id="c0c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个流量控制包中有如此多有趣的实现，我们需要一篇单独的文章来进行深入的讨论。</p><h1 id="3112" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">包裹</h1><p id="121f" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">如果不是这次事件，我永远不会感受到 APF 的强大。这无疑缓解了我们对蜜蜂服务器雷群问题的担忧。这也引发了新的思考:如果我们想在未来增加新的运营商，我们是否也应该评估 APF 限制？为了减少潜在问题，我们是否应该将此视为不同运营商访问集群的要求？当然，还可以期待更多的特性，比如更好地支持文档中提到的<a class="ae kv" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness#support-for-list-requests" rel="noopener ugc nofollow" target="_blank">列表</a>和<a class="ae kv" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness#support-for-watch-requests" rel="noopener ugc nofollow" target="_blank">观察</a>。</p><p id="412b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不是这次事件，我可能已经忘记了 Kubernetes 生态系统是如此庞大，有许多未知的功能和新功能等待着被发现和利用，所以永远不要停止研究。</p><p id="3d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><h1 id="dea6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">参考</h1><p id="7dba" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/enhancements/tree/master/keps/SIG-API-machinery/1040-priority-and-fairness</a></p><p id="9d7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/cluster-administration/flow-control/</a></p><p id="c0fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://www.youtube.com/watch?v=Tps4eAjuCr8 T4】</p><p id="af76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/cluster-administration/_print/#observability" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/cluster-administration/_ print/# observability</a></p></div></div>    
</body>
</html>