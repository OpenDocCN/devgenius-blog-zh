<html>
<head>
<title>Testing abstract classes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Java 中测试抽象类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/testing-abstract-classes-in-java-2989f12e9d5f?source=collection_archive---------1-----------------------#2020-07-30">https://blog.devgenius.io/testing-abstract-classes-in-java-2989f12e9d5f?source=collection_archive---------1-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78657dd7532ae9749e89f54a615ce5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z-TzM6blI5RtP2SA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">教皇莫伊苏在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 JUnit，您可以为 Java 项目中的任何源类编写测试类。即使是抽象类，如你所知，它们不能被实例化，但是为了“具体”子类的利益，它们可以有构造函数。</p><p id="5d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，测试类不必像被测试的相应类那样抽象，也不应该如此。</p><p id="c3d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们是否应该在项目中测试抽象类，或者是否使用抽象类，这是一个取决于特定项目和团队偏好的问题，但希望不是任何教条。</p><p id="4ff5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我能想到一些情况，在这些情况下，源文件夹中的抽象类在测试文件夹中有一个对应的测试类可能是一个好主意。具体来说:</p><ul class=""><li id="5cfa" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">当抽象类打算在它的包之外使用时，或者在 Java 9 和更高版本中，在它的模块之外使用时。</li><li id="cd5f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当抽象类有静态单元时，无需实例化任何子类就可以调用静态单元。</li><li id="d09d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当抽象类知道它的子类，并且能够管理它们之间的转换时。</li><li id="86fe" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当你想绝对确定你的项目有 100%的测试覆盖率时。</li></ul><p id="46bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很高兴知道如果你需要的话，选项是可用的。但是，根据您为 Java 使用的集成开发环境(IDE ),您可能需要注意一些问题。</p><p id="e864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个抽象类的例子。邮政编码，比如邮政编码，就是一个很好的例子，我在之前的文章中解释过。我还解释了如何在 Eclipse 中测试一个抽象类。</p><p id="7e85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将重点介绍另外两个主要的 Java IDEs，NetBeans 和 IntelliJ IDEA(通常称为“IntelliJ”)。</p><h1 id="ec53" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在 NetBeans 中测试抽象类</h1><p id="cb89" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">NetBeans 的当前版本是 12.0。我还在 11.2，还没升级。我提到这一点只是为了防止 12.0 中抽象类的测试有任何不同。</p><p id="9c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从你们那些关注 Eclipse 的人开始的第一份<code class="fe ms mt mu mv b">PostalCode</code>草案开始，但是添加了几个覆盖存根。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c8dc" class="ne lq iq mv b gy nf ng l nh ni">package postal;</span><span id="a15e" class="ne lq iq mv b gy nj ng l nh ni">import java.util.Locale;</span><span id="8264" class="ne lq iq mv b gy nj ng l nh ni">public abstract class PostalCode {<br/>    <br/>    protected final long postalCodeNumber;<br/>    <br/>    protected final Locale postalGov;</span><span id="2036" class="ne lq iq mv b gy nj ng l nh ni">    // TODO: Write tests for this<br/>    @Override<br/>    public boolean equals(Object obj) {<br/>        return false;<br/>    }</span><span id="c98c" class="ne lq iq mv b gy nj ng l nh ni">    // TODO: Write tests for this<br/>    @Override<br/>    public int hashCode() {<br/>        return 0;<br/>    }<br/><br/>    public Locale getCountry() {<br/>        return this.postalGov;<br/>    }<br/><br/>    public PostalCode(long number, Locale loc) {<br/>        this.postalCodeNumber = number;<br/>        this.postalGov = loc;<br/>    }<br/>    <br/>}</span></pre><p id="9210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是让我们为我们的第一稿<code class="fe ms mt mu mv b">ZIPCode</code>做一些比在 Eclipse 项目中更简单的事情:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="fd73" class="ne lq iq mv b gy nf ng l nh ni">package postal;<br/><br/>import java.util.Locale;</span><span id="6a5d" class="ne lq iq mv b gy nj ng l nh ni">public class ZIPCode {</span><span id="48ac" class="ne lq iq mv b gy nj ng l nh ni">public ZIPCode(int zip5) {<br/>        this(zip5, -1); // TODO: Write tests for this constructor<br/>    }</span><span id="274d" class="ne lq iq mv b gy nj ng l nh ni">public ZIPCode(int zip5, int zip4) {<br/>        // TODO: Write tests for this constructor<br/>    }</span><span id="bb37" class="ne lq iq mv b gy nj ng l nh ni">}</span></pre><p id="9dbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里要注意的主要事情是，我要求你省略“<code class="fe ms mt mu mv b">extends PostalCode</code>”。让我们为此编写一个测试:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="9b7f" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testSuperClass() {<br/>        <strong class="mv ir">Object zip</strong> = new ZIPCode(53703);<br/>        String msg <br/>           = "ZIPCode instance should also be PostalCode instance";<br/>        assert <strong class="mv ir">zip instanceof PostalCode</strong> : msg;<br/>    }</span></pre><p id="e7ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">把这个测试放到<code class="fe ms mt mu mv b">ZIPCodeTest</code>里。在 NetBeans 中，启动测试类最直接的方法是将光标放在类声明行上，然后单击代替行号的灯泡图标；然后选择“创建测试类[测试包中的 JUnit”。</p><p id="0d00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe ms mt mu mv b">zip</code>被声明为类型<code class="fe ms mt mu mv b">Object</code>而不是<code class="fe ms mt mu mv b">ZIPCode</code>。否则，NetBeans 会将其标记为错误，并阻止编译它。</p><p id="aa73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试当然失败了。因此，在<code class="fe ms mt mu mv b">ZIPCode</code>中添加“<code class="fe ms mt mu mv b">extends PostalCode</code>”，并添加需要编译的内容，但是要注意，它将无法通过我们将要编写的测试(比如将<code class="fe ms mt mu mv b">Locale</code>字段设置为其他<code class="fe ms mt mu mv b">Locale.US</code>)。</p><p id="bbb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如这个项目的 Eclipse 版本一样，NetBeans 的后续人员应该为构造函数编写测试(例如，辅助构造函数为 ZIP+4 填充“0000”)，并为<code class="fe ms mt mu mv b">toString()</code>编写测试(例如在适当的时候填充零)。</p><p id="aaaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，在这里，让我们在<code class="fe ms mt mu mv b">PostalCodeTest</code>而不是<code class="fe ms mt mu mv b">ZIPCodeTest</code>中编写<code class="fe ms mt mu mv b">equals()</code>的所有测试。正如您可以让 NetBeans 为“具体”类创建测试类一样，您也可以让 NetBeans 为类似于<code class="fe ms mt mu mv b">PostalCode</code>的抽象类创建测试类。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a82f3558069490647f1cbdb6f97024ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*p8uYlgwaUCkH4OmK7O60OQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在灯泡上单击鼠标右键后，选择第二个选项。</figcaption></figure><p id="5153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的测试类是根据普通 NetBeans 用户非常熟悉的非常有用的模板生成的。在生成的测试类的末尾有一个惊喜:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="bdb9" class="ne lq iq mv b gy nf ng l nh ni">    public class PostalCodeImpl extends PostalCode {</span><span id="a6d8" class="ne lq iq mv b gy nj ng l nh ni">        public PostalCodeImpl() {<br/>            super(0L, null);<br/>        }<br/>    <br/>    }</span></pre><p id="75cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个嵌套类。我了解嵌套类的时间几乎和我编写 Java 的时间一样长。我从来不认为它们特别有用。</p><p id="978c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，在这里，我认为嵌套类恰恰是最好的解决方案，因为我们很可能不需要<code class="fe ms mt mu mv b">PostalCodeTest</code>之外的<code class="fe ms mt mu mv b">PostalCodeImpl</code>。</p><p id="28d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[附录，2020 年 8 月 7 日:如果抽象类除了构造函数之外没有任何实例单元，NetBeans 可能不会在测试类中生成嵌套的静态类。至少在 NetBeans 11.2 中是这样的。当然，如果 NetBeans 不这样做，没有什么可以阻止我们编写这样的类。]</p><p id="c8f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代替愚蠢的 Zap 代码，我们可以使用<code class="fe ms mt mu mv b">PostalCodeImpl</code>实例对<code class="fe ms mt mu mv b">equals()</code>进行所有或者几乎所有的测试。我们只需要先对<code class="fe ms mt mu mv b">PostalCodeImpl</code>做一些小调整:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="94e5" class="ne lq iq mv b gy nf ng l nh ni">    public class PostalCodeImpl extends PostalCode {<br/>        <br/>        @Override<br/>        public String toString() {<br/>            return "ImplPostal " + this.postalCodeNumber;<br/>        }</span><span id="a9aa" class="ne lq iq mv b gy nj ng l nh ni">        public PostalCodeImpl(int code) {<br/>            super(code, Locale.US);<br/>        }<br/>        <br/>    }</span></pre><p id="174e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，用“取消引用空指针”警告注释掉<code class="fe ms mt mu mv b">PostalCodeTest</code>中的行，但保留“测试用例是原型”消息的行可能是个好主意。</p><p id="7d2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，参照相等测试。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="874b" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testReferentialEquality() {<br/>        PostalCode code = new PostalCodeImpl(482012005);<br/>        assertEquals(code, code);<br/>    }</span></pre><p id="5295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了节省你的输入，使用完成建议快捷键，Windows 上的 Ctrl-Space(我认为是 Mac OS X 上的 control-Space，而不是 Command-Space；不知道在 Linux 上是什么)。</p><p id="0e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键入“Post”，然后调用类型声明的快捷方式。在赋值操作符的右边，“new P”应该足以让快捷键调出“<code class="fe ms mt mu mv b">PostalCodeImpl</code>”作为第二个可能的补全，NetBeans 将建议 0 作为数字参数。</p><p id="03df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果你使用的是 Java 10 或更高版本，你可以利用<code class="fe ms mt mu mv b">var</code>来减少赋值操作符两边都有类型的繁琐。</p><p id="2c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试应该会失败。您知道如何让它通过:简单地让它返回<code class="fe ms mt mu mv b">this == obj</code>。继续进行不等于空测试:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3089" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testNotEqualsNull() {<br/>        PostalCode code = new PostalCodeImpl(21111307);<br/>        assertNotEquals(code, null);<br/>    }</span></pre><p id="6dd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与 Eclipse 项目一样，在 NetBeans 项目中，我们应该在为不同的运行时类编写测试之前，为不同的内存位置编写两个相同邮政编码的测试。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a57c" class="ne lq iq mv b gy nf ng l nh ni">    /**<br/>     * Test of equals method, of class PostalCode.<br/>     */<br/>    @Test<br/>    public void testEquals() {<br/>        System.out.println("equals");<br/>        PostalCode someCode = new PostalCodeImpl(480841564);<br/>        PostalCode sameCode = new PostalCodeImpl(480841564);<br/>        assertEquals(someCode, sameCode);<br/>    }</span></pre><p id="f5d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你知道如何通过这个测试，这样所有之前对<code class="fe ms mt mu mv b">equals()</code>的测试也能通过，但还没有真正检查<code class="fe ms mt mu mv b">this</code>或<code class="fe ms mt mu mv b">obj</code>的数字域。这意味着 NetBeans 应该仍然警告您<code class="fe ms mt mu mv b">equals()</code>仍然没有检查<code class="fe ms mt mu mv b">obj</code>的类型。</p><p id="fa85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们为不同的类编写一个:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d165" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testNotEqualsDiffClass() {<br/>        ZIPCode zip = new ZIPCode(90210, 4817);<br/>        PostalCode zap = new PostalCodeImpl(902104817);<br/>        assertNotEquals(zip, zap);<br/>    }</span></pre><p id="8979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许你不喜欢在<code class="fe ms mt mu mv b">PostalCodeTest</code>中使用<code class="fe ms mt mu mv b">ZIPCode</code>的想法。尤其是如果你还没有真正地在<code class="fe ms mt mu mv b">ZIPCode</code>上工作过。嗯，我们可以使用匿名类，就像这样:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="28f3" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testNotEqualsAnonClass() {<br/>        PostalCode zip = new PostalCodeImpl(200041477);<br/>        PostalCode zap = new PostalCode(200041477, Locale.US) {<br/>            <br/>            @Override<br/>            public String toString() {<br/>                return "AnonPostal" + this.postalCodeNumber;<br/>            }<br/>            <br/>        };<br/>        assertNotEquals(zip, zap);<br/>    }</span></pre><p id="1c57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您还为<code class="fe ms mt mu mv b">zap.getClass().getName()</code>输入一个打印行语句，您可能会看到“邮政。NetBeans“输出”窗格中的 PostalCodeTest $ 1"。</p><p id="9151" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe ms mt mu mv b">PostalCodeImpl</code>和匿名<code class="fe ms mt mu mv b">PostalCode</code>子类的测试都应该失败。两者的修复是相同的:检查引用的相等性，空值检查，以及运行时类与<code class="fe ms mt mu mv b">getClass()</code>的比较。</p><p id="600d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我认为唯一剩下的事情就是测试匹配的类，但是不同的邮政编码。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="24d4" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testNotEqualsDiffPostalCode() {<br/>        PostalCode someCode = new PostalCodeImpl(200041477);<br/>        PostalCode diffCode = new PostalCodeImpl(480841564);<br/>        assertNotEquals(someCode, diffCode);<br/>    }</span></pre><p id="da29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的<code class="fe ms mt mu mv b">equals()</code>应该是这样的:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="58d9" class="ne lq iq mv b gy nf ng l nh ni">@Override<br/>    public boolean equals(Object obj) {<br/>        if (this == obj) {<br/>            return true;<br/>        }<br/>        if (obj == null) {<br/>            return false;<br/>        }<br/>        if (!this.getClass().equals(obj.getClass())) {<br/>            return false;<br/>        }<br/>        return this.postalCodeNumber <br/>                             == ((PostalCode) obj).postalCodeNumber;<br/>    }</span></pre><p id="25a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的格式可能不同。</p><p id="16d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为实际上没有必要检查<code class="fe ms mt mu mv b">Locale</code>字段是否匹配。但是如果事实证明是这样，我们就为它写一个测试。</p><p id="cfa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们这样做的时候，我们可能希望将<code class="fe ms mt mu mv b">getCountry()</code>改为返回 null，这样我们就可以在<code class="fe ms mt mu mv b">PostalCodeTest</code>中为它编写一个测试，这个测试将在第一次运行时失败。当我第一次写<code class="fe ms mt mu mv b">PostalCode</code>的时候，我没有想过要测试这个。</p><h1 id="4d16" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在 IntelliJ IDEA 中测试抽象类</h1><p id="0430" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">对于 IntelliJ IDEA，我用的是 2019.3，社区版。它有局限性，但对我来说并不是问题。我依稀记得几个月前被给予了升级到 2020.1 的机会，但我不知道后来发生了什么。</p><p id="9387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冒着过分夸大字数的风险，但为了方便起见，我将重述第一稿<code class="fe ms mt mu mv b">PostalCode</code>，尽管有几处改动。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3a5a" class="ne lq iq mv b gy nf ng l nh ni">package postal;</span><span id="f656" class="ne lq iq mv b gy nj ng l nh ni">import java.util.Locale;</span><span id="28a6" class="ne lq iq mv b gy nj ng l nh ni">public abstract class PostalCode {</span><span id="10ba" class="ne lq iq mv b gy nj ng l nh ni">    protected final long postalCodeNumber;</span><span id="2364" class="ne lq iq mv b gy nj ng l nh ni">    protected final Locale postalGov;</span><span id="725a" class="ne lq iq mv b gy nj ng l nh ni">    // TODO: Write test for this<br/>    public Locale getCountry() {<br/>        return null;<br/>    }</span><span id="4680" class="ne lq iq mv b gy nj ng l nh ni">    // TODO: Write tests for this<br/>    @Override<br/>    public boolean equals(Object obj) {<br/>        return false;<br/>    }</span><span id="269a" class="ne lq iq mv b gy nj ng l nh ni">    // TODO: Write tests for this<br/>    @Override<br/>    public int hashCode() {<br/>        return 0;<br/>    }</span><span id="7e52" class="ne lq iq mv b gy nj ng l nh ni">    public PostalCode(long number, Locale loc) {<br/>        this.postalCodeNumber = number;<br/>        this.postalGov = loc;<br/>    }</span><span id="1b65" class="ne lq iq mv b gy nj ng l nh ni">}</span></pre><p id="27cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe ms mt mu mv b">ZIPCode</code>,使用我给 NetBeans 用户的第一份草稿，创建<code class="fe ms mt mu mv b">ZIPCodeTest</code>,并测试断言<code class="fe ms mt mu mv b">ZIPCode</code>实例也是<code class="fe ms mt mu mv b">PostalCode</code>的实例。</p><p id="7a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你从上面使用<code class="fe ms mt mu mv b">testSuperClass()</code>，IntelliJ 应该警告你<code class="fe ms mt mu mv b">zip instanceof PostalCode</code>总是假的。但还是迁就我一下，运行测试，然后修改<code class="fe ms mt mu mv b">ZIPCode</code>让它通过。</p><p id="d682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在 IntelliJ 应该警告你<code class="fe ms mt mu mv b">zip instanceof PostalCode</code>总是正确的。还要进行构造器测试和<code class="fe ms mt mu mv b">toString()</code>的测试。</p><p id="51be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在对<code class="fe ms mt mu mv b">PostalCodeTest</code>中的<code class="fe ms mt mu mv b">equals()</code>进行测试。IntelliJ 可以为抽象类启动测试类，就像为“具体”类一样。将光标置于<code class="fe ms mt mu mv b">PostalCode</code>源代码编辑器窗口，从顶层菜单中选择代码&gt;生成…,然后从生成弹出菜单中选择测试…。</p><p id="b809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与 Eclipse 一样，与 NetBeans 不同，IntelliJ 不在<code class="fe ms mt mu mv b">PostalCodeTest</code>中创建嵌套类。如果我们愿意，可能有一个模板可以定制。但是没有什么可以阻止我们通过键入来添加嵌套类。</p><p id="3873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，对于 IntelliJ，让我们使用英国邮政编码，而不是邮政编码。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="2481" class="ne lq iq mv b gy nf ng l nh ni">    private class PostalCodeImpl extends PostalCode {</span><span id="68ab" class="ne lq iq mv b gy nj ng l nh ni">        private final String postCode;</span><span id="01f6" class="ne lq iq mv b gy nj ng l nh ni">        @Override<br/>        public String toString() {<br/>            return this.postCode;<br/>        }</span><span id="cff8" class="ne lq iq mv b gy nj ng l nh ni">        PostalCodeImpl(String code) {<br/>            super(Long.parseLong(code.replace(" ", ""), 36),<br/>                                                         Locale.UK);<br/>            this.postCode = code.toUpperCase(Locale.UK);<br/>        }<br/>        <br/>    }</span></pre><p id="9a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果我们这样做是为了实际的生产使用，而不是为了测试目的，我们将不得不编写大量的测试来要求验证。</p><p id="d570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我没有质疑 NetBeans 为什么把<code class="fe ms mt mu mv b">PostalCodeImpl</code>公之于众。但是也许这没关系，因为<code class="fe ms mt mu mv b">PostalCodeImpl</code>不能从源码包中使用。因为我是用 IntelliJ 写的，所以出于习惯，我把它设为私有。如果我们需要将它更改为包私有或公共，我们会更改它。</p><p id="5e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想 IntelliJ 可能会告诉我们<code class="fe ms mt mu mv b">PostalCodeImpl</code>可以是私有的。然而，IntelliJ 告诉我<code class="fe ms mt mu mv b">PostalCodeImpl</code>可以是静态的，所以我说让它成为静态的。IDE 似乎并不关心访问修饰符。</p><p id="a78e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信我很久以前就了解了嵌套类，包括“静态”和“内部”类的区别。但是因为我没有在我写的程序中使用它们，我忘记了，所以我需要刷新我的记忆。</p><p id="37ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套的静态类是用<code class="fe ms mt mu mv b">static</code>关键字声明的，并且不能访问封闭类的字段(在<code class="fe ms mt mu mv b">PostalCodeImpl</code>的情况下，就是<code class="fe ms mt mu mv b">PostalCodeTest</code>)。就好像它是在自己的文件中自己声明的一样。</p><p id="ca09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个嵌套的内部类是在没有<code class="fe ms mt mu mv b">static</code>关键字的情况下声明的，它可以访问封闭类的字段。你有时会在 JDK 中看到这种情况，比如<code class="fe ms mt mu mv b">JTable</code>的<code class="fe ms mt mu mv b">AccessibleJTable</code>内部类(它也有几个静态嵌套类)。</p><p id="422e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们这里的目的，<code class="fe ms mt mu mv b">PostalCodeImpl</code>不需要从<code class="fe ms mt mu mv b">PostalCodeTest</code>访问任何字段。在测试类中嵌套<code class="fe ms mt mu mv b">PostalCode</code>实现对我们来说非常方便。</p><p id="04c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一种方法可以编写引用相等测试:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5a39" class="ne lq iq mv b gy nf ng l nh ni">    @Test<br/>    public void testReferentialEquality() {<br/>        PostalCode code = new PostalCodeImpl("NW1 6XE");<br/>        assertEquals(code, code);<br/>    }</span></pre><p id="29f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有人告诉我，这是伦敦贝克街 221B 号的邮政编码，现在是一个真实的地址，尽管不是某个世界闻名的侦探居住过的地址。</p><p id="f934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以使用的另一个英国邮政编码是 SW1A 1AA，代表白金汉宫。圣诞老人有他自己的加拿大邮政编码，H0H 0H0。我不知道英格兰和加拿大是不是同一个岗位体系，但是，在<code class="fe ms mt mu mv b">PostalCodeTest</code>和<code class="fe ms mt mu mv b">PostalCodeImpl</code>的背景下，无所谓。</p><p id="2064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要把它留在这里。一旦用<code class="fe ms mt mu mv b">PostalCodeTest</code>到<code class="fe ms mt mu mv b">PostalCodeImpl</code>彻底测试了<code class="fe ms mt mu mv b">equals()</code>，可能就没有必要在子类中测试<code class="fe ms mt mu mv b">equals()</code>，除非这些子类中有一个对<code class="fe ms mt mu mv b">equals()</code>有特殊要求，因此需要自己的<code class="fe ms mt mu mv b">equals()</code>覆盖。</p><p id="9208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果是这样的话，那么我不得不质疑这个子类是否真的应该从<code class="fe ms mt mu mv b">PostalCode</code>派生出来，或者<code class="fe ms mt mu mv b">PostalCode</code>是否缺少一些关键的属性，它应该是一个好的超类。</p><h1 id="3025" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">概括起来</h1><p id="2711" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">虽然通常认为没有必要为抽象类编写测试类，但是这个选项是可用的。它有助于增加测试覆盖率，同时有助于避免重复测试。</p><p id="f12e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在三种主要的 IDE 中都没有问题，并且让 IDE 生成这样的测试类的过程与让它为“具体的”类生成测试类的过程没有什么不同。</p></div></div>    
</body>
</html>