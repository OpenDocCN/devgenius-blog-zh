<html>
<head>
<title>7 Famous Approaches to Generate Distributed ID with Comparison Table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用比较表生成分布式 ID 的 7 种著名方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-famous-approaches-to-generate-distributed-id-with-comparison-table-af89afe4601f?source=collection_archive---------0-----------------------#2022-02-12">https://blog.devgenius.io/7-famous-approaches-to-generate-distributed-id-with-comparison-table-af89afe4601f?source=collection_archive---------0-----------------------#2022-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">如今，许多小型和大型系统都需要唯一的全局标识符；随着互联网使用的增长和对不同应用程序的高度依赖，这是分布式计算中的一项基本任务。</p><p id="66fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在直接跳到分布式 ID 生成方法之前，让我们首先了解传统的或当前的方法或非分布式方法:</p><h1 id="62c1" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">传统方法(非分布式系统)</h1><p id="9bcf" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">方法 1:ID 生成器使用一个共享计数器，该计数器在每次调用时都会增加。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/4c644527a4c05302f57b138f97947c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_Bvyyny3CLItedIYOLwqw.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">传统方法</figcaption></figure><p id="e1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以上述方法是可行的。甚至在今天，大多数应用程序仍在使用这种方法。</p><p id="1cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法 2，另一个本地解决方案是生成一个 ID 作为时间戳函数。但是这些都是不好的解决方案，因为存在以下问题。</p><ul class=""><li id="1e1f" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">多个独立的服务器可以生成相同的 ID。</li><li id="967c" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">相同的 ID 会为两个连续的请求生成。</li></ul><h2 id="e20d" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated"><strong class="ak">那么为什么我们需要一个复杂的系统来生成记录/行 ID 呢？</strong></h2><p id="b6c2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在复杂的分布式系统中，经常需要唯一地标识许多数据和消息。例如，在金融、支付、餐饮、酒店、猫眼电影以及其他产品中，数据与日俱增。将数据插入数据库和表后，需要一个惟一的 ID 来标识数据或消息。此时，能够生成全球唯一 id 的系统至关重要。此外，系统应该处理高并发请求/秒(HCRPS ),或者为每个新资源快速创建标识符。</p><h2 id="3440" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">应用程序</h2><p id="2a4f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">下面是一些需要分布式 ID 生成策略的应用程序:</p><ul class=""><li id="aea1" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">统计信息收集器</li><li id="5be6" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">聊天/信息</li><li id="1729" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">高赞/评论</li><li id="6789" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">状态更新/推文</li></ul><p id="a1e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们深入探讨基于不同需求的可用方法的数量。分布式 ID 生成器必须满足以下要求。</p><h2 id="cecf" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">功能需求</h2><ul class=""><li id="4c42" class="mn mo iq jp b jq ls ju lt jy nn kc no kg np kk ms mt mu mv bi translated">它们不可能有多长。让我们假设它的大小是 64 位。</li><li id="c876" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">在整个集群中顺序生成唯一的 id。</li><li id="d266" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">每秒生成超过 10，000 个唯一 id。</li></ul><h2 id="6719" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">非功能性需求</h2><ul class=""><li id="bfc5" class="mn mo iq jp b jq ls ju lt jy nn kc no kg np kk ms mt mu mv bi translated">高性能</li><li id="3df6" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">低延迟，包括地理延迟</li><li id="2245" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">高可用性</li><li id="9815" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">容错的</li><li id="5979" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">易于扩展</li></ul><h1 id="b2fe" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">方法:</h1><p id="212c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">以下是不同方法之间的总体比较表:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/4335a4e161fbefe3a4004ceb0b42b5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5LdL1IXwFmDvZUbTMT9uA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">不同方法之间的比较表</figcaption></figure><h2 id="4942" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">1.UUID / GUID</h2><p id="858d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">GUID 是代表<em class="nr">全球唯一标识符的首字母缩写；</em>它们被称为 UUIDs 或<em class="nr">通用唯一标识符。</em>这是一个多年来在软件领域广为人知的概念。UUIDs 是 128 位十六进制数；32 个十六进制字符，加上四个破折号，只是为了可读性更友好的版本，并且是全球唯一的。形式为 8–4–4–4–12，共 36 个字符。它非常容易使用</p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="c6b9" class="nb kv iq nt b gy nx ny l nz oa">public static void main(String[] args) {<br/>  String UUID = UUID.randomUUID().toString().replaceAll("-","");<br/>  System.out.println(UUID);<br/>}</span></pre><p id="eb65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UUIDs 有四个版本。</p><ul class=""><li id="84db" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">UUID1 使用 MAC 地址和时间戳来生成有效的唯一性。</li><li id="9726" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">UUID3 和 UUID 5 使用加密哈希和应用程序提供的文本字符串来生成 UUID。(<em class="nr"> UUID 3 使用 MD5 哈希，UUID 5 使用 SHA-1 哈希</em>)。</li><li id="275e" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">UUID4 使用伪随机数生成器来生成 UUID。</li></ul><h2 id="7581" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">2.MySQL:集中自动增量/著名的“Flickr 票务服务”方法</h2><p id="b21e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">如果我们不能让 MySQL 自动增量跨多个数据库工作，那么就建立一个只有一个表和一个记录的专用数据库，它的唯一目的是提供惟一的增量 ID。MySQL 的<a class="ae ob" href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" rel="noopener ugc nofollow" target="_blank"> Replace Into </a>语句可以帮助高效地实现这一点。</p><p id="e4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nr"> REPLACE 的工作方式与 INSERT 完全相同，只是如果表中的旧行与主键或唯一索引的新行具有相同的值，则在插入新行之前会删除旧行。</em></p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="18b9" class="nb kv iq nt b gy nx ny l nz oa">CREATE TABLE `ID` (<br/>  `id` bigint(20) unsigned NOT NULL auto_increment,<br/>  `stub` char(1) NOT NULL default '',<br/>  PRIMARY KEY  (`id`),<br/>  UNIQUE KEY `stub` (`stub`)<br/>) ENGINE=MyISAM</span></pre><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我需要一个新的全局唯一的 64 位 ID 时，我发出以下 SQL:</p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="f3ae" class="nb kv iq nt b gy nx ny l nz oa">REPLACE INTO ID (stub) VALUES ('a');<br/>SELECT LAST_INSERT_ID();</span></pre><h2 id="61c2" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">3.MySQL:集群模式</h2><p id="5d76" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">正如在传统的 MySQL AUTO_INCREMENT 方法中提到的，单点数据库模式是不可取的。为了改进上述集中模式，我们需要对高可用性进行一些更改，例如应该替换主从集群模式。如果怕一个主节点挂掉，可以考虑双主模式集群；也就是说，两个 MySQL 实例可以分别产生自增长的 id。但是具有不同的初始值和步长。</p><p id="d6b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解</strong>:设置起始值和自增步长<br/> <strong class="jp ir"> MySQL_ 1 配置:</strong></p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="e745" class="nb kv iq nt b gy nx ny l nz oa">set @@auto_ increment_ Offset = 1; -- starting value<br/>set @@auto_ increment_ Increment = 2; -- step size</span></pre><p id="9d36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MySQL_ 2 配置:</strong></p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="c214" class="nb kv iq nt b gy nx ny l nz oa">set @@auto_ increment_ Offset = 2; -- starting value<br/>set @@auto_ increment_ Increment = 2; -- step size</span></pre><p id="3c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">两个 MySQL 实例的自增量 id 如下:</strong></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oc"><img src="../Images/977a3a4734539de605d940cd4be8fbe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVq28dY4uvGaaHxt6xZIBQ.png"/></div></div></figure><p id="7a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，您可以根据需要拥有任意多的机器，这些机器具有不同的步长和 ID 的初始位置。您甚至可以将同样的策略扩展到地理级别；每个位置将有不同的起始值和步长。</p><h2 id="8964" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">4.MongoDB</h2><p id="78ad" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">MongoDB 使用 ObjectIds 作为每个文档的<code class="fe od oe of nt b">_id</code>字段的默认值，它是在创建任何文档时生成的。<a class="ae ob" href="https://www.mongodb.com/blog/post/generating-globally-unique-identifiers-for-use-with-mongodb" rel="noopener ugc nofollow" target="_blank">更多详情</a> <br/> ObjectID 是一个 96 位的数字，组成如下:</p><ul class=""><li id="4424" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">一个 4 字节的<em class="nr">时间戳值</em>，表示自 Unix 纪元以来的秒数(直到 2106 年才会用完秒数)</li><li id="aeff" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">一个 5 字节的<em class="nr">随机值</em>，以及</li><li id="c5e6" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">一个 3 字节的递增计数器，从一个随机值开始。</li></ul><p id="e98a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">For e.g. <a class="ae ob" href="https://docs.mongodb.com/manual/reference/method/ObjectId.getTimestamp/#mongodb-method-ObjectId.getTimestamp" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nr">507c7f79bcf86cd7994f6c0e</em></strong></a> has ISO time value of <strong class="jp ir">2012–10–15T21:26:17Z</strong></p><h2 id="515e" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">5. Twitter Snowflake</h2><p id="51c4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">There’s a famous ID generator called Snowflakes created by Twitter. Twitter snowflake is a dedicated service for generating 64-bit unique identifiers used in distributed computing for objects within Twitter such as Tweets, Direct Messages, Lists, etc.<br/>These IDs are unique 64-bit unsigned integers, which are based on time. The full IDs are made up of the following components:</p><ul class=""><li id="7507" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">Epoch timestamp in a millisecond — 41 bits (gives us 69 years for any custom epoch)</li><li id="a3f4" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">Configured machine/node/shard Id — 10 bits (gives us up to total of 2 i.e 1024 Ids)</li><li id="0ada" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">Sequence number — 12 bits (A local counter per machine that sets to zero after every 4096 values)</li><li id="53ee" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">In the beginning, the extra one reserved bit is set as 0 to make the overall number positive.</li></ul><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi og"><img src="../Images/5b134c436a25034408b758bf092778fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q01S_8UxXwBHXZEpB8P1OQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Twitter Snowflake</figcaption></figure><p id="2676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Since these use the timestamp as the first component, therefore, <strong class="jp ir">they are time sortable as well</strong>. Another benefit is its <strong class="jp ir">High Availability</strong>.<br/>By default, 64-bit unsigned integers (long) will generate an Id whose length is 19, but sometimes it may be too long; our use case needed an Id whose size should not be greater than 10. This design requires a Zookeeper to keep mapping Nodes and Machine Ids. Also, it requires several Snowflake servers and introduces additional complexity and more’ moving parts’.</p><p id="b6d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">💡 <strong class="jp ir">Clock synchronization<br/></strong>There’s a hidden assumption that all ID generation servers have the <strong class="jp ir">same</strong> <strong class="jp ir">clock</strong> to generate the timestamp, which might not be accurate in distributed systems. In reality, system clocks can drastically skew in distributed systems</p><h2 id="773e" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">6. Baidu UID generator</h2><p id="c645" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">UID generator is developed by the Baidu technology department and implemented based on the snowflake algorithm. Unlike the original snowflake algorithm, It works as a component and allows users to override workID bits and initialization strategy. As a result, it is much more suitable for virtualization environments, such as <a class="ae ob" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">docker</a>. Besides these, it overcomes concurrency limitation of Snowflake algorithm by consuming future time; parallels UID produce and consume by caching UID with RingBuffer; eliminates CacheLine pseudo sharing, which comes from RingBuffer, via padding. And finally, it can offer over 6 million QPS per single instance.</p><p id="8f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要添加一个工作节点表。当应用程序启动时，一条记录将被插入到数据库表中。成功插入后返回的自增 ID 为<code class="fe od oe of nt b">workID</code>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oh"><img src="../Images/51687c1135c274fef10631d87f826223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwI1K5OR4C6reX_4QXarGQ.png"/></div></div></figure><p id="a0a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图可以看出，UID 生成器的时间部分只有 28 位，也就是说默认情况下 UID 生成器只能忍受 8.5 年(2 ^ 28–1/86400/365)。当然，根据您的业务需求，UID 生成器可以适当地调整增量秒数、工作节点 ID 和序列占用率。如果你有兴趣了解它是如何实现的，这里有更详细的 Github 代码。</p><h2 id="0bb9" class="nb kv iq bd kw nc nd dn la ne nf dp le jy ng nh li kc ni nj lm kg nk nl lq nm bi translated">7.索尼</h2><p id="a47c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Sonyflake 是一个分布式唯一 ID 生成器，灵感来自 Twitter 的雪花。Sonyflake 专注于许多主机/核心环境中的生命周期和性能。因此它的位分配与雪花不同。<br/>Sony flake ID 由以下部分组成</p><ul class=""><li id="84c2" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">以 10 毫秒为单位的 39 位时间</li><li id="bfb7" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">序列号为 8 位</li><li id="20bc" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">机器 id 为 16 位</li></ul><p id="0d33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，Sonyflake 有以下优点和缺点:</p><ul class=""><li id="72c6" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">寿命(174 年)比雪花(69 年)长</li><li id="89b0" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">它可以在比雪花(⁰)更多的分布式机器(⁶)上工作</li><li id="890a" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">在单个机器/线程中，它最多可以每 10 毫秒生成一个⁸id(比雪花慢)</li></ul><p id="fce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果希望在一台主机上有更高的生成速率，可以使用 goroutines 快速地同时运行多个 Sonyflake ID 生成器。由于技术巨头对上述实现有一些缺点，您可以编写一个自定义 ID 来满足您的特定需求。</p><h1 id="af4f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="dec2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这七种方法非常有名，只要根据您的业务需求稍加调整，您就可以采用其中的任何一种。继续你的传统方法没有错，因为它非常有效。</p><p id="fadb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我结束了这次学习；我希望你今天学到了一些新东西。请与更多的同事或朋友分享。最后，考虑成为<a class="ae ob" href="https://zonito.medium.com/membership" rel="noopener">的媒介成员</a>。谢谢大家！</p></div></div>    
</body>
</html>