<html>
<head>
<title>Getting Started with FAST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速 API 入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-fast-api-c7e52e68685f?source=collection_archive---------5-----------------------#2022-10-25">https://blog.devgenius.io/getting-started-with-fast-api-c7e52e68685f?source=collection_archive---------5-----------------------#2022-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2354b976df585d94a25e60b48a980009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6Eaowb7nHrLSiH41Tp4sA.png"/></div></div></figure><p id="e146" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">FastAPI 是一个现代化的快速 web 框架，用于使用 Python 构建 API。这个 Python web 框架最近很受欢迎。FAST API 中的软件开发类似于 Flask，这是大多数用 Python 开始 web 开发的人的默认选项。Fast API 易于使用，其文档简单易懂。顾名思义，FastAPI 速度快；与 Go 和 NodeJs 并驾齐驱；多亏了 Starlette 和 Pydantic，FastAPI 框架才得以建立。FastAPI 比 Flask web framework 更快，因为它是建立在 ASGI(异步服务器网关接口)上，而不是 Flask 使用的 SGI (Web 服务器网关接口)。简单地说，当使用 ASGI 时，不同的请求在完成它们的任务之前不必等待另一个请求。各种请求可以不按特定顺序处理。而在 WSGI 中，请求只被顺序处理。</p><h1 id="c3f0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">FAST API 的功能</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/f4182135e37c1af6f4120e5340450698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*027mZtvcwsqxDblcdWbJQg.png"/></div></div></figure><p id="15d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了 FastAPI 真的很快这一事实之外，FAST API 中还有一些值得注意的特性，其中一些是；</p><ul class=""><li id="688a" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><strong class="jx io">自动文档</strong> : FastAPI 提供交互式 API 文档和 exploration web 用户界面。这些接口基于 OpenAPI 框架，有多个选项，其中默认为 SwaggerUI 和 ReDoc。</li><li id="f4f0" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><strong class="jx io">验证</strong> : FastAPI 为大多数 python 数据类型和其他数据类型(如 UUID、电子邮件等)提供验证，因为它利用 Pydantic 进行验证。</li><li id="f02e" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><strong class="jx io">安全和认证</strong> : FastAPI 附带了 OpenAPI 中定义的所有安全方案，以及 Starlette 中的安全特性(包括会话 cookies)。</li><li id="81da" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">依赖注入:你可能听说过坚实的原则；FAST API 通过强大的依赖注入系统认真对待坚实原则中的“D”。依赖注入由系统自动处理，这使得编写干净的代码成为可能，并减少了整个系统中的耦合。</li></ul><h1 id="6bba" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">FAST API 的使用</h1><p id="dacd" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">为了深入了解如何使用 FAST API 构建应用程序，我们将构建一个最小的应用程序来展示 FAST API 如何工作以及如何在 FAST API 中构建项目。随着我们的继续，假设您对 python 有很好的了解。</p><h1 id="1da4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">装置</h1><p id="7fd2" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">首先，我们必须使用 pip python 包管理器或诗歌安装快速 API。</p><p id="ea86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 pip，我们运行下面的命令<code class="fe mp mq mr ms b">pip install fast-api</code></p><p id="0f6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用诗歌后，我们可以运行<code class="fe mp mq mr ms b">poetry add fast-api</code> <strong class="jx io"> <em class="mt">我们必须使用</em> </strong> <code class="fe mp mq mr ms b"><strong class="jx io"><em class="mt">poetry init</em></strong></code> <strong class="jx io"> <em class="mt">初始化诗歌。我们将在另一篇文章中讨论更多关于诗歌的内容，以及诗歌如何用于依赖性管理。</em></strong></p><p id="59db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，FAST API 构建在 ASGI 之上；因此，我们需要安装一个 ASGI 服务器。对于本教程，我们将安装 uvicorn。我们可以使用<code class="fe mp mq mr ms b">poetry add uvicorn</code>或<code class="fe mp mq mr ms b">pip install uvicorn</code>来安装它。在安装 FAST API 时，会安装其他包，如 pydantic 和 Starlette。</p><h1 id="35fb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构建迷你应用程序</h1><p id="ecad" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">成功安装了上面的包之后，我们就可以开始构建我们最小的快速 API 应用程序了。这个应用程序将是一个待办事项列表，我们应该能够创建，更新和删除待办事项。</p><p id="6ec0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们创建一个名为<code class="fe mp mq mr ms b"><strong class="jx io">main.py</strong></code> <strong class="jx io">，</strong>的文件，作为应用程序的入口点。</p><pre class="ls lt lu lv gt mu ms mv mw aw mx bi"><span id="7ff1" class="my ku in ms b gy mz na l nb nc">"""Entry point to the application"""<br/>import uvicorn<br/>from fastapi import FastAPI<br/>from fastapi.middleware.cors import CORSMiddleware</span><span id="78f7" class="my ku in ms b gy nd na l nb nc">def start_application():<br/>    """Setting up necessary stuff during application start up"""<br/>    app = FastAPI(title="Test Project", version="1.0")<br/>    origins = [<br/>        '&lt;http://localhost&gt;',<br/>        '&lt;http://localhost:8080&gt;'<br/>    ]</span><span id="c8d4" class="my ku in ms b gy nd na l nb nc">    app.add_middleware(<br/>        CORSMiddleware,<br/>        allow_origins=origins,<br/>        allow_credentials=True,<br/>        allow_methods=['*'],<br/>        allow_headers=['*'],<br/>    )</span><span id="3937" class="my ku in ms b gy nd na l nb nc">    return app</span><span id="6b12" class="my ku in ms b gy nd na l nb nc">app = start_application()</span><span id="02f3" class="my ku in ms b gy nd na l nb nc">if __name__ == '__main__':<br/>    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)</span></pre><p id="2e88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数<code class="fe mp mq mr ms b">start_application</code>设置了我们应用程序所需的所有重要实体，比如添加路由器(我们稍后会看到)、设置 CORS 等等。我们在<code class="fe mp mq mr ms b">start_application</code>中添加了 CORSMiddleware，这样我们就可以进行跨来源请求；这些请求来自不同的 IP 地址、不同的协议、端口等。FAST API 还让您能够添加定制的中间件。</p><p id="d91f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面代码片段的最后一部分，我们使用 uvicorn ASGI 服务器运行应用程序，指定端口号和主机等。注意，<code class="fe mp mq mr ms b"><strong class="jx io"><em class="mt">main:app</em></strong></code>指向应用程序在<code class="fe mp mq mr ms b">main.py</code>中初始化的位置，由于<code class="fe mp mq mr ms b">main.py</code>在根文件夹中，我们简单地将其写成</p><p id="acb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mp mq mr ms b"><strong class="jx io"><em class="mt">main:app</em></strong></code> <strong class="jx io"> <em class="mt">。</em> </strong></p><p id="2042" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要启动应用程序，可以运行<code class="fe mp mq mr ms b">python3 main.py</code>，服务器在端口<code class="fe mp mq mr ms b">8000</code>上运行，如最后一行代码中所定义的。运行<code class="fe mp mq mr ms b"><a class="ae ne" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></code>应显示</p><p id="ab14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mp mq mr ms b">{"detail": "Not Found"}</code>。您可以使用<code class="fe mp mq mr ms b"><a class="ae ne" href="http://localhost:8000/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/docs</a></code>访问 swagger 文档 UI，使用<code class="fe mp mq mr ms b"><a class="ae ne" href="http://localhost:8000/redoc" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redoc</a></code>访问 redoc UI</p><h1 id="2110" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建 API</h1><p id="f820" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">创建一个 API 文件夹，创建一个 todo 文件夹并创建<code class="fe mp mq mr ms b"><a class="ae ne" href="http://todo.py/" rel="noopener ugc nofollow" target="_blank">todo.py</a></code>文件。在这个文件中，我们会有下面这段代码。</p><pre class="ls lt lu lv gt mu ms mv mw aw mx bi"><span id="de03" class="my ku in ms b gy mz na l nb nc">"""Todo Endpoints"""<br/>import uuid<br/>from typing import Dict</span><span id="2513" class="my ku in ms b gy nd na l nb nc">from fastapi import APIRouter, status, HTTPException<br/>from api.todo.schemas import Todo, TodoResponse</span><span id="5595" class="my ku in ms b gy nd na l nb nc">router = APIRouter(<br/>    tags=['todo'],<br/>    prefix='/v1/todo',<br/>    responses={404: {'description': 'Not found'}},<br/>)</span><span id="60e8" class="my ku in ms b gy nd na l nb nc">todo_db: Dict = {}</span></pre><p id="909c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们为 todo API 创建了一个路由器。我们还创建了一个内存数据库来存储我们的 todo，主要用于我们的 todo 的 CRUD(创建、更新和删除)功能。</p><p id="a161" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样需要注意的是，虽然在本教程中我们没有连接到数据库，但是我们可以使用 Sqlalchemy、Pymongo 等库将任何数据库连接到我们的应用程序。</p><p id="9e31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到有些模式是在 todo 文件中导入的；在没有这些模式的情况下运行代码会导致错误。因此，我们在 todos 文件夹中创建了<code class="fe mp mq mr ms b">[schemas.py](&lt;http://schemas.py&gt;)</code>文件。模式由我们在创建 API 时用于数据验证的 Pydantic 模型组成。模式详细信息如下所示。</p><pre class="ls lt lu lv gt mu ms mv mw aw mx bi"><span id="0658" class="my ku in ms b gy mz na l nb nc">from pydantic import BaseModel, Field</span><span id="1c1e" class="my ku in ms b gy nd na l nb nc">class Todo(BaseModel):<br/>    name: str = Field(..., description='Name of the todo')<br/>    complete: bool = Field(False, description='Checks if the todo has finished')<br/>    creator_name: str = Field(..., max_length=20, description='Name of the creator')</span><span id="c10d" class="my ku in ms b gy nd na l nb nc">class TodoResponse(Todo):<br/>    id: str = Field(..., description='Unique identifier of the todo')</span></pre><p id="d5fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个字段中的描述使 FAST API 能够开发详细的文档。creator_name 的最大长度为 20 个字符；如果数字超过 20 个字符，Pydantic 将抛出一个验证错误异常。有了定义良好的 Pydantic 模型，我们就可以得到正确的数据。建议浏览一下<a class="ae ne" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic 文档</a>,因为使用 Pydantic 可以做更多令人兴奋的事情。</p><p id="2f3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始创建一些 API。</p><pre class="ls lt lu lv gt mu ms mv mw aw mx bi"><span id="aaa3" class="my ku in ms b gy mz na l nb nc">@router.post(<br/>	'/', <br/>	description='Create a new todo', <br/>	response_model=TodoResponse, <br/>	status_code=status.HTTP_200_OK<br/>)<br/>async def create_todo(data: Todo):<br/>    new_data = data.dict()<br/>    unique_id = str(uuid.uuid4())<br/>    new_data['id'] = unique_id<br/>    todo_db[unique_id] = new_data</span><span id="8928" class="my ku in ms b gy nd na l nb nc">    return TodoResponse(**new_data)</span><span id="0dc7" class="my ku in ms b gy nd na l nb nc">@router.get(<br/>	'/{todo_id}', <br/>	description='Get a todo', <br/>	response_model=TodoResponse, <br/>	status_code=status.HTTP_200_OK<br/>)<br/>async def get_a_todo(todo_id: str) -&gt; Todo:<br/>    todo = todo_db.get(todo_id)<br/>    if not todo:<br/>        raise HTTPException(<br/>						status_code=status.HTTP_404_NOT_FOUND, detail='Todo not found')</span><span id="d9f8" class="my ku in ms b gy nd na l nb nc">    return Todo.parse_obj(todo)</span></pre><p id="1606" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用之前创建的路由器来修饰函数<code class="fe mp mq mr ms b">create_todo</code>和<code class="fe mp mq mr ms b">get_a_todo</code>，并使用 POST HTTP 动词来创建一个带有默认路由<code class="fe mp mq mr ms b">'/'</code>的新 todo。函数<code class="fe mp mq mr ms b">create_todo</code>接受一个 Todo 类型的参数数据(我们创建的 pydantic 模式)；这样，Pydantic 可以根据模式定义验证数据。在<code class="fe mp mq mr ms b">create_todo</code>函数的最后一行中，我们将刚刚创建的新 todo 传递给根据<strong class="jx io"> <em class="mt">模式呈现数据的 to dore response</em></strong>。</p><p id="8ba9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了获得一个 todo，路由改变以适应我们想要获得的 todo_id。因此，我们在 URL 中传递 todo_id，并将 todo_id 作为参数添加到<code class="fe mp mq mr ms b">get_a_todo</code>函数中。</p><p id="60e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经有了一个简单的 API 功能，所以我们可以将路由器添加到我们最初创建的<code class="fe mp mq mr ms b"><strong class="jx io">main.py</strong></code>文件中的<code class="fe mp mq mr ms b">start_application</code>函数中。</p><pre class="ls lt lu lv gt mu ms mv mw aw mx bi"><span id="4db0" class="my ku in ms b gy mz na l nb nc">from api.todo import todo</span><span id="3b97" class="my ku in ms b gy nd na l nb nc">def start_application():<br/>    """Setting up necessary stuff during application start up"""<br/>    app = FastAPI(title="Test Project", version="1.0")<br/>    origins = [<br/>        '&lt;http://localhost&gt;',<br/>        '&lt;http://localhost:8080&gt;'<br/>    ]</span><span id="63d6" class="my ku in ms b gy nd na l nb nc">    app.add_middleware(<br/>        CORSMiddleware,<br/>        allow_origins=origins,<br/>        allow_credentials=True,<br/>        allow_methods=['*'],<br/>        allow_headers=['*'],<br/>    )</span><span id="5cd4" class="my ku in ms b gy nd na l nb nc">    app.include_router(todo.router)</span><span id="5089" class="my ku in ms b gy nd na l nb nc">    return app</span></pre><p id="c132" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面代码片段的开始，我们从 API 文件夹导入 todo 来访问文件和路由器中的所有函数，这在本例中很重要。我们通过调用应用程序上的<code class="fe mp mq mr ms b">include_router</code>函数并将 todo 路由器作为参数传递，将我们的路由器包含在<code class="fe mp mq mr ms b">start_application</code>函数中。</p><p id="2017" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过以上更改，我们可以运行我们的应用程序并导航到 swagger UI 文档来运行代码并使用该接口测试 API。您也可以根据需要决定添加更多端点。</p><p id="66ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的教程是理解 FAST API 的一个非常简单的方法；这仅仅触及了使用 FAST API 可以构建的应用程序的表面。FAST API 是一个非常简单但功能强大且灵活的框架，可用于构建大规模应用程序。</p><h1 id="4289" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异步/等待</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/da886c01afa2134c3259d396132e4106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22BUwpBM-HIKiGZwpDiy1Q.png"/></div></div></figure><p id="1064" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的教程中，你一定见过教程中<strong class="jx io"> async </strong>在定义各种路由的函数时的用法。现代 python 应用程序支持异步代码，即使用 async/await。</p><p id="03ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步代码意味着告诉计算机，在代码执行的某个时刻，它必须等待“其他事情”完成。在“其他事情”完成的过程中，代码可以继续执行代码的其他部分，同时等待结果。</p><p id="b3e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数时候，异步代码等待的进程通常是 I/O 操作，例如，通过网络从客户端发送的数据、返回结果的数据库查询等等。</p><h1 id="93e5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3589" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">虽然我们已经开发了一个非常简单的应用程序来演示如何使用 FAST API 构建 API，但是您还可以使用 FAST API 构建许多其他令人兴奋的东西。本文应该已经为您提供了一些关于在应用程序中使用 FAST API 的基本知识。</p></div></div>    
</body>
</html>