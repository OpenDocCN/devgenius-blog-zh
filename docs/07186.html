<html>
<head>
<title>Seasoned Java Developers Use These 9 Simple Performance Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的 Java 开发人员使用这 9 个简单的性能技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/seasoned-java-developers-use-these-9-simple-performance-tips-68035aeb1de2?source=collection_archive---------1-----------------------#2022-03-04">https://blog.devgenius.io/seasoned-java-developers-use-these-9-simple-performance-tips-68035aeb1de2?source=collection_archive---------1-----------------------#2022-03-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="12f7" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何用 9 个简单的技巧优化你的 Java 代码</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/d10f45282c48d5e79bee5d9f4835eea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CXO9W92IJ6w58pi-.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://www.freepik.com/photos/business" rel="noopener ugc nofollow" target="_blank">由亚娜拉·www.freepik.com 创作的商业照片</a></figcaption></figure><p id="6fda" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Java 开发人员不关心性能或维护成本。</p><p id="67d8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">大部分复制了 StackOverflow 的东西。如果代码有效，就不要碰代码。有经验的开发人员不会放过这一点。</p><p id="cad8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是编写更高性能的 Java 代码的方法。</p><h1 id="801e" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">1.偏好组合而非继承</h1><p id="17c3" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">合成有更多的好处，因为它不需要 vtable lookup。因为你没有很多子类，你将避免虚拟调用。</p><p id="53d4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">没有子类方法的方法的单调用点是单态的。它们只有一种形态，一种形状，因此被称为单形。他们有更好的表现。</p><p id="9826" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">一个方法的许多调用点，许多覆盖该方法的子类，都是多态的。它们有许多形状，因此得名。因为它们需要 vtable 查找，所以性能会受到影响。</p><p id="a51a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">最多三次覆盖不会影响性能。三次覆盖以上的所有操作都会影响性能。</p><p id="80cc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">考虑到 is-a 和 has-a 的关系。不要盲目地遵循这个提示，而是要把它考虑进去。</p><h1 id="99de" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">2.保持你的兰姆达斯短</h1><p id="ad15" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">一天没有λ。</em>T9】</strong></p><p id="5e13" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">保持你的兰姆达斯短。 参数越多——捕获成本越大。函数类型是在运行时生成的，它们需要捕获参数。本质上，保持做空以获得收益。</p><p id="3687" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">不指非静态成员。</em> </strong>来自外部类的参数会导致一些性能损失。尽管命中率可以忽略不计，但最好不要使用非静态成员。</p><h1 id="dbe9" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">3.使用未绑定的方法引用</h1><p id="da1b" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">用这些<code class="fe mn mo mp mq b">Class::method</code>代替<code class="fe mn mo mp mq b">this::method</code>。后者的表现会更差。如果你喜欢静态方法引用来降低捕获成本。</p><h1 id="34bd" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">4.根除大方法</h1><p id="e67d" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">创造小而热的方法。避免大方法。</em> </strong></p><p id="4669" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">编译器内嵌小方法。</em> </strong>你要尽量给他喂小的。这符合干净代码的原则，所以这是一个双赢的局面。</p><p id="03ae" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="mm">如何找到改进的方法？使用<a class="ae ks" href="https://github.com/AdoptOpenJDK/jitwatch/blob/master/jarScan.sh" rel="noopener ugc nofollow" target="_blank"> jarScan </a>并将限制设置为 325 字节。极限指出大方法。</em></p><h1 id="f4c8" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">5.首选枚举集</h1><p id="ee14" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">这是一个在<code class="fe mn mo mp mq b">Set</code>中存储<code class="fe mn mo mp mq b">Enum</code>值并获得更好性能的结构。</p><p id="1c40" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你应该更喜欢<code class="fe mn mo mp mq b">EnumSet</code>而不是<code class="fe mn mo mp mq b">HashSet</code>。<em class="mm">为什么？</em> <code class="fe mn mo mp mq b">EnumSet</code>，由于密钥事先已知，可以用 bitset 来存储值。这使得<code class="fe mn mo mp mq b">EnumSet</code>占用的空间更少，所有操作都是按位的。</p><h1 id="469d" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">6.学习等号和 hashCode 关系</h1><p id="b50c" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">对这些方法的无知会浪费你宝贵的时间。每次面试都会问到这些问题，所以这可能会让你丢掉一份工作。</p><p id="1680" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里有一些关于这些的提示。</p><p id="6d36" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">不应该有常量 hashCode。</em>T11】</strong></p><p id="66a3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这将影响性能，并消除哈希的优势。假设您使用 constant 作为 hashCode。每次访问类似散列的结构都会导致冲突。这将把常数访问时间降低到线性时间复杂度。</p><p id="4b99" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">对于 hashCode，你应该只使用不可变的字段。T15】</p><p id="eece" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">不要使用可变字段来生成 hashCode。这可能会适得其反，导致奇怪的错误。你可以看看这个例子，看看记录是如何产生这些错误的。</p><h1 id="51b0" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">7.你不应该对常量使用接口</h1><p id="0fc2" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">只有常量的接口是一种反模式。 不创建接口来存储常量。或者创建内部接口来存储常数。</p><p id="cb07" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">用</em> </strong> <code class="fe mn mo mp mq b"><strong class="kv is"><em class="mm">EnumSets</em></strong></code> <strong class="kv is"> <em class="mm">。这些将容纳多达 64 个常数，给你更快的访问，和一个存储常数的惯用方法。</em></strong></p><p id="87a0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因为接口不是密封的，所以你可以实现这个只有常量的接口。至少布洛赫是这么说的。你在实践中永远看不到这一点。但是你可以添加越来越多的常量，扩大界面。</p><h1 id="e24d" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">8.按照预期使用断言错误</h1><p id="e59d" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">断言错误就是错误。</em> </strong>错误应该发生。错误不是例外。</p><p id="3652" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里很好的解释了什么时候用哪个。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://github.com/google/guava/wiki/ConditionalFailuresExplained#summary" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="6e39" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mm">抛出异常和断言错误不一样。正确对待这个问题会增加你作为开发者的价值。</em></strong></p><p id="4df1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这两者之间的明显区别可以提高你的表现。你将确切地知道什么是错误，什么是异常。</p><h1 id="b982" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">9.不要迭代枚举值</h1><p id="6563" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">在 Java 枚举中你会经常看到这种情况。当你出于某种原因需要所有的值时，你求助于<code class="fe mn mo mp mq b">Enum.values()</code>。</p><p id="d608" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你应该尝试使用<code class="fe mn mo mp mq b">EnumSet</code>或<code class="fe mn mo mp mq b">EnumMap</code>。如前所述，这些将有助于你与枚举。它们将比其他解决方案更具性能。</p><p id="ce37" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">如果需要使用值，缓存它们。<a class="ae ks" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks#dont-iterate-over-enumvalues" rel="noopener ugc nofollow" target="_blank">基准测试显示</a>对于更大的 Enums 有很大的改进。</p><h1 id="4df8" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">外卖食品</h1><p id="ac38" class="pw-post-body-paragraph kt ku ir kv b kw mh js ky kz mi jv lb lc mj le lf lg mk li lj lk ml lm ln lo ik bi translated">这些都是可以有所作为的微优化。你不应该扔掉你当前的代码，而是把它们留在你的脑海里。</p></div></div>    
</body>
</html>