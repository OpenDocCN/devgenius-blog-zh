<html>
<head>
<title>Go: Support Universal Binaries Using Shell Script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:使用 Shell 脚本支持通用二进制文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-support-universal-binaries-using-shell-script-ec9478ac716?source=collection_archive---------4-----------------------#2022-08-16">https://blog.devgenius.io/go-support-universal-binaries-using-shell-script-ec9478ac716?source=collection_archive---------4-----------------------#2022-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/69f83a9c97475d7af249fdd65971db5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z7yatnawvL9hUhfG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">马库斯·斯皮斯克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="78f9" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="6c0d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你有没有想过用一个二进制文件编写一个可以在多个平台上运行的围棋程序？我一直有点希望 Go 会有“胖”的二进制文件，就像我们从 PowerPC 转换到 Intel 时旧 Mac 的二进制文件一样，让你可以在任何一个平台上运行。</p><p id="e369" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">那么，如果我们想发布我们的 Go 程序，使它能从一个可执行文件中支持多种平台/操作系统组合，我们今天能做些什么呢？</p><p id="3b73" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">可信的旧 shell 脚本。</p><h1 id="5c26" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">广告</h1><p id="635f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果你对使用 Go 进行 DevOps 工作感兴趣，可以在亚马逊上查看我的书:<a class="ae jz" href="https://www.amazon.com/Go-DevOps-language-Kubernetes-Terraform/dp/1801818894/ref=cm_cr_arp_d_pdt_img_top?ie=UTF8" rel="noopener ugc nofollow" target="_blank"> Go For DevOps </a>。</p><p id="0d97" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">作者(不是出版商)的收益将捐给无国界医生组织，一个伟大的组织。</p><h1 id="e0b7" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">让我们把这个解决掉</h1><p id="19e2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">实际上，我讨厌大多数用例的 shell 脚本。它们容易出错，测试也很痛苦。我的 shell 脚本的主要用例是围绕一个片状测试运行一个<strong class="la io"> for </strong>循环，试图让它再次跳闸。</p><p id="51db" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是像任何事情一样，也有例外。sh 在每个 Unix 平台上都有，因此它的通用性使它非常适合这种用途。</p><h1 id="84f9" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">是什么原因让我写了这个？</h1><p id="3a13" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我最近遇到有人试图使用 shell 将数据推送到一个拥有多种语言 SDK 的服务中。但是那个人不想让他们要支持的所有系统都有不同的二进制文件，也不想安装其他运行时(Python、.网，…)。这意味着在那个平台的 REST 流上做一些逆向工程，在 shell 中做一些复杂的体操，同时调用<em class="mb"> cURL。</em></p><p id="48f0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我想一定有更好的方法，于是就做了这个演示。这个想法来自于谷歌和脸书用来打包 Python 程序进行分发的方法。</p><h1 id="1580" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这个想法</h1><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7106" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们将在一个 shell 脚本中封装多个 Go 二进制文件，shell 脚本将检测操作系统/平台，并将我们想要的二进制文件解码到正确的位置并调用它。我们可以将 shell 脚本的参数直接传递给二进制文件。</p><p id="a25a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您有足够多的二进制文件或大型程序，这会使 shell 脚本变大。另一个版本可以让脚本从 GitHub 或其他地方下载正确的版本以节省空间。但是在这个演示中，我们将只是烘焙二进制文件。</p><p id="cd72" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个演示的所有代码都可以在这里找到:<a class="ae jz" href="https://github.com/johnsiilver/shellembed" rel="noopener ugc nofollow" target="_blank">https://github.com/johnsiilver/shellembed</a></p><h1 id="41b0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">包装脚本</h1><p id="1f01" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了使这一切工作，我们需要一个脚本来包装我们的 Go 二进制文件，然后在调用时打开它们。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="29a4" class="mn kb in mj b gy mo mp l mq mr">#!/bin/bash <br/># define the tasks that need to be done with the extracted content<br/>process_tar() {<br/>    cd $WORK_DIR"/bin"<br/>    # do something with the extracted content<br/>    eval "./hello_${os}_${arc} $@"<br/>}</span></pre><p id="dfa5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">首先定义一个函数，我们稍后将调用这个函数<em class="mb"> process_tar() </em>。该函数将进入我们稍后创建的工作目录，并对工作目录中的二进制文件运行<em class="mb"> eval </em>命令，向其传递脚本传递的参数(<em class="mb"> $@ </em>)。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="377f" class="mn kb in mj b gy mo mp l mq mr"># line number where payload starts<br/>PAYLOAD_LINE=$(awk '/^__PAYLOAD_BEGINS__/ { print NR + 1; exit 0; }' $0)</span></pre><p id="6b65" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来，我们使用<em class="mb"> awk </em>扫描我们所在的脚本文件，并记录具有<em class="mb"> __PAYLOAD_BEGINS_ 的行号。</em>这之后的所有内容都将是我们的 Go 二进制文件，它们已经在 shell 脚本的末尾放入了压缩的<em class="mb"> tar </em>格式。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="53f6" class="mn kb in mj b gy mo mp l mq mr"># Determine the os and arch.<br/>if [[ "$OSTYPE" == "linux-gnu"* ]]; then<br/>  os="linux"<br/>elif [[ "$OSTYPE" == "darwin"* ]]; then<br/>  os="darwin"<br/>else <br/>  echo "unsupported OS: " + `uname -a` <br/>  exit 1<br/>fi</span><span id="e377" class="mn kb in mj b gy ms mp l mq mr">if [[ `uname -m` == "arm64" ]]; then  <br/>  arc="arm64"<br/>elif [[ `uname -m` == "x86_64" ]]; then <br/>  arc="amd64"<br/>else <br/>  echo "unsupported arch: " + `uname -m` <br/>  exit 1<br/>fi</span></pre><p id="8b45" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们希望支持运行在 x86_64 和 arm64 处理器上的 Linux 和 Darwin。我们使用<em class="mb"> $OSTYPE </em>和<em class="mb"> uname </em>来确定我们的 OS 和平台。如果存在任何其他组合，我们给出一个错误。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="f696" class="mn kb in mj b gy mo mp l mq mr"># make our directory if it doesn't exist.<br/>mkdir -p /tmp/helloshell<br/>WORK_DIR=/tmp/helloshell</span></pre><p id="4ec0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然后，我们创建一些工作目录，将提取的 tar 文件转储到其中，以获取 Go 可执行文件。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="4407" class="mn kb in mj b gy mo mp l mq mr"># extract the embedded tar file<br/>tail -n +${PAYLOAD_LINE} $0 | tar -zpx -C $WORK_DIR &gt;/dev/null 2&gt;&amp;1</span><span id="0c4a" class="mn kb in mj b gy ms mp l mq mr"># perform actions with the extracted content<br/>process_tar $@</span><span id="51cb" class="mn kb in mj b gy ms mp l mq mr">exit 0<br/>__PAYLOAD_BEGINS__</span></pre><p id="a064" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然后，我们创建一些工作目录，将提取的 tar 文件转储到其中，以获取 Go 可执行文件。</p><p id="b811" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然后我们<em class="mb">解包</em>我们的 Go 可执行文件，并从上面执行我们的<em class="mb"> process_tar() </em>函数。</p><p id="5681" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们有了一个脚本，如果我们支持这个平台，它可以解包一些 Go 二进制文件并运行它们。但是我们如何将 Go 二进制文件放到脚本中呢？</p><h1 id="3e52" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为平台脚本构建</h1><p id="cf66" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">下面是一个小脚本，它为我们想要的每个操作系统/平台组合构建我们的二进制文件，然后将它们嵌入到一个名为<strong class="la io"> run.sh. </strong>的文件中。这个文件是<strong class="la io"> hello.sh </strong>的副本，其中 Go 二进制文件嵌入为压缩的<em class="mb"> tar </em>文件。</p><p id="57b4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个构建器脚本将被命名为<strong class="la io"> build_for_platform.sh </strong></p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="1f71" class="mn kb in mj b gy mo mp l mq mr">#!/bin/bash</span><span id="4642" class="mn kb in mj b gy ms mp l mq mr">export GOOS=linux <br/>export GOARCH=amd64 <br/>go build -o bin/hello_linux_amd64</span><span id="c54e" class="mn kb in mj b gy ms mp l mq mr">export GOOS=linux <br/>export GOARCH=arm64 <br/>go build -o bin/hello_linux_arm64</span><span id="b212" class="mn kb in mj b gy ms mp l mq mr">export GOOS=darwin<br/>export GOARCH=amd64 <br/>go build -o bin/hello_darwin_amd64</span><span id="83e3" class="mn kb in mj b gy ms mp l mq mr">export GOOS=darwin<br/>export GOARCH=arm64 <br/>go build -o bin/hello_darwin_arm64</span></pre><p id="533a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第一部分只是在一个名为<em class="mb"> bin/ </em>的目录中构建我们的 Go 二进制文件，并根据操作系统和平台对它们进行索引。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="2fc6" class="mn kb in mj b gy mo mp l mq mr">tar -czvf hello.tar.gz bin/</span></pre><p id="f455" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下一部分创建我们的<em class="mb"> bin/ </em>的<em class="mb"> tarball </em></p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="f971" class="mn kb in mj b gy mo mp l mq mr">cp hello.sh run.sh<br/>cat hello.tar.gz &gt;&gt; run.sh</span></pre><p id="bf34" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们创建我们的<strong class="la io"> hello.sh </strong>副本作为<strong class="la io"> run.sh </strong>并将我们的 tarball 附加到<strong class="la io"> run.sh </strong>的末尾。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="5bb7" class="mn kb in mj b gy mo mp l mq mr">rm hello.tar.gz<br/>rm -rf bin/</span></pre><p id="c9d8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">最后，我们做一些清理工作。</p><h1 id="94fd" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如果你愿意，就敲鼓吧</h1><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mt mh l"/></div></figure><p id="3f74" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您现在可以简单地运行:</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="234c" class="mn kb in mj b gy mo mp l mq mr">./build_for_platform.sh</span></pre><p id="3903" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这将创建您的<strong class="la io"> run.sh </strong>文件。</p><p id="44dd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在让我们执行我们的<strong class="la io"> run.sh </strong>并给它传递一个参数(它将打印出一个名称):</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="26a5" class="mn kb in mj b gy mo mp l mq mr">./run.sh John</span></pre><p id="f68f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这会输出类似这样的内容(输出取决于平台):</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="6c8e" class="mn kb in mj b gy mo mp l mq mr">hello John from: darwin/arm64</span></pre><h1 id="f18d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="4e77" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">正如您从上面看到的，使用 shell 脚本为所有支持的平台创建通用的二进制文件是可能的。如果您希望保持 shell 脚本较小，您可以让它简单地下载您需要的二进制文件，并使用相同的参数进行调用。</p><p id="e017" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是当你不想依赖网络的时候，这是一个很好的方法。</p><p id="cd20" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你想看更多我写的东西，你应该在亚马逊上看看我的书:<a class="ae jz" href="https://www.amazon.com/Go-DevOps-language-Kubernetes-Terraform/dp/1801818894/ref=cm_cr_arp_d_pdt_img_top?ie=UTF8" rel="noopener ugc nofollow" target="_blank"> Go For DevOps </a></p><p id="3e73" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">你也可以在 medium 或我在 golangsre.com<a class="ae jz" href="http://golangsre.com" rel="noopener ugc nofollow" target="_blank">的博客上找到更多关于各种主题的文章。如果你想从一些互动视频课程中学习围棋，请访问我的免费网站 golangbasics.com</a><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/ golangbasics.com"/>。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/561c94d018534c8ee9df0ca580a1ca93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QF1HcVcmXjXMrd9MRiGVsQ.png"/></div></div></figure></div></div>    
</body>
</html>