<html>
<head>
<title>Auto hiding a toast message in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动隐藏有角度的祝酒辞</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/auto-hiding-a-toast-message-in-angular-54f886ad6129?source=collection_archive---------6-----------------------#2022-05-31">https://blog.devgenius.io/auto-hiding-a-toast-message-in-angular-54f886ad6129?source=collection_archive---------6-----------------------#2022-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a26f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">错误和干杯</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fa3e6ecd87f7fb724fad7f9b9df2fd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TNdV5DomMTxDier_0xWkQ.png"/></div></div></figure><p id="d236" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以前我们建立了一个服务来通过产生一个 toast 消息来<a class="ae lk" href="https://garage.sekrab.com/posts/catching-and-displaying-ui-errors-with-toast-messages-in-angular" rel="noopener ugc nofollow" target="_blank">处理我们的 UI 错误，今天我们增强了 toast 的行为，超时和自动隐藏。</a></p><h1 id="fc78" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">超时设置</h1><p id="7a88" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">超时是可变的，但是您不想考虑它，所以我们创建一些打包的选项来定义最常见的超时。让我们从超时的属性开始，看看如何处理它。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="042a" class="mn lm in mj b gy mo mp l mq mr">export interface IToast {<br/>  text?: string;<br/>  css?: string; <br/>  extracss?: string;<br/>  buttons?: IToastButton[];<br/>  timeout?: number; // new for timeout to hide<br/>}</span><span id="ee6f" class="mn lm in mj b gy ms mp l mq mr">@Injectable({ providedIn: 'root' })<br/>export class Toast {<br/>  // ...<br/>  <br/>  // keep track of timeout<br/>  private isCancled: Subscription;</span><span id="0820" class="mn lm in mj b gy ms mp l mq mr">  // change default to have default 5 seconds delay<br/>  private defaultOptions: IToast = {<br/>    // ...<br/>    timeout: 5000,<br/>  };</span><span id="c89f" class="mn lm in mj b gy ms mp l mq mr">  Show(code: string, options?: IToast) {<br/>    // we need to hide before we show in case consecutive show events<br/>    // this will reset the timer<br/>    this.Hide();<br/>    <br/>    // ...<br/>   <br/>    // timeout and hide<br/>    this.isCanceled = timer(_options.timeout).subscribe(() =&gt; {<br/>      this.Hide();<br/>    });<br/>    <br/>   <br/>  }<br/>  Hide() {<br/>    // reset the timer<br/>    // in case of showing two consecutive messages or user clicks dismiss <br/>    if (this.isCanceled) {<br/>      this.isCanceled.unsubscribe();<br/>    }<br/>    this.toast.next(null);<br/>  }</span></pre><p id="cbb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个想法是基本的；创建一个计时器超时，并取消(或重置)显示前，或当用户点击解散计时器。用法很简单，但可以增强(超时是可选的):</p><p id="78a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mj b">this.toast.ShowSuccess('INVALID_VALUE', {timeout: 1000});</code></p><p id="1f7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">代替传递显式超时，我们希望拥有 times 的<strong class="kq io">选项，主要有三种:<strong class="kq io"> short，long，never </strong>。我们可以将超时重新定义为一个<code class="fe mt mu mv mj b">enum</code>:</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="379a" class="mn lm in mj b gy mo mp l mq mr">// toast model<br/>export enum EnumTimeout {<br/>  Short = 4000, // 4 seconds<br/>  Long = 20000, // 20 seconds<br/>  Never = -1, // forever<br/>}</span><span id="64b2" class="mn lm in mj b gy ms mp l mq mr">export interface IToast {<br/>  // ... redefine<br/>  timeout?: EnumTimeout; // new for timeout to hide<br/>}</span><span id="ce3e" class="mn lm in mj b gy ms mp l mq mr">// state service<br/>@Injectable({ providedIn: 'root' })<br/>export class Toast {<br/>  // ...<br/>  // we can set to the default to "short" or any number<br/>  private defaultOptions: IToast = {<br/>   // ...<br/>   timeout: EnumTimeout.Short, // or you can use Config value<br/>  };</span><span id="4fc8" class="mn lm in mj b gy ms mp l mq mr">  Show(code: string, options?: IToast) {<br/>    // ...<br/>    // if timeout, timeout and hide<br/>    if (_options.timeout &gt; EnumTimeout.Never) {<br/>      this.isCanceled = timer(_options.timeout).subscribe(() =&gt; {<br/>        this.Hide();<br/>      });<br/>    }<br/>  }<br/>  //...<br/>}</span></pre><p id="9bdc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要使用它，我们可以将它作为一个数字或一个<code class="fe mt mu mv mj b">enum</code>来传递:</p><p id="83bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mj b">this.toast.Show('SomeCode', {timeout: EnumTimeout.Never});</code></p><p id="1c4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在来谈谈 UX 问题。</p><h1 id="f685" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">为什么要藏起来，藏多久</h1><p id="339b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><em class="mw"> snackbars </em>的材料指南允许一条消息出现在前一条消息之上(在 z 方向)。当用户关闭当前消息时，它下面的旧消息仍然存在。<strong class="kq io">这在用户体验方面有很大的缺陷</strong>。小吃店和面包店意味着<strong class="kq io">即时和上下文的注意力抓取器</strong>。展示一个陈旧的是很吵的。这就是为什么我选择了上面的实现，它允许一次一条消息，被更新的消息覆盖。</p><p id="6a29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们应该仔细考虑向用户显示什么信息，何时显示，显示多长时间。否则，敬酒的价值，就是敬酒！<strong class="kq io">一般规则是，如果有其他视觉提示，信息应该简短。</strong>这也意味着成功的手术很少需要举杯庆祝。</p><p id="52fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下是你可能会同意的食谱:</p><h2 id="a2a3" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">提交时表单字段无效</h2><p id="cad8" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当用户点击提交一个带有无效字段的表单时，一个很快消失的<strong class="kq io">快速通知</strong>就足够了，因为表单字段已经有了视觉指示。当屏幕大小不适合所有表单字段，并且无效字段位于视窗上方时，这很有帮助。</p><h2 id="0524" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">没有视觉反应的成功动作</h2><p id="1c51" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">想想脸书的分享行动，创建的帖子并没有直观地更新时间轴。一条简短甜蜜的祝酒辞，加上一个查看帖子的动作，是最理想的。</p><h2 id="025b" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">系统生成的带有视觉提示的消息</h2><p id="19e4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当收到电子邮件或互动的推送通知时，页面上的另一个元素也会更新，在这种情况下，贝尔图标、<strong class="kq io">一个简短且可行的祝酒词</strong>可能是正确的答案、<strong class="kq io">一个不祝酒词</strong>也可能是另一种方式，想想桌面 Twitter 通知。</p><h2 id="cbd4" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">系统生成的消息没有视觉提示</h2><p id="a61f" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当一个 PWA 站点有了新版本，想要邀请用户“更新”时，或者一个新用户被提示“订阅”一份时事通讯时，<strong class="kq io">一个带有动作</strong>的冗长的拒绝消息听起来是正确的。决定因素是消息有多紧急，它可能是一个粘性消息。</p><p id="2250" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些上下文很少会妨碍展示，有时页面的刷新会消除任何遗留问题，一条祝酒词会打断注意力，而不是抓住它。现在考虑以下情况。</p><h2 id="a2d4" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">陈旧页面需要操作</h2><p id="50be" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当页面打开时间过长，<strong class="kq io">授权用户超时</strong>时，当用户点击任何需要授权的动作时，<strong class="kq io">重定向到登录页面</strong>，<strong class="kq io">并显示简短的原因提示</strong>。</p><h2 id="0478" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">带有可选操作的陈旧页面</h2><p id="4994" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">然而，如果<strong class="kq io">授权是可选的</strong>，并且用户可以注册或登录，那么<strong class="kq io"> toast 消息应该具有动作按钮</strong>，并且<strong class="kq io">不应该消失</strong>，除非用户取消它，或者另一个 toast 覆盖它。</p><h2 id="bb34" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">服务器使进程超时</h2><p id="c624" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当服务器由于未知原因长时间拒绝完成一个进程时，<strong class="kq io">错误提示最好告诉用户进程没有通过</strong>。用户可能已经离开屏幕一段时间了(可能他们认为网站太害羞了，在他们看的时候不敢做自己的事情😏).</p><h2 id="2c29" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">API 404 错误</h2><p id="198a" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">一般的 API 404 错误也需要<strong class="kq io">逗留</strong>，因为没有其他视觉提示来指示它们，但是如果页面重定向，就不需要显示任何消息。</p><h1 id="8abb" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">动画</h1><p id="3783" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">最后要添加的是动画。动画的主要成分是让烤面包片先出现，进入视野，停留，隐藏，然后消失。有多种方法可以做到这一点，下面是一些方法:</p><h2 id="7fb7" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">1.在不移除元素的情况下制作动画</h2><p id="f7b7" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">第一个也是最直接的方法是放弃烤面包的条件存在，只让它潜入视口的底部。这是为了避免在元素被 Angular 移除后不得不在 DOM 中隐藏元素。</p><p id="bf9a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">CSS 动画看起来像这样:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ec5a" class="mn lm in mj b gy mo mp l mq mr">.toast {<br/>  /* ...  remember the bottom: 10px */<br/>  /*by default is should be out of view*/<br/>  /* calculate 100% of layer height plus the margin from bottom */<br/>  transform: translateY(calc(100% + @space));<br/>  transition: transform 0.2s ease-in-out;<br/>}<br/>.toast.inview {<br/>  /*transition back to 0*/<br/>  transform: translateY(0);<br/>}</span></pre><p id="2f26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的状态和 toast 模型中，我们为可见性添加了一个新的属性。我们用<strong class="kq io">缺省值 false </strong>初始化我们的状态，并更新该属性，而不是使状态无效:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="bd4c" class="mn lm in mj b gy mo mp l mq mr">// toast model<br/>export interface IToast {<br/>  // ...<br/>  visible?: boolean;<br/>}</span><span id="7820" class="mn lm in mj b gy ms mp l mq mr">// state<br/>@Injectable({ providedIn: 'root' })<br/>export class Toast {</span><span id="4737" class="mn lm in mj b gy ms mp l mq mr">  // ... <br/>  private defaultOptions: IToast = {<br/>    // ...<br/>    // add default visible false<br/>    visible: false<br/>  };</span><span id="6279" class="mn lm in mj b gy ms mp l mq mr">  // set upon initialization<br/>  constructor() {<br/>    this.toast.next(this.defaultOptions);<br/>  }<br/>  Show(code: string, options?: IToast) {<br/>    // ...<br/>    // update visible to true<br/>    this.toast.next({ ..._options, text: message, visible: true });<br/>    <br/>    // ... timeout and hide<br/>  }<br/>  Hide() {<br/>    // ...<br/>    // reset with all current values<br/>    this.toast.next({ ...this.toast.getValue(), visible: false });<br/> }<br/>}</span></pre><p id="77aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，在组件模板中，我们添加了<code class="fe mt mu mv mj b">inview</code>条件类:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="b737" class="mn lm in mj b gy mo mp l mq mr">&lt;ng-container *ngIf="toastState.toast$ | async as toast"&gt;<br/>  &lt;div <br/>    [class.inview]="toast.visible"<br/>    class="{{toast.css}} {{toast.extracss}}"&gt;<br/>    ...<br/>  &lt;/div&gt;<br/>&lt;/ng-container&gt;</span></pre><h2 id="806d" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">2.以编程方式隐藏</h2><p id="6fe4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们也可以制作动画，然后在移除元素之前观察动画的结尾(<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/animationend_event" rel="noopener ugc nofollow" target="_blank">animation end</a>)。这有点扭曲，但是如果你坚持在完成后<strong class="kq io">移除吐司元素，这比动画包便宜。</strong></p><p id="d1db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 toast 状态下，使用上面添加的相同属性<code class="fe mt mu mv mj b">visible</code>:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d694" class="mn lm in mj b gy mo mp l mq mr">// toast state<br/>@Injectable({ providedIn: 'root' })<br/>export class Toast {<br/>  // ...<br/>  Show(code: string, options?: IToast): void {<br/>    // completely remove when new message comes in<br/>    this.Remove();<br/>    <br/>    // ... <br/>    this.toast.next({ ..._options, text: message, visible: true });<br/>    <br/>    // ... timeout and Hide<br/>  }<br/>  <br/>  // make two distinct functions<br/>  Hide() {</span><span id="4c15" class="mn lm in mj b gy ms mp l mq mr">    // this is hide by adding state only and letting component do the rest (animationend)<br/>    this.toast.next({ ...this.toast.getValue(), visible: false });<br/>  }<br/>  <br/>  Remove() {<br/>    if(this.isCanceled) {<br/>      this.isCanceled.unsubscribe();<br/>    }<br/>    // this removes the element<br/>    this.toast.next(null);<br/>  }<br/>}</span></pre><p id="0d66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的<code class="fe mt mu mv mj b">css</code>中，我们添加了动画序列:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="85fb" class="mn lm in mj b gy mo mp l mq mr">.toast {<br/>  /*...*/<br/>  <br/>  /*add animation immediately*/<br/>  animation: toast-in .2s ease-in-out;<br/>}<br/>/*add outview animation*/<br/>.toast.outview {<br/>  animation: toast-out 0.1s ease-in-out;<br/>  animation-fill-mode: forwards;<br/>}</span><span id="a8bd" class="mn lm in mj b gy ms mp l mq mr">@keyframes toast-in {<br/>    0% {<br/>        transform: translateY(calc(100% + 10px);<br/>    }<br/>    100% {<br/>        transform: translateY(0);<br/>    }<br/>}</span><span id="dbb3" class="mn lm in mj b gy ms mp l mq mr">@keyframes toast-out {<br/>    0% {<br/>        transform: translateY(0);<br/>    }</span><span id="5906" class="mn lm in mj b gy ms mp l mq mr">    100% {<br/>        transform: translateY(calc(100% + 10px));<br/>    }<br/>}</span></pre><p id="5083" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，在我们的组件中，我们做了扭转，观察<code class="fe mt mu mv mj b">animationend</code>移除吐司。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="a086" class="mn lm in mj b gy mo mp l mq mr">@Component({<br/>    selector: 'gr-toast',<br/>    template: `<br/>    &lt;ng-container *ngIf="toastState.toast$ | async as toast"&gt;<br/>    &lt;!-- here add outview when toast is invisible, then watch animationend --&gt;<br/>      &lt;div [class.outview]="!toast.visible" (animationend)="doRemove($event)"<br/>      class="{{ toast.css}} {{toast.extracss}}"&gt;<br/>        &lt;div class="text"&gt;{{toast.text }}&lt;/div&gt;<br/>        &lt;div class="buttons" *ngIf="toast.buttons.length"&gt;<br/>            &lt;button *ngFor="let button of toast.buttons"<br/>            [class]="button.css"<br/>            (click)="button.click($event)" &gt;{{button.text}}&lt;/button&gt;<br/>        &lt;/div&gt;</span><span id="d0e8" class="mn lm in mj b gy ms mp l mq mr">      &lt;/div&gt;<br/>    &lt;/ng-container&gt;<br/>    `,<br/>    changeDetection: ChangeDetectionStrategy.OnPush,<br/>    styleUrls: ['./toast.less'],<br/>})<br/>export class ToastPartialComponent {<br/>    constructor(public toastState: Toast) {<br/>    }<br/>    // on animation end, remove element<br/>    doRemove(e: AnimationEvent) {<br/>        if (e.animationName === 'toast-out') {<br/>            this.toastState.Remove();<br/>        }<br/>    }<br/>}</span></pre><p id="9488" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">长得丑？是的，所以如果我们真的想删除元素，我们的另一个选择是一个巨大的样板文件，称为角动画包。</p><h2 id="825d" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">3.角度动画包</h2><p id="89f7" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Angular 的动画包神奇地处理了这个问题。</p><blockquote class="ni nj nk"><p id="d5bd" class="ko kp mw kq b kr ks jo kt ku kv jr kw nl ky kz la nm lc ld le nn lg lh li lj ig bi translated"><em class="in">我试图找到代码，但是我不太明白 ngIf 被忽略直到动画结束的机制。你能找到兔子吗？请在评论中告诉我。</em></p></blockquote><p id="ed2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先撤销上面的操作，将动画包添加到根目录。css 应该不再有任何动画，状态应该简单地显示和隐藏(不需要<code class="fe mt mu mv mj b">visible</code>属性)。然后在组件中，我们添加以下内容:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="0f43" class="mn lm in mj b gy mo mp l mq mr">@Component({<br/>  selector: 'gr-toast',<br/>  template: `<br/>  &lt;ng-container *ngIf="toastState.stateItem$ | async as toast"&gt;<br/>    &lt;div @toastHideTrigger class="{{ toast.css}} {{toast.extracss}}" &gt;<br/>      The only change is @toastHideTrigger <br/>      ...<br/>  &lt;/ng-container&gt;<br/>  `,<br/>  // add animations<br/>  animations: [<br/>    trigger('toastHideTrigger', [<br/>      transition(':enter', [<br/>        // add transform to place it beneath viewport<br/>        style({ transform: 'translateY(calc(100% + 10px))' }),<br/>        animate('0.2s ease-in', style({transform: 'translateY(0)' })),<br/>      ]),<br/>      transition(':leave', [<br/>        animate('0.2s ease-out', style({transform: 'translateY(calc(100% + 10px))'  }))<br/>      ])<br/>    ]),<br/>  ]<br/>})<br/>// ...</span></pre><p id="5566" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能会有偏好，比如在 angular 中使用动画包，我看不出有什么附加价值。我喜欢的方法是简单的，把它放在页面上，永远不要删除。</p><h2 id="1f2d" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">轻微的增强</h2><p id="a482" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">你可能注意到了我们在显示之前隐藏了<strong class="kq io">，变化如此之快，以至于显示新消息的动画并没有开始。为了解决这个问题，我们可以将节目延迟几毫秒，以确保动画开始播放。在我们的<code class="fe mt mu mv mj b">Show</code>法中:</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="b144" class="mn lm in mj b gy mo mp l mq mr">// Show method, wait milliseconds before you apply<br/>// play a bit with the timer to get the result you desire<br/>timer(100).subscribe(() =&gt; {<br/>  // add visible: true if you are using the first or second method<br/>  this.toast.next({ ..._options, text: message  });<br/>});</span></pre><p id="5c1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们使用第二种(扭曲的)方法时，这个效果是最完美的。因为这是唯一一个两个连续的消息，强制删除第一个没有动画，这是理想的行为。</p><p id="125f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看看<a class="ae lk" href="https://stackblitz.com/edit/angular-error-toast?file=src/app/app.component.html" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上的结果。</p><h1 id="2d79" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">基于 RxJS 的状态管理</h1><p id="654d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">如果你正在跟进，我不久前在 Angular 中介绍了基于 RxJS 的状态管理。这个烤面包器可以如下利用它:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c71b" class="mn lm in mj b gy mo mp l mq mr">// to replace state with our State Service<br/>// first, extend the StateService of IToast<br/>export class Toast extends StateService&lt;IToast&gt; {<br/>  <br/>  // then remove the internal observable<br/>  // private toast: BehaviorSubject&lt;IToast | null&gt; = new BehaviorSubject(null);<br/>  // toast$: Observable&lt;IToast | null&gt; = this.toast.asObservable();<br/>  <br/>  constructor() {<br/>    // call super<br/>    super();<br/>    // set initial state<br/>    this.SetState(this.defaultOptions);<br/>  }</span><span id="69b4" class="mn lm in mj b gy ms mp l mq mr">  // ...<br/>  Show(code: string, options?: IToast) {<br/>    // ... <br/>    // use state instead of this<br/>    // this.toast.next({ ..._options, text: message });<br/>    this.SetState({ ..._options, text: message });<br/>  }<br/>  Hide() {<br/>    // ...<br/>    // use state instead<br/>    // this.toast.next(null);<br/>    this.RemoveState();<br/>    <br/>    // or update state<br/>    this.UpdateState({ visible: false });<br/>  }<br/>}</span></pre><p id="8d48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模板现在应该看<code class="fe mt mu mv mj b">toastState.stateItem$</code>，而不是<code class="fe mt mu mv mj b">toastState.toast$</code>。</p><p id="09b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是所有的乡亲。你找到兔子了吗？让我知道。</p><h1 id="f874" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">资源</h1><ul class=""><li id="0b42" class="no np in kq b kr md ku me kx nq lb nr lf ns lj nt nu nv nw bi translated"><a class="ae lk" href="https://stackblitz.com/edit/angular-error-toast" rel="noopener ugc nofollow" target="_blank"> StackBlitz 项目</a></li><li id="446b" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" href="https://angular.io/guide/transition-and-triggers#enter-and-leave-aliases" rel="noopener ugc nofollow" target="_blank">角度动画:进入和离开别名</a></li><li id="5f56" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/animationend_event" rel="noopener ugc nofollow" target="_blank"> HTML 动画结束事件</a></li></ul><h2 id="2e5a" class="mn lm in bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">控制台系列</h2><ul class=""><li id="c5f3" class="no np in kq b kr md ku me kx nq lb nr lf ns lj nt nu nv nw bi translated"><a class="ae lk" href="https://medium.com/@aayyash/writing-a-wrapper-for-console-log-for-better-control-in-javascript-part-i-9bbd238fb9ad" rel="noopener">为 console.log 编写一个包装器以更好地控制 JavaScript，第一部分</a></li><li id="a72b" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii-5b09b65af2c5">为 console.log 编写一个包装器，以便更好地控制 Angular，第二部分</a></li><li id="c9e8" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" href="https://medium.com/@aayyash/catching-and-handling-errors-in-angular-3ac6b95853ba" rel="noopener">捕捉和处理角度误差</a></li><li id="eb11" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/catching-and-displaying-ui-errors-with-toast-messages-in-angular-db06f2605a6d">用 toast 消息捕获并显示 UI 错误</a></li><li id="34be" class="no np in kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><a class="ae lk" href="https://medium.com/@aayyash/auto-hiding-a-toast-message-in-angular-54f886ad6129" rel="noopener">自动隐藏有角度的祝酒辞</a></li></ul></div></div>    
</body>
</html>