<html>
<head>
<title>Passthru: Monitoring HTTP traffic via a very simple proxy implementation with Zuul</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Passthru:使用Zuul通过一个非常简单的代理实现来监控HTTP流量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/passthru-monitoring-http-traffic-via-a-very-simple-proxy-implementation-with-zuul-ebe0f6f2c386?source=collection_archive---------1-----------------------#2020-10-28">https://blog.devgenius.io/passthru-monitoring-http-traffic-via-a-very-simple-proxy-implementation-with-zuul-ebe0f6f2c386?source=collection_archive---------1-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/47235b09f2df088638fd4c4d97097f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWZ4ZaS3KxoU0ZpZyitzuQ.png"/></div></div></figure><p id="ace8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">曾几何时，有一个名为<a class="ae kt" href="https://ws.apache.org/tcpmon/" rel="noopener ugc nofollow" target="_blank"> TCPMon </a>的工具用于检查HTTP流量，对于调试web服务(SOAP和其他HTTP服务)非常方便。基本上，它充当一个代理，将流量转发到目标服务，同时记录请求/响应并通过Swing UI显示。这是我参与的许多项目的救命稻草。</p><p id="082d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不幸的是，TCPMon不再被维护，而且在容器化的环境中使用也不太方便。此外，我找不到一个简单的即插即用的替代品来达到同样的目的。当然，像Nginx或HAProxy这样的代理可以很容易地监控和记录请求，但我发现它们在配置开发时并不方便。(老实说，我也发现Lua配置有点令人生畏)</p><h1 id="91f3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第一次尝试:Servlet</h1><p id="5616" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以我决定尝试使用Spring Boot+科特林实现一个非常简单的代理。我最初的想法是实现一个简单的servlet，将请求转发到目标主机(作为环境变量传递，所以在Docker compose环境中也很容易配置)。当流量通过时，servlet会将请求记录到控制台。所以我把它命名为<strong class="jx io"> <em class="lx">直通</em> </strong>。</p><p id="efd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Passthru Servlet应该处理传入的Http请求，重新创建、分派、处理响应并记录处理所有编码、头、参数和有效负载的内容。我对自己实现所有这些并不太放心。这些应该已经被比我更有时间和承诺的人解决了。</p><h1 id="27f2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Zuul Gateway</h1><p id="399f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因此，我继续挖掘，发现了网飞的作品。我听说Zuul是API网关，但没有机会尝试。基本上，Zuul是一个应用级网关，幸运的是，它可以直接与Spring集成。此外，Zuul提供了RequestContext对象，使开发人员能够存储请求范围的数据(在线程本地对象中)。</p><p id="7214" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个PassthruContext类来记录请求响应信息，如下所示:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="f9cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我需要做的一切似乎很简单:</p><ol class=""><li id="532c" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">实现一个预过滤器来拦截请求并将其记录在上下文中。</li><li id="2f6c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">实现一个后置过滤器来处理响应并在上下文中记录。</li><li id="de62" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">记录PassthruContext(到控制台)</li></ol><p id="7f53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，它并不像我开始预期的那样顺利。在路上我必须克服一些障碍。在接下来的部分中，我将回顾这些步骤以及我必须解决的小故障。</p><h1 id="0407" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">预过滤器</h1><p id="8316" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这一部分非常简单，我所要做的就是提取请求方法、头和有效载荷，并将它们保存在上下文中。你可以看到下面的代码。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="3c9d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">后置过滤器</h1><p id="a85c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在阅读了上一节之后，人们可以很容易地认为处理响应也很简单。我们将解析响应头、主体和状态代码，对吗？嗯，没那么快。在响应处理过程中，我们需要解决许多问题</p><h2 id="06db" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">使用响应输入流</h2><p id="aa06" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">关于Java输入流的一个不太有趣的事情是，如果您使用了一次输入流，就不能保证您能够重绕它。这是因为有些InputStream实现是缓冲的，而有些实现不是。对于Zuul，可以重新读取请求输入流；但不是Zuul响应输入流</p><p id="1745" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，一种方法是将请求读入缓冲区(即字节数组)；从原始输入流构造另一个输入流，并用新的输入流替换原始输入流。Zuul还在上下文中提供了responseBody字段；因此，一旦解析了响应，也可以将主体设置为字符串。你可以看到下面的片段。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="0508" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">Gzip内容</h2><p id="ae53" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在记录请求内容时，我们还必须处理另一个细节。现代HTTP交换内容以Gzip格式压缩，而不是纯文本格式。因此，我们将要使用的响应输入流很可能是在Gzip中。所以我们需要在记录之前提取Gzip内容，并把它作为输入流放回去。</p><p id="79c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在下面看到我们如何在后置过滤器中做到这一点。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="22d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们的post过滤器看起来像这样:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="76c0" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">带主体的HTTP GET</h2><p id="6854" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">到目前为止，我们能够处理大多数HTTP请求，这很好。如果我们处理有主体的GET请求(比如Elasticsearch查询)，我们需要考虑一个更微妙的问题。GET请求中的Body是一个有争议的话题，许多实现都不支持它。不幸的是，Zuul是在HTTP GET中省略主体的实现之一。在路由阶段，SimpleHostRoutingFilter在传出的HttpRequest中忽略GET请求体。</p><p id="5cad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过以下步骤解决这个问题:</p><ol class=""><li id="aad8" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">禁用<em class="lx"> SimpleHostRoutingFilter </em></li><li id="23b3" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">实现我们自己的路由过滤器并替换被禁用的过滤器。</li></ol><p id="a15d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以禁用<em class="lx"> SimpleHostRoutingFilter </em>，包括应用程序中的以下行</p><pre class="ly lz ma mb gt ne nf ng nh aw ni bi"><span id="ca63" class="ms kv in nf b gy nj nk l nl nm">zuul.SimpleHostRoutingFilter.route.disable: true</span></pre><p id="3641" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们需要实现自己的路由过滤器，从现有的(禁用的)过滤器扩展而来。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="dae5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们创建了一个能够封装实体的HttpRequest对象。其余的代码是样板文件，复制了基本实现中的一些私有方法/字段。</p><h2 id="99cc" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">将流量记录到控制台</h2><p id="8b2d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这部分很简单。为了简洁起见，我将跳过这一部分。可以参考来源<a class="ae kt" href="https://github.com/itasyurt/passthru" rel="noopener ugc nofollow" target="_blank">代号</a>。</p><h2 id="ae7a" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">应用程序属性</h2><p id="aed2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们有以下应用程序属性</p><pre class="ly lz ma mb gt ne nf ng nh aw ni bi"><span id="4156" class="ms kv in nf b gy nj nk l nl nm">zuul.routes.passhtru.url: ${passthru.target}<br/>zuul.routes.passhtru.path: /**<br/>zuul.SimpleHostRoutingFilter.route.disable: true<br/><br/>ribbon.eureka.enabled=false</span></pre><p id="b82a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前两行是将所有流量路由到目标服务器，其中第三行禁用SimpleHostRoutingFilter，最后一行禁用Eureka。</p><h2 id="7b67" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">结论</h2><p id="0292" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在这篇文章中，我试图总结我使用Spring Boot+Zuul +Kotlin实现一个简单代理服务器的经验。你可以在这个<a class="ae kt" href="https://github.com/itasyurt/passthru" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到完整的源代码。请注意，这是一个非生产质量的努力，旨在自我学习和探索。</p></div></div>    
</body>
</html>