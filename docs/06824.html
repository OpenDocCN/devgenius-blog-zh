<html>
<head>
<title>I tried to find MongoDB connection strings over 1000 public GitHub repositories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我试图在 1000 多个公共 GitHub 存储库中找到 MongoDB 连接字符串</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/i-tried-to-find-mongodb-connection-strings-over-1000-public-github-repositories-b870cb3bcac5?source=collection_archive---------18-----------------------#2022-02-05">https://blog.devgenius.io/i-tried-to-find-mongodb-connection-strings-over-1000-public-github-repositories-b870cb3bcac5?source=collection_archive---------18-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ce36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我试着通过在 GitHub search 上搜索就能得到别人的 Mongo 数据库连接字符串。是的，我找到了一些。我试着连接了几个，是的，成功了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7966b4cc940e8657232817f66e7ee6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnl4ybDeg2_e4UbwBUOP2w.png"/></div></div></figure><p id="23ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你报警之前，请听听我的背景故事。🙏🏽</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/453f63ab74e6edcbc758b293ef44aca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*jzWkGuBSbTVqtQacKn4y2w.gif"/></div></figure><p id="1066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我正在开发一个 NodeJS/Express 应用程序，我记得我按了<em class="kv">。env </em>文件到我的远程存储库。在修复这个错误的过程中，我想到了有多少人会犯这个错误，即使秘密最终没有被公开，它也会留在提交历史中的某个地方。<br/>所以我上钩了，做了这个<a class="ae kw" href="https://github.com/search?p=1&amp;q=mongodb%2Bsrv%3A&amp;type=Code" rel="noopener ugc nofollow" target="_blank"> GitHub 搜索</a>。虽然大多数结果都不是实际的连接字符串，但是其中很多仍然有效。</p><p id="73e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[免责声明:没有恶意，这只是为了引起公众的注意]</p><h2 id="8c76" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">我是如何浏览 1000 个知识库的</h2><p id="333a" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">实际上，<a class="ae kw" href="https://docs.github.com/en/rest/reference/search#about-the-search-api" rel="noopener ugc nofollow" target="_blank"> GitHub 搜索 API 限制每次搜索 1000 个结果</a>。使用下面的脚本，我能够生成代码包含<em class="kv"> mongodb+srv: </em>的存储库</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f8a8" class="kx ky in lw b gy ma mb l mc md">// index.ts<br/>import dotenv from “dotenv”<br/>dotenv.config()</span><span id="ab2a" class="kx ky in lw b gy me mb l mc md">import axios from “axios”;<br/>import fs from “fs/promises”;<br/>import cliProgress from “cli-progress”;</span><span id="a5d9" class="kx ky in lw b gy me mb l mc md">const jsonpath = “list_of_repo.json”;</span><span id="cb9b" class="kx ky in lw b gy me mb l mc md">const makeSearch = async (page: number) =&gt; {<br/> const config = {<br/> headers: {<br/> Authorization: `Token ${process.env.GITHUB_API_TOKEN}`,<br/> },<br/> };</span><span id="e05d" class="kx ky in lw b gy me mb l mc md">const url = `<a class="ae kw" href="https://api.github.com/search/code?q=mongodb%2Bsrv+in:file&amp;page=${page}&amp;per_page=100`" rel="noopener ugc nofollow" target="_blank">https://api.github.com/search/code?q=mongodb%2Bsrv+in:file&amp;page=${page}&amp;per_page=100`</a>;<br/> const result: {<br/> items: { html_url: string; repository: { html_url: string } }[];<br/> } = await axios.get(url, config);</span><span id="ee46" class="kx ky in lw b gy me mb l mc md">// make an an object from result<br/> let obj = {};<br/> result.data.items.forEach((item) =&gt; {<br/> obj[item.repository.html_url] = item.html_url;<br/> });</span><span id="8d8d" class="kx ky in lw b gy me mb l mc md">await addToJson(jsonpath, obj);<br/>};</span><span id="05d5" class="kx ky in lw b gy me mb l mc md">async function addToJson(jsonpath: string, data?: object) {<br/> const oldJson = (await fs.readFile(jsonpath)).toString();<br/> let jsonData = JSON.stringify(data, null, 2);</span><span id="59f9" class="kx ky in lw b gy me mb l mc md">if (oldJson) {<br/> jsonData = JSON.stringify(<br/> { …JSON.parse(oldJson), …JSON.parse(jsonData) },<br/> null,<br/> 2<br/> );<br/> }</span><span id="2023" class="kx ky in lw b gy me mb l mc md">await fs.writeFile(jsonpath, jsonData);<br/>}</span><span id="592e" class="kx ky in lw b gy me mb l mc md">async function main() {<br/> // I included a CLI progress loader because, who doesn’t like a loader.<br/> const bar1 = new cliProgress.SingleBar(<br/> {},<br/> cliProgress.Presets.shades_classic<br/> );<br/> // number of iteration 10<br/> bar1.start(10, 0);<br/> for (let i = 1; i &lt;= 10; i++) {<br/> await makeSearch(i);<br/> bar1.update(1);<br/> }<br/> bar1.stop();<br/>}</span><span id="3b1c" class="kx ky in lw b gy me mb l mc md">main();</span></pre><p id="75d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提供的结果并不意味着实际的 MongoDB 连接字符串存在，它只是暗示结果中的存储库有一个与<em class="kv"> mongodb+srv: </em>匹配的文件内代码</p><p id="edb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我可以进一步创建一个脚本来搜索每个代码 URL，并运行一个正则表达式来进一步查找实际的连接字符串，但这不是必需的，因为我的目的是提高公众意识以及如何保护我们自己。</p><h2 id="50aa" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">我发现了什么以及我们如何保护自己</h2><p id="9cd2" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">我的一些发现包括:</p><p id="e664" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">- <strong class="jm io">一些结果在提交历史中包含旧的提交</strong>:就像我导致这篇文章的错误一样，有时我们忘记创建一个<em class="kv">。gitignore </em>文件，并在提交历史的某个地方准备一些秘密。<br/> <br/>我们可以利用像<a class="ae kw" href="https://www.gitguardian.com/" rel="noopener ugc nofollow" target="_blank"> GitGuardian </a>这样的工具不断扫描我们的回购协议，寻找源代码中的秘密。<br/> <br/> - <strong class="jm io">一些结果包含了来自不同日志文件和环境文件的消息:</strong>这可能是由于没有包含一个<em class="kv">. git ignore .</em><br/><br/>GitHub 提供了一个<a class="ae kw" href="https://github.com/github/gitignore" rel="noopener ugc nofollow" target="_blank"> repo </a>和众多类型的<em class="kv">。gitignore </em>不同语言的模板，框架，工具，IDE e . t . c .<br/>T21【我创建了一个简单的交互式 CLI 来生成<em class="kv">。gitignore </em>基于 GitHub 列表的模板。</p><p id="2df6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以找到交互式 CLI 工具来生成您的<em class="kv">。gitignore </em>模板此处:<a class="ae kw" href="https://www.npmjs.com/package/gittyignore](https://www.npmjs.com/package/gittyignore)" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/gittyignore</a></p><p id="b6f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您通读！🤗</p></div></div>    
</body>
</html>