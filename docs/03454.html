<html>
<head>
<title>Best of Modern JavaScript — Generator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—生成器函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-generator-functions-2ed9ba1e29a8?source=collection_archive---------3-----------------------#2020-11-06">https://blog.devgenius.io/best-of-modern-javascript-generator-functions-2ed9ba1e29a8?source=collection_archive---------3-----------------------#2020-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa9b34ceee04a0bfd2f5058ee1b2ef70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O9JROX8Ek3fYN6Ru"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sobermusings?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡洛·维拉里卡</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript生成器。</p><h1 id="c56b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过生成器实现可迭代对象</h1><p id="3a61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Iterables可以用生成器来实现。</p><p id="2cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Symbol.iterable</code>方法创建一个可迭代的对象，使它成为可迭代的。</p><p id="0ad5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6b21" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  *[Symbol.iterator]() {<br/>    yield 1;<br/>    yield 2;<br/>    yield 3;<br/>  }<br/>}</span></pre><p id="7b91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe me mf mg mh b">Symbol.iterator</code>方法中有<code class="fe me mf mg mh b">yield</code>关键字。</p><p id="1fd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="48d0" class="mq lc iq mh b gy mr ms l mt mu">for (const x of obj) {<br/>  console.log(x);<br/>}</span></pre><p id="619c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迭代这些值，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d424" class="mq lc iq mh b gy mr ms l mt mu">1<br/>2<br/>3</span></pre><p id="f73f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">obj[Symbol.iterator]</code>是一个生成器方法，它生成我们可以迭代的值。</p><p id="95c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-使用该方法作为迭代器来获取值。</p><h1 id="d858" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无限迭代</h1><p id="8d7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用生成元来制造无穷大的变量。</p><p id="0b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="edf4" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  *[Symbol.iterator]() {<br/>    for (let n = 0;; n++) {<br/>      yield n;<br/>    }<br/>  }<br/>}</span><span id="db6e" class="mq lc iq mh b gy mv ms l mt mu">function* take(n, iterable) {<br/>  for (const x of iterable) {<br/>    if (n &lt;= 0) {<br/>      return;<br/>    }<br/>    n--;<br/>    yield x;<br/>  }<br/>}</span><span id="c0ae" class="mq lc iq mh b gy mv ms l mt mu">for (const x of take(5, obj)) {<br/>  console.log(x);<br/>}</span></pre><p id="8529" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的可迭代<code class="fe me mf mg mh b">obj</code>对象有生成整数的<code class="fe me mf mg mh b">Symbol.iterator</code>方法。</p><p id="d83b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了<code class="fe me mf mg mh b">take</code>函数来从<code class="fe me mf mg mh b">iterable</code>中产生第一个<code class="fe me mf mg mh b">n</code>项。</p><p id="f161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们遍历返回的变量。</p><h1 id="605a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">惰性求值的生成器</h1><p id="4d1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器对于惰性求值很有用。</p><p id="98fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个从字符串中产生单个字符的函数。</p><p id="8dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们遍历字符串并得到密钥。</p><p id="827d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1cc6" class="mq lc iq mh b gy mr ms l mt mu">function* tokenize(str) {<br/>  for (const s of str) {<br/>    yield s;<br/>  }<br/>}</span><span id="9682" class="mq lc iq mh b gy mv ms l mt mu">let c;<br/>const gen = tokenize('foobar');</span><span id="c0b3" class="mq lc iq mh b gy mv ms l mt mu">while (c = gen.next().value) {<br/>  console.log(c);<br/>}</span></pre><p id="9a7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从对象中获取值。</p><h1 id="f693" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">继承和迭代器</h1><p id="db3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以像其他函数一样用生成器函数实现继承。</p><p id="8ad1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码向生成器添加一个实例方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7fd4" class="mq lc iq mh b gy mr ms l mt mu">function* g() {}<br/>g.prototype.foo = function() {<br/>  return 'bar'<br/>};<br/>const obj = g();<br/>console.log(obj.foo());</span></pre><p id="8784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向<code class="fe me mf mg mh b">prototype</code>属性添加了<code class="fe me mf mg mh b">foo</code>方法。</p><p id="02d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">g</code>生成器函数返回生成器。</p><p id="5cb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在它上面调用<code class="fe me mf mg mh b">foo</code>方法。</p><p id="5994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台日志应该记录了<code class="fe me mf mg mh b">'bar'</code>。</p><p id="3a0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图得到迭代器的原型。</p><p id="8737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="162e" class="mq lc iq mh b gy mr ms l mt mu">const getProto = Object.getPrototypeOf.bind(Object);<br/>console.log(getProto([][Symbol.iterator]()));</span></pre><p id="6924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到了<code class="fe me mf mg mh b">Array Iterator</code>物体。</p><p id="16bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有迭代器原型的<code class="fe me mf mg mh b">next</code>方法和其他属性。</p><h1 id="d434" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">this</code>在发电机中</h1><p id="761c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">发电机功能有自己的值<code class="fe me mf mg mh b">this</code>。</p><p id="1731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个设置并返回一个生成器对象的函数。</p><p id="189e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含生成器对象单步执行的代码。</p><p id="df7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写来看<code class="fe me mf mg mh b">this</code>的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d8cf" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  yield this;<br/>}</span><span id="f25a" class="mq lc iq mh b gy mv ms l mt mu">const [genThis] = gen();<br/>console.log(genThis)</span></pre><p id="99e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它在顶层，我们像析构一样得到了<code class="fe me mf mg mh b">this</code>的值，我们得到了窗口对象。</p><p id="e5ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是假设严格模式关闭。</p><p id="0e03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果严格模式打开:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c7b6" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  'use strict';<br/>  yield this;<br/>}</span></pre><p id="4854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">genThis</code>就是<code class="fe me mf mg mh b">undefined</code>。</p><p id="3658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的生成器在一个对象中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bcb9" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  'use strict';<br/>  yield this;<br/>}</span><span id="0e22" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  gen<br/>}</span><span id="8d5b" class="mq lc iq mh b gy mv ms l mt mu">const [genThis] = obj.gen();<br/>console.log(genThis);</span></pre><p id="a45e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">genThis</code>就是物体本身。</p><p id="0e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器函数类似于传统函数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/20e1064625cfc9d83f1dd814ada76182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WAoCWXCIfHb5Q234"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@rashevsky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Anastasia Palagutina </a>拍摄</figcaption></figure><h1 id="f713" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9a3a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Iterables可以用生成器来实现。</p><p id="da45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以实现继承，并用生成器函数得到<code class="fe me mf mg mh b">this</code>的值。</p></div></div>    
</body>
</html>