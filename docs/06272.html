<html>
<head>
<title>A simple guide to atomics in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中原子的简单指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-simple-guide-to-atomics-in-c-670fc4842c8b?source=collection_archive---------0-----------------------#2021-12-27">https://blog.devgenius.io/a-simple-guide-to-atomics-in-c-670fc4842c8b?source=collection_archive---------0-----------------------#2021-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aef2a9b8cc88adb19fab3e9256707863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-tLYgoPcfh-BGtVf"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">丹·迈耶斯在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="230e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当计算机科学中的某个东西被称为“原子”时，经常会出现混淆。在大多数情况下，它可能只是意味着某个过程发生在一个单独的步骤或操作中。然而，在 C++中，原子性的定义要具体得多。相反，使用<code class="fe ky kz la lb b">std::atomic</code>类和类型并不能确保所有代码都是真正的原子代码。尽管原子类型是 C++语言的一部分，但是无论程序运行在什么硬件上，原子操作都必须得到支持。本指南是理解 C++中原子性的简单指南。</p><h1 id="73cc" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">类型</h1><p id="ef9e" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在 C++中，<code class="fe ky kz la lb b">std::atomic&lt;&gt;</code>模板类可以用来包装许多其他类型，以便于对该类型进行原子操作。不过，该模板并不保证任何操作实际上都是原子的。如果当前 CPU 不支持任何原子操作，编译器将使用基于互斥体的回退。幸运的是，有一个有用的函数和原子类型的保证布尔成员来帮助你检查 CPU 是否支持原子操作</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ceeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的观念也指出了关于原子的另一个重要事实，只有操作是原子的，而不是类型或数据。就其代表的底层数据而言，<code class="fe ky kz la lb b">int</code>与<code class="fe ky kz la lb b">std::atomic&lt;int&gt;</code>没有什么不同。只有对数据的操作可以是原子的。此外，<code class="fe ky kz la lb b">std::atomic&lt;&gt;</code>类型是以这样一种方式设计的，即只有原子操作才能应用于一个类型所代表的数据，而不能混合原子和非原子操作。</p><h1 id="6c7d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">装载和存储</h1><p id="7b8a" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">最基本的原子操作是加载和存储。尽管您可能会想到短语“在变量中存储值”，但这并不是原子存储真正发生的情况。首先，记住原子的目的是允许多线程以线程安全的方式修改数据。要做到这一点，这些数据必须存在于共享内存或缓存中。因此，根据处理器架构，原子加载将数据从共享内存加载到寄存器或线程专用内存。原子存储以原子方式将数据移动到共享内存中。</p><p id="4f70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了真正理解操作(如加载或存储)的原子性质，让我们先来看看原子性是什么样子的。</p><h2 id="4981" class="ml ld in bd le mm mn dn li mo mp dp lm kl mq mr lq kp ms mt lu kt mu mv ly mw bi translated">原子性，一个时间点</h2><p id="386b" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在时间<em class="mx"> t1 </em>取一个值为 3 的变量<em class="mx"> a </em>。如果在<em class="mx"> t1 </em>向 a 施加原子负载，该负载将检索值 3。然而，如果在下一个时间点<em class="mx"> t2 </em>施加负载，则可能检索到不同于 3 的值，这仅仅是因为另一个操作可能已经在<em class="mx"> t1 </em>发生。</p><p id="4c2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设变量<em class="mx"> a </em>用值 1 初始化，使得在应用任何操作之前<em class="mx"> a </em>的表示必须是 1。如果一个存储操作，然后一个加载操作被应用到一个，则绝对不能保证加载操作将从存储操作中检索存储的值。这是因为加载和存储发生在两个不同的时间点。原子的经验法则是，在任意两个时间点之间可以有无限多的操作。</p><p id="67d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们把它们放在一个代码示例中。这里，两个线程都试图将一个值存储然后加载到同一个原子整数中。一个布尔标志协调两个线程几乎同时启动。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e394" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您编译并运行这个程序，您可能会得到如下结果</p><pre class="mf mg mh mi gt my lb mz na aw nb bi"><span id="b90d" class="ml ld in lb b gy nc nd l ne nf">t1 0 - 3<br/>t1 1 - 3<br/>t1 2 - 3<br/>t1 3 - 3<br/>t1 4 - 3<br/>t1 5 - 3<br/>t1 6 - 3<br/>t1 7 - 3<br/>t1 8 - 3<br/>t1 9 - 3<br/>t2 0 - 6<br/>t2 1 - 6<br/>t2 2 - 6<br/>t2 3 - 6<br/>t2 4 - 6<br/>t2 5 - 6<br/>t2 6 - 6<br/>t2 7 - 6<br/>t2 8 - 6<br/>t2 9 - 6</span></pre><p id="704b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能看起来很奇怪，因为它表明每个线程都能够加载存储的内容。这个程序可能的操作顺序是线程<code class="fe ky kz la lb b">t1</code>加载开始变量，然后完成所有的加载和存储，然后<code class="fe ky kz la lb b">t2</code>加载开始变量，并完成所有的加载和存储。为了测试这一点，我们可以在存储和加载之间添加一些“旋转”。这相当于一个线程做了不在共享内存空间中的额外工作，就像<code class="fe ky kz la lb b">for (int k = 0; k &lt; 1000; ++k);</code>。如果我们这样做并运行程序，每个线程加载的内容之间的差异开始出现。</p><h1 id="425d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">交换</h1><p id="16c5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">交换也称为交换，是一种原子操作，它替换原子变量中的某个值，并返回先前存在的值。交换的功能是存储，然后在单个原子操作中加载。但是，它不会在操作之前检查原子变量的值。因此，交换也可以被认为是无条件的。交易所不提供加载然后存储的原子解决方案。</p><p id="6d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">交换操作也称为缓存一致性。这意味着，在交换之后，任何反映交换写入变量的值的操作。为了说明这一点，可以使用一个具有单个工作线程的示例。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dacc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，工作线程被赋予了一个交换 100，000 次值的大任务。在此期间，主函数将存储在<code class="fe ky kz la lb b">foobar</code>中的值更改为<code class="fe ky kz la lb b">14</code>。主函数交换后的每个后续调用现在返回<code class="fe ky kz la lb b">14</code>。</p><h1 id="7d60" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">提取操作</h1><p id="3981" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">提取操作，例如提取和添加，或者提取和减去，将一些操作应用到原子变量，并且提取在应用操作之前存储的值。提取操作的工作方式类似于交换，从这个意义上说，原子交换只是写入一个值并“提取”前一个值。有几种类型的获取操作，C++支持以下几种:</p><ul class=""><li id="7399" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated"><code class="fe ky kz la lb b">fetch_add</code></li><li id="3386" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe ky kz la lb b">fetch_sub</code></li><li id="8d03" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe ky kz la lb b">fetch_and</code></li><li id="3198" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe ky kz la lb b">fetch_or</code></li><li id="1ae9" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe ky kz la lb b">fetch_xor</code></li></ul><p id="ac34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原子获取操作的一个限制是它们只允许等价的后缀操作，比如<code class="fe ky kz la lb b">x++;</code>。提取操作只返回操作之前的值，从不返回操作之后的值。在操作之后返回值将需要额外的原子加载，这将使得这两个操作对于变量值来说不是原子的。下面的例子实现了一个基于<code class="fe ky kz la lb b">fetch_add</code>和<code class="fe ky kz la lb b">fetch_sub</code>操作的计数器</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a4dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果编译并运行的话，</p><pre class="mf mg mh mi gt my lb mz na aw nb bi"><span id="7ffd" class="ml ld in lb b gy nc nd l ne nf">0<br/>1<br/>2<br/>1</span></pre><p id="0662" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最初<code class="fe ky kz la lb b">fetch_sub</code>返回 2 的原因是因为<code class="fe ky kz la lb b">fetch_add</code>在递增值之前返回该值。对<code class="fe ky kz la lb b">fetch_sub</code>的下一个调用返回 1，表明前一个调用在获取前一个值后减去了 1。</p><p id="2e8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能会注意到像乘法和除法这样的典型算术运算没有<code class="fe ky kz la lb b">fetch</code>等价物。原因与原子背后的基本思想有关，它们需要硬件支持。没有支持原子乘法或除法的硬件。尽力而为的方法确实存在，包括在软件中实现它们。一个例子是自动加载一个整数，将其相乘，然后自动存储回来，例如</p><pre class="mf mg mh mi gt my lb mz na aw nb bi"><span id="4572" class="ml ld in lb b gy nc nd l ne nf">std::atomic&lt;int&gt; a(3);<br/>int b = a.load() * 3;<br/>a.store(b);</span></pre><p id="8140" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但这有个问题。在上面的第二个和第三个语句之间，有可能另一个线程改变了<code class="fe ky kz la lb b">a</code>的值，这样“乘以 3”的目标就不起作用了，因为<code class="fe ky kz la lb b">b</code>是<code class="fe ky kz la lb b">a</code>和 3 的前一个值的乘积。简单地将<code class="fe ky kz la lb b">b</code>存储在<code class="fe ky kz la lb b">a</code>中可能会导致数据状态不一致。在这种情况下没有什么危险，没有内存泄漏或分段错误的可能性。然而，在多线程程序中，每个线程都需要有一致的原子数据视图，以成功完成各自的任务。这需要原子操作中的“失败”概念。</p><h1 id="2632" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">比较交换</h1><p id="d3d4" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">比较交换也称为比较和交换(CAS ),是 C++中最强大的原子操作。在大多数情况下，它允许对原子变量的当前值进行原子比较，如果比较结果为真，那么它将尝试存储所需的值。尽管是原子操作，但是如果另一个线程在比较交换读取和写入之间更改了变量值，比较交换肯定会失败。比较交换操作也称为读-修改-写操作(RMW)。</p><p id="56c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">处理器以不同的方式实现比较交换。在一些强有序处理器中，如 x86 处理器，比较交换是在一条汇编指令中完成的。这意味着，只有在比较交换操作完成之前，另一个线程<em class="mx">真正地</em>改变了原子变量的值，比较交换操作才会失败。在弱序处理器上，比较交换是用两条汇编指令实现的，通常是锁定加载和条件存储(LLCS)。由于使用了两条指令，LLCS 可能会暂时失败，例如对于上下文切换的线程。</p><p id="5280" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">C++中有两个比较交换函数，<code class="fe ky kz la lb b">compare_exchange_weak</code>和<code class="fe ky kz la lb b">compare_exchange_strong</code>。弱版本更适合在循环中调用操作的情况。在循环中调用比较交换通常出现在实现无锁数据结构时。举个例子，让我们看看最简单的无锁数据结构，栈。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7fe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，堆栈有两个方法，<code class="fe ky kz la lb b">push</code>和<code class="fe ky kz la lb b">pop</code>。它们中的每一个都满足锁自由的主要标准，一个线程总是取得进展并完成它的 push 或 pop 任务。如果许多线程调用<code class="fe ky kz la lb b">compare_exchange_weak</code>，其中只有一个会成功。所有其他线程都经历了一个失败的<code class="fe ky kz la lb b">compare_exchange_weak</code>，这意味着它们将加载当前存储在变量中的值。该循环允许比较交换操作实质上“对原子变量的最后一个已知值重复”。</p><p id="eded" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个堆栈只有一个点，可以从这个点添加或删除数据。因此，任何操作都依赖于该点的值。只有在栈顶最后一个已知节点上的<code class="fe ky kz la lb b">compare_exchange_weak</code>调用成功时，推送操作才能在原子意义上成功。pop 操作也是如此。</p></div></div>    
</body>
</html>