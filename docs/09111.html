<html>
<head>
<title>Practical Bloom Filters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用布鲁姆过滤器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/practical-bloom-filters-dc49e3deb335?source=collection_archive---------4-----------------------#2022-07-30">https://blog.devgenius.io/practical-bloom-filters-dc49e3deb335?source=collection_archive---------4-----------------------#2022-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="09ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di">答</span>几年前，我想学习更多不同类型的常用数据结构。使用过它们是一回事，但知道它们如何工作或从头开始构建它们是另一回事。在本文中，我们将深入探讨 bloom filters，包括一些代码示例和用例。</p><h1 id="ec32" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是布鲁姆过滤器？</h1><p id="e85a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">根据<a class="ae lx" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">维基百科</a>，一个布隆过滤器是:</p><blockquote class="ly lz ma"><p id="afff" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">一种节省空间的概率数据结构，由 Burton Howard Bloom 于 1970 年提出，用于测试一个元素是否是一个集合的成员。假阳性匹配是可能的，但假阴性是不可能的。</p></blockquote><p id="271d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以本质上，bloom filter 是一个位数组(1/8 字节),其中最初所有的位都被设置为<code class="fe mf mg mh mi b">0</code>。为了向布隆过滤器添加元素，需要散列函数来将该元素“映射”到位数组中的特定位置。两个或更多的元素可以被映射到相同的位置，这可能导致误报(这就是为什么它被称为概率性的)。然而，如果元素位置的位是<code class="fe mf mg mh mi b">0</code>,我们肯定知道它不包含在集合中。</p><h2 id="0e09" class="mj kv iq bd kw mk ml dn la mm mn dp le jy mo mp li kc mq mr lm kg ms mt lq mu bi translated">简而言之:</h2><p id="8c6f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">布隆过滤器可以用于有效地检查元素<strong class="jp ir">是否是集合中包含的</strong> <strong class="jp ir">而不是</strong>。</p><h1 id="83fd" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">真实世界的用法</h1><h2 id="82fc" class="mj kv iq bd kw mk ml dn la mm mn dp le jy mo mp li kc mq mr lm kg ms mt lq mu bi translated">CRLite</h2><p id="2e8c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">2020 年<a class="ae lx" href="https://blog.mozilla.org/security/2020/01/09/crlite-part-2-end-to-end-design/" rel="noopener ugc nofollow" target="_blank"> Mozilla 宣布</a>他们正在开发一个名为 CRLite 的替代方案，用于验证 Firefox 中被撤销的证书。当时，所有未过期的吊销证书的集合在磁盘上损害了 6.7GB，这被压缩为大约 1.3MB 的布隆过滤器。对于有效的证书来说，验证证书是否被撤销是很便宜的，因为它只需要散列证书序列号来获得该位的位置，并验证它是否被设置为<code class="fe mf mg mh mi b">0</code>。</p><h2 id="c2c2" class="mj kv iq bd kw mk ml dn la mm mn dp le jy mo mp li kc mq mr lm kg ms mt lq mu bi translated">卡桑德拉</h2><p id="65d9" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Apache Cassandra <a class="ae lx" href="https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/operations/opsTuningBloomFilters.html" rel="noopener ugc nofollow" target="_blank">使用 bloom filters </a>来确定一个 SSTable 是否有特定分区的数据。验证 SSTable 是否有分区的数据是廉价的，因为它不需要读取其内容(避免 IO 操作)。</p><h1 id="e7bf" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">从头开始建造一个</h1><p id="745f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们将使用 Rust 来创建我们的 bloom filter。让我们从一个包含位数组的简单结构开始:</p><pre class="mv mw mx my gt mz mi na nb aw nc bi"><span id="196d" class="mj kv iq mi b gy nd ne l nf ng">struct BloomFilter&lt;const N: usize&gt; {<br/>    bytes: [u8; N],<br/>}</span><span id="5979" class="mj kv iq mi b gy nh ne l nf ng">impl&lt;const N: usize&gt; BloomFilter&lt;N&gt; {<br/>    fn new() -&gt; Self {<br/>        Self { bytes: [0; N] }<br/>    }<br/>}</span><span id="9ab7" class="mj kv iq mi b gy nh ne l nf ng">fn main() {<br/>    let filter = BloomFilter::&lt;10&gt;::new();<br/>}</span></pre><p id="ba38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个基本结构，它保存我们的位集，并在创建 bloom filter 时将所有位都设置为<code class="fe mf mg mh mi b">0</code>。因为没有办法将单个位表示为一种类型，所以我们的位数组被定义为字节数组。因此，本例中的大小<code class="fe mf mg mh mi b">N</code>是以字节为单位的大小(因为<code class="fe mf mg mh mi b">u8</code>是 Rust 中一个字节的数据类型)，而不是位。</p><p id="113e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要实现的第一件事是向 bloom filter 添加一个新元素。我们需要对值进行 hash 得到一个数值，得到字节的位置，得到字节内部的位的位置，设置为<code class="fe mf mg mh mi b">1</code>。我们将使用字符串作为元素，并使用<code class="fe mf mg mh mi b">DefaultHasher</code>作为散列函数。</p><pre class="mv mw mx my gt mz mi na nb aw nc bi"><span id="37bf" class="mj kv iq mi b gy nd ne l nf ng">use std::collections::hash_map::DefaultHasher;<br/>use std::hash::{Hash, Hasher};</span><span id="df53" class="mj kv iq mi b gy nh ne l nf ng">fn hash(value: &amp;str) -&gt; u64 {<br/>    let mut s = DefaultHasher::new();</span><span id="92e6" class="mj kv iq mi b gy nh ne l nf ng">    value.hash(&amp;mut s);<br/>    s.finish()<br/>}</span><span id="6e34" class="mj kv iq mi b gy nh ne l nf ng">struct BloomFilter&lt;const N: usize&gt; {<br/>    bytes: [u8; N],<br/>}</span><span id="af6f" class="mj kv iq mi b gy nh ne l nf ng">impl&lt;const N: usize&gt; BloomFilter&lt;N&gt; {<br/>    fn new() -&gt; Self {<br/>        Self { bytes: [0; N] }<br/>    }</span><span id="e466" class="mj kv iq mi b gy nh ne l nf ng">    fn add(&amp;mut self, key: &amp;str) {<br/>        let bit_size = N * 8;<br/>        let pos = hash(key) % (bit_size as u64);<br/>        let (byte_idx, bit_idx) = (pos / 8, pos % 8);</span><span id="bd00" class="mj kv iq mi b gy nh ne l nf ng">        self.bytes[byte_idx as usize] |= 1 &lt;&lt; bit_idx;<br/>    }<br/>}</span></pre><p id="338a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有很多东西需要打开。为了获得绝对位位置，对元素进行哈希运算以获得一个数值，并针对位数组的大小使用模运算，以便我们最终得到一个有效的位置。然后我们需要找到字节的位置，并计算相对位的位置。最后，我们通过一个位运算来设置这个位。</p><figure class="mv mw mx my gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ni"><img src="../Images/e8c353d5650e84020092dcd0f0ab1517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ie_a0qn61a66CgXlUQJ2A.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">在<code class="fe mf mg mh mi b"><em class="nu">pos=20</em></code>处添加一个元素</figcaption></figure><p id="c8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是实现一个方法，检查元素<strong class="jp ir">是否不包含在集合中。这个过程类似于添加一个元素，但是我们需要检查它的值，而不是设置这个位。</strong></p><pre class="mv mw mx my gt mz mi na nb aw nc bi"><span id="551b" class="mj kv iq mi b gy nd ne l nf ng">use std::collections::hash_map::DefaultHasher;<br/>use std::hash::{Hash, Hasher};</span><span id="d217" class="mj kv iq mi b gy nh ne l nf ng">fn hash(value: &amp;str) -&gt; u64 {<br/>    let mut s = DefaultHasher::new();</span><span id="d171" class="mj kv iq mi b gy nh ne l nf ng">    value.hash(&amp;mut s);<br/>    s.finish()<br/>}</span><span id="09a2" class="mj kv iq mi b gy nh ne l nf ng">struct BloomFilter&lt;const N: usize&gt; {<br/>    bytes: [u8; N],<br/>}</span><span id="2a68" class="mj kv iq mi b gy nh ne l nf ng">impl&lt;const N: usize&gt; BloomFilter&lt;N&gt; {<br/>    fn new() -&gt; Self {<br/>        Self { bytes: [0; N] }<br/>    }</span><span id="be44" class="mj kv iq mi b gy nh ne l nf ng">    fn get_positions(&amp;self, key: &amp;str) -&gt; (usize, u64) {<br/>        let bit_size = N * 8;<br/>        let pos = hash(key) % (bit_size as u64);</span><span id="8d17" class="mj kv iq mi b gy nh ne l nf ng">        ((pos / 8) as usize, pos % 8)<br/>    }</span><span id="648a" class="mj kv iq mi b gy nh ne l nf ng">    fn add(&amp;mut self, key: &amp;str) {<br/>        let (byte_idx, bit_idx) = self.get_positions(key);</span><span id="7d15" class="mj kv iq mi b gy nh ne l nf ng">        self.bytes[byte_idx] |= 1 &lt;&lt; bit_idx;<br/>    }</span><span id="8976" class="mj kv iq mi b gy nh ne l nf ng">    fn contains(&amp;self, key: &amp;str) -&gt; bool {<br/>        let (byte_idx, bit_idx) = self.get_positions(key);</span><span id="71f7" class="mj kv iq mi b gy nh ne l nf ng">        self.bytes[byte_idx] &amp; (1 &lt;&lt; bit_idx) != 0<br/>    }<br/>}</span></pre><p id="268a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大部分逻辑转移到计算字节索引和位位置的<code class="fe mf mg mh mi b">get_positions</code>方法。让我们也添加一些测试代码，看看它是否如预期的那样工作:</p><pre class="mv mw mx my gt mz mi na nb aw nc bi"><span id="2407" class="mj kv iq mi b gy nd ne l nf ng">fn main() {<br/>    let mut filter = BloomFilter::&lt;10&gt;::new();</span><span id="ad2b" class="mj kv iq mi b gy nh ne l nf ng">    filter.add("test1");<br/>    filter.add("test2");</span><span id="0486" class="mj kv iq mi b gy nh ne l nf ng">    println!("test1: {}", filter.contains("test1"));<br/>    println!("test2: {}", filter.contains("test2"));<br/>    println!("test3: {}", filter.contains("test3"));<br/>}</span></pre><p id="7152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的机器上，这会产生以下输出:</p><pre class="mv mw mx my gt mz mi na nb aw nc bi"><span id="aefb" class="mj kv iq mi b gy nd ne l nf ng">➜ cargo run<br/>   Compiling bloom-filter v0.1.0<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.14s<br/>     Running `target/debug/bloom-filter`<br/>test1: true<br/>test2: true<br/>test3: false</span></pre><p id="13d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住我们只能保证<code class="fe mf mg mh mi b">test3</code>不包含在集合中。我们不能确定<code class="fe mf mg mh mi b">test1</code>或<code class="fe mf mg mh mi b">test2</code>是否包含在集合中，因为它们可能是假阳性。源代码可以在<a class="ae lx" href="https://github.com/dillendev/bloom-filter-rs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="4bde" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结束语</h1><p id="4316" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在我们的 bloom filter 实现中，我们选择随机大小的<code class="fe mf mg mh mi b">10</code>字节(=80 位)。在现实世界中，大小应该基于您的数据集和误报的预期概率。选择太小的大小会对性能产生负面影响，因为会有太多的误报。确定布隆过滤器属性的最佳方式是运行性能测试并使用<a class="ae lx" href="https://hur.st/bloomfilter/" rel="noopener ugc nofollow" target="_blank">布隆过滤器计算器</a>。</p></div></div>    
</body>
</html>