<html>
<head>
<title>How to build Alamofire Network Layer with Protocol-Oriented Programming and Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用面向协议编程构建Alamofire网络层并结合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-alamofire-network-layer-with-protocol-oriented-programming-and-combine-4de005290566?source=collection_archive---------0-----------------------#2020-12-11">https://blog.devgenius.io/how-to-build-alamofire-network-layer-with-protocol-oriented-programming-and-combine-4de005290566?source=collection_archive---------0-----------------------#2020-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6b45323b4d5afa3020fbf0fd5757f33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mgt6GDITALeVigIj"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alina Grubnyak </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9231" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是面向协议的编程？</h1><p id="642a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">面向协议编程是Swift使用的一种新的编程范式。在面向协议的方法中，我们通过定义协议开始设计我们的系统，然后定义协议扩展、协议继承和协议组合，这允许我们不仅向一种类型添加新的功能，而且向所有符合相同协议的类型的整个集合添加新的功能。</p><p id="d45a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">Swift中的值类型，如struct或enum，不能从其他struct或enum继承，这意味着我们不能对值类型使用继承，但值类型可以从协议继承，甚至可以从多个协议继承，这是Swift最强大的功能，它给了我们更多的重用和更少的代码冗余。强烈推荐在Swift WWDC观看<a class="ae jz" href="https://developer.apple.com/videos/play/wwdc2015/408" rel="noopener ugc nofollow" target="_blank">面向协议的编程</a>并阅读更多关于<a class="ae jz" href="https://medium.com/dev-genius/learn-combine-by-code-55e661a5256c" rel="noopener">苹果联合收割机</a>的信息。</p><p id="9ac2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">假设我们有一个<code class="fe mb mc md me b">User</code>，用户有一封电子邮件，我们需要检查这封电子邮件是否有效，那么让我们按以下顺序开始:</p><h2 id="2279" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">1-定义协议</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="1a7a" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">定义<code class="fe mb mc md me b">EmailValidator</code>协议和该协议需要的输入，如<code class="fe mb mc md me b">email</code>。</li></ul><h2 id="3ec4" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated"><strong class="ak"> 2-扩展协议</strong></h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="9fa4" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">扩展协议并应用我们需要验证的所有逻辑，看<code class="fe mb mc md me b">email</code>是否有效。</li></ul><h2 id="f7e2" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">3-应用协议</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="2b38" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">然后将<code class="fe mb mc md me b">EmailValidator</code>应用到<code class="fe mb mc md me b">User</code>结构中，无需编写任何代码来验证电子邮件，用户将继承它。超级简单，是吧？😍</li><li id="5990" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">我们可以将<code class="fe mb mc md me b">EmailValidator</code>协议应用于任何需要验证电子邮件的类或结构，而不需要编写更多的代码。🎉</li></ul><h2 id="1254" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">4-使用协议进行测试</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="728d" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">使用POP最强大的功能是<em class="nl">测试</em>，假设我们因为某些原因需要返回所有无效的电子邮件，我们所需要的就是扩展<code class="fe mb mc md me b">EmailValidator</code>被<code class="fe mb mc md me b">MockUser</code>符合的地方，并覆盖<code class="fe mb mc md me b">isValidEmail</code>的逻辑以总是返回<code class="fe mb mc md me b">false</code>超级简单，我喜欢！。</li></ul><p id="be70" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这就是我们如何在Swift中使用面向协议的编程，它很容易重用和测试，因此我们将在网络层应用相同的概念。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/28c9825a124ccc0978523e30f8afea71.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/1*UO0FtN9C7A4wf_-ojUuFZg.gif"/></div></figure><ul class=""><li id="3fe6" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">在这个演示中将学习如何调用网络请求来获取电影流行列表，你可以查看本文末尾的所有代码。</li></ul><h2 id="4ea6" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">1-定义协议</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="90c4" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">定义符合<code class="fe mb mc md me b">URLRequestConvertible</code>协议的<code class="fe mb mc md me b">URLRequestBuilder</code>协议，该协议是Alamofire的一部分。</li><li id="924c" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">然后我们需要定义我们的协议需要的所有输入，但是在此之前我们需要检查<code class="fe mb mc md me b">URLRequestConvertible</code>协议。</li></ul><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/0d5756ab6898046625779f33c7af75fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiBo7XPqsThRWR4osw5alg.png"/></div></div></figure><ul class=""><li id="3215" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">当我们检查<code class="fe mb mc md me b">URLRequestConvertible</code>协议时，会发现只有一个函数<code class="fe mb mc md me b">asURLRequest()</code>会返回<code class="fe mb mc md me b">URLRequest</code>。</li><li id="43e2" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">因此，我们需要知道如何构建<code class="fe mb mc md me b">URLRequest</code>，因此将定义网络请求需要的所有输入，如:<code class="fe mb mc md me b">URL</code>、<code class="fe mb mc md me b">path</code>、<code class="fe mb mc md me b">ParameterEncoding</code>、<code class="fe mb mc md me b">HTTPHeaders</code>、<code class="fe mb mc md me b">HTTPMethod</code>。</li></ul><h2 id="c1b7" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">2-扩展协议</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="0031" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">做<code class="fe mb mc md me b">URLRequestBuilder</code>扩展并添加每个输入的实现，这将取决于请求，比如:如果httpMethod是<code class="fe mb mc md me b">.get</code>，那么编码将是<code class="fe mb mc md me b">URLEncoding</code>，如果它是<code class="fe mb mc md me b">.post</code>，那么编码将是<code class="fe mb mc md me b">JSONEncoding</code>。</li><li id="7e81" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">用httpMethod构建<code class="fe mb mc md me b">URLRequest</code>,并为请求添加头值。</li><li id="f73e" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">尝试用参数对urlRequest进行编码，并在<code class="fe mb mc md me b">asURLRequest</code>函数中返回。</li></ul><h2 id="7d2e" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">3-应用协议</h2><ul class=""><li id="606f" class="mx my in la b lb lc lf lg lj nv ln nw lr nx lv nc nd ne nf bi translated">在这个例子中，我们有两个网络调用，一个获取受欢迎的电影列表，另一个搜索电影，然后我们需要将我们的<code class="fe mb mc md me b">URLRequestBuilder</code>协议应用到它们中，所以让我们看看如何进行。</li></ul><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="84f7" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">创建<code class="fe mb mc md me b">MoviesAPIs</code> enum，它将扩展我们的协议<code class="fe mb mc md me b">URLRequestBuilder</code>，并且有两个网络调用的两种情况。</li></ul><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="4450" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">在<code class="fe mb mc md me b">MoviesAPIs</code>扩展中实现每个案例/调用的路径。</li></ul><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="06cf" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">在<code class="fe mb mc md me b">MoviesAPIs</code>扩展中实现每个案例/调用的参数，比如:我们需要为<strong class="la io"> getPopularList </strong>案例/调用准备<code class="fe mb mc md me b">language</code>、<code class="fe mb mc md me b">api_key</code>、<code class="fe mb mc md me b">page</code>。</li></ul><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="f2c0" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">在<code class="fe mb mc md me b">MoviesAPIs</code>扩展中，为每个案例/调用实现http方法。</li></ul><h2 id="4713" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">4-创建网络服务</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="54ca" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">创建具有一个执行URLRequest功能的<code class="fe mb mc md me b">NetworkServiceProtocol</code>协议。</li><li id="96d2" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">在<code class="fe mb mc md me b">NetworkServiceProtocol</code>将实现<code class="fe mb mc md me b">execute</code>功能，现在Alamofire支持<a class="ae jz" href="https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#using-alamofire-with-combine" rel="noopener ugc nofollow" target="_blank">联合</a>。</li><li id="7f87" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">首先，我们需要通过调用带有模型类型的<code class="fe mb mc md me b">publishDecodable</code>来获得<code class="fe mb mc md me b">DataResponsePublisher</code>，我们将把它解码为可编码的。</li><li id="5d79" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">然后我们需要在后台队列上订阅发布者来执行我们的网络调用。</li><li id="a714" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">然后我们需要在主队列上接收发布者来处理所有的UI更改。</li><li id="c0f1" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">然后我们需要下沉到发布者以获得结果并在完成时返回。</li><li id="3300" class="mx my in la b lb ng lf nh lj ni ln nj lr nk lv nc nd ne nf bi translated">最后，我们需要从Sink函数返回<code class="fe mb mc md me b">AnyCancellable</code>，这样我们就可以随时取消它。</li></ul><h2 id="dc00" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">4-如何使用网络服务</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="db4d" class="mx my in la b lb lw lf lx lj mz ln na lr nb lv nc nd ne nf bi translated">只需创建网络服务类，执行类似<code class="fe mb mc md me b">Endpoints.getPopularList(<strong class="la io">self</strong>.pager.nextPage).resolve()</code>的网络请求，并添加类似<code class="fe mb mc md me b">MoviesResponse.<strong class="la io">self</strong></code> <strong class="la io"> </strong>的响应类型，网络层本身就会处理剩下的事情，超级简单！<strong class="la io">😃</strong></li></ul><p id="d158" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">希望你和我一样喜欢😃🎉如果是这样，请随意鼓掌😄并与您的朋友分享，与人分享总是令人愉快的，如果您也想查看，这里有所有源代码:</p><div class="ny nz gp gr oa ob"><a href="https://github.com/deda9/MovizySwiftUI" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">deda9/MovizySwiftUI</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op jt ob"/></div></div></a></div></div></div>    
</body>
</html>