<html>
<head>
<title>Encoding Methods to encode Categorical data in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中分类数据的编码方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/encoding-methods-to-encode-categorical-data-in-machine-learning-717b5509933c?source=collection_archive---------7-----------------------#2022-07-18">https://blog.devgenius.io/encoding-methods-to-encode-categorical-data-in-machine-learning-717b5509933c?source=collection_archive---------7-----------------------#2022-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9376" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在机器学习领域，在进行建模之前，数据准备是一项强制性任务。在准备数据时，我们需要执行各种步骤，对分类数据进行编码是其中一项被认为至关重要的任务。大多数机器学习算法只接受数字数据作为输入。例如，K-最近邻算法计算特征的两个观察值之间的欧几里德距离。来计算两个观察值之间的欧几里得距离，因此传递的输入应该是数字类型的。因此，在将数据提供给算法之前，必须将分类数据转换或编码为数字类型，这反过来会产生更好的结果。</p><p id="f7ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">分类数据</em>可以认为是被分组的有限可能值。例如，不同的血型、性别、不同的城市和州。分类数据有两种类型:</p><ul class=""><li id="1e63" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><strong class="jm io">有序数据</strong>:由一组有限的离散值组成的数据，这些离散值具有一个优先顺序或优先级别。示例—[低，中，高]，[正，负]，[真，假]</li><li id="3f50" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><strong class="jm io">名义数据</strong>:由一组有限的离散值组成的数据，这些值之间没有关系。例如— ["印度"、"美国"、"英国"]、["狮子"、"猴子"、"斑马"]</li></ul><p id="c20c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于序号数据，在对数据进行编码并训练模型之后，我们需要再次将其转换为原始形式，因为需要它来正确预测值。但是对于名义数据，这不是必需的，因为这里偏好并不重要，我们只需要信息。</p><p id="cc54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对分类数据进行编码</strong>是将分类数据转换为整数格式的过程，以便将转换后的分类值数据提供给模型，从而给出并改进预测。</p><p id="71fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理论讲得够多了，让我们从编码部分和我们可以用来编码分类数据的不同技术开始。在本教程中，我们将使用来自 UCI 的经过处理的蘑菇数据集。这里 可以找到<a class="ae kx" href="https://github.com/muttinenisairohith/Encoding-Categorical-Data/tree/main/data" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">。</strong></a></p><h2 id="e49e" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><strong class="ak">加载数据集</strong></h2><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/e7a4f413ffab8b355dd9c601ec7e2fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5E0dKdJzc4DVfNjFDlynrA.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">加载数据</figcaption></figure><p id="74e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们有 15 列，其中 12 列的数据类型是 object，该数据中没有缺失值。因此，在建模之前，我们需要对这 12 个特征进行编码。</p><h2 id="e3a8" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><strong class="ak">标签编码</strong></h2><p id="0922" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">在标签编码中，每个标签将被转换成整数值。这里的输出将是一维的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/47499d8afc5084676bfd07f9a69d2220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*RmwUY5UWIFie4DLJLzaJkg.png"/></div></figure><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="6fd0" class="ky kz in mo b gy ms mt l mu mv">#using scikit-learn<br/>#Import LabelEncoder using sklearn</span><span id="1a87" class="ky kz in mo b gy mw mt l mu mv">from sklearn.preprocessing import LabelEncoder</span><span id="23dd" class="ky kz in mo b gy mw mt l mu mv">le = LabelEncoder()</span><span id="2b38" class="ky kz in mo b gy mw mt l mu mv">data["season"] = le.fit_transform(data["season"])</span></pre><h2 id="c164" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">顺序编码</h2><p id="851e" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">类似于标签编码，但是当我们打算将输入变量组织成行和列时，通常使用顺序编码。(例如:Matix)</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0561666b8c511d779d14ab3a45440ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*rVPvRGFF9n7-CW-z1JKyYw.png"/></div></figure><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="42af" class="ky kz in mo b gy ms mt l mu mv">#using scikit-learn<br/>#Import OrdinalEncoder using sklearn</span><span id="3364" class="ky kz in mo b gy mw mt l mu mv">from sklearn.preprocessing import OrdinalEncoder</span><span id="eecb" class="ky kz in mo b gy mw mt l mu mv">oe = OrdinalEncoder()</span><span id="f21f" class="ky kz in mo b gy mw mt l mu mv">encoded_data["season"] = oe.fit_transform(data[["season"]])</span></pre><h2 id="e94e" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><strong class="ak">一个热编码</strong></h2><p id="31af" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">在一次性编码中，任何分类变量的每个类别都有一个新变量。它用二进制数(0 或 1)映射每个类别。当数据是名义数据时，使用这种类型的编码。新创建的二进制特征可被视为<strong class="jm io">虚拟变量</strong>。在一次热编码之后，虚拟变量的数量取决于数据中出现的类别的数量。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi my"><img src="../Images/c78c80916f585b5cd6a0d4167e874a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJ16MJ7a4u8wx6UT9k3Hnw.png"/></div></div></figure><p id="58dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于一个热编码，我们将使用 category_encoders 包而不是 sklearn，因为它更有用。</p><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="a7fe" class="ky kz in mo b gy ms mt l mu mv">!pip install category_encoders</span></pre><p id="47eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码:</p><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="1a22" class="ky kz in mo b gy ms mt l mu mv">#Import OneHotEncoder from category_encoders<br/>from category_encoders import OneHotEncoder</span><span id="c5bc" class="ky kz in mo b gy mw mt l mu mv">ohe = OneHotEncoder( handle_unknown='return_nan', return_df=True, use_cat_names=True)</span><span id="aff1" class="ky kz in mo b gy mw mt l mu mv">ohe_results = ohe.fit_transform(data[["season"]])</span></pre><h2 id="fd9d" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><a class="ae kx" href="https://pypi.org/project/MultiColumnLabelEncoder/" rel="noopener ugc nofollow" target="_blank">多列编码器</a>(首选方法)</h2><p id="9547" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">使用 MultiColumnLabelEncoder 的主要优点是，每当模型包含顺序数据时，在编码之后，我们需要对数据进行逆变换，并获得原始数据，因此使用 MultiColumnLabelEncoder，顾名思义，在一个步骤中对多个列进行编码。</p><p id="686d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它的工作方式几乎类似于标签编码，但它适用于单个实例中的多个列，逆转换和获取原始数据太容易了。</p><p id="6463" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装:</p><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="c65d" class="ky kz in mo b gy ms mt l mu mv">!pip install MultiColumnLabelEncoder</span></pre><p id="8a89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码代码:</p><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="d67e" class="ky kz in mo b gy ms mt l mu mv">from MultiColumnLabelEncoder import MultiColumnLabelEncoder</span><span id="08ca" class="ky kz in mo b gy mw mt l mu mv">Mcle = MultiColumnLabelEncoder()<br/>encoded_data = Mcle.fit_transform(encoded_data)</span><span id="700e" class="ky kz in mo b gy mw mt l mu mv">encoded_data.head()</span></pre><p id="1787" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，它将对数据框中的所有对象列进行编码。我们也可以传递 columns 参数，如果传递了 columns 参数，它将只对传递的列名进行编码。</p><p id="5a9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">逆拟合变换:</p><pre class="ls lt lu lv gt mn mo mp mq aw mr bi"><span id="811c" class="ky kz in mo b gy ms mt l mu mv">inverse_encoded_data = Mcle.inverse_fit_transform(encoded_data)</span><span id="eece" class="ky kz in mo b gy mw mt l mu mv">inverse_encoded_data.head()</span></pre><p id="9bd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先前使用的相同字符串列将用于反转，但是如果我们只想传递某些列，我们可以通过传递一个可选的参数列来实现</p><h2 id="da07" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">结论</h2><p id="315e" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">还有其他编码库可用于编码，pandas 中的内部函数(如 map、replace、apply)也可用于编码，但上面提供的方法是对数据进行编码和及时逆变换的简单方法。所以我跳过了这些方法。</p><p id="2eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐编码…</p><p id="b273" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保持快乐…</p></div></div>    
</body>
</html>