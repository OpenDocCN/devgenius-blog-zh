<html>
<head>
<title>Dev IRL : How to add React components to an Express powered website using Create React App (without eject)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dev IRL:如何使用 Create React App 向 Express powered 网站添加 React 组件(不带弹出)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dev-irl-how-to-add-react-components-to-an-express-powered-website-using-create-react-app-336670c9261a?source=collection_archive---------4-----------------------#2021-12-31">https://blog.devgenius.io/dev-irl-how-to-add-react-components-to-an-express-powered-website-using-create-react-app-336670c9261a?source=collection_archive---------4-----------------------#2021-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aa4d2b6a69a68e40089ef8f8dfa7f2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VHJlGZADKBnJ906S"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图为<a class="ae jz" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">舒巴姆·达吉</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="2db2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们通常将 React 定义为一个库，而不是一个框架。理论上，你可以在你的网站上添加 React，而不必完全依赖它，也不必更新网站的内部结构。但在实际操作中，如果你只是想用 React 添加一些组件，那就另当别论了。</p><h1 id="80ee" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">TL；速度三角形定位法(dead reckoning)</h1><blockquote class="lw lx ly"><p id="2a6c" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">如果只是想看最终文件，可以去 repo:<a class="ae jz" href="https://github.com/SimonBriche/medium-stories/tree/main/react-components" rel="noopener ugc nofollow" target="_blank">https://github . com/Simon riche/medium-stories/tree/main/react-components</a></p><p id="7ea8" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">如果你想要一步一步的教程，请继续阅读😄</p></blockquote><p id="c615" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如《宣言》所述:</p><blockquote class="lw lx ly"><p id="b3bc" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">你可以在一分钟内将 React 添加到一个 HTML 页面中。然后，您可以逐渐扩展它的存在，或者保持它包含在几个动态小部件中。</p></blockquote><p id="c9dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这种说法是正确的，但是如果你按照教程去做，你最终会得到一堆不那么“生产就绪”的代码。此外，您将无法获得<a class="ae jz" href="https://create-react-app.dev" rel="noopener ugc nofollow" target="_blank"> Create React App </a> (CRA)的所有好处。</p><p id="702a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在编写我的即插即用 React 组件之前，我的要求是:</p><ol class=""><li id="189a" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx mi mj mk ml bi translated">使用 CRA，并获得其所有功能</li><li id="1127" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">能够根据我的网站结构编译到特定的文件夹</li><li id="a80c" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">在任何 HTML 文件中加载 React 组件</li><li id="4401" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">仅加载页面上使用的 React 组件的代码</li><li id="22eb" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">用 HTML 标记将属性注入组件</li><li id="ee38" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">组件之间的通信能力</li><li id="5169" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">能够动态添加更多组件</li><li id="aad1" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">轻松测试组件(无论是独立的，与他人或在最终网站本地)</li><li id="cde0" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated">不需要弹出 CRA(不要为自定义 webpack 配置而烦恼)</li><li id="31bd" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx mi mj mk ml bi translated"><em class="lz">奖励</em>:在远程 CDN 中托管组件</li></ol><p id="381d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从 Express powered 网站的最低配置和文件夹结构开始(请不要在生产中使用！仅供测试之用):</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e0ff471edd8f1987207e2cf9565ef63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*ftl7tTm2sUF3po8YR3VS1w.png"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="371c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用根文件夹中的<code class="fe my mz na nb b">node server.js</code>运行服务器，访问<code class="fe my mz na nb b">http://localhost:3000</code>，您应该会看到您的索引页面。注意，我在这里使用了<code class="fe my mz na nb b">pug</code> <a class="ae jz" href="https://pugjs.org/" rel="noopener ugc nofollow" target="_blank">模板</a>，因为我喜欢它简洁的语法😄</p><p id="1950" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以通过在根文件夹中运行<code class="fe my mz na nb b">npx create-react-app react-cmp</code>在<code class="fe my mz na nb b">/react-cmp</code>文件夹中安装一个默认的 Create React 应用程序。<code class="fe my mz na nb b">cd react-cmp</code>和<code class="fe my mz na nb b">npm start</code>，你会看到你默认的 React 应用🎉</p><p id="411e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们稍微调整一下 React 应用程序，在<code class="fe my mz na nb b">react-cmp</code>文件夹的根目录下创建一个<code class="fe my mz na nb b">.env</code> <a class="ae jz" href="https://create-react-app.dev/docs/advanced-configuration" rel="noopener ugc nofollow" target="_blank">文件</a>。现在，只需添加以下两行:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="31ae" class="ng kz in nb b gy nh ni l nj nk">BROWSER=none<br/>PORT=4200</span></pre><p id="4e13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将防止 CRA 在启动时打开一个新的浏览器窗口(我不喜欢这种行为)和改变 CRA 服务器的监听端口(默认是 3000，这也是我们的快速服务器端口)。您现在可以打开两个终端窗口，一个通过运行根文件夹中的<code class="fe my mz na nb b">node server.js</code>来启动我们的 Express 服务器，另一个通过运行<code class="fe my mz na nb b">/react-cmp</code>文件夹中的<code class="fe my mz na nb b">npm start</code>来启动 CRA 服务器。访问<code class="fe my mz na nb b">http://localhost:3000</code>上的快速服务器和<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:4200." rel="noopener ugc nofollow" target="_blank">http://localhost:4200</a></code>上的 CRA 服务器。恭喜你，我们已经达到了第一个目标:<em class="lz">访问 CRA 的所有功能</em>！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h1 id="13f7" class="ky kz in bd la lb ns ld le lf nt lh li lj nu ll lm ln nv lp lq lr nw lt lu lv bi translated">建立档案</h1><p id="c3fd" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">我们的第二个目标是在 Express 服务器可访问的位置构建文件。默认情况下，如果你运行<code class="fe my mz na nb b">npm run build</code>，CRA 会用编译后的文件创建一个<code class="fe my mz na nb b">/react-cmp/build</code>文件夹。由于我们的 Express 服务器访问其<code class="fe my mz na nb b">public</code>文件夹中的公共文件，我们需要<strong class="kc io">改变 CRA </strong>的构建路径。</p><p id="881b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开您的<code class="fe my mz na nb b">.env</code>文件并添加以下行:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="46ab" class="ng kz in nb b gy nh ni l nj nk">BUILD_PATH="../public/react-cmp/production"</span></pre><p id="395f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在 Express 服务器的<code class="fe my mz na nb b">production</code> a 文件夹中构建文件(我们将在后面看到为什么需要<code class="fe my mz na nb b">production</code>文件夹)。目标 2 完成✅</p><h2 id="da08" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">在 Express 服务器中加载我们的 React 应用程序</h2><p id="6fc6" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">让我们检查一下 CRA 生成的<code class="fe my mz na nb b">index.html</code>文件:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d68a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看到文件的路径了吗？显然，这会导致一个难看的<code class="fe my mz na nb b">404</code>错误。幸运的是，我们可以通过在我们的<code class="fe my mz na nb b">.env</code>文件中设置一个<code class="fe my mz na nb b">PUBLIC_URL</code>环境变量来告诉 CRA <strong class="kc io">最终文件位于哪里</strong>，在我们的例子中:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="95f0" class="ng kz in nb b gy nh ni l nj nk">PUBLIC_URL="/react-cmp/production"</span></pre><p id="a022" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用<code class="fe my mz na nb b">npm run build</code>重新构建 app，检查新的<code class="fe my mz na nb b">index.html</code>:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6e13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好多了！我们甚至可以通过访问<code class="fe my mz na nb b">http://localhost:3000/react-cmp/production</code>查看我们的应用程序运行🎉</p><p id="b6f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很棒，但是请记住我们的第三个目标:<em class="lz">在</em> <strong class="kc io"> <em class="lz">任何</em> </strong> <em class="lz"> HTML 文件</em>中加载 React 组件。</p><h1 id="eed1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">反应积分</h1><p id="44e7" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">因为我们需要在任何 HTML 模板中加载 React 代码，所以我们需要获取生成的<code class="fe my mz na nb b">.js</code>和<code class="fe my mz na nb b">.css</code>文件的路径，并将它们放入模板中。但是如果您仔细看看路径，例如<code class="fe my mz na nb b">.js</code>主文件:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="05d0" class="ng kz in nb b gy nh ni l nj nk">/react-cmp/production/static/js/main.b37b1599.js</span></pre><p id="3f49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…虽然路径本身是相同的，但文件名包含一个哈希，它将在每次代码更新时更新。然而，<code class="fe my mz na nb b">index.html</code>文件本身总是在一个已知的位置:<code class="fe my mz na nb b">[PUBLIC_URL]/static/index.html</code>！</p><p id="1d23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们最终并不真正需要<code class="fe my mz na nb b">index.html</code>文件(我们宁愿加载我们的 Express 服务器页面’),我们仍然可以使用它作为一个<em class="lz">映射</em>,在那里找到组件的代码(即<code class="fe my mz na nb b">.js</code>和<code class="fe my mz na nb b">.css</code>文件)。</p><p id="2fc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们知道 React 文件在哪里，但是我们需要在每个 HTML 页面中注入它们的 URL。这听起来像是一个小型加载器实用程序的工作！</p><p id="33a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="eca8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个实用程序(我们将存储在 CRA 的<code class="fe my mz na nb b">/react-cmp/public</code>文件夹中，就在<code class="fe my mz na nb b">index.html</code>旁边)相当简单:</p><ul class=""><li id="57d0" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated">我们获取脚本的当前路径(该路径实际上是在<code class="fe my mz na nb b">script</code>标签的<code class="fe my mz na nb b">src</code>属性中设置的<strong class="kc io">。这将是我们所有资源的根路径。</strong></li><li id="4c73" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">我们找到了<code class="fe my mz na nb b">index.html</code>文件，它应该是我们的加载程序的下一个的<em class="lz"/></li><li id="3a74" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">我们用正则表达式从<code class="fe my mz na nb b">index.html</code>文件内容中提取出<code class="fe my mz na nb b">.js</code>和<code class="fe my mz na nb b">.css</code>文件的路径</li><li id="0b2f" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">我们注入并执行<code class="fe my mz na nb b">.js</code>文件</li><li id="e36d" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">我们注入<code class="fe my mz na nb b">.css</code>文件</li></ul><p id="6b81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，将其加载到<code class="fe my mz na nb b">index.pug</code>模板中:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9c29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一件事，在产品构建期间，CRA 可以将运行时脚本作为内嵌脚本嵌入到 index.html 中。为了确保所有代码都将构建在<code class="fe my mz na nb b">.js</code>文件中，我们可以通过添加以下行在<code class="fe my mz na nb b">.env</code>文件中添加一个额外的配置:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="8610" class="ng kz in nb b gy nh ni l nj nk">INLINE_RUNTIME_CHUNK=false</span></pre><p id="b263" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您现在应该看到我们的默认 React 应用程序被加载到我们的<code class="fe my mz na nb b">#root</code>容器 div 中，就在<code class="fe my mz na nb b">h1</code>的下面。任务完成:我们现在可以在任何 HTML 文件中加载 React 组件了 ✅</p><h1 id="090c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">加载实际组件</h1><p id="f209" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">我们的设置已经完成，我们现在可以编写 2 个(非常)简单的组件，并将它们加载到页面上。但是请记住:我们的目标是<strong class="kc io">只加载使用过的组件的代码</strong>，而不是整个应用！</p><p id="8cf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们把它们写下来:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4d3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所看到的，你很难让他们更简单！在一个标准的 React 应用程序中，我们会导入它们并把它们放在<code class="fe my mz na nb b">App</code>模板中。但是我们希望能够只加载一个、另一个或两个组件。</p><p id="befa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看<code class="fe my mz na nb b">index.js</code>文件，那是我们 CRA 的切入点:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e724" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，它导入整个<code class="fe my mz na nb b">App</code>并渲染它。我们将更新这个行为来控制<strong class="kc io">必须加载什么</strong>(基于组件列表)和<strong class="kc io">如何加载</strong>(只加载需要的代码)。</p><h2 id="8520" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">什么</h2><p id="fd1b" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">如果您查看默认的<code class="fe my mz na nb b">index.js</code>文件，您会注意到它会搜索一个将<code class="fe my mz na nb b">root</code>作为<code class="fe my mz na nb b">id</code>的<code class="fe my mz na nb b">div</code>,将其用作渲染的容器。以类似的方式，我们可以搜索 HTML 元素的一个非常具体的<em class="lz">集合</em>，并将它们用作组件的容器。比方说，所有以<code class="fe my mz na nb b">__react-cmp</code>为类名的<code class="fe my mz na nb b">div</code>。</p><p id="ea3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于要在这些容器中呈现的实际组件，我们可以使用 custom <code class="fe my mz na nb b">attributes</code>来存储它们的类名。比方说，<code class="fe my mz na nb b">data-react-component</code>。</p><h2 id="a0d6" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">怎么做</h2><p id="0d04" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">事情是这样的，如果你导入所有可能被插入到我们的 HTML 页面中的<em class="lz">潜在的</em>组件，你最终会加载<em class="lz">所有的代码</em>所有的组件，例如只显示一个简单的按钮。好在 React 自带<a class="ae jz" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">代码拆分</a>使用<strong class="kc io"> React.lazy() </strong>和<strong class="kc io">悬念</strong>！</p><p id="da82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，您可以用一个承诺(使用<code class="fe my mz na nb b">React.lazy()</code>)来导入模块，如果模块被实际调用并显示给用户(使用<code class="fe my mz na nb b">&lt;Suspense /&gt;</code>)，只有<strong class="kc io">才能解析。</strong></p><h2 id="35f6" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">将“什么”和“如何”结合在一起</h2><p id="f07b" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">您已经知道了:这个想法是用<code class="fe my mz na nb b">React.lazy()</code>导入所有的<em class="lz">潜在的</em>组件，遍历当前 HTML 页面中的<code class="fe my mz na nb b">div.__react-cmp</code>元素，获取它们的<code class="fe my mz na nb b">data-react-component</code>属性，并在一个<code class="fe my mz na nb b">&lt;Suspense /&gt;</code>组件中呈现它们。那我们就这么做吧:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6fc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要相应地更新我们的<code class="fe my mz na nb b">index.pug</code>:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="255a" class="ng kz in nb b gy nh ni l nj nk">//old<br/>h1 Hello there !<br/>#root</span><span id="45b8" class="ng kz in nb b gy oo ni l nj nk">//new<br/>h1 Hello there !<br/>.__react-cmp(data-react-component="App")</span></pre><p id="c982" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行<code class="fe my mz na nb b">npm run build</code>更新 React app，重新加载<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>。你应该看到完全一样的东西，除了 React 应用的容器不是<code class="fe my mz na nb b">#root</code>而是<code class="fe my mz na nb b">.__react-cmp</code>。</p><p id="dafa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">神奇的事情发生了:如果您将<code class="fe my mz na nb b">data-react-component</code>属性从<code class="fe my mz na nb b">App</code>更新为<code class="fe my mz na nb b">TestComponent1</code>，您应该会看到我们的组件，而不是默认的应用程序！尝试将属性更新为<code class="fe my mz na nb b">TestComponent2</code>或复制容器，现在您就可以在 HTML 页面的任何位置注入任何组件，次数不限。</p><p id="ecbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在 DevTools 中检查您加载的资源，您应该看到根据加载的组件，资源是不同的。这实现了我们的第四个目标:<em class="lz">只加载页面上使用的 React 组件的代码🎉</em></p><p id="2dd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这基本上是我们想要的，但现在让我们添加一些功能。</p><h1 id="ceb5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将属性注入组件</h1><p id="df29" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">自定义属性是组件的必备属性。例如，如果你实现了一个“共享”按钮，你必须能够注入 URL 来共享，因为这是不同按钮之间唯一的区别。为了更有趣，你会想给你的按钮设置大小(<code class="fe my mz na nb b">normal</code>、<code class="fe my mz na nb b">small</code>、<code class="fe my mz na nb b">big</code>)，甚至是一个主题(<code class="fe my mz na nb b">light</code>、<code class="fe my mz na nb b">dark</code>)。</p><p id="703b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为容器是一个 HTML 元素，我们可以用它所有的<code class="fe my mz na nb b">dataset</code>来呈现我们的组件。让我们相应地更新我们的<code class="fe my mz na nb b">index.js</code>文件:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="2054" class="ng kz in nb b gy nh ni l nj nk">&lt;Suspense fallback={&lt;Fallback /&gt;}&gt;<br/>  &lt;App {...el.dataset} /&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="1aa9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以及我们的<code class="fe my mz na nb b">TestComponent1</code>的模板来确保我们可以通过组件的<code class="fe my mz na nb b">props</code>访问属性:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="36b6" class="ng kz in nb b gy nh ni l nj nk">&lt;div&gt;<br/>  I'm the component 1 with attribute {props.testAttribute}<br/>&lt;/div&gt;</span></pre><p id="b232" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更新<code class="fe my mz na nb b">index.pug</code>文件添加<code class="fe my mz na nb b">data-test-attribute</code>:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="bc00" class="ng kz in nb b gy nh ni l nj nk">h1 Hello there !<br/>.__react-cmp(data-react-component="TestComponent1" data-test-attribute="test attribute value")</span></pre><p id="455d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">构建并重新加载页面:您现在应该会看到<code class="fe my mz na nb b">I'm the component 1 with attribute test attribute value</code>。您现在可以通过 HTML 属性向组件注入各种类型的(字符串)值！</p><p id="a994" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，定制的 HTML 属性必须以<code class="fe my mz na nb b">data-</code>开头，虽然 HTML 属性的名称是破折号大小写，但是在<code class="fe my mz na nb b">dataset</code>属性中它们是驼色大小写。</p><h1 id="b649" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">组件之间的通信能力</h1><p id="4f36" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">如果您想对组件的布局有更多的控制，这个目标是非常有用的。</p><p id="d677" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您想要创建一个图库，带有一个用于过滤、搜索或排序元素的工具栏。你可以用这两者来制作一个组件，但是你需要在它们之间放一些 HTML 元素，或者工具栏需要总是在页面的顶部，等等...长话短说，它们不能在同一个组件中。</p><p id="5ea5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的想法是有一个“桥”，可以跨组件传递事件，因此它们可以互相更新。首先，我们需要将这个桥的引用传递给所有组件。我们只需创建一个新的<code class="fe my mz na nb b">EventTarget</code>对象，并将其作为<code class="fe my mz na nb b">bridgeEvent</code>属性传递给所有组件:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0bb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们在<code class="fe my mz na nb b">TestComponent1.js</code>中实现了两个简单的计数器:一个用于接收的事件(将在组件本身中递增)，另一个用于按钮被点击的次数(作为自定义<code class="fe my mz na nb b">detail</code>与事件一起传递)。注意，一旦用<code class="fe my mz na nb b">useEffect</code>钩子声明了事件监听器，我们就在<code class="fe my mz na nb b">bridge</code>上添加事件监听器。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6343" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe my mz na nb b">TestComponent2.js</code>中，我们在每次按钮被点击时调度一个新的事件，点击计数器作为事件的<code class="fe my mz na nb b">detail</code>。请注意，您可以在该属性上传递任何您想要的内容。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e916" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，更新<code class="fe my mz na nb b">index.pug</code>以显示两个组件:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="4eb8" class="ng kz in nb b gy nh ni l nj nk">h1 Hello there !<br/>.__react-cmp(data-react-component="TestComponent1" data-test-attribute="test attribute value")<br/>.__react-cmp(data-react-component="TestComponent2")</span></pre><p id="a16d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">构建并刷新页面。如果你点击按钮，计数器应该增加！我们清除了第 6 个目标:<em class="lz">将信息从一个 React 组件发送到另一个组件</em>👍</p><h1 id="fad2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">能够动态添加更多组件</h1><p id="a23b" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">如果你的应用 100%由 React 驱动，那么动态添加组件就是框架的一部分。但是在我们的例子中，您可能需要在服务器渲染之后添加一些新的组件。换句话说，我们需要能够随时解析 HTML。</p><p id="f208" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是脸书对其 SDK 和 FBML 的典型做法:</p><ul class=""><li id="c626" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated">首先，你用<code class="fe my mz na nb b">fbAsyncInit</code>监听 SDK 的可用性</li><li id="d7a6" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">然后，您可以通过一个全局对象访问 SDK:<code class="fe my mz na nb b">window.FB</code></li><li id="8a6d" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">最后，你可以通过调用<code class="fe my mz na nb b"> window.FB.XFBML.parse();</code>随时解析你的 HTML，如果你已经动态地添加了新的部件(这在 SPAs 中很常见)</li></ul><p id="0002" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以为组件系统实现类似的行为，对吗？但是有一个小问题:我们需要选择一个可能已经被使用的全局对象名。幸运的是，React 附带了定制环境变量<a class="ae jz" href="https://create-react-app.dev/docs/adding-custom-environment-variables" rel="noopener ugc nofollow" target="_blank">，我们可以用它来设置这个名字。这样，我们可以在构建时定制这个全局对象的名称。让我们看看如何在我们的<code class="fe my mz na nb b">index.js</code>中实现这一点:</a></p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="914b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们用默认名称<code class="fe my mz na nb b">ReactComponents</code>定义我们的应用程序名称空间。这个名字可以被替换为在我们的<code class="fe my mz na nb b">.env</code>文件中定义的<code class="fe my mz na nb b">REACT_APP_NAMESPACE</code>环境变量的内容，如果它存在的话。注意，所有自定义环境变量都必须以<code class="fe my mz na nb b">REACT_APP_</code>开头。</p><p id="36d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们用以下方法实现我们的全局对象:</p><ul class=""><li id="8f1a" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated">一个<code class="fe my mz na nb b">ready</code>属性，用于检查对象是否可用</li><li id="0506" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">一个<code class="fe my mz na nb b">parseComponents</code>方法，用于解析 HTML 文档或特定容器</li></ul><p id="6efc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们通过调用<code class="fe my mz na nb b">parseComponents()</code>(它将解析服务器生成的 HTML)来触发我们的第一个文档解析，我们注意到通过调用(potential) <code class="fe my mz na nb b">ReactComponentsAsyncInit</code>函数，我们的全局对象是可用的。</p><p id="a7e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们更新我们的<code class="fe my mz na nb b">index.pug</code>文件来使用这个全局对象，并动态实例化一些组件:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="acaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于测试的目的，我们添加了一个<code class="fe my mz na nb b">#new-components</code> <code class="fe my mz na nb b">div</code>来进行特定的容器解析，并添加了一个脚本标签，我们将在其中通过一个<code class="fe my mz na nb b">addNewComponent()</code>函数进行动态插入和解析。</p><p id="58a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，我们首先检查全局对象是否可用(通过测试它的<code class="fe my mz na nb b">ready</code>属性):</p><ul class=""><li id="dfa0" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated">如果有，我们可以立即打电话<code class="fe my mz na nb b">addNewComponent()</code></li><li id="c3df" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">如果没有，我们通过创建一个<code class="fe my mz na nb b">window.ReactComponentsAsyncInit</code>函数来等待对象被实例化，这个函数将在第一次解析完成后被调用</li></ul><p id="b885" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了说明这种生成，我们通过<code class="fe my mz na nb b">addNewComponent()</code>创建、附加和解析超时略有不同的组件。重新加载页面，您应该会看到动态组件一个接一个地出现，与<code class="fe my mz na nb b">TestComponent1</code>完全连接。无论你点击由服务器生成的<code class="fe my mz na nb b">TestComponent2</code>，追加到文档或<code class="fe my mz na nb b">#new-component</code>容器的那个，全局事件计数器都会增加，按钮点击计数器会被发送！我们已经成功地<em class="lz">动态添加了更多组件</em>！✅</p><h1 id="e711" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">轻松测试组件</h1><p id="67dc" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">您应该已经注意到，从这个旅程开始，构建和重新加载页面以查看修改是一件痛苦的事情。那么，当我们在一个开发团队中工作时，我们能做些什么来一个接一个地测试组件，与其他人一起或者在最终的网站中？答案就在可以和 React 一起使用的多个<code class="fe my mz na nb b">.env</code> <a class="ae jz" href="https://create-react-app.dev/docs/adding-custom-environment-variables#what-other-env-files-can-be-used" rel="noopener ugc nofollow" target="_blank">文件中。</a></p><p id="f2c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CRA 最酷的功能之一是实时重载:你只需要保存你的文件，浏览器就会立即反映你的改变。事情是这样的，我们在<code class="fe my mz na nb b">index.js</code>文件中做了更新，当你运行<code class="fe my mz na nb b">npm start</code>并访问<code class="fe my mz na nb b">http://localhost:4200</code>时，什么也没有显示。事实上，我们不再在<code class="fe my mz na nb b">#root</code>容器中呈现任何东西(我们甚至不需要<code class="fe my mz na nb b">index.html</code>来呈现)，但是我们可以使用这个模板来呈现我们的测试！我们缺少的信息是我们想要测试的组件列表。</p><p id="8f15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们正在开发，并且我们想在本地机器上测试组件，所以让我们在<code class="fe my mz na nb b">/react-cmp</code>文件夹中创建一个<code class="fe my mz na nb b">.env.development.local</code>文件。这个不会包含在 Git 回购中，所以不会困扰我们的同事。在这个文件中，我们可以定义一个环境变量，该变量包含我们想要测试的组件的类名，以逗号分隔(因为我们希望能够测试多个组件)。姑且称之为<code class="fe my mz na nb b">REACT_APP_RENDER_CMP</code>:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="54cb" class="ng kz in nb b gy nh ni l nj nk">REACT_APP_RENDER_CMP="App"</span></pre><p id="dff1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们可以更新我们的<code class="fe my mz na nb b">index.js</code>文件来获取这个变量，如果可能的话分割它的内容，并在<code class="fe my mz na nb b">#root</code>容器中追加所有组件:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ce1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，所有的环境变量都可以通过<code class="fe my mz na nb b">process.env</code>对象访问。在你的终端中运行<code class="fe my mz na nb b">npm start</code>，访问<code class="fe my mz na nb b">http://localhost:4200</code>，你应该会看到默认的 CRA 应用，就好像你没有改变任何东西一样！现在更新您的<code class="fe my mz na nb b">.env.development.local</code>文件并设置:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="ddc9" class="ng kz in nb b gy nh ni l nj nk">REACT_APP_RENDER_CMP="TestComponent1,TestComponent2"</span></pre><p id="b7f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您的终端中再次运行<code class="fe my mz na nb b">npm start</code>(您需要重新启动您的服务器以便考虑环境变量)，重新加载页面，您应该看到两个测试组件。现在，看看这个:如果你改变了<code class="fe my mz na nb b">TestComponent1</code>模板中的一个单词，一旦你保存了这个文件，它会立即在浏览器中更新！🎉</p><h2 id="2f0a" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">使用属性</h2><p id="9de5" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">缺少的一件事是测试具有定制属性的组件。为了保持<code class="fe my mz na nb b">REACT_APP_RENDER_CMP</code>变量和生成逻辑的简单性，我们将创建另一个变量:<code class="fe my mz na nb b">REACT_APP_RENDER_CMP_WITH_ATTRS</code>。这个变量将包含一个数组的 JSON 表示，其中包含我们需要的所有信息:类名和属性。例如:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="6aaf" class="ng kz in nb b gy nh ni l nj nk">REACT_APP_RENDER_CMP_WITH_ATTRS="[{"class":"TestComponent1","data":{"data-test-attribute":"test attribute value"}}]"</span></pre><p id="b9d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，用那些具有属性的组件<strong class="kc io">的生成逻辑来更新我们的<code class="fe my mz na nb b">index.js</code>:</strong></p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d20c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这相当简单:我们基于对象的<code class="fe my mz na nb b">class</code>属性生成组件，然后我们将所有的<code class="fe my mz na nb b">data</code>对象属性作为属性注入。重启您的 CRA 服务器并重新加载您的页面:您应该看到一个没有属性的<code class="fe my mz na nb b">TestComponent1</code>(用<code class="fe my mz na nb b">REACT_APP_RENDER_CMP</code>变量生成的那个)和一个带 <code class="fe my mz na nb b">test attribute value</code>的<code class="fe my mz na nb b">TestComponent1</code> <strong class="kc io">(用<code class="fe my mz na nb b">REACT_APP_RENDER_CMP_WITH_ATTRS</code>变量生成的那个)。当然，如果<code class="fe my mz na nb b">TestComponent1.js</code>的代码源发生变化，两者都会立即更新。</strong></p><p id="a9d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以你已经独立地开发和测试了你的组件，现在你想在网站上看到结果。很公平。</p><h2 id="ff1f" class="ng kz in bd la oc od dn le oe of dp li kl og oh lm kp oi oj lq kt ok ol lu om bi translated">网站内测试</h2><p id="ab11" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">还记得我们设置为<code class="fe my mz na nb b">../public/react-cmp/production</code>的<code class="fe my mz na nb b">BUILD_PATH</code>环境变量吗？是时候设置到<code class="fe my mz na nb b">../public/react-cmp/development</code>了！</p><p id="09fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">等等。</p><p id="9e66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你仍然需要你的体型，对吗？因此，创建一个<code class="fe my mz na nb b">.env.development</code>文件，并在其中设置<code class="fe my mz na nb b">BUILD_PATH</code>变量，以及<code class="fe my mz na nb b">PUBLIC_URL</code>变量:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="e8ee" class="ng kz in nb b gy nh ni l nj nk">BUILD_PATH="../public/react-cmp/development"<br/>PUBLIC_URL="/react-cmp/development"</span></pre><p id="a1f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在您应该有 3 个<code class="fe my mz na nb b">.env</code>文件，它们在运行 CRA 服务器时以这个顺序覆盖变量:</p><ul class=""><li id="d363" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated"><code class="fe my mz na nb b">.env</code>设置初始值</li><li id="101e" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated"><code class="fe my mz na nb b">.env.development</code>覆盖<code class="fe my mz na nb b">.env</code>值</li><li id="7643" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated"><code class="fe my mz na nb b">.env.development.local</code>覆盖<code class="fe my mz na nb b">.env.development</code>值</li></ul><p id="3412" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，一旦构建完成，组件只考虑<code class="fe my mz na nb b">.env</code>文件的变量。那么，我们如何告诉 CRA 在构建我们的应用程序时获取<code class="fe my mz na nb b">.env.development</code>定义呢？借助<code class="fe my mz na nb b">env-cmd</code>的<a class="ae jz" href="https://www.npmjs.com/package/env-cmd" rel="noopener ugc nofollow" target="_blank"> NPM 当然包</a>了！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="7bde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，这个包将帮助我们在执行 CRA 的<code class="fe my mz na nb b">package.json</code>文件中定义的脚本时选择一个特定的<code class="fe my mz na nb b">.env</code>文件。让我们通过运行以下命令将它安装在我们的开发依赖项中:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="993e" class="ng kz in nb b gy nh ni l nj nk">npm install env-cmd --save-dev</span></pre><p id="f98f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，通过在<code class="fe my mz na nb b">scripts</code>部分添加一个新脚本来更新我们的<code class="fe my mz na nb b">package.json</code>，就在<code class="fe my mz na nb b">build</code>脚本的下面:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="d185" class="ng kz in nb b gy nh ni l nj nk">"build:development": "env-cmd -f ./.env.development npm run-script build",</span></pre><p id="0ce2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意到<code class="fe my mz na nb b">:development</code>部分了吗？这样你可以创建更多的环境，比如<code class="fe my mz na nb b">staging</code> one。现在，运行<code class="fe my mz na nb b">npm run build:development</code>来构建我们的开发应用程序！检查你的<code class="fe my mz na nb b">/public/react-cmp/development</code>文件夹，你应该会看到生成的文件。你应该把这个文件夹添加到你的<code class="fe my mz na nb b">.gitignore</code>文件中，因为它只是为开发阶段准备的。</p><p id="0f64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后要做的是告诉我们的 Express 服务器当前的环境，即<code class="fe my mz na nb b">cmp-loader.js</code>所在的位置。我们可以简单地将<code class="fe my mz na nb b">PUBLIC_URL</code>存储在 Express 服务器的环境变量中，并在<code class="fe my mz na nb b">index.pug</code>模板中更新加载程序的路径以使用它:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="fd0d" class="ng kz in nb b gy nh ni l nj nk">//old<br/>script(src="/react-cmp/production/cmp-loader.js")<br/>//new<br/>script(src=`${process.env.REACT_PUBLIC_URL}/cmp-loader.js`)</span></pre><p id="6f58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了简单起见，我们只在<code class="fe my mz na nb b">server.js</code>文件的最开始添加<code class="fe my mz na nb b">REACT_PUBLIC_URL</code>定义:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="fb34" class="ng kz in nb b gy nh ni l nj nk">process.env.REACT_PUBLIC_URL = "/react-cmp/<!-- -->development<!-- -->";</span><span id="1e97" class="ng kz in nb b gy oo ni l nj nk">const morgan = require('morgan');<br/>const express = require('express');<br/>const PORT = "3000";<br/>const app = express();</span><span id="23c1" class="ng kz in nb b gy oo ni l nj nk">....</span></pre><p id="ad22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，你可以在一个<code class="fe my mz na nb b">.env</code>文件中声明<code class="fe my mz na nb b">REACT_PUBLIC_URL</code>变量，并使用<a class="ae jz" href="https://github.com/strongloop/node-foreman" rel="noopener ugc nofollow" target="_blank">节点领班</a>或<code class="fe my mz na nb b">dotenv</code>NPM 包<a class="ae jz" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">来加载它。</a></p><p id="e15c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！现在，您可以按照您想要的方式测试您的组件，而不会打扰其他开发人员，因为所有的更改都是通过环境变量完成的，并且临时文件不是 repo 的一部分。🎊</p><h1 id="5655" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不需要驱逐 CRA</h1><p id="53cb" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">这里只需简单说明一下，正如你看到的，我们不需要为这个设置弹出 CRA，这很好，因为你保持简单(不需要额外的 webpack 配置),并且你可以没有太多麻烦地更新 CRA。</p><h1 id="f5c8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">✨Bonus✨将组件托管在远程 CDN 中</h1><p id="e661" class="pw-post-body-paragraph ka kb in kc b kd nx kf kg kh ny kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ig bi translated">如果您想在远程 CDN 中托管您的组件，您只需:</p><ul class=""><li id="9631" class="md me in kc b kd ke kh ki kl mf kp mg kt mh kx on mj mk ml bi translated">相应地设置 CRA <code class="fe my mz na nb b">PUBLIC_URL</code>环境变量，例如<code class="fe my mz na nb b">https://your-cdn-solution.com/react-cmp/production</code></li><li id="1f5d" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">将 Express server <code class="fe my mz na nb b">REACT_PUBLIC_URL</code>环境变量设置为与<strong class="kc io">完全相同的值</strong>，即<code class="fe my mz na nb b"><a class="ae jz" href="https://your-cdn-solution.com/react-cmp/production" rel="noopener ugc nofollow" target="_blank">https://your-cdn-solution.com/react-cmp/production</a></code></li><li id="f02d" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">构建文件，这些文件应该存储在由<code class="fe my mz na nb b">BUILD_PATH</code>环境变量定义的文件夹中(在 CRA 的<code class="fe my mz na nb b">.env</code>文件中)</li><li id="c72c" class="md me in kc b kd mm kh mn kl mo kp mp kt mq kx on mj mk ml bi translated">上传你的 CDN 文件夹中的文件<code class="fe my mz na nb b"><a class="ae jz" href="https://your-cdn-solution.com/react-cmp/production" rel="noopener ugc nofollow" target="_blank">/react-cmp/production</a></code></li></ul><p id="95c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重新启动 Express 服务器并重新加载页面。所有组件的文件都应该来自你的 CDN！🎉</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="c8a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">拍拍你自己的背，你现在能够在任何现有的 HTML 网站上创建和添加可重用的 React 组件，而不用让它们成为一个 SPA。您甚至可以创建一个完整的 React 应用程序作为静态 HTML 网站上的组件，并将其托管在您的服务器或远程 CDN 中。</p></div></div>    
</body>
</html>