<html>
<head>
<title>WebSockets with Spring WebFlux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带 Spring WebFlux 的 WebSockets</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/websockets-with-spring-webflux-ba9d0b47b348?source=collection_archive---------2-----------------------#2020-06-06">https://blog.devgenius.io/websockets-with-spring-webflux-ba9d0b47b348?source=collection_archive---------2-----------------------#2020-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6eff4fbef74d3a7a3c3f98e09a16d2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZo0jHuz-L4ivrJgCiwzFA.jpeg"/></div></div></figure><h1 id="7fbd" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="1ea2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在本教程中，我们将看看如何用 Spring WebFlux 创建一个基本的 websocket 连接。</p><p id="d80e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">WebSocket 是 web 浏览器和服务器之间通过单一 TCP 连接进行双向通信的协议。因此，它在聊天应用程序或任何基于事件的通信中都很有用。换句话说，您可以在一个请求(连接)中流数据。</p><p id="7e11" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">本页涵盖以下主题:</p><ol class=""><li id="fb09" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">如何配置 websockets？</li><li id="a2a2" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如何阅读信息？</li><li id="42d7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">怎么发消息？</li><li id="baaf" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">编写演示项目。</li><li id="4d68" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如何保护 websockets？</li></ol><p id="945d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在开始之前，我们需要设置项目，以加快进程使用<a class="ae mk" href="http://start.spring.io" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>与依赖反应网络。</p><h1 id="3107" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何配置 websockets</h1><p id="8bae" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们从配置开始，说明为什么我们需要一些组件。</p><p id="5017" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先要做的是为反应式 websockets 编写配置。</p><p id="c545" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它需要 HandlerMapping 和 HandlerAdapter beans。</p><p id="b7ae" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">易于创建的手柄:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ea2b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为什么这门课需要？此适配器在内部初始化 websocket 服务，并使用 WebSocketHandler 实现。换句话说，通过这个 bean 声明，我们在 Spring WebFlux 中启用了 websockets。</p><p id="a266" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">下一个 bean 是 HandlerMapping。有了这个类，我们就能够建立一个 uri(字符串)到 WebSocketHandler 和订单信息的映射。Spring 将知道设置哪个 url 来连接这个地图，在我们的例子中是<a class="ae mk" href="http://localhost:8080/push." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="44d3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当然，您可以创建任意多的路径和处理程序条目。</p><p id="d092" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">目前，我们需要实现 WebSocketHandler。有了这个类，我们就可以处理 WebSocketSession，换句话说，就是读取和发送消息。</p><p id="3cbb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们在这里留下了 Mono.empty，但是后面将展示完整的实现。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d1b8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">配置类的完整代码。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="4a20" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何阅读信息？</h1><p id="f280" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">读取逻辑应该作为 WebSocketHandler 实现的一部分提供。</p><p id="2a1c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们需要对 WebSocketSession 对象进行操作，只需调用 receive()方法即可获得反应流并订阅/修改它。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="77b9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">怎么发消息？</h1><p id="f850" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们继续修改 WebSocketHandler 的实现之前，我们需要创建一个模型，并将它发送给客户端。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="844d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">此外，我们需要创建一个将事件作为反应流提供的服务，因为 WebSocketSession 需要它。</p><p id="9209" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">该服务的主要要求是能够向现有流添加新事件。</p><p id="28dc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，我们的事件类接口将如下所示:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e70c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了实现这项服务，将使用一个符合我们所有要求处理器。这个处理器可以处理无限量的事件，并与多个订阅者共享。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e328" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里:</p><ul class=""><li id="9114" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mr mc md me bi translated">publish()创建共享通量流的 ConnectableFlux。</li><li id="fade" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mr mc md me bi translated">autoConnect()将这个 ConnectableFlux 连接到一个名为 subscribe 方法的地方。</li></ul><p id="1b05" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它还可以用于方法 replay(int ),该方法缓存最新的元素并将其返回给新的订阅者。</p><p id="d4c9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">发送消息看起来像这样。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a3b7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">正如您所看到的，在向客户端发送对象之前，我们需要将其转换为 JSON。Spring WebFlux 没有提供默认的机制来将对象转换为 websockets 的 JSON。</p><p id="1425" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在这段代码中使用了 Jackson 的 object mapper # writeValueAsString。</p><p id="60a0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，我们可以将我们的 DefaultWebSocketHandler 联合读取和发送到一个流。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="f168" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">演示</h1><p id="e94e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">出于演示目的，将添加简单的事件发生器，它每秒钟增加一个计数器，并发送一个事件及其值。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a65a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">不要忘记在应用程序中启用调度程序。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="08aa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">客户</h1><p id="e33b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">对于客户端将使用角。</p><p id="623f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如何安装它你可以在官方文档中找到。</p><p id="88c1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">要做的步骤:</p><p id="2058" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">创建项目。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="a937" class="mx jw in mt b gy my mz l na nb">ng new projectname</span></pre><p id="85eb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">修改 app.component.ts</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8582" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里我们使用 rxjs websockets。</p><p id="1841" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">要在网络界面中查看我们的消息，只需更新 app.component.html 即可。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c859" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行应用程序，在浏览器中键入<a class="ae mk" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank"> localhost:4200 </a>并查看结果。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/577aad388eccb5b876c15279ff01aaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN-eNfRGp0_GvvYs30-M6A.png"/></div></div></figure><h1 id="4766" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何保护 websockets？</h1><ol class=""><li id="eaa9" class="lw lx in kv b kw kx la lb le nd li ne lm nf lq mb mc md me bi translated">使用 SSL/TLS 上的 web sockets(was://protocol)。</li><li id="8357" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">验证客户端和服务器数据。</li><li id="9c3d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">仅在授权后使用 websocket 连接。</li><li id="5b76" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在 websocket 连接之前，生成可以通过 HTTP 检索的用户唯一推送 id，并使用它与服务器通信。</li><li id="f2c5" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">使用原始标题。</li></ol><h1 id="6ef0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="f207" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">本文展示了使用反应式 websockets 配置、读取和发送消息的基础知识。涵盖了服务器端配置和客户端演示。</p><p id="7397" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代码示例可以在<a class="ae mk" href="https://github.com/MaxNeutrino/snippets/tree/master/webflux-websocket" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</p></div></div>    
</body>
</html>