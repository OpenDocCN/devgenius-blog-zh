<html>
<head>
<title>DSA | Kahn’s algorithm for Topological sorting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DSA | Kahn 的拓扑排序算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dsa-kahns-algorithm-for-topological-sorting-33c8587985a1?source=collection_archive---------5-----------------------#2022-05-17">https://blog.devgenius.io/dsa-kahns-algorithm-for-topological-sorting-33c8587985a1?source=collection_archive---------5-----------------------#2022-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4c6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文是数据结构与算法系列的一部分。在这个系列中，我将尝试详细解释重要而棘手的数据结构和算法主题。</p><p id="e375" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将介绍 Kahn 的拓扑排序算法。</p><h1 id="9ea6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">定义</h1><p id="a833" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先让我们理解什么是拓扑排序。</p><p id="1411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">define: topological sorting</code></p><blockquote class="lp lq lr"><p id="af52" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated"><strong class="jm io">有向图的拓扑排序</strong>是其顶点的线性排序，使得对于从顶点<em class="in"> u </em>到顶点<em class="in"> v </em>的每个有向边<em class="in"> uv </em>，在排序中<em class="in"> u </em>在<em class="in"> v </em>之前</p></blockquote><h1 id="cf68" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">应用</h1><p id="27fe" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们可以使用拓扑排序来根据它们之间的依赖关系安排一系列的工作或任务。</p><p id="64a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作业由顶点表示，如果作业<em class="ls"> u </em>必须在作业<em class="ls"> v </em>开始之前完成，则存在从<em class="ls"> u </em>到<em class="ls"> v </em>的边(让我们以课程安排为例，其中每个顶点将表示一个课程，从<em class="ls"> u </em>到<em class="ls"> v </em>的边意味着课程<em class="ls"> u </em>必须被视为有资格参加课程<em class="ls"> v </em></p><h1 id="45d1" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">图形数据结构基础</h1><p id="b59e" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在进入卡恩算法之前。让我们复习一下算法中用到的图形数据结构的一些基础知识。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/e503c7dd87bc271d2b6f855e76548984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*7rSnuQgXjbM0V3rO3hG08w.jpeg"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">图形的类型</figcaption></figure><ul class=""><li id="a4b8" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated">顶点:节点称为顶点(例如。a、B、C、D)</li><li id="5500" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">边:两个顶点之间的连接称为边(例如。AB、AC、AD)</li><li id="9980" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">路径:从一个顶点到另一个顶点的顶点序列(例如。BAC)</li><li id="895f" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">循环:起点和终点相同的路径</li><li id="d1b5" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">度:这只适用于未加权的图。这是连接到给定顶点的边的数量</li><li id="7f59" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">入度:对于有向图，这是给定顶点的入边数</li><li id="224b" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">出度:类似于入度，这是给定顶点的出边数</li></ul><h1 id="914f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">卡恩算法</h1><p id="70a5" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这个算法中，我们选择顶点的顺序与最终的拓扑顺序相同。</p><ol class=""><li id="627d" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mw mo mp mq bi translated">首先，我们选择入度为零的节点，并将其存储为一个队列。非空非循环图中必须至少存在一个这样的节点。</li><li id="31fd" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">然后我们遍历队列，直到至少有一个节点。</li><li id="4b8d" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">在每次迭代中:首先我们将节点添加到结果列表(L)中。然后我们覆盖所有链接的节点并减少它们的入度。如果入度变为零，那么我们将其添加到队列中</li></ol><p id="aa99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看一下伪代码。</p><pre class="lx ly lz ma gt mx lo my mz aw na bi"><span id="1af6" class="nb kj in lo b gy nc nd l ne nf">L ← Resultant List [Initial state: {}]<br/>S ← Queue of all the nodes with In-Degree zero</span><span id="120f" class="nb kj in lo b gy ng nd l ne nf">while S is not empty do<br/>    remove a node n from S<br/>    add n to L<br/>    for each node m with an edge e from n to m do<br/>        decrease the In-Degree of m<br/>        if In-Degree of m is 0 then<br/>            insert m into S</span><span id="afee" class="nb kj in lo b gy ng nd l ne nf">if any node have In-Degree &gt; 0 then<br/>    return error   (graph has at least one cycle)<br/>else <br/>    return L   (a topologically sorted order)</span></pre><h1 id="e935" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">例子</h1><p id="501b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">让我们举一个例子，试着用卡恩的算法来解决这个问题。</p><h2 id="7435" class="nb kj in bd kk nh ni dn ko nj nk dp ks jv nl nm kw jz nn no la kd np nq le nr bi translated">问题陈述</h2><p id="1d9b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">总共有<code class="fe ll lm ln lo b">numCourses</code>门课程需要你去修，分别标为从<code class="fe ll lm ln lo b">0</code>到<code class="fe ll lm ln lo b">numCourses - 1</code>。给你一个数组<code class="fe ll lm ln lo b">prerequisites</code>，其中<code class="fe ll lm ln lo b">prerequisites[i] = [ai, bi]</code>表示如果你想上<code class="fe ll lm ln lo b">ai</code>课，你<strong class="jm io">必须先</strong>上<code class="fe ll lm ln lo b">bi</code>课。</p><ul class=""><li id="83f4" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated">例如，对子<code class="fe ll lm ln lo b">[0, 1]</code>表示，要学习课程<code class="fe ll lm ln lo b">0</code>，你必须先学习课程<code class="fe ll lm ln lo b">1</code>。</li></ul><p id="c15b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">返回<em class="ls">完成所有课程</em>所需的课程顺序。如果有许多有效答案，返回其中的任何一个。如果无法完成所有课程，返回<strong class="jm io">一个空数组</strong>。</p><h2 id="b482" class="nb kj in bd kk nh ni dn ko nj nk dp ks jv nl nm kw jz nn no la kd np nq le nr bi translated">解决办法</h2><p id="b6d0" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">让我们先了解一下这个图会是什么样子。</p><ol class=""><li id="9965" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mw mo mp mq bi translated">每个课程都将是一个节点</li><li id="b9f8" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">每个<code class="fe ll lm ln lo b">prerequisites</code>元素将代表来自<code class="fe ll lm ln lo b">bi -&gt; ai</code>的一条边</li></ol><p id="7fd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于输入:<code class="fe ll lm ln lo b">numCourses = 4, prerequisites = [[1,0], [2,0], [3,1], [3, 2]]</code>。这是图表的样子。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bb723a0307fa0f552ccd92ab7995bb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*9bZbvvDxPtdD5OZpyOX6HQ.jpeg"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">图表</figcaption></figure><p id="8b9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们在看代码之前，先试着理解一下算法的流程。</p><ol class=""><li id="804e" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mw mo mp mq bi translated">如我们所见，只有节点 0 的入度为零，因此我们将把它添加到队列中。</li><li id="2dd8" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">然后我们将循环遍历队列，直到它不为空。</li><li id="1e2a" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated"><strong class="jm io">在第一次迭代中</strong>:我们将有节点 0。我们会把它添加到列表中。然后我们将通过节点 1 和节点 2。然后降低节点 1 和节点 2 的入度。在减少后，两者的入度都变为零，所以我们将两者都添加到队列中。</li><li id="59ac" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">因为节点 1 和 2 都在队列中，所以我们将进行另一次迭代。如果这样，我们可以得到节点 1 或节点 2(这将取决于哪个先被添加，两个答案都是正确的)。</li><li id="97fe" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated"><strong class="jm io">在第二次迭代中</strong>:假设我们有节点 1。然后我们会把它添加到列表中。然后减少节点 3 的入度。即使在减少之后，节点 3 的入度也不会为零。因此我们不会将其添加到队列中。</li><li id="4ee7" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated">在第三次迭代中:我们将有节点 2。然后我们会把它添加到列表中。然后减少节点 3 的入度。现在，节点 3 的入度为零，因此我们将把它添加到队列中。</li><li id="8ec9" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mw mo mp mq bi translated"><strong class="jm io">在最后一次迭代中</strong>:我们将有节点 3。然后我们会把它添加到列表中。由于它没有任何邻居，所以我们将停止。</li></ol><p id="d4a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此我们的<strong class="jm io">最终列表</strong>将是<code class="fe ll lm ln lo b">[0, 1, 2, 3]</code>或<code class="fe ll lm ln lo b">[0, 2, 1, 3]</code>。</p><p id="6b32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看最终的实现。</p><pre class="lx ly lz ma gt mx lo my mz aw na bi"><span id="cb18" class="nb kj in lo b gy nc nd l ne nf">public int[] findOrder(int numCourses, int[][] prerequisites) {<br/> int[] inDegree = new int[numCourses];<br/> List&lt;Integer&gt;[] am = new List[numCourses];<br/> <br/> for (int i = 0; i &lt; numCourses; i++) {<br/>  am[i] = new ArrayList&lt;&gt;();<br/> }<br/> <br/> // Populating adjacency matrix and inDegree<br/> for (int i = 0; i &lt; prerequisites.length; i++) {<br/>  inDegree[prerequisites[i][0]]++;<br/>  am[prerequisites[i][1]].add(prerequisites[i][0]);<br/> }<br/> <br/> Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();<br/> <br/> // Checking which course have inDegree as 0 and <br/> // adding it to the Queue<br/> for (int i = 0; i &lt; numCourses; i++) {<br/>  if (inDegree[i] == 0) {<br/>   q.offer(i);<br/>  }<br/> }<br/> <br/> // This will be the final order of courses<br/> List&lt;Integer&gt; courseOrder = new ArrayList&lt;&gt;();<br/> <br/> // Looping through the Queue until it is not empty<br/> while (!q.isEmpty()) {<br/>  int size = q.size();<br/>  for (int i = 0; i &lt; size; i++) {<br/>   // Adding current course to List<br/>   int currentCourse = q.poll();<br/>   courseOrder.add(currentCourse);<br/>   // Looping throgh all the courses which you are eligible now <br/>   for (int course: am[currentCourse]) {<br/>    // Decreasin the inDegree of course<br/>    inDegree[course]--;<br/>    // If inDegree become 0 then we will add it to the Queue<br/>    if (inDegree[course] == 0) {<br/>     q.offer(course);<br/>    }<br/>   }<br/>  }<br/> }<br/> <br/> // If there is any node which still have inDegree greater then 0<br/> // Which means there exist a cycle and course scheduling is not possible<br/> for (int i = 0; i &lt; numCourses; i++) {<br/>  if (inDegree[i] != 0) {<br/>   return new int[0];<br/>  }<br/> }<br/> <br/> int[] res = new int[numCourses];<br/> <br/> for (int i = 0; i &lt; courseOrder.size(); i++) {<br/>  res[i] = courseOrder.get(i);<br/> }<br/> <br/> // Otherwise we will return the course order<br/> return res;<br/>}</span></pre></div></div>    
</body>
</html>