# 设计模式—原型

> 原文：<https://blog.devgenius.io/design-pattern-prototype-59bffd7d29ab?source=collection_archive---------4----------------------->

原型设计模式详解

![](img/fea359839680cacf25728651dc4fa0fe.png)

Avi Werde 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

原型设计模式是由四人帮(g of)提出的另一种创造性的设计模式。当我们已经有了一个与我们想要创建的对象相同类型(原型)的对象时，就使用这个。我们可以克隆现有类型的对象来创建一个新的。

# 原型设计模式是什么？

当创建对象的成本很高，或者克隆一个现有的对象比从头创建一个更容易时，原型设计模式是最常用的。这可能是当我们试图重构和优化代码中的某个模块时，通常使用这种模式的原因。

原型设计模式中的对象是从另一个原型实例克隆的，而不是用“new”创建的。这不是规则，而是惯例。

原型模式是用一个称为*注册表*的支持或助手类创建的。这个类可以保存一组原型对象，并可以在需要时快速克隆一个。这个助手类本身可以使用其他设计模式，比如 Singleton。

原型模式通常用一个*可克隆的*接口实现。这就是我们如何摆脱称*为新*的方法。

# 原型设计模式解决的问题

*   创建新对象的成本很高——这有助于隐藏创建新实例的复杂性。复制或克隆对象有时比创建新对象更有效。
*   不使用*新建*创建对象。
*   它有助于在不知道类型的情况下生成新对象。

# 原型设计模式的应用

![](img/f89c983d9be409530dff8b09b6d60a7c.png)

杰里米·毕晓普在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

当实现原型设计模式时，您应该遵循某些指导原则。

*   对象的克隆——在原型设计模式中，我们克隆对象并且不使用*新的*操作符。即使对象是克隆的而不是新建的，每个克隆的实例都是唯一的。
*   可克隆接口——原型模式，因为它使用对象的克隆，所以通常用可克隆接口来实现。通常是原型对象的抽象类实现了这个接口。
*   注册表——原型模式通常伴随着一个注册表类。这个类保存了原型对象，需要时会克隆这些对象。

让我们看一些代码—

# 抽象类—食物

抽象类食物

这里我们创建了一个抽象的食物类。这个类将是我们想要克隆的所有对象类型的超类。它实现了可克隆接口的 clone()方法。它还可能包含一些成员变量和函数。

# 具体类

下面是 Food 类型的几个具体类的实现。这些是我们想要克隆对象的类的实现。它主要是成员变量及其 getters 和 setters。在一个更真实的应用程序中，我们可以想象这些类可能不那么简单，因为正如我们所讨论的，它们的创建是昂贵的，这就是为什么我们使用这种设计模式。

中餐

另一个具体的类—

意大利食品

# 登记处

就像我们之前讨论的，原型模式通常有一个注册表类。这是我们存放克隆对象的地方。

登记处

正如你在代码中看到的，我们创建了一个原型图。这些原型是用*新*制造的。我们将在应用程序开始时创建所有这样的对象并保存它们。

这个类还包含一个方法 *getNewItem()* 。这个方法用一个类型(名称)来分类。此方法克隆所提供类型的对象并返回一个对象。我们将在下面的代码中看到，每当我们想要获取特定类型对象的新实例时，都会调用该方法。

# 演示代码

主要的

在第 6 行，我们正在迎合注册中心。这很可能是一个单胎。我们选择保持我们的注册表简单。

现在在第 7 行，我们调用前面提到的 *getNewItem()* 方法。这个方法需要一个参数，并返回一个新的克隆对象。我们在这里使用 string 来标识类型，它很可能是类本身类型的一个*枚举*。我们得到一个类型为 *ChineseFood* 的新对象。类似地，我们在第 17 行再次调用 *getNewItem()* 。它再次返回类型为 *ChineseFood* 的新实例。

如你所见，我们在第 12 & 20 行打印对象。从输出中可以看到，这两个对象有不同的 ID。所以每次你克隆一个对象，你会得到一个从现有对象克隆的新对象。

# 输出

# 何时使用原型设计模式？

当创建一个新对象的成本很高时，通常使用原型设计模式。我们可以通过克隆相同类型的现有对象来获得对象的新实例。此克隆对象是同一类型的现有对象的副本。

# 限制

*   经常与其他模式一起使用——使用原型模式需要一个注册中心。这就变成了一个框架，你在另一个框架中使用一个设计模式。
*   非常不常见——这与 Singleton 相反。Singleton 是一种过度使用的模式，而 Prototype 并不经常使用。这可能是因为缺少我们可能想要使用这种设计模式的场景。
*   浅层复制——Prototype 进行浅层复制，这对于常见的字段类型来说是可以的，但是当我们在原型对象中有类似数组的东西时，可能会很麻烦。
*   制作对象本身的副本有时很复杂。

# 摘要

当创建一个给定类的实例很昂贵或者很复杂时，可以使用原型模式。

大多数情况下，它被用作重构的一部分，而不是工程师们一开始就想到的东西。

*撰写&编辑——维韦克·米塔尔*

[](https://www.linkedin.com/in/vivekmittal06) [## Vivek Mittal -首席软件工程师- Nuance Communications | LinkedIn

### 我是一名经验丰富的软件工程师，在软件工程方面有超过 10 年的经验。我有广泛的…

www.linkedin.com](https://www.linkedin.com/in/vivekmittal06) 

# 附加阅读

[](https://medium.com/dev-genius/software-design-patterns-1b41de14ab8b) [## 软件设计模式

### 软件设计模式概述

medium.com](https://medium.com/dev-genius/software-design-patterns-1b41de14ab8b) [](https://medium.com/dev-genius/design-pattern-singleton-fa0f676a5d16) [## 设计模式—单例

### 最常见的设计模式——单一模式的详细讨论

medium.com](https://medium.com/dev-genius/design-pattern-singleton-fa0f676a5d16) [](https://medium.com/dev-genius/design-pattern-builder-1ad55ed26120) [## 设计模式—构建器

### Builder 设计模式的详细讨论

medium.com](https://medium.com/dev-genius/design-pattern-builder-1ad55ed26120) [](https://medium.com/dev-genius/design-pattern-state-e0ed37cd853a) [## 设计模式—状态

### 状态设计模式的深入探讨

medium.com](https://medium.com/dev-genius/design-pattern-state-e0ed37cd853a)