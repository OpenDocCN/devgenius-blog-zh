<html>
<head>
<title>DP Basic Problems Part~1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DP 基本问题第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dp-basic-problems-part-1-5d21e1b2c213?source=collection_archive---------3-----------------------#2022-10-20">https://blog.devgenius.io/dp-basic-problems-part-1-5d21e1b2c213?source=collection_archive---------3-----------------------#2022-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f8482768a7ff1f8f169ba2899f1adb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zh6YXKF5etmYTDp2"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/photos/hHL08lF7Ikc" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="f9ab" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">(1)<a class="ae jz" href="https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1" rel="noopener ugc nofollow" target="_blank">0–1 背包问题</a></h1><p id="bccf" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给你<strong class="la io"> N </strong>件物品的重量和价值，将这些物品放入一个容量为<strong class="la io"> W </strong>的背包中，以获得背包中最大的总价值。请注意，每种商品我们只有<strong class="la io">一个数量。<br/>换句话说，给定两个整数数组<strong class="la io"> val[0..N-1] </strong>和<strong class="la io"> wt[0..N-1] </strong>，分别代表与<strong class="la io"> N </strong>项相关联的值和权重。同样给定一个表示背包容量的整数 W，找出<strong class="la io"> val[] </strong>的最大值子集，使得这个子集的权重之和小于等于<strong class="la io"> W. </strong>不能分解一个物品，<strong class="la io">要么选择完整的物品，要么不选择(0–1 属性)</strong>。</strong></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/82157a876d38d5299c538fb66ef7ec19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mm7KolOIGvtjkPmtUibVSA.png"/></div></div></figure><p id="9843" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io"> <em class="mg">解决方案:</em> </strong></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/48e8cb0f70300d240ef9772d827cae12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5HcOMzPpX8BejjwR45XtA.png"/></div></div></figure><h1 id="0b4f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://www.codingninjas.com/codestudio/problem-details/count-ways-to-reach-nth-stairs_798650" rel="noopener ugc nofollow" target="_blank"> (2)计算到达第 N 级楼梯的方法</a></h1><p id="1a1a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你已经有了几级楼梯。最初，你在第 0 级楼梯，你需要到达第 n 级楼梯。每次你要么爬一步，要么爬两步。你应该返回从第 0 步爬到第 n 步的不同方式的数量。</p><p id="648b" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">例如:</strong></p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="6d42" class="mn kb in mj b gy mo mp l mq mr">N=3</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/dabb333b3ea26f5f0475a79a1b472553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*UMZHwM-YWe1uws1o.png"/></div></figure><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="bd72" class="mn kb in mj b gy mo mp l mq mr">We can climb one step at a time i.e. {(0, 1) ,(1, 2),(2,3)} or we can climb the first two-step and then one step i.e. {(0,2),(1, 3)} or we can climb first one step and then two step i.e. {(0,1), (1,3)}.</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/cb2a8d2e78a1b91d2a34c013e0fc5979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*iw2RMOKmma4bjBj8XnSkug.png"/></div></figure><p id="1ba5" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/fe31f6ea5ea774994ab81dc7804cab1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCI_oK7YyxPlhp7QJtA3iw.png"/></div></div></figure><h1 id="81f9" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://www.codingninjas.com/codestudio/problem-details/frog-jump_3621012" rel="noopener ugc nofollow" target="_blank"> (3)蛙跳</a></h1><p id="a3d2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">N 级长楼梯的第一级台阶上有一只青蛙。青蛙想到达第 n 级楼梯。HEIGHT[i]是第(i+1)级楼梯的高度。如果青蛙从第 I 级跳到第 j 级楼梯，那么跳跃中损失的能量由|HEIGHT[i-1] — HEIGHT[j-1] |给出。青蛙在第 I 层楼梯上，他可以跳到第(i+1)层或第(i+2)层。你的任务是找出青蛙从第一级楼梯到达第 n 级楼梯所用的最小总能量。</p><p id="a53a" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">例如</strong></p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="e94f" class="mn kb in mj b gy mo mp l mq mr">If the given ‘HEIGHT’ array is [10,20,30,10], the answer 20 as the frog can jump from 1st stair to 2nd stair (|20-10| = 10 energy lost) and then a jump from 2nd stair to last stair (|10-20| = 10 energy lost). So, the total energy lost is 20.</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/8142802a2eb8dd080b3bff68c2c1e1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUNTqWw764EpM22BQoPpvw.png"/></div></div></figure><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="343b" class="mn kb in mj b gy mo mp l mq mr">Recurrence Relation:</span><span id="bbc0" class="mn kb in mj b gy mw mp l mq mr">f(n)</span><span id="7da2" class="mn kb in mj b gy mw mp l mq mr">if n==0:return 0</span><span id="ef3c" class="mn kb in mj b gy mw mp l mq mr">left = f(n-1) + abs(arr[n]-arr[n-1])</span><span id="2003" class="mn kb in mj b gy mw mp l mq mr">if n&gt;1: <br/>      right = f(n-2) + abs([arr[n]-arr[n-2])</span><span id="3601" class="mn kb in mj b gy mw mp l mq mr">return min(left,right)</span></pre><p id="fe26" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/b1451361df204fe9b750a0e7a0dc9a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B83fPFqrZxL59KohUhwMLA.png"/></div></div></figure><p id="4f49" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io"> <em class="mg">空间优化代码</em> </strong></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/a07672d4eb6f765f0b86f9053fece177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JdabmpYLw9NLo0x4Cl-jA.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/322117ed211758e76a3e085658ebe422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j_JhdDPcL2Bi7_HWJFCRg.png"/></div></div></figure><h1 id="9eff" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://practice.geeksforgeeks.org/problems/stickler-theif-1587115621/1?utm_source=gfg&amp;utm_medium=article&amp;utm_campaign=bottom_sticky_on_article" rel="noopener ugc nofollow" target="_blank"> (4)粘人小偷</a></h1><p id="8e26" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">小偷想从一个拥有排成一行的房子的社会中抢劫钱财。他是一个古怪的人，在抢劫房屋时遵循一定的规则。按照规则，他将<strong class="la io">永远不会连续打劫两栋房子</strong>。同时，他希望<strong class="la io">最大化</strong>他<strong class="la io">抢劫</strong>的金额。小偷知道哪所房子里有多少钱，但却想不出一个最佳的抢劫策略。他请求你帮助他找到最大的钱，如果他严格遵守规则的话。每家都有一定数量的钱。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="ab46" class="mn kb in mj b gy mo mp l mq mr"><strong class="mj io">Input:<br/></strong>n = 6<br/>a[] = {5,5,10,100,10,5}<br/><strong class="mj io">Output: </strong>110<br/><strong class="mj io">Explanation: </strong>5+100+5=110</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/c4a49494aee84bbb65d7db852dcc5b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Lpwl9qv04CU6hrFA4qyKA.png"/></div></div></figure><p id="3268" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/457712f4bb34d71081a203e2771ea223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ip70_nnll6UHjvfYvuPVcw.png"/></div></div></figure><p id="bc15" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">制表方法:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/4c8d31be2cec934d63e403094a9db4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3-uvI9gBWVtHLCHrY3s4A.png"/></div></div></figure><p id="b045" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">空间优化代码</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/e069ce711810cb634cc942caddafca30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUWYDLPrXfEY2F1rghjcng.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/22f7a7fd183ff499a0b05400dd3ddf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcRRo8twNaWo7jSEsAfJ8g.png"/></div></div></figure><h1 id="b830" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://leetcode.com/problems/house-robber-ii/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> (5)入室抢劫者 II </strong> </a></h1><p id="ac93" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你是一个专业的强盗，计划沿街抢劫房屋。每所房子都藏了一定数量的钱。这个地方所有的房子都排成一圈。这意味着第一栋房子是最后一栋的邻居。同时，相邻的房子都有一个安全系统连接，如果两个相邻的房子在同一个晚上被闯入<strong class="la io">它会自动联系警察。</strong></p><p id="1d5f" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">给定一个整数数组<code class="fe nf ng nh mj b">nums</code>代表每套房子的钱数，返回<em class="mg">你今晚可以抢劫的最大金额</em> <strong class="la io"> <em class="mg">而不报警</em> </strong>。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="57a3" class="mn kb in mj b gy mo mp l mq mr"><strong class="mj io">Input:</strong> nums = [2,3,2]<br/><strong class="mj io">Output:</strong> 3<br/><strong class="mj io">Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/5b5dbc70a604a2e2c10b16ed65cdefc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdWBDGQKSdoh6kQAlJz_Ew.png"/></div></div></figure><p id="aa5d" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/e1f65ded91142ed1e428f8b145a95855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0m1Oa0jkNSbi7gK0TvEHw.png"/></div></div></figure><h1 id="48f1" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003" rel="noopener ugc nofollow" target="_blank"> (6)忍者的训练</a></h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/5c7a85aa8ed1e7d1b643617451e5ac2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4S8tTNjZhLg2M8n1tkXb9Q.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/7189d72c7487b4e25291bcd0694f8e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RljYdERSGXpp8ZId2hSZIQ.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/69bc2ecf45dfdadca59f0dd1b29f7203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hf2xFOgO8rrf7FZagcSnbQ.png"/></div></div></figure><p id="5dee" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/64d32e7b66a77d8ab45a1ad67d6a82b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIf84T-QvtXBf6Y61YoVSw.png"/></div></div></figure><h1 id="6b6f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://leetcode.com/problems/unique-paths/" rel="noopener ugc nofollow" target="_blank"> (7)独特路径</a></h1><p id="3cbd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">一个<code class="fe nf ng nh mj b">m x n</code>网格上有一个机器人。机器人初始位于<strong class="la io">左上角</strong>(即<code class="fe nf ng nh mj b">grid[0][0]</code>)。机器人试图移动到<strong class="la io">右下角</strong>(即<code class="fe nf ng nh mj b">grid[m - 1][n - 1]</code>)。机器人在任何时候只能向下或向右移动。</p><p id="55cf" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">给定两个整数<code class="fe nf ng nh mj b">m</code>和<code class="fe nf ng nh mj b">n</code>，返回<em class="mg">机器人可以到达右下角</em>的可能唯一路径的数量。</p><p id="a994" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">测试用例的生成使得答案将小于或等于<code class="fe nf ng nh mj b">2 * 109</code>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/30f3382bc68685ed917a640f0c90a0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o2GoWM9YETiYExI6.png"/></div></div></figure><p id="ba19" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/9cb06e425d3c80a93a196c7e81f062a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8p8-x3B1MPy5A17EaWTGsg.png"/></div></div></figure><h1 id="b798" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://leetcode.com/problems/unique-paths-ii/" rel="noopener ugc nofollow" target="_blank"> (8)独特的路径二</a></h1><p id="ccab" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给你一个<code class="fe nf ng nh mj b">m x n</code>整数数组<code class="fe nf ng nh mj b">grid</code>。有一个机器人最初位于<strong class="la io">左上角</strong>(即<code class="fe nf ng nh mj b">grid[0][0]</code>)。机器人试图移动到<strong class="la io">右下角</strong>(即<code class="fe nf ng nh mj b">grid[m-1][n-1]</code>)。机器人在任何时候只能向下或向右移动。</p><p id="1102" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">在<code class="fe nf ng nh mj b">grid</code>中，障碍物和空间分别标记为<code class="fe nf ng nh mj b">1</code>或<code class="fe nf ng nh mj b">0</code>。机器人走的路径不能包含任何作为障碍物的正方形。</p><p id="82f4" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">返回<em class="mg">机器人到达右下角</em>可能采用的唯一路径的数量。</p><p id="36b7" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">测试用例的生成使得答案将小于或等于<code class="fe nf ng nh mj b">2 * 109</code>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8661d48c709a7cf4c7aa1ccf9ffe21da.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/0*UklxEh0pTuTHczfy.jpg"/></div></figure><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="65db" class="mn kb in mj b gy mo mp l mq mr"><strong class="mj io">Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br/><strong class="mj io">Output:</strong> 2<br/><strong class="mj io">Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.<br/>There are two ways to reach the bottom-right corner:<br/>1. Right -&gt; Right -&gt; Down -&gt; Down<br/>2. Down -&gt; Down -&gt; Right -&gt; Right</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/e7e8584cf433697b73b5d7414d8fa651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJXtcY7BUObTspUXr50E5g.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/c36d94f1d22cb990b11907b6674abbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgVXvEh5jBxoQknKeEuj0Q.png"/></div></div></figure><p id="9e57" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/fc51d76a5aac0b847f30e4aa22010d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LI_dy7zoTZ6CV6BHuUG0eA.png"/></div></div></figure><h1 id="ba2f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://leetcode.com/problems/minimum-path-sum/" rel="noopener ugc nofollow" target="_blank"> (9)最小路径和</a></h1><p id="9205" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给定一个填充了非负数的<code class="fe nf ng nh mj b">m x n</code> <code class="fe nf ng nh mj b">grid</code>，找出一条从左上到右下的路径，使沿其路径的所有数字之和最小。</p><p id="7e84" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">注意:</strong>在任何时间点，您只能向下或向右移动。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="0567" class="mn kb in mj b gy mo mp l mq mr"><strong class="mj io">Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]<br/><strong class="mj io">Output:</strong> 7<br/><strong class="mj io">Explanation:</strong> Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6791433c6783318b9487f82fc5056fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*z0EW6vneOFVIzDoigg_24g.png"/></div></figure><p id="d346" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">解决方案:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/7874e1405081ef9733f3106fd0b2d9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJ-6dE5JkvSj2T2H3wbvfw.png"/></div></div></figure><h1 id="e928" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><a class="ae jz" href="https://leetcode.com/problems/target-sum/" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="nv">【10】目标总和</em> </strong> </a></h1><p id="1a67" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给你一个整数数组<code class="fe nf ng nh mj b">nums</code>和一个整数<code class="fe nf ng nh mj b">target</code>。</p><p id="8e30" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">您希望通过在 nums 中的每个整数前添加符号<code class="fe nf ng nh mj b">'+'</code>和<code class="fe nf ng nh mj b">'-'</code>中的一个来构建 nums 的<strong class="la io">表达式</strong>，然后连接所有的整数。</p><ul class=""><li id="941e" class="nw nx in la b lb mb lf mc lj ny ln nz lr oa lv ob oc od oe bi translated">比如说<code class="fe nf ng nh mj b">nums = [2, 1]</code>，你可以在<code class="fe nf ng nh mj b">2</code>前加一个<code class="fe nf ng nh mj b">'+'</code>，在<code class="fe nf ng nh mj b">1</code>前加一个<code class="fe nf ng nh mj b">'-'</code>，串联起来构建表达式<code class="fe nf ng nh mj b">"+2-1"</code>。</li></ul><p id="734c" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">返回您可以构建的不同<strong class="la io">表达式</strong>的数量，其计算结果为<code class="fe nf ng nh mj b">target</code>。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="84fd" class="mn kb in mj b gy mo mp l mq mr"><strong class="mj io">Input:</strong> nums = [1,1,1,1,1], target = 3<br/><strong class="mj io">Output:</strong> 5<br/><strong class="mj io">Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.<br/>-1 + 1 + 1 + 1 + 1 = 3<br/>+1 - 1 + 1 + 1 + 1 = 3<br/>+1 + 1 - 1 + 1 + 1 = 3<br/>+1 + 1 + 1 - 1 + 1 = 3<br/>+1 + 1 + 1 + 1 - 1 = 3</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/7e0c4bda285905c2c61c8bd18ab35738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U9qdg0yyLf7wdGQt.png"/></div></div></figure><p id="4518" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io"> <em class="mg">解决方案:</em> </strong></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/78f731f9a1f9a287a519b666a8cde9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPqzCgmeMtFxxORj8CX7WA.png"/></div></div></figure><p id="6184" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">查看类似的博客:</p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/10-daily-practice-problems-day-12-619934ae6e98"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">10 个日常练习题~第 12 天</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">1.除自身以外的数组乘积</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">blog.devgenius.io</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jt ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@Mr.DataScientist/stacks-problems-2cac2f450422" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">堆栈问题…！！！！</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">让我们来解决一些著名的问题，这些问题可以通过堆栈轻松解决。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy jt ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/10-daily-practice-problems-day-8-c303db2bd1ef"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">10 个日常练习题~第 8 天</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">1.同一棵树</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">blog.devgenius.io</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy jt ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@Mr.DataScientist/subarray-problems-d515e1f0fbbf" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">子阵列问题</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">1.最大乘积子阵列</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="pb l ov ow ox ot oy jt ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@Mr.DataScientist/10-daily-practice-problems-day-3-6470449e5cd5" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">10 个日常练习题~第三天</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">1.K-组中的反向节点</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="pc l ov ow ox ot oy jt ok"/></div></div></a></div><h1 id="8205" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> <em class="nv">参考文献:</em> </strong></h1><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="pd pe l"/></div></figure><div class="oh oi gp gr oj ok"><a href="https://www.youtube.com/c/NeetCode" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">尼特码</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">以前的 Neet 和现在的 SWE @ Google，也是我热爱教学！(不在教育、就业或培训领域)…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.youtube.com</p></div></div><div class="ot l"><div class="pf l ov ow ox ot oy jt ok"/></div></div></a></div></div></div>    
</body>
</html>