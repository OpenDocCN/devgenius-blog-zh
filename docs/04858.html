<html>
<head>
<title>Deno + Svelte (Part 2): Using Deno functions in Svelte ❤️🦕</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Deno + Svelte(第2部分):在Svelte ❤️中使用Deno函数🦕</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deno-svelte-part-2-using-deno-functions-in-svelte-%EF%B8%8F-2386accd4274?source=collection_archive---------3-----------------------#2021-05-13">https://blog.devgenius.io/deno-svelte-part-2-using-deno-functions-in-svelte-%EF%B8%8F-2386accd4274?source=collection_archive---------3-----------------------#2021-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f321f3ce740c35c51906498923074771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqxcDS9nEwRko3OvXUSJDA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在你的苗条应用中安全地运行任何JS、TS或wasm</figcaption></figure><p id="6262" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上一次<a class="ae kx" href="https://douganderson444.medium.com/deno-svelte-compiled-frontend-without-package-headaches-d336f1a6555a" rel="noopener">我写这个话题</a>的时候，苗条的生态系统还处于它的婴儿期。我们可以用Deno编译一个苗条的脚本，但仅此而已。</p><p id="30a8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">自第一篇文章以来，已经发生了一些很好的改进:</p><ol class=""><li id="c1ec" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">苗条的生态系统已经成长为更好地支持Deno(通过<a class="ae kx" href="https://github.com/crewdevio/Snel" rel="noopener ugc nofollow" target="_blank"> Snel </a>)，并且</li><li id="1e69" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">我对如何与来自Svelte的Deno互动的想法已经成熟。</li></ol><p id="b4cd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们在这些部分中描述我的编码经验:</p><p id="ab44" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">A部分:Snel——使用Deno构建苗条的应用程序！</strong></p><p id="c2b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">B部分:Snel —将Svelte远程连接到Deno</strong></p><p id="8547" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">C部分:使用来自Svelte的Deno方法</strong></p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="dd4f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">A区— Snel </strong></p><p id="a9cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们有了一个在Deno中构建苗条应用的萌芽框架:<a class="ae kx" href="https://github.com/crewdevio/Snel" rel="noopener ugc nofollow" target="_blank"> Snel </a>。我想尝试在没有任何Nodejs交互的情况下，100%用Deno构建这个苗条的应用程序。Snel是最有希望的答案。</p><p id="2519" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">TL；博士:基本上，它是有效的！ <em class="lt">多半。</em></p><p id="96dd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用Snel的嵌入式Trex工具按照Snel的说明进行操作，可以让您非常快速地完成一个项目。然而，如果你想做一些更复杂的汇总工作(比如你的精简代码中的一个文件),那么对T2插件和T3的支持还不够成熟。但到目前为止，导入一个<code class="fe lu lv lw lx b">json</code>文件是Snel唯一不让我做的事情。不幸的是，Snel似乎也不允许你从你的细长代码中调用<a class="ae kx" href="https://deno.land/manual/examples/read_write_files" rel="noopener ugc nofollow" target="_blank"> Deno.readFile </a>(),所以我对这个问题的解决办法有点困惑。最后，我只是复制并粘贴了我正在寻找的<code class="fe lu lv lw lx b">json config data</code>并继续前进。我想很快会有一个解决这种小事的方法。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="90e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">B部分:Snel — Deno连接</strong></p><p id="f882" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好了，我们有了一个可以用Deno构建的工作前端。现在是激动人心的部分！</p><p id="559b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们知道Deno最好的一点是，你可以从“net”和“read/write”这样的环境中<a class="ae kx" href="https://deno.land/manual@v1.10.1/getting_started/permissions" rel="noopener ugc nofollow" target="_blank">保护你的JavaScript代码</a>,以真正保持对可编程访问的控制。这在运行其他人的代码(OPC)时尤其重要。甚至<strong class="kb io"> <em class="lt">更重要的是</em> </strong>当你用<strong class="kb io"> <em class="lt">你的</em> </strong>数据运行别人的代码时。您最不希望看到的是一些内置功能、深度嵌套的库或JavaScript bug将您的个人信息偷偷转移到远程服务器。</p><p id="3250" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们希望在Deno中执行其他人的代码(OPC ),但是在CLI之外，所以我们需要一个前端来与Deno交互——因为<a class="ae kx" href="https://github.com/denoland/deno/discussions/3234" rel="noopener ugc nofollow" target="_blank">没有Deno标准GUI</a>—我们可以使用Svelte作为我们的GUI，并建立客户端-服务器关系来相互交互。</p><p id="d929" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是我们需要一种方法，从我们纤细的浏览器代码中获取Deno的命令和数据。</p><p id="a1b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">回车:远程过程调用(RPC) </strong></p><p id="d0c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">RPC 很酷，就像电影《阿凡达》中的<a class="ae kx" href="https://www.imdb.com/title/tt0499549/" rel="noopener ugc nofollow" target="_blank">或者手套箱。你在那里得到所有的功能，而不是真的在那里。安全距离内的功能。</a></p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/70a75bb86fa360983a2773d01f87983b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*ilh_i_b9zNNfYgWqgBbCeQ.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来源:<a class="ae kx" href="https://commons.wikimedia.org/wiki/File:S_Krikalev_with_miniglovebox.jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:S _ Krikalev _ with _ miniglovebox . jpg</a></figcaption></figure><p id="b30a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将RPC与Deno一起使用给了我们所有来自浏览器的控制，但也给了我们Deno所有的安全性。</p><p id="00d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另外:我也考虑过用其他方法进行试验，比如用服务器端渲染或Puppeteer来编译Deno中的JS代码，这也是可行的，但是在这些情况下，JavaScript在渲染过程中被剥离，使得我们的站点变成了相当静态的HTML。使用RPC，我们仍然可以在客户端代码中获得相当高的反应性。稍后我可能会写另一篇关于SSR/木偶版本的文章，但是现在我们是以RPC方式进行的😎<em class="lt">。</em></p><p id="4690" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> RPC类型:HTTP vs Websockets </strong></p><p id="1a9d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一个困境是选择HTTP POST，还是用websocket来回连接？考虑Deno运行的环境:如果你在本地主机上运行Deno，你可以使用websockets，如果你是Cloudflares持久对象的内部测试用户，你也可以使用websockets。但是如果你要在Vercel函数或普通的Cloudflare Workers中使用Deno，它们不支持websockets，所以你不能使用这些工具。</p><blockquote class="md"><p id="5933" class="me mf in bd mg mh mi mj mk ml mm kw dk translated">所以，由于HTTP是最小公分母，我选择了HTTP POST。</p></blockquote><p id="cb75" class="pw-post-body-paragraph jz ka in kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ig bi translated"><em class="lt">此外:Deno中最新的原生HTTP服务器(以及Deno Oak服务器)使用Rust的Hyper server，</em> <a class="ae kx" href="https://twitter.com/deno_land/status/1382049535782948870" rel="noopener ugc nofollow" target="_blank"> <em class="lt">支持HTTP/2 </em> </a> <em class="lt">因此，如果你的前端支持HTTP/2，你就是未来的prof。</em></p><p id="9748" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">既然我们已经选择了一个协议，我们需要找出RPC等式。我选择了<a class="ae kx" href="https://www.jsonrpc.org/" rel="noopener ugc nofollow" target="_blank"> JSON-RPC </a>，因为它看起来非常简单易懂。</p><p id="ba0c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了设置Deno JSON RPC，我们需要一个Deno服务器，所以我选择了Deno的<a class="ae kx" href="https://oakserver.github.io/oak/" rel="noopener ugc nofollow" target="_blank"> Oak服务器</a>,因为它让路由变得更容易。但是我们的服务器需要一个函数来执行，让我们使用一个Javascript + WebAssembly函数来返回“答案”给我们，并将其命名为<code class="fe lu lv lw lx b">getAnswer()</code>:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Deno Oak服务器的getAnswer()处理程序</figcaption></figure><p id="7212" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我选择执行WebAssembly (wasm)来说明一个目的。从字节码来看，你真的不知道这段代码在做什么。据你所知，它会把你珍贵的号码发送到某个远程服务器。</p><p id="5d2e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最棒的是，我们可以在Deno中以无信任的方式运行这个JavaScript和WebAssembly代码，因为默认情况下Deno不允许脚本访问互联网！或者硬盘。<a class="ae kx" href="https://deno.land/manual/getting_started/permissions" rel="noopener ugc nofollow" target="_blank">除非我们这么说</a>。</p><p id="02fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个原型的未来版本中，我们将从互联网上获得这个<code class="fe lu lv lw lx b">getAnswer</code>代码，而不必自己编写。但是为了举例，我们需要先自己设置一些东西，这样就可以了。</p><p id="675a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们已经有了答案处理程序，我们只需通过Oak中的<code class="fe lu lv lw lx b">.post() </code>路由访问它，并使用JSON-RPC返回响应。这个服务器路由所做的就是获取函数，运行它，并将响应返回给服务器。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="d950" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">C部分:在苗条中使用Deno方法</strong></p><p id="9fbd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">事情苗条的一面更简单，因为我们已经完成了Deno面的大部分处理。</p><p id="efc7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要在一个<code class="fe lu lv lw lx b">.js</code>文件中设置JSON-RPC方法来为我们执行实际的调用:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="34d4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">RPC函数对服务器进行fetch调用，传递任何参数。<code class="fe lu lv lw lx b">new <a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">Proxy</a></code> <a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">是一个标准的JavaScript对象</a>，它使我们能够截取并重新定义该对象的基本操作，因为我们希望将动作重定向到服务器，而不是在本地调用它。</p><p id="ad23" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了将这个远程RPC代理导入到Svelte中，我选择将它包含在将Svelte注入到HTML页面的<code class="fe lu lv lw lx b">main.js </code>中，但是您也可以将它导入到代码中的任何地方。但是这样一来，<code class="fe lu lv lw lx b">App.svelte</code>就可以将方法作为属性(prop)使用。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="27d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在在细长的代码中，我们可以调用我们的Deno TypeScript/JavaScript Wasm函数！</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="dfde" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那是非常漂亮的！代码在Deno中安全执行，但在Svelte中可以用作本地函数。</p><p id="536c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">利用这个框架，我们可以做更多的事情。比如从互联网上下载代码来运行，在Vercel中设置Deno函数，这样这些都可以无服务器地完成<em class="lt"/>。<em class="lt">无服务器</em>是单词了吗？</p><p id="1f82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我相信我会在未来的基础上继续努力(所以，点击“喜欢”按钮，订阅，等等，等等，更新)。</p><blockquote class="md"><p id="2b45" class="me mf in bd mg mh mi mj mk ml mm kw dk translated">所以，点击“喜欢”按钮，订阅等…等…更新</p></blockquote><p id="39ab" class="pw-post-body-paragraph jz ka in kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ig bi translated">在我之前关于Deno + Svelte 的文章中，通过一个简单的编译步骤，我们已经从这个设置的1.0版本走了很长的路。</p><p id="e556" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完整的代码在这里:</p><div class="mu mv gp gr mw mx"><a href="https://github.com/DougAnderson444/deno-rpc" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">DougAnderson444/deno-rpc</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">受rpcseed和Snel的启发，如果您想对数据运行不可信的javascript、typescript或webassembly代码，您…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jt mx"/></div></div></a></div></div></div>    
</body>
</html>