<html>
<head>
<title>LeetCode 1871. Jump Game VII</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 1871。跳跃游戏 VII</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/jump-game-vii-simplest-explanation-in-python-3433b401b2b8?source=collection_archive---------12-----------------------#2022-10-03">https://blog.devgenius.io/jump-game-vii-simplest-explanation-in-python-3433b401b2b8?source=collection_archive---------12-----------------------#2022-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="29f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单又神奇的问题！</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/c57809f2d46fe6672a3c21c7e1a32844.png" data-original-src="https://miro.medium.com/v2/format:webp/1*teCAcrvCkQW6ywWCCGaMiQ.png"/></div></figure><h2 id="8959" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">先看问题提示</h2><p id="f5f5" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">给定一个索引为 0 的二进制字符串 s 和两个整数 minJump 和 maxJump。一开始，你站在索引 0，等于' 0 '。如果满足以下条件，您可以从索引 I 移动到索引 j:</p><p id="08d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(1) i + minJump &lt;= j &lt;= min(i + maxJump, s.length — 1), and<br/> (2) s[j] == '0 '。</p><p id="715f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果可以达到索引 s . length-1 in s，则返回 true，否则返回 false。</p><p id="64a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示解释</strong></p><ul class=""><li id="667f" class="lo lp in jm b jn jo jr js jv lq jz lr kd ls kh lt lu lv lw bi translated">所以基本上我们得到了一个字符数组(称为字符串),我们在第一个位置。也给定了第一个位置将总是 0。</li><li id="a92b" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated">现在使用两个条件，我们需要达到最终位置。此外，最终位置不应为 1。</li></ul><h2 id="9c48" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">让我们看看例子:</h2><p id="f24b" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><p id="6c89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入:s = "011010 "，minJump = 2，maxJump = 3 <br/>输出:true <br/>解释:<br/>第一步，从索引 0 移动到索引 3。<br/>第二步，从索引 3 移动到索引 5。</p><p id="bd2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 2: </strong> <br/>输入:s = "01101110 "，minJump = 2，maxJump = 3 <br/>输出:false</p><h2 id="0fda" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">让我们来理解这两个例子</h2><p id="fafe" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated"><strong class="jm io">例:1 </strong></p><p id="f642" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，对于从 0 开始的第一个例子。我们可以移动到[2，3]的范围</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/e8760248f62bfe6c881b161e63ce9252.png" data-original-src="https://miro.medium.com/v2/format:webp/1*cmaMP7SeTBII24EliE6AYw.png"/></div></figure><p id="bb6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，因为在 2 处有 1，所以我们不能从那个位置开始跳。而 3 是 0，所以我们可以跳跃。从 3，我们可以跳到[5，6]。5 是最后一个索引，也是在 5，我们有' 0 '，所以我们到达了目的地。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/01c8a280ca006f4c069259b8d1a241ba.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OSIWzZ7M_hRqJWWs_mRVCw.png"/></div></figure><p id="b561" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 2: </strong></p><p id="2d3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，这里我们有 minJump 和 maxJump。首先，我们从 0 移动到位置[2，3]，如上例。现在，从 3，我可以达到[5，6]，但在这里 5 和 6 我们都有' 1 '，所以我们不能再跳了。因此这是死胡同。因此，我们返回错误。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/aec228043031955355f364a9740d055f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sEnE9_ccX1HpOnzMVsxmsQ.png"/></div></figure><p id="2839" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">我希望从以上两个例子中，问题是清楚的！！！</em></p><p id="44ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，让我们直接进入代码。我将逐行解释每个步骤。</p><p id="111b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们在索引 0 处，利用条件，我们得到了必须跳转的位置。</p><pre class="ki kj kk kl gt md me mf mg aw mh bi"><span id="fd1e" class="kq kr in me b gy mi mj l mk ml">index = 0<br/>a1, a2 = index+minJump, min(index+maxJump, len(s)-1)</span></pre><p id="1455" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们从 a1 和 a2 开始迭代，得到 0。但是等一下，我们需要一些东西来存储所有索引，以便进行回溯。</p><p id="8c6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们有两种选择，要么使用堆栈，要么使用队列。如果我们使用堆栈，那么该算法被称为深度优先搜索，如果我们使用队列，那么它被称为广度优先搜索。</p><p id="1cac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">让我们看看如果使用 DFS 会面临什么问题</strong></p><pre class="ki kj kk kl gt md me mf mg aw mh bi"><span id="1eff" class="kq kr in me b gy mi mj l mk ml">index = 0<br/>stack = []<br/>a1, a2 = index+minJump, min(index+maxJump, len(s)-1)<br/>for j in range(a1,a2+1):<br/>    if s[j] == '0':<br/>        stack.append(j)</span></pre><p id="e79d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我们想移动到下一个位置时，我们获取最后一个位置，并为该值指定 index。我们重复这个过程，直到堆栈不再为空。所以我们的代码会变成这样。</p><pre class="ki kj kk kl gt md me mf mg aw mh bi"><span id="610a" class="kq kr in me b gy mi mj l mk ml">class Solution(object):<br/>    def canReach(self, s, minJump, maxJump):<br/>        """<br/>        :type s: str<br/>        :type minJump: int<br/>        :type maxJump: int<br/>        :rtype: bool<br/>        """<br/>        if s[-1]=='1':<br/>            return False<br/>        stack = [0]<br/>        index = 0<br/><br/>        while index &lt; len(s) and len(ls) &gt; 0:<br/>            index = stack.pop()<br/>            a1, a2 = index+minJump,min(index+maxJump, len(s)-1)<br/>            for j in range(a1, a2+1):<br/>                if s[j] == '0':<br/>                    stack.append(j)<br/>            if index == len(s)-1 and s[index] == '0':<br/>                return True<br/>            <br/>        return(False)</span></pre><p id="3c71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个代码是 100%有效的，它可以工作。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/0c26843a708ddc78e68953d64d542ba8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eP5djQ1WgELhlmQiM_pcEg.png"/></div></figure><p id="fdd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等一下，当你回溯的时候，你是在栈中重新访问和添加已经访问过的元素。因此这个成本为 O(n)时间。你可以通过追踪这个例子来看。</p><p id="e513" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，现在为了不访问已经访问过的元素，我们使用了某种跟踪器(称为最远的)。这将追溯到我们达到的最大元素。让我们用例子来看看。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/2b98fdcc30f60516ba9fcdc0a04d9086.png" data-original-src="https://miro.medium.com/v2/format:webp/1*i3DKeJNXJvPjKOKQ9bjcdQ.png"/></div></figure><p id="8515" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个字符串，minJump 是 2，maxJump 是 5。我们用 f 作为最远的指针。现在下次我们带 max(minJump，最远+1)到 maxJump。因此，它将如下</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/f6e3f90dfe7e5ce01622fb33a94457d5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hyObMqlOmbFSrpatHYoBcg.png"/></div></figure><p id="1e1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，因为 9 和 10 是 1，所以我们不能添加到堆栈中，下一次跳转将从 8 开始。</p><p id="6b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样为了避免重复，我们取最大值。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/4bd686a18e4900d3dd753c42bb373fd8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4A34p-UAKkLLm0laDAml-w.png"/></div></figure><p id="d0c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因很简单，8+2 是 10，但我们已经访问了 10，所以我们利用最远的指针，即 f+1 = 11。所以我们考虑窗口[11，13]，这里 8+5 = 13。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/a1cbd85efae281af0cc4d8d23705623f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*T_BgcO5F4VBYX-2VOSK_8w.png"/></div></figure><p id="2ec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一班从 12 点到 14 点，我们到达目的地。</p><p id="ce71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以代码会变成这样，</p><pre class="ki kj kk kl gt md me mf mg aw mh bi"><span id="fed8" class="kq kr in me b gy mi mj l mk ml">class Solution(object):<br/>    def canReach(self, s, minJump, maxJump):<br/>        """<br/>        :type s: str<br/>        :type minJump: int<br/>        :type maxJump: int<br/>        :rtype: bool<br/>        """<br/>        stack = [0]<br/>        index = -1<br/>        farthest = 0<br/>        out = False<br/>        if s[-1]=='1':<br/>            return(False)<br/>        while len(stack) &gt; 0:<br/>            index = stack.pop()<br/>            a1, a2 = max(index+minJump, farthest), min(index+maxJump, len(s)-1)<br/>            print(a1,a2)<br/>            for j in range(a1, a2+1):<br/>                if s[j] == '0':<br/>                    if j == len(s)-1:<br/>                        out = True<br/>                    stack.append(j)<br/>            farthest = max(farthest, a2)<br/>        return out</span></pre><p id="c52a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题</strong></p><p id="5f5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你注意到了吗，当我们回溯的时候，我们的最远距离将会超过 maxJump，我们将永远无法回溯。可以考虑这个测试用例。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/8de5500e5029f6fd6a90ea70623c3717.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_wW8vvFlcprF5ne_WE21wA.png"/></div></figure><p id="d747" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">尝试追踪，看看你会得到一个最远&gt;最大跳转，我们不能做回溯的情况。我们将以错误的答案结束</em></p><p id="2b66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解决方案</strong> <br/>发生这种情况是因为我们正在进行深度优先搜索，我们的最远指针仍然非常远。我们可以用广度优先搜索来解决。</p><h2 id="cfc3" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">横向优先搜索</h2><p id="70d6" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">整个代码是相同的，但是我们使用 Queue 来代替 stack，我们弹出先来先得的元素。这样我们就不会超过最远的指针。</p><pre class="ki kj kk kl gt md me mf mg aw mh bi"><span id="19b7" class="kq kr in me b gy mi mj l mk ml">class Solution(object):<br/>    def canReach(self, s, minJump, maxJump):<br/>        """<br/>        :type s: str<br/>        :type minJump: int<br/>        :type maxJump: int<br/>        :rtype: bool<br/>        """<br/>        queue = [0]<br/>        index = -1<br/>        farthest = 0<br/>        out = False<br/>        if s[-1]=='1':<br/>            return(False)<br/>        while len(queue) &gt; 0:<br/>            index = queue.pop(0)<br/>            a1, a2 = max(index+minJump, farthest+1), min(index+maxJump, len(s)-1)<br/>            for j in range(a1, a2+1):<br/>                if s[j] == '0':<br/>                    if j == len(s)-1:<br/>                        return(True)<br/>                    queue.append(j)<br/>            farthest = max(farthest,a2)<br/>        return(False)</span></pre><p id="bc16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在 O(n)时间内完成。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/f11a6d5374147255faf379060202bcb6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oAhRPVQVM3LPorRA6aWxaw.png"/></div></figure><p id="a583" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你喜欢我的解释。请喜欢并关注我更多这样的博客。<br/>谢谢！</p></div></div>    
</body>
</html>