<html>
<head>
<title>7 Simple (Optimization) Tips in JavaScript🧼</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript🧼的 7 个简单(优化)技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-simple-optimization-tips-in-javascript-18aa2211dafb?source=collection_archive---------3-----------------------#2022-05-09">https://blog.devgenius.io/7-simple-optimization-tips-in-javascript-18aa2211dafb?source=collection_archive---------3-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e5d2004500b961281f14a99caa4fbe86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NO3SHEGevHZuFkm7xE9Nbw.png"/></div></div></figure><p id="9c60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你如何优化 JavaScript 来提高网页的性能？这个简单的指南将向你展示 JavaScript 中的 7 大优化技巧，帮助你的网页加载更快，运行更流畅，甚至在功能不那么强大的设备上！</p><h1 id="68bc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">保持简单</h1><p id="f7d6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">通常，当开发人员决定回去清理时，优化就发生了。如果你正在为某件重要的事情编写代码——通常，直到代码崩溃，我们才意识到它有多重要——尝试尽可能快地改进每一件事会很有诱惑力。</p><p id="3515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然没有硬性规定禁止这样做，但是请记住，复杂代码通常比简单代码更难阅读和维护。当寻找优化代码的方法时，从你能简化的地方开始——理想的情况是在编写程序的新部分时，而不是以后不得不回去重做你已经编写的东西。</p><h1 id="4627" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测试迭代</h1><p id="1301" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">俗话说代码写一遍，读多遍更是真理。编写团队中每个人都理解的代码需要时间和<strong class="ka ir">仔细的考虑</strong>——但是确保代码在改变后能够工作只需要一瞬间。作为开发人员，我们必须能够尽可能频繁地信任我们的代码和测试，以便当在开发或产品变更期间不可避免地引入 bug 时，它们可以被及早发现，并且可以在它们造成任何损害之前被快速而容易地修复。</p><p id="fd19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，测试并不难:诀窍是确保您使用的工具(<em class="lz">如</em> <a class="ae ma" href="https://jestjs.io/es-ES/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> Jest </em> </a>)或框架(<em class="lz">如</em><a class="ae ma" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"><em class="lz">React Native</em></a>)使测试变得轻松而简单。</p><h1 id="d04d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用本机函数</h1><p id="dd0f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">总是使用本地函数来创建对象和数组。有很多框架(<em class="lz">像</em> <a class="ae ma" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> jQuery </em> </a>)也有它们自己的本地实现，所以你可以用它们来代替。由于浏览器更好的优化，本地函数甚至比它们的本地对应物要快得多。</p><p id="9786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个很好的例子是我们如何用较少的字符创建一个带有索引的数组:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="002c" class="mk kx iq mg b gy ml mm l mn mo">var arr = [].slice(0); <br/>// vs for (var i = 0; i &lt; 10; i++) { arr[i] = []; }</span></pre><p id="c70b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">乍一看，您可能看不出这两个代码块之间有很大的区别，但是当涉及到更大的数组(<em class="lz">数百万或更多的元素</em>)时，这就很重要了！</p><h1 id="343b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">避免不必要的函数调用</h1><p id="2d69" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在任何项目中，您都应该尝试跟踪正在调用的函数，并避免不必要的函数调用。尽量记住所有的变量名以及何时使用它们。避免使用<strong class="ka ir">不必要的变量名</strong>,因为这样更容易找到未使用的变量。此外，尽可能避免使用太多的变量，因为这样会更容易跟踪变量的访问位置。</p><p id="93e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以使用<a class="ae ma" href="http://es6-features.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">ECMAScript 6</strong></a><strong class="ka ir">'</strong>s const 关键字来代替 var。这允许你定义常量(<em class="lz">例如 PI = 3 </em>)。常量在一个函数的所有实例中都是静态的，所以如果你不需要一个特定的值来改变，那么<strong class="ka ir">将其定义为常量</strong>而不是常规变量。</p><h1 id="9a1d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">尽可能使用循环而不是递归</h1><p id="5a93" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae ma" href="https://www.javatpoint.com/javascript-loop" rel="noopener ugc nofollow" target="_blank">循环</a>很慢，这意味着如果你能递归而不是循环，你会更快。另外，递归函数倾向于一次又一次地调用自己。这可能会导致堆栈溢出错误或内存资源不足。递归也使调试变得更加困难，因为它迫使您在调用堆栈的更深处识别错误。</p><p id="3f37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，递归增加了一些开销，因为每个函数都必须在调用自己之前保存状态。与循环相比，它的执行时间也较慢。另一方面，有时递归对于遍历非线性数据结构很有用——如果您不确定是否有更好的选择，那么先尝试两种方法，看看哪种执行得更好！</p><h1 id="462a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使其经得起未来考验并可维护</h1><p id="8fb6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">可维护性是不经常讨论的事情之一。毕竟，如果您正在编写新代码，它应该是可维护的，对吗？不对。如果您从零开始构建全新的东西，这可能是真的——但是遗留代码呢？在职业生涯的某个阶段，你很可能继承了一些混乱的、可能写得很差的代码——毕竟，不是每个人生来就有完美的编码技能。</p><p id="d357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当公司经历一轮又一轮的裁员或公司过渡到新的领导团队时尤其如此——这似乎是清除任何旧的或未维护的东西的好时机。</p><h1 id="9012" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">避免全局变量</h1><p id="7f69" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">程序的每个部分都可以访问全局变量，因此它们容易出现许多不同的问题。一个常见的问题是数据竞争——当程序的多个部分试图同时读写全局变量的数据时。这往往会产生违反直觉的结果，因为程序中没有一个单独的部分可以控制其他部分何时访问或更新全局变量。</p><p id="2a47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你使用了大量的全局变量，在任何地方增加锁都会导致死锁，这会使事情变得比需要的要慢。通常最好不要有全局变量！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h2 id="eb4a" class="mk kx iq bd ky mw mx dn lc my mz dp lg kj na nb lk kn nc nd lo kr ne nf ls ng bi translated"><strong class="ak">精选:</strong></h2><p id="50a4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">https://jestjs.io/es-ES/<a class="ae ma" href="https://jestjs.io/es-ES/" rel="noopener ugc nofollow" target="_blank"/></p><p id="aa67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【https://reactnative.dev/ T4】</p><p id="2538" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" href="http://es6-features.org/" rel="noopener ugc nofollow" target="_blank">http://es6-features.org/</a></p><p id="d40b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank">https://jquery.com/</a></p><p id="d2b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" href="https://www.javatpoint.com/javascript-loop" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/javascript-loop</a></p></div></div>    
</body>
</html>