# 使用枚举不仅仅是封装存储的数据

> 原文：<https://blog.devgenius.io/using-enums-for-more-than-just-encapsulating-stored-data-8bb40b8a93f5?source=collection_archive---------4----------------------->

## 枚举——封装代码✅修改数据✅干得干净利落✅

## 创建一个包含美国各州的枚举，包括名称、缩写以及它们的数组

![](img/61258b624c8c057babec7e7fa562004c.png)

地图少了几个…但我们不会😉

## 我们的使用案例

我们正在为美国顾客开发一款购物应用。要求是，我们必须在应用程序的几个地方使用州和缩写，并且我们的拼写保持一致是很重要的。有时我们需要一个州名，有时我们需要州名的缩写，有时两者都需要。有时我们需要一个包含他们所有名字的数组，有时我们需要一个包含他们所有缩写的数组。最后，有时候我们在一个数组中需要两者，所以我们可以很容易地访问列表中的任何一个。

## 让我们从基础开始

大多数时候我在项目中看到枚举的使用，它们被用于非常基本的用例，比如使用用例名和一个`rawValue`来存储常量。这是一种非常酷的整洁存储代码的方式。

事实上，枚举要强大得多，但是让我们从一个简单的用例开始——我们只想存储我们的州名，而不必担心代码中的拼写错误。

![](img/3126762ce715a67a072811684ba22596.png)

注意:我们会列出一些很长的清单。如果你不怕惩罚，或者不能从包含的 gists 中复制/粘贴，我强烈推荐在 Xcode(或者你选择的代码编辑器)中使用多行光标支持。这里有一个关于 Xcode 主题的很棒的帖子:[https://sarunw.com/posts/multi-cursor-editing-in-xcode/](https://sarunw.com/posts/multi-cursor-editing-in-xcode/)

![](img/3126762ce715a67a072811684ba22596.png)

这太棒了，现在我可以使用`USState.**stateName**`访问所有这些，其中`**stateName**`是案例名称。

但是除了封装这些案例，我们还没有真正做任何事情。你只有一个小写的状态列表，你可以用一种简洁的方式调用它。与使用`String`值相比，这样做的好处是可以避免代码中的运行时错误。在代码中拼错任何一个 case 名称都会抛出一个编译器错误，这样就不会出现运行时错误，以后调试起来会很棘手。

![](img/3126762ce715a67a072811684ba22596.png)

## 说到字符串值…

通常，当我们有一个条目列表时，能够使用这些条目显示给用户是很重要的。我们目前不能只使用`USState.**stateName**` 来做到这一点，因为这(目前)不能清晰地映射到`String` …所以让我们来解决这个问题。

通常，转换需要用值初始化类型。我们可以在这里使用 String(description:`USState.**stateName**`)来做到这一点，但是有一种更简洁的方法。我们可以用一个`rawValue`。这样做很容易，就像让一个对象符合一个协议。只需在我们的枚举声明后添加`: String` ,如下所示:

现在，如果你想从这些情况中得到一个字符串值，你可以这样访问它:`USState.**stateName**.rawValue`

![](img/3126762ce715a67a072811684ba22596.png)

# 枚举非常适合制作包含案例的列表(数组)……不需要任何硬编码

有一个名为`CaseIterable`的协议，我们可以将它添加到我们的 enum 符合的事物列表中。我们可以简单地通过在枚举声明中的`String`后添加`, CaseIterable`来做到这一点。然后我们在枚举类型上得到`allCases`，我们可以这样访问:

`USState.allCases`

现在…如果你想要一个你的州名的字符串数组，你可以像这样映射这个数组:

`USState.allcases.map { $0.rawValue }`

…然后很快！你有一个所有案例名称的数组。记得我说过枚举非常强大吗？实际上，我们可以将这个字符串数组作为一个计算属性存储在我们的 enum 中，这样我们以后就不必在代码中映射任何东西了:

![](img/3126762ce715a67a072811684ba22596.png)

好的……现在我向你保证我们还会包括一系列缩写。有很多方法可以解决这个问题，但是为了一石二鸟，我将向您展示如何从您的案例名称中获得不同的`rawValue`，并且不丢失案例名称包含的`String`值。

首先，我们将改变每个州的原始值，以匹配其两个字母的缩写。为此，我们简单地说`case **stateName** = "**rawValue**"`。这里需要注意的是，你现在没有得到你原来的病例名称`rawValue` …但是它仍然隐藏在阴影中——我们只需要把它从隐藏中哄出来。

1.  让我们把所有的`rawValues`都改成州缩写(要点如下)
2.  将属性名称`allStateNames`更改为`allStateAbbreviations`。
3.  创建一个名为`stateName`的新计算属性。这将返回描述案例的字符串。让我们也利用这一点。这将允许我们遵循使用小写字母的标准 Swift 命名惯例，并且仍然使用大写的“友好”(显示)名称。当我们遇到一个大写字母时，我们还需要添加一个空格
4.  然后，我们使用`stateName`创建另一个计算属性(`allStateNames`)，将所有案例映射到它们的`stateName`

![](img/3126762ce715a67a072811684ba22596.png)

现在您可以使用`USState.allStateNames`来获得所有州名的数组，或者使用`USState.allStateAbbreviations`来获得我们州所有缩写的数组。

您可以使用`USState.**exampleStateName**.stateName` 获取案例名称作为`String`值。

您可以使用`USState.**exampleStateName**.rawValue`来获取任何州的缩写。

最后，您可以使用`USState.allCases`将所有案例及其所有属性作为一个数组

![](img/3126762ce715a67a072811684ba22596.png)

说到枚举，这真的只是冰山一角。我最近发现自己在有意义的情况下将整个类转换成枚举。它们可以存储函数和计算属性，所有这些都是为了对封装的数据做些什么。同时，它们还能让东西变得干净整洁！

请在下面的评论中告诉我你是如何使用枚举的，或者你会对此做些什么改变⏬