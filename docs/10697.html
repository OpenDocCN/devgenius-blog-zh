<html>
<head>
<title>Make optimized Server-Side Rendering with React and Go: Part 2— Programming server application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 React and Go 优化服务器端呈现:第 2 部分—服务器应用程序编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-optimized-server-side-rendering-with-react-and-go-part-2-programming-server-application-eae03f834702?source=collection_archive---------3-----------------------#2022-11-23">https://blog.devgenius.io/make-optimized-server-side-rendering-with-react-and-go-part-2-programming-server-application-eae03f834702?source=collection_archive---------3-----------------------#2022-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f28a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们谈到用 React 应用程序完成的 SSR 时，我们通常会考虑像 NextJS 或 NestJS 这样的框架。这种方法非常适合内容丰富的交互式网站。但是如果…</p><p id="ec90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.React 中已经内置了一个 SPA，只实现客户端渲染？</p><p id="68cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.这是用 create-react-app 等第三方 React 模板工具创建的？</p><p id="7f0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.您不喜欢为服务器构建创建单独的 Webpack 配置吗？</p><p id="ab1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.你正在寻找一种便捷的渲染优化方法(不同的缓存策略取决于页面等)。)带轻量级运行时？</p><p id="4ee7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，你不是一个人！在这一系列文章中，我将向您解释我是如何为 handy SSR 找到自己的解决方案的。以下是该系列文章的链接:</p><p id="36aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链接到第 1 部分—<a class="ae ki" href="https://medium.com/@jzx777/make-optimized-server-side-rendering-with-react-and-go-part-1-preparing-spa-68d1fba9512e" rel="noopener">https://medium . com/@ jzx 777/make-optimized-server-side-rendering-with-react-and-go-Part-1-preparing-spa-68 D1 FBA 9512 e</a></p><p id="7bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链接至第 2 部分—此处</p><p id="0ba5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这部分是通过核心后端的开发过程来渲染网络应用。让我们继续我们的旅程。耶；3</p><ol class=""><li id="71e4" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><strong class="jm io">首先，我们需要指定服务的关键特性</strong></li></ol><ul class=""><li id="c0b3" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ks kp kq kr bi translated">它应该支持静态资源提取(如 CSS，JS，音频，图像等。)就像静态服务器一样；</li><li id="f65c" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">它应该支持静态资源的持久缓存；</li><li id="38a9" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">它应该有回退到基本的 HTML 模板，如果没有所需的页面匹配；</li><li id="4e46" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">呈现的页面可能依赖于一些提取的数据；</li><li id="70b7" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">如果数据获取失败，一些页面仍然应该给客户端:这也将是基本的 HTML 模板；</li><li id="f594" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">根据页面的种类，它应该支持最少一个或两个缓存策略:静态页面的最低要求是基于时钟的无效。依赖于外部内容的页面的最低要求是:基于时钟和基于 RPC 的失效；</li></ul><p id="cd8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。因此，让我们首先编写文件服务功能。真的很简单，长这样:</strong></p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="642b" class="lh li in ld b be lj lk l ll lm">package filecontroller<br/><br/>import (<br/> errors "go-frontend-service-template/utils/errors"<br/> files "go-frontend-service-template/utils/files"<br/> "io/ioutil"<br/> "net/http"<br/> "path/filepath"<br/>)<br/><br/>type TFileController struct {<br/> uploadRoot string<br/>}<br/><br/>var extensionToMime map[string]string = map[string]string{<br/> "png":  "image/png",<br/> "jpg":  "image/jpg",<br/> "gif":  "image/gif",<br/> "svg":  "image/svg+xml",<br/> "ico":  "image/x-icon",<br/> "mp3":  "audio/mpeg",<br/> "ogg":  "audio/ogg",<br/> "html": "text/html; charset=UTF-8",<br/> "js":   "application/javascript; charset=UTF-8",<br/> "css":  "text/css; charset=UTF-8",<br/> "json": "application/json",<br/> "txt":  "text/plain",<br/> "ttf":  "application/x-font-ttf",<br/> "otf":  "application/x-font-opentype",<br/>}<br/><br/>func New(uploadRoot string) TFileController {<br/> return TFileController{<br/>  uploadRoot: uploadRoot,<br/> }<br/>}<br/><br/>func (self *TFileController) FetchFile(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/>) {<br/> path := req.URL.Path<br/><br/> filePath := filepath.Join(<br/>  self.uploadRoot,<br/>  path,<br/> )<br/> extension := files.GetFileExtension(filePath)<br/> file, err := ioutil.ReadFile(filePath)<br/> if err != nil {<br/>  errors.WriteErrToResponse(<br/>   wrt,<br/>   err,<br/>   "FileController",<br/>   "FetchFile",<br/>  )<br/>  return<br/> }<br/><br/> mime, hasMime := extensionToMime[extension]<br/> if !hasMime {<br/>  mime = "application/x-octet-stream"<br/> }<br/><br/> wrt.Header().Add("Content-Type", mime)<br/> wrt.Header().Add("Cache-Control", "max-age=240000")<br/> wrt.WriteHeader(200)<br/> wrt.Write(file)<br/>}</span></pre><p id="6b82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。接下来，我们将为页面渲染编写控制器。</strong></p><p id="1777" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现起来更复杂。它主要有两种类型的端点:</p><ul class=""><li id="398b" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ks kp kq kr bi translated">呈现由 Webpack 编译的默认 HTML 库。如在一些静态服务器中所做的那样；</li><li id="38aa" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">用某种资源呈现我们想要的页面；</li></ul><p id="5f4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一部分的代码是这样的:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="e661" class="lh li in ld b be lj lk l ll lm">package pagerendercontroller<br/><br/>import (<br/> "net/http"<br/>)<br/><br/>type TPagesRenderController struct {<br/> htmlBase         string<br/>}<br/><br/>func New(<br/> htmlBase string,<br/>) *TPagesRenderController {<br/> return &amp;TPagesRenderController{<br/>  htmlBase:         htmlBase,<br/> }<br/>}<br/><br/>func (self *TPagesRenderController) renderDefaultPageImpl(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/>) {<br/> wrt.Header().Add("Content-Type", "text/html")<br/> wrt.WriteHeader(200)<br/> wrt.Write([]byte(self.htmlBase))<br/>}<br/><br/>func (self *TPagesRenderController) RenderDefaultPage(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/>) {<br/> self.renderDefaultPageImpl(wrt, req)<br/>}</span></pre><p id="be2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于第二部分，我们应该考虑几个步骤来执行工作:</p><ul class=""><li id="a4e5" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ks kp kq kr bi translated">检查所需页面是否已经在缓存中。如果是这样——就退回去；</li><li id="5b1f" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">通过渲染的全过程为 SPA 的 SSR 端点准备参数:语言，然后资源，然后 URL 路径，然后查询参数；</li><li id="3832" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">为页面提取资源；</li><li id="c7c5" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">通过调用之前捆绑的 JS 代码导出的函数到 Go 应用中 JS 解释器的实例，获得前端状态补丁；</li><li id="f19e" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">用和以前一样的方法渲染 HTML 和 CSS 标签(我使用样式化的组件所以我也需要它们)；</li><li id="0092" class="kj kk in jm b jn kt jr ku jv kv jz kw kd kx kh ks kp kq kr bi translated">具有呈现状态补丁、HTML 和 CSS 标签的基于补丁的 HTML 模板；</li></ul><p id="b62a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们编写用于呈现的基本函数，该函数将由特定的页面呈现端点使用:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="d89e" class="lh li in ld b be lj lk l ll lm">package pagerendercontroller<br/><br/>import (<br/> "encoding/json"<br/> "errors"<br/> "fmt"<br/> "go-frontend-service-template/services/jsinterpreter"<br/> pagescache "go-frontend-service-template/services/pages-cache"<br/> rpcservice "go-frontend-service-template/services/rpc-service"<br/> errorsutils "go-frontend-service-template/utils/errors"<br/> httpheadersutils "go-frontend-service-template/utils/http-headers"<br/> "log"<br/> "net/http"<br/> "strings"<br/> "time"<br/>)<br/><br/>type TPagesRenderController struct {<br/> pagesCache       *pagescache.TPagesCache<br/> jsinterpreter    *jsinterpreter.TJsInterpreter<br/> htmlBase         string<br/> acceptLangParser *httpheadersutils.TAcceptLanguageParser<br/> rpcService       *rpcservice.TRpcService<br/>}<br/><br/>func New(<br/> pagesCache *pagescache.TPagesCache,<br/> jsinterpreter *jsinterpreter.TJsInterpreter,<br/> htmlBase string,<br/> rpcService *rpcservice.TRpcService,<br/>) *TPagesRenderController {<br/> return &amp;TPagesRenderController{<br/>  htmlBase:         htmlBase,<br/> }<br/>}<br/><br/>func (self *TPagesRenderController) renderPage(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/> pageName string,<br/> pageCacheDuration time.Duration,<br/> pageGetResource func() (interface{}, error),<br/>) {<br/> pathWQuery := ""<br/> if len(req.URL.RawQuery) &gt; 0 {<br/>  pathWQuery = fmt.Sprintf(<br/>   "%v?%v",<br/>   req.URL.Path,<br/>   req.URL.RawQuery,<br/>  )<br/> } else {<br/>  pathWQuery = req.URL.Path<br/> }<br/><br/> cachedPage, hasCachedPage := self.pagesCache.GetPage(pathWQuery)<br/> if hasCachedPage {<br/>  wrt.Header().Add("Content-Type", "text/html")<br/>  wrt.WriteHeader(200)<br/>  wrt.Write([]byte(cachedPage))<br/>  return<br/> }<br/><br/> acceptLanguage := req.Header.Get("Accept-Language")<br/> language := self.acceptLangParser.GetLanguageCode(acceptLanguage)<br/> pageSsrArgs := []interface{}{language}<br/><br/> resource, err := self.getPackedResource(<br/>  pageGetResource,<br/> )<br/> if err != nil {<br/>  log.Println(<br/>   fmt.Sprintf(<br/>    "[%v/%v/ERROR-ON-FETCH-RESOURCE] =&gt; %v",<br/>    "PageRenderController",<br/>    fmt.Sprintf(<br/>     "Page%vRender",<br/>     pageName,<br/>    ),<br/>    err.Error(),<br/>   ),<br/>  )<br/>  self.renderDefaultPageImpl(wrt, req)<br/>  return<br/> }<br/> if len(resource) &gt; 0 {<br/>  pageSsrArgs = append(pageSsrArgs, resource)<br/> }<br/><br/> statePatch, err := self.getStatePatch(pageName, pageSsrArgs)<br/> if err != nil {<br/>  errorsutils.WriteErrToResponse(<br/>   wrt,<br/>   err,<br/>   "PagesRenderController",<br/>   fmt.Sprintf(<br/>    "Render%vPage",<br/>    pageName,<br/>   ),<br/>  )<br/>  return<br/> }<br/><br/> pageSsrArgsForPage := make([]interface{}, 0)<br/> for _, arg := range pageSsrArgs {<br/>  pageSsrArgsForPage = append(pageSsrArgsForPage, arg)<br/> }<br/> pageSsrArgsForPage = append(pageSsrArgsForPage, req.URL.Path)<br/> if len(req.URL.RawQuery) &gt; 0 {<br/>  pageSsrArgsForPage = append(pageSsrArgsForPage, req.URL.RawQuery)<br/> }<br/> htmlCss, err := self.getRenderedHtmlCss(pageName, pageSsrArgsForPage)<br/> if err != nil {<br/>  errorsutils.WriteErrToResponse(<br/>   wrt,<br/>   err,<br/>   "PagesRenderController",<br/>   fmt.Sprintf(<br/>    "Render%vPage",<br/>    pageName,<br/>   ),<br/>  )<br/>  return<br/> }<br/><br/> page := self.getRenderedPage(statePatch, htmlCss["html"], htmlCss["cssTags"])<br/> self.pagesCache.PutPage(<br/>  pathWQuery,<br/>  page,<br/>  pageCacheDuration,<br/> )<br/><br/> wrt.Header().Add("Content-Type", "text/html")<br/> wrt.WriteHeader(200)<br/> wrt.Write([]byte(page))<br/>}<br/><br/><br/><br/>// ... already declared endpoint for base HTML rendering ...</span></pre><p id="5c76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“getPackedResource”的内部方法是这样的:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="1969" class="lh li in ld b be lj lk l ll lm">func (self *TPagesRenderController) getPackedResource(<br/> pageGetResource func() (interface{}, error),<br/>) (string, error) {<br/> resource, err := pageGetResource()<br/> if err != nil {<br/>  return "", err<br/> }<br/> if resource != nil {<br/>  packedResource, err := json.Marshal(resource)<br/>  if err != nil {<br/>   return "", err<br/>  }<br/>  return string(packedResource), nil<br/> }<br/><br/> return "", nil<br/>}</span></pre><p id="9444" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(是的，字符串化资源也是处理向 JS 解释器调用的函数传递参数问题的一部分——如果我决定也缓存资源，我也会重构这个函数)</p><p id="867a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“getStatePatch”和“getRenderedHtmlCss”函数的实现方式如下:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="ba51" class="lh li in ld b be lj lk l ll lm">func (self *TPagesRenderController) getStatePatch(<br/> pageName string,<br/> pageSsrArgs []interface{},<br/>) (string, error) {<br/> statePatchFn := fmt.Sprintf(<br/>  "ssr%vStatePatch",<br/>  pageName,<br/> )<br/> statePatch, err := self.jsinterpreter.ExecExtFunction(<br/>  statePatchFn,<br/>  pageSsrArgs...,<br/> )<br/> if err != nil {<br/>  return "", err<br/> }<br/> statePatchStr, isStatePatchStr := statePatch.(string)<br/> if !isStatePatchStr {<br/>  return "", errors.New("state patch is not a string")<br/> }<br/><br/> return statePatchStr, nil<br/>}<br/><br/>func (self *TPagesRenderController) getRenderedHtmlCss(<br/> pageName string,<br/> pageSsrArgs []interface{},<br/>) (map[string]string, error) {<br/> pageFn := fmt.Sprintf(<br/>  "ssr%vPage",<br/>  pageName,<br/> )<br/> rawPage, err := self.jsinterpreter.ExecExtFunction(<br/>  pageFn,<br/>  pageSsrArgs...,<br/> )<br/> if err != nil {<br/>  return nil, err<br/> }<br/> page, isPageMap := rawPage.(map[string]interface{})<br/> if !isPageMap {<br/>  return nil, errors.New("page is not an object with html &amp; cssTags")<br/> }<br/><br/> if _, hasHtml := page["html"]; !hasHtml {<br/>  return nil, errors.New("page doesn't have 'html' string")<br/> }<br/> if _, isHtmlString := page["html"].(string); !isHtmlString {<br/>  return nil, errors.New("page's 'html' is not a string")<br/> }<br/><br/> if _, hasCssTags := page["cssTags"]; !hasCssTags {<br/>  return nil, errors.New("page doesn't have 'cssTags' string")<br/> }<br/> if _, isCssTagsString := page["cssTags"].(string); !isCssTagsString {<br/>  return nil, errors.New("page's 'cssTags' is not a string")<br/> }<br/><br/> return map[string]string{<br/>  "html":    page["html"].(string),<br/>  "cssTags": page["cssTags"].(string),<br/> }, nil<br/>}</span></pre><p id="eb42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">缓存和交付页面之前的最后一步:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="76d7" class="lh li in ld b be lj lk l ll lm">func (self *TPagesRenderController) getRenderedPage(<br/> statePatch string,<br/> renderedHtml string,<br/> renderedCss string,<br/>) string {<br/> htmlWithPatch := strings.Replace(<br/>  self.htmlBase,<br/>  "&lt;script id=\"state-patch-root\"&gt;&lt;/script&gt;",<br/>  statePatch,<br/>  1,<br/> )<br/> html := strings.Replace(<br/>  htmlWithPatch,<br/>  "&lt;div id=\"root\"&gt;&lt;/div&gt;",<br/>  fmt.Sprintf(<br/>   "&lt;div id=\"root\"&gt;%v&lt;/div&gt;",<br/>   renderedHtml,<br/>  ),<br/>  1,<br/> )<br/> fullHtml := strings.Replace(<br/>  html,<br/>  "&lt;style id=\"sc-placeholder-root\"&gt;&lt;/style&gt;",<br/>  renderedCss,<br/>  1,<br/> )<br/><br/> return fullHtml<br/>}</span></pre><p id="b580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！然后，我们可以像这样利用端点中的核心功能:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="d194" class="lh li in ld b be lj lk l ll lm">func (self *TPagesRenderController) RenderExamplePageA(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/>) {<br/> getResource := func() (interface{}, error) {<br/>  resource, err := self.rpcService.GetExampleResource()<br/>  return resource, err<br/> }<br/><br/> self.renderPage(<br/>  wrt,<br/>  req,<br/>  "Example",<br/>  time.Hour*3,<br/>  getResource,<br/> )<br/>}</span></pre><p id="870c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。无效页面缓存</strong></p><p id="5ec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，该服务支持缓存失效的两个关键策略:通过计时器和通过调用外部微服务可以使用的公开端点。要实现第一点，您应该运行无限循环 goroutine 来侦听滴答。要实现第二点，您应该从允许缓存删除的缓存实用程序中公开端点。让我们这样做:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="1a80" class="lh li in ld b be lj lk l ll lm">package pagescache<br/><br/>import (<br/> lrucache "go-frontend-service-template/utils/lru_cache"<br/> "sync"<br/> "time"<br/>)<br/><br/>type TPagesCacheEntry struct {<br/> Content   string<br/> ExpiredAt time.Time<br/>}<br/><br/>type TPagesCache struct {<br/> pages     *lrucache.LruCache<br/> pagesLock *sync.Mutex<br/> timer     *time.Ticker<br/>}<br/><br/>func New() *TPagesCache {<br/> cache := lrucache.New(10)<br/> return &amp;TPagesCache{<br/>  pages:     &amp;cache,<br/>  pagesLock: &amp;sync.Mutex{},<br/>  timer:     nil,<br/> }<br/>}<br/><br/>func (self *TPagesCache) GetPage(pathWQuery string) (string, bool) {<br/> self.pagesLock.Lock()<br/> defer self.pagesLock.Unlock()<br/><br/> page, hasPage := self.pages.Get(pathWQuery)<br/> if !hasPage {<br/>  return "", false<br/> }<br/><br/> pageEntry := page.(TPagesCacheEntry)<br/> return pageEntry.Content, true<br/>}<br/><br/>func (self *TPagesCache) PutPage(<br/> pathWQuery string,<br/> pageContent string,<br/> pageDuration time.Duration,<br/>) {<br/> self.pagesLock.Lock()<br/> defer self.pagesLock.Unlock()<br/><br/> self.pages.Put(<br/>  pathWQuery,<br/>  TPagesCacheEntry{<br/>   Content:   pageContent,<br/>   ExpiredAt: time.Now().Add(pageDuration),<br/>  },<br/> )<br/>}<br/><br/>func (self *TPagesCache) InvalidatePage(pathWQuery string) {<br/> self.pagesLock.Lock()<br/> self.pages.Delete(pathWQuery)<br/> self.pagesLock.Unlock()<br/>}<br/><br/>func (self *TPagesCache) InvalidatePages(pathsWQuery []string) {<br/> self.pagesLock.Lock()<br/> defer self.pagesLock.Unlock()<br/><br/> for _, page := range pathsWQuery {<br/>  self.pages.Delete(page)<br/> }<br/>}<br/><br/>func (self *TPagesCache) RunTrashClock() {<br/> self.timer = time.NewTicker(time.Minute * 2)<br/><br/> go func() {<br/>  for {<br/>   &lt;-self.timer.C<br/><br/>   now := time.Now()<br/><br/>   self.pagesLock.Lock()<br/>   pagesIter := self.pages.GetIterator()<br/>   deletedPages := make([]string, 0)<br/>   for pagesIter.HasNext() {<br/>    kv := pagesIter.Next()<br/>    pageEntry := kv.Val.(TPagesCacheEntry)<br/>    if now.After(pageEntry.ExpiredAt) {<br/>     deletedPages = append(deletedPages, kv.Key.(string))<br/>    }<br/>   }<br/>   for _, dPage := range deletedPages {<br/>    self.pages.Delete(dPage)<br/>   }<br/>   self.pagesLock.Unlock()<br/>  }<br/> }()<br/>}</span></pre><p id="2354" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(是的，缓存是基于 LRU 缓存策略的——这在缓存依赖于不同参数(如查询参数)的服务器渲染页面时特别有用)；</p><p id="986f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基地建成了。让我们为缓存无效编写控制器。这很简单:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="f60d" class="lh li in ld b be lj lk l ll lm">package cacheinvalidatorcontroller<br/><br/>import (<br/> pagescache "go-frontend-service-template/services/pages-cache"<br/> "net/http"<br/>)<br/><br/>type TCacheInvalidatorController struct {<br/> pagesCache   *pagescache.TPagesCache<br/> ipcSecretKey string<br/>}<br/><br/>func New(<br/> pagesCache *pagescache.TPagesCache,<br/> ipcSecretKey string,<br/>) *TCacheInvalidatorController {<br/> return &amp;TCacheInvalidatorController{<br/>  pagesCache:   pagesCache,<br/>  ipcSecretKey: ipcSecretKey,<br/> }<br/>}<br/><br/>func (self *TCacheInvalidatorController) InvalidateExamplePage(<br/> wrt http.ResponseWriter,<br/> req *http.Request,<br/>) {<br/> ipcSecret := req.Header.Get("x-ipc-secret")<br/> if ipcSecret != self.ipcSecretKey {<br/>  wrt.WriteHeader(403)<br/>  wrt.Write([]byte("Not authorized"))<br/>  return<br/> }<br/><br/> self.pagesCache.InvalidatePage("/example")<br/> wrt.WriteHeader(200)<br/> wrt.Write([]byte("OK"))<br/>}</span></pre><p id="d5d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。结合我们之前写的所有东西，在路由:</strong></p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="002f" class="lh li in ld b be lj lk l ll lm">package initjobs<br/><br/>import (<br/> // Services<br/> jsinterpreter "go-frontend-service-template/services/jsinterpreter"<br/> pagescache "go-frontend-service-template/services/pages-cache"<br/> rpcservice "go-frontend-service-template/services/rpc-service"<br/><br/> // Controllers<br/> cacheinvalidatorcontroller "go-frontend-service-template/controllers/cache-invalidator-controller"<br/> filecontroller "go-frontend-service-template/controllers/file-controller"<br/> pagecontroller "go-frontend-service-template/controllers/page-render-controller"<br/><br/> // Modules<br/> "net/http"<br/><br/> mux "github.com/gorilla/mux"<br/> fileutils "go-frontend-service-template/utils/files"<br/>)<br/><br/>func InitInternalRoutes(<br/> rootRouter *mux.Router,<br/> pagesCache *pagescache.TPagesCache,<br/> ipcSecretKey string,<br/>) {<br/> cacheInvalidateController := cacheinvalidatorcontroller.New(<br/>  pagesCache,<br/>  ipcSecretKey,<br/> )<br/><br/> internalRouter := rootRouter.PathPrefix("/internal").Subrouter()<br/> internalRouter.<br/>  Methods("POST").<br/>  Headers("x-ipc-secret").<br/>  Path("/invalidate-example").<br/>  HandlerFunc(<br/>   func(rw http.ResponseWriter, r *http.Request) {<br/>    cacheInvalidateController.InvalidateExamplePage(rw, r)<br/>   },<br/>  )<br/>}<br/><br/>func InitSsrRoutes(<br/> rootRouter *mux.Router,<br/> frontendBuildPath string,<br/> pagesCache *pagescache.TPagesCache,<br/> jsInterpreter *jsinterpreter.TJsInterpreter,<br/> htmlBase string,<br/> rpcService *rpcservice.TRpcService,<br/>) {<br/> fileController := filecontroller.New(frontendBuildPath)<br/> pageController := pagecontroller.New(<br/>  pagesCache,<br/>  jsInterpreter,<br/>  htmlBase,<br/>  rpcService,<br/> )<br/><br/> frontendRouter := rootRouter.<br/>  PathPrefix("/").<br/>  Subrouter()<br/> frontendRouter.<br/>  Methods("GET").<br/>  Path("/pageA").<br/>  HandlerFunc(<br/>   func(rw http.ResponseWriter, r *http.Request) {<br/>    pageController.RenderExamplePageA(rw, r)<br/>   },<br/>  )<br/> frontendRouter.<br/>  Methods("GET").<br/>  PathPrefix("/").<br/>  HandlerFunc(<br/>   func(rw http.ResponseWriter, r *http.Request) {<br/>    // If index page is same as pageA<br/>    if r.URL.Path == "/" {<br/>     pageController.RenderExamplePageA(rw, r)<br/>    } else {<br/>     fileExtension := fileutils.GetFileExtension(r.URL.Path)<br/>     if len(fileExtension) &gt; 0 {<br/>      fileController.FetchFile(rw, r)<br/>     } else {<br/>      pageController.RenderDefaultPage(rw, r)<br/>     }<br/>    }<br/>   },<br/>  )<br/>}</span></pre><p id="61b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一个前端路径可能看起来有点奇怪，但是它有明确的目的:如果你在索引路径上，你应该总是呈现一些页面。如果路径不是某个静态托管资源的路径，您应该回退到 HTML 基础。否则，您从前端构建发送一些静态资源；</p><p id="6cec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我在上一篇文章中承诺的，这里是我开发的模板的源代码:【https://gitlab.com/jbyte777/go-frontent-service-template<a class="ae ki" href="https://gitlab.com/john-byte/go-frontent-service-template" rel="noopener ugc nofollow" target="_blank"/>。还可以查看 FFI 用 JS 是怎么做的；</p><p id="2ca8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请根据您的经验等随意留下任何建议。我感谢任何有益的反馈；)</p><p id="cb9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ln">我的 git lab:</em><a class="ae ki" href="https://gitlab.com/john-byte" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://gitlab.com/jbyte</em></a><em class="ln">777</em></p></div></div>    
</body>
</html>