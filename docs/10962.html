<html>
<head>
<title>Learning to Test Buffers in MIPS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习测试 MIPS 中的缓冲器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-to-test-buffers-in-mips-a43f10393f86?source=collection_archive---------12-----------------------#2022-12-10">https://blog.devgenius.io/learning-to-test-buffers-in-mips-a43f10393f86?source=collection_archive---------12-----------------------#2022-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fc52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时你的 MIPS 程序会将缓冲区作为输入，但是我们如何利用 MUnit 来测试这些功能呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/daminals/Unit_Testing_with_MUnit"><div class="gh gi ki"><img src="../Images/737cc315a4391b59c16d8ab0d6746fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxdQQn_P6Xu44foCqO55Qw.png"/></div></a><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">查看该项目的 GitHub！</figcaption></figure><h1 id="6363" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="8ec7" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在上一篇文章中，我向您展示了如何开始用 MUnit 测试 MIPS 代码。如果你还没看过，看看<a class="ae lx" href="https://medium.com/dev-genius/introduction-to-unit-testing-in-munit-4ce7e24ff3f4" rel="noopener">这里</a>！</p><p id="e535" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将向您展示如何测试接受缓冲区的函数，以及如何在单元测试中使用缓冲区。没有别的告别了，让我们开始吧！</p><h1 id="ba54" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">问题说明</h1><p id="f01b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们需要一个函数，它接收正数的缓冲区，接受正数的恭维，并将它们存储到输出缓冲区。$v0 将存储有多少数字被写入缓冲区。如果 input_buffer 内部的任何数字是负数，那么将输出缓冲区中的所有内容都设置为 0，$v0 将包含-1。</p><h2 id="4d73" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">约束条件:</h2><p id="b0ef" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们的输出缓冲区包含 20 个字，我们的输入缓冲区永远不会超过 20 个数字</p><p id="3753" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，这是一个相当复杂的函数，需要几个测试用例。现在，我将向您展示一个包含一个 bug 的解决方案。</p><pre class="kj kk kl km gt mk ml mm bn mn mo bi"><span id="7d0f" class="mp kv in ml b be mq mr l ms mt">.data<br/>buffer:<br/>  .word 1<br/>  .word 2<br/>  .word 3 4 5 6 7 8 9 0<br/><br/>output_buffer:<br/>  .word 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br/><br/>.text<br/><br/>la $a0, buffer<br/>la $a1, output_buffer<br/><br/># while testing our code, everything before this function <br/># (.data, defining a0,a1) will be ignored<br/><br/>.globl onescompl<br/>onescompl:<br/>  # inputs: a0=input_buffer, a1=output_buffer<br/>  # Save the null-terminated buffer to the stack<br/>  addi $sp, $sp, -8<br/>  sw $s1, 0($sp)<br/>  sw $a1, 4($sp)<br/>  li $v0, 0<br/><br/>  # Iterate over the buffer<br/>  loop:<br/>  lw $s1, 0($a0)<br/><br/>  # If we have reached the end of the buffer, exit the loop<br/>  beqz $s1, end<br/><br/>  # if number not positive, wipe output buffer<br/>  bltz $s1, wipe_buffer<br/><br/>  # Convert the number to one's compliment form<br/>  neg $s1, $s1<br/>  # note that MIPS stores numbers in twos compliment form already, <br/>  # so we will need to subtract one to go from 1's to 2's<br/>  addi $s1, $s1, -1<br/><br/>  # Save the number to the output_buffer<br/>  sw $s1, 0($a1)<br/>  addi $v0,$v0,1<br/><br/>  # next element in output_buffer<br/>  addi $a1, $a1, 4 <br/><br/>  # Move to the next element in the buffer<br/>  addi $a0, $a0, 4<br/>  j loop<br/><br/>  # wipe output buffer<br/>  wipe_buffer:<br/>    lw $a1, 4($sp)<br/>    # 20 numbers * 4 bytes per word<br/>    li $s1, 80<br/>    li $v0, -1<br/>    wipe_buffer_loop:<br/>      beqz $s1, end<br/>      addi $s1, $s1, -4<br/>      sw $0, 0($a1)<br/>      addi $a1,$a1,4<br/><br/>  # end program<br/>  end:<br/>    lw $s1, 0($sp)<br/>    addi $sp, $sp, 8<br/>    jr $ra</span></pre><p id="c64a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么让我们跳到本文的重点。我们如何为这个函数编写单元测试并找出错误呢？</p><h1 id="b469" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单元测试</h1><p id="ba62" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">首先，让我们确定我们需要测试的案例</p><ul class=""><li id="86b3" class="mu mv in jm b jn jo jr js jv mw jz mx kd my kh mz na nb nc bi translated">数字 1-20 的缓冲区</li><li id="ffca" class="mu mv in jm b jn nd jr ne jv nf jz ng kd nh kh mz na nb nc bi translated">包含一个负数的缓冲区</li></ul><p id="2a06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然只有两种情况，但是在这些情况中有几件事我们必须测试。</p><p id="0a5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在案例 1 中，我们必须确保$v0=输入缓冲区中的数字量，并且一个人的称赞形式是正确的。</p><p id="abb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于第二种情况，我们必须测试 output_buffer 包含所有的 0，并且$v0 包含-1。</p><p id="80d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，让我们使用前一篇文章中的模板，并向其中添加我们的新测试用例。</p><pre class="kj kk kl km gt mk ml mm bn mn mo bi"><span id="b54b" class="mp kv in ml b be mq mr l ms mt">  @Test<br/>  public void verify_positive() {<br/>    Label input_buffer = wordData(1,2,3,4,5,6,7,8,9,10, 0); // null terminated = 0 at end<br/>    Label output_buffer = wordData(0,0,0,0,0, // 20 num buffer<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0); <br/><br/>    run("onescompl", input_buffer,output_buffer);<br/>    Assert.assertEquals("$v0 contains incorrect count",10, get(v0)); // 10 nums written<br/>    for (int i=0;i&lt;10;i++) {<br/>      Assert.assertEquals("output_buffer contains incorrect value",<br/>                            -1*(i+2), getWord(output_buffer,i*4)); <br/>    }<br/>  }</span></pre><p id="686c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，让我们来解释一下这是怎么回事。首先，我们使用从 MUnit 导入的函数来进行测试。这包括 Label 对象，它表示单元测试中的一个. data 部分，以及 wordData 函数，它允许我们以$a0 和$a1 的形式输入缓冲区</p><p id="3987" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">这与在中定义缓冲区的效果相同。数据和运行 la $a0，缓冲区</em></p><p id="cfea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们运行我们的函数，验证 v0 包含一个正确的计数(这个测试是 10)。然后我们验证两人的恭维形式是正确的。在我的循环示例中，我们应该测试 1–10，但是循环从 0–9 开始(因为它用于跟踪地址位置)。这意味着我们应该采取(i+1)的赞美形式，它等于-1*(i+2)。</p><p id="2777" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们进行测试！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/f53c08435b4c02b07bec8c6648b2ffae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npo7qmPRzkjzJaG5yfHLUg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">测试用例通过！</figcaption></figure><p id="ec6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">成功！我们通过了第一个测试案例。为了确保这不是侥幸，我将再写 2 个测试用例 1。把这当作你自己的一个练习，试着写一个测试用例。</p><p id="c5c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我想到的:</p><pre class="kj kk kl km gt mk ml mm bn mn mo bi"><span id="662b" class="mp kv in ml b be mq mr l ms mt">@Test<br/>  public void verify_positive_1() {<br/>    Label input_buffer = wordData(2,3,4,5,6,7,8,9,10,11, 0); // null terminated = 0 at end<br/>    Label output_buffer = wordData(0,0,0,0,0, // 20 num buffer<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0); <br/><br/>    run("onescompl", input_buffer,output_buffer);<br/>    Assert.assertEquals("$v0 contains incorrect count",10, get(v0)); // 10 nums written<br/>    for (int i=0;i&lt;10;i++) {<br/>      Assert.assertEquals("output_buffer contains incorrect value",<br/>            -1*(i+3), getWord(output_buffer,i*4)); <br/>    }<br/>  }<br/><br/>  @Test<br/>  public void verify_positive_2() {<br/>    Label input_buffer = wordData(47,99, 0); // null terminated = 0 at end<br/>    Label output_buffer = wordData(0,0,0,0,0, // 20 num buffer<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0); <br/><br/>    run("onescompl", input_buffer,output_buffer);<br/>    Assert.assertEquals("$v0 contains incorrect count",2, get(v0)); // 2 nums written<br/>    Assert.assertEquals("output_buffer contains incorrect value", -48, getWord(output_buffer,0)); <br/>    Assert.assertEquals("output_buffer contains incorrect value", -100, getWord(output_buffer,4)); <br/>  }</span></pre><p id="8423" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以根据需要编写尽可能多的代码来验证您的代码是否正常工作。替代测试用例的一些好主意是将非常大的数字和非常小的数字放在同一个输入缓冲区中，以验证它们被正确存储。</p><p id="9638" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，让我们开始第二种情况。对于这个测试用例，我的想法是将我们编写的第一个测试用例添加到输入缓冲区中。我们试试吧！</p><pre class="kj kk kl km gt mk ml mm bn mn mo bi"><span id="1756" class="mp kv in ml b be mq mr l ms mt">  @Test<br/>  public void verify_negative() {<br/>    Label input_buffer = wordData(1,2,3,4,5,6,7,8,9,10,-1, 0); // null terminated = 0 at end<br/>    Label output_buffer = wordData(0,0,0,0,0, // 20 num buffer<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0,<br/>                                   0,0,0,0,0); <br/><br/>    run("onescompl", input_buffer,output_buffer);<br/>    Assert.assertEquals("$v0 contains incorrect count",-1, get(v0)); <br/>    for (int i=0;i&lt;20;i++) {<br/>      Assert.assertEquals("output_buffer contains incorrect value",<br/>            0, getWord(output_buffer,i*4)); <br/>    }<br/>  }</span></pre><p id="8de1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们最大的变化是在断言。缓冲区加-1 后，我们知道$v0 应该是-1，输出缓冲区应该全零。</p><p id="6270" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行它的时间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/47d4c1caada3573fd39c44efcb2703f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZ7UI4ZYX_k4ah6503Ae4g.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">验证否定测试用例失败</figcaption></figure><p id="1ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，看来我们的函数在清除缓冲区时失败了。让我们来看看这段代码:</p><pre class="kj kk kl km gt mk ml mm bn mn mo bi"><span id="895a" class="mp kv in ml b be mq mr l ms mt">  # ....................<br/>  # wipe output buffer<br/>  wipe_buffer:<br/>    lw $a1, 4($sp)<br/>    # 20 numbers * 4 bytes per word<br/>    li $s1, 80<br/>    li $v0, -1<br/>    wipe_buffer_loop:<br/>      beqz $s1, end<br/>      addi $s1, $s1, -4<br/>      sw $0, 0($a1)<br/>      addi $a1,$a1,4<br/>       # ................</span></pre><p id="8f22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，经过进一步的调查，我想我找到了问题所在。我们不会循环回 wipe_buffer_loop。难怪我们的输出缓冲区没有被清空。让我们添加行<code class="fe np nq nr ml b">j wipe_buffer_loop</code>并再次测试我们的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ns"><img src="../Images/8156cf81c5378e63f38a271e8a898f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYzJZyk52WTv82Z63ymeEQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">所有测试用例都通过了</figcaption></figure><p id="a2c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太棒了。我们的代码现在按预期运行。</p><h1 id="e22a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="235e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这篇文章的目标是帮助您提高在 MUnit 和在 MIPS 中用缓冲区测试代码方面的知识。这绝对是一个令人困惑的话题，当我第一次开始寻找合适的资源来编写这些测试用例时，我很挣扎。</p><p id="6b6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解如何编写 MUnit 测试用例，请点击这里查看我的文章:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-unit-testing-in-munit-4ce7e24ff3f4"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">MUnit 中的单元测试介绍</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">低级代码不一定是未经测试的代码</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">blog.devgenius.io</p></div></div><div class="of l"><div class="og l oh oi oj of ok ko nw"/></div></div></a></div><p id="7136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以查看这个项目的 github 页面，其中有 MUnit 的其他例子！你可以在这里找到它的链接:</p><div class="nt nu gp gr nv nw"><a href="https://github.com/daminals/Unit_Testing_with_MUnit" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">GitHub-da minals/Unit _ Testing _ with _ MUnit</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">学习使用基于 JUnit 的单元测试框架 MUnit</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok ko nw"/></div></div></a></div></div></div>    
</body>
</html>