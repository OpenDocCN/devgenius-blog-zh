<html>
<head>
<title>Create a Background Job Service with DynamoDB Streams and Lambda Functions with “Serverless” Framework. :: Part 02</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 DynamoDB 流和 Lambda 函数创建一个后台作业服务，使用“无服务器”框架。*第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-a-background-job-service-with-dynamodb-streams-and-lambda-functions-with-serverless-dc8e0eac4a1c?source=collection_archive---------8-----------------------#2022-04-05">https://blog.devgenius.io/create-a-background-job-service-with-dynamodb-streams-and-lambda-functions-with-serverless-dc8e0eac4a1c?source=collection_archive---------8-----------------------#2022-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/06fb141341e1025bcd9c9529c756ea81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHRqQKnCz0-qjItyiTzUTg.png"/></div></div></figure><p id="1620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="https://medium.com/@iwiick/create-a-background-job-service-with-dynamodb-streams-and-lambda-functions-with-serverless-60b7bc49fd48" rel="noopener">之前的文章</a>中，我们讨论了如何为这个服务设置后端。所以现在让我们来看看后端实现:)</p><h2 id="c089" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">" monitorJobTableChanges "λ</h2><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><ul class=""><li id="7b48" class="lt lu in jx b jy jz kc kd kg lv kk lw ko lx ks ly lz ma mb bi translated">我知道代码乍一看很复杂，但实际上并不复杂。</li><li id="1dc3" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">在第 19 行，我从<strong class="jx io">事件中提取<strong class="jx io">记录</strong>。</strong>正如我前面提到的，这可以是一个“插入”、“修改”或“删除”事件。</li><li id="ebb1" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">然后，我调用<strong class="jx io">getmodifiedbjob</strong>助手函数(第 45 行)来获取“插入”和“修改”事件的新旧图像。</li><li id="247e" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">现在，如果我们有一个“任务”，在第 26 行，我们对它采取行动。让我们看看<strong class="jx io"> takeActionsOnJob </strong>函数；</li></ul><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><ul class=""><li id="5550" class="lt lu in jx b jy jz kc kd kg lv kk lw ko lx ks ly lz ma mb bi translated">我们在第 4 行向作业添加了一个“动作”。该函数位于第 53 行。我们比较新旧图像，添加动作“触发λ”、“通知成功”、“通知失败”或“什么都不做”，并返回新图像。</li><li id="115e" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">在 switch 语句中，第 10 行是我们如何触发 lambda 的。Lambda 是指我们如何触发一个任务。</li><li id="e439" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">在第 4 行，我们有<strong class="jx io">一个有效载荷</strong>和<strong class="jx io">一个触发器λ</strong>。当我们使用“<strong class="jx io">create job</strong>”lambda 创建一个作业时，这些都是从“job”表中获取的，正如我前面提到的，这是通过 POST 请求触发的。</li><li id="802f" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">在我的例子中，<strong class="jx io"> payload 是一个包含执行作业</strong>所需的所有数据的对象。例如:如果我们有一个名为"<strong class="jx io">invite ventparticipants job</strong>"的 lambda(作业)，那么它的有效负载可能是这样的…</li></ul><pre class="ln lo lp lq gt mh mi mj mk aw ml bi"><span id="38c7" class="ku kv in mi b gy mm mn l mo mp">payload = {<br/>    eventId: &lt;SOME_ID_HERE&gt;<br/>}</span></pre><ul class=""><li id="0683" class="lt lu in jx b jy jz kc kd kg lv kk lw ko lx ks ly lz ma mb bi translated">"<strong class="jx io"> triggerLambda </strong>"是要执行的 Lambda 函数的名称。</li><li id="d225" class="lt lu in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">所以在第 12 行，我所做的是使用<strong class="jx io"> AWS-SDK </strong>从"<strong class="jx io">monitorJobTableChanges</strong>" Lambda 中触发另一个 Lambda(在这个上下文中的一个作业)</li></ul><p id="0d3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上就是这样。这里的其余代码是将作业状态更改为“已完成”或“失败”,这样，如果您有所需的参数，就可以使用这些更改的流通过电子邮件或推送通知来通知用户。这部分完全由你自己定制:)以防你好奇，我所做的是使用<strong class="jx io"> Web Sockets </strong>发送推送通知。这完全是另外一个话题:)</p><h2 id="370b" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">从前端触发作业</h2><p id="bd7e" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">这真的很简单。我们所要做的就是用相关的<strong class="jx io">有效负载</strong>对象向“createJob”端点发送一个 POST 请求，并将 lambda(job)的名称传递给 trigger ( <strong class="jx io"> triggerLambda </strong>)，在我的例子中。后端实现将处理剩下的部分:)</p><blockquote class="mv mw mx"><p id="5966" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated">这里要记住的重要一点是，对“createJob”端点的 POST 请求启动了“Job”服务。</p></blockquote><p id="fbb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦您开始使用作业服务，您的“作业”表将如下所示。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/de7b10ceac6a933478d046d78bfa9892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlvWKhmjtk3dYcVKB8xX6g.png"/></div></div></figure><p id="fbeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“<strong class="jx io">作业状态</strong>也可用于重新运行失败的作业</p><p id="7bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，干杯…您现在可以将 lambda 作为作业触发，这消除了 API 网关的 30 秒超时，允许我们利用 Lambda 的全部 300 秒超时。</p><p id="109b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="my">经</em> <strong class="jx io">经<em class="my">合山</em>经</strong></p></div></div>    
</body>
</html>