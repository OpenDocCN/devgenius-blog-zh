<html>
<head>
<title>AWS Lambda Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda 错误处理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/aws-lambda-error-handling-dfe2285f9a85?source=collection_archive---------1-----------------------#2021-01-11">https://blog.devgenius.io/aws-lambda-error-handling-dfe2285f9a85?source=collection_archive---------1-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e27029d116a053938fccddbbdbf6f4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzqEdxBr6kHAxmjPkV_lYg.png"/></div></div></figure><p id="b5ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将讨论您需要了解的关于 AWS Lambda 错误处理的基础知识，以及一些使用阶跃函数和 X 射线的流行方法。不管你是 AWS Lambda 专家还是 Lambda 新用户，<strong class="jx io">总有新东西要学。您可能已经遇到过 Lambda 错误，这些错误看起来很有挑战性，因为运行<a class="ae kt" href="https://dashbird.io/knowledge-base/aws-lambda/retries-and-idempotency/" rel="noopener ugc nofollow" target="_blank"> Lambda 重试</a>的机制通常会使您难以跟踪无服务器应用程序中发生的变化。</strong></p><p id="b456" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://dashbird.io/knowledge-base/basic-concepts/what-is-serverless/" rel="noopener ugc nofollow" target="_blank">无服务器</a>不完全是关于直接执行<a class="ae kt" href="https://dashbird.io/knowledge-base/aws-lambda/anatomy-of-a-lambda-function/" rel="noopener ugc nofollow" target="_blank"> Lambda 函数</a>的代码，而是你的整个系统的<strong class="jx io">不同类型的架构。这个体系结构中的分布式节点由于异步事件而被激活，这就是这个系统的组成部分。</strong></p><blockquote class="ku kv kw"><p id="333a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">每个节点都必须设计成一个单独的部分，有自己的 API。</p></blockquote><p id="f37d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了学习如何准确定义所有这些节点，你必须知道如何处理 Lambda 错误。此外，也有必要适当地处理 Lambda 重试行为。</p><p id="9acd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们直接进入<strong class="jx io">AWS Lambda 重试和错误是如何工作的</strong>，以及围绕它的所有讨论。</p><h1 id="9322" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Lambda 重试行为</h1><p id="0582" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">Lambda 函数可能会失败(<em class="kx">它们将会失败</em>)，当它们失败时，是因为以下情况之一:</p><ul class=""><li id="ad3a" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><a class="ae kt" href="https://dashbird.io/event-library/aws-lambda/aws-lambda-out-of-memory/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">内存不足</strong> </a> —如果内存不足，Lambda 通常会以消息<em class="kx">“进程在完成请求前退出”终止</em><em class="kx">“内存大小”</em>始终与<em class="kx">“最大已用内存”相同</em>你可以在这里了解更多关于资源分配和 AWS Lambda 内存<a class="ae kt" href="https://dashbird.io/knowledge-base/aws-lambda/resource-allocation-and-performance/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="fa92" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">引发未处理的异常</strong> —可能是因为编程错误、外部 API 故障或收到无效输入而发生。</li><li id="a6e3" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">超时</strong> — <em class="kx"> ' </em> <a class="ae kt" href="https://dashbird.io/event-library/aws-lambda/aws-lambda-task-timed-out-after/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">任务在 X 秒后超时</em> </a> <em class="kx"> ' </em>当 Lambda 因运行时间超过预先配置的超时持续时间而剧烈关闭时，出现消息。最大值是五分钟，默认值是六秒。</li></ul><p id="ff75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当故障发生时，它将在某个时间点发生，您很可能会注意到基于这些行为的<strong class="jx io"> Lambda 重试:</strong></p><ul class=""><li id="15d8" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><strong class="jx io">基于流的事件</strong> —如果当前事件仅为<a class="ae kt" href="https://dashbird.io/knowledge-base/dynamodb/dynamodb-streams/" rel="noopener ugc nofollow" target="_blank"> DynamoDB 流</a>和 AWS Kinesis 数据流。当它发生时，AWS 再次触发这些失败的 Lambda 函数，直到它们被成功处理或直到数据过期，AWS 将阻塞事件源，直到它发生。</li><li id="5b31" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">同步事件</strong> —在使用 SDK 的同步调用或<a class="ae kt" href="https://dashbird.io/knowledge-base/api-gateway/what-is-aws-api-gateway/" rel="noopener ugc nofollow" target="_blank"> API 网关</a>等事件源中，被调用的应用负责创建它从<strong class="jx io">λ</strong>获得的基于响应的重试。这种情况是最不有趣的，因为它类似于单一的错误处理。</li><li id="8e29" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">异步事件</strong> —对于大多数事件源，Lambda 调用是异步发生的。这意味着没有任何 app 会响应失败。因此，<strong class="jx io"> AWS 框架会自行处理</strong>。它会以完全相同的事件再次触发 Lambda，这在接下来的大约 3 分钟内几乎会发生两次(在一些零星的情况下，它甚至会花费 6 个小时，而连续重试的次数可能会有所不同)。如果所有的重试都失败了，就必须记录这个事件，而不是把它扔掉。这就是为什么至关重要的死信队列(DLQ)功能能够通过接收这类事件的<a class="ae kt" href="https://dashbird.io/knowledge-base/sqs/introduction-to-sqs-queue-service/" rel="noopener ugc nofollow" target="_blank"> AWS SQS </a>来配置 DLQ。</li></ul><h1 id="89f4" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">AWS Lambda 重试行为的后果</h1><p id="751d" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">每个 Lambda 都可以用同一个输入多次执行<strong class="jx io">，而<em class="kx">“调用者”</em>并不知道它的发生。为了多次成功地执行相同的操作，Lambda 必须是“幂等的”<strong class="jx io">幂等性</strong>意味着当相同的输入多次运行时，不会产生额外的效果。</strong></p><p id="4d8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">值得一提的是，<strong class="jx io">无服务器函数并不是幂等项</strong>的唯一例子。一个标准的模型是 API 网络:当一个请求没有收到响应时，相同的请求将被重复发送。</p><p id="902b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，在无服务器架构中，当 Lambda 在收到响应之前超时，就会出现类似的情况。尽管这是一件非常意外的事情，但在某些情况下，错误的重试处理可能会导致严重的问题(数据库(DB)结构违规)。</p><h1 id="0324" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是 AWS 幂等？</h1><p id="fe08" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">幂等性的定义表明它是计算机科学和数学中特定运算的性质。除了第一次应用之外，它可以多次应用而不会破坏结果。但是，还是有些混乱。</p><blockquote class="ku kv kw"><p id="d64e" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">如果您希望多次执行同一个操作，但实际上不是重试，会发生什么情况？</p></blockquote><p id="fe8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设 Lambda 接收到一个用户操作日志作为输入，它单独负责将该操作日志记录到数据库中。在这个例子中，我们需要区分 Lambda 的触发输入和重试情况，因为它们是相同的，因为用户再次启动了相同的操作。</p><p id="2c00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">将 Lambda 的请求 ID 作为输入本身的一部分是正确的解决方案。</strong>只有在 Lambda 重试时，您才能获得相同的 ID。为了能够提取它，可以使用 Node.js 中的<em class="kx"> context.awsRequestId </em>或者任何其他语言中的适当字段。这个方法的作用是<strong class="jx io">提供了搜索重试执行的一般方法。</strong></p><p id="edc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">利用请求 ID 作为真正的等幂并不总是一个方便的解决方案。您可能已经注意到，在前面的例子中，这个 ID 也应该保存在 DB 中。这样，下面的调用将意识到是否需要添加新记录。还有一个解决方案，就是<strong class="jx io">使用一些内存中的数据存储</strong>。然而，这可能会增加相当大的开销。</p><h1 id="00fb" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">利用自动气象站阶跃函数建立自动气象站λ误差处理控制系统</h1><p id="fa1c" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">AWS Lambda 错误处理可以用不同的方式完成，比如利用包装器。另一方面，<strong class="jx io"> AWS 步骤函数</strong>已经被证明对于构建一个无服务器应用程序非常有益，它将适当地处理重试和错误，使步骤函数成为一个有效的解决方案。您可以在我们的<a class="ae kt" href="https://dashbird.io/blog/ultimate-guide-aws-step-functions/" rel="noopener ugc nofollow" target="_blank">步进函数终极指南</a>中了解更多关于 AWS 步进函数的信息。</p><h1 id="660e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迈出下一步</h1><p id="55d6" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">假设<strong class="jx io">应用程序必须执行多个操作来响应事件</strong>。通过用相同的λ组合它们，<strong class="jx io">代码将不得不分别检查每个操作</strong>。</p><blockquote class="ku kv kw"><p id="c3b4" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">如果你想保持你的λ幂等，应该重做吗？</p></blockquote><p id="06dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，这可能会导致严重的头痛。如果你了解了<a class="ae kt" href="https://dashbird.io/knowledge-base/well-architected/monolith-vs-microservices/" rel="noopener ugc nofollow" target="_blank">单片</a>应用和我们提到的阶跃函数例子之间的区别，这将会有所帮助。在单片应用程序中，<strong class="jx io">应用程序本身可以负责强制重试</strong>，因为它能够在它们之间等待，而这在无服务器中是不可能的。</p><p id="a472" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，使用<strong class="jx io">阶跃函数</strong>，您可以<strong class="jx io">在单独的λ</strong>上运行每个操作。此外，您可以为每种特定情况定义它们之间合适的转换。您还可以<strong class="jx io">控制重试的行为</strong>——它们的延迟时间和次数。这样，您可以很快调整到最适合您的特定情况。当你认为这是正确的步骤时，你甚至会禁用它。即使单个 Lambda 需要，创建步进机<strong class="jx io">可能是禁用不想要的重试行为</strong>的最直接的解决方案。</p><h1 id="e7d0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何对 Lambda 实现阶跃函数？</h1><p id="776a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">您可能知道，所有可用的<strong class="jx io">阶跃函数触发器都非常有限</strong>；唯一可用的触发器是 API Gateway，包括利用 SDK 的手动执行。</p><p id="2e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了成功部署这个 Lambda，你必须<strong class="jx io">利用无服务器框架</strong>，以及令人难以置信的<em class="kx">‘无服务器-资源-环境’</em>插件，这样它就可以<strong class="jx io">轻松通过状态机 ARN </strong>。此外，您必须确保使用<em class="kx">‘无服务器伪参数’</em>和<em class="kx">‘无服务器步进函数’</em>，以便能够定义状态机，如下例所示:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/e0e18fa50775d9de359ef1fcb8ee6172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9272pZHovScxMoEY.png"/></div></div></figure><p id="ba37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以看到，实现 SNS 事件的人工选择是为了触发状态机而特意做出的<strong class="jx io">，它可以作为初始步骤 Lambda 的输入进行访问。一切都将变得幂等，因为我们<strong class="jx io">故意将状态机的执行命名为调用者<em class="kx">‘Lambda 请求 ID’</em>如果这个调用程序 Lambda 发生重试，<strong class="jx io"> AWS 将给予它相同的请求 ID。</strong></strong></strong></p><p id="15b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在那之后，<strong class="jx io"> AWS 不会再执行状态机</strong>，因为它有相同的名字。理论上，状态机的执行名也是其输入的<strong class="jx io">部分。尽管这种解决方案在许多情况下是有利的，但你应该知道<strong class="jx io">它也会增加大量的复杂性开销</strong>，进一步影响系统的整体<a class="ae kt" href="https://dashbird.io/blog/debugging-serverless-apps-with-dashbird/" rel="noopener ugc nofollow" target="_blank">可观察性和调试。</a></strong></p><h1 id="c3b6" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于阶跃函数错误处理机制的注意事项</h1><p id="cf8a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">理解<a class="ae kt" href="https://dashbird.io/blog/aws-step-functions-error-handling/" rel="noopener ugc nofollow" target="_blank"> Step 函数的错误处理</a>机制与 AWS Lambda 错误处理机制有很大不同是很重要的。对于每个任务状态，可以设置一个<strong class="jx io">超时持续时间占位符</strong>，在任务没有及时完成的情况下，<em class="kx">会进行状态转换。将产生超时</em>错误。这种特殊的超时在某种程度上是无限的。此外，在执行 Lambda 的任务的典型情况下，情况<strong class="jx io">不会是相同的</strong>。Lambda 的<strong class="jx io">实际超时持续时间</strong>只能由它的<strong class="jx io">预配置值</strong>决定，利用这种方法不能再长了。因此，必须确保<strong class="jx io">您已经配置了任务超时</strong>，因此<strong class="jx io">等于 Lambda 的超时</strong>。默认情况下，任务的重试行为是禁用的，可以通过某种方式进行配置。</p><h1 id="a1c0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">AWS Lambda 误差处理器示例应用程序</h1><p id="470c" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">错误处理器示例应用程序展示了如何利用<a class="ae kt" href="https://dashbird.io/blog/complete-aws-lambda-handbook-beginners-part-1/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>来处理来自 AWS CloudWatch 日志订阅的事件。现在，<strong class="jx io"> CloudWatch 日志将允许您调用 Lambda </strong>函数，如果<strong class="jx io">日志条目匹配特定模式</strong>。该应用程序中的订阅将监控函数日志组中所有带有单词<em class="kx">错误</em>的条目。作为响应，它将<strong class="jx io">调用一个处理器 Lambda 函数。</strong>处理器函数随后将检索导致此错误的请求的完整日志流和跟踪数据，并存储它们以便以后使用。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/a1ea2d9e489d895b9a38c9024e779803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1HwK3SXRzBb2ypTH.png"/></div></div></figure><p id="f217" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">功能代码可在以下文件中找到:</p><ul class=""><li id="066a" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">处理器— <a class="ae kt" href="https://github.com/awsdocs/aws-lambda-developer-guide/blob/master/sample-apps/error-processor/processor/index.js" rel="noopener ugc nofollow" target="_blank">处理器/index.js </a></li><li id="085c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">随机误差— <a class="ae kt" href="https://github.com/awsdocs/aws-lambda-developer-guide/blob/master/sample-apps/error-processor/random-error/index.js" rel="noopener ugc nofollow" target="_blank"> random-error/index.js </a></li></ul><p id="3084" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过 AWS CloudFormation 和 AWS CLI 在几分钟内快速部署示例。</p><h1 id="b678" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件结构和架构</h1><p id="9ab0" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">这个示例应用程序利用了这些 AWS 服务:</p><ul class=""><li id="ee75" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><strong class="jx io">亚马逊 S3</strong>——它将存储应用程序输出和部署工件。</li><li id="be00" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> Amazon CloudWatch Logs </strong> —收集日志，但是当日志条目匹配过滤模式时，它也会调用一个函数。</li><li id="9c06" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> AWS X 射线</strong> —生成服务地图，索引搜索所需的轨迹，并收集轨迹数据。</li><li id="6087" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> AWS Lambda </strong> —将所有跟踪数据发送到 X 射线，将日志发送到 CloudWatch 日志，并运行功能代码。</li></ul><p id="b9d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当在应用程序中发现 Lambda 函数时，它会随机产生错误。如果 CloudWatch 日志在函数的日志中检测到单词<em class="kx"> ERROR </em>，它将为处理器函数提供一个事件进行处理。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/a740934e65f18df8e4cfb0ef44b962fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCmbXjbK_GZhVDSzaXRBog.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">CloudWatch 记录消息事件</figcaption></figure><p id="f780" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解码时，数据包含日志事件的详细信息。该函数将使用所有这些细节来成功地<strong class="jx io">识别日志流</strong>并且<strong class="jx io">解析日志消息</strong>，因此它将获得导致该错误的特定请求的 ID。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/2e82ee80c54b0cb1542d1061aa3e55c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hwz4YGxVIcwkaL2o.png"/></div></div></figure><p id="e509" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理器功能将利用从 CloudWatch 日志事件中获得的信息来下载导致错误的请求<strong class="jx io">的<a class="ae kt" href="https://dashbird.io/blog/tracing-lambda-functions-with-aws-x-ray/" rel="noopener ugc nofollow" target="_blank"> X 射线</a>轨迹和完整日志流。</strong>两者都将<strong class="jx io">储存在 AWS S3 桶内。</strong>此外，为了成功完成跟踪时间和日志流，该函数将在开始访问数据之前等待一小段时间。</p><h1 id="e9be" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">AWS X 射线仪器</h1><p id="4237" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">应用程序利用 AWS X 射线来测试<strong class="jx io"> race 函数调用</strong>以及函数对 AWS 的所有<strong class="jx io">调用。</strong> X 射线利用从功能接收的跟踪数据创建<strong class="jx io">服务图</strong>，这对<strong class="jx io">错误识别有重要帮助。</strong>这个特定的服务图展示了随机错误函数，该函数为一些特定的请求生成错误。此外，它展示了调用 CloudWatch 日志、亚马逊 S3 和 X 射线的处理器函数。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/419c713e922d5039b2749e5e86dbf7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hsle9fVnI42gz8Iq.png"/></div></div></figure><p id="d920" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个已配置的 Node.js 函数在模板内提供<strong class="jx io">主动跟踪</strong>，并在代码中使用 AWS X-Ray SDK (Node.js)进行检测。除了主动跟踪之外，Lambda 标签还会向所有传入的请求添加一个<strong class="jx io">跟踪头</strong>，并且它们会向 AWS X-Ray 发送一个带有<strong class="jx io">计时细节</strong>的跟踪。此外，随机错误功能利用 X-Ray SDK 来记录注释中的请求 ID 和用户信息。这些注释被附加到跟踪中，所以<strong class="jx io">您可以使用它们来定位特定请求的跟踪。</strong></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/8d1aa1356a56ee69cb39d9ef68a813e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ix0lawrXrCAT2bL.png"/></div></div></figure><p id="b556" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理器函数将从 CloudWatch Logs 事件中获取请求 ID，并利用 AWS SDK for JavaScript 在 X-Ray 中搜索该特定请求。它还利用了<strong class="jx io"> AWS SDK 客户端</strong>，X-Ray SDK 通过这些客户端下载日志流和跟踪。之后，<strong class="jx io">它会将它们存储在输出桶中。</strong>X-Ray SDK 将记录所有这些呼叫，并且<strong class="jx io">它们将作为子段</strong>出现在跟踪中。</p><h1 id="ec7f" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">AWS CloudFormation 模板和其他资源</h1><p id="be9b" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">该应用程序在两个 Node.js 模块中实现，并使用 shell 脚本和 AWS CloudFormation 模板进行部署。该模板将创建<strong class="jx io">处理器函数</strong>、<strong class="jx io">随机错误函数</strong>，以及所有以下<strong class="jx io">支持资源</strong>:</p><ul class=""><li id="817c" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><strong class="jx io">执行角色</strong> —是一个 IAM 角色，允许有权限的功能访问其他 AWS 服务。</li><li id="856a" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">初始函数</strong> —是一个附加函数，其目的是调用随机误差函数来创建一个特定的日志组。</li><li id="e789" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">定制资源</strong> —是另一个 AWS CloudFormation 定制资源，它将在部署期间调用 primer 函数，因此它将确保这个特定的日志组存在。</li><li id="d89f" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> CloudWatch Logs 订阅</strong> —当<em class="kx">错误</em>字被成功记录时，触发处理器功能的日志流的订阅。</li><li id="b6d8" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">基于资源的策略</strong> —是关于处理器功能的特定权限声明，允许通过 CloudWatch 日志调用。</li><li id="e844" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">亚马逊 S3 桶</strong> —是一个输出存储位置(处理器功能)。</li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/8d68b71cf99d0237b98aa0a46254b32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*maMknheXeNhWZY-A.png"/></div></div></figure><p id="7b9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你试图<strong class="jx io">解决将 Lambda </strong>与 CloudFormation 成功集成的限制，模板将提供一个<strong class="jx io">附加功能</strong>，它将<strong class="jx io">在部署</strong>期间运行。所有的 Lambda 函数总是带有一个特定的 CloudWatch 日志组，该日志组将<strong class="jx io">存储所有函数执行的输出</strong>。此外，在第一次调用该函数之前，不会创建这个日志组。</p><p id="5527" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">创建依赖于日志组唯一存在的订阅，应用程序需要利用第三个 Lambda 函数来调用随机错误函数。</strong>该模板还包括 primer 函数的内联代码。每个 AWS CloudFormation 定制资源都能够在部署期间调用它。<em class="kx">依赖</em>属性将确保<strong class="jx io">基于资源的策略</strong>和<strong class="jx io">日志流</strong>是在订阅之前<strong class="jx io">创建的。</strong></p><h1 id="a225" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Dashbird 如何帮助您更快、更轻松地处理 AWS Lambda 错误？</h1><p id="035f" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io">无服务器架构</strong>从根本上改变了我们开发、部署和监控应用的方式。正如你现在所知道的，像 AWS Lambda 这样的服务也有自己的限制和特性:有限的内存和执行时间，重试行为，以及许多其他可能产生副作用的服务，这些副作用很容易成为<strong class="jx io">监控噩梦</strong>。</p><p id="e3b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为计算、数据存储、队列等组合多个服务。放大了问题。潜在问题的数量因整个云堆栈中的交互和依赖性而成倍增加。</p><p id="4b25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大规模运行这样的架构更具挑战性。在每个流量级别，我们不能期望堆栈的行为是一致的。例如，AWS Lambda 函数的伸缩速度可能会比数据库更快。</p><p id="3daa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Dashbird 旨在<strong class="jx io">为开发人员提供轻松解决此类复杂问题的方法</strong>，同时在任何无服务器架构中实现高度可见性和高质量。</p><p id="55eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Dashbird 是由无服务器开发人员创建的，用于无服务器开发人员</strong>增强专门针对 AWS 服务的大规模监控和操作。通过<strong class="jx io">持续收集和过滤您的日志数据</strong>，Dashbird <strong class="jx io">会自动实时</strong>检测您所有的代码异常、超时、配置错误和其他异常<strong class="jx io">，如果有错误或即将发生的事情，会立即向您发送<strong class="jx io">通知</strong>。</strong></p><p id="fb34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最重要的是，该平台将基于<a class="ae kt" href="https://sls.dashbird.io/aws-well-architected-framework-serverless" rel="noopener ugc nofollow" target="_blank"> AWS 架构良好的框架</a>为您提供<strong class="jx io">可操作的见解</strong>，帮助您改进基础设施，使其在任何规模下都真正可靠，并能够随着时间的推移承担额外的复杂性。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/0c076234740b66252d63a8e6de9fc0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AkETQ0gt1PzgV8Ft.gif"/></div></div></figure><p id="4851" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以<a class="ae kt" href="https://dashbird.io/features/" rel="noopener ugc nofollow" target="_blank">免费试用一下大鸟</a>:</p><ul class=""><li id="6f46" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">没有代码更改</li><li id="029c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">不需要信用卡</li><li id="3d9d" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">简单的两分钟设置</li><li id="2f99" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">获得所有高级功能</li><li id="1a2b" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">立即开始处理您的数据并排除故障</strong></li></ul><h1 id="cf52" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包扎</h1><p id="c0ae" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">无服务器架构中的 AWS Lambda 错误处理可能看起来相当混乱，但是尽管很难理解它如何影响您的整个系统，但彻底理解它是至关重要的。知道如何<strong class="jx io">成功管理 AWS Lambda 重试行为</strong>很重要，对于步骤函数也是如此。上下文参数中的每个重试计数器字段无疑是一个已经丢失的特性。</p><p id="8f90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了本文提到的技术之外，还有各种其他方法可以帮助处理 AWS Lambda 错误，利用包装器只是一个例子。</p><p id="2e62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们今天讨论的具有阶跃函数的架构在很多情况下都非常有用，AWS Lambda 错误处理就是其中之一。即使它有助于适当地控制 Lambda 重试，它也鼓励元素的<strong class="jx io">分离</strong>，这在无服务器的世界中是一个很好的实践。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h2 id="94ce" class="nl lc in bd ld nm nn dn lh no np dp ll kg nq nr lp kk ns nt lt ko nu nv lx nw bi translated">延伸阅读:</h2><ul class=""><li id="1d6d" class="me mf in jx b jy lz kc ma kg nx kk ny ko nz ks mj mk ml mm bi translated"><a class="ae kt" href="https://dashbird.io/blog/python-aws-lambda-error-handling/" rel="noopener ugc nofollow" target="_blank">AWS Lambda 中的 Python 错误处理</a></li><li id="088b" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://dashbird.io/blog/how-to-save-hundreds-hours-debugging-lambda/" rel="noopener ugc nofollow" target="_blank">如何在 Lambda 调试上节省数百小时</a></li><li id="80b1" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://dashbird.io/blog/saving-money-aws-lambda/" rel="noopener ugc nofollow" target="_blank"> 6 种降低成本的方法</a></li><li id="03eb" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://dashbird.io/blog/aws-console-serverless-debugging/" rel="noopener ugc nofollow" target="_blank">为什么 AWS CloudWatch 不是最好的无服务器调试？</a></li></ul></div></div>    
</body>
</html>