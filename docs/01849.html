<html>
<head>
<title>8 quick ways of improving React app performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React应用程序性能的8种快速方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/8-quick-ways-of-improving-react-app-performance-4eb187608c4?source=collection_archive---------0-----------------------#2020-07-13">https://blog.devgenius.io/8-quick-ways-of-improving-react-app-performance-4eb187608c4?source=collection_archive---------0-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/486c10880116cfa24c3bd9e85b41e9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nL0qMIR2QoY1Z2zoLGbuXw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自<a class="ae jz" href="https://www.ebay.com/i/222212508756?chn=ps&amp;norover=1&amp;mkevt=1&amp;mkrid=711-117182-37290-0&amp;mkcid=2&amp;itemid=222212508756&amp;targetid=917185845248&amp;device=c&amp;mktype=pla&amp;googleloc=9060360&amp;poi=&amp;campaignid=10459991946&amp;mkgroupid=100467642381&amp;rlsatarget=pla-917185845248&amp;abcId=2146000&amp;merchantid=113800378&amp;gclid=EAIaIQobChMIiYbf__W86gIVIwnnCh06GwNCEAQYASABEgJdRPD_BwE" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure><p id="a06f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您的经理要求您<em class="ky">“提高我们React应用的前端性能。”</em>从哪里开始？</p><p id="fa0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这个清单上的大多数项目现在感觉像是第二天性，但是三、四年前的我会发现它们非常有用。</p><p id="ec3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从基本原则的角度来看，您可以将性能归结为两个因素:内存和CPU。使用量越低越好。</p><p id="4f95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">延迟也是需要考虑的重要因素。例如，网络请求的延迟比存储和读取缓存数据或资产的延迟高得多。改善延迟是一个值得讨论的话题，它将不会是本文的重点。你可以在这里查看常见的延迟数字:<a class="ae jz" href="https://gist.github.com/jboner/2841832" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jboner/2841832</a></p><p id="5f95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将如何解决内存和CPU的使用分成几个部分。处理绩效的所有8种方法都属于这两类中的一类。</p><p id="ceed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> TLDR:您可以通过</strong><code class="fe kz la lb lc b"><strong class="kc io">command+f</strong></code><strong class="kc io"><em class="ky">TLDR #</em>浏览此贴。</strong></p><h1 id="1e81" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">I .降低CPU消耗</h1><p id="49c9" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">CPU消耗来自代码执行。例如，每次React组件渲染时，它都会占用CPU。每次发出网络请求，都会占用CPU。每次执行一个函数，它都会占用CPU。</p><h2 id="5589" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">第1部分:消除无用的React组件重新呈现</h2><p id="6e43" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">这一节对于大多数使用过React的人来说应该很熟悉，但是我还是要写它。</p><p id="8bfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一个组件在没有实际状态或道具改变的情况下重新渲染，这表明该组件正在不必要的重新渲染。</p><p id="8c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个普通的组件(<code class="fe kz la lb lc b">React.Component</code>)在每次<code class="fe kz la lb lc b">setState</code>被调用时，或者当它从父组件接收到新的道具时重新渲染，不管实际值是否已经改变。</p><p id="63ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，PureComponent ( <code class="fe kz la lb lc b">React.PureComponent</code>)在重新渲染之前会对其状态和道具进行浅层比较。因此，如果状态和属性没有改变，使用PureComponent将消除重新渲染。</p><blockquote class="ms"><p id="3f62" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #1:用<code class="fe kz la lb lc b">React.PureComponent</code>替换<code class="fe kz la lb lc b">React.Component</code></p></blockquote><p id="ff10" class="pw-post-body-paragraph ka kb in kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">在Javascript中<code class="fe kz la lb lc b">[] === []</code>为false。Javascript通过引用进行对象比较。因此，传递给组件的属性(数组或对象)的浅层比较将会失败。因此，您应该避免将对象或数组的新实例作为道具直接传入组件。</p><p id="e493" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要这样做:</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="bbaa" class="mg le in lc b gy np nq l nr ns">&lt;CorgiList corgis={(this.state.dogs || []).filter((dog) =&gt; dog.breed === 'corgi')} /&gt;</span></pre><p id="bc86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们调用<code class="fe kz la lb lc b">filter</code>，它每次都会创建一个新的数组。</p><blockquote class="ms"><p id="041e" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #2:不要把数组或对象的新实例作为道具传入组件</p></blockquote><p id="b84d" class="pw-post-body-paragraph ka kb in kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">redux中的连通分量也做自动浅层比较。在连接的组件中，还应该避免创建数组或对象的新实例。考虑这个例子:</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="e7db" class="mg le in lc b gy np nq l nr ns">const mapStateToProps = (state) =&gt; {<br/>  return {<br/>    corgis: (state.dogs || []).filter((dog) =&gt; dog.breed === 'corgi')<br/>  }<br/>}</span><span id="d5f9" class="mg le in lc b gy nt nq l nr ns">connect(mapStateToProps)(CorgiList)</span></pre><p id="2c5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次redux商店发生变化，<code class="fe kz la lb lc b">mapStateToProps</code>就会被调用。因此，即使一个不相关的对象(例如，<code class="fe kz la lb lc b">state.cats</code>相对于<code class="fe kz la lb lc b">state.dogs</code>)由于redux动作而改变，这个<code class="fe kz la lb lc b">mapStateToProps</code>将运行并返回一个新的数组，导致<code class="fe kz la lb lc b">CorgiList</code>组件重新呈现。</p><p id="d5b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，提高React性能的一个简单方法是删除<code class="fe kz la lb lc b">mapStateToProps</code>中所有新建的<code class="fe kz la lb lc b">{}</code>或<code class="fe kz la lb lc b">[]</code>对象。</p><p id="aa3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现这一点的方法是使用选择器。如果一个选择器的所有参数都没有改变，它将返回一个记忆化的结果。这意味着如果<code class="fe kz la lb lc b">state.dogs</code>没有改变，我们的<code class="fe kz la lb lc b">CorgiList</code>组件将不会重新渲染。</p><p id="3ea9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<a class="ae jz" href="https://github.com/toomuchdesign/re-reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>来考虑这个实现:</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="b308" class="mg le in lc b gy np nq l nr ns">import { createCachedSelector } from 're-reselect';</span><span id="9f51" class="mg le in lc b gy nt nq l nr ns">const getDogs = (state) =&gt; state.dogs;<br/>const getBreed = (_state, breed) =&gt; breed;</span><span id="e41a" class="mg le in lc b gy nt nq l nr ns">const getCorgiList = createCachedSelector(<br/>  [getDogs, getBreed],<br/>  (dogs, breed) =&gt; {<br/>    return (dogs || []).filter((dog) =&gt; dog.breed === breed)<br/>  }<br/>)(<br/>  // re-reselect keySelector (receives selectors' arguments)<br/>  // Use "breed" as cacheKey<br/>  (_state, breed) =&gt; breed<br/>);</span><span id="d986" class="mg le in lc b gy nt nq l nr ns"><br/>const mapStateToProps = (state) =&gt; {<br/>  return {<br/>    corgis: getCorgiList(state, 'corgi')<br/>  }<br/>}</span></pre><blockquote class="ms"><p id="cebe" class="mt mu in bd mv mw nu nv nw nx ny kx dk translated">TLDR #2:在<code class="fe kz la lb lc b">mapStateToProps by using selectors</code>中删除新<code class="fe kz la lb lc b">{ }</code>和<code class="fe kz la lb lc b">[ ]</code>的创建</p></blockquote><h2 id="dc73" class="mg le in bd lf mh nz dn lj mj oa dp ln kl ob mm lr kp oc mo lv kt od mq lz mr bi translated">第2部分:减少高频函数调用</h2><p id="51a0" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">如果应用程序正在快速连续地多次执行某个代码块，这是一个改进的机会。</p><p id="e9a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑这个实现:</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="62a5" class="mg le in lc b gy np nq l nr ns">saveInput = (e) =&gt; {<br/>  const text = e.target.value;<br/>  fetch(SOME_URL, {<br/>    method: 'POST',<br/>    <!-- -->headers: {<br/>      'Content-Type': 'application/json'<br/>    },<br/>    <!-- -->body: JSON.stringify({ text })<br/>  });<br/>}</span><span id="8540" class="mg le in lc b gy nt nq l nr ns">render() {<br/>  return (<br/>    &lt;input<br/>      onChange={this.saveInput}<br/>      ...<br/>    /&gt;<br/>  )<br/>}</span></pre><p id="7e6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于输入字段的每个<code class="fe kz la lb lc b">onChange</code>事件，我们发出一个网络请求。如果这是一个在数百个文件的代码库中重复出现的模式，它将很容易提高CPU使用率。(注意，我可以在我的例子中调度一个动作，而不是<code class="fe kz la lb lc b">fetch</code>，这没关系。想法是我们不应该对每个事件都执行处理程序，因为处理程序很可能被高频率地触发)。</p><p id="cd08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据您的需要，以对您的应用有意义的时间间隔，将高频呼叫封装在<a class="ae jz" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖</a>或<a class="ae jz" href="https://lodash.com/docs/4.17.15#throttle" rel="noopener ugc nofollow" target="_blank">节流</a>中。</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="7674" class="mg le in lc b gy np nq l nr ns">debouncedSaveInput = _.debounce((e) =&gt; {<br/>  const text = e.target.value;<br/>  fetch(<br/>    ...<br/>  );<br/>}, SOME_INTERVAL);</span><span id="c058" class="mg le in lc b gy nt nq l nr ns">render() {<br/>  return (<br/>    &lt;input<br/>      onChange={this.debouncedSaveInput}<br/>      ...<br/>    /&gt;<br/>  )<br/>}</span></pre><blockquote class="ms"><p id="84f8" class="mt mu in bd mv mw nu nv nw nx ny kx dk translated">TLDR #4:使用去抖或节流来限制高频通话</p></blockquote><p id="e321" class="pw-post-body-paragraph ka kb in kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">另一个常见的性能陷阱是遍历一个数组，并为数组中的每一项调用一个函数(比如调度一个动作)。</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="8538" class="mg le in lc b gy np nq l nr ns">componentDidMount() {<br/>  this.props.corgis.forEach((corgi) =&gt; {<br/>    this.props.fetchOwnerInfoForCorgi(corgi);<br/>  });<br/>}</span></pre><p id="480a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就性能而言，更好的设计模式是消除循环，取而代之的是获取给定的CORBA列表所需的所有信息。</p><pre class="nh ni nj nk gt nl lc nm nn aw no bi"><span id="a179" class="mg le in lc b gy np nq l nr ns">componentDidMount() {<br/>  this.props.fetchOwnerInfoForCorgis(this.props.corgis)<br/>}</span></pre><p id="611d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修复这个性能问题通常需要更多的努力和重构。如果这是你的代码库中的一种常见模式，从长远来看，在工程文化中采用批量优先的思想是有益的。</p><blockquote class="ms"><p id="09bc" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #5:批量获取、创建、更新、删除等。</p></blockquote><h2 id="aba8" class="mg le in bd lf mh nz dn lj mj oa dp ln kl ob mm lr kp oc mo lv kt od mq lz mr bi translated">第3部分:减少页面上的代码量</h2><p id="987e" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">页面上的代码越少，页面使用的CPU就越少。</p><p id="7b74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Chrome dev tools的performance标签有一个Javascript CPU profiler。分析器可以按功能分解CPU的使用情况。<a class="ae jz" href="https://blog.appsignal.com/2020/02/20/effective-profiling-in-google-chrome.html" rel="noopener ugc nofollow" target="_blank">这是我跟随</a>学习如何使用性能工具的一个好帖子。</p><p id="2d4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我对https://coronavirus.medium.com/的侧写</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/b0b23e45553218d2fd0fe360a00c2d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG0CTNzYIpJwh8WXevgwFQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">页面负载分析</figcaption></figure><p id="3a4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">页面上有大量的脚本(黄色条)或Javascript代码评估。沿着调用树往下，您可以看到瓶颈在哪里:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/1332cf20e2dc4827e2b12f0daf46292b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_97wR5WkzjtV7f1QsFlxA.png"/></div></div></figure><p id="b98a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来大多数脚本都来自供应商脚本/节点模块。</p><p id="7528" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还可以放大时间线以查看正在运行的确切功能:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/58c66d5a9704cdf70a6507154322642d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11RlePPdGMchUpa_bntFBw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">告诉您正在运行哪些功能</figcaption></figure><p id="e9da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不管所有这些脚本是否对那个页面是必要的，它把我带到了我的下一个观点。在页面上加载尽可能少的Javascript。</p><blockquote class="ms"><p id="5c55" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #6:找到减少捆绑包大小的方法</p></blockquote><p id="5834" class="pw-post-body-paragraph ka kb in kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">npm很容易安装一个库来解决我们的问题，而不需要考虑额外模块的成本。不要这样做，尤其是当你只需要库的一部分功能时。注意可能会增加包大小的依赖项。在每个文件中只导入您需要的内容。</p><p id="ec97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<a class="ae jz" href="https://medium.com/hackernoon/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758" rel="noopener">包分割</a>或者使用Webpack进行代码分割(如果你还没有这样做的话)。</p><h1 id="d904" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">二。降低内存消耗</h1><p id="25bd" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">内存消耗来自存储。例如，redux存储越大，内存使用就越多。Redux存储大小也会影响CPU，因为更大的存储意味着当状态改变时更多的计算。</p><h2 id="0113" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">第1部分:减少冗余大小</h2><p id="ba6b" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">redux存储规模过大的一个常见原因是预先加载了过多的必要信息。</p><p id="62cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决大型redux商店的一个方法是延迟加载商店。这意味着不要填充整个商店；在用户请求时获取新项目。</p><p id="dc5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">惰性加载会产生额外的网络请求，从而导致应用程序的延迟更大。因此，对于小商店来说，这很可能不值得。</p><p id="dfa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个可能的解决方案是预取数据并将数据保存到indexDB(磁盘)。当用户请求数据时，从indexDB读取，而不是发出网络请求。正如这里的<a class="ae jz" href="https://gist.github.com/jboner/2841832" rel="noopener ugc nofollow" target="_blank">所写的</a>，从磁盘读取比发出网络请求的延迟要低。然而，像内存一样，磁盘也有<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria#Storage_limits" rel="noopener ugc nofollow" target="_blank">存储限制</a>。</p><blockquote class="ms"><p id="144f" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #7:懒惰装载大redux商店</p></blockquote><h2 id="47cd" class="mg le in bd lf mh nz dn lj mj oa dp ln kl ob mm lr kp oc mo lv kt od mq lz mr bi translated">第2节:修复内存泄漏</h2><p id="73ca" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">内存问题的另一个来源是内存泄漏。在Javascript中，当垃圾收集器无法清除未使用的变量时，就会发生这种情况。因此，应用程序中有一些在任何地方都不会用到的对象。</p><p id="6201" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React中，一个常见的泄漏源是卸载组件时未附加的事件侦听器。另一个泄漏源是来自<code class="fe kz la lb lc b">setTimeout</code>或<code class="fe kz la lb lc b">setInterval</code>的泄漏，这些泄漏在组件卸载时没有被清除。</p><p id="1cba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个我发现的很酷的例子:<a class="ae jz" href="https://egghead.io/lessons/react-stop-memory-leaks-with-componentwillunmount-lifecycle-method-in-react" rel="noopener ugc nofollow" target="_blank">https://egghead . io/lessons/react-stop-memory-leaks-with-component will unmount-life cycle-method-in-react</a></p><p id="b6ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Chrome开发工具显示内存泄漏在哪里。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/a47ab207d080ea058c55ca824db81b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz9C-A_IcXbcaPEwsGrovA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">本页<a class="ae jz" href="https://medium.com/hackernoon/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758" rel="noopener">的剖析此处</a></figcaption></figure><p id="d3b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转到“Memory”选项卡，拍摄堆快照，然后过滤“detached”。<a class="ae jz" href="https://developers.google.com/web/tools/chrome-devtools/memory-problems" rel="noopener ugc nofollow" target="_blank">分离的对象是内存泄漏的常见原因</a>，因为这些对象没有被使用。</p><blockquote class="ms"><p id="dc4c" class="mt mu in bd mv mw mx my mz na nb kx dk translated">TLDR #8:通过移除事件监听器和清除计时事件来修复内存泄漏</p></blockquote></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="0337" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到前端性能，少即是多，懒即是好。加载绝对最小值脚本，并做你能逃脱的绝对最小值计算。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/a857abc9c1281211a9a74164a395a79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnigZ1vD7IIedlE-7ethSQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">柯基从<a class="ae jz" href="https://www.flickr.com/photos/milkyfactory/16223331172" rel="noopener ugc nofollow" target="_blank">到这里</a></figcaption></figure></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h2 id="7999" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">我是Slack的前端基础设施工程师。你可以在LinkedIn上找到我。</h2><h2 id="e817" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">如果你觉得这篇文章有价值，介意为我鼓掌吗？我将不胜感激！😃</h2></div></div>    
</body>
</html>