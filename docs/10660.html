<html>
<head>
<title>MVVM architecture, ViewModel and LiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM 建筑、ViewModel 和 LiveData</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mvvm-architecture-viewmodel-and-livedata-d6c74ef45728?source=collection_archive---------1-----------------------#2022-11-20">https://blog.devgenius.io/mvvm-architecture-viewmodel-and-livedata-d6c74ef45728?source=collection_archive---------1-----------------------#2022-11-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f809" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是 MVVM？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/8c73606b6d92b9e5a8d995caa6d58216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*x_gukitZvSTd7eQebvMAAw.png"/></div></figure><p id="84aa" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">模型-视图-视图模型(MVVM)是一种软件设计模式，旨在分离程序逻辑和用户界面控件。</p><p id="3ce3" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">MVVM 基本上由三层组成:</p><p id="fd49" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">模型:它保存了应用程序的数据。它不能直接与视图对话。通常，建议通过 Observables 向 ViewModel 公开数据。</p><p id="fb0c" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">视图:它表示应用程序的 UI，没有任何应用程序逻辑。它观察视图模型。</p><p id="a186" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">ViewModel:它充当模型和视图之间的链接。它负责转换模型中的数据。准备可由视图观察到的可观察对象..它还使用挂钩或回调来更新视图。它将从模型中请求数据。</p><p id="16cb" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在下面的简单图表中，我们可以很容易地看到这三个部分之间存在什么样的相互作用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/a93763300578ec9b8b515a812d80ccaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*2YMOIUxRlJ6Tl1KOKIV62Q.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">MVVM</figcaption></figure><h1 id="1397" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">LiveData</h1><p id="d729" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated"><code class="fe ly lz ma mb b"><a class="ae mc" href="https://developer.android.com/reference/androidx/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData 具有生命周期意识，这意味着它尊重其他应用程序组件的生命周期，如活动、片段或服务。这种意识确保 LiveData 仅更新处于活动生命周期状态的应用程序组件观察者。</p><blockquote class="md me mf"><p id="7e45" class="kq kr mg ks b kt ku kv kw kx ky kz la mh lc ld le mi lg lh li mj lk ll lm ln ig bi translated">使用 LiveData 的优势</p></blockquote><ol class=""><li id="ebd5" class="mk ml in ks b kt ku kx ky lb mm lf mn lj mo ln mp mq mr ms bi translated"><strong class="ks io">确保你的用户界面与你的数据状态相匹配</strong></li><li id="8fa7" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">没有内存泄露</strong></li><li id="7cff" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">没有因停止活动而导致的崩溃</strong></li><li id="04db" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">不再需要手动处理生命周期</strong></li><li id="d106" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">总是最新数据</strong></li><li id="e0cf" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">适当的配置变更</strong></li><li id="7083" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated"><strong class="ks io">共享资源</strong></li></ol><p id="9d08" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在让我们看看我是如何在我的消息应用程序中使用它的。</p><h1 id="866d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">将 LiveData 用于域层或存储库层</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/8ed4eab3dba1790243135ed7b4038a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSt-3Fh3V8rPuRioxjwmTg.png"/></div></div></figure><p id="5abd" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须使用不同的图层来获取数据。</p><p id="2be3" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">存储库可以有以下实例:</p><ol class=""><li id="4bfb" class="mk ml in ks b kt ku kx ky lb mm lf mn lj mo ln mp mq mr ms bi translated">远程即网络</li><li id="dcb7" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated">数据库ˌ资料库</li><li id="15f6" class="mk ml in ks b kt mt kx mu lb mv lf mw lj mx ln mp mq mr ms bi translated">缓存或共享首选项。</li></ol></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="469e" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">贮藏室ˌ仓库</h1><p id="5bdf" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">有一个为消息传递定义任务的接口和一个使用该接口的类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/694216ee9e1b7498c772181b9f6eaad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*EMOzIsbfyAa0zlF0DcPNyw.png"/></div></figure><p id="e0ed" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">示例存储库接口</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="04d9" class="nu jl in mb b be nv nw l nx ny">interface UserRepositoryI {<br/>    fun showListOfUser(userList : ArrayList&lt;Users&gt;)<br/>}</span></pre><p id="e4ef" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我用 firebase 做仓库。</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="9b61" class="nu jl in mb b be nv nw l nx ny">class UserRepository(UserRepositoryI: UserRepositoryI) {<br/><br/>    private var userRepositoryI : UserRepositoryI ?= UserRepositoryI<br/>    private  var userList = ArrayList&lt;Users&gt;()<br/><br/>    fun getUserFirebase(){<br/>        val ref = FirebaseDatabase.getInstance().getReference("/users")<br/>        ref.addListenerForSingleValueEvent(object : ValueEventListener {<br/>            override fun onDataChange(snapshot: DataSnapshot) {<br/>                userList.clear()<br/>                snapshot.children.forEach{<br/>                    val user = it.getValue(Users::class.java)<br/><br/>                    if (user!=null &amp;&amp; user.uid != FirebaseAuth.getInstance().uid){<br/>                        userList.add(user)<br/>                        userRepositoryI?.showListOfUser(userList)<br/><br/>                    }<br/>                }<br/><br/>            }<br/>            override fun onCancelled(error: DatabaseError) {<br/>                Log.d("ViewModel",error.message)<br/>            }<br/>        })<br/>    }<br/>}</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="864a" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">模型</h1><p id="a2ff" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">让我们创建一个数据模型类</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="396c" class="nu jl in mb b be nv nw l nx ny">@Entity<br/>@Parcelize<br/>class Users(<br/>    @PrimaryKey(autoGenerate = false)<br/>    var uid : String ,<br/>    @ColumnInfo(name = "username")<br/>    var username:String,<br/>    @ColumnInfo(name = "profileImageURL")<br/>    var profileImageURL:String,<br/>    @ColumnInfo(name = "status")<br/>    var status : String,<br/>    @ColumnInfo(name = "Email")<br/>    var Email : String,<br/>    @ColumnInfo(name = "activeState")<br/>    var activeState : String ,<br/>    @ColumnInfo(name = "token")<br/>    var token : String?) : Parcelable{<br/><br/>    constructor() : this("","","","","","offline","")<br/><br/>    companion object{<br/>        private val addition = Addition()<br/>        @JvmStatic<br/>        @BindingAdapter("imageUrl")<br/>        fun loadImage(view : CircleImageView , imageUrl : String?){<br/>            imageUrl?.let {<br/>                addition.picassoUseIt(imageUrl,view)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="2af7" class="mk ml in ks b kt ku kx ky lb mm lf mn lj mo ln nz mq mr ms bi translated"><strong class="ks io"> Room </strong> —它是 Google 提供的一个 ORM，以对象的形式在 SQLite 数据库和我们的数据之间提供了一个抽象层。它在编译时给我们错误，这比难以跟踪和调试的运行时错误好得多。为了使用房间，定义我们的模式非常重要。我们通过创建一个数据模型类并添加一个<a class="ae mc" href="http://twitter.com/entity" rel="noopener ugc nofollow" target="_blank"> @entity </a>注释来做到这一点。我们还必须给实体的 id 添加一个<a class="ae mc" href="http://twitter.com/PrimaryKey" rel="noopener ugc nofollow" target="_blank"> @PrimaryKey </a>注释。</li></ul></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="1de7" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">视图模型</h1><p id="1add" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">ViewModel 对象充当视图和模型之间的中介，这意味着它为片段或活动等 UI 组件提供数据。它还包括一个名为 LiveData 的可观察数据容器，允许 ViewModel 在数据更新时通知或更新视图。这是非常关键的，主要是为了防止我们的应用程序在方向改变时重新加载。这最终提供了出色的用户体验。这里有一个例子，</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="5bf0" class="nu jl in mb b be nv nw l nx ny">class UserListViewModel(application: Application) : BaseViewModel(application), UserRepositoryI {<br/>    private var userRepository = UserRepository(this)<br/>    val users = MutableLiveData&lt;List&lt;Users&gt;&gt;()<br/>    val userLoading = MutableLiveData&lt;Boolean&gt;()<br/>    val informationMessage = MutableLiveData&lt;Boolean&gt;()<br/><br/>    private val specialSharedPreferences = SpecialSharedPreferences(getApplication())<br/>    private var updateTimeValue = 0.1 * 60 * 1000 * 1000 * 1000L<br/>    fun getAllUsers() : LiveData&lt;List&lt;Users&gt;&gt;{<br/>        return users<br/>    }<br/>    fun getUser(){<br/>        val getTime = specialSharedPreferences.getTime()<br/>        if (getTime !=null &amp;&amp; getTime!=0L &amp;&amp; System.nanoTime()-getTime&lt;updateTimeValue){<br/>            //get SqLite<br/>            getDataSQlite()<br/>        }<br/>        else{<br/>            //get Firebase<br/>            userRepository.getUserFirebase()<br/>            getAllUsers().value?.let { saveSQLite(it) }<br/><br/>        }<br/><br/>    }<br/>    private fun getDataSQlite(){<br/>        launch {<br/>            val userList = UsersDatabase(getApplication()).usersDao().getAllUser()<br/>            if (userList.isEmpty()){<br/>                userRepository.getUserFirebase()<br/>                getAllUsers().value?.let { saveSQLite(it) }<br/>            }<br/>            users.value = userList<br/>            informationMessage.value = userList.isEmpty()<br/>            userLoading.value = false<br/>        }<br/>    }<br/>    override fun showListOfUser(userList: ArrayList&lt;Users&gt;) {<br/>        users.value = userList<br/>        informationMessage.value = userList.size==0<br/>        userLoading.value = false<br/>    }<br/>    private fun saveSQLite(userList : List&lt;Users&gt;) {<br/>        launch {<br/>            val dao = UsersDatabase(getApplication()).usersDao()<br/>            dao.deleteAllUser()<br/>            dao.insertAllUser(*userList.toTypedArray())<br/>        }<br/>        specialSharedPreferences.saveTime(System.nanoTime())<br/>    }<br/>}</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="6b47" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">视角</h1><p id="80d4" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">我们在视图端观察来自视图模型的可观察的实时数据。</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="0b96" class="nu jl in mb b be nv nw l nx ny"> private fun observeLiveData(){<br/>        viewModel.users.observe(viewLifecycleOwner, Observer {<br/>            it?.let {<br/>                binding.newInformationTV.visibility = View.GONE<br/>                binding.recyclerView4.visibility = View.VISIBLE<br/><br/>                adapter.UsersListUpdate(it)<br/>            }<br/><br/>        })<br/>        viewModel.informationMessage.observe(viewLifecycleOwner, Observer {<br/>            it?.let {<br/>                if (it){<br/>                    binding.newInformationTV.text = "Kullanıcı Listen Boş"<br/>                }<br/>                else{<br/>                    binding.newInformationTV.text = ""<br/>                }<br/>            }<br/>        })<br/>        viewModel.userLoading.observe(viewLifecycleOwner, Observer {<br/>            it?.let {<br/>                if (it){<br/>                    binding.newLoadingBar.visibility = View.VISIBLE<br/>                }<br/>                else<br/>                {<br/>                    binding.newLoadingBar.visibility = View.GONE<br/>                }<br/>            }<br/>        })<br/>    }</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="0632" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">回收器视图适配器</h1><p id="6fa4" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">我们用适配器在视图端显示我们观察到的实时数据。</p><pre class="kj kk kl km gt nq mb nr bn ns nt bi"><span id="7902" class="nu jl in mb b be nv nw l nx ny">class NewMessagesRVAdapter(private val userList: ArrayList&lt;Users&gt;) : RecyclerView.Adapter&lt;NewMessagesRVAdapter.NewMessageViewHolder&gt;(),Filterable{<br/>    var userFilterList = ArrayList&lt;Users&gt;()<br/>    lateinit var mContext: Context<br/><br/><br/>    init {<br/>        userFilterList = userList<br/>    }<br/>    private val addition = Addition()<br/>    class NewMessageViewHolder(itemView: View): RecyclerView.ViewHolder(itemView){<br/>        var itemImage : ImageView = itemView.findViewById(R.id.message_imageView)<br/>        var itemTitle : TextView = itemView.findViewById(R.id.message_TV)<br/>        var itemStatus: TextView = itemView.findViewById(R.id.status_TV)<br/>        var itemProgressBar : ProgressBar = itemView.findViewById(R.id.new_messages_progressBar)<br/>    }<br/>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): NewMessageViewHolder {<br/>        val view = LayoutInflater.from(parent.context).inflate(R.layout.user_row_new_message,parent,false)<br/>        return NewMessageViewHolder(view)<br/>    }<br/>    override fun getItemCount(): Int {<br/>        return userFilterList.size<br/>    }<br/>    override fun onBindViewHolder(holder: NewMessageViewHolder, position: Int){<br/>        holder.itemTitle.text = userFilterList[position].username<br/>        holder.itemStatus.text = userFilterList[position].status<br/>        addition.picassoUseIt(userFilterList[position].profileImageURL,holder.itemImage,holder.itemProgressBar)<br/>        holder.itemProgressBar.visibility = View.GONE<br/>        holder.itemView.setOnClickListener {<br/>            val action = NewMessagesFragmentDirections.actionNewMessagesFragmentToChatLogFragment(<br/>                position,<br/>                userFilterList[position].uid,<br/>                userFilterList[position].username,<br/>                userFilterList[position].profileImageURL,<br/>                userFilterList[position].status,<br/>                userFilterList[position].activeState,<br/>                userFilterList[position].Email,<br/>                userFilterList[position].token!!<br/>            )<br/>            Navigation.findNavController(it).navigate(action)<br/>        }<br/><br/>    }<br/><br/><br/>    @SuppressLint("NotifyDataSetChanged")<br/>    fun UsersListUpdate(NewUserList : List&lt;Users&gt;){<br/>        userList.clear()<br/>        userList.addAll(NewUserList)<br/><br/>        notifyDataSetChanged()<br/>    }<br/><br/>    override fun getFilter(): Filter {<br/>        return object : Filter() {<br/>            override fun performFiltering(constraint: CharSequence?): FilterResults {<br/>                val charSearch = constraint.toString()<br/>                if (charSearch.isEmpty()) {<br/>                    userFilterList = userList<br/>                } else {<br/>                    val resultList = ArrayList&lt;Users&gt;()<br/>                    for (row in userList) {<br/>                        if (row.username.lowercase(Locale.ROOT).contains(charSearch.lowercase(Locale.ROOT))) {<br/>                            resultList.add(row)<br/>                        }<br/>                    }<br/>                    userFilterList = resultList<br/>                }<br/>                val filterResults = FilterResults()<br/>                filterResults.values = userFilterList<br/>                return filterResults<br/>            }<br/><br/>            @SuppressLint("NotifyDataSetChanged")<br/>            @Suppress("UNCHECKED_CAST")<br/>            override fun publishResults(constraint: CharSequence?, results: FilterResults?) {<br/>                userFilterList = results?.values as ArrayList&lt;Users&gt;<br/>                notifyDataSetChanged()<br/>            }<br/><br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="4bc1" class="jk jl in bd jm jn nk jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd no kf kg kh bi translated">结果</h1><p id="3526" class="pw-post-body-paragraph kq kr in ks b kt lt kv kw kx lu kz la lb lv ld le lf lw lh li lj lx ll lm ln ig bi translated">一个人可以不遵循这种架构而轻松地制作 android 应用程序，但是如果我们想要制作健壮、可测试、可维护和易读的应用程序，那么我们必须利用这一点。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="ae1a" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢阅读，如果你喜欢这篇文章，记得给鼓掌。</p></div></div>    
</body>
</html>