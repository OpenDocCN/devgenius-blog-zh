<html>
<head>
<title>Conversion of Entity to DTO Using ModelMapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模型映射器将实体转换为 DTO</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/conversion-of-entity-to-dto-using-modelmapper-21f2ca8a0ff7?source=collection_archive---------0-----------------------#2021-04-03">https://blog.devgenius.io/conversion-of-entity-to-dto-using-modelmapper-21f2ca8a0ff7?source=collection_archive---------0-----------------------#2021-04-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="74d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示如何使用模型映射库实现<strong class="jm io">实体到 DTO 的转换。我们将为<code class="fe ki kj kk kl b">orders</code>创建一个简单的 REST API，同时展示实体到 DTO 的转换，反之亦然。</strong></p><h1 id="250a" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">理解企业架构</h1><p id="5f3a" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在大多数企业架构中，您将拥有 REST APIs。这些 API 的消费者发送一个请求，服务器用一个响应来响应。请求到响应的转换发生在 API 之后。您执行业务逻辑并修改这些对象。</p><p id="ed3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">传统上，该体系结构有三层。Web 层、业务层和数据库层。</p><p id="8eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，数据库层中的对象将与 web 层中的相同对象完全不同。数据库层中的数据库实体包含 web 层中不需要的某些字段。更重要的是，来自 web 层的任何对象都应该是用户友好的。用户不必猜测他们在处理什么。应该是不言自明的。当我展示它的实现时，这一点会更清楚。</p><h1 id="d05a" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">实体和 DTO 之间的层分离</h1><p id="b90d" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">数据传输对象(DTO)是从一层移动到另一层的对象。这些对象更加用户友好，只包含最需要的字段。</p><p id="5020" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，数据库实体表示数据库表。许多自动生成的字段可能不需要用户知道。然而，它们是数据库实体的一部分。在 DTO，我们忽略这些领域。由于这些字段是自动生成的，我们的数据库层代码可以处理这些。</p><p id="b761" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是当对象从 web 层移动到数据库层时，需要对其进行转换，以便该层使用。在下一节中，我将展示如何使用 ModelMapper 库实现从实体到 DTO 的转换。</p><h1 id="7546" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用模型映射程序将实体映射到 DTO</h1><p id="768d" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">模型映射器库提供了一种将实体对象转换为 DTO 的简单方法，反之亦然。</p><p id="166e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个演示中，我有一个客户订购商品的场景。创建该项目的订单。我们保存订单详情、客户详情和客户地址。</p><p id="0027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了能够在我们的应用程序中使用这个库，添加如下依赖项:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="426a" class="lx kn in kl b gy ly lz l ma mb">implementation 'org.modelmapper:modelmapper:2.3.0'</span></pre><p id="58ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果我们想要使用模型映射器库函数，我们将添加一个 bean，如下所示:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="d9eb" class="lx kn in kl b gy ly lz l ma mb">@Bean public ModelMapper modelMapper() <br/>{ <br/>  return new ModelMapper(); <br/>}</span></pre><p id="a2e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前，我说过客户可以订购。因此，我们将通过一个 REST API 来实现这一点，该 API 将创建订单详细信息、客户详细信息。</p><h1 id="ffd4" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">畴层</h1><p id="5b0f" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在这个架构中，我们有客户在特定地址订购的订单。</p><p id="ef7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在数据库实体图中，它将如下所示:</p><figure class="lp lq lr ls gt md gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/cea7d23bfb172498753e20bb2794b7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*c7rZG6AMs1rh8X4o"/></div></figure><p id="5684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个客户可以订购多个项目，所以多个订单。多个订单可以发送到一个地址。</p><p id="11a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的域对象将如下所示，从顺序开始:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="0b0d" class="lx kn in kl b gy ly lz l ma mb">package com.betterjavacode.modelmapperdemo.models;<br/><br/>import javax.persistence.*;<br/>import java.io.Serializable;<br/><br/>@Entity(name = "Order")<br/>@Table(name = "orders")<br/>public class Order implements Serializable<br/>{<br/>    private static final long serialVersionUID = 7385741327704693623L;<br/><br/>    public Order()<br/>    {<br/><br/>    }<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    @Column(name = "id", nullable = false)<br/>    private long id;<br/><br/>    @Column(name ="order_item")<br/>    private String orderItem;<br/><br/>    @Column(name = "description")<br/>    private String description;<br/><br/><br/>    @ManyToOne<br/>    @JoinColumn(name = "customer_id")<br/>    private Customer customer;<br/><br/><br/>    @ManyToOne<br/>    @JoinColumn(name = "address_id")<br/>    private Address address;<br/>    <br/>    // Getters and setters omitted for demo purposes<br/><br/><br/>}</span></pre><p id="e5c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">地址是:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="3104" class="lx kn in kl b gy ly lz l ma mb">package com.betterjavacode.modelmapperdemo.models;<br/><br/>import javax.persistence.*;<br/>import java.io.Serializable;<br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@Entity(name = "Address")<br/>@Table(name = "address")<br/>public class Address implements Serializable<br/>{<br/>    private static final long serialVersionUID = -439961851267007148L;<br/><br/>    public Address()<br/>    {<br/><br/>    }<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    @Column(name = "id", nullable = false)<br/>    private long id;<br/><br/>    @Column<br/>    private String street;<br/><br/>    @Column<br/>    private String city;<br/><br/>    @Column<br/>    private String state;<br/><br/>    @Column<br/>    private String country;<br/><br/>    @Column<br/>    private int zipcode;<br/><br/>    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)<br/>    private List orderList = new ArrayList&lt;&gt;();<br/><br/><br/>}</span></pre><p id="57ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户将:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="f6f1" class="lx kn in kl b gy ly lz l ma mb">package com.betterjavacode.modelmapperdemo.models;<br/><br/>import javax.persistence.*;<br/>import java.io.Serializable;<br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@Entity(name = "Customer")<br/>@Table(name = "customer")<br/>public class Customer implements Serializable<br/>{<br/>    private static final long serialVersionUID = -2205735699915701334L;<br/><br/>    public Customer()<br/>    {<br/><br/>    }<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    @Column(name = "id", nullable = false)<br/>    private long id;<br/><br/>    @Column(name = "first_name")<br/>    private String firstName;<br/><br/>    @Column(name = "last_name")<br/>    private String lastName;<br/><br/>    @Column<br/>    private String email;<br/><br/>    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)<br/>    private List orderList = new ArrayList&lt;&gt;();<br/><br/><br/>}</span></pre><p id="60c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这三个对象 order、customer 和 address 代表我们的数据库实体和数据库层的一部分。对于存储库来说，持久性的其余部分很简单。</p><h1 id="7ce6" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Web 层</h1><p id="79aa" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">Web 层主要关注我们为 API 创建的控制器。这些控制器负责接收来自客户端的请求。此外，我们将通过 API 公开的对象将是 DTO 对象。<code class="fe ki kj kk kl b">Order</code>的 DTO 对象看起来如下:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="9863" class="lx kn in kl b gy ly lz l ma mb">package com.betterjavacode.modelmapperdemo.dtos;<br/><br/>public class OrderDTO<br/>{<br/>    String orderItem;<br/>    String orderDescription;<br/>    String customerFirstName;<br/>    String customerLastName;<br/>    String customerEmail;<br/>    String streetAddress;<br/>    String cityAddress;<br/>    String stateAddress;<br/>    String countryAddress;<br/>    int zipcodeAddress;<br/><br/>   // Getters and Setters omitted for demo<br/><br/>}</span></pre><p id="1442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个 DTO 对象包括来自订单、客户和地址的字段。我们的 API 将在 POST 请求中接收该对象，我们将使用 ModelMapper 库将该 DTO 对象转换为实体对象，然后将该实体对象传递给我们的<code class="fe ki kj kk kl b">Service</code>类进行进一步处理。</p><p id="68d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">OrderController</code>将如下:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="5c8a" class="lx kn in kl b gy ly lz l ma mb">package com.betterjavacode.modelmapperdemo.controllers;<br/><br/>import com.betterjavacode.modelmapperdemo.dtos.OrderDTO;<br/>import com.betterjavacode.modelmapperdemo.models.Order;<br/>import com.betterjavacode.modelmapperdemo.service.IOrderService;<br/>import org.modelmapper.ModelMapper;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@RestController<br/>@RequestMapping("/v1/betterjavacode/orders")<br/>public class OrderController<br/>{<br/>    private static final Logger LOGGER = LoggerFactory.getLogger(OrderController.class);<br/><br/>    @Autowired<br/>    private IOrderService orderService;<br/><br/>    @Autowired<br/>    private ModelMapper modelMapper;<br/><br/>    @PostMapping<br/>    public OrderDTO createOrder(@RequestBody OrderDTO orderDTO)<br/>    {<br/>        Order order = convertToEntity(orderDTO);<br/>        Order orderCreated = orderService.createOrder(order);<br/><br/>        return convertToDTO(orderCreated);<br/>    }<br/><br/>    @GetMapping("/{customerId}")<br/>    public List getAllOrders(@PathVariable("customerId") long customerId)<br/>    {<br/>        List orderList = orderService.getAllOrdersForCustomer(customerId);<br/>        List orderDTOs = new ArrayList&lt;&gt;();<br/>        for(Order order : orderList)<br/>        {<br/>            orderDTOs.add(convertToDTO(order));<br/>        }<br/>        return orderDTOs;<br/>    }<br/><br/><br/>    private Order convertToEntity (OrderDTO orderDTO)<br/>    {<br/>        LOGGER.info("DTO Object = {} ", orderDTO);<br/><br/>        Order order = modelMapper.map(orderDTO, Order.class);<br/><br/>        return order;<br/>    }<br/><br/>    private OrderDTO convertToDTO (Order order)<br/>    {<br/>        OrderDTO orderDTO = modelMapper.map(order, OrderDTO.class);<br/>        return orderDTO;<br/>    }<br/>}</span></pre><p id="cea9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个 POST API 来创建订单，还有一个 GET API 来为客户检索订单。</p><h1 id="566e" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模型映射器库</h1><p id="71d5" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在我们的控制器中，我们使用<code class="fe ki kj kk kl b">ModelMapper</code> bean 将 DTO 对象转换为实体，将实体对象转换为 DTO。</p><p id="fc07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ModelMapper 库实际上是如何实现的呢？</p><p id="2136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当映射器调用 map 方法时，它会分析源和目标类型，以确定要匹配的属性。它使用匹配的策略和配置来映射这些属性。一旦映射了属性，它将映射数据。</p><p id="e557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们看看我们的 DTO 类，我们有类似于<code class="fe ki kj kk kl b">customerFirstName</code>、<code class="fe ki kj kk kl b">customerLastName</code>的属性匹配到<code class="fe ki kj kk kl b">Customer</code>实体对象，而类似于<code class="fe ki kj kk kl b">streetAddress</code>、<code class="fe ki kj kk kl b">cityAddress</code>的属性将匹配到<code class="fe ki kj kk kl b">Address</code>对象的属性。</p><p id="30f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您选择这样做，模型映射器还提供了一种显式映射属性的方法。</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="97c8" class="lx kn in kl b gy ly lz l ma mb">modelMapper.typeMap(Order.class, OrderDTO.class).addMappings(mapper -&gt; { mapper.map(src -&gt; src.getBillingAddress().getStreet(), Destination::setBillingStreet); </span><span id="d7d4" class="lx kn in kl b gy mg lz l ma mb">mapper.map(src -&gt; src.getBillingAddress().getCity(), Destination::setBillingCity); });</span></pre><p id="75d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该库提供三种类型的匹配策略:</p><ol class=""><li id="4d1f" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated"><strong class="jm io">标准</strong> —在该策略中，库智能地将源属性与目标属性进行匹配。该策略是默认配置的。所有目标属性名标记必须匹配。</li><li id="3fc9" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated"><strong class="jm io">松散</strong> —源和目标的属性匹配松散。如果源对象和目标对象的属性层次不相似，那么松散的策略可以起作用。最后一个目标属性名必须匹配所有标记。</li><li id="3809" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated"><strong class="jm io">严格</strong> —源属性应该与目标属性严格匹配。令牌以严格的顺序匹配。这一战略不允许有任何含糊之处。</li></ol><h1 id="3586" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用模型映射程序将实体转换为 DTO 的完整演示</h1><p id="04a2" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">我们已经展示了 REST 控制器和域对象。现在，我将展示我们如何通过传递一个 DTO 对象到 POST API 来使用 postman 调用这个 REST API。</p><p id="7fad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将为客户订购的商品创建一个订单。</p><figure class="lp lq lr ls gt md gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/9a7074eaabccb26db974254bec12fc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*ZAzTuvbwXcauRcMY"/></div></figure><p id="a526" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在请求中，我传递了一个包含订单、客户和地址信息的 DTO 对象。</p><p id="b90b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的服务层，我们处理转换后的实体对象，验证业务规则并保存这些信息以创建订单。</p><h1 id="8332" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">避免技术债务</h1><p id="3481" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">理解 DTO 和实体对象的概念是很重要的。什么时候用什么样的对象可以帮你避免技术债。从个人经验来看，我见过很多初级开发人员犯在 web 层使用实体对象的错误。根据您的应用，这可能会增加系统的复杂性。</p><h1 id="7fb3" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="e41c" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在这篇文章中，我展示了如何使用 modelmapper 库将实体转换为 DTO。你可以在这里下载模型映射器库。这个演示的代码可以在我的<a class="ae mv" href="https://github.com/yogsma/betterjavacode" rel="noopener ugc nofollow" target="_blank"> GitLab 仓库</a>中找到。如果你喜欢这篇文章，考虑在这里订阅我的博客<a class="ae mv" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="c4c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nd">原载于 2021 年 4 月 3 日 https://betterjavacode.com</em><em class="nd"/><a class="ae mv" href="https://betterjavacode.com/spring-boot/conversion-of-entity-to-dto-using-modelmapper" rel="noopener ugc nofollow" target="_blank"><em class="nd">。</em></a></p></div></div>    
</body>
</html>