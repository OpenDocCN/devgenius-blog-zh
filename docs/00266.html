<html>
<head>
<title>Building Associations in Object Oriented Ruby; Letting Common Sense Make Sense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在面向对象的Ruby中建立关联；让常识有意义</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-associations-in-object-oriented-ruby-letting-common-sense-make-sense-e7ab3d357886?source=collection_archive---------10-----------------------#2020-05-28">https://blog.devgenius.io/building-associations-in-object-oriented-ruby-letting-common-sense-make-sense-e7ab3d357886?source=collection_archive---------10-----------------------#2020-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/74ba843df272c182c0efcb677b2b04cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tVa7gQSABtUJXSTF"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">马库斯·斯皮斯克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cf21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我第一次开始学习编码时(真的不是很久以前)，我认为我真正喜欢上整个论述的一点是它的根源在于逻辑。有多少次你坐在教室里，像兔子洞一样跟着一个问题，最终以一个教授或助手说，“嗯，因为这就是它的作用。这是我们目前所知道的。”这就是编码的最大魅力所在——它的核心是有意义的。如果你正在阅读这篇文章，并且刚刚开始学习面向对象编程的所有有趣和令人兴奋的复杂性，那么你最有可能开始学习面向对象编程的语言是Ruby。</p><p id="4f36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Ruby中的面向对象编程是给编程新手的礼物，因为它仍然忠实于OOP的核心原则，即它的对象和关系应该反映现实世界中的关系。也就是说有一个独特的物体叫做椅子，有独特的东西叫做人。一个是木头做的，一个现在正坐在这里看这个。但是，通过称为食物的不同对象，一个人与一把椅子相关联，这是他们吃饭时坐的座位。餐点连接着椅子和人。能够认识到日常生活中存在的关联，并能够在Ruby中表现出来，对于崭露头角的开发人员来说是一个强大的工具，我们将探讨其中的原因。</p><p id="14e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设你是一个狂热的读者。作为一个狂热的读者，(我自己就是一个)你不能像你希望的那样经常去健身房，你也厌倦了旅行时背着装满书的背包。所以你坐下来，决定开发一个应用程序来数字化你的收藏。但是很快你会更进一步。让我们完全去掉中间人，允许作者实例将图书直接发布到应用程序，读者获得这些图书对象。一开始你保持简单。这个应用程序只知道三件事:一个读者，一个作者，和一本书。</p><p id="acb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你决定一个读者，不欠任何人任何信息。它们只是用来读取的，因此，您只需用用户名初始化一个Reader实例。</p><p id="b935" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后处理一个author类，在这个author类中，您决定每个Author实例绝对需要的是一个名称，您可以通过这个名称来识别它们，以及它们有多老。</p><p id="a13d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，创建一个Book类。这个Book类实际上应该充当作者用户和读者用户之间的连接模型，所以我们应该初始化一本书的所有属性(比如流派、isbn和标题)，以及指定的作者和读者。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/f2459dfa43a08ef425e6014774a29d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kczoPRmRnHNg1j0vzvDnbw.png"/></div></div></figure><p id="3cc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，您可以看到一本书的每一个实例(让我们把它想象成每本书的每一个副本)现在都能够与一个读者和一个作者相关联。我们该如何联想？</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/5e18687259a98b93e0b5ce3f1dbe75e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqxCvqYJVgyqE2p6OFSrBQ.png"/></div></div></figure><p id="39bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们创建了一些作者的实例，一个读者的实例(就是我！)，以及我们图书馆的几本书。您应该马上注意到，我们没有将Author和Reader的属性与其名称的字符串值相关联，而是将它们直接链接到它们所在的特定类的实例。这将允许我们做一些非常有用的数据检索。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/4c29326eebb06bc148488a311306ccaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rni91-085oTBWZVeyEI_Pg.png"/></div></div></figure><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/0f17dcbb768d4adf44da77683d40632b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjB08NI29Jq_se1iokVW6Q.png"/></div></div></figure><p id="3019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们在Author类和Reader类中创建了一些方法。现在，我们的作者与我们的书直接相关，我们已经包含了允许我们的作者知道哪些书属于他们的代码，我们可以从作者那里访问关于书的信息，并通过作者的书访问作者的读者，反之亦然。</p><p id="5868" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当我们进入环境测试代码时:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/f11c3ed1cd8b1f38d3f41b8306b526d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTdcKHrsntF_tJRGd2LpLA.png"/></div></div></figure><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/5aff62804e408fb3ad44ef86d98057f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d30GxKgiBGQ0YlS3ufWDJQ.png"/></div></div></figure><p id="d031" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇，现在我们的朋友斯蒂芬·金知道有两个人读了新的闪亮重启，不错。我可以知道我图书馆里所有的作者。通过Ruby中面向对象允许我们进行的所有关联。</p></div></div>    
</body>
</html>