<html>
<head>
<title>What Is the Difference Between target and currentTarget?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">target 和 currentTarget 有什么区别？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-the-difference-between-target-and-currenttarget-2f91ca2ad7d8?source=collection_archive---------2-----------------------#2022-07-28">https://blog.devgenius.io/what-is-the-difference-between-target-and-currenttarget-2f91ca2ad7d8?source=collection_archive---------2-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff01" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么不能在 React 的异步处理程序中访问 currentTarget？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28a817f7ef80ae207c9b72543bfbdbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DWa3O9ZgpseEHH3U"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@silvanarnet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Silvan Arnet </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="afc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Event.target</code>和<code class="fe ls lt lu lv b">Event.currentTarget</code>是<a class="ae kv" href="https://www.w3.org/TR/DOM-Level-2/events.html#Events-interface" rel="noopener ugc nofollow" target="_blank"> DOM 事件接口</a>上的属性。简单来说，它们之间的区别在于:</p><p id="6da0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Event.currentTarget</code>是事件附加到的元素。永远不会变。</p><p id="237d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Event.target</code>是触发事件的元素。这取决于用户点击的确切位置。</p><p id="a1e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先用一个模态来演示他们的用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的演示。当你点击模态内部的时候，你可以看到<code class="fe ls lt lu lv b">currentTarget</code>指向覆盖图而<code class="fe ls lt lu lv b">target</code>指向模态。这也印证了我上面说的。</p><p id="d940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当你这样做的时候，你会发现它关闭了，这不是我们所期望的。那么有两种解决方案:</p><ul class=""><li id="a909" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">将事件绑定到模式，以防止事件冒泡到父元素。代码是这样的:</li></ul><pre class="kg kh ki kj gt mh lv mi mj aw mk bi"><span id="6164" class="ml mm iq lv b gy mn mo l mp mq">modal.addEventListener('click', (event) =&gt; {<br/>  event.stopPropagation();<br/>});</span></pre><ul class=""><li id="9d24" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">在<code class="fe ls lt lu lv b">overlay</code>附带的事件中，检查<code class="fe ls lt lu lv b">currentTarget</code>和<code class="fe ls lt lu lv b">target</code>是否相同。如果它们相同，就证明用户点击了覆盖区域，而不是模态内部。</li></ul><pre class="kg kh ki kj gt mh lv mi mj aw mk bi"><span id="1cec" class="ml mm iq lv b gy mn mo l mp mq">overlay.addEventListener('click', (event) =&gt; {<br/>  if (event.currentTarget === event.target) {<br/>    console.log('Close the modal');<br/>    overlay.style.display = 'none';<br/>  }<br/>});</span></pre><p id="158b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是集成的代码，您可以取消对它的注释来验证:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过上面的例子，相信你已经明白了。<code class="fe ls lt lu lv b">target</code>多用于事件委托。例如，如果您有大量需要绑定事件的子元素，那么您可以在其父元素上只绑定一个事件，并在子元素触发时使用<code class="fe ls lt lu lv b">target</code>来标识子元素。这提高了应用程序的性能。</p><p id="0919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React 中也使用了事件委托机制，在版本 17 之前，React 采用了事件池。这意味着所有的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">SyntheticEvent</a></code>对象被汇集，也就是说，将被重用，并且在事件处理程序被调用后，它们的所有属性都将失效。所以如果想在异步处理程序中获取事件对象的属性，就需要使用<code class="fe ls lt lu lv b">e.persist()</code>。</p><p id="e54d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">17 及以后版本去掉了事件池机制，不需要调用<code class="fe ls lt lu lv b">e.persist()</code>就可以在异步处理程序中获取事件对象的属性。</p><p id="05fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">currentTarget</code>的值只有在处理事件时才可用。当被访问时，代码的执行被暂停，并返回<code class="fe ls lt lu lv b">currentTarget</code>的值。</p><p id="6918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你直接打印<code class="fe ls lt lu lv b">event</code>，你会发现<code class="fe ls lt lu lv b">currentTarget</code>属性是<code class="fe ls lt lu lv b">null</code>，或者如果你想在一个异步函数中访问它，你会得到<code class="fe ls lt lu lv b">null</code>。注意，这与使用 React 与否无关。</p><p id="b9e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请参见下面的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr lx l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="f349" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mz">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="mz">中会员</em> </a> <em class="mz">。每月 5 美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="mz">我的链接</em> </a> <em class="mz">报名，我会得到一点佣金。</em></p><p id="116a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mz">你的支持对我来说非常重要——谢谢你。</em></p></div></div>    
</body>
</html>