<html>
<head>
<title>What Does The .git Folder do?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是什么？git 文件夹呢？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unraveling-the-mysteries-of-the-git-folder-d47b55071aa5?source=collection_archive---------24-----------------------#2022-12-14">https://blog.devgenius.io/unraveling-the-mysteries-of-the-git-folder-d47b55071aa5?source=collection_archive---------24-----------------------#2022-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e8f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每个由<strong class="jm io"> Git、</strong>监控的项目文件夹中，你会看到一个名为<code class="fe ki kj kk kl b">.git</code>的隐藏文件夹。这个文件夹是在 Git 初始化期间创建的(当您使用<code class="fe ki kj kk kl b">git init</code>命令时)。</p><p id="d324" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有没有想过这个文件夹为你做了什么？</p><p id="8142" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果答案是肯定的，那么你来对地方了，如果不是，那么你又来对地方了，因为，在这两种情况下，你可能会在阅读这篇文章时发现一些有趣的东西！或者至少这是我的希望。😜</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/33a60d146b42f629015a0b77f42b0eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lwm5bIuhTqtBsXyn"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇·🇺🇦</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="8037" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">使用的技术</h2><ul class=""><li id="7a4f" class="lw lx in jm b jn ly jr lz jv ma jz mb kd mc kh md me mf mg bi translated">Git 2 . 34 . 1</li></ul><h2 id="6345" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">使用的环境</h2><p id="c3e6" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Linux Ubuntu 22.04.1 LTS</p><p id="e440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">如果你像我一样在 Unix 系统中，要看到</em> <code class="fe ki kj kk kl b">.git</code> <em class="mk">文件夹，你需要做如下事情:</em></p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="898f" class="mp le in kl b be mq mr l ms mt">ls -a</span></pre><p id="31c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️<strong class="jm io">-一个</strong> <em class="mk">标志是对</em> <strong class="jm io"> <em class="mk"> —所有</em> </strong> <em class="mk">的排序，基本意思是列出所有文件(也包括隐藏的)。</em></p><p id="9812" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入<code class="fe ki kj kk kl b">.git</code>文件夹时，您会看到以下文件/子文件夹:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="c7e6" class="mp le in kl b be mq mr l mu mt">root <br/>└─.git<br/>  ├─📁 branches<br/>  ├─📄 config<br/>  ├─📄 description<br/>  ├─📄 HEAD<br/>  ├─📁 hooks<br/>  ├─📁 info<br/>  ├─📁 objects<br/>  └─📁 refs</span></pre><p id="af66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，这个文件夹的结构或者它的子目录可能与你项目中的不同。这是因为一些文件/文件夹是在初始化之后创建的，这取决于 git 的行为。此外，我分析文件夹内容的顺序不同于上面项目树中显示的顺序。这是因为在研究其他内容之前，我们需要了解一些内容的工作方式。如果有帮助的话，可以把它们当作必备知识。</p><p id="df54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说够了，让我们潜进去，看看发生了什么事。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5164f63016dd677e71e36cd4dc967f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*QJM1DiPc31UK10HbNlpCcw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">资料来源:<a class="ae lc" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">吉菲</a></figcaption></figure><div class="mw mx gp gr my mz"><a href="https://medium.com/@georgelinardis/membership" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">通过我的推荐链接加入媒体-乔治·里纳尔迪斯</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">阅读乔治·里纳尔迪斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kw mz"/></div></div></a></div><p id="aa3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过支付您的会员费，您将不仅支持我，也支持 Medium 上的其他作者，支持我们继续为您制作有价值的内容。</p><h1 id="70df" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📁分支</h1><p id="55ce" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">正如在<a class="ae lc" href="https://git-scm.com/docs/gitrepository-layout" rel="noopener ugc nofollow" target="_blank"> git 文档</a> <strong class="jm io">分支</strong>文件夹中提到的，是一个不推荐使用的机制，它可能不存在于您项目的 git 文件夹中。2009 年，当使用<code class="fe ki kj kk kl b">git init</code>时，Git 停止创建这个文件夹。过了一会儿，虽然那个提交(删除创建的<strong class="jm io">分支</strong>文件夹)被恢复，并且<strong class="jm io">分支</strong>再次被包含进来。初始化时 git 子文件夹。</p><h1 id="10bd" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📄描述</h1><p id="290d" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io">描述</strong>文件包含了您的存储库的描述。多。😏但是如果你打开这个文件，你会看到什么呢？</p><p id="41a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，其内容为:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="724e" class="mp le in kl b be mq mr l ms mt">Unnamed repository; edit this file ‘description’ to name the repository.</span></pre><p id="6583" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该文件主要由<a class="ae lc" href="https://git-scm.com/book/en/v2/Git-on-the-Server-GitWeb" rel="noopener ugc nofollow" target="_blank"> GitWeb </a>程序使用，该程序是一个<br/> Git Web 接口。要查看 GitWeb 的运行情况，只需在您的终端中键入:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="3feb" class="mp le in kl b be mq mr l ms mt">git instaweb --httpd=webrick</span></pre><p id="c066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️ <code class="fe ki kj kk kl b"><em class="mk">git instaweb</em></code> <em class="mk">可能需要不同的</em> <code class="fe ki kj kk kl b"><em class="mk">http</em></code> <em class="mk">守护进程，这取决于您的操作系统。我用的是 Linux Ubuntu。</em></p><p id="9cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行此命令将在您的系统上创建/配置一个 web 服务器，并打开您的浏览器，以便您可以查看您的存储库的信息。当我运行它时，我得到了这样的结果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/9b26277a40ef42f35fc74bbea49d583c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqODymDpJkkKZdkdzHBiNQ.png"/></div></div></figure><p id="25ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很酷吧？这就像为存储库的内容生成一个 UI。😎</p><h1 id="69cb" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📁信息</h1><p id="c997" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">对于初学者来说，在<strong class="jm io">信息</strong>文件夹中，只有一个名为<strong class="jm io">的文件，不包括</strong>。</p><p id="bcdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">排除</strong>文件是您可以添加规则的地方，以文件模式的形式，这样您就可以<strong class="jm io">忽略项目中的</strong>特定文件。</p><p id="d412" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等…如果这就是我们使用<strong class="jm io">排除</strong>的方式，那么与<strong class="jm io">有什么区别。gitignore </strong>文件？</p><p id="89a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好问题，让我们看看有什么不同:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/935ead903b3226a7c3a53750e3260715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*E7JwdZ5yd__6rPKGVhMQLA.png"/></div></figure><p id="33fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以把<strong class="jm io">排除</strong>看作本地私有<strong class="jm io">。gitignore </strong>文件，该文件可以存储您个人的关于文件排除的项目选项，而不会与其他任何人共享。但是优先级呢？哪个先来？</p><p id="c35b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于<a class="ae lc" href="https://git-scm.com/docs/gitignore" rel="noopener ugc nofollow" target="_blank"> git 文档</a>，优先顺序为:<br/> 1。命令行<br/> 2。<strong class="jm io">。git ignore</strong>T43】3。<strong class="jm io">排除</strong> <br/> 4。配置变量<code class="fe ki kj kk kl b">core.excludesFile</code></p><h1 id="e099" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📁钩住</h1><p id="0583" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">hooks 文件夹，如果它的名字还不明显的话，包含了你的项目使用的所有<br/> Git 钩子。</p><p id="d79d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️ <strong class="jm io"> <em class="mk">钩子</em> </strong> <em class="mk">是一种机制、函数的通用术语，它通过在事件之前或之后被调用来拦截该事件。</em></p><p id="207a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么钩子和 Git 有什么关系呢？</p><p id="161c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">钩子和<strong class="jm io"> config </strong>文件被认为是 Git 提供的在项目级定制其行为的方式。</p><p id="e5a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个项目中，你可能会看到自己重复一些工作流程。其中之一可能是在推送或部署代码更改之前检查控制台日志。尽管他们中的一些人总能找到办法逃过我们的检查，对吗？🤭另一种情况可能是偶然将那个分支合并到 master 并推动它活过来。勾起了谁的回忆？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ef9c9bcdba3d51cdbb35ad593d20e7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*qGPs832lwFAZL-FcW6Oq4w.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">资料来源:<a class="ae lc" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><p id="6780" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他例子包括:</p><ul class=""><li id="ed47" class="lw lx in jm b jn jo jr js jv oi jz oj kd ok kh md me mf mg bi translated">在提交或推送之前，在代码中应用 eslint 检查。</li><li id="78f6" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">提交前检查提交消息中的拼写错误。</li><li id="5ca1" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">在提交消息中自动添加任务 ID 前缀。</li></ul><p id="1de6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于任何一种情况，你都可以添加一个 Git 钩子，在特定事件之前或之后运行，比如在提交之前，它可以为你自动检查。</p><h1 id="7fac" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📄配置</h1><p id="67fb" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">这是 git 用来检查存储库配置的文件。如果您运行了以下一些命令，您可能已经看到应用了一些设置:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="1b7d" class="mp le in kl b be mq mr l ms mt">git config user.name “&lt;your name here&gt;”<br/>git config user.email &lt;your email here&gt;<br/>git config core.editor &lt;preferred editor&gt;</span></pre><p id="a490" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您以前没有使用过这些命令，也没关系。前两个命令将您的姓名和电子邮件应用于项目的存储库设置，而第三个命令将特定的编辑器设置为查看文件的默认编辑器。这些更改将反映在项目的配置文件中。例如，如果您运行这些命令，然后打开配置文件，您可能会看到如下内容:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="3703" class="mp le in kl b be mq mr l ms mt">[core]<br/> editor = vim<br/>[user]<br/> name = John Doe<br/> email = someone@example.com</span></pre><p id="6804" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这基本上是我们设置的记录。🤓<br/>还有比这里提到的更多的配置选项，如果你想了解更多，请访问<a class="ae lc" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" rel="noopener ugc nofollow" target="_blank"> git 配置文档</a>。</p><h1 id="5e67" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📄头</h1><p id="b460" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">这是 git 用来动态记录项目的<strong class="jm io">头</strong>名的文件。</p><p id="9a48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️ <em class="mk">头上的 git</em><strong class="jm io"><em class="mk"/></strong><em class="mk">是一个指针。一个指针，它指向您的活动分支的</em> <strong class="jm io"> <em class="mk">最新</em> </strong> <em class="mk">提交或提交散列(以防您已经签出并处于</em> <strong class="jm io"> <em class="mk">分离的</em> </strong> <em class="mk">头状态)。</em></p><p id="a3e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看<strong class="jm io">头</strong>文件的运行情况。我已经创建了一个空文件夹，它是使用 git 通过键入以下命令初始化的:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="0ace" class="mp le in kl b be mq mr l ms mt">git init</span></pre><p id="9ee0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认的 git 分支是<code class="fe ki kj kk kl b">main</code>分支。因此，如果我尝试通过键入以下内容来读取<code class="fe ki kj kk kl b">HEAD</code>文件:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="1a96" class="mp le in kl b be mq mr l ms mt">cat .git/HEAD</span></pre><p id="6799" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️<em class="mk"/><strong class="jm io"><em class="mk">猫</em> </strong> <em class="mk">命令用来显示一个文件的内容。</em></p><p id="0ac1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我得到以下回答:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="277e" class="mp le in kl b be mq mr l ms mt">ref: refs/heads/main</span></pre><p id="a285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个内容基本上说的是我们项目的<strong class="jm io">头</strong>是<code class="fe ki kj kk kl b">main</code>分支的最后一个提交。这就是为什么这个引用，<code class="fe ki kj kk kl b">refs/heads/main</code>也被称为分支引用。<strong class="jm io"> </strong> <br/> <em class="mk">(我们将在下一节更详细地讨论 refs 文件夹)。</em></p><p id="19f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过键入来切换到另一个分支</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="6dd7" class="mp le in kl b be mq mr l ms mt">git checkout -b playground</span></pre><p id="fe2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">切换到新的分支后，如果我现在再次阅读<code class="fe ki kj kk kl b">HEAD</code>的内容，它将显示一个不同的参考:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="7092" class="mp le in kl b be mq mr l ms mt">ref: refs/heads/playground</span></pre><p id="f0ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看到了吗？它只是记录你的项目的当前头。但是我们的小侦探🕵在上面几行提到的超脱的头部状态呢？让我们看看，我将在我的项目中添加一个简单的标记为<code class="fe ki kj kk kl b">some random change</code>的提交消息，并按<code class="fe ki kj kk kl b">git logs</code>查看它的提交散列:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="48b7" class="mp le in kl b be mq mr l ms mt">commit d31d7b141c9a27f71c13eab90b8943ae126b8f74 (HEAD -&gt; playground)<br/>Author: GeorgeLinardis<br/>Date:   Mon Dec 14 19:58:32 2022 +0200</span></pre><pre class="oq ml kl or os aw ot bi"><span id="7f97" class="ld le in kl b gy ou ov l mu mt">  some random change</span></pre><p id="732a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，现在我们有了提交的散列，让我们通过键入:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="fef8" class="mp le in kl b be mq mr l mu mt">git checkout d31d7b141c9a27f71c13eab90b8943ae126b8f74</span></pre><p id="eae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经使用提交的散列检查过了，我们处于<strong class="jm io">分离</strong>头<strong class="jm io">头</strong>状态。如果我们尝试查看我们头的文件内容，它会显示:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="a369" class="mp le in kl b be mq mr l mu mt">d31d7b141c9a27f71c13eab90b8943ae126b8f74</span></pre><p id="2e92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这实际上是我们使用的哈希。这很有道理，对吗？毕竟，如果这个文件记录了当前使用的文件头，并且我们使用散列而不是分支进行了检查，那么它应该准确地记录下来。</p><p id="ee42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">如果你正在阅读这篇文章，并且你也跟着读，记住，要从脱离状态回到你的分支，只需键入</em> <code class="fe ki kj kk kl b"><em class="mk">git checkout &lt;branch_name&gt;</em></code></p><h1 id="1fd7" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📁参考文献</h1><p id="d0b4" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Refs 是<strong class="jm io">引用</strong>的简写，是 git 引用提交散列的另一种方式。git 将通过类似于<code class="fe ki kj kk kl b">refs/heads/main.</code>的方式引用提交的散列，而不是提及提交的散列</p><p id="576c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵️<em class="mk">a</em><strong class="jm io"><em class="mk">hash</em></strong><em class="mk">是由一些输入数据生成的值。Git 使用 SHA-1 散列类型为其对象创建唯一标识符。</em><strong class="jm io"><em class="mk"/></strong><em class="mk">SHA-1 代表安全散列算法，基本上是一个函数。一种加密功能，接受输入并生成一个摘要，即哈希摘要，简单来说，它是一个基于所用内容的 40 位唯一字母数字消息。如果你想和 SHA-1 玩在线游戏，试试这个</em> <a class="ae lc" href="https://codebeautify.org/sha1-hash-generator" rel="noopener ugc nofollow" target="_blank"> <em class="mk">游乐场</em> </a> <em class="mk">。</em></p><p id="d8ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考文件</strong>文件夹包含以下文件/文件夹:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="a820" class="mp le in kl b be mq mr l ms mt">refs<br/> ├─📁 heads<br/> ├─📁 remotes<br/> ├─📁 tags<br/> └─📄 stash</span></pre><h2 id="d51f" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">头</h2><p id="72a2" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">它包含您所有的本地分支机构。Git 为创建的每个分支创建一个新文件，并使用分支的名称命名该文件。</p><p id="dc4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有两个分支，一个名为<strong class="jm io">主菜单</strong>，一个名为<strong class="jm io">导航栏菜单</strong>。(<em class="mk">导航栏菜单是从主菜单创建的一个分支)</em></p><p id="577e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着在<strong class="jm io"> heads </strong>文件夹中，您应该会看到以下两个文件:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="67ca" class="mp le in kl b be mq mr l ms mt">heads<br/>  ├─📄 main<br/>  └─📄 navbar-menu</span></pre><p id="65ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个文件将包含各自的<strong class="jm io">头</strong>提交散列。因此，如果我们要查看每个文件服务器的内容，我们会看到:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="6216" class="mp le in kl b be mq mr l mu mt">// inside the heads/main file<br/>ed37f2bdba2b9c062b1147226cb384619d4a0133</span></pre><pre class="oq ml kl or os aw ot bi"><span id="d0ad" class="ld le in kl b gy ou ov l mu mt">// inside the heads/playground file<br/>d31d7b141c9a27f71c13eab90b8943ae126b8f74</span></pre><p id="9fe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了仔细检查我们的发现，我们可以检查每个分支的日志历史:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="b18a" class="mp le in kl b be mq mr l mu mt">// main branch history<br/>commit ed37f2bdba2b9c062b1147226cb384619d4a0133 (HEAD -&gt; main)<br/>Author: GeorgeLinardis<br/>Date:   Mon Dec 14 20:57:57 2022 +0200<br/><br/>  init</span></pre><pre class="oq ml kl or os aw ot bi"><span id="a073" class="ld le in kl b gy ou ov l mu mt">// playground branch history<br/>commit d31d7b141c9a27f71c13eab90b8943ae126b8f74 (HEAD -&gt; playground)<br/>Author: GeorgeLinardis<br/>Date:   Mon Dec 14 20:58:32 2022 +0200</span><span id="a6d2" class="ld le in kl b gy ow ov l mu mt">    some random change</span><span id="c409" class="ld le in kl b gy ow ov l mu mt">commit ed37f2bdba2b9c062b1147226cb384619d4a0133 (main)<br/>Author: GeorgeLinardis<br/>Date:   Mon Dec 14 20:57:57 2022 +0200</span><span id="0440" class="ld le in kl b gy ow ov l mu mt">    init</span></pre><p id="b3da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，显示为<code class="fe ki kj kk kl b">HEAD -&gt; &lt;branch&gt;</code>的散列是包含在<strong class="jm io">头</strong>内的相应文件中的散列。开始感觉好像我们看到了指针，不是吗？</p><h2 id="da2c" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">隐藏物</h2><p id="3af7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">如果你以前没有使用过<strong class="jm io"> stash </strong>命令，最好查看 git 的<a class="ae lc" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank"> stash docs </a>来了解更多，这是一个非常有用的命令。</p><p id="1fcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵 <strong class="jm io"> <em class="mk"> stash </em> </strong> <em class="mk">当我们想要移除应用到我们的分支</em> <strong class="jm io"> <em class="mk">的任何变更时使用，但是</em> </strong> <em class="mk">同时保存那些变更以备后用</em>。</p><p id="e591" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的项目中，我在<strong class="jm io"> refs </strong>文件夹中没有 stash 文件，所以如果没有也不用担心。要查看 git 自动创建的<strong class="jm io"> stash </strong>文件，我们需要遵循以下步骤:</p><ol class=""><li id="7865" class="lw lx in jm b jn jo jr js jv oi jz oj kd ok kh ox me mf mg bi translated">修改文件的内容</li><li id="e15f" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh ox me mf mg bi translated">类型<code class="fe ki kj kk kl b">git stash</code></li></ol><p id="c24d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行 stash 命令后，您将看到它的文件变得栩栩如生。查看它的内容，您会看到一个散列，例如，我看到下面这个:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="1f12" class="mp le in kl b be mq mr l mu mt">e446267da6ae4d783e30dd5ce411fba5f4c12453</span></pre><p id="f33c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是从我之前查看日志的历史来看，我在任何地方都没有看到这个散列。那么它来自哪里呢？您可能已经猜到了，它代表了存储时存储的更改。</p><p id="319e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，但是我们能用它做什么呢？使用它们的一种方法是查看项目的当前状态和保存的存储更改之间的差异。这可以通过做类似于<code class="fe ki kj kk kl b">git diff &lt;stash hash&gt;</code>的事情来实现。酷吧？</p><p id="aeec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他两个子文件夹的<strong class="jm io">遥控器</strong>和<strong class="jm io">标签</strong>遵循相同的逻辑。它们包含对远程分支和标记的引用。</p><h1 id="8e47" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">📁目标</h1><p id="ebe7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Git 的核心是需要一种方法来存储恢复项目版本所需的所有必要信息，跟踪它的历史和任何已经做出的更改。为此，它使用许多数据结构和算法来有效地存储和管理版本控制信息。<br/>保存所有相关信息的地方是<strong class="jm io">对象</strong>文件夹，也称为<strong class="jm io">对象库</strong>。</p><p id="befc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是它是怎么做到的呢？这是否意味着如果你进入<strong class="jm io"> objects </strong>文件夹，你将会看到你的项目文件的不同版本？</p><p id="6dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯……是的，但不是你期望的方式(如果我没猜错的话)。</p><p id="f63f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Git 使用以下 4 种数据结构来保存信息:</p><ul class=""><li id="db7e" class="lw lx in jm b jn jo jr js jv oi jz oj kd ok kh md me mf mg bi translated"><strong class="jm io">斑点</strong></li><li id="c0cd" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated"><strong class="jm io">树木</strong></li><li id="da5d" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated"><strong class="jm io">提交</strong></li><li id="ef08" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated"><strong class="jm io">标签</strong></li></ul><h2 id="e425" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">一滴</h2><p id="78b8" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">对于文件的每个不同版本，文件的内容都保存为 blob。</p><p id="9187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵<em class="mk">a</em><strong class="jm io"><em class="mk">blob</em></strong><em class="mk">—</em><strong class="jm io"><em class="mk">a b</em></strong><em class="mk">inary</em><strong class="jm io"><em class="mk">l</em></strong><em class="mk">arge</em><strong class="jm io"><em class="mk">ob</em></strong><em class="mk">object—是一个大块，一段二进制数据。</em></p><h2 id="b78d" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">树</h2><p id="8560" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">树相当于目录。一棵树可以包括其他树和 blobs，或者换句话说，目录和文件。</p><h2 id="807d" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">承诺</h2><p id="03d4" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">每当我们使用<code class="fe ki kj kk kl b">git commit</code>命令时，就会创建一个提交对象，它包含以下关于每次提交的信息:</p><ul class=""><li id="2c1f" class="lw lx in jm b jn jo jr js jv oi jz oj kd ok kh md me mf mg bi translated">树的散列(<em class="mk">标识树对象的散列，文件夹结构</em></li><li id="8b37" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">父散列<em class="mk">(代表父分支顶端的散列)</em></li><li id="e2c1" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">作者信息</li><li id="622f" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">委托人信息</li><li id="21aa" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated">提交消息</li></ul><h2 id="1357" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">标签</h2><p id="6d82" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">标签是一种用户友好、人类可读的保存对象信息的方式。</p><p id="f2e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，让我们开始整合所有这些新信息:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/8fb7dfccb24507e9661e8af97479a054.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*D1PiCt9inwoJukLgDBjVig.gif"/></div></figure><p id="2fbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从另一个空的项目文件夹开始，在其中我们将通过键入<code class="fe ki kj kk kl b">git init</code>来初始化 git。首先，我们看到在我们的<strong class="jm io"> objects </strong>文件夹中没有文件。让我们通过键入<code class="fe ki kj kk kl b">touch README.md</code>创建一个空的<code class="fe ki kj kk kl b">README.md</code>文件。</p><p id="3c43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使存储库中还没有文件，也没关系！现在，我将为新的空<code class="fe ki kj kk kl b">README.md</code>文件添加一条提交消息，消息为“<em class="mk">添加 README.md 文件</em>”。当我这样做时，我看到在<strong class="jm io">的<strong class="jm io">对象</strong>文件夹中创建了三个新文件夹。git </strong>目录。git 使用这些文件夹来存储新提交的数据，包括<code class="fe ki kj kk kl b">README.md</code>文件的内容和提交元数据。这三个文件夹是:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="5d15" class="mp le in kl b be mq mr l ms mt">objects<br/> ├─📁 e0<br/> ├─📁 e6<br/> └─📁 f9</span></pre><p id="cc66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我键入<code class="fe ki kj kk kl b">git log</code>，我会看到一个包含以下信息的提交:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="5b3b" class="mp le in kl b be mq mr l ms mt">commit e0adef4693b25c2b2ab58b690f60ef70d8d51e44 (HEAD -&gt; main)<br/>Author: GeorgeLinardis<br/>Date:   Wed Dec 14 18:11:27 2022 +0200<br/><br/>    Adding README.md file</span></pre><p id="f684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个提交的散列被分成两部分</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/bf773e1d6ad78eb82667aca7af133eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*tO_LXHd8mZo9S48HnsnZtQ.png"/></div></figure><p id="d46b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">hash 的前两位用作文件夹名，剩下的 38 位用作<code class="fe ki kj kk kl b">e0</code>文件夹内的文件名。但是因为我们只有一个提交，其他两个文件夹代表什么呢？嗯，为了定义我们项目的状态，我们需要三条信息:一个<strong class="jm io">提交</strong>，一个<strong class="jm io">树</strong>，以及一个<strong class="jm io">斑点</strong>。这三个文件夹恰恰代表了这一点。我们可以使用以下命令查看每个文件的类型:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="8563" class="mp le in kl b be mq mr l ms mt">git cat-file -t &lt;hash&gt;</span></pre><p id="532f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<code class="fe ki kj kk kl b">&lt;hash&gt;</code>是我们想要检查的文件的哈希值。通过这样做，我们将看到每个文件都有以下类型:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="57ef" class="mp le in kl b be mq mr l ms mt">objects<br/> ├─📁 e0<br/> |  └─📄 adef4693b25c2b2ab58b690f60ef70d8d51e44 (commit)<br/> ├─📁 e6<br/> |  └─📄 9de29bb2d1d6434b8b29ae775ad8c2e48c5391 (blob)<br/> └─📁 f9<br/>    └─📄 3e3a1a1525fb5b91020da86e44810c87a2d7bc (tree)</span></pre><p id="206c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道你在想什么。那么每个文件里面都有什么呢？</p><h2 id="3b0a" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">犯罪</h2><p id="6ad2" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">为了查看标记为<code class="fe ki kj kk kl b">adef4...</code>的提交文件内部，我们将使用<code class="fe ki kj kk kl b">cat-file</code>命令，更具体地说是<code class="fe ki kj kk kl b">git cat-file -p &lt;hash&gt;</code>。</p><p id="19a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵 <code class="fe ki kj kk kl b">git <em class="mk">cat-file</em></code> <em class="mk">用于查看 git 对象内容。</em> <code class="fe ki kj kk kl b"><em class="mk">-p</em></code> <em class="mk">为蛮印。</em> <code class="fe ki kj kk kl b"><em class="mk">-t</em></code> <em class="mk">也可以用来查看对象的类型</em></p><p id="4239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过检查第一个文件的提交对象信息，我得到了以下内容:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="9540" class="mp le in kl b be mq mr l mu mt">tree f93e3a1a1525fb5b91020da86e44810c87a2d7bc<br/>author GeorgeLinardis 1671034287 +0200<br/>committer GeorgeLinardis 1671034287 +0200<br/><br/>Adding README.md file</span></pre><p id="32fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🕵 <em class="mk">你在我的提交信息中看到的 1671032375 是以 epoch UNIX 时间戳格式显示的时间。换句话说，是时间，以通用的方式写成，从 UTC 的 1970 年 1 月 1 日开始计时。(+0200 是我的时区)。</em></p><p id="b534" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等，在这个文件的内容中提到的树的散列和在第三个文件中使用的是一样的，对吗？你预料到了吗？是吗？哦，不过还是很酷！🤩</p><h2 id="cdb4" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">树</h2><p id="4f7a" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">通过执行相同的命令，我看到在树对象内部得到了以下内容:</p><pre class="kn ko kp kq gt ml kl mm bn mn mo bi"><span id="1174" class="mp le in kl b be mq mr l mu mt">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    README.md</span></pre><p id="230d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，那这意味着什么？这是项目文件夹在特定时间点的快照。它包含项目的结构，并引用 blob 对象(文件)和该快照上存在的其他树。</p><p id="146d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它基本上说的是 ID 为<code class="fe ki kj kk kl b">e69de29bb2d1d…</code>的对象是一个正则类型的 blob ( <em class="mk">一个文件</em>)(<code class="fe ki kj kk kl b"><em class="mk">100644</em></code><em class="mk">表示正则类型，而</em> <code class="fe ki kj kk kl b"><em class="mk">100755</em></code> <em class="mk">表示名为<code class="fe ki kj kk kl b">README.md</code>的可执行文件</em>。</p><h2 id="c118" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">一滴</h2><p id="f9e5" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">现在有趣的部分，让我们看看 blob 文件包含什么。和其他情况一样，通过输入<code class="fe ki kj kk kl b">git cat-file -p e69de2...</code>，我得到一个空的内容。🤔</p><p id="fed2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是啊。有道理对吗？毕竟我们提交 README.md 文件时它是空的。通过添加新文件，我们将看到我们的<code class="fe ki kj kk kl b">object</code>子文件夹基于我们项目中在那个时间点包含的文件而增加。</p><p id="5f65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以你有它！<strong class="jm io">。git </strong>文件夹就像是你的 git 库的心脏和灵魂，它装满了让 Git 成为如此强大的工具的所有好东西。这看起来像是一个拥有奇怪超能力的秘密巢穴，但我希望在读完这篇文章后，我们可以澄清它的一些能力，并在这个过程中变得更加明智。</p><p id="7e16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这篇文章，我发现探索<strong class="jm io">的内部运作。git </strong>文件夹可能是一个具有挑战性的话题，即使对于像我这样的初学者来说也是如此。尽管困难重重，但我发现深入研究这个话题并更好地理解如何做很有意思。git 在引擎盖下工作。有时这有点令人头痛🤕，但我认为这种努力是值得的。🥳</p><h1 id="f6c9" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">进一步阅读</h1><p id="8322" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">在写这篇文章并试图理解<code class="fe ki kj kk kl b">.git</code>文件夹是如何工作的时候，我发现了一些非常棒的文章，我想分享给你，以防你感到好奇并想深入了解:</p><ul class=""><li id="82c2" class="lw lx in jm b jn jo jr js jv oi jz oj kd ok kh md me mf mg bi translated">Tobias Günther 在 StackOverflow 上发表的《引擎盖下的一瞥:Git 中的分支是如何工作的》。</li><li id="51be" class="lw lx in jm b jn ol jr om jv on jz oo kd op kh md me mf mg bi translated"><a class="ae lc" href="https://www.freecodecamp.org/news/git-internals-objects-branches-create-repo/" rel="noopener ugc nofollow" target="_blank">Omer Rosenbaum 在 FCC 上发布的 Git 内部可视化指南——对象、分支以及如何从零开始创建回购</a></li></ul><h1 id="32d6" class="no le in bd lf np nq nr li ns nt nu ll nv nw nx lo ny nz oa lr ob oc od lu oe bi translated">谢谢你🙏</h1><p id="352d" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">恭喜你走到这一步。我希望你像我写这篇文章一样喜欢它！</p><p id="aab8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">👏感谢阅读！如果你觉得这个故事有趣或有帮助，请鼓掌让我知道。别忘了关注更多类似的精彩内容。</p><p id="2453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🛎有问题或评论吗？让我们在<a class="ae lc" href="https://twitter.com/FreakingCode" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae lc" href="https://www.linkedin.com/in/georgelinardis/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上保持联系，继续对话吧！</p><p id="7aa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下次见。🤓</p></div></div>    
</body>
</html>