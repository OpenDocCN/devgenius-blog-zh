<html>
<head>
<title>Javascript Promise.all vs Promise.race</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript promise . all vs promise . race</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-promise-all-vs-promise-race-b23a38605fd0?source=collection_archive---------8-----------------------#2022-02-16">https://blog.devgenius.io/javascript-promise-all-vs-promise-race-b23a38605fd0?source=collection_archive---------8-----------------------#2022-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="1398" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">承诺简介</strong></h1><p id="90dd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">想象一下，你是一个著名的作家，你的粉丝正等着看你的新书。为了得到一些安慰，你答应出版后给他们寄一本。他们填写了一个表格，填写了他们的递送地址，这样副本就会被发送给他们。如果出现任何问题，他们仍然会得到通知。这是一个现实生活中诺言的类比。</p><p id="0259" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">承诺用于处理 Javascript 中的异步操作。当一个承诺被创建时，生产代码运行，最终产生结果。在 Javascript 中，为了更好地避免将回调函数传递给函数，从而导致代码难以管理和阅读，可以使用 promises。</p><h1 id="f535" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Promise 语法和属性</h1><p id="3bcf" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Javascript promise 对象可以被实现、拒绝或挂起。如果满足，结果是一个值，如果拒绝，结果是一个错误对象，如果挂起，结果是未定义的。</p><p id="032c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">可以使用 Promise 构造函数创建 Promise，它有一个参数，一个回调函数有两个参数:resolve 和 reject。当回调函数执行时，如果一切顺利，它将调用 resolve 如果没有达到预期的操作，它将拒绝。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="b880" class="lu jl in lq b gy lv lw l lx ly">var promise = new Promise((myResolve, myReject) =&gt; {<br/>// Code that takes some time<br/><br/>  myResolve(); // call this when success<br/>  myReject();  // call this when error<br/>});<br/><br/>// Code that waits the fulfillment of Promise<br/>myPromise.then(<br/>  function(value) // if successful <br/>  function(error) // if error <br/>);</span></pre><h1 id="def1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">承诺.所有 vs 承诺.比赛</h1><p id="7bb7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Javascript 中的 Promise 对象提供了内置的方法，比如 Promise.all 和 Promise.race。</p><p id="3345" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> Promise.all </strong>接受一个可重复的承诺作为输入，并在尝试完成所有<strong class="kk io">承诺后返回输入承诺结果的单个承诺。如果这些输入承诺中的一个被拒绝，它将退出。想象一下，访问你的博客页面，必须满足几个要求，如查看你的内容，你保存的博客和与导航条互动。如果任何这些东西没有正确显示，你将被重定向到其他地方。由于所有这些操作对于用户与站点的交互都至关重要，所以可以使用 Promise.all，在这种情况下，当其中一个功能失败时，就会被拒绝。</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2bd1" class="lu jl in lq b gy lv lw l lx ly">const promise1 = Promise.resolve(3);<br/>const promise2 = 22;<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 100, 'foo');<br/>});</span><span id="7a26" class="lu jl in lq b gy lz lw l lx ly">Promise.all([promise1, promise2, promise3]).then((values) =&gt; {<br/>  console.log(values);<br/>});<br/>// expected output: Array [3, 22, "foo"]</span></pre><p id="bfe8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> Promise.race </strong>接受一个可迭代对象，比如一个承诺数组和一个待定承诺的返回值。就像名字一样，那些承诺将会相互竞争。该方法将返回解决或拒绝的第<strong class="kk io">个</strong>已解决的承诺，并在此之后退出。在下面的示例中，promise2 执行得更快，因此它将首先被解析。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="02b6" class="lu jl in lq b gy lv lw l lx ly">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 500, 'one');<br/>});</span><span id="9e28" class="lu jl in lq b gy lz lw l lx ly">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 100, 'two');<br/>});</span><span id="4dd1" class="lu jl in lq b gy lz lw l lx ly">Promise.race([promise1, promise2]).then((value) =&gt; {<br/>  console.log(value);<br/><br/>});<br/>// expected output: "two"</span></pre><p id="fe54" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Promise.all 不能处理部分失败，如果其中一个承诺被拒绝，则整个流程都存在失败回调。在返回一个已解决的承诺之前，race 不会等待所有的承诺都被解决。选择哪一个取决于我们需要完成什么。</p><p id="1b74" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">资源:</p><div class="ma mb gp gr mc md"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd io gy z fp mi fr fs mj fu fw im bi translated">Promise.race() - JavaScript | MDN</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">Promise.race()方法返回一个承诺，只要 iterable 中的一个承诺满足或拒绝…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">developer.mozilla.org</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ms md"/></div></div></a></div><div class="ma mb gp gr mc md"><a href="https://alligator.io/js/promise-all-promise-race/#:~:text=need%20to%20accomplish.-,Promise.,to%20fulfill%20all%20of%20them.&amp;text=race%20also%20accepts%20an%20array,either%20be%20resolved%20or%20rejected" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd io gy z fp mi fr fs mj fu fw im bi translated">JavaScript 中 Promise.all 和 Promise.race 的区别</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">JavaScript 中的 Promise 对象提供了一些有用的内置方法，Promise.all 和 Promise.race 就是其中的两个…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">鳄鱼. io</p></div></div><div class="mm l"><div class="mt l mo mp mq mm mr ms md"/></div></div></a></div></div></div>    
</body>
</html>