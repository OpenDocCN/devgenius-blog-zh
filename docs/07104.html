<html>
<head>
<title>Deeply Nested and Possibly Undefined — TypeScript Index Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度嵌套且可能未定义—类型脚本索引类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deeply-nested-and-possibly-undefined-typescript-index-types-baa7d6802028?source=collection_archive---------3-----------------------#2022-02-26">https://blog.devgenius.io/deeply-nested-and-possibly-undefined-typescript-index-types-baa7d6802028?source=collection_archive---------3-----------------------#2022-02-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dcf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！感谢您的加入！</p><p id="bbdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我想分享一个在 TypeScript 中快速处理索引/查找类型的小家伙——特别是在处理查找深度嵌套且可能未定义的类型时。</p><p id="a810" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以让我们进入未知的世界吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b73f0cd285c1a4e9af5b71e5dd69ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sq42IQ-YfnKq1dSlB8mbGA.jpeg"/></div></div></figure><h1 id="27ef" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建类型</h1><h2 id="d68a" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">界面</h2><p id="7c9f" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">有时，您可能会处理具有嵌套属性的接口，甚至可能处理数组和对象。对我来说，我在处理由<code class="fe mj mk ml mm b">graphql-codegen</code>生成的类型并将部分属性传递给 React 组件时遇到过这种情况。</p><p id="f1d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这个啤酒厂的示例界面，因为今天是周六。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="485d" class="ls kv in mm b gy mr ms l mt mu">interface Brewery {<br/>  name: string;<br/>  location: {<br/>    address: string;<br/>    addressLineTwo: string;<br/>    city: string;<br/>    state: string;<br/>    zip: number;<br/>  };<br/>  products?: {<br/>    name: string;<br/>    type: "IPA" | "Stout";<br/>    attributes?: {<br/>      hops: { name: string; dryHopped?: boolean }[];<br/>      malt: string;<br/>      ibu: number;<br/>      abv: number;<br/>    };<br/>  }[];<br/>}</span></pre><p id="af46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意上面，这个接口的一些属性可能是未定义的，包括<code class="fe mj mk ml mm b">products</code>和<code class="fe mj mk ml mm b">products.attributes</code>。</p><h1 id="09b8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">示例函数</h1><p id="9244" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">因此，让我们定义一些接受<code class="fe mj mk ml mm b">brewery</code>类型的<em class="mv">部分</em>的函数，作为使用它的半实际例子。这样，我们就不必在不需要的时候将整个 brewery 对象从一个函数传递到另一个函数。</p><h2 id="4cde" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">根据所需属性定义-格式名称</h2><p id="8579" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">下面的 format name 函数将只接受<em class="mv">啤酒厂<code class="fe mj mk ml mm b">name</code>的属性，并对其进行一些简单的格式化。为此，我们将使用上面的接口和查找类型键入参数<code class="fe mj mk ml mm b">breweryName</code>。</em></p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="4d75" class="ls kv in mm b gy mr ms l mt mu">const formatBreweryName = (breweryName: Brewery["name"]) =&gt; {<br/>  const formatted = breweryName.toUpperCase();</span><span id="7f73" class="ls kv in mm b gy mw ms l mt mu">  return formatted;<br/>};</span></pre><p id="e5de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">属性<code class="fe mj mk ml mm b">name</code>在类型<code class="fe mj mk ml mm b">Brewery</code>中是必需的，这使得这个参数有点容易定义。</p><h2 id="7d88" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">从所需的对象定义—格式地址</h2><p id="b5a0" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">同样，<code class="fe mj mk ml mm b">address</code>属性是必需的，这使得定义下面的<code class="fe mj mk ml mm b">breweryAddress</code>参数相当容易。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="4a72" class="ls kv in mm b gy mr ms l mt mu">const formatAddress = (breweryLocation: Brewery["location"]) =&gt; {<br/>  const formatted = `${breweryLocation.address} ${breweryLocation?.addressLineTwo}, ${breweryLocation.city}, ${breweryLocation.state} ${breweryLocation.zip}`;</span><span id="41ba" class="ls kv in mm b gy mw ms l mt mu">  return formatted;<br/>};</span></pre><h2 id="ad2d" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">从嵌套和未定义的数组中定义—列出产品名称</h2><p id="eb3f" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">根据上面的类型，<code class="fe mj mk ml mm b">products</code>属性是一个数组，可能没有定义，但是我们不需要做任何改变来定义<code class="fe mj mk ml mm b">breweryProducts</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="04d1" class="ls kv in mm b gy mr ms l mt mu">const listProductNames = (breweryProducts: Brewery["products"]) =&gt; {<br/>  const productNames = breweryProducts?.map((product) =&gt; product.name);</span><span id="1185" class="ls kv in mm b gy mw ms l mt mu">  return productNames;<br/>};</span></pre><h2 id="bc79" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">从潜在未定义的对象定义-提取名称和类型</h2><p id="a1b0" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">当访问数组中潜在的未定义对象的类型时，我们需要做一些调整。下面我们将访问<code class="fe mj mk ml mm b">products</code>数组中的对象类型来定义<code class="fe mj mk ml mm b">breweryProduct</code>参数。</p><p id="2cf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 TypeScript 提供的<code class="fe mj mk ml mm b">NonNullable</code>实用程序来定义该类型。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="8317" class="ls kv in mm b gy mr ms l mt mu">const extractNameAndType = (<br/>  breweryProduct: NonNullable&lt;Brewery["products"]&gt;[0]<br/>) =&gt; {<br/>  const name = breweryProduct.name.toUpperCase();<br/>  const type = breweryProduct.type.toUpperCase();</span><span id="3edf" class="ls kv in mm b gy mw ms l mt mu">  return { name, type };<br/>};</span></pre><h2 id="02cb" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">从潜在未定义的嵌套对象定义—格式跃点名称</h2><p id="86ed" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">让我们更深入，更不明确。下面的<code class="fe mj mk ml mm b">hops</code>参数是潜在未定义的<code class="fe mj mk ml mm b">attributes</code>的一部分，而<code class="fe mj mk ml mm b">attributes</code>是潜在未定义的<code class="fe mj mk ml mm b">products</code>的一部分。</p><p id="6f22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嵌套<code class="fe mj mk ml mm b">NonNullable</code>实用程序类型来访问这个类型。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="a25b" class="ls kv in mm b gy mr ms l mt mu">const formatHopsName = (<br/>  hops: NonNullable&lt;<br/>    NonNullable&lt;Brewery["products"]&gt;[0]["attributes"]<br/>  &gt;["hops"][0]<br/>) =&gt; {<br/>  const formatted = hops.name.toUpperCase();</span><span id="64ad" class="ls kv in mm b gy mw ms l mt mu">  return formatted;<br/>};</span></pre><h1 id="9219" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">就是这样！</h1><p id="23f9" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">今天是一个快速的问题，有一些非常基本的例子。希望对你有点用！</p><p id="5cd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具体来说，我用它来传递一个嵌套的、可能未定义的对象的属性，作为其他 React 组件的道具。真的，这是另一个故事的对话——如果你想进一步了解细节，请告诉我！</p><p id="3489" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你今天读到这篇文章，祝你周六愉快…如果不是，那就享受一个寒冷的周六吧(只要你成年了！！).</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="babf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿你们！感谢您花几分钟时间阅读上面的提示和技巧。我希望它在某种程度上有所帮助！</p><p id="187e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就文章而言，本周将会很有趣！当我还在从两周前的前交叉韧带手术中恢复的时候，我已经为你计划了一些。我将发布构建 Apollo 联合 API 教程和 Starter Repo 的第三部分——这将是账户服务！</p><p id="85a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我可能有一个快速反应项目给你，建立一个文件管理器模块！</p><p id="ea49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下次见，</p><p id="ab29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尼克·M</p></div></div>    
</body>
</html>