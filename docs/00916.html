<html>
<head>
<title>Reference and Value Type in swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift 中的参考和值类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reference-and-value-type-in-swift-3b8492d82b3f?source=collection_archive---------22-----------------------#2020-06-19">https://blog.devgenius.io/reference-and-value-type-in-swift-3b8492d82b3f?source=collection_archive---------22-----------------------#2020-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9cdb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这是关于独立和被推荐</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b6847755bde1c63230d352cdfa0fa8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M8zEyrjN07ijtWOiMfGiQ.png"/></div></div></figure><h1 id="8199" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">参考值和数值之间的差异</h1><p id="c95e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">举个简单的例子，想象你的朋友抄袭了你的作品，他发现了一些错误。如果他纠正了他和你作品中的错误，那就是参考类型。如果他只是随着工作而改变，那么他就是自私的(价值型)。</p><p id="1994" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">真正的意思是，如果你改变了复制的值，并且影响了原始值，那么它就是一个引用类型。如果它只影响复制的值，那么它就是一个值类型(自私的值类型)。</p><h2 id="98a1" class="mh kp in bd kq mi mj dn ku mk ml dp ky lp mm mn la lt mo mp lc lx mq mr le ms bi translated">为什么会这样？</h2><p id="04f2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这时你的脑海里应该会有一个问题“为什么地狱引用类型复制后会受到影响？”如果不是，你就不是开发者，只是一个用户(像我一样)</p><p id="d993" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我感到困惑，你不要担心，让我来澄清它</p><h1 id="30d6" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">参考类型</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/623babe59086f82d24257d0a20abc306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-fjpe1DHJe-9Bqt2ASvFAw.gif"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">参考类型</figcaption></figure><p id="95c3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里牛奶是抄参考的。当男人改变牛奶数据时，甚至原始牛奶数据也受到影响。</p><p id="d450" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">引用类型不是普通类型。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/23c2c169c8d6aa7c01ee00e16afeb166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG32ZD23k4XfDAL3HYHn7g.png"/></div></div></figure><p id="fdfd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我只改变了<code class="fe mz na nb nc b">x.data</code>，但是<code class="fe mz na nb nc b">y.data</code>也改变了</p><p id="8031" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里牛奶是抄参考的。当 man2 更改牛奶数据时，甚至原始牛奶数据也会受到影响。</p><p id="b59f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因为它的引用类型。这意味着类类型的变量不存储实际的实例，而是存储引用。</p><blockquote class="nd"><p id="319e" class="ne nf in bd ng nh ni nj nk nl nm mb dk translated">(注意:引用被分配给变量或触点或函数，而不是在复制时创建的任何内存)</p></blockquote><p id="aaa6" class="pw-post-body-paragraph lg lh in li b lj nn jo ll lm no jr lo lp np lr ls lt nq lv lw lx nr lz ma mb ig bi translated">函数、闭包和类在 swift 中充当引用类型</p><h1 id="a792" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">值类型</h1><p id="b947" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">值是普通类型。就像我们通常做的例子</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/376d048d7e12e5185cbfb655809a9aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*XLtkLlvT-aepP5JnjTDZLw.png"/></div></figure><p id="c67e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以当<code class="fe mz na nb nc b">b </code>被复制到<code class="fe mz na nb nc b">a</code>时。这里<code class="fe mz na nb nc b">b</code>有其数据的唯一副本<code class="fe mz na nb nc b">a</code>。现在你可以用它做任何事情，不会像普通方法一样影响<code class="fe mz na nb nc b">a</code>。</p><blockquote class="nd"><p id="e979" class="ne nf in bd ng nh ni nj nk nl nm mb dk translated">(注意:值类型是直接在内存中创建的类型。每个实例都保留数据的唯一副本。)</p></blockquote><h2 id="8687" class="mh kp in bd kq mi nt dn ku mk nu dp ky lp nv mn la lt nw mp lc lx nx mr le ms bi translated">结构示例</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/d402662fcaa203daadccf1bc21e7f65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwokFeUQYU2xEPo7BMR8mw.png"/></div></div></figure><p id="958f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里只有<code class="fe mz na nb nc b">a</code>变化不受影响<code class="fe mz na nb nc b">b</code></p><p id="20ef" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">struct、enum、tuple、Dictionary、int、double、string 和 set 类型在 swift 中充当值类型</p><h2 id="253b" class="mh kp in bd kq mi mj dn ku mk ml dp ky lp mm mn la lt mo mp lc lx mq mr le ms bi translated">为什么会这样回答</h2><p id="825f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这些都是因为堆栈和堆内存分配</p><p id="5932" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">值类型将其内容存储在堆栈上分配的内存中。当您创建值类型时，内存中会分配一个空间来存储该值，该变量直接保存一个值。如果将它赋给另一个变量，则直接复制该值，两个变量独立工作。</p><p id="644f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">引用类型由引用使用，该引用保存对对象的引用(地址),而不是对象本身。因为引用类型表示变量的地址而不是数据本身，所以将引用变量赋给另一个变量并不会复制数据。相反，它创建引用的第二个副本，该副本引用与原始值相同的堆位置。引用类型变量存储在称为堆的不同内存区域中</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="af43" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果你想喊我，就来<a class="ae of" href="https://twitter.com/Tonywilson_jpg" rel="noopener ugc nofollow" target="_blank"> twitter </a></p></div></div>    
</body>
</html>