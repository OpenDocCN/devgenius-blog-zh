<html>
<head>
<title>Subscripts in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的下标</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/subscripts-in-swift-dbcdb65233b7?source=collection_archive---------9-----------------------#2022-02-15">https://blog.devgenius.io/subscripts-in-swift-dbcdb65233b7?source=collection_archive---------9-----------------------#2022-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c95b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类、结构和枚举可以定义下标，下标是访问集合、列表或序列的成员元素的快捷方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff96d4d74e69088e201179535bfb3ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-EXRh62Vv1wF6hGc8enkg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/syntatic-sugar-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</figcaption></figure><p id="f8fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将解释下面列出的一些关于下标的问题。</p><p id="27a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">Swift 中的下标是什么？</em><br/><em class="kz">Swift 中如何使用下标？<br/>Swift 中的多维下标是什么？</em></p><p id="a36e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类、结构和枚举可以定义<em class="kz">下标</em>，这是访问集合、列表或序列的成员元素的快捷方式。</p><p id="4b6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用下标按索引设置和检索值，而不需要单独的设置和检索方法。例如，访问数组实例中的元素作为 someArray[index]，访问字典实例中的元素作为 someDictionary[key]。</p><p id="81f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以为单个类型定义多个下标，并根据传递给下标的索引值的类型来选择要使用的适当下标重载。</p><p id="562c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下标不限于单个维度，您可以使用多个输入参数来定义下标，以满足您的定制类型的需要。</p><p id="6655" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个代码示例。我将创建一个负责用户首选项的 UserPreferences 类。</p><p id="1b49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">UserPreferences 类有两个方法和一个数组。其中之一就是保留给予偏好。另一个是通过首选项类型获取首选项值。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="9900" class="lf lg in lb b gy lh li l lj lk">enum UserPreferencesType {<br/>case username,email<br/>}</span><span id="9f6b" class="lf lg in lb b gy ll li l lj lk">class UserPreferences {<br/> <br/>  static let shared = UserPreferences()</span><span id="a057" class="lf lg in lb b gy ll li l lj lk">  private var preferences: [UserPreferencesType: Any] = [:]</span><span id="4a1f" class="lf lg in lb b gy ll li l lj lk">  func preference(for type: UserPreferencesType) -&gt; Any? {<br/>    preferences[type]<br/>  }</span><span id="ca3d" class="lf lg in lb b gy ll li l lj lk">  func preference(_ value: Any, for type: UserPreferencesType) {<br/>    preferences[type] = value<br/>  }</span><span id="9441" class="lf lg in lb b gy ll li l lj lk">}</span></pre><p id="1557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过下面的调用保存一个用户偏好。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="51c3" class="lf lg in lb b gy lh li l lj lk">UserPreferences.shared.preference(“batikansosun”, for: .username)<br/>UserPreferences.shared.preference(“<a class="ae ky" href="mailto:batikansosun@example.com" rel="noopener ugc nofollow" target="_blank">batikansosun@example.com</a>”, for: .email)</span></pre><p id="f776" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后像下面的调用那样按首选项类型获取任何首选项值。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="31a0" class="lf lg in lb b gy lh li l lj lk">UserPreferences.shared.preference(for: .username) //batikansosun<br/>UserPreferences.shared.preference(for: .email) //batikansosun@example.com</span></pre><p id="4e20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">获取一个首选项值，并设置一个首选项值，这样可读性会更好一些。我们如何解决这个问题？<br/>首先，我们可以像我下面提到的那样定义一个下标方法。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="8f05" class="lf lg in lb b gy lh li l lj lk">subscript(type: UserPreferencesType) -&gt; Any? {<br/>  get { preferences[type] }<br/>  set { preferences[type] = newValue }<br/>}</span></pre><p id="929b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后调用如下所示的方法。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="139b" class="lf lg in lb b gy lh li l lj lk">UserPreferences.shared[.username] = “batikansosun”<br/>UserPreferences.shared[.username] //batikansosun</span></pre><p id="8177" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我仍然认为我们的类需要更多的可读性。我将把共享实例移到下标方法中。所以我需要定义一个静态下标方法。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="a305" class="lf lg in lb b gy lh li l lj lk">static subscript(type: UserPreferencesType) -&gt; Any? {<br/>  get { shared.preferences[type] }<br/>  set { shared.preferences[type] = newValue }<br/>}</span></pre><p id="54fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">静态前缀将使我免于使用共享实例。终于，我们班有了新的看法。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="0cb3" class="lf lg in lb b gy lh li l lj lk">class UserPreferences {<br/> <br/>  static let shared = UserPreferences()</span><span id="6255" class="lf lg in lb b gy ll li l lj lk">  private var preferences: [UserPreferencesType: Any] = [:]</span><span id="ccde" class="lf lg in lb b gy ll li l lj lk">  func preference(for type: UserPreferencesType) -&gt; Any? {<br/>    preferences[type]<br/>  }</span><span id="0660" class="lf lg in lb b gy ll li l lj lk">  func preference(_ value: Any, for type: UserPreferencesType) {<br/>    preferences[type] = value<br/>  }<br/> <br/>  static subscript(type: UserPreferencesType) -&gt; Any? {<br/>   get { shared.preferences[type] }<br/>   set { shared.preferences[type] = newValue }<br/>  }</span><span id="0840" class="lf lg in lb b gy ll li l lj lk">}</span></pre><p id="0d71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，按照下面的调用，通过首选项类型获取任何首选项值。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="47be" class="lf lg in lb b gy lh li l lj lk">UserPreferences[.username] = “batikansosun”<br/>UserPreferences[.username] //batikansosun</span></pre><p id="700a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为这段代码是一件伟大的事情。你同意我的观点吗？</p><p id="3da6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后可能得出结论:<br/> Swift 语言有很多特性，提供了很多编程的方式。下标就是其中之一。<br/>下标提供句法糖。<br/>下标减少开发时间。<br/>下标提供了一目了然的理解代码。这样使事情更容易阅读或表达。</p><p id="d0b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ref:<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/subscripts . html</a></p></div></div>    
</body>
</html>