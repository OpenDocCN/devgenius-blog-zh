<html>
<head>
<title>Why you should change your Regex Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该改变你的正则表达式引擎</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-you-should-change-your-regex-engine-4c26a66ebf23?source=collection_archive---------9-----------------------#2020-06-29">https://blog.devgenius.io/why-you-should-change-your-regex-engine-4c26a66ebf23?source=collection_archive---------9-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/101f5e04fdeb563766c5989330395d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wdY5HtuRX0ukbo1E"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">约书亚·阿拉贡在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="3d6c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也许你不<em class="ky">需要</em>改变你的正则表达式引擎，但是有件事你绝对应该知道。大多数regex引擎实现使用<a class="ae ja" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank">回溯</a>，它以<strong class="kc je"><em class="ky">【o(2^n】</em></strong>的指数时间运行，这意味着当提供恶意输入时，可能需要很长时间才能完成。</p><p id="5e05" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单回顾一下，这是一张在<a class="ae ja" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a>看到的Big-O复杂度图:</p><figure class="la lb lc ld gt ip gh gi paragraph-image"><a href="https://www.bigocheatsheet.com/"><div class="gh gi kz"><img src="../Images/ff413de169c42b358ac3bb2b6fe6a55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sgGsWonrDEvLSJ16JpjWw.png"/></div></a><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">Big-O复杂度图:<a class="ae ja" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></figcaption></figure><p id="d968" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想了解更多关于时间复杂度的信息，请看以下页面:</p><ul class=""><li id="aa33" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">维基百科:<a class="ae ja" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Time_complexity</a></li><li id="47eb" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">走向数据科学:<a class="ae ja" href="https://towardsdatascience.com/understanding-time-complexity-with-python-examples-2bda6e8158a7" rel="noopener" target="_blank">https://towardsdatascience . com/understanding-time-complexity-with-python-examples-2 bda6e 8158 a 7</a></li></ul><p id="32b1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，一旦你对时间和空间的复杂性有了很好的理解，在准备编码面试时，这里有一个很好的资源(上面给出的图表的来源):</p><ul class=""><li id="b5cd" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">Big-O小抄:<a class="ae ja" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></li></ul><p id="7fb5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到手头的问题，不用多久就会注意到，在某些条件下，即当输入数据大到足以引起问题时，指数运行时间算法可能会成为真正的噩梦。有时候，足够多的数据并不意味着大量的数据，它可能是一个100个字符的字符串。</p><p id="eb50" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样以这个例子为例，当试图将一个由一个重复多次的字符组成的100个字符的字符串与一个畸形的正则表达式进行匹配时，总的执行时间将超过10个⁵年，正如这篇伟大的文章<a class="ae ja" href="https://swtch.com/~rsc/regexp/regexp1.html" rel="noopener ugc nofollow" target="_blank">https://swtch.com/~rsc/regexp/regexp1.html</a>中所讨论的:</p><blockquote class="ls lt lu"><p id="e017" class="ka kb ky kc b kd ke kf kg kh ki kj kk lv km kn ko lw kq kr ks lx ku kv kw kx ig bi translated">注意，Perl需要60多秒来匹配一个29个字符的字符串。另一种方法被标记为汤普森NFA，原因将在后面解释，它需要二十<em class="jd">微秒</em>来匹配字符串。那不是错别字。Perl图以秒为单位绘制时间，而汤普森NFA图以微秒为单位绘制时间:在运行29个字符的字符串时，汤普森NFA实现比Perl快一百万倍。图表中显示的趋势还在继续:Thompson NFA在不到200微秒的时间内处理一个100个字符的字符串，而Perl需要超过10 ⁵年。(Perl只是大量使用相同算法的流行程序中最显眼的例子；上面的图可能是Python，或者PHP，或者Ruby，或者其他语言。本文后面更详细的图表展示了其他实现的数据。)</p></blockquote><p id="d556" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也许这一事实最具标志性的含义是广为人知的<em class="ky">正则表达式拒绝服务</em> (ReDoS)攻击。根据<a class="ae ja" href="https://owasp.org/" rel="noopener ugc nofollow" target="_blank"> OWASP </a>基金会的说法，这种攻击的定义强调了最常见的正则表达式库实现的指数级运行时间所导致的问题。可以在<a class="ae ja" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS" rel="noopener ugc nofollow" target="_blank">https://owasp . org/www-community/attacks/Regular _ expression _ Denial _ of _ Service _-_ ReDoS</a>找到:</p><blockquote class="ls lt lu"><p id="10b2" class="ka kb ky kc b kd ke kf kg kh ki kj kk lv km kn ko lw kq kr ks lx ku kv kw kx ig bi translated"><strong class="kc je">正则表达式拒绝服务(ReDoS) </strong>是一种<a class="ae ja" href="https://owasp.org/www-community/attacks/Denial_of_Service" rel="noopener ugc nofollow" target="_blank">拒绝服务</a>攻击，它利用了这样一个事实，即大多数正则表达式实现可能会遇到极端情况，导致它们运行非常缓慢(与输入大小成指数关系)。然后，攻击者可以使使用正则表达式的程序进入这些极端情况，然后长时间挂起。</p></blockquote><p id="8538" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，那么你能做些什么来避免这个问题呢？答案可能会有所不同。如果您的用例只涉及评估众所周知的、行为良好的正则表达式，这些表达式用于匹配一组众所周知的、非恶意的相对较小的输入，那么您可能根本就不应该为此费心。但是如果你仍然不确定，试着看看这些项目:</p><ul class=""><li id="da24" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">https://github.com/substack/safe-regex</li><li id="e2bf" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">rxxr 2:<a class="ae ja" href="https://www.cs.bham.ac.uk/~hxt/research/rxxr2/" rel="noopener ugc nofollow" target="_blank">https://www.cs.bham.ac.uk/~hxt/research/rxxr2/</a></li></ul><p id="bbcf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，如果您的应用程序接受用户输入并使用易受攻击的正则表达式引擎对其进行评估，您可以考虑选择一种新的编程语言，其正则表达式实现不会受到这个问题的影响(好吧…我知道说起来容易做起来难)，或者您可以使用另一个正则表达式库。</p><p id="346b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，目前我一直在试验RE2(<a class="ae ja" href="https://github.com/google/re2" rel="noopener ugc nofollow" target="_blank">https://github.com/google/re2</a>)，它是回溯正则表达式实现的一种快速而安全的替代方法，它提供了一个<strong class="kc je"><em class="ky">【n】</em></strong>的线性运行时间(如果有疑问，请参考Big-O复杂度图)，它已经满足了我所有的期望和要求。你可能已经注意到了，这是谷歌<a class="ae ja" href="https://github.com/google" rel="noopener ugc nofollow" target="_blank">库</a>中可用的项目之一，目前是<a class="ae ja" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">Golang</a>(<a class="ae ja" href="https://golang.org/pkg/regexp/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/regexp/</a>)使用的regex引擎。它是由<a class="ae ja" href="https://swtch.com/~rsc/" rel="noopener ugc nofollow" target="_blank"> Russ Cox </a>开发的，他还写了3篇很棒的文章解释他的代码的所有理论基础:</p><ul class=""><li id="20e0" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated"><a class="ae ja" href="https://swtch.com/~rsc/regexp/regexp1.html" rel="noopener ugc nofollow" target="_blank">正则表达式匹配可以简单快速(但在Java、Perl、PHP、Python、Ruby等语言中比较慢)</a></li><li id="98ca" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated"><a class="ae ja" href="https://swtch.com/~rsc/regexp/regexp2.html" rel="noopener ugc nofollow" target="_blank">正则表达式匹配:虚拟机方法</a></li><li id="a2ca" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated"><a class="ae ja" href="https://swtch.com/~rsc/regexp/regexp3.html" rel="noopener ugc nofollow" target="_blank">野外正则表达式匹配</a></li></ul><p id="cd14" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这三段文字对任何打算扩展他/她的计算机科学理论知识的人来说都是极好的资源。</p><p id="61b7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然RE2是用C++编写的，但是其他编程语言也可以使用包装器:</p><ul class=""><li id="5fdc" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">一个包装厂在https://github.com/marcomaggi/cre2/。</li><li id="4e44" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个Erlang包装器在<a class="ae ja" href="https://github.com/dukesoferl/re2/" rel="noopener ugc nofollow" target="_blank">https://github.com/dukesoferl/re2/</a>和十六进制(hex.pm)上。</li><li id="2d03" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个地狱般的包装在https://github.com/powerman/inferno-re2/。</li><li id="8be2" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">Node.js包装器在https://github.com/uhop/node-re2/和NPM。</li><li id="3c6c" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个OCaml包装器在https://github.com/janestreet/re2/和OPAM (opam.ocaml.org)。</li><li id="43d0" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个Perl包装器在https://github.com/dgl/re-engine-RE2/的T2和CPAN (cpan.org)。</li><li id="dcda" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个Python包装器在https://github.com/facebook/pyre2/的T4和PyPI (pypi.org)上。</li><li id="ea66" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个R包装器在https://github.com/qinwf/re2r/和CRAN (cran.r-project.org)上。</li><li id="a80d" class="le lf jd kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">一个红宝石包装器在https://github.com/mudge/re2/和rubygems.org的RubyGems上</li></ul><p id="e7db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，下面是不同正则表达式引擎的详细比较。您可以使用它来比较RE2与其他库的特性:</p><ul class=""><li id="8234" class="le lf jd kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">正则表达式引擎比较:<a class="ae ja" href="https://en.wikipedia.org/wiki/Comparison_of_regular-expression_engines#Language_features" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Comparison _ of _ regular-expression _ engines # Language _ features</a></li></ul></div></div>    
</body>
</html>