<html>
<head>
<title>Unleashing the Power of Recursion to Solve Crossword Puzzles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放递归的力量来解决纵横字谜</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unleashing-power-of-recursion-to-solve-crossword-puzzles-d5b94737c916?source=collection_archive---------4-----------------------#2022-12-18">https://blog.devgenius.io/unleashing-power-of-recursion-to-solve-crossword-puzzles-d5b94737c916?source=collection_archive---------4-----------------------#2022-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ca81c783330bb4ae89e0abf471ed0369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u-3wFoAsAofqfBPo.jpg"/></div></div></figure><p id="959f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">纵横字谜是一种文字游戏，游戏者得到一个方格和一系列线索。目标是用字母填充方块，形成在称为交叉点的特定方块处相交的单词。</p><p id="f365" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用纵横填字游戏时，您可能会遇到的一个问题是如何根据提供的线索有效地用正确的字母填充方块。你可能需要写一个程序来接收线索和网格，并输出完成的纵横字谜。</p><p id="3ab9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在解决此问题时，您可能会遇到一些挑战，包括:</p><ul class=""><li id="1719" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">解析和解释线索和网格数据</li><li id="0908" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">根据线索确定哪些方块应该被填充</li><li id="6c9d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">处理相互矛盾的线索或多种可能的解决方案</li><li id="b5dc" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">实现解决纵横字谜的有效算法</li></ul><h2 id="44c6" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">问题陈述</h2><p id="364a" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">给定一个纵横字谜，用一个数组表示，数组中的空格用“-”表示，还有一个单词列表可以放入空格中，我们需要一个程序用适当的单词填充空格，这样完成的纵横字谜才有效。"</p><h2 id="cdf5" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">示例:</h2><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/c85b52fb2c3ae5ab59723a7f44bee720.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kKP2mYIE1x1JmWSlUQFuJg.png"/></div></figure><h2 id="6cec" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">方法:</h2><p id="bcfa" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">为了解决这个纵横字谜问题，我们将使用回溯的递归方法。这意味着我们将在纵横字谜中尝试不同的单词和位置组合，并在到达死胡同或无效解时回溯。</p><p id="011e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">填字游戏的方法包括扫描网格中的每个方块，并尝试从左上角开始，一行一行、一列一列地横向或纵向填充一个单词。如果一个单词不适合某个特定的位置，我们将返回并尝试不同的组合。这个过程将会继续，直到我们成功地完成整个填字游戏，或者我们已经确定没有解决方案存在。</p><p id="378b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着我们将从网格的左上角(第 0 行，第 0 列)开始，尝试水平拟合第一个单词。如果单词不合适，我们将尝试垂直匹配。如果仍然不合适，我们将返回并尝试不同的单词和位置组合。一旦我们成功地放置了第一个单词，我们将移动到网格中的下一个位置(第 0 行，第 1 列),并重复该过程，直到我们已经填充了整个网格或者我们已经确定不存在解。"</p><p id="1582" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，波兰已被选中，然后纵横字谜的第一个元素被选中，它将横向和纵向检查波兰是否适合。像这样。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/4ecfccdfe98ffd0e92c16b83f97c1301.png" data-original-src="https://miro.medium.com/v2/format:webp/1*V3fGuU2Hx6YHDdJ-D6M94g.png"/></div></figure><p id="f348" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此后，将对第二个元素重复该操作。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/4db2382c62b0b3b12f37a4032a394755.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9NAwcS2rzxT65gUoDQ-npQ.png"/></div></figure><p id="af49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，它重复了第二个元素，并发现对于“P”它能够适合，但其余的字母不能适合。所以它将再次检查下一个元素。</p><p id="c48f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且重复这个过程，直到没有找到正确的位置。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/81f6139a4c04d1a8aaa5d5140158ba37.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oi394L0o-Uq33iKhen9vew.png"/></div></figure><p id="e0c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦这个单词的位置被找到，它将移动到下一个单词，拉萨。对于拉萨也一样，它会从头开始扫描，直到找不到合适的地方。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/e0ce3f713fbdb7ec9f1581e720d68965.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YtatRwNRTnqOvdaMaw364A.png"/></div></figure><p id="7550" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一进程将继续下去。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/212cd113de02c747beb86756b963ba35.png" data-original-src="https://miro.medium.com/v2/format:webp/1*MJdstXzhoJHa4N7_3_EOXg.png"/></div></figure><h2 id="8122" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">回溯:</h2><p id="f2af" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">现在，回溯将如何发生，它将从最后一个单词开始删除填充的字符。所以这里填的最后一个词是印度。所以它会开始删除字符。</p><p id="742e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，这里要注意的是“I”字是由意大利放置的，它是放置印度的线索。所以“我”不会被删除。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/acb81a02a8107a0539c5316b992cba83.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dphf5QhwdWYFdDRUjJaILg.png"/></div></figure><p id="bb58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将移除 NDIA。此后，在回溯的最后第二个词，即西班牙将被删除。但是 S 是由拉萨而不是西班牙填充的，所以“S”不会被删除。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/a65b6dfdfabaa7270bcd867eb4b360f7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CX25B6t0qpu1op0913tEUw.png"/></div></figure><p id="0841" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，通过这种方式，会发生回溯。</p><p id="f7dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果放置了错误的字母，那么回溯将删除这些字母，并从下一个位置重新开始搜索。</p><p id="21eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是解决纵横字谜问题的强力递归方法！</p><h2 id="1eef" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">伪代码</h2><p id="c3c3" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">基于该方法的伪代码如下所示:</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="724b" class="mp li in ml b be mq mr l ms mt">For all rows:<br/>    For all cols:<br/>        If CanPlaceHorizontally:<br/>            PlaceHorizontally<br/>            RECURSIVE_CALL()<br/>            UnPlaceHorizontal<br/>        <br/>        If CanPlaceVertically:<br/>            PlaceVertically<br/>            RECURSIVE_CALL()<br/>            UnplaceVertically</span></pre><p id="2e63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个伪代码定义了一个递归的方法来解决纵横字谜。它首先遍历纵横字谜的行和列，并尝试在每个位置水平和垂直地匹配当前单词。如果这个单词符合任何一个方向，它就把它放入纵横字谜中，并用修改过的纵横字谜递归地调用它自己。如果单词在任一方向都不合适，它将移动到下一个位置并再次尝试。</p><p id="d520" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个过程一直持续到所有的单词都被放入纵横字谜中，此时函数返回完成的纵横字谜。如果函数找不到解决方案，它将返回 None 或其他失败指示。</p><p id="e6c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法使用递归和回溯来探索在纵横字谜中放置单词的所有可能的方法，并且如果存在的话，它保证找到解决方案。然而，如果纵横字谜很大或者单词列表很长，它可能是低效的，因为它将需要探索大量的可能性。</p><h2 id="5851" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">逐步实施</h2><ol class=""><li id="28b1" class="kt ku in jx b jy ma kc mb kg mu kk mv ko mw ks mx kz la lb bi translated">函数解决方案将一个纵横字谜、一个单词列表和列表中的当前索引作为输入。</li><li id="9984" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果当前索引等于单词列表的长度，则意味着所有的单词都已被放入填字游戏中。因此，该函数调用 convert_to_string 将纵横字谜从一个列表转换为一个字符串，然后打印出来。然后返回 True，表示找到了解决方案。</li><li id="8505" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果所有的单词还没有被放置，函数将变量 word 设置为列表中的当前单词。</li><li id="a3a8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">然后，它遍历纵横字谜的行和列，对于每个位置，它检查单词是否可以水平或垂直放置。</li><li id="3ebe" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果单词可以水平放置，该函数调用 place horizontally 将其放置在纵横字谜中，然后用修改后的纵横字谜和更新后的索引递归调用自己。如果递归调用返回 False，表明没有找到解决方案，则该函数调用 unplaceHorizontally 从纵横字谜中删除该单词，并尝试下一个位置。如果递归调用返回 True，表示找到了解决方案，则该函数返回 True，表示找到了解决方案。</li><li id="8be4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果单词不能水平放置，或者已经在当前位置尝试过但失败了，则该函数对垂直放置重复相同的过程。</li><li id="2267" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果单词不能水平或垂直放置</li></ol><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="b5af" class="mp li in ml b be mq mr l ms mt">def solution(arr, words, idx):<br/>  # If all the words have been placed, print the crossword and return True<br/>  if idx == len(words):<br/>    convert_to_string()<br/>    print(crossword)<br/>    return True<br/>  <br/>  # Set the current word to the word at the current index<br/>  word = words[idx]<br/>  <br/>  # Iterate over the rows and columns of the crossword<br/>  for rows in range(len(crossword)):<br/>    for cols in range(len(crossword[0])):<br/>      # Try fitting the word horizontally<br/>      if canPlaceHorizontally(arr, word, rows, cols):<br/>        # Place the word horizontally<br/>        wherePlaced = placeHorizontally(arr, word, rows, cols)<br/>        # Recursively try to place the remaining words<br/>        if not solution(arr, words, idx+1):<br/>          # If no solution was found, remove the word from the crossword and try the next position<br/>          unplaceHorizontally(arr, wherePlaced, word, rows, cols)<br/>        else:<br/>          # If a solution was found, return True<br/>          return True<br/>      <br/>      # Try fitting the word vertically<br/>      if canPlaceVertically(arr, word, rows, cols):<br/>        # Place the word vertically<br/>        wherePlaced = placeVertically(arr, word, rows, cols)<br/>        # Recursively try to place the remaining words<br/>        if not solution(arr, words, idx+1):<br/>          # If no solution was found, remove the word from the crossword and try the next position<br/>          unplaceVertically(arr, wherePlaced, word, rows, cols)<br/>        else:<br/>          # If a solution was found, return True<br/>          return True<br/>  <br/>  # If the word did not fit horizontally or vertically, return False<br/>  return False</span></pre><p id="3cdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">检查水平放置和垂直放置</strong></p><p id="eccc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">canPlaceHorizontally 和 canPlaceVertically 函数是帮助函数，用于检查给定的单词是否可以水平或垂直地放置在纵横字谜的给定位置。它们都遵循相似的过程:</p><ol class=""><li id="8a78" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks mx kz la lb bi translated">他们将一个纵横字谜、一个单词和纵横字谜中的当前位置作为输入。</li><li id="aa15" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">他们计算纵横字谜的尺寸(M 和 N 代表垂直放置，M 和 N 代表水平放置)。</li><li id="ebeb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">它们检查单词的第一个字符是否可以放在当前位置。如果位置在纵横字谜的边缘，或者适当方向上的字符是一个加号，他们继续。否则，它们返回 False，表示该单词不能放在当前位置。</li><li id="4e1c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">然后，它们检查单词的最后一个字符是否可以放在当前位置。如果位置在纵横字谜的边缘，或者适当方向上的字符是一个加号，他们继续。否则，它们返回 False，表示该单词不能放在当前位置。</li><li id="7ed8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">然后，他们遍历单词的字符，检查每个字符是否可以放在纵横字谜中的相应位置。如果这个位置是空的或者这个字符已经存在于纵横字谜中，他们继续。否则，它们返回 False，表示该单词不能放在当前位置。</li><li id="26fd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks mx kz la lb bi translated">如果该函数到达循环的末尾，它将返回 True，表示该单词可以放在当前位置。</li></ol><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="8754" class="mp li in ml b be mq mr l ms mt">def canPlaceHorizontally(arr, word, rows, cols):<br/>  # Calculate the dimensions of the crossword<br/>  M = len(arr)<br/>  N = len(arr[0])<br/><br/>  # Check if the first character of the word can be placed at the current position<br/>  if cols &gt; 0 and arr[rows][cols-1] != '+':<br/>    return False<br/>  # Check if the last character of the word can be placed at the current position<br/>  elif (cols+len(word)-1) &gt;= N or ((cols+len(word) &lt; N) and (arr[rows][cols+len(word)] != '+')):<br/>    return False<br/><br/>  # Iterate over the characters of the word<br/>  for i in range(len(word)):<br/>    # Check if the character can be placed at the current position<br/>    if arr[rows][cols+i] != '-' and arr[rows][cols+i] != word[i]:<br/>      return False<br/><br/>  # If all characters of the word can be placed, return True<br/>  return True<br/><br/><br/>def canPlaceVertically(arr, word, rows, cols):<br/>  # Calculate the dimensions of the crossword<br/>  M = len(arr)<br/>  N = len(arr[0])<br/><br/>  # Check if the first character of the word can be placed at the current position<br/>  if rows &gt; 0 and arr[rows-1][cols] != '+':<br/>    return False<br/>  # Check if the last character of the word can be placed at the current position<br/>  elif (rows+len(word)-1) &gt;= M or ((rows+len(word) &lt; M) and (arr[rows+len(word)][cols] != '+')):<br/>    return False<br/><br/>  # Iterate over the characters of the word<br/>  for i in range(len(word)):<br/>    # Check if the character can be placed at the current position<br/>    if arr[rows+i][cols] != '-' and arr[rows+i][cols] != word[i]:<br/>      return False<br/><br/>  # If all characters of the word can be placed,<br/>  return True</span></pre><p id="68a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">放置逻辑非常简单，我们只需迭代并放置每个字符。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="f8d7" class="mp li in ml b be mq mr l ms mt">def placeHorizontally(arr, word, rows, cols):<br/>    wherePlaced = set()<br/>    for i in range(len(word)):<br/>        if arr[rows][cols+i] == '-':<br/>            arr[rows][cols+i] = word[i]<br/>            wherePlaced.add(cols+i)<br/>    return wherePlaced<br/><br/><br/>def placeVertically(arr, word, rows, cols):<br/>    wherePlaced = set()<br/>    for i in range(len(word)):<br/>        if arr[rows+i][cols] == '-':<br/>            arr[rows+i][cols] = word[i]<br/>            wherePlaced.add(rows+i)<br/>    return wherePlaced</span></pre><p id="d066" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在删除字符时，我们需要确保被删除的字符是由某个特定的句子书写的，而不是由任何其他句子书写的。因此，我们将借助于放置数组的位置。它包含由特定句子放置的字符的索引。</p><p id="4687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用集合是因为集合中的索引复杂度较低。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="45d6" class="mp li in ml b be mq mr l ms mt">def unplaceHorizontally(arr, wherePlaced, word, rows, cols):<br/>    for i in range(len(word)):<br/>        if cols+i not in wherePlaced:<br/>            continue<br/>        else:<br/>            arr[rows][cols+i] = '-'<br/><br/><br/>def unplaceVertically(arr, wherePlaced, word, rows, cols):<br/>    for i in range(len(word)):<br/>        if rows+i not in wherePlaced:<br/>            continue<br/>        else:<br/>            arr[rows+i][cols] = '-'</span></pre><h2 id="6929" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">时间复杂性分析</h2><p id="cdcc" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">该算法的总时间复杂度将为 O(MN <em class="my"> W </em> L)。这意味着算法所花费的时间将取决于纵横字谜的大小、要放置的字数以及单词的长度。</p><h2 id="7696" class="lh li in bd lj lk ll dn lm ln lo dp lp kg lq lr ls kk lt lu lv ko lw lx ly lz bi translated">下面给出了全部代码</h2><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="dc88" class="mp li in ml b be mq mr l ms mt">crossword = [<br/>    '++++++-+++',<br/>    '++------++',<br/>    '++++++-+++',<br/>    '++++++-+++',<br/>    '+++------+',<br/>    '++++++-+-+',<br/>    '++++++-+-+',<br/>    '++++++++-+',<br/>    '++++++++-+',<br/>    '++++++++-+',<br/><br/>]<br/><br/>words = "ICELAND;MEXICO;PANAMA;ALMATY"<br/>words = words.split(";")<br/><br/><br/>def convert_2_matrix():<br/>    for i in range(len(crossword)):<br/>        crossword[i] = list(crossword[i])<br/><br/><br/>def convert_to_string():<br/>    for rows in range(len(crossword)):<br/>        crossword[rows] = ''.join(crossword[rows])<br/><br/><br/>convert_2_matrix()<br/><br/><br/>def canPlaceHorizontally(arr, word, rows, cols):<br/>    M = len(arr)<br/>    N = len(arr[0])<br/>    if cols &gt; 0 and arr[rows][cols-1] != '+':<br/>        return False<br/>    elif (cols+len(word)-1) &gt;= N or ((cols+len(word) &lt; N) and (arr[rows][cols+len(word)] != '+')):<br/>        return False<br/>    for i in range(len(word)):<br/>        if(arr[rows][(cols+i)] == '-' or arr[rows][(cols+i)] == word[i]):<br/>            continue<br/>        else:<br/>            return False<br/><br/>    return True<br/><br/><br/>def canPlaceVertically(arr, word, rows, cols):<br/>    M = len(arr)<br/>    N = len(arr[0])<br/>    if rows &gt; 0 and arr[rows-1][cols] != '+':<br/>        return False<br/>    elif (rows+len(word)-1) &gt;= M or ((rows+len(word) &lt; M) and (arr[rows+len(word)][cols] != '+')):<br/>        return False<br/>    for i in range(len(word)):<br/>        if(arr[rows+i][cols] == '-' or arr[rows+i][cols] == word[i]):<br/>            continue<br/>        else:<br/>            return False<br/><br/>    return True<br/><br/><br/>def placeHorizontally(arr, word, rows, cols):<br/>    wherePlaced = set()<br/>    for i in range(len(word)):<br/>        if arr[rows][cols+i] == '-':<br/>            arr[rows][cols+i] = word[i]<br/>            wherePlaced.add(cols+i)<br/>    return wherePlaced<br/><br/><br/>def placeVertically(arr, word, rows, cols):<br/>    wherePlaced = set()<br/>    for i in range(len(word)):<br/>        if arr[rows+i][cols] == '-':<br/>            arr[rows+i][cols] = word[i]<br/>            wherePlaced.add(rows+i)<br/>    return wherePlaced<br/><br/><br/>def unplaceHorizontally(arr, wherePlaced, word, rows, cols):<br/>    for i in range(len(word)):<br/>        if cols+i not in wherePlaced:<br/>            continue<br/>        else:<br/>            arr[rows][cols+i] = '-'<br/><br/><br/>def unplaceVertically(arr, wherePlaced, word, rows, cols):<br/>    for i in range(len(word)):<br/>        if rows+i not in wherePlaced:<br/>            continue<br/>        else:<br/>            arr[rows+i][cols] = '-'<br/><br/><br/>def solution(arr, words, idx):<br/><br/>    if idx == len(words):<br/>        convert_to_string()<br/>        print(crossword)<br/>        return True<br/>    word = words[idx]<br/>    for rows in range(len(crossword)):<br/>        for cols in range(len(crossword[0])):<br/>            if(canPlaceHorizontally(arr, word, rows, cols)):<br/>                wherePlaced = placeHorizontally(arr, word, rows, cols)<br/>                if not solution(arr, words, idx+1):<br/>                    unplaceHorizontally(arr, wherePlaced, word, rows, cols)<br/>                else:<br/>                    return True<br/>            if(canPlaceVertically(arr, word, rows, cols)):<br/>                wherePlaced = placeVertically(arr, word, rows, cols)<br/>                if not solution(arr, words, idx+1):<br/>                    unplaceVertically(arr, wherePlaced, word, rows, cols)<br/>                else:<br/>                    return True<br/><br/>    return False<br/><br/><br/>solution(crossword, words, 0)</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="9c45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你阅读我的博客！</p><p id="1090" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">~普里图尔·戴夫(<a class="ae ng" href="https://linktr.ee/prituldave" rel="noopener ugc nofollow" target="_blank">https://linktr.ee/prituldave</a></p></div></div>    
</body>
</html>