<html>
<head>
<title>Log Structured Merge Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日志结构化合并树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/log-structured-merge-tree-a8733ce152b2?source=collection_archive---------4-----------------------#2022-10-24">https://blog.devgenius.io/log-structured-merge-tree-a8733ce152b2?source=collection_archive---------4-----------------------#2022-10-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ccb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多 NoSQL 数据库背后的秘方</p><p id="bc54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">日志结构合并是许多现代 NoSQL 数据库中使用的一种重要技术，例如 BigTable、Cassandra、HBase、RocksDB 和 DynamoDB。它为长期经历高更新率的文件提供了低成本的索引。</p><p id="55a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写入首先进入内存中的平衡二叉树(红黑树或 Skiplist)。这种内存中的数据结构也称为 MemTable。在写入之前，会将条目附加到预写日志(WAL)文件中，以防止崩溃并确保持久性。当达到 MemTable 阈值时，WAL 被刷新并用新的替换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f923e188e889a062a95512adb9bd4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzWT7HGCKxBZGP649Zw6aw.png"/></div></div></figure><p id="c238" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当达到某个阈值时，Memtables 将作为已排序的字符串表(SSTable)刷新到磁盘。这些表是不可变的，并且使用顺序的磁盘 I/O。SSTable 由称为 Segment 的多个排序文件组成。SSTable 分为数据文件、索引文件和摘要文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/b09eb5b79f48b8a61ac0088def6e6de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNjscYxzZj7pgKhBd4c33Q.png"/></div></div></figure><h2 id="715d" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">表摘要文件</h2><p id="37d8" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">表摘要文件保存在内存中，并为索引文件中的快速查找提供了一个键示例。可以把它想象成一个表索引文件的索引。要搜索某个特定的键，首先要查阅摘要文件，找出可以找到该键的小范围位置，然后将该特定偏移量加载到内存中。</p><h2 id="06ec" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">表索引文件</h2><p id="ef5e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">索引文件按顺序列出数据文件中的键，给出每个键在数据文件中的位置。</p><h2 id="0828" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">稳定数据文件</h2><p id="3ff8" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">该表包含存储在称为块的块中的键值条目。这些数据文件是经过编码的。这些块也被压缩以节省磁盘空间。不同级别的压缩算法可能不同。对于数据完整性，使用校验和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lt"><img src="../Images/853373459b03db048a1be85e3ea8a307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKN8PJzojs9_7FoJJA8I6Q.png"/></div></div></figure><h2 id="60dd" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">压缩/合并表</h2><p id="9e30" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">压缩是一个后台过程，不断将旧数据段组合成新数据段。LSM 树的读写性能受压缩方式的影响很大。</p><blockquote class="lu lv lw"><p id="f721" class="jk jl lx jm b jn jo jp jq jr js jt ju ly jw jx jy lz ka kb kc ma ke kf kg kh ig bi translated">层压缩—写优化(Cassandra) <br/>级别压缩—读优化(RocksDB) <br/>时间窗口— InfluxDB <br/>快照压缩<br/>混合压缩— ScyllaDB</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/8c432b34ac6ea2573a7f550e7dc29f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1c3bywtvBTXtb7pcR4kC7Q.png"/></div></div></figure><p id="6c64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在实现方面，使用专用的后台线程来执行压缩。作为一种优化，可能有多个专用的压缩器线程在给定的时间点运行(如在 RocksDB 中)来压缩 SSTables 文件。压缩线程还负责在任何合并后更新稀疏索引，以指向新表文件中键的新偏移量。</p><h2 id="7a31" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">阅读 LSM</h2><p id="c737" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">我们首先搜索内存表。由于 MemTables 位于内存中，所以查找速度很快，如果我们在 Memtables 上找到任何数据，我们就将结果返回给客户机。如果 MemTables 上没有这个键，那么我们就在表中搜索这个键，Bloom filters 帮助我们缩小了搜索范围。我们会从最新的部分开始，然后回到最老的部分，直到找到我们要找的那个键。这意味着我们能够更快地检索最近写入的密钥。一个简单的优化是保持内存中的稀疏索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/63f6b01ee34d5db7b97f72c58435356c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GfxrnQnMLT-GW8ITnHY_w.png"/></div></div></figure><h2 id="f1d7" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">删除 LSM</h2><p id="d546" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">删除实际上遵循与写入数据完全相同的路径。每当接收到删除请求时，就会为该键写入一个称为<em class="lx"> tombstone </em>的唯一标记。最终，墓碑会被压缩掉，这样这个值就不再存在于磁盘上了。</p><h2 id="26be" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">LSM 树的缺点</h2><ul class=""><li id="bece" class="md me in jm b jn lo jr lp jv mf jz mg kd mh kh mi mj mk ml bi translated">压缩是资源密集型的</li><li id="3bf5" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">需要更多空间(即使删除也会增加存储)</li><li id="5323" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">读取速度较慢</li></ul><p id="f475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！！</p></div></div>    
</body>
</html>