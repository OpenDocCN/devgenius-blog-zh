<html>
<head>
<title>Why You Should Test Your Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该测试你的软件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-you-should-test-your-software-1745962351a8?source=collection_archive---------17-----------------------#2020-06-27">https://blog.devgenius.io/why-you-should-test-your-software-1745962351a8?source=collection_archive---------17-----------------------#2020-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件测试的简单介绍，为什么你应该这样做，为什么我们不想要100万亿个测试用例。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bda002c93973324380f7df02caeb4c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SVpFC4Ee2TD8xNFr"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><p id="eeeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">测试包括运行软件，以确定它是否在做它应该做的事情</strong>——并找到bug，即与目标行为的偏差。</p><p id="9c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">测试远不是处理软件质量的唯一活动。软件质量管理包括各种建设性的和分析性的措施。<br/>设计措施有助于从一开始就实现最高的质量。这些包括，例如，使用统一的风格指南，使用合适的开发工具，使用合适的设计原则，比如松耦合，使用设计模式，等等。<br/>另一方面，分析方法用于检查软件开发中创建的工件(草稿文档、源代码和可执行程序)。您寻找现有的问题和错误，以便可以在以后修复它们。这方面有许多程序，例如代码审查或确定质量相关的指标。这样的关键数字可以通过深层嵌套来评估代码的复杂性。过度的代码复杂性是不利的，因为它很容易导致错误。除了这些静态过程，测试作为一个动态过程在每个软件项目中扮演着重要的角色。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="2949" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">学习基础知识</h2><p id="2219" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">当我们谈到错误时，我们区分以下几点:</p><p id="d467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.<em class="ng">错误</em> —错误是指，例如，算法执行不正确。这也包括最终用户错误操作应用程序的情况！</p><p id="800a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<em class="ng">故障</em> —这包括在执行时导致故障的不正确子程序，也包括过载时损害整个系统功能的组件状态。</p><p id="bd74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<em class="ng">故障</em> —这是出现在外部的故障的影响。我们可以通过将实际值与预期目标值进行比较来发现这一点。</p><blockquote class="nh ni nj"><p id="826d" class="kw kx ng ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">不是每个错误都会导致失败！一种排序算法可以在美国公司中发挥数十年的巨大作用，但一旦被送到德国，它就会爆炸。为什么？因为实现不能处理变音。该死的。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="b8ae" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">测试阶段</h2><p id="188b" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">每个开发人员每天都在忙着测试自己刚写好的代码。如果你用Java写了一个新方法，你用一些示例性的值调用它，并检查它是否做了你期望它做的事情。你对此熟悉吗？这被称为单元测试(因为只检查了一个单元)。我们大致区分了开发阶段的三个不同级别的测试:</p><ul class=""><li id="e03e" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><strong class="ky ir">单元测试</strong>(单个方法、类和工件的测试)</li><li id="053a" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">集成测试</strong>(将现有的工件连接到被测试交互的子系统)</li><li id="e2e4" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">系统测试</strong>(测试整个系统)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7bc9f43040046505ce2c55e74e233dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B4LTnVCWdtydHWCf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从这三个层面着手。但是我们实际上从哪个角度来看待我们的系统呢？我们看到的是内部结构，还是客户也会看到的“发送”按钮？我们与众不同:</p><p id="675b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ng">白盒</em> </strong> <br/>我们洞察到了源代码的内部结构。这样，我们可以遍历代码中的所有分支，并确保所有方法和指令都被执行。</p><p id="1d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ng">灰色方框</em> </strong> <br/>我们来看不同的组件。例如，我们可以测试组件之间的接口。我们不再看到组件本身的内部结构。</p><p id="2e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ng">黑盒</em> </strong> <br/>我们的测试对象是一个黑盒。我们不知道内部结构，也不知道哪些组件以何种方式进行通信。我们只检查某些输入是否导致某些输出。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="b19e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">测试用例爆炸</h2><p id="b127" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">大家都喜欢爆款吧？嗯，不是在软件工程领域。尤其是在测试中。所以我们遇到了测试的一个基本问题:我们不能测试所有可能的情况。我们已经用最小的方法达到了这个极限，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/94f3bfc5afe6a5bd306e122ca11964eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*9wYvFLxdXLEDrZOMvidz6Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">测试用例展开示例</figcaption></figure><p id="959d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法有7个输入参数。如果我们想要完全测试，我们必须测试参数a到g的不同组合。我们必须浏览所有的指令。所以我们需要测试用例，其中<strong class="ky ir"> a &gt; b </strong>和那些<strong class="ky ir"> a &lt; = b </strong>。你看到if-else分支在循环的<strong class="ky ir">中了吗？热！因此，我们必须开发循环运行1-20次的测试用例，变量“完成”有不同的情况。我将为您保存一个控制流图。我们只做一个快速计算，所以每次计算后再看一遍代码。</strong></p><p id="63d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你遍历一次循环，有5条路径可以遍历。通过两次传递，已经有了⁵路径。如果我们在环路上走20次，我们可以走⁵ ⁰路。但是请记住，我们开发的测试用例中，循环运行了1、2、3、4……次。所以我们得到:5 + ⁵ + ⁵ + …+ ⁵ ⁰.这就产生了大约100万亿个测试用例。进一步阅读如何避免这种情况。</p><p id="e0d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">等价类</strong> <br/>我们把这一节缩短一点。你应该知道那是什么以及如何使用它。你可以就这个主题写一整本书。<br/>等价类的形成是一个<em class="ng">黑箱过程</em>。我们将所有可能的输入值集合划分为等价类。我们假设我们的测试对象对一个等价类中的所有值表现相同。<br/>下面以一个函数<em class="ng">计算绝对量</em>为例。对于正值(包括零)，它返回值本身，对于负值，它改变符号。<br/>如果我们想测试这个函数，我们只需输入一个(或多个)正值和一个(或多个)负值。你注意到这个错误了吗？我们只测试有效的输入值。<strong class="ky ir">但是我们也要对无效值形成等价类！</strong>这应该回答了以下问题:如果我们将值<em class="ng"> XY </em>传递给函数会发生什么？<em class="ng"> XY </em>可以是字符串或其他复杂数据类型，但也可以是值“null”。我们还应该查看等价类的<em class="ng">边界</em>以及这些边界附近的值，因为这些可以揭示错误。我们还检查超出范围的违规(例如，对于数据类型“int”)。</p><h2 id="f748" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">即将结束</h2><p id="1ded" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">在本文中，您了解到编写合适的测试并实现测试场景的良好覆盖并不容易。然而，你绝对应该试一试——有许多工具可以帮助你做到这一点。甚至免费社区版中的IntelliJ IDEs也能帮助Java开发人员编写单元测试——试试吧！</p></div></div>    
</body>
</html>