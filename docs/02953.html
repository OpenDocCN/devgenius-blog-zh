<html>
<head>
<title>Why is my fetch request to OAuth server being blocked by CORS? (CORS, Same Origin Policy, Making Cross Origin Requests with <form>)</form></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我对OAuth服务器的获取请求被CORS阻止了？(CORS，相同原产地政策，提出跨原产地请求</h1><form>)
<blockquote>原文：<a href="https://blog.devgenius.io/why-is-my-fetch-request-to-oauth-server-being-blocked-by-cors-c8bdadb92b30?source=collection_archive---------0-----------------------#2020-09-15">https://blog.devgenius.io/why-is-my-fetch-request-to-oauth-server-being-blocked-by-cors-c8bdadb92b30?source=collection_archive---------0-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d47cff175fbf2b07cf9007d5ec1074bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-2QrHNz8rYnd1BKvH4qyBw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">OAuth 2！</figcaption></figure><div class=""/><div class=""><h2 id="48cb" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">背景</h2></div><p id="3e67" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我花了相当多的时间试图让OAuth为一个集成了Google Drive API的编写应用程序工作。我遇到了CORS的一系列问题，并决定做一些关于CORS到底是什么的研究。我还学到了很多关于如何从浏览器向OAuth服务器发出请求的知识。如果你一直在努力学习CORS和OAuth 2.0，你可能会发现这些东西很有帮助。</p><h1 id="d3d1" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">同源策略</h1><p id="85c9" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">很快，在我们深入了解为什么我们需要CORS之前，我们需要了解同源政策。</p><p id="8b60" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">浏览器发出的所有请求都是使用<strong class="kw jg">同源策略</strong>发出的(除了我们将在后面介绍的一些方法)。</p><p id="f727" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这意味着从一个来源执行的代码不能访问不同来源的内容。<strong class="kw jg">代码的来源由(协议、域和端口)定义。</strong></p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="30dc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">“交叉”原产地请求的另一个示例:</p><p id="8b4a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">假设您在一个托管在<a class="ae mt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>的React应用程序上，并且您试图使用<code class="fe mu mv mw mx b">fetch</code>从位于<a class="ae mt" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000 </a>的API访问内容。这个请求将被web浏览器强制执行的SOP拒绝。(如果您已经开发了全栈应用程序，您可能已经使用CORS(跨源资源共享)来实现跨源访问。顾名思义，CORS是一种“放松”浏览器执行的SOP并允许跨来源资源共享的方式。我们一会儿就去CORS。)</p><h1 id="0344" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">为什么浏览器要强制执行SOP？</h1><p id="47df" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">出于安全考虑。</p><p id="f1d1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里有一个来自<a class="ae mt" href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important" rel="noopener ugc nofollow" target="_blank"> stackexchange </a>的回答，展示了同源策略是如何保护用户的。</p><blockquote class="my mz na"><p id="d4ac" class="ku kv nb kw b kx ky kg kz la lb kj lc nc le lf lg nd li lj lk ne lm ln lo lp ij bi translated">“为什么同源政策很重要？</p><p id="bb50" class="ku kv nb kw b kx ky kg kz la lb kj lc nc le lf lg nd li lj lk ne lm ln lo lp ij bi translated">假设您登录到脸书，并在另一个浏览器选项卡中访问了一个恶意网站。如果没有同源策略，该网站上的JavaScript可以对你的脸书账户做任何你被允许做的事情。例如阅读私人信息，发布状态更新，在提交表单前输入密码后分析HTML DOM树。</p><p id="a776" class="ku kv nb kw b kx ky kg kz la lb kj lc nc le lf lg nd li lj lk ne lm ln lo lp ij bi translated">当然，脸书希望使用JavaScript来提升用户体验。因此，浏览器能够检测到该JavaScript被信任来访问脸书资源是非常重要的。这就是同源策略发挥作用的地方:如果JavaScript包含在facebook.com的HTML页面中，它可能会访问facebook.com资源。</p><p id="e39b" class="ku kv nb kw b kx ky kg kz la lb kj lc nc le lf lg nd li lj lk ne lm ln lo lp ij bi translated">现在把脸书换成你的网上银行网站，很明显这是一个问题。"</p></blockquote><p id="0772" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">通过确保只能向发出请求的同一来源发出请求，浏览器能够保护用户信息免受恶意网站的攻击。</p><h1 id="ae47" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">CORS(跨产地资源共享)</h1><p id="59de" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">CORS允许我们放松浏览器强制的SOP。全CORS是一个过程，通过它我们可以安全地允许两个不同来源之间的资源共享。它的工作原理是<strong class="kw jg">在响应和请求</strong>中都指定额外的HTTP头。使用这些“CORS报头”，<strong class="kw jg"><em class="nb">浏览器</em>决定来源是否应该访问所请求的内容</strong>。</p><h1 id="bcc9" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">配置CORS</h1><p id="ff18" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">首先，内容服务器需要配置CORS，并指定哪些源应该能够从内容服务器访问内容——y<em class="nb">您也可以配置CORS，只允许某些内容，如方法(即获取、发布、删除)或标题(即内容类型)；为Access-Control-Allow-Origins指定</em> <code class="fe mu mv mw mx b"><em class="nb">*</em></code> <em class="nb">将允许来自所有来源的请求。查看文档，了解如何为后端服务器配置CORS。</em></p><p id="30b1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然后，请求者向服务器发送一个HTTP请求，HTTP头<code class="fe mu mv mw mx b">Origin</code>，HTTP请求模式设置为<code class="fe mu mv mw mx b">cors</code>(见下面的<code class="fe mu mv mw mx b">Sec-Fetch-Mode</code>)。</p><p id="1418" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">服务器将接收请求并返回一个响应，在消息头中包含CORS(例如<code class="fe mu mv mw mx b">Access-Control-Allow-Origin</code>、<code class="fe mu mv mw mx b">Access-Control-Allow-Methods</code>、<code class="fe mu mv mw mx b">Access-Control-Allow-Headers</code>)配置。</p><p id="3c5a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">看起来是这样的。</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f91dcb4144751582bcd4005f156944df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*JdkwfbRTm-mrG6EiGOTcfA.jpeg"/></div></figure><p id="cf05" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是用于生成该请求的代码。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6024" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一旦浏览器从内容服务器获得响应，它将比较响应和请求中的CORS报头。如果来源包含在<code class="fe mu mv mw mx b">Access-Control-Allow-Origin</code>中，并且满足所有其他<code class="fe mu mv mw mx b">Access-Control-Allow… </code>配置，浏览器将允许提供内容。否则，该请求将被CORS策略阻止。</p><p id="ed77" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里要做的一个重要区别是<strong class="kw jg"><em class="nb">浏览器</em>正在执行CORS政策</strong>，而不是内容服务器。请求服务器和内容服务器仅分别在HTTP请求和响应中包含额外的CORS报头。浏览器接收响应并确定CORS报头是否令人满意，从而确定是否应该提供内容。</p><h1 id="ad82" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">我们如何访问我们无法控制的服务器上的内容，例如OAuth服务器？</h1><p id="f8f4" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">配置CORS是允许不同来源访问服务器内容的简单方法，但是我们只能为我们控制的服务器配置CORS。</p><p id="a574" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果我们想要使用任何第三方API，我们很可能需要从OAuth服务器接收一个<code class="fe mu mv mw mx b">access_token</code>，而OAuth服务器不会将CORS配置为允许我们的应用程序的原始访问。</p><p id="8fb6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nb">边注:(如果你对OAuth 2.0的工作方式有任何困惑，我真的推荐你去看看这篇</em> <a class="ae mt" href="https://medium.com/@darutk/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb" rel="noopener"> <em class="nb">中的帖子，这篇帖子非常简单地解释了OAuth 2.0</em></a><em class="nb">)。</em></p><p id="db37" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从浏览器到OAuth服务器使用任何类型的获取API都会导致这个错误。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="c224" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">使用<form>向OAuth服务器提交跨来源请求</form></h1><p id="b9b4" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">一开始，我们说<em class="nb">几乎所有浏览器发出的请求都使用相同的起源策略。一些不实施同源策略的请求包括由标签<code class="fe mu mv mw mx b">&lt;script&gt;</code> <code class="fe mu mv mw mx b">&lt;img&gt;</code> <code class="fe mu mv mw mx b">&lt;forms&gt;</code> <code class="fe mu mv mw mx b">&lt;a&gt;</code> <code class="fe mu mv mw mx b">&lt;frame&gt;</code>和<code class="fe mu mv mw mx b">&lt;iframe&gt;</code>做出的请求。</em></p><p id="4a64" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由于OAuth服务器将授权代码作为重定向URL中的参数返回，我们可以使用类似于<code class="fe mu mv mw mx b">form</code>的标签向OAuth服务器发出跨源请求。(表单无法访问HTTP响应，但是对OAuth服务器的成功请求将简单地使用URL中的“response”进行重定向，因此表单非常适合使用)。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3c02" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Oauth请求经过服务器和用户授权后，会重定向到这个URL(我指定OAuth服务器重定向到的URL；您需要在您正在使用的API的Oauth凭证中对此进行配置)，</p><p id="34a3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe mu mv mw mx b"><a class="ae mt" href="http://localhost:3000/client#state=oauth&amp;access_token=myaccesstoken&amp;token_type=Bearer&amp;expires_in=3599&amp;scope=https://www.googleapis.com/auth/drive" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/client#state=oauth&amp;access_token=myaccesstoken&amp;token_type=Bearer&amp;expires_in=3599&amp;scope=https://www.googleapis.com/auth/drive</a></code></p><p id="9398" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在React中，我们可以使用<code class="fe mu mv mw mx b">qs</code>包和<code class="fe mu mv mw mx b">react-router-dom</code>中的<code class="fe mu mv mw mx b">history</code>轻松解析URL。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ca75" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们有了访问令牌，我们可以向google drive API发出请求了！</p><h1 id="3fdb" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">从这篇文章中学到的东西:</h1><ol class=""><li id="7af9" class="ng nh jf kw b kx mi la mj ld ni lh nj ll nk lp nl nm nn no bi translated">浏览器使用相同的起源策略，因此来自一个起源的Javascript不能访问来自另一个起源的内容。</li><li id="3bd9" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">CORS只是一种允许“跨来源”访问的机制。CORS通过请求方和响应方提供额外的“CORS报头”来工作。浏览器将查看请求/响应的CORS报头，并确定是否应该提供该内容。</li><li id="7890" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">像<code class="fe mu mv mw mx b">&lt;form&gt;</code> <code class="fe mu mv mw mx b">&lt;script&gt;</code> <code class="fe mu mv mw mx b">&lt;img&gt;</code>等标签都不用SOP。我们可以很容易地使用<code class="fe mu mv mw mx b">&lt;form&gt;</code>标记向OAuth服务器提交请求，并在URL中捕获响应。</li></ol><p id="f3c8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我希望这些材料中的一些能让使用CORS和配置Oauth 2.0变得简单一些。祝你编码好运！</p><h1 id="8b17" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">资源和进一步阅读材料:</h1><ul class=""><li id="76ab" class="ng nh jf kw b kx mi la mj ld ni lh nj ll nk lp nu nm nn no bi translated"><a class="ae mt" href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important" rel="noopener ugc nofollow" target="_blank">https://security . stack exchange . com/questions/8264/为什么同源政策如此重要</a></li><li id="9b52" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Security/Same-origin _ policy</a></li><li id="ca92" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></li><li id="6198" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://expressjs.com/en/resources/middleware/cors.html#simple-usage-enable-all-cors-requests" rel="noopener ugc nofollow" target="_blank">https://express js . com/en/resources/middleware/CORS . html # simple-usage-enable-all-CORS-requests</a></li><li id="8021" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://developers.google.com/identity/protocols/oauth2#clientside" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/identity/protocols/oauth 2 # client side</a></li><li id="1efc" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow#oauth-2.0-endpoints" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/identity/protocols/oauth 2/JavaScript-implicit-flow # oauth-2.0-endpoints</a></li><li id="f025" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://stackoverflow.com/questions/11423682/cross-domain-form-posting" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/11423682/跨域表单发布</a></li><li id="a947" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://www.itprotoday.com/web-application-management/javascript-same-origin-policy" rel="noopener ugc nofollow" target="_blank">https://www . itprotoday . com/we B- application-management/JavaScript-same-origin-policy</a></li><li id="d609" class="ng nh jf kw b kx np la nq ld nr lh ns ll nt lp nu nm nn no bi translated"><a class="ae mt" href="https://jvaneyck.wordpress.com/2014/01/07/cross-domain-requests-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://jvaneyck . WordPress . com/2014/01/07/cross-domain-requests-in-JavaScript/</a></li></ul></div></div>    
</form></body>
</html>