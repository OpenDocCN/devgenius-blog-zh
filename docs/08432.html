<html>
<head>
<title>How we built a Trello clone with Wasp — Waspello!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何用 Wasp 构建了一个 Trello 克隆体——Waspello！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-we-built-a-trello-clone-with-wasp-waspello-a87ad9864d43?source=collection_archive---------13-----------------------#2022-06-14">https://blog.devgenius.io/how-we-built-a-trello-clone-with-wasp-waspello-a87ad9864d43?source=collection_archive---------13-----------------------#2022-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2449c7b1ee161a79f70f2152a73efe61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ze9Mh9CyC0rIEK5dVIDYHg.png"/></div></div></figure><p id="27f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用 Wasp 造了一个 Trello 克隆体！请继续阅读，了解进展情况以及您可以如何做出贡献。</p><p id="6a58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://waspello.netlify.app/" rel="noopener ugc nofollow" target="_blank">试试这里的 Waspello！</a> | <a class="ae kt" href="https://github.com/wasp-lang/wasp/blob/main/examples/waspello/main.wasp" rel="noopener ugc nofollow" target="_blank">参见代号</a></p><p id="cf9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> Wasp 是一种配置语言(DSL ),用于使用更少的代码和最佳实践构建全栈 web 应用，与 React 和 Node.js 一起工作。我们的使命是简化 web 应用开发，同时使开发人员能够继续使用代码和他们喜爱的工具的力量。我们得到了 Y Combinator 和来自 Airbnb、脸书和 Lyft 的工程师的支持。</em></p><p id="e0c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://bit.ly/3Mo0Gu6" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">我们在 Alpha(试用)！</strong> </a> → <a class="ae kt" href="https://discord.gg/rzdnErX" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">加入我们的社区</strong> </a> → <a class="ae kt" href="https://wasp-lang.notion.site/Founding-Engineer-at-Wasp-402274568afa4d7eb7f428f8fa2c0816" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">与我们一起工作</strong> </a></p><h1 id="f27c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">为什么是特雷罗？</h1><p id="aa5c" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在构建 Wasp 时，我们的目标是尽可能多地使用它来构建我们的项目并使用它，这样我们就可以了解什么是有效的，以及我们下一步应该做什么。这就是为什么 Trello 是使用 Wasp 构建应用程序的最佳选择——它是最知名的全栈 web 应用程序之一，使用起来非常简单直观，而且涵盖了当今现代 web 应用程序所使用的大部分功能。</p><p id="c14f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们深入研究一下，看看效果如何——哪些可行，哪些不可行，接下来还会有什么遗漏/即将出现！</p><h1 id="ec29" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么管用？</h1><h1 id="fe7a" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">它是活的⚡🤖！！</h1><p id="3674" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">好消息是所有的基本功能都在这里——Waspello 用户可以注册/登录，这将他们带到他们的项目板，在那里他们可以对列表和卡片执行 CRUD 操作——创建它们，编辑它们，移动它们，等等。让我们来看看它的实际应用:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/bd0659fe21fa5b368c9028a986707975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DDWErB5DpB7UFird.gif"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">瓦斯佩洛在行动！</figcaption></figure><p id="c17e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，一切都正常，但并不是一切都完美(例如，创建/移动卡片时会有延迟)——稍后我们将研究为什么会这样。</p><h1 id="8d4b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在后台🚘 🔧</h1><p id="adf7" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">以下是 Waspello 代码剖析的简单可视化概述(适用于每个 Wasp 应用程序):</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/80c259d32b9f180b0a4509398f97124f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iullk3NEIZ1magq7.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">瓦斯佩洛代码解剖学</figcaption></figure><p id="6511" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们更深入地研究一下 Wasp 支持的每个概念(页面、查询、实体等等)，并通过代码示例了解如何使用它来实现 Waspello。</p><h2 id="54cd" class="mi kw in bd kx mj mk dn lb ml mm dp lf kg mn mo lj kk mp mq ln ko mr ms lr mt bi translated">实体</h2><p id="438c" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">这一切都始于数据模型定义(在 Wasp 中称为<code class="fe mu mv mw mx b">entity</code>),它是通过 Prisma 模式语言定义的:</p><p id="14f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">main.wasp |通过 Prisma 模式语言定义实体:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="5cc0" class="mi kw in mx b gy nc nd l ne nf">// Entities</span><span id="6ad5" class="mi kw in mx b gy ng nd l ne nf">entity User {=psl<br/>   id          Int     @id @default(autoincrement())<br/>   email       String  @unique<br/>   password    String<br/>   lists       List[]<br/>   cards       Card[]<br/>psl=}</span><span id="e11b" class="mi kw in mx b gy ng nd l ne nf">entity List {=psl<br/>   id          Int     @id @default(autoincrement())<br/>   name        String<br/>   pos         Float</span><span id="7766" class="mi kw in mx b gy ng nd l ne nf">   // List has a single author.<br/>   user        User    @relation(fields: [userId], references: [id])<br/>   userId      Int<br/>   cards       Card[]<br/>psl=}</span><span id="c00c" class="mi kw in mx b gy ng nd l ne nf">entity Card {=psl<br/>   id          Int     @id @default(autoincrement())<br/>   title       String<br/>   pos         Float</span><span id="54b2" class="mi kw in mx b gy ng nd l ne nf">   // Card belongs to a single list.<br/>   list        List    @relation(fields: [listId], references: [id])<br/>   listId      Int</span><span id="eaf2" class="mi kw in mx b gy ng nd l ne nf">   // Card has a single author.<br/>   author      User    @relation(fields: [authorId], references: [id])<br/>   authorId    Int<br/>psl=}</span></pre><p id="070e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这三个实体就是我们所需要的！Wasp 使用 Prisma 在底层创建数据库模式，并允许开发人员通过其生成的 SDK 查询它。</p><h2 id="876e" class="mi kw in bd kx mj mk dn lb ml mm dp lf kg mn mo lj kk mp mq ln ko mr ms lr mt bi translated">查询和操作(操作)</h2><p id="37a8" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在我们定义了数据模型之后，下一步就是用它们做点什么！我们可以读取/创建/更新/删除一个实体，这就是<code class="fe mu mv mw mx b">query</code>和<code class="fe mu mv mw mx b">action</code>机制的作用。下面是 Waspello 代码的一个例子，演示了它是如何工作的。</p><p id="a712" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是向 Wasp 声明将有一个查询，指向包含查询逻辑的实际函数，并说明它将从哪些实体读取信息:</p><p id="21d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">main.wasp |中查询的声明:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="5a7a" class="mi kw in mx b gy nc nd l ne nf">query getListsAndCards {</span><span id="4309" class="mi kw in mx b gy ng nd l ne nf">   // Points to the function which contains query logic.<br/>   fn: import { getListsAndCards } from "@ext/queries.js",</span><span id="201b" class="mi kw in mx b gy ng nd l ne nf">   // This query depends on List and Card entities.<br/>   // If any of them changes this query will get re-fetched (cache invalidation).<br/>   entities: [List, Card]<br/>}</span></pre><p id="b826" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个声明的要点是让 Wasp 知道这个查询，从而能够<strong class="jx io">为我们做很多繁重的工作——例如，它将在没有任何额外代码</strong>的情况下为客户端提供查询，开发人员需要做的就是将它导入到他们的 React 组件中。<strong class="jx io">另一件大事是一旦数据改变，缓存失效/自动重新获取查询</strong>(这就是为什么声明它依赖于哪些实体很重要)。</p><p id="5627" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的步骤是用查询逻辑编写函数。</p><p id="4d15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ext/Query . js |查询逻辑，通过 Node.js 使用 Prisma SDK</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="05c7" class="mi kw in mx b gy nc nd l ne nf">export const getListsAndCards = async (args, context) =&gt; {</span><span id="892b" class="mi kw in mx b gy ng nd l ne nf">   // Only authenticated users can execute this query.<br/>   if (!context.user) { throw new HttpError(403) }</span><span id="38ad" class="mi kw in mx b gy ng nd l ne nf">   return context.entities.List.findMany({<br/>      // We want to make sure user can access only their own cards.<br/>      where: { user: { id: context.user.id } },<br/>      include: { cards: true }<br/>   })<br/>}</span></pre><p id="ef6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是一个普通的 Node.js 函数，你可以返回的内容没有限制！Wasp 提供的所有东西(用户数据，特定实体的 Prisma SDK)都包含在一个<code class="fe mu mv mw mx b">context</code>变量中。</p><p id="c4ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">动作代码非常相似(我们只需要使用<code class="fe mu mv mw mx b">action</code>关键字代替<code class="fe mu mv mw mx b">query</code>)，所以我在这里不再重复。您可以在这里查看<code class="fe mu mv mw mx b">updateCard</code>动作<a class="ae kt" href="https://github.com/wasp-lang/wasp/blob/main/examples/waspello/main.wasp#L103" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><h2 id="aeb4" class="mi kw in bd kx mj mk dn lb ml mm dp lf kg mn mo lj kk mp mq ln ko mr ms lr mt bi translated">页面、路由和组件</h2><p id="31ec" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">为了显示我们所有的好数据，我们将使用反应组件。在 Wasp 中如何使用 React 组件没有限制，唯一的限制是每个<code class="fe mu mv mw mx b">page</code>都有它的根组件。</p><p id="1eaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">main.wasp |中的页面和路线声明:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="31ad" class="mi kw in mx b gy nc nd l ne nf">route MainRoute { path: "/", to: Main }<br/>page Main {<br/>   authRequired: true,<br/>   component: <em class="ku">import</em> Main <em class="ku">from </em>"@ext/MainPage.js"<br/>}</span></pre><p id="eeef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，一切都很简单！正如您在这里看到的，Wasp 还提供了<a class="ae kt" href="https://wasp-lang.dev/docs/language/features#authentication--authorization" rel="noopener ugc nofollow" target="_blank">即用型认证</a>。</p><p id="3b8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，Waspello 的大部分客户端逻辑都包含在<code class="fe mu mv mw mx b">ext/MainPage.js</code>中(我们应该对其进行一些分解)😅- <a class="ae kt" href="https://github.com/wasp-lang/wasp/issues/334" rel="noopener ugc nofollow" target="_blank">你可以帮助我们！</a>)。为了给你一个主意，这里有一个简单的介绍。</p><p id="7940" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ext/MainPage.js |在 Wasp 中使用反应组件:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="59c3" class="mi kw in mx b gy nc nd l ne nf"><em class="ku">// "Special" imports provided by Wasp.<br/>import</em> { useQuery } <em class="ku">from</em> '@wasp/queries'<br/><em class="ku">import</em> getListsAndCards <em class="ku">from</em> '@wasp/queries/getListsAndCards'<br/><em class="ku">import</em> createList <em class="ku">from</em> '@wasp/actions/createList' </span><span id="eaca" class="mi kw in mx b gy ng nd l ne nf"><em class="ku">const</em> MainPage = ({ user }) =&gt; {  <br/>   <em class="ku">// Fetching data via useQuery.</em>  <br/>   <em class="ku">const</em> { data: listsAndCards, isFetchingListsAndCards, errorListsAndCards } = useQuery(getListsAndCards)<br/>  <br/>   <em class="ku">// A lot of data transformations and sub components.</em>  <br/>   ...   </span><span id="873f" class="mi kw in mx b gy ng nd l ne nf"><em class="ku">   // Display lists and cards.<br/>   return</em> (<br/>   ...  <br/>   )<br/>}</span></pre><p id="6e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦您如上所述定义了一个查询或动作，您可以通过在导入路径中使用前缀<code class="fe mu mv mw mx b">@wasp</code>立即将其导入到您的客户机代码中，如代码示例所示。<code class="fe mu mv mw mx b">useQuery</code>确保反应性，这样一旦数据改变，查询将被重新获取。你可以在这里找到更多关于<a class="ae kt" href="https://wasp-lang.dev/docs/language/features#usequery" rel="noopener ugc nofollow" target="_blank">的细节。</a></p><p id="0a68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这几乎是它的工作原理😄！我在这里讲得有点仓促——关于 Wasp 所有特性的更多细节，以及用 Wasp 构建你的第一个应用，请查看我们的<a class="ae kt" href="https://wasp-lang.dev/docs" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="cf10" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么(还)不起作用</h1><p id="c9cd" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">Waspello 当前实现的主要问题是 Wasp 中缺乏对乐观 UI 更新的支持。这意味着，当前，当进行与实体相关的更改时(例如，将一张卡片从一个列表移动到另一个列表)，我们必须等待，直到该更改在服务器上完全执行，直到它在 UI 中可见，这导致了明显的延迟。<br/>在许多情况下，这并不是问题，但是当用户界面元素一次全部可见，并且期望它们立即更新时，这一点就很明显了。这也是我们选择在 Waspello 上工作的主要原因之一——为这个特性建立一个基准/沙箱！由于这个问题，以下是目前的情况:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d453853c8ffe5891d842b227926f9386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/0*0onoDbGTMbImudac.gif"/></div></figure><p id="82b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以注意到从卡片被放入“完成”列表到它成为该列表的一部分之间的延迟。原因是，在将卡放入“完成”列表的时候，带有更改的 API 请求被发送到服务器，只有当更改在服务器上被完全处理并保存到数据库时，查询<code class="fe mu mv mw mx b">getListsAndCards</code>才返回正确的信息，因此，UI 被更新到正确的状态。<br/>这就是为什么在点击“Done”时，卡首先返回到原始列表(因为更改还没有保存在 db 中，所以<code class="fe mu mv mw mx b">useQuery(getListsAndCards)</code>仍然返回“旧”状态)，它等待一段时间，直到 API 请求被成功处理，就在这时，更改在 UI 中得到反映。</p><h2 id="a8bf" class="mi kw in bd kx mj mk dn lb ml mm dp lf kg mn mo lj kk mp mq ln ko mr ms lr mt bi translated">解决方案</h2><p id="6553" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">解决这个问题的一个典型方法是让客户端更加自信，不要等待来自服务器的确认，而是立即更新 UI，同时甚至在 API 请求被触发之前。如果后来发现服务器出了问题(这通常是不应该发生的)，它会撤销更改并显示一条错误消息。因此，名称乐观的用户界面更新，因为客户端预先假设一切将顺利提供一个更好的 UX。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1f23eb789cc8b1f9ed12f4c9c67a64ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*SmIHnrPU2z0pW7B1.gif"/></div></figure><p id="b988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是当今开发 web 应用程序时最复杂和最容易出错的特性之一，这就是为什么我们非常兴奋能在 Wasp 中解决它，并使体验尽可能流畅！我们目前处于“找出解决方案”阶段，您可以<a class="ae kt" href="https://github.com/wasp-lang/wasp/issues/63" rel="noopener ugc nofollow" target="_blank">在 GitHub </a>上跟踪/加入讨论！</p><h1 id="c7db" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">缺少什么(下一个功能)</h1><p id="11f4" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">虽然乍一看起来超级简单，但 Trello 实际上是一个巨大的应用程序，在表面下隐藏着许多非常酷的功能！以下是 Waspello 目前不支持的一些比较明显的功能:</p><ul class=""><li id="3e3c" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">用户可以拥有多个板，用于不同的项目(目前我们在 Waspello 中根本没有“板”实体的概念，所以只有一个)</li><li id="80d3" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">详细的卡片视图—单击卡片时，会打开带有额外选项的“完整”视图</li><li id="44f3" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">搜索—用户可以搜索特定的列表/卡片</li><li id="205e" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">协作—多个用户可以参与同一个讨论板</li></ul><p id="fa81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有更多—例如支持工作区(层次结构的下一层，一组电路板)、卡片标签、过滤器等等。拥有如此多样的特性非常有帮助，因为我们可以将它作为 Wasp 的试验场，并将其作为 Beta/1.0 的导航星！</p><h1 id="bc92" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">成为一名 Waspeller！</h1><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/05f4e4fb61c471dd8108a673ad90b19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*CuuIcCvNqNOzxO8T.png"/></div></figure><p id="114c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想参与 OSS 并同时熟悉 Wasp，这是一个很好的开始方式——请随意<a class="ae kt" href="https://github.com/wasp-lang/wasp/issues/337" rel="noopener ugc nofollow" target="_blank">选择这里列出的一个功能或添加你自己的</a>,帮助我们使 Waspello 成为最好的演示生产力应用程序！</p><p id="95fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，请确保<a class="ae kt" href="https://discord.gg/rzdnErX" rel="noopener ugc nofollow" target="_blank">加入我们的不和谐社区</a>。我们一直在那里，并期待着看到你的建设！</p><p id="ef6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://bit.ly/3Mo0Gu6" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">我们在 Alpha(试用)！</strong> </a> → <a class="ae kt" href="https://discord.gg/rzdnErX" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">加入我们的社区</strong> </a> → <a class="ae kt" href="https://wasp-lang.notion.site/Founding-Engineer-at-Wasp-402274568afa4d7eb7f428f8fa2c0816" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">与我们一起工作</strong> </a></p></div></div>    
</body>
</html>