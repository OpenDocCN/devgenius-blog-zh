<html>
<head>
<title>Introducing Prototypes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 中引入原型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introducing-prototypes-in-javascript-b2353028d470?source=collection_archive---------6-----------------------#2022-04-29">https://blog.devgenius.io/introducing-prototypes-in-javascript-b2353028d470?source=collection_archive---------6-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b219" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">面向初学者的原型概念的可视化介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4d94bd6bbb8cb7a7698f057c68ef764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMzE24eqRAMyCVrra2QzLg.jpeg"/></div></div></figure><h2 id="1843" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">面向对象的 JavaScript</h2><p id="2f88" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">虽然 JavaScript 不是基于类的语言，也没有实现传统意义上的面向对象编程，但它确实提供了使我们能够使用面向对象编程概念的特性和模式。我们可以称之为<strong class="lp ir">原型继承</strong>。</p><h2 id="d038" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">JavaScript 中的原型是什么？</h2><p id="a544" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">JavaScript 中原型的核心概念是一个对象可以从另一个对象继承属性或方法。如果你考虑下面的家谱，在底部的人与在顶部的一个人联系在一起，你可以沿着这条路线一步一步向上到达顶部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/4a454d045d38e2139b9d75d0aa23a07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CbxBQyzIp4RYwA5Cd1uEg.jpeg"/></div></div></figure><p id="ee39" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在 JavaScript 中，你可以把一个原型想象成一个蓝图、一个模板或者一个包含方法的基本对象，所创建的对象的任何实例都可以访问这些方法。如果我们没有原型，那么我们将不得不在一个对象的每一个实例上定义方法，这将不是非常有效的，它将消耗大量的内存。</p><p id="021d" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">有两个原型，我们需要了解原型属性和对象原型本身。让我们从原型属性开始。</p><h2 id="d92b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">原型属性</h2><p id="251e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">当我们在数组上使用诸如<em class="mm"> pop </em>或<em class="mm"> includes </em>之类的 JavaScript 方法时，我们使用的是 JavaScript 内的内置方法。让我们从视觉上来看。我们可以从访问数组原型构造函数的原型属性开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/d25c562d79c040670350d4a2f887a451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvR9DrCv4I9ZQ67KEkTNgw.png"/></div></div></figure><p id="54a6" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">现在让我们创建一个数组，看看如何在数组内部查看 prototype 属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/993632ce05a95da7fecacd693ec9035f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*X-9KqxLdStXvVQ2Wi8FZKQ.png"/></div></figure><p id="0579" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在上面的例子中，一个名为<em class="mm"> ourArray </em>的变量被声明并用一个包含值 1、2 和 3 的数组初始化。之后，我们的<em class="mm">阵列</em>被检查。当我们想从数组末尾移除一个元素时，我们可以使用<em class="mm"> pop </em>方法。这是从哪里来的呢？让我们再检查一下我们的阵列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/d43a4d03c013a95a00e1952a3ac67a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGj4sJsbC0juWffwwmgJkQ.png"/></div></div></figure><p id="affc" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">JavaScript 中的每个对象都有一个<em class="mm"> [[Prototype]] </em>属性。这是一个内部属性，由包围它的双括号表示。当我们选择[[Prototype]]属性时，我们可以看到可用的方法，在我们的例子中，这些方法继承自数组构造函数。我们还可以使用方法<em class="mm"> getPrototypeOf </em>，该方法将返回给定对象的<em class="mm"> [[Prototype]] </em>属性(记住数组是一种特殊类型的对象)。</p><p id="1c7a" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">值得注意的是，你可能会遇到使用<em class="mm"> __proto__ </em>的例子。这是一个遗留特性，eslint 有一个规则(no-proto)来防止它的使用。<em class="mm"> __proto__ </em>属性公开一个对象的内部<em class="mm"> [[Prototype]] </em>。最好使用如下图所示的<em class="mm"> getPrototypeOf </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/a7b77087a9cb5b381340fcaed709aaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0wdiqz6kTKQTT-RMaGuDw.png"/></div></div></figure><p id="38b0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我们可以将此与<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> mdn </a>网站上列出的方法进行对比。所以，所有的数组都可以访问这些方法，但是它们本身并没有这些方法的属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/60ce24cd9edbea53793b9d0630f7ace9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDjHalR8an_egQRzKlsqLA.png"/></div></div></figure><p id="cac0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这些是每个数组都可以使用的方法，但是这些方法不是在每个数组中单独定义，而是在原型对象上定义。这并不特定于数组，也适用于 JavaScript 中的其他内置对象。我们也可以在创建对象时使用它。</p><h2 id="7329" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">这一切怎么可能？</h2><p id="cf76" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">作为<em class="mm">[[原型]] </em>属性的值的对象是我们正在检查的任何对象的原型。如果不存在，它将为空。当我们在<em class="mm">我们的数组</em>上使用<em class="mm"> pop </em>方法时，JavaScript 解释器最初会在<em class="mm">我们的数组</em>上寻找该方法。当它在那里找不到它时，它将在原型上寻找。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/d1226d208acd1b563ceb42e390efec8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzYZ9LuBNdjA1G7jgNpdTg.jpeg"/></div></div></figure><p id="b2f6" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我们称这个过程为<em class="mm">原型继承</em>或<em class="mm">原型链</em>。这个过程可以一直持续下去，但是最好不要创建复杂的链，因为调试它会变得令人困惑。使用原型链，你可以只在一个对象上存储一个函数，如果解释器在第一个对象中找不到它，它就会查找这个对象。让我们看一些代码中的例子。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="31eb" class="kr ks iq mu b gy my mz l na nb">function GameTracker(name, result) {<br/>  this.name = name;<br/>  this.result = result;<br/>}</span></pre><p id="2e84" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在上面的代码中，我们用参数<em class="mm"> name </em>和<em class="mm"> result </em>声明了一个名为<em class="mm"> GameTracker </em>的构造函数。当它被存储在内存中时，它被存储为一个带有对象的函数。该对象有一个空对象的原型属性。任何使用 GameTracker 构造函数创建的函数都可以访问 prototype 属性。在函数内部，我们使用这个函数设置了<em class="mm">名称</em>和<em class="mm">结果</em>，因此它们引用对象的当前实例。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="87ad" class="kr ks iq mu b gy my mz l na nb">let playerOne = new GameTracker("Fred", 8);</span></pre><p id="85f5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">接下来，我们创建一个名为<em class="mm"> playerOne </em>的变量，它最初是未初始化的。然后通过使用 new 关键字，创建了一个新的游戏追踪器实例。当我们使用<em class="mm"> new </em>关键字时，prototype 属性被设置，这将是对 GameTracker 对象的引用。如果我们检查 playerOne，我们将看到以下内容。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="ce1b" class="kr ks iq mu b gy my mz l na nb">console.log(playerOne);<br/>//Returns ---&gt; GameTracker {name: 'Fred', result: 8}</span></pre><p id="18db" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">现在让我们试着找出 playerOne 的构造函数。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="96a5" class="kr ks iq mu b gy my mz l na nb">Object.getPrototypeOf(playerOne);</span><span id="17f8" class="kr ks iq mu b gy nc mz l na nb">//Returns ---&gt; <strong class="mu ir">constructor</strong>: <em class="mm">ƒ GameTracker(name, result)</em></span></pre><p id="1408" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">使用原型，我们可以向原型添加一个方法。我们将添加一个开始我们的游戏。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="caf0" class="kr ks iq mu b gy my mz l na nb">GameTracker.prototype.start = function() {<br/>  return `Hello ${this.name} the game is ready.`;<br/>}</span></pre><p id="6f4a" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">现在让我们再次检查 playerOne 对象。我们可以看到启动功能存储在原型中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/431b37b1fb8605be2a846b7e1837b893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvFnVBxkjaiiir11UGG4eg.png"/></div></div></figure><p id="fd52" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">所以我们可以使用 playerOne 上的启动功能。让我们试一试。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="6633" class="kr ks iq mu b gy my mz l na nb">playerOne.start();</span><span id="ec9d" class="kr ks iq mu b gy nc mz l na nb">//Returns ---&gt; 'Hello Fred the game is ready.'</span></pre><p id="caab" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我希望你喜欢阅读这篇文章。请随时发表任何评论、问题或反馈，并关注我以获取更多内容！</p><ul class=""><li id="ac7a" class="ne nf iq lp b lq mh lt mi la ng le nh li ni mf nj nk nl nm bi translated"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array</a></li></ul></div></div>    
</body>
</html>