<html>
<head>
<title>Analyzing Application and Infrastructure Logs With SQL (No Parsers Needed)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL分析应用程序和基础架构日志(不需要解析器)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/analyzing-application-logs-with-sql-2c607ba8d39e?source=collection_archive---------16-----------------------#2022-01-18">https://blog.devgenius.io/analyzing-application-logs-with-sql-2c607ba8d39e?source=collection_archive---------16-----------------------#2022-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/84084ea462a132127742a3c03052ee65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qq_cXDPpNqexRBfOycCdJQ.jpeg"/></div></div></figure><h1 id="1cea" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="c412" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这篇文章是为SQL爱好者写的，他们喜欢SQL，喜欢使用它的能力，并且很少遇到集成问题，以便从所有可用的工件中获得洞察力。我将展示如何轻松地对应用程序和基础设施日志运行特定的SQL查询，筛选出嵌入日志中的金块信息，并将其与存储在数据仓库中的数据结合起来，以分析和预测系统健康和用户旅程。事实证明，要实现这一点，除了您喜欢的RDBMS之外，您不一定需要专业工具。要了解如何做，请继续阅读。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="5803" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">当我们将业务逻辑处理委托给短暂的云容器或SaaS服务(如AWS Lambda)时，分析应用程序日志的能力在无服务器计算的现代时代非常重要。该行业通过仔细检查和监控应用程序和基础架构日志及遥测技术，确立了生产环境故障排除的最佳实践。然而，随着应用程序及其组件的复杂性和粒度不断增加，传统的grep向导无法扩展，需要延长故障排除SLA。</p><p id="b2c7" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">首先，让我们检查一下现实:这里没有魔法。通常，专注于满足最后期限的工程师和经理对自己撒谎，并在过程中误导他们的业务和领导。他们相信一旦每个组件都建立了日志记录(检查！)，系统投产时一切都会在掌控之中(成功！)… <em class="md">如果我们遇到意料之外的边缘情况(这怎么可能呢！？)，通过查看日志就可以很容易地缩小问题的范围。没什么好担心的！</em> …直到有了<em class="md">。</em>我过去共事过的许多非常聪明的人都成了这种自我欺骗的受害者——所以我想分享一些技巧，告诉你如何利用你很可能已经拥有的系统，以最小的代价控制局面。</p><p id="d4fc" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">在复杂系统的世界中，通常有许多服务和不连贯的子系统记录有价值的遥测和业务逻辑信息。没有事先的设计，推断独立记录的事实之间的相关性是很困难的。许多人提到了AWS云观察或其他云服务的力量，它们可以在需要时提供帮助。这让我想起了以前的好时光，那时XML开始流行，许多人认为只要在他们的文档和有效载荷中放上尖括号，他们所有的问题都可以解决。不幸的是，情况并非如此，如果系统的架构不合理，最终会花费更多的成本——不管是在本地还是在云中，也不管您使用什么数据存储格式。</p><p id="e779" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">如果您没有提前考虑、建模和设置所有子系统的日志记录，那么一旦工程兴奋和音乐停止，真正的生产工作负载开始，就很难理解记录的数据。当生产问题陷入困境时，你想成为沃森，而不是夏洛克。用放大镜浏览所有子系统是一项艰难的侦查工作——它可能带来一些工作保障，但总体项目可能会失败。您希望将故障排除的成本和时间降至最低。</p><h1 id="17e1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">“日志优先”模式</h1><p id="8466" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">流行的"<a class="ae me" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试优先</a>"工程范例对于确保我们考虑已知的测试用例是很棒的。我在这里描述的是一个“日志优先”的工程范例，旨在减轻系统的未知和意外的健康问题和边缘情况，使您能够在最终用户升级之前检测到它们。</p><p id="b45b" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">当然，我们需要做的第一件事是在我们所有的子系统中建立日志记录，并弄清楚如何将日志从服务器和容器传输到一个集中的存储。但这只是一个非常基本的勾号，会造成一种虚假的自信感。细节决定成败。以下是我建议遵循的一些规则:</p><ol class=""><li id="46de" class="mf mg in kv b kw ly la lz le mh li mi lm mj lq mk ml mm mn bi translated">在交易系统中，有许多活动的部分和维度，如用户交互、分布式交易、客户、账户、活动等。，<strong class="kv io">日志可以帮助追踪这些物体的行程和生命周期</strong>。为此，我们需要将这些对象和事务的元数据合并到跨前端、中间层和后端发出的日志中，这将允许跨所有应用层跟踪沿袭和执行根本原因分析。</li><li id="e988" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">不同的系统可能独立发展——用不同的语言编写，遭受不同数量的技术债务，等等。—因此，标准化日志结构和格式可能超出了我们的控制范围，但这种情况仍然是可以管理的。重要的不是<em class="md">如何创建</em>日志，而是<em class="md">记录了什么</em>。<strong class="kv io">如果关键信息(如公共对象和事务的标识符)被记录，我们将找到一种方法来提取知识并加以利用。</strong></li></ol><blockquote class="mt mu mv"><p id="0710" class="kt ku md kv b kw ly ky kz la lz lc ld mw ma lg lh mx mb lk ll my mc lo lp lq ig bi translated">当心建造巴别塔的风险:如果整体的各个部分在关键时刻不能相互理解，那么整个系统就可能分崩离析。当提到共同的关键对象和事件时，所有子系统应该使用相同的词汇和术语。确保这是在控制之下，否则你将需要处理大量的技术债务。</p></blockquote><p id="271e" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">以下是一些需要考虑的其他挑战:</p><ol class=""><li id="936c" class="mf mg in kv b kw ly la lz le mh li mi lm mj lq mk ml mm mn bi translated">您可以控制您的团队设计的系统，但是您对第三方组件和服务的控制较少。</li><li id="890f" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">大量不重要的日志记录会产生噪音，浪费空间，并减慢系统进程。确保在迁移到生产环境时，应用程序日志包含所有必要的信息，但不要超出必要的范围。这就是艺术。</li></ol><p id="d2a9" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">此外，设计良好的日志架构为我们提供了分析用户、事务、批处理作业、项目等的数据。一旦与我们的数据湖中的核心交易和参考数据集成，我们就可以在复杂的业务逻辑计算和机器学习算法中利用从日志中提取的知识。这给了我们额外的能力来推导事件和异常值之间的相关性，学习和计算预测，并推动建议。<strong class="kv io"> <em class="md"> </em>一个设计良好的日志记录系统是一个强大的工具，可以发现异常的根本原因，并在用户受到影响之前预测潜在的问题。</strong></p><h1 id="39d2" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">技术方法</h1><p id="13e4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">关于如何实际发出日志的技术细节和最佳实践超出了本文的范围。有很多很棒的日志工具和库，比如<a class="ae me" href="https://www.loggly.com/docs/java-log4j/" rel="noopener ugc nofollow" target="_blank"> log4j </a>、<a class="ae me" href="https://www.loggly.com/docs/net-logs/" rel="noopener ugc nofollow" target="_blank"> log4net </a>、apache logs等等。(如果你还没有使用它们)你可以通过搜索网络和这里的<a class="ae me" href="https://medium.com/search?q=application%20logging" rel="noopener">媒体</a>找到。重要的是，您对感兴趣的领域有一个标准的模式，并且您的所有应用程序都遵循既定的标准，无论它们是用Java、C/C++、Python、Go还是其他语言编写的。</p><p id="10de" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">现在，您的系统正在生成日志，您需要一个日志分析解决方案。有许多强大的供应商工具专注于日志分析和托管日志解决方案。他们收取这么高的费用是有原因的——看看Gartner和其他咨询公司的一些优秀供应商评论。但是，有时成本(许可证、额外的基础设施、额外的技术技能和时间)可能不值得投资。此外，有时您需要一个定制的解决方案和与现有系统集成的能力，这是商业日志解析和分析工具不容易支持的。</p><p id="7d7e" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">在本文中，我们将研究如何在现有的数据仓库中接收和分析日志。我们将在日志文件上创建示例SQL视图，这些视图可以在分析查询中用来监视、分析和排除生产系统的故障。我还将向您展示如何使用Postgres实现日志优化。一旦您熟悉了这种方法，您应该能够轻松地将其扩展到其他系统(基于MySQL的系统、雪花系统、Redshift系统、BigQuery系统、SQL Server系统、Oracle系统等)。).</p><p id="01a0" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">这里介绍的简单解决方案基于在Xcalar开发的工作(在Xcalar，我领导一个产品工程团队开发一个计算平台，以加速云规模数据应用程序的开发和运营)。目标是在Xcalar数据引擎本身中处理多个子系统的日志，因为它从数百个Kafka流中获取和处理数据。我们想吃自己的狗粮，用Xcalar分析Xcalar。你可以在YouTube上找到描述这项工作的视频:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/5cf0d688349967c673986c29cdba91aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_H1po9DZbEg_NpoQxBIHQQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae me" href="https://www.youtube.com/watch?v=RAQ4OnIBkss&amp;t=3914s" rel="noopener ugc nofollow" target="_blank">数据库月:SQL NYC，NoSQL &amp; NewSQL，2020 </a></figcaption></figure><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/29e16c45619fdc7250d210da59634bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjDzPDcMPw2-ep-ur1Qflg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae me" href="https://www.youtube.com/watch?v=kId44PF7iXk&amp;t=1337s" rel="noopener ugc nofollow" target="_blank">2020年洛杉矶数据会议</a></figcaption></figure><h1 id="76b9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">示例实现和代码</h1><p id="7127" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们看一个简单的例子，它演示了如何在不使用任何额外工具和解析器的情况下，使用Postgres SQL接收和分析各种格式的日志。您应该能够将这种方法扩展到其他用例。如果您有任何问题或需要进一步的指导，请随时联系我！</p><p id="eb5e" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">网上有大量的日志样本可供使用。例如，看看<a class="ae me" href="https://github.com/logpai/loghub" rel="noopener ugc nofollow" target="_blank">这个由LogPai收集的来自不同系统的日志的大集合</a>。您可以使用这些文件来测试不同的解析模式；然而，您甚至不需要走那么远:您可以在您的个人或云计算机上找到系统和应用程序日志。例如，macOS(以及Linux)将系统日志存储在<em class="md"> /var/log </em>目录中(取决于您的OS版本，它可能在<em class="md"> /Library/Logs/或~/Library/Logs/) </em>。这是我的MacBook笔记本电脑的快照:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/3d4919cf0027250b5e7d8f5b48d818b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEME33R9-objwoJGpc7cqg.png"/></div></div></figure><p id="eab4" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">为了便于说明，让我们解析<em class="md"> install.log </em>来找到最活跃的安装程序和补丁活动。我们需要做的第一件事是创建原始日志表，该表有一个接收原始日志条目的文本列。我们还将创建一个自动递增的列，该列将由Postgres自动填充，并与源日志文件的行号相对应。当我们未来的SQL操作需要行顺序上下文时，这个数据字段将会派上用场。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9c735386d7dfb54e9c9aa34aa5528b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*5B7A-u3asPQoK27Ma3_X-w.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">创建原始日志表</figcaption></figure><p id="ee33" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">接下来，我们将利用awesome Postgres <em class="md"> COPY </em>命令将日志文件中的所有记录提取到一个名为<em class="md"> log_record的列中。</em>因为Postgres <em class="md"> COPY </em>命令需要一个分隔符，所以我们需要使用一个保证不会出现在日志文件中的字符。对于这个例子，我们将使用一个声音哔(<a class="ae me" href="https://en.wikipedia.org/wiki/Bell_character" rel="noopener ugc nofollow" target="_blank">铃声</a>)字符。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/efab217716f24bf2b38ac898a9b6705b.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*hxn-b0CCy3lqoiOzT7J9tg.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">使用“哔”字符作为分隔符，以确保日志行作为单个字段加载</figcaption></figure><p id="3b14" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">瞧，我们快到了。现在我们的原始数据表中有了日志记录，我们将解析它们。Postgres支持正则表达式，这使得解析变得非常容易。</p><blockquote class="mt mu mv"><p id="7464" class="kt ku md kv b kw ly ky kz la lz lc ld mw ma lg lh mx mb lk ll my mc lo lp lq ig bi translated">所有主流的RDBMS(基于MySQL、雪花、红移、BigQuery、SQL Server、Oracle等。)支持正则表达式。然而，如果你的RDBMS不支持正则表达式，没问题。您可以使用基本的ANSI SQL字符串操作函数(子字符串、索引等)获得类似的结果。)，可能比正则表达式要罗嗦一点。我将在下面的代码示例中说明其中的一些内容。</p></blockquote><p id="cd2d" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">我使用<a class="ae me" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a>在线工具来开发和测试我的正则表达式:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/fae25cd4b75dfa919ebe5bb16ec58178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhtZHvkZ8gPD6sNiZ2jtjg.png"/></div></div></figure><p id="b77c" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">我注意到，大多数日志条目都有一个共同的模式，只是略有不同:一些记录在发出的消息的信息部分有额外的子结构。下面的脚本说明了:</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b18d" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">在上面的第4行，我们首先应用公共正则表达式，然后在第12–17行，我们处理变化(由一些子系统发出的日志条目有一个额外的部分，我们将它分割到msg_action字段，而一些子系统跳过它)。第12–17行还说明了如果RDBMS不支持正则表达式，如何解析日志条目。</p><p id="3545" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">以下是结果集的一个片段:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/354f2e0edf248ab4d53189223f2ef15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NI3kbppF2XG5qGldqRgyRQ.png"/></div></div></figure><p id="b345" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">现在我们已经完全解析了日志，我们可以看到哪些应用程序安装程序在您的机器上是最活跃的(或者说，最活跃地记录了它们的活动)。例如，我们可以运行一些统计查询，如下所示:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/2fa488110a9b4852e4a7ab60ce8b48a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMOuxhT3K_uk8LaRcoJm-w.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">显示最多产的伐木工</figcaption></figure><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/b9c72fcac58448db9d09634e4399f507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF1bYx4-iipURqWCHW8KJA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">分析写入频率</figcaption></figure><blockquote class="mt mu mv"><p id="52d0" class="kt ku md kv b kw ly ky kz la lz lc ld mw ma lg lh mx mb lk ll my mc lo lp lq ig bi translated">注意，Postgres过滤掉了10%的日志记录，因为它们与regex模式不匹配。我分析了这些记录，它们看起来并不有趣，但是您应该始终确保测试异常值和异常情况，以避免丢失信息:</p></blockquote><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/8c9959f251d8bee7974d06ca05a8ac99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4UlhPlWwdEUhC5jBl1vsQ.png"/></div></div></figure><p id="a74c" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">完整的SQL脚本在这里:</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="23ca" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">这种方法的美妙之处在于民主化的程度。只要有一个适配器(在这种情况下是一个简单的SQL查询)可以提取日志分析所需的语义，应用程序和服务就可以自由地以任何方便的格式编写信息。当然，理想情况下，所有系统都应该努力实现单一标准。利用如上所示的SQL适配器，可以构建抽象层，使企业能够向前推进，同时标准化工作可以并行进行。</p><blockquote class="mt mu mv"><p id="9608" class="kt ku md kv b kw ly ky kz la lz lc ld mw ma lg lh mx mb lk ll my mc lo lp lq ig bi translated">注意:为了避免暴露专有信息，我在这个练习中使用了一个相当随机的例子和命名对话。当然，一旦您遇到需要解决的特定日志分析问题，您应该遵循组织中采用的适当命名约定和最佳实践。</p></blockquote><p id="9c91" class="pw-post-body-paragraph kt ku in kv b kw ly ky kz la lz lc ld le ma lg lh li mb lk ll lm mc lo lp lq ig bi translated">如果您喜欢这种方法，您可能需要开始考虑接下来的步骤。比如开发更深更复杂的解析模式；聚集来自多个系统的日志；从S3、Azure/GCP blob或其他云存储媒体摄取日志；增加历史博客；跟踪错误堆栈跟踪；丰富您的数据仓库中的其他数据集并与之连接；在聚集的数据集上运行机器学习模型；等等。敬请关注，如果你对这些话题感兴趣，请给我写封私信，发表评论，或者在LinkedIn上联系我。</p></div></div>    
</body>
</html>