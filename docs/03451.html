<html>
<head>
<title>Npm, package.json, package-lock.json, node_modules. What does it all mean? Create your first npm package.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Npm，package.json，package-lock.json，node_modules。这一切意味着什么？创建您的第一个npm包。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-npm-d5b5cf898985?source=collection_archive---------0-----------------------#2020-11-06">https://blog.devgenius.io/what-is-npm-d5b5cf898985?source=collection_archive---------0-----------------------#2020-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fb8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，在这篇博文中，我想谈谈NPM。它是如何工作的？它与package.json、package-lock.json和node_modules目录有什么关系？</p><p id="1b99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还将讨论“什么是包，什么是模块？”此外，我们将创建自己的非常简单的npm包并发布它。</p><h1 id="ffb6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">介绍</h1><p id="09ff" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我已经使用了像React和Vue这样的Javascript库将近两年了——也使用了NodeJS for APIs。我对安装包并将它们导入到我的项目中有一点了解。能够导入代码库和即插即用使得构建应用程序更加容易和快速。然而，当一个包出现问题时，它是如此令人沮丧，因为，一，我对NPM没有深入的了解，二，我不熟悉该包的代码(导入的代码不是我的代码)。</p><p id="2fb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于包不是我的代码，我真的做不了什么，但是我认为通过熟悉<code class="fe ll lm ln lo b">npm</code>我可以变得更擅长处理包和调试任何错误。</p><p id="f820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就在昨天，我试图建立一个Vue项目的Docker映像，我在使用<code class="fe ll lm ln lo b">npm</code>时遇到了问题。在执行<code class="fe ll lm ln lo b">npm run build</code>命令期间，我使用的名为<code class="fe ll lm ln lo b">v-calendar</code>的依赖项出现了问题。我从不再可用的v-calendar模块中导入了一个CSS文件。此外，软件包的用法已经更新，使用v-calendar组件的代码被破坏。</p><p id="a911" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我解决了这两个问题之后，<code class="fe ll lm ln lo b">npm run build</code>命令可以工作了，但是这需要大量的谷歌搜索和几个小时不必要的代码调试。相反，如果我了解npm是如何工作的，我就可以很容易地看到npm错误消息并解决我的问题。</p><p id="744b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以说了这么多，今天，我想理解<code class="fe ll lm ln lo b">npm</code>的基础，因此，能够轻松地解决依赖或包相关的问题。</p><p id="eec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，包管理器在今天的任何现代编程语言中都有涉及。Ruby bundler，Python PiP，NodeJS npm。我学到的关于npm的知识可以很容易地转移给其他的包管理人员，所以<code class="fe ll lm ln lo b">npm</code>将是一个很有用的东西。</p><p id="df09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lp">注意:我想我还应该注意，我不会太关注npm命令，因为你可以很容易地在文档中找到它们。相反，我将关注这些不同的npm组件的“什么”以及“如何”。</em></p><h1 id="c98b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">NPM到底是什么？</h1><p id="a807" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">所以我认为我们首先应该谈论的是NPM。NPM到底是什么？</p><p id="b789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要是两个不同的(或者三个)东西。</p><ol class=""><li id="f2b3" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">我们用来安装软件包的<strong class="jm io"> CLI </strong>(命令行界面)，例如<code class="fe ll lm ln lo b">npm install some_module</code></li><li id="564e" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><strong class="jm io">注册表</strong>=&gt;JS包上传到的公共数据库。</li><li id="4f5d" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">(网站)</li></ol><h2 id="c3af" class="me kj in bd kk mf mg dn ko mh mi dp ks jv mj mk kw jz ml mm la kd mn mo le mp bi translated">重要定义:模块与包</h2><p id="d8ba" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated"><strong class="jm io">打包</strong> = &gt;一个由<code class="fe ll lm ln lo b">package.json</code>描述的文件或目录。</p><p id="2cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">模块</strong>=&gt;<code class="fe ll lm ln lo b">node_modules</code>目录中任何可以用Node.js程序中的<code class="fe ll lm ln lo b">require()</code>加载的东西。</p><p id="e890" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Nodejs require()可以加载什么？</p><ul class=""><li id="5c21" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh mq lw lx ly bi translated">一个带有<code class="fe ll lm ln lo b">package.json</code>的文件夹，里面装着<code class="fe ll lm ln lo b">main</code></li><li id="c9e4" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">一个文件夹，里面有一个<code class="fe ll lm ln lo b">index.js</code>文件</li><li id="ddcb" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">js文件</li></ul><h2 id="9453" class="me kj in bd kk mf mg dn ko mh mi dp ks jv mj mk kw jz ml mm la kd mn mo le mp bi translated">有什么区别？</h2><p id="6cd2" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">大多数npm包都是模块。然而，一些npm包不能被加载，例如<code class="fe ll lm ln lo b">cli</code>包只包含一个可执行的命令行界面，不提供用于NodeJS程序的<code class="fe ll lm ln lo b">main</code>字段。</p><p id="1234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个例子:</p><blockquote class="mr ms mt"><p id="9916" class="jk jl lp jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">例如，如果你在<code class="fe ll lm ln lo b">node_modules/foo.js</code>创建了一个文件，然后有一个程序做了<code class="fe ll lm ln lo b">var f = require('foo.js')</code>，它将加载模块。但是，<code class="fe ll lm ln lo b">foo.js</code>在这里不是一个“包”,因为它没有package.json。</p><p id="f18a" class="jk jl lp jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">或者，如果您创建的包在<code class="fe ll lm ln lo b">package.json</code>文件中没有<code class="fe ll lm ln lo b">index.js</code>或<code class="fe ll lm ln lo b">"main"</code>字段，那么它就不是一个模块。即使安装在<code class="fe ll lm ln lo b">node_modules</code>里，也不能成为<code class="fe ll lm ln lo b">require()</code>的参数。</p></blockquote><p id="3e05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在NodeJS/npm应用程序的上下文中，当我们运行<code class="fe ll lm ln lo b">npm install some-package</code>时，我们正在从npm注册表安装一个包。然后这个包被添加到我们的node_modules目录中。这个包现在也是我们应用程序的一个模块，我们可以使用<code class="fe ll lm ln lo b">const somePackage = require(‘some-package’);</code>将它加载到我们的应用程序中。</p><h1 id="17ca" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">package.json是什么？</h1><p id="016a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">既然我们知道包只是一个包含package.json文件的目录，接下来我们想知道package.json文件到底是什么？？</p><p id="a5cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Package.json是描述npm </strong>的包的json文件。我认为创建和发布我们自己的包将很容易演示package.json如何与包相关联，所以让我们在这里这样做。</p><ol class=""><li id="e153" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">首先，<strong class="jm io">在网站上创建一个npm账户</strong>。<a class="ae mx" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/</a></li><li id="c063" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">接下来，<strong class="jm io">创建你的包<br/> </strong> a .创建你的目录<code class="fe ll lm ln lo b">mkdir arthur-test-package &amp;&amp; cd arthur-test-package<br/></code> b .创建你的package.json文件<code class="fe ll lm ln lo b">npm init<br/></code>日志会提示你描述你的包，即<code class="fe ll lm ln lo b">name</code>等信息。对于所有提示，您只需按enter键，并使用默认字段。需要注意的重要事情是<code class="fe ll lm ln lo b">name</code>和<code class="fe ll lm ln lo b">main</code>字段。该名称将用作发布到注册表时的名称，而<code class="fe ll lm ln lo b">main</code>字段是导入的<strong class="jm io">文件</strong>当用户执行<code class="fe ll lm ln lo b">require(‘your-module’).<br/></code> <em class="lp">时，您也可以使用</em> <code class="fe ll lm ln lo b">npm init -y</code> <em class="lp">创建一个带有默认字段</em>的package.json</li></ol><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c746" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c.在您的“主”文件(默认为index.js)中创建代码。我的看起来是这样的(<em class="lp">这是不言而喻的，但请确保您的包中有您需要的任何依赖项，以便您的packge.json文件将列出这些依赖项。)</em></p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1e1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.现在我们有了自己的包，我们只需要<strong class="jm io">登录</strong>就可以将它发布到注册表中，<code class="fe ll lm ln lo b">npm login</code>并输入您的用户名和密码</p><p id="d1f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.<strong class="jm io">将</strong>发布到npm注册表。<code class="fe ll lm ln lo b">npm publish</code></p><p id="29e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！创建和发布npm包非常容易。我们可以很容易地在国家预防机制网站上通过导航到我们的个人资料下的“包”部分来查看我们的包。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/6c675d16d2ceffc278b65031bff69810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6k0GuvJ3o9jsMulZenUrw.png"/></div></div></figure><p id="3887" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参见<a class="ae mx" href="https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多关于发布你的包到npm的细节！</p><p id="abc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以在单独的NodeJS项目中打包。</p><p id="ac1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在另一个初始化了npm的NodeJS项目中，我们可以运行<code class="fe ll lm ln lo b">npm install arthur-test-package</code>并在代码中使用arthur-test-package。</p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1760" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我们运行这个文件<code class="fe ll lm ln lo b">node someotherfile.js</code>时，它使用我们在arthur-test-package中创建的函数记录日期字符串。</p><p id="5bf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以在创建了我们自己的包及其附带的package.json文件后，我们知道<strong class="jm io"> package.json文件只是一个向NPM描述包的json文件。</strong></p><ul class=""><li id="37e1" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh mq lw lx ly bi translated">包的名称</li><li id="301b" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">包需要的任何依赖项</li><li id="48fc" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated"><code class="fe ll lm ln lo b">main</code>字段描述了使用<code class="fe ll lm ln lo b">require</code>加载该包时导入的文件</li></ul></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><h2 id="f576" class="me kj in bd kk mf mg dn ko mh mi dp ks jv mj mk kw jz ml mm la kd mn mo le mp bi translated">npm命令如何使用package.json文件</h2><p id="ad83" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">其他一些需要知道的事情是npm命令如何处理package.json文件。</p><p id="82c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">跑<code class="fe ll lm ln lo b">npm install</code>会怎么样？</p><p id="ae3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">npm install</code> = &gt;会将package.json文件中“dependencies”下列出的任何包安装到node_modules目录中，以便您可以开始在应用程序中使用这些模块！</p><p id="e769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">npm install some-package</code> = &gt;会将特定的包安装到node_modules目录中，还会在package.json中的“依赖项”下列出该包，以便npm知道该包需要某个包才能正确运行。</p><h1 id="8cf3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">最后，package-lock.json是什么？</h1><p id="eafa" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">第一次运行<code class="fe ll lm ln lo b">npm install</code>时，npm会自动创建一个package-lock.json文件？</p><p id="49f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如果我们有描述我们需要的任何依赖项的package.json，为什么我们需要package-lock.json？？</strong></p><p id="2a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">文件上说:</p><blockquote class="mr ms mt"><p id="ed5f" class="jk jl lp jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">对于npm修改<code class="fe ll lm ln lo b">node_modules</code>树或<code class="fe ll lm ln lo b">package.json</code>的任何操作，都会自动生成<code class="fe ll lm ln lo b">package-lock.json</code>。它描述了生成的确切的树，使得<strong class="jm io">后续安装能够生成相同的树，</strong>而不管中间的依赖关系更新。</p></blockquote><p id="c2f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们读得更多，就会发现package-lock.json:</p><blockquote class="mr ms mt"><p id="7294" class="jk jl lp jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">描述依赖关系树的单一表示，从而保证队友、部署和持续集成安装完全相同的依赖关系。</p></blockquote><p id="a9f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，package-lock.json确保任何运行<code class="fe ll lm ln lo b">npm install</code>的人都会生成一个相同的<strong class="jm io">依赖树。这很重要，因为你的项目可能需要同一个包的几个不同版本。为了确保这些依赖需求得到解决，我们需要依赖树，任何想要运行你的程序的人也需要生成精确的依赖树。</strong></p><p id="33c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解析不同的依赖版本被称为“依赖地狱”。你可以在他们的文档中读到更多关于什么是依赖地狱以及npm如何解决依赖地狱的内容。<a class="ae mx" href="https://npm.github.io/how-npm-works-docs/npm2/how-npm2-works.html" rel="noopener ugc nofollow" target="_blank">https://NPM . github . io/how-NPM-works-docs/NPM 2/how-NPM 2-works . html</a></p><h2 id="e344" class="me kj in bd kk mf mg dn ko mh mi dp ks jv mj mk kw jz ml mm la kd mn mo le mp bi translated">为什么要把package-lock.json文件提交给GitHub？</h2><p id="1b69" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我总是有点不确定是否应该将package-lock.json文件提交给GitHub，但是在理解了它们的作用之后，就明白了为什么应该提交它们。</p><p id="eff1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前的:</p><blockquote class="mr ms mt"><p id="1678" class="jk jl lp jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">[packge-lock.json]描述了依赖关系树的单一表示，从而确保队友、部署和持续集成安装完全相同的依赖关系。</p></blockquote><ul class=""><li id="03d8" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh mq lw lx ly bi translated">此外，package-lock.json提供了我们的依赖关系树的历史，而不必提交整个node_modules目录。</li></ul><p id="93bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，提交我们的package-lock.json提供了GitHub存储库中依赖树的历史记录，并允许其他人在node_modules中生成精确的依赖树。</p><h2 id="a3ca" class="me kj in bd kk mf mg dn ko mh mi dp ks jv mj mk kw jz ml mm la kd mn mo le mp bi translated">最后的想法…</h2><p id="5ef6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">好了，至此，我想我们对npm的工作原理以及package.json、package-lock.json和node_modules有了一个很好的理解。</p><ul class=""><li id="78ee" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh mq lw lx ly bi translated">npm是一个公共注册中心，软件包在这里发布到</li><li id="f83c" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">npm也是我们用来下载软件包的CLI</li><li id="3ad2" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">package.json是一个json文件，它向npm描述了我们的包</li><li id="fecf" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">node_modules是npm安装我们的包的目录，也是NodeJS寻找模块的地方</li><li id="9967" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh mq lw lx ly bi translated">最后，package-lock.json是一个描述npm生成的确切依赖树的文件；它确保了使用该应用程序的其他人在安装包时创建相同的依赖树！</li></ul><p id="a2df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初，我也想进入<code class="fe ll lm ln lo b">npm scripts</code>，具体来说，React和Vue <code class="fe ll lm ln lo b">run</code>和<code class="fe ll lm ln lo b">build</code>脚本，以及它们到底是如何工作的，但我认为这个帖子已经够长了。此外，分解这些脚本本身所做的事情似乎已经足够广泛了，所以希望我可以在另一个时间讨论这个问题。</p></div></div>    
</body>
</html>