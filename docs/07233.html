<html>
<head>
<title>Measuring React performance with OpenTelemetry and Honeycomb</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 OpenTelemetry 和 Honeycomb 测量反应性能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/measuring-react-performance-with-opentelemetry-and-honeycomb-2b20a7920335?source=collection_archive---------2-----------------------#2022-03-08">https://blog.devgenius.io/measuring-react-performance-with-opentelemetry-and-honeycomb-2b20a7920335?source=collection_archive---------2-----------------------#2022-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af76" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">POC 到前端的性能可观察性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09343cf8816fa3c4344169bfce7bea26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN-2OxMF5HVj7kNlpDUHIQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="dd8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">性能是一个很难解决的问题。有许多方法可以达到这个目标——有些容易成功，有些不那么简单。一个简单的优化是通过使用选择器和 PureComponents 来消除不必要的 React 渲染。另一种方法是找到性能瓶颈，并从那里进行优化。那么，如何找到这些性能瓶颈呢？</p><p id="2ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也有许多方法。一种方法是使用 Chrome 性能分析器进行分析。然而，这种方法虽然有帮助，但是不可扩展。这对于轶事证据来说是好的，但是对于批量分析来说不是很好。如果客户有性能问题，他们必须收集并向您发送他们的分析数据。最后，对于初学者来说，这是一个强大的工具，没有源地图，火焰图很难阅读。</p><p id="3fd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:现在有一个<a class="ae lr" href="https://wicg.github.io/js-self-profiling/" rel="noopener ugc nofollow" target="_blank"> JS 自分析 API </a>可以自动分析你的代码。我将在以后的文章中讨论这项新技术。</p><p id="f6c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章是关于追踪的。在这里，我展示了一个简单的概念验证跟踪系统，它将自动收集和发送 React 性能数据，以便于可视化。</p><p id="c6c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文大致分为四个部分。第一部分只是让应用程序运行起来。第二部分是关于收集痕迹。第三部分是关于如何评测 React 代码。在最后一部分中，我将讨论如何将这个概念验证转化为适用于实际生产环境的东西。</p><h1 id="2add" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第 1 部分:创建一个在节点上运行的简单应用程序</h1><p id="475f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我使用<code class="fe mp mq mr ms b"><a class="ae lr" href="https://create-react-app.dev/docs/getting-started" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>创建了一个简单的 TodoApp，我将通过跟踪来收集性能数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/7111aa9cc73ae2496c2ea52145ebc71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTKGufPjlyWaZHrop_99QQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用于创建和编辑待办事项的简单待办事项应用程序</figcaption></figure><p id="5403" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个简单的界面，你在输入框中输入一个待办事项，然后点击“回车”将它添加到待办事项列表的顶部。</p><p id="bf97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这里找到完整的<a class="ae lr" href="https://github.com/lilychencodes/profiling-demo" rel="noopener ugc nofollow" target="_blank"> Github 回购</a>。</p><h2 id="2e0a" class="mu lt iq bd lu mv mw dn ly mx my dp mc le mz na me li nb nc mg lm nd ne mi nf bi translated">创建节点服务器</h2><p id="0239" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">节点服务器是向蜂巢发送跟踪数据所必需的。创建一个简单的 express 服务器很容易。你只需要遵循 3 个简单的步骤:</p><ol class=""><li id="8557" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">同时安装 express、nodemon 和。</li></ol><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="3809" class="mu lt iq ms b gy nt nu l nv nw">npm i express --save<br/>npm i nodemon concurrently --save-dev</span></pre><p id="d190" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.在根文件夹中创建一个<code class="fe mp mq mr ms b">server.js</code>文件。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="7a2e" class="mu lt iq ms b gy nt nu l nv nw">const express = require('express');</span><span id="ec17" class="mu lt iq ms b gy nx nu l nv nw">const app = express();<br/>const port = process.env.PORT || 5000;</span><span id="e5cc" class="mu lt iq ms b gy nx nu l nv nw">app.get('/send-trace', (req, res) =&gt; {<br/>  // TODO: send trace data to Honeycomb</span><span id="d70f" class="mu lt iq ms b gy nx nu l nv nw">  res.send({ status: 'done' });<br/>});</span><span id="37f4" class="mu lt iq ms b gy nx nu l nv nw">app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><p id="3ede" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.更新 package.json 脚本和代理。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="bd63" class="mu lt iq ms b gy nt nu l nv nw">"scripts": {<br/>    "client": "react-scripts start",<br/>    "server": "nodemon server.js",<br/>    "start": "concurrently \"npm run server\" \"npm run client\""<br/>},<br/>"proxy": "<a class="ae lr" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a>",</span></pre><p id="7e40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您需要运行一个应用程序，我们准备开始分析我们的前端 Javascript。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="a5e0" class="ls lt iq bd lu lv of lx ly lz og mb mc jw oh jx me jz oi ka mg kc oj kd mi mj bi translated">第 2 部分:使用 OpenTelemetry 和蜂巢收集踪迹</h1><p id="366e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://opentelemetry.io/docs/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>是一个开源项目，它提供了用于收集度量和跟踪的工具库。我们将使用 OpenTelemetry 跟踪我们的代码。<a class="ae lr" href="https://www.honeycomb.io/" rel="noopener ugc nofollow" target="_blank">蜂巢</a>是一个软件，让你可视化和分析你的痕迹。我们将把通过 OpenTelemetry 收集的跟踪数据发送到蜂巢。</p><p id="e097" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有许多方法可以建立这样一个系统。一种做法是将跟踪数据发送到收集器<a class="ae lr" href="https://docs.honeycomb.io/getting-data-in/otel-collector/" rel="noopener ugc nofollow" target="_blank">并设置收集器将数据发送到蜂巢。为此，您必须在 Docker 容器中运行收集器。我可能会在某个时候这样做，但是对于本文，我采用了一种更为人工但熟悉的方法:即将跟踪数据发送到我自己的端点，然后通过它们的</a><a class="ae lr" href="https://docs.honeycomb.io/api/events/" rel="noopener ugc nofollow" target="_blank">事件 API </a>将数据推送到蜂巢。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/6906bbf497f5d3ffedfee5ae733e7776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zR3uvmabw_E-QbaQ5VNn9Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">追踪架构</figcaption></figure><p id="2673" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将浏览器跟踪发送到蜂巢，我使用了蜂巢文档。</p><ol class=""><li id="570a" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">下载必要的软件包。</li></ol><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="9761" class="mu lt iq ms b gy nt nu l nv nw">npm i @opentelemetry/sdk-trace-web @opentelemetry/context-zone @opentelemetry/instrumentation-fetch @opentelemetry/api libhoney --save</span></pre><p id="742a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.实例化跟踪检测。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="aa01" class="mu lt iq ms b gy nt nu l nv nw">const provider = new WebTracerProvider(...);</span><span id="bad8" class="mu lt iq ms b gy nx nu l nv nw">provider.register({<br/>  contextManager: new ZoneContextManager()<br/>});</span><span id="5379" class="mu lt iq ms b gy nx nu l nv nw">const fetchInstrumentation = new FetchInstrumentation({});</span><span id="be20" class="mu lt iq ms b gy nx nu l nv nw">fetchInstrumentation.setTracerProvider(provider);</span><span id="54d8" class="mu lt iq ms b gy nx nu l nv nw">// Registering instrumentations<br/>registerInstrumentations({<br/>  instrumentations: [<br/>    fetchInstrumentation,<br/>  ],<br/>});</span><span id="a6cd" class="mu lt iq ms b gy nx nu l nv nw">export default function TraceProvider({ children }) {<br/>  return (<br/>    &lt;&gt;<br/>      {children}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="5949" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您可以将顶级组件包装在 TraceProvider 中。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="37fc" class="mu lt iq ms b gy nt nu l nv nw">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;TraceProvider&gt;<br/>      &lt;App /&gt;<br/>    &lt;/TraceProvider&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="50e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在我的 Github repo <a class="ae lr" href="https://github.com/lilychencodes/profiling-demo/blob/master/src/trace-provider.js" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的代码。</p><p id="ed7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.创建跨度并开始收集数据。</p><p id="ec5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要创建一个跨度，使用<code class="fe mp mq mr ms b">.startSpan()</code>方法。当工作完成时，不要忘记通过调用<code class="fe mp mq mr ms b">.end()</code>来关闭跨度。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="082c" class="mu lt iq ms b gy nt nu l nv nw">// inside a component<br/>  const createTodo = useCallback(<br/>    (e) =&gt; {<br/>      if (e.key !== 'Enter') return;</span><span id="31f2" class="mu lt iq ms b gy nx nu l nv nw">      withTracing('create_todo', async () =&gt; {<br/>        const newTodos = [<br/>          { title: currentTodo },<br/>          ...todos<br/>        ];<br/>        await setTodos(newTodos);<br/>      });<br/>    },<br/>    [todos, setTodos, currentTodo, setTodo]<br/>  )</span><span id="3137" class="mu lt iq ms b gy nx nu l nv nw">// withTracing utility function<br/>async function withTracing(name, cb) {<br/>  const tracer = api.trace.getTracer('profiling-demo');<br/>  const span = tracer.startSpan(name);</span><span id="2c68" class="mu lt iq ms b gy nx nu l nv nw">  await cb();</span><span id="ad61" class="mu lt iq ms b gy nx nu l nv nw">  span.end();</span><span id="38f2" class="mu lt iq ms b gy nx nu l nv nw">  reportSpan(span);<br/>}</span><span id="76c8" class="mu lt iq ms b gy nx nu l nv nw">function reportSpan(span) {<br/>  const payload = { ... }; // span id, name, duration, etc.</span><span id="691b" class="mu lt iq ms b gy nx nu l nv nw">  fetch('./send-trace', {<br/>    method: 'POST',<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(payload),<br/>  });<br/>}</span></pre><p id="2c46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我想知道重新计算待办事项列表需要多长时间。</p><p id="62db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.将跟踪数据从后端发送到蜂巢。</p><p id="9243" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了向 Honeycomb 发送跟踪数据，我使用了 Honeycomb 的<a class="ae lr" href="https://docs.honeycomb.io/getting-data-in/libhoney/javascript/" rel="noopener ugc nofollow" target="_blank"> libhoney </a>库。</p><pre class="kg kh ki kj gt np ms nq nr aw ns bi"><span id="b0c4" class="mu lt iq ms b gy nt nu l nv nw">const honeycomb = new Libhoney({<br/>  writeKey: HONEYCOMB_API_KEY,<br/>  dataset: 'profiling-demo',<br/>});</span><span id="61c2" class="mu lt iq ms b gy nx nu l nv nw">// /send-trace endpoint<br/>app.post('/send-trace', (req, res) =&gt; {</span><span id="536c" class="mu lt iq ms b gy nx nu l nv nw">  const event = honeycomb.newEvent();<br/>  const payload = { ... }; // processed payload from req.body<br/>  event.add(payload);<br/>  event.send();</span><span id="2f41" class="mu lt iq ms b gy nx nu l nv nw">  res.send({ status: 'done' });<br/>});</span></pre><p id="39a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然您可以直接从浏览器向 Honeycomb 发送数据，但这通常不是一个好的做法，因为像 API 密钥这样的敏感数据在浏览器中永远不会真正安全。</p><p id="fc64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些都完成后，我们可以看到蜂巢中的数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/4ea1a53a8f1e48a5df02a849c02983e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORA65QivAO5M5x9BA7DzRA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">更新 todos 所用的持续时间。</figcaption></figure><p id="4281" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以单击单个轨迹。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/99a58d456a62828f0e7f3f73b014d32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMtY3stMKUSk-JM2kIM0Ow.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">跟踪示例</figcaption></figure><p id="16ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，我们的痕迹仍然很少。在现实生活中，您可以使用嵌套跨度实现更复杂、更有洞察力的跟踪。请继续阅读一些例子！</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="a0a0" class="ls lt iq bd lu lv of lx ly lz og mb mc jw oh jx me jz oi ka mg kc oj kd mi mj bi translated">第 3 部分:测量反应性能</h1><p id="ba91" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用跟踪可以做很多事情！有没有想过你的 React 组件会因为一些用户动作而重新渲染多少次？你的应用程序响应用户交互需要多长时间？</p><p id="3dda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React 确实提供了一个<a class="ae lr" href="https://reactjs.org/docs/profiler.html" rel="noopener ugc nofollow" target="_blank"> React 分析器</a>。然而，根据文档，Profiler 组件在 prod 中是默认禁用的，应该仅在必要时使用。每次使用都会给应用程序增加一些 CPU 和内存开销。我们将尝试使用我们的开放式遥测系统来分析反应。</p><p id="3e2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在创建新的 todo 时跟踪主 TodoApp 及其子 TodoItems 的呈现。</p><p id="7eb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了测量 React render，在组件顶部开始一个新的跨度，并关闭<code class="fe mp mq mr ms b">useEffect</code>钩子内的跨度。完整的代码可以在<a class="ae lr" href="https://github.com/lilychencodes/profiling-demo/blob/master/src/components/TodoItem.tsx" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/980e6417c98be26c0086000fc9272e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHkyf8qXiCVGKw3D8LFVcw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用户交互的应用响应时间</figcaption></figure><p id="7228" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所示，每个 TodoItem 组件在创建新的 todo 时都会重新渲染，每次渲染大约需要 5–10 毫秒。从按下“回车”到<code class="fe mp mq mr ms b">useEffect()</code>钩子触发(相当于<code class="fe mp mq mr ms b">componentDidUpdate</code>)的总时间约为 27 毫秒。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="406f" class="ls lt iq bd lu lv of lx ly lz og mb mc jw oh jx me jz oi ka mg kc oj kd mi mj bi translated">第 4 部分:利用可观察性解决生产中的性能问题</h1><p id="3292" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在过去的几年里，我花了很多时间研究性能的可观察性。这是一个难题空间。尽管有太多的工具，但是仍然不容易找出造成性能瓶颈的因素。追踪提供了可见性，但是仍然需要人工来检测和分析痕迹。</p><p id="069f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去的几年里，我学到的一个有用的策略是利用 metatags 的 sh*t。</p><p id="3481" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">元标记是可以添加到跟踪中的标记。在 Honeycomb 中，您可以基于标签值查询和比较数据。前端性能世界中一些有用的元标记是 Redux 存储大小、A/B 测试变量和<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection" rel="noopener ugc nofollow" target="_blank">网络信息</a>。例如，我发现 Redux 大小与应用程序响应用户交互的速度密切相关。在我目前的公司，我们投入了大量精力来减少 Redux 大小(例如，通过延迟加载数据、缓存回收等)。).</p><p id="87e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇 POC 文章对您有所帮助。在真实的生产环境中，您可能还需要做一些额外的事情。</p><ol class=""><li id="e024" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">对您的数据进行采样。</li><li id="1f63" class="ng nh iq kx b ky oo lb op le oq li or lm os lq nl nm nn no bi translated">限制 api 调用的批处理事件。</li><li id="02f0" class="ng nh iq kx b ky oo lb op le oq li or lm os lq nl nm nn no bi translated">为开发和生产使用单独的数据集。</li><li id="a5c2" class="ng nh iq kx b ky oo lb op le oq li or lm os lq nl nm nn no bi translated">将前端跟踪(反应时间)与后端跟踪(api 时间)连接起来，以获得更完整的用户监控画面。</li></ol></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="7783" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！如果你有任何问题，请不要犹豫来找我。你可以在我的<a class="ae lr" href="https://github.com/lilychencodes/profiling-demo" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到这篇文章的代码。</p></div></div>    
</body>
</html>