<html>
<head>
<title>Redis Optimizing round-trip times with Pipelining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis 使用流水线优化往返时间</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redis-optimizing-round-trip-times-with-pipelining-1dbae39265c3?source=collection_archive---------8-----------------------#2022-12-31">https://blog.devgenius.io/redis-optimizing-round-trip-times-with-pipelining-1dbae39265c3?source=collection_archive---------8-----------------------#2022-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f49528e6ddb390405d941ed0798a0f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BBVzjMFbHvbLBG_PX2plw.png"/></div></div></figure><p id="4a0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🥰这篇短文将解释 TCP、请求/响应协议、RTT 和 Redis 管道。</p><h2 id="c042" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">🧐:在我们开始之前，让我们回顾一下我使用的一些术语:</h2><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/1fc3e74317f4973574f5df6590cf7375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*0rjadNG55bmnXvZMhcQNhw.jpeg"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">makeameme.org 术语模因</figcaption></figure><h2 id="6b02" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">传输控制协议（Transmission Control Protocol）</h2><p id="c5fc" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">TCP 是面向连接的协议，这意味着它在发送数据之前连接发送方和接收方。这种连接在整个传输过程中保持不变，确保数据以正确的顺序无误地传送。TCP 还控制数据流并检查错误，这有助于确保传输的可靠性。</p><h2 id="bcae" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><em class="ma">请求/响应协议</em></h2><p id="fb01" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">在请求-响应协议中，客户端向服务器发送请求，服务器用响应进行响应。人们通常称这个过程为“往返”，因为客户端发送请求，服务器向客户端发回响应。通常，TCP(传输控制协议)或 UDP(用户数据报协议)用于设置它们。</p><p id="bb3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在请求-响应协议中，客户端向服务器发送请求以开始对话。该请求可以包括服务器处理该请求所需的数据或参数。服务器处理请求，并向客户端发回响应。根据请求的类型和处理的结果，响应可以是数据、确认或错误消息。</p><h2 id="c11c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">循环时间(Round-Trip Time)</h2><p id="bd23" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">往返时间，或称 RTT，是对客户端向服务器发送请求并接收响应所需时间的度量。RTT 通常以毫秒(ms)为单位，它取决于客户端离服务器有多远、网络连接有多快以及服务器有多忙等因素。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="f753" class="mi ku in bd kv mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv mw mx lk my bi translated">💎管道铺设</h1><p id="a246" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">管道意味着客户端可以向服务器发送多个请求，而无需等待响应，然后在一个步骤中读取响应。管道化允许客户端向服务器发送多个请求，而无需等待响应，然后一次性读取所有响应。</p><h2 id="0957" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">🥳是一个真实世界的代码示例</h2><p id="01fa" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">下面的基准测试将使用支持管道的 Redis Ruby 客户端，以及基准测试 gem 来测试管道带来的速度提升。</p><p id="dee3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们转到我们的工作目录，然后键入您的终端:</p><pre class="ln lo lp lq gt mz na nb bn nc nd bi"><span id="68a2" class="ne ku in na b be nf ng l nh ni">gem install redis benchmark</span></pre><p id="0445" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，让我们启动我们的 redis 服务器</p><pre class="ln lo lp lq gt mz na nb bn nc nd bi"><span id="fdf3" class="ne ku in na b be nf ng l nh ni">brew services start redis</span></pre><p id="45b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦完成，让我们前往我们最喜欢的 IDE 我的是 RubyMine 创建一个名为<strong class="jx io">benchmark _ pipes . Rb</strong>的文件，开始编码:</p><pre class="ln lo lp lq gt mz na nb bn nc nd bi"><span id="a575" class="ne ku in na b be nf ng l nh ni">require 'redis'<br/>require 'benchmark'<br/><br/># Connect to the Redis server<br/>r = Redis.new<br/><br/># Set the keys we'll be using for the benchmark<br/>keys = ['food', 'ats', 'loush']<br/><br/># With pipeline<br/>puts Benchmark.measure {<br/>  # Start the pipeline<br/>  r.pipelined do <br/>    keys.each do |key|<br/>        5_000.times do<br/>            r.ping<br/>            r.incr(key)<br/>            r.get(key)<br/>        end<br/>    end<br/>  end<br/>}<br/><br/># Without pipeline<br/>puts Benchmark.measure {<br/>  keys.each do |key|<br/>    5_000.times do<br/>            r.ping<br/>            r.incr(key)<br/>            r.get(key)<br/>    end<br/>  end<br/>}</span></pre><p id="789b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们运行脚本，见证管道的威力！</p><pre class="ln lo lp lq gt mz na nb bn nc nd bi"><span id="e9a6" class="ne ku in na b be nf ng l nh ni">ruby benchmarking_pipes.rb</span></pre><blockquote class="nj"><p id="460f" class="nk nl in bd nm nn no np nq nr ns ks dk translated">难以置信吧。</p></blockquote><figure class="nu nv nw nx ny jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e661768d66c1393f696952a04a3bbb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*rWtOrVQhNcz8JFCSPLQr9Q.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">法。Bu。Lous GIF</figcaption></figure><p id="bc1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="nz">批量使用，性能得到惊人优化😎</em> </strong></p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="69c7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">Redis 流水线的优势:</h2><ul class=""><li id="6df1" class="oa ob in jx b jy lv kc lw kg oc kk od ko oe ks of og oh oi bi translated">提高性能:管道化的主要优点之一是它可以显著提高 Redis 支持的应用程序的性能。通过减少执行命令所需的网络往返次数，管道可以显著减少单个请求的开销，并提高应用程序的整体性能。</li><li id="a2bf" class="oa ob in jx b jy oj kc ok kg ol kk om ko on ks of og oh oi bi translated">减少延迟:通过允许客户端在一个请求中发送多个命令，管道也有助于减少请求的延迟。这对于依赖实时数据或有严格延迟要求的应用程序尤其有用。</li></ul><h2 id="816d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">Redis 流水线的缺点:</h2><ul class=""><li id="4a14" class="oa ob in jx b jy lv kc lw kg oc kk od ko oe ks of og oh oi bi translated">不能保证命令的执行顺序:流水线的一个潜在缺点是它不能保证命令的执行顺序。这意味着，如果您需要以特定的顺序更新多个键，管道可能不是正确的选择。在这些情况下，可以使用<code class="fe oo op oq na b">BATCH</code>命令来代替，这保证了命令将按照它们被发送的顺序执行。</li><li id="19de" class="oa ob in jx b jy oj kc ok kg ol kk om ko on ks of og oh oi bi translated">增加复杂性的可能性:使用管道也会增加代码的复杂性，因为您需要管理管道，并确保它在需要时正确关闭或重置。这在处理多线程或并发请求时尤其重要。</li></ul></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><blockquote class="nj"><p id="49c8" class="nk nl in bd nm nn or os ot ou ov ks dk translated">希望你发现这篇文章有趣和有用的❤️</p></blockquote></div></div>    
</body>
</html>