<html>
<head>
<title>LeetCode 104: Maximum Depth of Binary Tree (solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 104:二叉树的最大深度(带图片的解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-104-maximum-depth-of-binary-tree-solution-with-images-6c43c03af382?source=collection_archive---------5-----------------------#2022-08-15">https://blog.devgenius.io/leetcode-104-maximum-depth-of-binary-tree-solution-with-images-6c43c03af382?source=collection_archive---------5-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="46e4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题:→</h1><p id="9a45" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定二叉树的<code class="fe lj lk ll lm b">root</code>，返回<em class="ln">其最大深度</em>。</p><p id="6874" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">二叉树的<strong class="kn ir">最大深度</strong>是从根节点到最远叶节点的最长路径上的节点数。</p><p id="315f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 1: </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/db0ee5f71e59b15ac75e7246ab48fb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*D4gatV8AU-1rLX1V.jpg"/></div></figure><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="c081" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lm ir">Output:</strong> 3</span></pre><p id="d593" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 2: </strong></p><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="4df4" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> root = [1,null,2]<br/><strong class="lm ir">Output:</strong> 2</span></pre><p id="d5b4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">约束:</strong></p><ul class=""><li id="0f69" class="mk ml iq kn b ko lo ks lp kw mm la mn le mo li mp mq mr ms bi translated">树中的节点数量在范围<code class="fe lj lk ll lm b">[0, 104]</code>内。</li><li id="5d25" class="mk ml iq kn b ko mt ks mu kw mv la mw le mx li mp mq mr ms bi translated"><code class="fe lj lk ll lm b">-100 &lt;= Node.val &lt;= 100</code></li></ul><h1 id="b48a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案:→</h1><p id="71c6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，我们可以通过以下方式检查深度。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi my"><img src="../Images/e9d499328d558ab9be6cf1490f7f2c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/1*DGqMQygsEtL2aMa539wjaw.gif"/></div></figure><p id="c9ee" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们用代码来理解，</p><p id="085a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，我们将检查，如果根节点为空，那么我们不需要做任何树的遍历，我们可以简单地返回<strong class="kn ir"> 0 </strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/88955844a0e26f9bdf8d8c24cc680f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*2lVpJkYqBaq1eKOGbY_VkQ.png"/></div></figure><p id="de9c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">之后，如果<strong class="kn ir">根</strong>为<strong class="kn ir">不为空</strong>，那么我们将把这个添加到<strong class="kn ir">队列中。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/d937dccdd6a16a831b88259b1d9148e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p_hGkijDI62j5SCHBCVnA.png"/></div></div></figure><p id="5079" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir">将遍历</strong>整棵树，验证下一个节点的<strong class="kn ir">左右节点</strong>。</p><p id="7ddf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，我们将找出<strong class="kn ir">堆栈大小</strong>(这将帮助我们找出一次迭代中的节点数)，在这里，我们得到<strong class="kn ir"> 1 </strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nf"><img src="../Images/1e0961f52df23c5d6ec5d986a28e3ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfJkAZ9MsaifyCfb819JCg.png"/></div></div></figure><p id="58d2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，<strong class="kn ir">左节点</strong>，如果是<strong class="kn ir">非空</strong>，那么我们将<strong class="kn ir">加入队列</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ng"><img src="../Images/66dcb4f05378156fd65ded2e37f70596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adfPLBawCsnBP-BQ08KYxA.png"/></div></div></figure><p id="cc1f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir">右节点</strong>，如果是<strong class="kn ir">非空</strong>，那么我们也将<strong class="kn ir">加入队列</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nh"><img src="../Images/37a86eb91749d537e3aa9cfe6e54ee51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4emSVFmUvvN-TXPGdtPPXg.png"/></div></div></figure><p id="11c2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，尺寸将变成<strong class="kn ir"> 0 </strong>，但是这里<strong class="kn ir">深度</strong>将<strong class="kn ir">增加</strong>1。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ni"><img src="../Images/31b35c213683420f81382d5f5abb2fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkbDxoHutr0zzrLkqPqBMg.png"/></div></div></figure><p id="3f9d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">对于<strong class="kn ir">第二次迭代</strong>，我们将首先获得<strong class="kn ir">队列的总大小。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ni"><img src="../Images/9712d5704906d64fc8db3d395dea17f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXcnMd_6T3MoGCDNoDp0-w.png"/></div></div></figure><p id="df1a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们将<strong class="kn ir">从<strong class="kn ir">队列</strong>中移除节点</strong>即<strong class="kn ir"> 2 </strong>，并检查其是否为<strong class="kn ir">左节点</strong>和<strong class="kn ir">右节点</strong>。</p><p id="320f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是对于<strong class="kn ir"> 2 节点的</strong>来说<strong class="kn ir">左节点</strong>和<strong class="kn ir">右节点</strong>都是<strong class="kn ir"> NULL，</strong>所以我们不会添加到堆栈中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ni"><img src="../Images/187650f544e34f888505427a43a0f308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUz6ez8n1S2qk0WRvmMHSA.png"/></div></div></figure><p id="7f1f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们将转移到另一个迭代，我们将从<strong class="kn ir">队列</strong>中取出节点</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nj"><img src="../Images/e7fd967fd686949385fda3b32fafac2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldGGthdyXKOnpi7UVFGyVg.png"/></div></div></figure><p id="ebfa" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，我们将检查它的<strong class="kn ir">左</strong>和<strong class="kn ir">右节点</strong>，这里<strong class="kn ir">左</strong>是<strong class="kn ir"> 4 </strong>而<strong class="kn ir">右</strong>是<strong class="kn ir">空</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/0d69071058a1af5bd468c75c43086442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgTfRCdmLeqLoUSYA_cxZg.png"/></div></div></figure><p id="8c1a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里对于，<strong class="kn ir">根节点 3 </strong>，只有<strong class="kn ir">左节点</strong>为<strong class="kn ir">非空</strong>，所以我们再补充一下。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/6e25e2c75dcbc2e55d7346f4f4f1f3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuLnoiZMiyGNjgyWlfl3Ew.png"/></div></div></figure><p id="aeae" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，迭代结束，我们将<strong class="kn ir">增加深度的大小</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/8ee5c62b26d61d87e644916169581655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrJkIQRkMjV1cgDXcY0-Hg.png"/></div></div></figure><p id="e4c4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下一次迭代，我们将从队列中取值。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/c8635f8994726b61a325525b7a306561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-utSNuP1dN1vTooU0vvjA.png"/></div></div></figure><p id="cbb4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir">根节点</strong>将是<strong class="kn ir"> 4 </strong>，我们将检查它的<strong class="kn ir">左</strong>和<strong class="kn ir">右节点</strong>。</p><p id="6ed7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir">左节点</strong>为<strong class="kn ir">空</strong>，所以我们不加，但是<strong class="kn ir">右节点</strong>为<strong class="kn ir"> 5 </strong>，所以我们加到<strong class="kn ir">队列</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/776cbbb59427551ae1dc4f8560dbf205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoGQ0wfwl0Ah6i-WORLEw.png"/></div></div></figure><p id="ca91" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，迭代结束，我们将<strong class="kn ir">增加深度的大小。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/88e4f0e8aecf0f9822f84c1ff74c8810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AWBPvY2bvi1zDfm5wbB-Q.png"/></div></div></figure><p id="7ad5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下一次迭代，我们将从<strong class="kn ir">队列</strong>中取值。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nj"><img src="../Images/e9ebc58c02a880a41cf9149397745f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTOcWXH-S_Z1YQl8ax7uGQ.png"/></div></div></figure><p id="8b03" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们将<strong class="kn ir">从<strong class="kn ir">队列</strong>中移除<strong class="kn ir"> 2 </strong>的节点</strong>，并检查它是<strong class="kn ir">左节点</strong>和<strong class="kn ir">右节点</strong>。</p><p id="a175" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是对于 5 个<strong class="kn ir">节点的</strong>，左<strong class="kn ir">节点</strong>和右<strong class="kn ir">节点</strong>都是<strong class="kn ir"> NULL，</strong>所以我们不会添加到堆栈中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ni"><img src="../Images/f13d4e2cc945b203dc4c0c1b7920b650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it4MuJaHGK7KYCqPp6JWng.png"/></div></div></figure><p id="c79f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，迭代结束，我们将<strong class="kn ir">增加深度的大小。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/3bf0b05660fd2f92d344a120f5e14cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ovNRWjSY_ZDbbONFaqOmw.png"/></div></div></figure><p id="9fcc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir">队列</strong>变为<strong class="kn ir">空</strong>因此<strong class="kn ir">外 while 循环的</strong> <strong class="kn ir">条件</strong>也将变为<strong class="kn ir">假</strong>。</p><p id="d51c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">函数结束，我们简单的返回<strong class="kn ir">深度</strong>，这将是我们的<strong class="kn ir">答案</strong>。</p><p id="b38a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们看看完整的源代码。</p><h1 id="bacd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Java): →</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="ca59" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Python): →</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="7abf" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="d78d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里，我们遍历两次，所以总时间复杂度是<strong class="kn ir"> O(n ) </strong>。</p><h1 id="2aac" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">空间复杂性</h1><p id="791f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们使用了一个额外的队列，那么，空间复杂度将是 O(n)<strong class="kn ir"><em class="ln">。</em></strong></p><p id="7718" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果您想以其他方式(递归方式)检查解决方案，则<a class="ae nr" href="https://medium.com/@alexmurphyas8/leetcode-104-maximum-depth-of-binary-tree-using-recursive-way-solution-with-images-91c427de9c6c" rel="noopener">点击此处。</a></p><p id="0d51" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">感谢你阅读这篇文章，❤</p><p id="9a12" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果这篇文章对你有帮助，请鼓掌👏这篇文章。</p><p id="0d28" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请在<a class="ae nr" href="https://medium.com/@alexmurphyas8" rel="noopener">媒体</a>上关注我，我会像上面一样发布有用的信息。</p><p id="3515" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">insta gram→<a class="ae nr" href="https://www.instagram.com/alexmurphyas8/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/alexmurphyas8/</a></p><p id="c813" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">推特→<a class="ae nr" href="https://twitter.com/AlexMurphyas8" rel="noopener ugc nofollow" target="_blank">https://twitter.com/AlexMurphyas8</a></p><p id="e278" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p></div></div>    
</body>
</html>