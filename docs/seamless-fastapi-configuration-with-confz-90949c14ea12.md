# 使用 ConfZ 的无缝 FastAPI 配置

> 原文：<https://blog.devgenius.io/seamless-fastapi-configuration-with-confz-90949c14ea12?source=collection_archive---------0----------------------->

![](img/d456828ce42f67eff7c58b89ba06ac27.png)

FastAPI、SQLModel 和 ConfZ 的现成模板，轻松构建高度可配置的强大 API。

[ConfZ](https://github.com/Zuehlke/ConfZ) 是 Python 新的**配置管理库**。它基于 [pydantic](https://pydantic-docs.helpmanual.io/) ，这使得它可以完美地与 FastAPI 一起使用。结合新的 [SQLModel](https://sqlmodel.tiangolo.com/) ORM，它也使用 pydantic，您得到了 API 的完美三重奏。

在下文中，我们首先展示一个由 FastAPI 和 SQLModel 组成的示例项目。然后，我们添加 ConfZ 并展示我们可以多么轻松地:

*   **配置** API 细节，无需硬编码
*   管理所有**环境**(开发、测试、生产……)的数据库
*   编写**测试**而无需注入任何代码

所有代码都可以在 [GitHub](https://github.com/silvanmelchior/FastAPI_ConfZ_Demo) 上获得。

# 示例项目

让我们从一个基于 FastAPI 和 SQLModel 的样例项目开始，它的灵感来自于 SQLModel 的文档。这是一个允许**管理用户**的 API。目前，用户仅由一个`id`和一个`name`组成。按照文档中的建议，我们创建一个包含所有公共字段的`UserBase`类，然后添加表、读取和创建场景的细节*(更新目前被忽略)*。

我们还需要一些逻辑来创建引擎和管理会话:

当然，我们需要我们的 API:

现在我们有了创建我们的**路线**的所有材料:

就是这样。由于 FastAPI 和 SQLModel 的巧妙集成，我们只需要这几行代码就可以实现一个(基本的)用户管理 API。为了简单起见，我们忽略了这个例子中的更新和删除*(但是它们也非常简单)*。

# 配置我们的 API

在我们的 API 文件中，我们有**硬编码的**特定配置，如 API 标题或 CORS 起源。这当然不是好的做法。例如，将它们放在 yaml **配置文件**中会更好:

多亏了 ConfZ，现在加载这个文件、验证它的内容，然后在我们的应用程序中使用它变得很简单。我们只需要定义**配置方案**(与我们定义 API 方案或 DB 方案的方式相同)并指定配置文件的位置:

我们现在可以直接使用这个配置，**而不需要任何额外的步骤**:

ConfZ **在我们第一次访问 config** 时自动加载它，使用 pydantic 验证它给定的配置模式，然后为以后的每次访问提供一个缓存副本。

# 配置我们的数据库

虽然我们的 API 配置仍然是相对静态的，但是 DB 配置依赖于**环境**:

*   在开发过程中，为了方便起见，我们使用本地 SQLite 数据库
*   在生产中，我们使用外部 PostgreSQL 数据库
*   对于测试，我们使用内存中的 SQLite DB

为了尽可能灵活，我们希望每个环境都有一个**配置文件(测试除外，我们将在后面介绍)。为了区分不同的环境，我们想读取一个相应的**环境变量**。任何 DB **凭证**也应该从环境中读取，因为我们不想将它们直接放在配置文件中。**

虽然这些需求一开始可能听起来很复杂，但实际上使用 ConfZ 非常简单。首先，我们定义我们的**配置类和源**:

我们的数据库配置`DBConfig`包含 echo-setting 和两种类型的数据库。根据`type`字段的不同，它可以是 SQLite DB(内存中或指定位置)或 PostgreSQL DB。`CONFIG_SOURCES`定义了 ConfZ 应该检查 config-folder 并使用在环境变量`DB_ENV`中指定的文件。我们可以用文件将这个变量设置为 *db_dev.yml* :

或者用文件 *db_prod.yml* :

在后一种情况下，我们还需要设置环境变量`DB.USER`和`DB.PASSWORD`。

现在，我们可以使用这个配置来创建我们的数据库:

就这样，我们已经用这几行代码涵盖了上面的所有需求。

# 测试

FastAPI 有一个丰富的**依赖注入系统**来简化测试。然而，在本教程中，我们不需要它，因为我们的数据库类已经支持内存数据库，我们只需要**修改配置**并将`db.path`设置为`None`。ConfZ 中的每个 config 类都支持这种开箱即用，并有一个专用的**上下文管理器**:

我们在这里定义的是一个具有`autouse=True`的数据库夹具，所以我们不会意外地访问开发*(或者更糟:生产)*数据库。我们直接在代码中定义测试配置，并用新的配置覆盖现有的配置源。

这里缺少了一部分:我们已经在模块级定义了`engine`，所以改变配置不会有直接帮助，因为**引擎已经在那个时间点创建了**。为了防止这种情况，我们用一个 getter 函数代替了直接创建:

来自 ConfZ 的`depends_on`装饰器确保我们在第一次调用*后得到一个**缓存副本**(单例机制，就像以前一样在模块级)*。它还确保当我们用上下文管理器更改`DBConfig`时，我们**重新创建引擎**。

我们现在可以用`get_engine()`替换对`engine`的所有访问，ConfZ 将确保所有 FastAPI 路由都使用新的引擎。

我们现在已经准备好编写我们的单元测试了，再也不用担心任何依赖性了:

# 早期验证

仍然缺少一个小细节:在启动时，加载我们的 API 配置并创建 API。然而，只有在我们第一次访问时，即第一次调用用户路线时，才会加载数据库配置并创建引擎**。**

如果在那个时间点上我们的配置没有被正确地指定(例如没有设置`DB_ENV`变量)，ConfZ 将抛出一个错误。这可能很晚了，最好在启动时检查所有的**。幸运的是，ConfZ 也提供了一个答案。我们只需要调整我们的`on_startup`方法:**

ConfZ 的`validate_all_configs`将检查所有的配置类，加载它们的源代码，并且**已经验证了内容**。因此，数据库配置中的错误将在该时间点被发现。标志`include_listeners`确保`get_engine`也已经被执行，所以配置不仅有正确的模式，而且我们实际上也可以连接到我们的数据库。

# 结论

正如我们所见，ConfZ **自然地将**与 FastAPI 和 SQLModel 集成在一起。它们共同组成了一个三人组，可以用来轻松构建高度可配置且功能强大的 API。

[ConfZ 在 GitHub 上](https://github.com/Zuehlke/ConfZ)。如果你喜欢它，尝试一下，看看它是否也适合你！

*更多内容尽在*[*blog . dev genius . io*](http://blog.devgenius.io)*。*