<html>
<head>
<title>Best practices for multi-module projects with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 多模块项目的最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-practices-for-multi-module-projects-with-spring-boot-28566174811f?source=collection_archive---------4-----------------------#2022-09-26">https://blog.devgenius.io/best-practices-for-multi-module-projects-with-spring-boot-28566174811f?source=collection_archive---------4-----------------------#2022-09-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d28d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现实世界中的大多数应用，从长远来看都会积累大量的特性和代码。<strong class="jm io">多模块项目是构建应用的好方法</strong>,无需走复杂的微服务之路。以下五个建议可以帮助你更好地组织这样的 Spring Boot 项目。</p><h2 id="70fe" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">#1 找到合适的模块结构</h2><p id="e5d2" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">总的来说，使用两个模块<em class="lg">【基础】</em>和<em class="lg">【web】</em>是 Spring Boot 应用程序的一个<strong class="jm io">好的起点。“基础”模块描述基本设置，例如数据库设置，并提供实用程序类。此处定义的标准适用于所有其他模块。在“web”中，所有模块被组合在一起，可执行的应用程序被构建——我们的可执行程序“fat jar”。</strong></p><p id="8521" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中间模块<strong class="jm io">的结构应该更少技术性，更多领域驱动</strong>。首先，这里有一个划分网店的反面例子。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/e37f2623261b11f6ca1154ad72657a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*xOBjsSF2dfZ4bYGc.png"/></div></figure><p id="9541" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lg">技术结构不佳的例子</em></p><p id="41ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然纯粹的<strong class="jm io">技术分离是可能的，但它提供的优势很少</strong>:对于一个开发人员来说，要执行一个典型的任务(“向搜索添加一个过滤器”)，所有涉及的工件都必须从多个模块中收集。然而，使用领域驱动的细分，对于许多任务，定制将被限制在一个模块中。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/de41574d8b9b20975ab57e343a3101d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*tIxDgdxTCMt7v3XD.png"/></div></figure><p id="3964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">▴ <em class="lg">领域驱动模块化的好例子</em></p><p id="12eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当应用程序随着时间的推移而扩展时，很容易添加更多具有域驱动结构的模块，例如“blog”。对于技术分离，这没有什么意义，在某些时候<strong class="jm io">你会以一个大泥球</strong>结束。</p><h2 id="bff5" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">#2 最大限度减少依赖性</h2><p id="47fd" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">每个模块应该<strong class="jm io">包含它需要提供自己的功能</strong>的所有工件，以便最小化对其他模块的依赖性。这包括类、模板、依赖项、资源等等。</p><p id="41ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个有趣的问题是 ORM 层是应该存储在一个中央模块中，还是分散在各个模块中。现在支持分离的人很多，所以实际上没有人反对。每个模块可以包含自己的 JPA 实体和 Flyway/liqui base changelog。当在一个模块中运行集成测试时，一个部分数据库模式将被创建，<strong class="jm io">基于当前的和所有被引用的模块</strong>。</p><p id="11d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个有用的支持分离模块的库是<a class="ae lq" href="https://github.com/tleipzig/springify-multiconfig" rel="noopener ugc nofollow" target="_blank"> Springify Multiconfig </a>。它允许每个模块包含自己的<code class="fe lr ls lt lu b">application-mc-xx.yml</code>文件来存储该模块的特定配置。如果没有这个库，整个配置必须在“基本”模块的<code class="fe lr ls lt lu b">application.yml</code>中。</p><h2 id="8fc6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">#3 持续改进</h2><p id="271f" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">糟糕的架构总比没有好，但是模块的最佳结构从一开始就不清楚。因为所有的依赖关系都在一个应用程序中，所以如果需要，可以通过一个拉请求来调整分区。对于微维修，通常需要广泛的多阶段程序。</p><p id="e985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">质疑现状并从长远来看进一步改善现状总是值得的。</p><h2 id="9092" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">#4 Gradle api 与实施</h2><p id="8744" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">在开发模块的代码时，当前项目的直接和间接引用的模块总是可用的。当外部库被声明为依赖时，在 Gradle 中有两种可能性:使用<code class="fe lr ls lt lu b">api</code>(以前的<code class="fe lr ls lt lu b">compile</code>)库也是间接可见的，而使用<code class="fe lr ls lt lu b">implementation</code>库只在当前模块中可用。换句话说，如果一个模块被引用，并且<code class="fe lr ls lt lu b">implementation</code>、<strong class="jm io">中包含了一个库，那么它将被隐藏，不能在代码</strong>中使用。</p><p id="e5b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最终的应用程序中，所有的依赖项再次以单一的“fat jar”结束，但是在构建过程中，无效的访问已经被阻止了。按照这种方法，开发期间可用的库应该保持更干净。</p><h2 id="7a2b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">#5 使用单独的测试罐</h2><p id="dc19" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">每个模块都有自己的测试来验证它包含的功能。然而，有时会创建测试数据或者提供构建在它们之上的模块所需的实用方法——例如，创建测试用户。</p><p id="02d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，测试<strong class="jm io">所需的类和数据不应该包含在随后在生产</strong>中运行的应用中。对于 Maven、Gradle 和 Kotlin 脚本，有一种方法<strong class="jm io">为每个模块创建单独的测试 jar</strong>。然后这些可以被测试代码专门引用。关于实现的更多背景，Maven 的<a class="ae lq" href="https://bootify.io/multi-module/test-jars-for-maven-multi-module.html" rel="noopener ugc nofollow" target="_blank">在这里，Gradle 的</a><a class="ae lq" href="https://bootify.io/multi-module/test-jars-in-gradle-multi-module.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h2 id="bdc5" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">结论</h2><p id="0b1a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">多模块项目现在正得到越来越多的关注，因为微服务在实践中面临许多挑战，额外的努力只有对较大的开发团队才是值得的。通过遵循最佳实践，<strong class="jm io">可以为现实世界开发出结构良好的应用程序</strong>。如果以后你想转向微服务，可以将单个模块分解为独立的应用程序。</p><p id="74b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Bootify 的专业计划中，一个<strong class="jm io"> Spring Boot 应用可以通过多模块设置</strong>进行初始化。“基础”和“web”模块是默认创建的，自定义模块可以在两者之间预先配置。支持 Maven、Gradle 以及 Kotlin 脚本。</p><p id="c5b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lq" href="https://bootify.io/pricing.html" rel="noopener ugc nofollow" target="_blank">见<strong class="jm io">功能和定价</strong>见</a></p></div></div>    
</body>
</html>