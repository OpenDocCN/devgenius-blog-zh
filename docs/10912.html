<html>
<head>
<title>Read-Once object implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中一次性读取对象的实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/read-once-object-implementation-in-python-743928d04dfc?source=collection_archive---------20-----------------------#2022-12-06">https://blog.devgenius.io/read-once-object-implementation-in-python-743928d04dfc?source=collection_archive---------20-----------------------#2022-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="e2a0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是只读一次的对象？</h1><p id="58cb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这一概念在<a class="ae lg" href="https://www.manning.com/books/secure-by-design" rel="noopener ugc nofollow" target="_blank">设计安全</a>一书中有定义和解释。</p><p id="655f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在这个环节<a class="ae lg" href="https://livebook.manning.com/concept/security/read-once-object" rel="noopener ugc nofollow" target="_blank"> LiveBook </a>也有曝光。</p><p id="c93f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一次性读取对象的总体特征，摘自<a class="ae lg" href="https://adriancitu.com/tag/read-once-object-pattern/" rel="noopener ugc nofollow" target="_blank">书评:安全设计</a></p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="f13c" class="lv jl in lr b be lw lx l ly lz">Read-once objects<br/><br/>A read-once object is an object designed to be read once (or a limited number of times). This object usually represents a value or concept in your domain that’s considered to be sensitive (for example, passport numbers, credit card numbers, or passwords). The main purpose of the read-once object is to facilitate detection of unintentional use of the data it encapsulates.<br/><br/>Here’s a list of the key aspects of a read-once object:<br/><br/>    Its main purpose is to facilitate detection of unintentional use.<br/>    It represents a sensitive value or concept.<br/>    It’s often a domain primitive.<br/>    Its value can be read once, and once only.<br/>    It prevents serialization of sensitive data.<br/>    It prevents sub-classing and extension.</span></pre><h1 id="2781" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">关于用法</h1><p id="ac87" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设您需要向某个服务传递密码，该服务将登录到您的用户。登录服务只需要这个密码一次，那么为什么不限制它只能被读取和使用一次呢？</p><h1 id="f1da" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用 pip 安装:</h1><p id="bd64" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><code class="fe ma mb mc lr b">pip install readonce</code></p><p id="1ad9" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">GitHub 回购-&gt;<a class="ae lg" href="https://github.com/ShahriyarR/py-read-once" rel="noopener ugc nofollow" target="_blank">https://github.com/ShahriyarR/py-read-once</a></p><p id="7356" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后就从<code class="fe ma mb mc lr b">ReadOnce</code>继承:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d7d9" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这里，密码字符串作为一个秘密添加。从我们的定义来看，它只能被读取一次，并且只能使用<code class="fe ma mb mc lr b">get_secret()</code>，不能直接获取秘密。</p><ul class=""><li id="bb32" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">您也不能公开对象属性:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="cd2f" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">尝试读取密码两次:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="65fe" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">如果有人试图将自己的秘密添加到已经实例化的对象中，然后得到已经定义的秘密数据(原始秘密)，那么他将只得到一个新的秘密。</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="62a0" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">您不能从敏感类创建子类，这是一种暴露父类数据的方法，但没有成功:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="e273" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">如果有人试图直接获取机密:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="12d5" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">你不能腌制它:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="6304" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">你不能 JSON 序列化它:</li></ul><p id="a9ca" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">使用默认编码器:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1003" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">带定制编码器:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="cb9d" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">在某些情况下，类本身可以被自动转储到日志中，但在这里不行:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="32d3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Python <a class="ae lg" href="https://docs.python.org/3.10/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank"> Dataclasses </a>怎么样？</h1><p id="5bac" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">关于数据类，禁止直接定义一个字段，然后将其添加到机密:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8307" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">结果将是:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="eabc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">更好的方法是使用字段作为“描述符”。假设您有一个想法，要以整块的方式共享您的数据库凭证。我们可以为每条信息创建单独的敏感数据持有者或机密:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="c843" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后我们可以将它们合并到一个数据类中:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="09a6" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">通过这种方式，我们可以再次使用<code class="fe ma mb mc lr b">get_secret()</code>找回我们的秘密，而且只有一次:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="7594" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">打印或转储凭据对象也不会提供任何有价值的信息:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="012c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">好吧，就 Python 而言，这不是一个完整的“描述符”(没有<code class="fe ma mb mc lr b">__get__</code>和<code class="fe ma mb mc lr b">__set__</code>)，但我不是故意打开这扇门的。</p><ul class=""><li id="3ddb" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">使用数据类的另一种方法是声明字段:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3211" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后在将来初始化这些字段。这种方法类似于 dto(数据传输对象)。</p><ul class=""><li id="2994" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">JSON 有没有可能连载<code class="fe ma mb mc lr b">DBCredentials</code>？如果您决定转储敏感字段，则不可能:尝试使用自定义编码器:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="229c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这同样适用于酸洗:</p><h1 id="d949" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">与<a class="ae lg" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>的关系</h1><p id="7b60" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">正如我们所知，Pydantic 模型是基于类型注释的数据验证的事实上的标准，我们可以很容易地将 ReadOnce 对象与 Pydantic 一起使用。在这一部分，我将分享一些测试。</p><p id="b48f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">用 ReadOnce 对象声明 Pydantic 模型的最简单方法是允许任意类型:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a938" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">创建凭据:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9205" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">同样，敏感数据不会暴露:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d892" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">它不能以默认方式序列化:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1e1e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">不幸的是，ReadOnce 对象的性质阻止了在模型类中使用强大的验证机制。在其核心，敏感对象不能被使用两次，如果它已经被消费:</p><ul class=""><li id="1985" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">如果之前没有调用过<code class="fe ma mb mc lr b">get_secret()</code>，你可以调用任意时间<code class="fe ma mb mc lr b">add_secret()</code>。</li><li id="2d9f" class="mg mh in kk b kl mp kp mq kt mr kx ms lb mt lf ml mm mn mo bi translated">每当您调用<code class="fe ma mb mc lr b">get_secret()</code>时，敏感对象被视为已耗尽。</li></ul><p id="3ed3" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">假设我们想要验证密码长度，并尝试在 Pydantic 模型中添加一个自定义验证器:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3bcb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如您所料，我们首先需要获取机密数据，然后验证它，如果验证通过，我们需要将机密数据放回敏感对象中，这是不可能的。</p><p id="2d77" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">因此，最好将验证逻辑推向<code class="fe ma mb mc lr b">Password</code>敏感类。我们将在未来深入探讨验证。</p><p id="e452" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果我们测试这个<code class="fe ma mb mc lr b">InvalidDBCredentialsModel</code>，它应该会失败:<code class="fe ma mb mc lr b">readonce.UnsupportedOperationException: ('Not allowed on sensitive value', 'Sensitive object exhausted; you can not use it twice')</code></p><blockquote class="mu mv mw"><p id="cc9f" class="ki kj mx kk b kl lh kn ko kp li kr ks my lj kv kw mz lk kz la na ll ld le lf ig bi translated"><em class="in">如果你有任何进一步的想法，请打开一个问题，我们可以探索并找出最佳的用法</em></p></blockquote><h1 id="a029" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">应用合同设计中的最佳实践</h1><p id="a4c5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了进一步确保数据(秘密)的完整性和安全性，我们可以使用<code class="fe ma mb mc lr b">DbC</code>的想法，因为它给了我们一个定义可重用约束的更干净的方法。</p><p id="e78f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我喜欢<a class="ae lg" href="https://github.com/Parquery/icontract" rel="noopener ugc nofollow" target="_blank"> icontract </a>包，这是一个相当方便的工具。我也试图解释这个 YouTube 教程<a class="ae lg" href="https://www.youtube.com/watch?v=yi-GInnc768" rel="noopener ugc nofollow" target="_blank">用 Python 进行契约式设计编程</a>。</p><p id="65a2" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们将我们的敏感类重新定义为:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="377f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">目前的密码验证相当幼稚，它只是检查字符串的长度:这是我们的<code class="fe ma mb mc lr b">pre-condition</code>，它被标记为<code class="fe ma mb mc lr b">@icontract.require</code>。</p><p id="6d16" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">但是什么是<code class="fe ma mb mc lr b">@icontract.ensure</code>?这就是我们所谓的<code class="fe ma mb mc lr b">post-condition</code>:在添加一个秘密之后，秘密存储的长度必须等于 1。</p><p id="e3ef" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们可以使用 regex 添加更复杂的密码验证，这取决于您的业务需求。</p><p id="95bf" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这里应该问这个问题:<em class="mx">“我们的应用程序的密码是什么？”</em></p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="aec4" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">写下密码要求后，作为 DbC 方法的一部分，您可以将它们转换为<code class="fe ma mb mc lr b">pre-conditions</code>。</p><ul class=""><li id="4f72" class="mg mh in kk b kl lh kp li kt mi kx mj lb mk lf ml mm mn mo bi translated">我在<code class="fe ma mb mc lr b">ReadOnce</code>实现中也使用了这些想法，比如:</li></ul><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="64f4" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在这里，我让自己确信一切都被正确重置。</p><p id="b1ec" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">另一个重要的话题是不变量。</p><p id="a1d3" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">考虑一下<code class="fe ma mb mc lr b">ReadOnce</code>对象，在其生命周期中可以没有秘密，也可以只有一个秘密:</p><figure class="lm ln lo lp gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="40e5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果有人试图将多条数据注入秘密存储器，将会失败，因为这是明显的不变违例。</p></div></div>    
</body>
</html>