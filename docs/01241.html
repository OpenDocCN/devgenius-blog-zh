<html>
<head>
<title>Big Int in Go : Handling large numbers is easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的大整数:处理大数很容易</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/big-int-in-go-handling-large-numbers-is-easy-157cb272dd4f?source=collection_archive---------3-----------------------#2020-06-28">https://blog.devgenius.io/big-int-in-go-handling-large-numbers-is-easy-157cb272dd4f?source=collection_archive---------3-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/05db112ddd6b7b967f086bdd6576be27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_Xc-fL_3zWlq21zmhK9rg.jpeg"/></div></div></figure><p id="8c0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，我们希望进行数学运算，这涉及到非常大的整数计算，超出了所有可用的原始数据类型的限制。例如，100 的阶乘包含 158 位数字，因此我们不能将其存储在任何可用的原始数据类型中。Golang 不会隐式检查溢出，因此当 int64 中存储的位数超过 64 位时，这可能会导致意外的结果。</p><p id="00df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，Go 提供了实现任意精度算术(大数)的包“big”。</p><h1 id="b0a8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">描述</h1><p id="ab7e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">支持以下数值类型:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ffdb" class="mf ku in mb b gy mg mh l mi mj">Int    signed integers<br/>Rat    rational numbers<br/>Float  floating-point numbers</span></pre><p id="4708" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Int、Rat 或 Float 的零值对应于 0。因此，新值可以以通常的方式声明，并表示为 0，而无需进一步初始化:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e5d9" class="mf ku in mb b gy mg mh l mi mj">var x Int        // &amp;x is an *Int of value 0<br/>var r = &amp;Rat{}   // r is a *Rat of value 0<br/>y := new(Float)  // y is a *Float of value 0</span></pre><h2 id="87a6" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">工厂功能</h2><p id="782f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">或者，可以使用以下形式的工厂函数来分配和初始化新值:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="18e9" class="mf ku in mb b gy mg mh l mi mj">func NewT(v V) *T</span></pre><p id="7b78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，NewInt(x)返回一个设置为 int64 参数 x 的值的*Int，NewRat(a，b)返回一个设置为分数 a/b 的*Rat，其中 a 和 b 是 int64 值，NewFloat(f)返回一个初始化为 float64 参数 f 的*Float。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="218e" class="mf ku in mb b gy mg mh l mi mj">var z1 Int<br/>z1.SetUint64(123)                 // z1 := 123<br/>z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4<br/>z3 := new(Float).SetInt(z1)       // z3 := 123.0</span></pre><h1 id="5c2d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用法:斐波那契数</h1><p id="be0e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在我们来看一个例子</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="507e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个例子演示了如何使用 big.Int 计算具有 100 位小数的最小斐波那契数，并测试它是否是质数。这概述了大包装的使用。</p><h1 id="94d4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">与其他类型相互转换</h1><p id="41a7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我在使用大软件包时面临的另一个困难是类型转换。类型转换是我们在编写代码开发应用程序时经常要做的事情。</p><p id="3b4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可供我们用作大包输入的数据通常是原始数据类型。最直接的方法是以字符串格式传输这些数据，通常作为某个 JSON 对象的属性。以下是一些将值与<code class="fe mx my mz mb b">big.Int</code>相互转换的例子。</p><h2 id="e0b6" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">从 int 转换</h2><p id="64a4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">将一个<code class="fe mx my mz mb b">int</code>转换成<code class="fe mx my mz mb b">big.Int</code>很简单，但是必须通过<code class="fe mx my mz mb b">int64</code>，就像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ece5" class="mf ku in mb b gy mg mh l mi mj">newBigInt := big.newInt(int64(someInt))</span></pre><h2 id="e7db" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">转换为整数</h2><p id="ceb5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">要将大整数转换为 uint64，请运行以下代码:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="46e1" class="mf ku in mb b gy mg mh l mi mj">var smallnum, _ = new(big.Int).SetString("2188824200011112223", 10)<br/>num := smallnum.Uint64()</span></pre><p id="38ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，Go 不执行边界检查——如果大整数的值不适合 uint64，您将不会得到任何警告，并且<strong class="jx io"> num </strong>将溢出并保存不正确的值。</p><p id="3688" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要转换成带符号的 64 位整数，请使用<code class="fe mx my mz mb b">Int64()</code>而不是<code class="fe mx my mz mb b">Uint64()</code>。</p><h2 id="44ce" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">从字符串转换</h2><p id="e3d4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">假设你持有一个大整数作为<code class="fe mx my mz mb b">string</code>，你用它创建一个<code class="fe mx my mz mb b">big.Int</code>，如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d7a4" class="mf ku in mb b gy mg mh l mi mj"><strong class="mb io">var </strong>bignum, ok = new(big.Int).SetString("218882428714186575617", 0)</span></pre><p id="5972" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果输入到<code class="fe mx my mz mb b">setString()</code>的字符串以“0x”开始，将使用基数 16(十六进制)。如果字符串以“0”开头，将使用基数 8(八进制)。否则，它将使用基数 10(十进制)。您也可以手动指定基数(最多 62)。返回值的类型为<code class="fe mx my mz mb b">*big.Int</code>。如果 Go 未能创建 big.Int，则将<strong class="jx io"> ok </strong>设置为<em class="na"> false </em>。</p><h2 id="2a95" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">转换为字符串</h2><p id="831d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">转换成字符串可以让你序列化为 JSON，打印到控制台，等等，所以它非常有用。</p><p id="51c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要将一个<code class="fe mx my mz mb b">big.Int</code>转换成十六进制符号的<code class="fe mx my mz mb b">string</code>，使用:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="58fc" class="mf ku in mb b gy mg mh l mi mj">str1 := prime1.Text(16) // or: str1 := fmt.Sprintf("0x%x", bigInt)</span></pre><p id="a66a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要转换成十进制记数法，请使用:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9c3c" class="mf ku in mb b gy mg mh l mi mj">str1 := prime1.Text(10) // fmt.Sprintf("%v", bigInt)</span></pre><h1 id="5303" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="26e4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我把这个留给你，让你积累经验。</p><p id="40da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！我希望这篇关于 Go 大整数的短文。有用！当然，欢迎各种评论。</p><h1 id="c4ca" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><div class="nb nc gp gr nd ne"><a href="https://golang.org/pkg/math/big/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">big-Go 编程语言</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Package big 实现任意精度的算术(大数)。支持以下数值类型:Int…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">golang.org</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jt ne"/></div></div></a></div></div></div>    
</body>
</html>