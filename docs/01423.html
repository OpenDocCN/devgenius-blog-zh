<html>
<head>
<title>Useful JavaScript Tips — Formatting Numbers and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的JavaScript技巧——格式化数字和对象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/useful-javascript-tips-formatting-numbers-and-objects-498357062dcf?source=collection_archive---------42-----------------------#2020-07-02">https://blog.devgenius.io/useful-javascript-tips-formatting-numbers-and-objects-498357062dcf?source=collection_archive---------42-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8bd227529e678cacfa5d0061acd410d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cw0xri-PMl_AETl0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">惠特尼·赖特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="51dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写JavaScript代码。</p><h1 id="37a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">国际机场。数字格式</h1><p id="1fc6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Intl.NumberFormat</code>构造函数来格式化数字。</p><p id="722e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1c65" class="mq lc iq mh b gy mr ms l mt mu">const formatter = new Intl.NumberFormat('fr-ca', {<br/>  style: 'currency',<br/>  currency: 'CAD'<br/>})<br/>const price = formatter.format(100);</span></pre><p id="1664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">price</code>就是<code class="fe me mf mg mh b">“100,00 $”</code>，因为我们将地区设置为加拿大法语，货币是加元。</p><p id="f629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以设置<code class="fe me mf mg mh b">minimumFractionDigits</code>属性来设置返回数字字符串中的最小小数位数。</p><p id="40cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="24c3" class="mq lc iq mh b gy mr ms l mt mu">const formatter = new Intl.NumberFormat('fr-ca', {<br/>  style: 'currency',<br/>  currency: 'CAD',<br/>  <!-- -->minimumFractionDigits: 2<br/>})<br/>const price = formatter.format(100);</span></pre><p id="eb58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">minimumFractionDigits</code>设置为2，这样我们将总是显示这些数字。</p><h1 id="9d06" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">国际机场。多重规则</h1><p id="b002" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Intl.PluralRules</code>构造函数让我们返回要使用的复数规则的名称。</p><p id="df2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d149" class="mq lc iq mh b gy mr ms l mt mu">const pr = new Intl.PluralRules('en-gb', {<br/>  type: 'ordinal'<br/>})</span></pre><p id="867e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以对<code class="fe me mf mg mh b">pr</code>使用<code class="fe me mf mg mh b">select</code>方法，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6358" class="mq lc iq mh b gy mr ms l mt mu">pr.select(0)</span></pre><p id="a394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">'other'</code>。如果我们写<code class="fe me mf mg mh b">pr.select(1)</code>，我们得到<code class="fe me mf mg mh b">'one'</code>。</p><p id="93b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pr.select(2)</code>返回<code class="fe me mf mg mh b">'two'</code>，<code class="fe me mf mg mh b">pr.select(3)</code>返回<code class="fe me mf mg mh b">'few'</code>。</p><p id="5a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以创建一个对象来获取该语言的正确序号后缀。</p><p id="9a12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8058" class="mq lc iq mh b gy mr ms l mt mu">const suffixes = {<br/>  'one': 'st',<br/>  'two': 'nd',<br/>  'few': 'rd',<br/>  'other': 'th'<br/>}</span></pre><p id="455f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将数字格式化为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="888d" class="mq lc iq mh b gy mr ms l mt mu">const format = number =&gt; `${number}${suffixes[pr.select(number)]}`</span></pre><p id="9217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用适当的数字调用<code class="fe me mf mg mh b">format</code>函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e0a0" class="mq lc iq mh b gy mr ms l mt mu">format(0)</span></pre><p id="c4e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">'0th'</code>。<code class="fe me mf mg mh b">format(1)</code>返回<code class="fe me mf mg mh b">'1st'</code>以此类推。</p><h1 id="3982" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目标</h1><p id="0f47" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">创建对象有很多方法，我们可以创建一个对象文字，使用<code class="fe me mf mg mh b">Object</code>构造函数或者使用<code class="fe me mf mg mh b">Object.create</code>。</p><p id="eccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f981" class="mq lc iq mh b gy mr ms l mt mu">const dog = {};</span></pre><p id="3804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a145" class="mq lc iq mh b gy mr ms l mt mu">const dog = Object();</span></pre><p id="99bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b32b" class="mq lc iq mh b gy mr ms l mt mu">const dog = Object.create();</span></pre><p id="36d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.create</code>用于创建一个具有自己原型的对象。</p><p id="4f4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不需要设置自己的原型，对象文字是首选方式。</p><p id="7438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以创建一个构造函数来创建多个相同类型的对象。</p><p id="c587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8983" class="mq lc iq mh b gy mr ms l mt mu">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName= lastName;<br/>}</span></pre><p id="b91b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过运行以下命令来使用<code class="fe me mf mg mh b">new</code>操作符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e899" class="mq lc iq mh b gy mr ms l mt mu">const person = new Person('james', 'smith');</span></pre><p id="7912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象总是通过引用传递。</p><p id="fc3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把它赋给一个变量，那么这个变量就引用原始对象。</p><h1 id="855c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">内置对象属性</h1><p id="d078" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大多数对象都有内置属性。</p><p id="7e3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一个包含<code class="fe me mf mg mh b">Object.prototype</code>对象的原型，大多数对象都是从这个原型继承而来的。</p><p id="d4d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有不是用<code class="fe me mf mg mh b">null</code>原型创建的对象都继承自<code class="fe me mf mg mh b">Object.prototype</code>。</p><h1 id="e622" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">()方法的对象值</h1><p id="5fd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript对象有<code class="fe me mf mg mh b">valueOf</code>方法来返回对象的原始表示。</p><p id="6681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="855d" class="mq lc iq mh b gy mr ms l mt mu">const person = { name: 'joe' };<br/>const val = person.valueOf();</span></pre><p id="12e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们拿回物体。</p><p id="0352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它的价值在于我们可以重写方法来返回我们想要的结果。</p><h1 id="9baf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Object toString()方法</h1><p id="fc29" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">toString</code>方法返回一个对象的字符串表示。</p><p id="ed6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7814" class="mq lc iq mh b gy mr ms l mt mu">const person = { name: 'joe' };<br/>const val = person.valueOf();</span></pre><p id="0752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到了<code class="fe me mf mg mh b">‘[object Object]'</code>，但是我们可以覆盖它来得到我们想要的字符串值。</p><h1 id="9f21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查对象是否可枚举</h1><p id="3a37" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象的可枚举性表明我们是否可以遍历一个对象属性。</p><p id="3066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2dbc" class="mq lc iq mh b gy mr ms l mt mu">const person = { name: 'james' }</span><span id="5695" class="mq lc iq mh b gy mv ms l mt mu">Object.defineProperty(person, 'age', {<br/>  value: 27,<br/>  enumerable: false<br/>})</span></pre><p id="6c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">propertyIsEnumerable</code>方法来检查属性是否可以被遍历。</p><p id="2c41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56c5" class="mq lc iq mh b gy mr ms l mt mu">person.propertyIsEnumerable('name')</span></pre><p id="9bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并返回<code class="fe me mf mg mh b">true</code>。</p><p id="4c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="51fd" class="mq lc iq mh b gy mr ms l mt mu">person.propertyIsEnumerable('age')</span></pre><p id="efbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">false</code>。</p><p id="2945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们使用for-in循环遍历<code class="fe me mf mg mh b">person</code>，那么我们将看到<code class="fe me mf mg mh b">name</code>而不是<code class="fe me mf mg mh b">age</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5c73bc4e2e6b1abc87bee2189f655c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ch3F7_BDtfThtcZN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@nomadicrx_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·桑蒂利</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8a22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c63b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用对象文字、<code class="fe me mf mg mh b">Object</code>构造函数和<code class="fe me mf mg mh b">Object.create</code>方法创建对象。</p><p id="69d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查一个对象属性是否是可枚举的，那么我们可以使用<code class="fe me mf mg mh b">propertyIsEnumerable</code>方法。</p><p id="91bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些以语言敏感的方式格式化数字的方法。</p></div></div>    
</body>
</html>