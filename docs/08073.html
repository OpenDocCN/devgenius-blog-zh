<html>
<head>
<title>Experimenting with Javascript User Defined Functions on Trino</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Trino 上试验 Javascript 用户定义函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/experimenting-with-javascript-user-defined-functions-on-trino-ecce32359da4?source=collection_archive---------6-----------------------#2022-05-15">https://blog.devgenius.io/experimenting-with-javascript-user-defined-functions-on-trino-ecce32359da4?source=collection_archive---------6-----------------------#2022-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4a21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们将构建一个简单的 Trino 连接器，它可以对整个数据世界执行任意 Javascript。这是个好主意还是搬起石头砸自己的脚？一起来了解一下吧！</p><p id="a5df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将 Javascript 引入数据，而不是将数据引入 Javascript，这多酷啊？</p><h1 id="b196" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Trino 是什么？</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/bc961c3360aef48569373da03a67beeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CIIbhBsb3A9eUq7r.png"/></div></div></figure><p id="c314" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Trino ，一个以可笑的速度运行的查询引擎。它是用于大数据分析的快速分布式 SQL 查询引擎，可帮助您探索您的数据世界。</p><p id="5646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ls" href="https://trino.io/" rel="noopener ugc nofollow" target="_blank"> Trino </a>让你无需将数据复制到一个统一的存储层，就可以连接并查询你所有的数据。</p><h1 id="84bf" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是用户自定义函数？</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3b80f4e9d4ec5f0e2b910c58b450ff97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*qQ_VT-Iu9ozhbTT3.png"/></div></figure><blockquote class="lu lv lw"><p id="e80d" class="jk jl lx jm b jn jo jp jq jr js jt ju ly jw jx jy lz ka kb kc ma ke kf kg kh ig bi translated"><strong class="jm io">用户定义函数</strong> ( <strong class="jm io"> UDF </strong>)是由程序或环境的用户提供的函数，在这种情况下，通常的假设是函数被构建到程序或环境中。UDF 通常是根据其创建者的要求编写的。<br/> <a class="ae ls" href="https://en.wikipedia.org/wiki/User-defined_function" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="d0e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在数据库环境中，它允许用户发明和提供可重用的逻辑块，并将它们存储在数据库中。</p><p id="b92c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，雪花从一开始就支持<a class="ae ls" href="https://docs.snowflake.com/en/developer-guide/udf/javascript/udf-javascript-introduction.html" rel="noopener ugc nofollow" target="_blank"> Javascript 用户自定义函数</a>。</p><h1 id="a2d8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">为什么使用 Javascript 用户定义函数？</h1><p id="5d98" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">根据 statista 的统计，Javascript 是全球开发者使用最多的编程语言。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mg"><img src="../Images/ed1ccfb54acadb075df8a09e158063a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pgz02wBd9lJi-2BhZk5X_Q.png"/></div></div></figure><p id="13ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么开发人员喜欢 javascript:</p><ul class=""><li id="3a3b" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">易于学习，因为有大量的学习材料</li><li id="b079" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">通过<a class="ae ls" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">国家预防机制</a>形成一个成熟且充满活力的生态系统</li></ul><h1 id="79c7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">简而言之，教程</h1><p id="9280" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我们将开发一个简单的用户定义函数，允许我们使用 JVM 11 的现成 nashorn Javascript 脚本引擎来执行 Javascript 函数。</p><h1 id="6c43" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">会出什么问题呢？</h1><h2 id="bc5e" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">安全性</h2><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5182bec16ca5f915dc40e67bb30c15b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*KVgJTFcPS9dv8bJh.jpg"/></div></figure><p id="1874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，JavaScript 引擎不是沙箱化的，它允许执行任何任意 Java 代码，并在活动的 Java 类加载器上加载任何类。</p><p id="99f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这段代码暴露了 Trino worker 进程的所有环境变量(可能暴露了您的任何数据湖或数据库凭证)。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="6260" class="mv kj in nj b gy nn no l np nq">javascript_eval('function udf() { <br/>  return java.lang.System.getenv();<br/>}')</span></pre><h2 id="2fc9" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">表演</h2><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nr"><img src="../Images/4e9ef13b6a00915973c8336fc6d0a5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1YMdzgGW4s5vPZMr.png"/></div></div></figure><p id="44fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显然，简单的 javascript 函数在用标准的 Trino SQL 函数表达时可能会快得多，这些函数可能会被 Trino 的优化器重写，甚至被推送到底层存储的 T2。</p><p id="37ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用为每次调用解释用户代码的脚本引擎也会带来潜在的高开销。</p><h1 id="534e" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">我们开始吧！</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1c2f1c15daa4dd16f131ebabfb75ab20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*PMjuNr91YKKEHokc"/></div></figure><p id="c347" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">不要在生产中使用这个代码。使用此代码完全由您自己承担风险。</strong></p><p id="a3b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">连接器代码可在<a class="ae ls" href="https://github.com/mdesmet/trino-javascript" rel="noopener ugc nofollow" target="_blank"> my github </a>上获得。</p><h2 id="399b" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">如何在 JVM 上执行 Javascript？</h2><p id="8870" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">使用 Nashorn ScriptEngine，我们可以评估 Javascript 代码并调用任何声明的函数。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="44a3" class="mv kj in nj b gy nn no l np nq">ScriptEngine engine = new ScriptEngineManager().getEngineByName("javascript");<br/>engine.eval("function udf(a,b){ return a + b;}");<br/>System.out.println(((Invocable) engine).invokeFunction("udf", new Object[]{1, 1}));</span></pre><p id="6335" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将应用两个参数，1 和 1。用 Javascript 将它们加在一起，并返回用 Java 自己的 System.out.println 打印的值 2.0。</p><h2 id="a379" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">快速设置新的 Trino 连接器</h2><p id="75be" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了快速设置 Trino 连接器，我们使用了由 Jan wai 开发的<a class="ae ls" href="https://github.com/nineinchnick/trino-plugin-archetype" rel="noopener ugc nofollow" target="_blank">酷 maven 原型</a>。</p><p id="72c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意 Nashorn，下一步我们可以用<a class="ae ls" href="https://www.graalvm.org/22.1/reference-manual/js/NashornMigrationGuide/" rel="noopener ugc nofollow" target="_blank"> GraalVM Javascript 引擎</a>替换现有代码。潜在地也解决了上面提到的安全问题。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="d9f4" class="mv kj in nj b gy nn no l np nq">mvn archetype:generate \                                         <br/>  -DarchetypeGroupId=pl.net.was \<br/>  -DarchetypeArtifactId=trino-plugin-archetype \<br/>  -DarchetypeVersion=1.5-SNAPSHOT \<br/>  -DgroupId=io.innover.trino.plugin.javascript \<br/>  -DartifactId=trino-javascript \<br/>  -DclassPrefix=Javascript \<br/>  -DconnectorNAme=trino-javascript \<br/>  -DgithubRepo=mdesmet/trino-javascript</span></pre><h2 id="26ac" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">创建我们自己的用户定义函数</h2><p id="3d77" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">一些数据库允许使用如下语句创建 UDF</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="9bd2" class="mv kj in nj b gy nn no l np nq"><strong class="nj io">CREATE</strong> <strong class="nj io">FUNCTION</strong> dbo.CtoF(Celsius FLOAT)<br/>  <strong class="nj io">RETURNS</strong> FLOAT<br/>  <strong class="nj io">RETURN</strong> (Celsius * 1.8) + 32</span></pre><p id="b398" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在 Trino 中实现这一点，但这远远超出了 Trino 连接器目前所支持的范围。</p><h2 id="f31c" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">到底是不是瓦拉格斯？</h2><p id="da83" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我们想要的是这样的东西:</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="1c83" class="mv kj in nj b gy nn no l np nq">SELECT javascript_eval('function udf(a, b) { return a + b; }', 1, 1)</span></pre><p id="c6e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个 API 看起来非常类似于现有的<a class="ae ls" href="https://trino.io/docs/current/functions/conversion.html#formatting" rel="noopener ugc nofollow" target="_blank">格式</a>函数，允许传递任意数量的不同类型的变量参数。</p><p id="3fe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看看 Github 上的<a class="ae ls" href="https://github.com/trinodb/trino/blob/f4878e655e4a55111497115489a559d835c69f7c/core/trino-main/src/main/java/io/trino/operator/scalar/FormatFunction.java" rel="noopener ugc nofollow" target="_blank">代码。</a></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="8ca6" class="mv kj in nj b gy nn no l np nq">public final class FormatFunction<br/>        extends SqlScalarFunction<br/>{<br/>    private FormatFunction()<br/>    {<br/>        super(FunctionMetadata.scalarBuilder()<br/>                .signature(Signature.builder()<br/>                        .name(NAME)<br/>                        .variadicTypeParameter("T", "row")<br/>                        .argumentType(VARCHAR.getTypeSignature())<br/>                        .argumentType(new TypeSignature("T"))<br/>                        .returnType(VARCHAR.getTypeSignature())<br/>                        .build())<br/>                .hidden()<br/>                .description("formats the input arguments using a format string")<br/>                .build());<br/>    }</span></pre><p id="9d09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意 variadicTypeParameter 为我们的函数提供了变量。</p><p id="5564" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而不幸的是，连接器目前不支持这一功能。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="1aa7" class="mv kj in nj b gy nn no l np nq">2022-05-15T12:01:16.547+0000 INFO Registering functions from JavascriptPlugin</span><span id="60c9" class="mv kj in nj b gy nt no l np nq">java.lang.IllegalArgumentException: Class [io.innover.trino.plugin.javascript.JavascriptEvalFunction] does not have any methods annotated with <a class="ae ls" href="http://twitter.com/ScalarFunction" rel="noopener ugc nofollow" target="_blank">@ScalarFunction</a> or <a class="ae ls" href="http://twitter.com/ScalarOperator" rel="noopener ugc nofollow" target="_blank">@ScalarOperator</a></span></pre><h2 id="5d61" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">我们必须重新发明我们的 API…</h2><p id="f765" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">使用行类型怎么样？</p><p id="ec5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，<a class="ae ls" href="https://trino.io/docs/current/language/types.html#row" rel="noopener ugc nofollow" target="_blank">行</a>类型类似于数据库行。那一行的每一列都可能是不同的类型，这正是我们所需要的。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="e818" class="mv kj in nj b gy nn no l np nq">SELECT javascript_eval('function udf(a, b) { return a + b; }', ROW(1, 1))</span></pre><p id="d695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还需要坚持使用 Trino docs 中自定义 UDF 的 e <a class="ae ls" href="https://trino.io/docs/current/develop/functions.html" rel="noopener ugc nofollow" target="_blank">示例中的注释。</a></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="2fdd" class="mv kj in nj b gy nn no l np nq">@ScalarFunction("javascript_eval")<br/>@TypeParameter("V")<br/>@SqlType(StandardTypes.<em class="lx">VARCHAR</em>)<br/>public static Slice evalWithArgs(<br/>        @TypeParameter("V") RowType rowType,<br/>        @SqlType(StandardTypes.<em class="lx">VARCHAR</em>) Slice slice,<br/>        @SqlNullable @SqlType("V") Block row)<br/>{<br/>    Object[] args = <em class="lx">mapArgs</em>(rowType, row);<br/>    return <em class="lx">executeJavascript</em>(slice, args);<br/>}</span></pre><p id="665b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">javascript 执行正是我们在上面讨论过的，但是如何得到我们的参数，行元素？</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="ea33" class="mv kj in nj b gy nn no l np nq">private static final Set&lt;Type&gt; <em class="lx">SUPPORTED_TYPES </em>= ImmutableSet.<em class="lx">of</em>(<em class="lx">UNKNOWN</em>, <em class="lx">TINYINT</em>, <em class="lx">SMALLINT</em>, <em class="lx">INTEGER</em>, <em class="lx">BIGINT</em>);</span><span id="b9cc" class="mv kj in nj b gy nt no l np nq">private static Object[] mapArgs(RowType rowType, Block block)<br/>{<br/>    int positionCount = block.getPositionCount();<br/>    List&lt;Type&gt; types = rowType.getTypeParameters();<br/>    Object[] output = new Object[positionCount];<br/>    for (int position = 0; position &lt; positionCount; position++) {<br/>        Type type = types.get(0);<br/>        if (!<em class="lx">SUPPORTED_TYPES</em>.contains(type)) {<br/>            throw new TrinoException(<em class="lx">NOT_SUPPORTED</em>, "Argument of type " + type.getDisplayName() + " is not supported in javascript_eval invocation.");<br/>        }<br/><br/>        if (type.equals(<em class="lx">UNKNOWN</em>)) {<br/>            output[position] = null;<br/>        }<br/>        if (type.equals(<em class="lx">TINYINT</em>) || type.equals(<em class="lx">SMALLINT</em>) || type.equals(<em class="lx">INTEGER</em>) || type.equals(<em class="lx">BIGINT</em>)) {<br/>            output[position] = type.getLong(block, position);<br/>        }<br/>        if (type.equals(<em class="lx">REAL</em>)) {<br/>            output[position] = <em class="lx">intBitsToFloat</em>(<em class="lx">toIntExact</em>(type.getLong(block, position)));<br/>        }<br/>        if (type.equals(<em class="lx">DOUBLE</em>)) {<br/>            output[position] = type.getDouble(block, position);<br/>        }<br/>    }<br/>    return output;<br/>}</span></pre><p id="3767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将限制对数字类型的支持。在后面的会话中，我们可能会添加对更多类型的支持，例如字符串类型或带有命名字段的嵌套行(javascript 对象？).</p><h2 id="e495" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">它真的有用吗？</h2><p id="016a" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">让我们添加一个单元测试来看看它是否有效。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="414a" class="mv kj in nj b gy nn no l np nq">@Test<br/>public void javascriptEval()<br/>{<br/>    assertFunction("javascript_eval('function udf(a,b){ return a + b;}', ROW(1, 1))", <em class="lx">VARCHAR</em>, "2.0");<br/>}</span></pre><p id="a16b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试成功完成！</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nu"><img src="../Images/fac88502ef909eab3f6771a4178b0e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHNHB6OMtmj3ZqYd8azXjQ.png"/></div></div></figure><h2 id="b160" class="mv kj in bd kk mw mx dn ko my mz dp ks jv na nb kw jz nc nd la kd ne nf le ng bi translated">接下来我们能做什么？</h2><ul class=""><li id="02d4" class="mh mi in jm b jn mb jr mc jv nv jz nw kd nx kh mm mn mo mp bi translated">向 GraalVM Javascript 迁移以提高安全性和性能</li><li id="d8f3" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">支持更多的输入类型(如嵌套对象)</li><li id="71a9" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">支持更多输出类型</li></ul><p id="2dd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请在评论中告诉我你接下来想看什么！</p></div></div>    
</body>
</html>