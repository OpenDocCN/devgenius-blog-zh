<html>
<head>
<title>Metaprogramming in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elixir 中的元编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/metaprogramming-in-elixir-4c74ba9dddc8?source=collection_archive---------1-----------------------#2021-05-23">https://blog.devgenius.io/metaprogramming-in-elixir-4c74ba9dddc8?source=collection_archive---------1-----------------------#2021-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dda5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习如何编写能写代码的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/881f3b0b2fd116c394ab50ca384addb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2qtZexPTPtNhLsE8YJGRg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@didsss?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Didssph </a>在<a class="ae kv" href="https://unsplash.com/s/photos/russian-doll?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="956e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，我们认为程序是操纵数据以达到某种结果的东西。</p><p id="5d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是数据呢？</p><p id="a8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们能把程序本身作为数据吗？🤔</p><p id="b895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在今天的文章中，我们将在 Elixir 的帮助下进入兔子洞，这是一种渗透了元编程的编程语言。</p><h1 id="add7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是元编程？</h1><p id="faf8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">元编程只是编写操纵程序的程序。这是一个相当广泛的术语，可以包括编译器、解释器和其他种类的程序。</p><p id="06ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将重点关注元编程，因为它是在 Elixir 中完成的，涉及宏和编译时代码生成。</p><h1 id="cb96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Elixir 中的元编程</h1><p id="ea1c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了理解元编程在 Elixir 中是如何工作的，理解一些关于编译器如何工作的事情很重要。在编译过程中，每个计算机程序都被转换成抽象语法树(AST)——一种使计算机能够理解程序内容的树结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/1ecc8d20018fd066a93e970f85e8f6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ju_Ds_oh3OCZC1C_.png"/></div></div></figure><p id="fd84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 Elixir 中，AST 的每个节点(基本值除外)都是一个由三部分组成的元组:函数名、元数据和函数参数。</p><p id="8409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elixir 使我们能够通过<code class="fe mq mr ms mt b">quote</code>访问这个内部 AST 表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用<a class="ae kv" href="https://elixir-lang.org/getting-started/meta/macros.html" rel="noopener ugc nofollow" target="_blank">宏</a>修改这些 AST，这些宏是从 AST 到 AST 的函数，在编译时执行。</p><p id="0b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用宏来生成样板代码，创建新的语言特性，甚至构建特定于领域的语言(DSL)。</p><p id="e32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我们在 Elixir 中经常使用的许多语言结构，如<code class="fe mq mr ms mt b">def</code>、<code class="fe mq mr ms mt b">defmodule</code>、<code class="fe mq mr ms mt b">if</code>等都是宏。此外，许多流行的库，如<a class="ae kv" href="https://www.phoenixframework.org/" rel="noopener ugc nofollow" target="_blank"> Phoenix </a>、<a class="ae kv" href="https://hexdocs.pm/ecto/getting-started.html" rel="noopener ugc nofollow" target="_blank"> Ecto </a>和<a class="ae kv" href="https://hexdocs.pm/absinthe/Absinthe.html" rel="noopener ugc nofollow" target="_blank">absinie</a>都自由地使用宏来创建方便的开发人员体验。</p><p id="6619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是文档中的一个 Ecto 查询示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elixir 中的元编程是一个非常强大的工具。它在表现性上接近于<a class="ae kv" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="noopener ugc nofollow" target="_blank">LISP</a>(OG 元编程 steam roller)，但在抽象性上保持了一个层次，使您能够仅在需要时钻研 AST。换句话说，Elixir 是<em class="mw">基本上是</em> LISP 但是可读的。🙃</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="a1e4" class="ls lt iq bd lu lv ne lx ly lz nf mb mc jw ng jx me jz nh ka mg kc ni kd mi mj bi translated">入门指南</h1><p id="f772" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">那么我们如何引导这种巨大的力量呢？🧙</p><p id="95a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然元编程可能相当棘手，但在 Elixir 中开始元编程是相当简单的。你只需要知道三件事:引号，非引号，和 defmacro。</p><h2 id="a388" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">引用</h2><p id="a2ed" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">quote</code>将酏剂代码转换为其内部 AST 表示形式。</p><p id="219f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将正则表达式和带引号的表达式的区别看作是两个不同请求的区别。</p><ul class=""><li id="df07" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">请说出你的名字。在这里，要求是用你的名字回复。</li><li id="de81" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">请说“你的名字”。在这里，请求是用语言中请求的内部表示——“你的名字”来回复。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="96d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">quote</code>编写宏变得轻而易举，因为我们不必手工生成或编写 AST。</p><h2 id="9236" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">引文止</h2><p id="1157" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">但是如果我们想要访问<code class="fe mq mr ms mt b">quote</code>内部的变量呢？解决方法是<code class="fe mq mr ms mt b">unquote</code>。</p><p id="c2ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">unquote</code>类似字符串插值的功能，使您能够从周围的上下文中将变量拉入引用的块中。</p><p id="2c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是它在《长生不老药》中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="962e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不去引用<code class="fe mq mr ms mt b">two</code>，我们将得到 Elixir 的内部表示，它是一个叫做 two 的未赋值变量。如果我们取消对它的引用，我们就可以访问引用块中的变量。</p><h2 id="48b7" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">定义宏</h2><p id="9998" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://elixir-lang.org/getting-started/meta/macros.html" rel="noopener ugc nofollow" target="_blank">宏</a>是从 ASTs 到 ASTs 的功能。</p><p id="6cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们想创建一种新的表达式来检查数字的奇怪性。</p><p id="6a87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用几行代码<code class="fe mq mr ms mt b">defmacro</code>、<code class="fe mq mr ms mt b">quote</code>和<code class="fe mq mr ms mt b">unquote</code>为它制作一个宏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="1b4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么时候应该使用元编程？</h1><blockquote class="oj ok ol"><p id="7350" class="kw kx mw ky b kz la jr lb lc ld ju le om lg lh li on lk ll lm oo lo lp lq lr ij bi translated"><em class="iq">规则 1:不要写宏——Chris MC cord，Elixir 中的元编程</em></p></blockquote><p id="9821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然元编程可能是一个很棒的工具，但应该谨慎使用。</p><p id="f2fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">宏会使调试更加困难，并增加整体的复杂性。只有在必要的时候才应该求助于它们——当您遇到无法用常规函数解决的问题时，或者当您需要隐藏幕后的许多管道时。</p><p id="b57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，如果使用得当，它们会非常有益。</p><p id="739c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解宏在现实生活中是如何使用的，你可以看看我们的教程，为定义定制函数构建一个<a class="ae kv" href="https://serokell.io/blog/elixir-metaprogramming#build-your-own-macro-in-elixir" rel="noopener ugc nofollow" target="_blank">宏。</a></p><h1 id="1a4d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进一步学习</h1><p id="70d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您想了解更多关于 Elixir 中的宏的知识，我建议查看以下资源:</p><ul class=""><li id="e0de" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated"><a class="ae kv" href="https://pragprog.com/titles/cmelixir/metaprogramming-elixir/" rel="noopener ugc nofollow" target="_blank">仙丹中的元编程</a>。Chris McCord 的书通过精彩实用的代码示例对宏进行了相当深入的介绍。</li><li id="790d" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><a class="ae kv" href="https://www.theerlangelist.com/article/macros_1" rel="noopener ugc nofollow" target="_blank">了解仙丹宏</a>。SAA juri 撰写的这个系列文章比我更详细地介绍了这个主题，如果您没有时间阅读 Chris 的书，这也是一个不错的选择。</li><li id="b874" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">不要写宏，但要学习它们是如何工作的。如果你更喜欢看视频，这是杰西·安德森的一个很好的演讲。</li></ul></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="1c83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">最初发布于</em><a class="ae kv" href="https://serokell.io/blog/elixir-metaprogramming" rel="noopener ugc nofollow" target="_blank"><em class="mw">https://sero Kell . io</em></a><em class="mw">。</em></p></div></div>    
</body>
</html>