# 更换累加器模式

> 原文：<https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4?source=collection_archive---------0----------------------->

保持代码安全不变的函数式编程策略

![](img/23a1d0b4b32b44722ab5ff69d5e2a9b2.png)

由 [timJ](https://unsplash.com/@the_roaming_platypus?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

*杰森·李·霍奇斯是软件工程团队的领导者，也是《从零开始的软件工程》一书的作者你可以在这里* *了解更多关于这本书的信息或者在线订购* [*。*](http://bit.ly./JHODGES)

累加器模式可以说是软件工程中最常用的设计模式。即使那些没有学习过设计模式，甚至可能没有意识到他们正在使用这种模式的人，也倾向于频繁地使用它。它有几个显著的优势，有助于其持续重现。然而，当将它的使用与常见的函数式编程最佳实践进行比较时，它也引发了一些危险信号。如果您像许多其他人一样，正在努力将您的代码移植到一个函数式范例中，那么理解什么是累加器模式，为什么它被如此频繁地使用，它的缺点是什么，以及用什么来代替它，将会使您受益匪浅。

累加器模式是一种策略，1)实例化一个变量 2)迭代一组数据、一个范围，或者直到满足一个条件，3)通过每次迭代更新初始变量。在迭代之外定义的变量被称为**累加器**。图 1 提供了一个使用 typescript 对列表中的所有数字求和的基本累加器模式的示例。

图 1 —基本累加器模式

图 1.2 提供了另一个稍微复杂一点的累加器模式的例子，它基于一列数据构建一个对象。在这种情况下，累加器就是`week`变量。

图 1.2 —构建对象的累加器模式

我经常发现，在进行代码评审时，甚至一些我最尊敬和最有经验的同事也经常求助于累加器模式来完成他们代码库中的任务。我认为它被如此频繁地使用有几个原因。首先，当处理这些类型的挑战时，它可能是软件开发中最先学习的策略之一。就像学习一门新的口语并在头脑中将其翻译回你的母语一样，当试图解决编程中的问题时，最简单的方法通常是求助于你第一次学习的最基本或最简单的方法。第二，有人可能会说，它容易推理，容易阅读，因此从长远来看最终更容易维护。这是为一个幼稚的解决方案辩护时常用的论点，虽然它有时可能是正确的，但它几乎总是掩盖了缺乏更大的理解。尽管有这些使用它的常见原因，累加器模式还是有一些缺陷，尤其是考虑到它在函数式编程范例中的使用时。

我不会深入探讨为什么在许多情况下，函数式编程范式被认为比过程式编程更有好处——有几篇文章深入讨论了这个主题，我不需要重复。然而，就其核心而言，函数式编程的论点使用简洁、富于表现力且通常是声明性的语法来产生安全、不可变的状态。或者，累加器模式的过程化风格会导致一个变量的改变或突变，而这个变量不在进行改变的代码体的范围之内。在某些情况下，这可能会导致意想不到的结果，因为该变量也可以在代码中的任何其他地方进行更改，或者被不了解该变量用途的其他开发人员无意中更改。正因为如此，我挑战自己和那些我审查的代码，尽可能避免过程化的风格。有几个容易发现的危险信号表明正在使用过程化范例，所有这些都出现在累加器模式中:

1.  累加器变量
2.  任何种类的可变变量
3.  For 或 while 循环

有人可能会说，将累加器模式改为函数式模式的最简单方法是用一个高阶函数替换 for 循环。图 2 提供了一个使用`forEach`函数进行重构的例子。然而，就其本质而言，`forEach`是用来产生副作用的，这与函数式编程的主要目标相矛盾。这里出现的副作用是累加器的突变。

图 2 —使用高阶函数的累加器模式

## 用什么代替

因此，如果过程风格被认为是一种不好的实践，并且`forEach`没有实现任何显著的好处，那么您应该使用什么来代替呢？出于某种原因，它经常被忽视，但是任何时候你觉得需要使用累加器模式，你应该能够使用一个`reduce`高阶函数来代替(在一些语言中这可能被称为`fold`)。图 3 提供了几个使用`reduce`构建最终变量的例子，该变量从代码中其他地方的数据集合中“累积”值。

图 3 —用 Reduce 函数替换累加器模式

`reduce`函数将一个对数据集合执行操作的回调函数作为其第一个参数——其结果将用于数据集的下一次迭代。这个回调函数接受两个参数，这两个参数代表数据集合的前两项。如果向`reduce`函数提供第二个参数，它将充当“种子”值，或者作为第一个参数通过第一次迭代传递给回调函数的值。后续迭代将使用回调函数的返回值作为回调的下一次迭代的第一个参数，并将集合中的下一项作为第二个参数。因此,“种子”值经常被用作累加器——满足累加器模式试图完成的任务，但是是以功能性和不可变的方式。

如果你认同函数范式确实有益的观点，那么我向你发出挑战，请你注意并纠正你的代码库中的累加器模式，并向你的同事传播这个消息，替换他们代码库中的累加器模式。关于如何使用`reduce`的更多信息，你可以参考这里的 [MDN 文档。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)