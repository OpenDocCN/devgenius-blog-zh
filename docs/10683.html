<html>
<head>
<title>Make optimized Server-Side Rendering with React and Go: Part 1 — Preparing SPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 React and Go 优化服务器端渲染:第 1 部分—准备 SPA</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-optimized-server-side-rendering-with-react-and-go-part-1-preparing-spa-68d1fba9512e?source=collection_archive---------0-----------------------#2022-11-22">https://blog.devgenius.io/make-optimized-server-side-rendering-with-react-and-go-part-1-preparing-spa-68d1fba9512e?source=collection_archive---------0-----------------------#2022-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f28a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们谈到用 React 应用程序完成的 SSR 时，我们通常会考虑像 NextJS 或 NestJS 这样的框架。这种方法非常适合内容丰富的交互式网站。但是如果…</p><p id="ec90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.React 中已经内置了一个 SPA，只实现客户端渲染？</p><p id="68cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.这是用 create-react-app 等第三方 React 模板工具创建的？</p><p id="7f0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.您不喜欢为服务器构建创建单独的 Webpack 配置吗？</p><p id="ab1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.你正在寻找一种便捷的渲染优化方法(不同的缓存策略取决于页面等)。)带轻量级运行时？</p><p id="4ee7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，你不是一个人！在这一系列的文章中，我将向你解释，我是如何实现我自己的便捷 SSR 解决方案的，我将在第二部分给你 Golang 样板文件的链接。以下是该系列文章的链接:</p><p id="36aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链接至第 1 部分—此处</p><p id="7bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链接到第 2 部分—<a class="ae ki" href="https://medium.com/@jzx777/make-optimized-server-side-rendering-with-react-and-go-part-2-programming-server-application-eae03f834702" rel="noopener">https://medium . com/@ jzx 777/make-optimized-server-side-rendering-with-react-and-go-Part-2-programming-server-application-EAE 03 f 834702</a></p><p id="0ba5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一部分将探讨为了让 SSR 发挥作用，您需要对前端应用程序做些什么。让我们开始我们的旅程。耶；3</p><p id="ba1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。SPA 的 index.tsx 条目通常是这样的:</strong></p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="a21c" class="ks kt in ko b be ku kv l kw kx">// src/index.tsx<br/><br/>/* eslint-disable no-restricted-globals */<br/>import React from 'react';<br/>import ReactDOM from "react-dom";<br/>import App from "./components/app";<br/><br/>const root = document.getElementById("root");<br/><br/>ReactDOM.render(<br/>   &lt;App /&gt;,<br/>   root,<br/>);</span></pre><p id="a713" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比如说，我们只需要在页面/屏幕"/pageA "、"/pageB "、"/pageC "上做 SSR，而不需要在其他页面/屏幕上做。您还想保留以前构建 SPA 的开发经验(包括所有客户端渲染内容)。因此，首先，我们需要一种方法来区分浏览器和非浏览器环境。让我们创建简单的全局 var 检查:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="e3cb" class="ks kt in ko b be ku kv l kw kx">// is-client.ts<br/><br/>export const IS_CLIENT = typeof window !== 'undefined';</span></pre><p id="c937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那我们就在半路上了！我们的“index.tsx”文件可以通过以下方式进行修改，以处理上述选择性水合情况:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="92b8" class="ks kt in ko b be ku kv l kw kx">// index.tsx<br/><br/>/* eslint-disable no-restricted-globals */<br/>import React from 'react';<br/>import ReactDOM from "react-dom";<br/>import App from "./components/app";<br/>import { IS_CLIENT } from './is-client';<br/><br/>const getRoot = () =&gt; {<br/>    return document.getElementById("root");<br/>};<br/><br/>// It can be more smart or quick check depending on your use-case<br/>const isHydratedPage = (path: string) =&gt;<br/>    path.startsWith('/pageA') ||<br/>    path.startsWith('/pageB') ||<br/>    path.startsWith('/pageC');<br/><br/>const initializeApp = () =&gt; {<br/>    const root = getRoot();<br/><br/>    // @ts-ignore<br/>    if (process.env.NODE_ENV === 'development') {<br/>        ReactDOM.render(<br/>            &lt;App /&gt;,<br/>            root,<br/>        );<br/>        return;<br/>    }<br/><br/>    if (root.childNodes.length &amp;&amp; isHydratedPage(window.location.pathname)) {<br/>        ReactDOM.hydrate(<br/>            &lt;App /&gt;,<br/>            root,<br/>        );<br/>    } else {<br/>        ReactDOM.render(<br/>            &lt;App /&gt;,<br/>            root,<br/>        );<br/>    }<br/>};<br/><br/>if (IS_CLIENT) {<br/>  initializeApp();<br/>}</span></pre><p id="14ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户端工作的所有修改都已完成。但是我们的服务器渲染器应该如何从页面获取 html 呢？</p><p id="1289" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。我们需要记住几件事:</strong></p><ul class=""><li id="5179" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">区分不同的页面是服务器的责任，因为我们需要用不同种类的资源和缓存策略来获取和缓存页面；</li><li id="0b72" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">浏览器应用程序应该在启动时以某种方式恢复其应用程序状态。如果你用像 Redux 这样的库或者你自己的解决方案来区分应用程序和 UX 状态(我目前正在使用 Redux，所以将会给出关于它的例子)；</li><li id="3ddd" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">运行在服务器上的 JS 应用程序，不能监听 URL 更新，也不知道当前的 URL。因此，我们需要一些来自服务器的预定义路由路径(我将展示一种关于 React Router lib 的方法)；</li><li id="c583" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">启动时应用程序应避免 FOUC(非样式内容的闪存)问题，以获得更好的用户体验；</li></ul><p id="9453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于第一部分，让我们添加仅由服务器使用的端点，以便呈现所需的页面:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="6a36" class="ks kt in ko b be ku kv l kw kx">// index.tsx <br/>// ... rest of client-side startup code we previously wrote<br/><br/>// External endpoints for server renderer<br/>if (!IS_CLIENT) {<br/>    const ssrAPage = (args: string[]) =&gt; {<br/>        const [language, pageAData, requestedPath] = args;<br/>        <br/>        const serverStatePatch = (state: TRootModel) =&gt; {<br/>            const res = {<br/>                ...state,<br/>                globalSettings: {<br/>                    ...state.globalSettings,<br/>                    language: language,<br/>                },<br/>                dataA: JSON.parse(pageAData),<br/>            }<br/><br/>            return res;<br/>        };<br/><br/>        const html = ReactDOMServer.renderToString(<br/>            &lt;App serverStatePatch={serverStatePatch} requestedPath={requestedPath} /&gt;,<br/>        );<br/><br/>        return html;<br/>    };<br/>    // @ts-ignore<br/>    ssrExports.ssrAPage = ssrAPage;<br/><br/>    // ... Rest of endpoints are analogous to it <br/>}</span></pre><p id="8153" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想，在这一点上你有一个问题，比如:“为什么你把 SSR 端点的参数写成一个字符串数组？”。我这样写是因为 JavaScript 解析库的古怪，我将在下一部分介绍它。然而，它工作得很好；</p><p id="9311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如第二点所述，为了使恢复 Redux 状态成为可能，我将添加另一个 SSR 端点来修补初始 Redux 状态:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="3be4" class="ks kt in ko b be ku kv l kw kx">// index.tsx <br/>// ... rest of client-side startup code we previously wrote<br/><br/>// External endpoints for server renderer<br/>if (!IS_CLIENT) {<br/>    const ssrAStatePatch = (args: string[]) =&gt; {<br/>        const [language, pageAData] = args;<br/><br/>        return `<br/>            &lt;script&gt;<br/>                window.__INIT_STATE_PATCH__ = function(state) {<br/>                    var res = {<br/>                        ...state,<br/>                        globalSettings: {<br/>                          ...state.globalSettings,<br/>                          language: "${language}",<br/>                        },<br/>                        dataA: ${pageAData},<br/>                    };<br/><br/>                    return res;<br/>                };<br/>            &lt;/script&gt;<br/>        `;<br/>    };<br/>    // @ts-ignore<br/>    ssrExports.ssrAStatePatch = ssrAStatePatch;<br/><br/>    const ssrAPage = (args: string[]) =&gt; {<br/>        const [language, pageAData, requestedPath] = args;<br/>        <br/>        const serverStatePatch = (state: TRootModel) =&gt; {<br/>            const res = {<br/>                ...state,<br/>                globalSettings: {<br/>                    ...state.globalSettings,<br/>                    language: language,<br/>                },<br/>                dataA: JSON.parse(pageAData),<br/>            }<br/><br/>            return res;<br/>        };<br/><br/>        const html = ReactDOMServer.renderToString(<br/>            &lt;App serverStatePatch={serverStatePatch} requestedPath={requestedPath} /&gt;,<br/>        );<br/><br/>        return html;<br/>    };<br/>    // @ts-ignore<br/>    ssrExports.ssrAPage = ssrAPage;<br/><br/>    // ... Rest of endpoints are analogous to it <br/>}</span></pre><p id="aa69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在状态初始化函数中使用这个精心制作的补丁，如下所示:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="cfed" class="ks kt in ko b be ku kv l kw kx">// State<br/>import { globalSettingsInitState } from './global-settings';<br/>// ... A bunch of init states ...<br/>// Is client<br/>import { IS_CLIENT } from '@is-client';<br/>// Types<br/>import { TRootModel } from './types';<br/><br/>export const createrRootInitState = (): TRootModel =&gt; {<br/>  let res = {<br/>    globalSettings: globalSettingsInitState,<br/>    // ... A bunch of init states ...<br/>  };<br/><br/>  // @ts-ignore<br/>  if (IS_CLIENT &amp;&amp; window.__INIT_STATE_PATCH__) {<br/>    // @ts-ignore<br/>    return window.__INIT_STATE_PATCH__(res);<br/>  }<br/><br/>  return res;<br/>} </span></pre><p id="bb8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序入口的最后一个代码片段包含“App”组件的一些奇怪属性，如“serverStatePatch”。此属性使服务器上的 Redux 状态初始化成为可能，方法如下:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="646c" class="ks kt in ko b be ku kv l kw kx">// State<br/>import { globalSettingsInitState } from './global-settings';<br/>// ... A bunch of init states ...<br/>// Is client<br/>import { IS_CLIENT } from '@is-client';<br/>// Types<br/>import { TRootModel } from './types';<br/><br/>export const createrRootInitState = (serverPatch?: (state: TRootModel) =&gt; TRootModel): TRootModel =&gt; {<br/>  let res = {<br/>    globalSettings: globalSettingsInitState,<br/>    // ... A bunch of init states ...<br/>  };<br/><br/>  if (serverPatch) {<br/>    return serverPatch(res);<br/>  }<br/><br/>  // @ts-ignore<br/>  if (IS_CLIENT &amp;&amp; window.__INIT_STATE_PATCH__) {<br/>    // @ts-ignore<br/>    return window.__INIT_STATE_PATCH__(res);<br/>  }<br/><br/>  return res;<br/>}</span></pre><p id="72b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“createRootInitState”用于存储初始化函数:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="5b74" class="ks kt in ko b be ku kv l kw kx">// eslint-disable-next-line @typescript-eslint/no-unused-vars<br/>import { createStore } from 'redux';<br/>import { makeRootReducer } from '@redux-reducers';<br/>import { createrRootInitState } from '@redux-models';<br/>// IS_CLIENT<br/>import { TRootModel } from '@/redux-models/types';<br/><br/>export const initializeStore = (serverPatch?: (state: TRootModel) =&gt; TRootModel) =&gt; {<br/>  return createStore(<br/>    makeRootReducer(),<br/>    createrRootInitState(serverPatch),<br/>  );<br/>}</span></pre><p id="4cea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">store 在“App”组件中初始化，以处理客户端和服务器的工作，如下所示:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="30a4" class="ks kt in ko b be ku kv l kw kx">// ../app.tsx<br/><br/>import React, { useMemo } from "react";<br/>import { Provider as StoreProvider } from 'react-redux';<br/>import { ThemeProvider } from "styled-components";<br/>import { BrowserRouter, Route, Routes as Switch } from "react-router-dom";<br/>import { StaticRouter } from 'react-router-dom/server';<br/>import { DefaultTheme } from "@themes";<br/>import { Navigate } from 'react-router';<br/>// Screens<br/>import PageA from '@screens/PageA';<br/>// Components<br/>import SomeToolbar from '@components/SomeToolbar';<br/>// Store<br/>import { initializeStore } from '@redux-store';<br/>// Utils<br/>import { withAuth } from './withAuth';<br/>import { TRootModel } from "@/redux-models/types";<br/>// Contexts<br/>import { ServicesProvider } from '@contexts/services';<br/>// Is client<br/>import { IS_CLIENT } from '@is-client';<br/><br/>interface TAppProps {<br/>  serverStatePatch?: (state: TRootModel) =&gt; TRootModel;<br/>  requestedPath?: string;<br/>  requestedQuery?: string;<br/>}<br/><br/>const Router: React.FC&lt;{<br/>  requestedPath?: string;<br/>  requestedQuery?: string;<br/>  children?: React.ReactNode;<br/>}&gt; = ({<br/>  requestedPath,<br/>  requestedQuery,<br/>  children,<br/>}) =&gt; {<br/>  if (IS_CLIENT) {<br/>    return (<br/>      &lt;BrowserRouter&gt;<br/>        {children}<br/>      &lt;/BrowserRouter&gt;<br/>    );<br/>  }<br/><br/>  return (<br/>    &lt;StaticRouter<br/>      location={{<br/>        pathname: requestedPath,<br/>        search: requestedQuery, <br/>      }}<br/>    &gt;<br/>      {children}<br/>    &lt;/StaticRouter&gt;<br/>  );<br/>}<br/><br/>const App: React.FC&lt;TAppProps&gt; = ({ serverStatePatch, requestedPath, requestedQuery }) =&gt; {<br/>  const store = useMemo(<br/>    () =&gt; {<br/>      return initializeStore(serverStatePatch);<br/>    },<br/>    // eslint-disable-next-line react-hooks/exhaustive-deps<br/>    [],<br/>  );<br/>  <br/>  return (<br/>    // @ts-ignore<br/>    &lt;StoreProvider store={store}&gt;<br/>      &lt;ServicesProvider&gt;<br/>        &lt;ThemeProvider theme={DefaultTheme}&gt;<br/>          &lt;Router requestedPath={requestedPath} requestedQuery={requestedQuery}&gt;<br/>            &lt;SomeToolbar /&gt;<br/>            &lt;Switch&gt;<br/>              &lt;Route<br/>                path='/pageA'<br/>                element={&lt;PageA /&gt;}<br/>              /&gt;<br/>              {/* ... rest of pages ... */}<br/>            &lt;/Switch&gt;<br/>          &lt;/Router&gt;<br/>        &lt;/ThemeProvider&gt;<br/>      &lt;/ServicesProvider&gt;<br/>    &lt;/StoreProvider&gt;<br/>  )<br/>};<br/><br/>export default App;</span></pre><p id="14f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，我们还宣布了依赖于环境的选择性路由器。属性“requestedPath”和“requestedQuery”用于第三点中描述的目的；</p><p id="3e6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一点也取决于你使用的造型方法。我使用“样式组件”,所以我在 SSR html 渲染端点中添加了一个可爱的小补丁:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="c180" class="ks kt in ko b be ku kv l kw kx">// index.tsx <br/>// ... rest of client-side startup code we previously wrote<br/><br/>// External endpoints for server renderer<br/>if (!IS_CLIENT) {<br/>    // ... ssr state patch endpoint we previously wrote ...<br/>    const ssrAPage = (args: string[]) =&gt; {<br/>        const [language, pageAData, requestedPath] = args;<br/>        <br/>        const serverStatePatch = (state: TRootModel) =&gt; {<br/>            const res = {<br/>                ...state,<br/>                globalSettings: {<br/>                    ...state.globalSettings,<br/>                    language: language,<br/>                },<br/>                dataA: JSON.parse(pageAData),<br/>            }<br/><br/>            return res;<br/>        };<br/><br/>        const styleSheet = new ServerStyleSheet();<br/>        const html = ReactDOMServer.renderToString(<br/>            styleSheet.collectStyles(<br/>              &lt;App serverStatePatch={serverStatePatch} requestedPath={requestedPath} /&gt;<br/>            ),<br/>        );<br/>        const cssTags = styleSheet.getStyleTags();<br/><br/>        return {<br/>          html,<br/>          cssTags,<br/>        }<br/>    };<br/>    // @ts-ignore<br/>    ssrExports.ssrAPage = ssrAPage;<br/><br/>    // ... Rest of endpoints are analogous to it <br/>}</span></pre><p id="e1a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是选择性 SSR 的 SPA 代码准备的全部内容。根据您使用的库和模式(例如小心‘react-router-DOM’中的‘useSearchParams’:这个钩子在初始化阶段严重依赖浏览器环境，在非浏览器环境下需要省略)；</p><p id="6a2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。准备 HTML 基础模板，以便服务器可以对其应用补丁:</strong></p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="4f41" class="ks kt in ko b be ku kv l kw kx">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;link rel="icon" href="%PUBLIC_URL%/favicon.ico" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/>    &lt;meta name="theme-color" content="#000000" /&gt;<br/>    &lt;meta<br/>      name="description"<br/>      content="example content"<br/>    /&gt;<br/>    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;<br/>    &lt;title&gt;Example SPA&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="%PUBLIC_URL%/styles.css" /&gt;<br/>    &lt;style id="sc-placeholder-root"&gt;&lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;script id="state-patch-root"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d9fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。让我们做一些 Webpack 配置和额外的工作脚本</strong></p><p id="6f17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要做的就是声明我们自己的全局变量，这样 Webpack 就不会破坏它，这样服务器就能够理解它们:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="2e1e" class="ks kt in ko b be ku kv l kw kx">// my-project/config/global-vars.patch.js<br/><br/>module.exports = {<br/>  ssrExports: "ssrExports",<br/>  ssrImports: "ssrImports",<br/>  // I declared ssrImports for some useful server APIs like logging and debugging JS code<br/>};</span></pre><p id="4698" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的 Webpack 配置中:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="8738" class="ks kt in ko b be ku kv l kw kx">// my-project/config/webpack.config.js<br/>const globalVarsPatch = require('./global-vars-patch');<br/><br/>// ...<br/><br/>  plugins: [<br/>    // ... a bunch of other plugins ...,<br/>    new webpack.DefinePlugin({<br/>        ...env.stringified,<br/>        ...globalVarsPatch,<br/>    }),<br/>    // ... a bunch of other plugins ...,<br/>  ],<br/><br/>// ...</span></pre><p id="dfa3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还需要通过对 Terser 插件的一些修改来阻止篡改 SSR 端点:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="0322" class="ks kt in ko b be ku kv l kw kx">// my-project/config/webpack.config.js<br/>// ...<br/><br/>  minimizer: [<br/>    new TerserPlugin({<br/>          terserOptions: {<br/>            parse: {<br/>              ecma: 8,<br/>            },<br/>            compress: {<br/>              ecma: 5,<br/>              warnings: false,<br/>              comparisons: false,<br/>              inline: 2,<br/>            },<br/>            mangle: {<br/>              safari10: true,<br/>            },<br/>            keep_classnames: isEnvProductionProfile,<br/>            // This line makes things work<br/>            keep_fnames: /^ssr[a-zA-Z]+Page|ssr[a-zA-Z]+StatePatch$/,<br/>            output: {<br/>              ecma: 5,<br/>              comments: false,<br/>              ascii_only: true,<br/>            },<br/>          },<br/>        }),<br/>    // ... a bunch of other plugins ...,<br/>  ],<br/><br/>// ...</span></pre><p id="5cbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后要做的是创建 JS 构建复制脚本。服务器需要 JS 构建的稳定名称，但是默认情况下，Webpack 在构建名称中包含散列字符串(但是，在文件缓存的情况下，这对于在客户端强制 JS 捆绑包更新很有用):</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="d4f3" class="ks kt in ko b be ku kv l kw kx">// my-project/job-scripts/copy-build-for-server/index.js<br/><br/>const fs = require('fs/promises');<br/>const path = require('path');<br/>const getFileExtension = require('./file').getFileExtension;<br/><br/>const main = async () =&gt; {<br/>  const pathToStatic = path.resolve(<br/>    __dirname,<br/>    "..",<br/>    "..",<br/>    "build",<br/>    "static",<br/>    "js"<br/>  );<br/>  const fileNames = await fs.readdir(pathToStatic);<br/><br/>  for (const fName of fileNames) {<br/>    const ext = getFileExtension(fName);<br/>    if (fName.startsWith('main') &amp;&amp; ext === 'js') {<br/>      const jsFile = await fs.readFile(<br/>        path.resolve(pathToStatic, fName),<br/>        { encoding: 'utf-8' },<br/>      );<br/><br/>      const writePath = path.resolve(__dirname, "..", "..", "build", "server", "js");<br/>      await fs.mkdir(writePath, { recursive: true });<br/>      await fs.writeFile(<br/>        path.resolve(writePath, "build.js"),<br/>        jsFile,<br/>        { encoding: 'utf-8' },<br/>      );<br/><br/>      console.log('Server build is ready!');<br/>      return;<br/>    }<br/>  }<br/>};<br/><br/>main().catch(err =&gt; console.error(err));<br/>// my-project/job-scripts/copy-build-for-server/file.js</span></pre><pre class="lm kn ko kp bn kq kr bi"><span id="aa1b" class="ks kt in ko b be ku kv l kw kx">// my-project/job-scripts/copy-build-for-server/file.js<br/>const getFileExtension = (path) =&gt; {<br/>  let ptr = path.length - 1;<br/>  while (ptr &gt;= 0 &amp;&amp; path[ptr] !== '.') {<br/>    ptr--;<br/>  }<br/><br/>  return ptr &gt;= 0 ? path.slice(ptr + 1) : '';<br/>};<br/><br/>module.exports = {<br/>  getFileExtension,<br/>};</span></pre><p id="39c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并将该脚本链接到“package.json”中的“build”命令:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="e675" class="ks kt in ko b be ku kv l kw kx">"build": "node scripts/build.js &amp;&amp; node job-scripts/copy-build-for-server/index.js",</span></pre><p id="7e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的温泉之旅结束了！您仍然可以在开发服务器上将它作为客户端呈现的应用程序进行测试。核心内容将在系列的下一部分描述；</p><p id="2ca8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ln">请随意留下你的经验等任何建议。我感谢任何有益的反馈；)</em></p><p id="cb9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ln">我的 git lab:</em><a class="ae ki" href="https://gitlab.com/john-byte" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://gitlab.com/jbyte</em></a><em class="ln">777</em></p></div></div>    
</body>
</html>