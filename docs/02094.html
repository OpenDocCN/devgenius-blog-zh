<html>
<head>
<title>Bridges and Articulation points in an Undirected graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无向图中的桥和接合点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bridges-and-articulation-points-in-an-undirected-graph-fe79347f0745?source=collection_archive---------4-----------------------#2020-07-19">https://blog.devgenius.io/bridges-and-articulation-points-in-an-undirected-graph-fe79347f0745?source=collection_archive---------4-----------------------#2020-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b0c4b9901f91c83808b5a8434f361e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEl0_zT9jeLStJt1hWabPA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来源:新华社</figcaption></figure><p id="a2e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于术语“桥”听起来像两个岛之间的连接，这在两个岛之间的运输和通信中起着关键作用，类似地，无向图中的桥<strong class="kb io"> G(U，V) </strong>是当从图中移除时会增加连接组件的数量的边。换句话说，如果我们移除作为桥的边，那么图将不再保持连通。那么如何在无向图中找到桥呢？</p><h1 id="a5cd" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">寻找桥梁</strong></h1><p id="d235" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在无向图中寻找桥的强力方法是检查每条边是否是桥。这可以通过首先移除边，然后检查由该边连接的顶点是否仍然连接来实现。但是就需要执行的操作数量而言，这种方法的成本非常高。这种方法的时间复杂度是<strong class="kb io"> O(E*(V+E)) </strong>(其中 E 和 V 是图 G 中边和顶点的数量)。我们能做得更好吗？</p><p id="baf0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个问题的答案是肯定的，但是怎么才能做到呢？</p><p id="1bb0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们借助我们著名的 DFS 算法，它的时间复杂度为<strong class="kb io"> O(V+E) </strong>，但在此之前，让我们先了解一下寻找桥梁的主要思想是什么。对于 DFS 树(当我们使用 DFS 遍历一个图时会得到它)，后边缘是连接顶点<strong class="kb io"> V </strong>和顶点<strong class="kb io"> U </strong>的边缘，其中<strong class="kb io"> U </strong>在顶点<strong class="kb io"> V </strong>的父顶点之前被发现。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/911de7a24aedbbdb9f310f8038df57f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9akZUtJyQqc4vog472_hFw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 1 无向图</figcaption></figure><h1 id="12c3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> DFS 树</strong></h1><p id="0e98" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">让我们通过图 1 中给出的示例图来理解后沿的概念。这里我们可以看到边(2，4)、(5，8)、(1，3)、(3，6)和(3，7)是桥。这是因为通过移除这些边，我们增加了连接组件的数量。让我们看一下 DFS 树:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/81faff7c332d2b25b2a987639bcba041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBV_xdmzkUGQvrGQK8WP5w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 2 DFS 树</figcaption></figure><p id="407f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以看到，edge (5，1)是一个后边缘，因为如果我们从节点 1 启动 DFS，我们将遍历并访问节点 5，节点 2 是节点 5 的父节点。后沿是从 5 到 1，其中节点 1 在节点 2(节点 5 的父节点)之前被访问，因此它是后沿。为什么后边缘受到如此多的关注？这是因为，<strong class="kb io">后边缘提供了替代路径</strong>。在这个例子中，如果我们移除边(2，5)，那么边(1，5)将是备选路径，因此该图将仍然保持连接。</p><p id="2a9a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">假设在 DFS 中，当我们寻找与顶点 V 相邻的顶点时，那么(V，U)将是一个桥，当且仅当在 DFS 遍历树中，顶点 U 或它的任何后代都没有到顶点 V 或它的任何祖先的后边缘。</strong>我们可以通过维护<strong class="kb io"> tin[]数组来检查<strong class="kb io"> O(V+E) </strong>时间中后沿的存在，该数组将记录节点首次被访问的时间，</strong>我们还将维护数组<strong class="kb io"> low[]，对于每个顶点 V，该数组记录最早被访问的顶点的发现时间，当前顶点</strong> <strong class="kb io"> V 或以 V 为根的子树中任何具有后沿的顶点，</strong>我们将把 low[]初始化为-1。我们还需要一个变量<strong class="kb io">计时器</strong>来跟踪当前的发现时间。</p><p id="8f48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于更新 low[]我们有 3 种情况:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/63ffa081e4201fafa7f58a5c1aa4e458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHTx30nAFd9myU5nOcuy-g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来源:CP 算法</figcaption></figure><p id="fe0c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，当且仅当 low[u]≤ tin[v]时，存在从<strong class="kb io"> U 或它的一个后代到 V (V 是 U 的父代)</strong>的祖先的后沿。你可以想一想，也许会得到解释。这是因为如果有后沿，则 low[u]的值必须小于 tin[v]。如果 low[u]=tin[v]，则后沿直接从<strong class="kb io"> V </strong>到 U 。<strong class="kb io">因此，DFS 树中的边(v，u)是桥当且仅当 low[u] &gt; tin[v]。</strong></p><p id="bc0a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用此技术查找桥梁的代码如下:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8b65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在代码中，low[s]=min(low[s]，low[x])(在递归 dfs 调用之后)对于在回溯时找到到父顶点的后边缘之后传播更新的值非常重要。注意，我们正在跳过已经访问过的父节点<strong class="kb io">(如果(x==p)继续；).</strong></p><h1 id="58c1" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">寻找关节点</h1><p id="48a2" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">最后，在大量讨论了桥之后，让我们来讨论一下什么是关节点，以及如何在无向图中找到它们。<strong class="kb io">关节点是无向图中的顶点，当与它们相关联的边一起被移除时，它们倾向于增加图中连通分量的数量。</strong>例如，你可以把一个计算机网络看作一个图，那么连接点就是当从网络中移除时，网络将被断开或者以其他方式，网络中连接的组件的数量增加的计算机。现在，我们可以像寻找桥梁一样找到关节点，只需对寻找桥梁的算法做很小的改动。在图 1 中，你可以看到顶点 3，5，2 和 1 是关节点。</p><p id="9c6c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在寻找关节点的算法中有两种情况:</p><ol class=""><li id="f28d" class="mj mk in kb b kc kd kg kh kk ml ko mm ks mn kw mo mp mq mr bi translated">对于 DFS 树中除根之外的所有<strong class="kb io">顶点，如果当前边是<strong class="kb io"> (V，U) </strong>使得<strong class="kb io">没有顶点<strong class="kb io"> U </strong>的</strong>或其后代具有到 V 或 V 的任何祖先的后边缘，则<strong class="kb io"> V 是铰接点。否则，V 不是关节点。</strong></strong></li><li id="72ad" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">如果我们正在寻找的顶点是 DFS 树的根，并且<strong class="kb io">如果根至少有 2 个子节点</strong>，那么通过移除根和它的相关边，我们正在断开它的子节点，因此<strong class="kb io">根是一个铰接点</strong>。<strong class="kb io">否则根不是一个关节点。</strong></li></ol><p id="7a2d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们需要稍微改变一下算法，我们将在遍历 DFS 树时跟踪顶点的父顶点，如果顶点的父顶点= -1，那么我们可以说这是我们的 DFS 树的根，因此进行相应的处理。我们需要改变的第二件事是在图中寻找桥的条件(low[u]&gt;tin[v]，其中 v 是 u 的父节点)。在检查顶点是否是铰接点而不是根的情况下，我们有条件 low[u]≥tin[v]。</p><p id="e63b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">这是因为如果 low[u]=tin[v]，那么后沿直接到 v，否则到 v 的祖先</strong>。<strong class="kb io"> </strong>在这种情况下，如果我们移除顶点 v，那么连接的组件的数量会增加，因此它是一个关节点，但是在桥的情况下，如果我们有 low[u]=tin[v]，那么如果我们移除边(v，u ),如果后边来自 u 的中心，那么图仍将保持连接，因此边(v，u)不是桥。</p><p id="eb05" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是相同的代码:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="57c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们使用图 1 中给出的输入图来跟踪代码，我们将在代码末尾得到以下输出:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/952e151042b4db7347b2228b503076fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTSa9VEDQwTnw__If7XJTg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 3 输出</figcaption></figure><p id="9846" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">寻找桥梁和关节点有许多应用。它们代表了网络的脆弱性，因为通过移除桥和接合点，网络将被断开，更准确地说，网络中连接的组件的数量增加。其他应用可以在社交网络图中，其中一些用户就像接合点，移除它们将断开社交网络。</p><p id="453f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以，文章到此结束。我希望你喜欢它。这是我在 Medium 的第一篇文章。所以，如果你觉得有什么需要改进的地方，你可以给我建议，我会很乐意提高自己。谢了。</p></div></div>    
</body>
</html>