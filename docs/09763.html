<html>
<head>
<title>Must Know These Thread Concepts For Java Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 开发人员必须了解这些线程概念</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/must-know-these-thread-concepts-for-java-developers-ed9bdea495bf?source=collection_archive---------1-----------------------#2022-09-11">https://blog.devgenius.io/must-know-these-thread-concepts-for-java-developers-ed9bdea495bf?source=collection_archive---------1-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1402" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="fd72" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何开始使用 Java 中的线程</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4774455c91a61f481d5125ee95105a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PEbiRAqyww_YdCcP"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">肯尼·埃利亚松在<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上的照片</figcaption></figure><h1 id="d4bc" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">概观</h1><p id="c56e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在 Java 编程中，线程是最流行的并发和并行编程技术。就 Java 技术概念而言，线程帮助我们在 Java 程序中实现并行性，它使应用程序运行得更快，尤其是同时运行多个任务。在本文中，我将通过简单的理论和例子与您分享如何在 Java 编程中使用线程，帮助您更容易理解。</p><h1 id="2d19" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">为什么线程很重要</h1><p id="2c1f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">使用线程有四个原因:</p><ul class=""><li id="75e0" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated"><strong class="lz ja">为了更快地处理后台/批处理任务</strong>:当必须同时执行多个任务时，多线程允许不同的任务并行进行。结果减少了总的处理时间。</li><li id="1c2b" class="mt mu iq lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><strong class="lz ja">充分利用 CPU 能力</strong>:大多数现代 CPU 都有多个处理器，每个处理器都有多个内核。多线程允许不同的处理器运行不同的线程，从而更有效地利用系统资源。</li><li id="63bf" class="mt mu iq lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><strong class="lz ja">为了减少响应时间</strong>:我们也可以使用多线程来减少响应时间，方法是通过将一个大问题分成较小的块并使用多线程处理它们来进行快速计算。</li><li id="bdc2" class="mt mu iq lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><strong class="lz ja">同时为多个用户服务</strong>:假设有一个多线程服务器，这意味着多个用户可以同时连接到服务器。例如，有许多用户同时向服务器发送请求，因此在多线程服务器中，每个用户不必等到应用程序处理完前一个用户的请求，因为他们是独立处理的，彼此不依赖。</li></ul><h1 id="a3ef" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">线程生命周期</h1><p id="f921" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">线程的生命周期是线程从诞生开始到死亡结束时的转换状态。当通过调用 thread 类的 start()方法创建并执行一个新的线程实例时，线程进入 runnable 状态。当调用 Thread 类的 sleep()或 wait()方法时，线程进入不可运行的模式。线程在退出 run()进程时会死亡。</p><p id="1360" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">生命周期中基本上有几个阶段，见下文:</p><p id="7e42" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja"> New </strong>:当一个新线程被创建时，它以新的状态开始它的生命周期。</p><p id="03e5" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">可运行</strong>:新线程启动后，进入可运行状态。在这种状态下，线程被认为正在执行它的任务。</p><p id="ab92" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">阻塞/等待</strong>:当一个线程暂时不活动时，它就处于阻塞/等待状态。</p><p id="bc2a" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">定时等待</strong>:处于定时等待状态的线程在调用带有超时参数的方法时，等待直到超时结束。例如，当一个线程调用 sleep()方法时，它将进入定时等待状态。</p><p id="1c0c" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja"> Terminate (Dead) </strong>:线程在其 run()方法完成语句执行时，处于终止状态。当调用 stop()方法时，线程也可能是死的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bf0e9cc56df1344bb9ce0c054a183445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*Dw41-U29Yb3tyMLl"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来源:<a class="ae le" href="https://www.geeksforgeeks.org" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org</a></figcaption></figure><h1 id="a1a1" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">使用线程类</h1><p id="7e89" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Java 提供了一个线程类来实现编程，它提供了在线程上创建和执行操作的构造函数和方法。</p><p id="77df" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">使用线程构造函数创建线程的示例代码:</p><p id="1a1b" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程():</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="aca2" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">这个例子没有为线程指定任何要执行的代码。</p><p id="a91c" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程(可运行 r):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1368" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><p id="79dc" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">可运行的运行</p><h1 id="86f2" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">扩展线程类</h1><p id="b7d4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这样，一个线程就被一个扩展了 thread 类的新类创建了。该类将覆盖 run()方法，该方法包含应该由线程实现的功能。</p><p id="0b89" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">下面是通过扩展 thread 类来创建线程的示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="95da" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><p id="bfc2" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程正在运行</p><p id="6a99" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">上面，start()方法用于创建一个新线程并使其可运行。新线程从 void run()方法内部开始。</p><h1 id="7e2f" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">实现可运行接口</h1><p id="2d74" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在 Java 中实现多线程的另一种方法是创建一个实现 Runnable 接口的类。Runnable 接口是 java 平台附带的标准 Java 接口。Runnable 接口只有一个方法 run()。我们应该在 run()方法中编写代码来执行线程。</p><p id="25e9" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">这里有一个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="068a" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">start()方法用于调用 run()方法。当 start()被调用时，一个新的堆栈被赋予线程，run()方法被调用以在程序中引入一个新的线程。</p><h1 id="ffc1" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">线程优先级</h1><p id="8695" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在 Java 中，每个线程都有一个优先级。优先级由 1 到 10 之间的数字表示。线程调度器根据线程的优先级来调度线程，以确定应该允许哪个线程执行。</p><p id="a3e9" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程类中定义了三个优先级常量:</p><ul class=""><li id="3bf1" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">线程。最小优先级</li><li id="884e" class="mt mu iq lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">线程。NORM _ 优先级</li><li id="bfde" class="mt mu iq lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">线程。最高优先级</li></ul><p id="711e" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">NORM_PRIORITY 是一个线程的默认优先级，为 5。MIN_PRIORITY 和 MAX_PRIORITY 的其余部分，值分别为 1 和 10。</p><p id="7f40" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程优先级的示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8872" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><p id="d962" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程-1</p><p id="e43a" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程 2</p><p id="2b67" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程-0</p><p id="a6db" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">当执行线程时，优先级高的线程将优先于优先级低的线程。</p><p id="80a0" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">但是，如果有两个线程具有相同的优先级，那么就无法预测哪个线程将获得优先执行权。然后，执行取决于线程调度器的算法(先来先服务等)。</p><p id="4b04" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">举例:</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e217" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><p id="72a6" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程 2</p><p id="d9ed" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程-0</p><p id="1ee6" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">线程的优先级线程-1</p><h1 id="069c" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">线程中常用的方法</h1><p id="ac88" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Thread 类中有很多常用的方法，举例如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/fc1a148608d3c43c484a431edb98710e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eB3OPnEs-CjYnUNMd01HNA.png"/></div></div></figure><h1 id="5d31" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">线程中的同步</h1><p id="07ff" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">当我们在一个程序中启动两个或多个线程时，可能会出现这样的情况:多个线程试图访问相同的资源，最终产生错误的和无法预料的结果。</p><p id="c641" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">例如，有三个线程:A 和 B，它们并发执行，需要访问一个关键资源 C，为了避免访问 C 时发生冲突，线程 A 和 B 必须同步。因此，当 A 访问 C，B 也试图访问 C 时，B 对 C 的访问必须避免冲突，直到 A 完成其操作并从 C 中出来。</p><p id="8c91" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">Java 提供了一种创建线程和使用同步块同步线程任务的方法。Java 中的同步块用 Synchronized 关键字标记。</p><p id="4de7" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">使用了两种同步策略:</p><p id="742f" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">同步方法:</strong></p><p id="8ee5" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">它在声明中使用了 synchronized 关键字。当线程调用同步方法时，同步方法自动获取该方法的锁，并在该方法返回或退出时释放它。</p><p id="2a66" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4daa" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/a49d1eaeb64d1892f323dbde26f0a7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhW7Huo05ZjYeZ0JZNbP2w.png"/></div></div></figure><p id="5cfe" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">同步语句:</strong></p><p id="cfc0" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">声明要同步的代码块。Java 中的同步块在某些对象上是同步的。所有其他试图进入 synchronized 语句的线程都被阻塞，直到 synchronized 语句中的线程退出该块。</p><p id="a96d" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated">示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="92aa" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg nj mi mj mk nk mm mn mo nl mq mr ms ij bi translated"><strong class="lz ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/a49d1eaeb64d1892f323dbde26f0a7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhW7Huo05ZjYeZ0JZNbP2w.png"/></div></div></figure><h1 id="bbed" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="414e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Java 中的线程是每个 Java 开发者都应该知道的重要部分。这对于高效开发同时处理多个任务并充分利用 CPU 能力的程序非常有帮助。这篇文章向我们传达了 Java 中的线程概念以及它们是如何实现的。我希望这篇文章能帮助你更容易地理解 Java 中的线程。</p><h1 id="1e78" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">参考</h1><div class="nr ns gp gr nt nu"><a href="https://www.geeksforgeeks.org/java-lang-thread-class-java/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ja gy z fp nz fr fs oa fu fw iz bi translated">Java - GeeksforGeeks 中的 Java.lang.Thread 类</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">线程化程序中的一行执行。每个程序可以有多个关联的线程。每个线程都有一个…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="od l"><div class="oe l of og oh od oi ky nu"/></div></div></a></div></div></div>    
</body>
</html>