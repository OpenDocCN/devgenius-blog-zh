<html>
<head>
<title>Postgres Storage Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres 存储优化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/postgres-storage-optimization-905978c9fd38?source=collection_archive---------9-----------------------#2022-10-08">https://blog.devgenius.io/postgres-storage-optimization-905978c9fd38?source=collection_archive---------9-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1424" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何优化 Postgres 数据库的存储，最终帮助优化有助于整体数据库性能的查询？</p><p id="5114" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数时候，当存储空间似乎已满时，我们会继续向 Postgres 堆中添加存储空间，因为添加存储空间很便宜。</p><p id="38c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这是应对不断增长的存储需求的正确方法吗？或者我们可以在不增加存储的情况下从容应对，这样有助于降低成本并优化性能。</strong></p><p id="d33b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，了解存储持续增长的原因。几个值得注意的潜力:</p><ol class=""><li id="6edc" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">未使用的索引</li><li id="4e0c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">膨胀</li></ol><p id="779c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们详细讨论这两个问题。</p><h2 id="dd09" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">未使用的索引:</h2><ol class=""><li id="8d2a" class="ki kj in jm b jn lp jr lq jv lr jz ls kd lt kh kn ko kp kq bi translated">索引是在创建表的过程中创建的，从未被使用过。</li><li id="9827" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">索引是用错误的索引类型(b 树、哈希、gin)创建的，我们用不支持的运算符查询了那些列。</li><li id="278f" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">我们最初创建并使用索引，但是过了一段时间后，我们停止使用它，它就成为一个未使用索引的候选。</li></ol><p id="3bf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询查找未使用的索引:</strong></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="12bb" class="kw kx in lz b gy md me l mf mg"><strong class="lz io">select</strong></span><span id="2d7b" class="kw kx in lz b gy mh me l mf mg">relname,</span><span id="0439" class="kw kx in lz b gy mh me l mf mg">indexrelname,</span><span id="ddff" class="kw kx in lz b gy mh me l mf mg">idx_scan,</span><span id="b269" class="kw kx in lz b gy mh me l mf mg">idx_tup_read,</span><span id="2db5" class="kw kx in lz b gy mh me l mf mg">idx_tup_fetch,</span><span id="50d7" class="kw kx in lz b gy mh me l mf mg">pg_size_pretty(pg_relation_size(indexrelname::<strong class="lz io">regclass</strong>)) <strong class="lz io">as</strong> <strong class="lz io">size</strong></span><span id="dd79" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">from</strong></span><span id="2500" class="kw kx in lz b gy mh me l mf mg">pg_stat_all_indexes</span><span id="6c9c" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">where</strong></span><span id="1dba" class="kw kx in lz b gy mh me l mf mg">schemaname = 'public'</span><span id="b219" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">and</strong> indexrelname <strong class="lz io">not</strong> <strong class="lz io">like</strong> 'pg_toast_%'</span><span id="d9f8" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">and</strong> idx_scan = 0</span><span id="48c4" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">and</strong> idx_tup_read = 0</span><span id="3eaf" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">and</strong> idx_tup_fetch = 0</span><span id="2d4b" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">and</strong> indexrelname != 'SequelizeData_pkey'</span><span id="a259" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">order</strong> <strong class="lz io">by</strong></span><span id="ba8a" class="kw kx in lz b gy mh me l mf mg">pg_relation_size(indexrelname::<strong class="lz io">regclass</strong>) <strong class="lz io">desc</strong>;</span></pre><p id="b762" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">idx_scan =索引扫描的次数</p><p id="603f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大小=索引占用的总存储量</p><p id="5007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">idx_tup_read =索引扫描返回的索引条目数</p><p id="eb82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">idx_tup_fetch =简单索引扫描返回的活动表行数</p><p id="d9d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我们不能删除所有未使用的索引，因为它们可能会在以后使用，或者 postgres 可能会显示一些错误的统计数据。</strong></p><p id="6fde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>建议定期重置索引统计，以便更好地查看已使用的索引。要重置，我们首先需要找到表的对象标识符 id (oid ),然后进行重置。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7497" class="kw kx in lz b gy md me l mf mg"><strong class="lz io">SELECT</strong> <strong class="lz io">oid</strong> <strong class="lz io">FROM</strong> pg_class c <strong class="lz io">WHERE</strong> relname = ‘test’; // test is table name</span><span id="086c" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">SELECT</strong> pg_stat_reset_single_table_counters(oid_fetched); // Reset to get new stats regularly</span></pre><h2 id="11cf" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak">膨胀:</strong></h2><p id="a5a3" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">Postgres 使用 MVCC(多版本并发控制)最终为更新/插入创建一个新行。这有助于并发事务，较旧的事务可以访问较旧版本的数据(因为它们需要被完成)，但同时，它也在系统中添加了大量陈旧的存储。因此，一次只有一个版本的行是活动的，所有其他的都是死的(陈旧的)行。</p><p id="8e81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">膨胀也存在于索引中。</strong>假设您更新了表中的一个元组(行),并且为该表索引了 3 列。现在为更新部分创建了一个新的元组(如果我们更新所有这些列的数据)，将在所有三个索引中创建一个相应的新条目，早期的引用将被标记为陈旧。</p><p id="8bc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong> Postgres 使用热(仅堆元组)优化，其中假设表有 3 个索引列，现在在更新时我们只更新一个索引列，因此在这种情况下，2 个旧索引数据的引用将从旧元组更改为新元组的引用，并且只为索引更新列创建新索引数据。</p><p id="7a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有当行(元组)的创建速率大于元组被清理的速率时，才会在数据库中产生膨胀。此外，Autovaccum(后台进程)会删除文件中的记录，但 stoarge 仍未清除，我们需要进行碎片整理。</p><p id="71da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多的膨胀会导致更多的 I/O，最终降低查询性能。</p><p id="f872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看膨胀的一个简单方法是:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6479" class="kw kx in lz b gy md me l mf mg"><strong class="lz io">CREATE</strong> <strong class="lz io">EXTENSION</strong> pgstattuple;</span><span id="c350" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">select</strong> * <strong class="lz io">from</strong> pgstattuple(‘sales’); // sales is table name.</span></pre><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/122adc3dd75c216483c5e60e62b696ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNRa3ICQoE30XSQyQ7KAuA.png"/></div></div></figure><p id="7344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我将更新/删除一些行并查看结果。我们可以看到死亡夫妇计数和相应的长度。</p><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mt"><img src="../Images/c10ee97f8a3288229ee8690614b310bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEWk1IiXZXjhI0Xe1eo2nQ.png"/></div></div></figure><p id="5614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的讨论中我们知道，膨胀是在以下情况下产生的:</p><ol class=""><li id="b0cf" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">桌子</li><li id="0e0c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">指数</li></ol><p id="124a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">表膨胀和索引膨胀可以很容易地通过某个了不起的人给出的查询得到。简单的复制和运行，我们将得到所有的数据</p><p id="3ed3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Git 链接:<a class="ae mu" href="https://github.com/ioguix/pgsql-bloat-estimation/blob/master/table/table_bloat.sql" rel="noopener ugc nofollow" target="_blank">https://github . com/io guix/pg SQL-bloat-estimation/blob/master/table/table _ bloat . SQL</a></p><h2 id="4370" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">表格膨胀演示:</h2><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="df1b" class="kw kx in lz b gy md me l mf mg">psql blog; <strong class="lz io">// blog is db name</strong></span><span id="a289" class="kw kx in lz b gy mh me l mf mg">create table bloat_demo (id int) with (autovacuum_enabled = off);</span><span id="5b7e" class="kw kx in lz b gy mh me l mf mg">insert into bloat_demo select * from generate_series(1, 8000000);</span><span id="8eb7" class="kw kx in lz b gy mh me l mf mg">select pg_size_pretty(pg_relation_size('bloat_demo'));</span></pre><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mv"><img src="../Images/55518201819a447e8bec4a33c2771b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFiHhkI2ZXC65zysCezmJw.png"/></div></div></figure><p id="3eb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在更新所有的行并检查表格的大小；(我们将看到表格的大小现在将增加一倍)</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9736" class="kw kx in lz b gy md me l mf mg">update bloat_demo set id = id + 100;</span><span id="b8d4" class="kw kx in lz b gy mh me l mf mg">select pg_size_pretty(pg_relation_size('bloat_demo'));</span></pre><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mw"><img src="../Images/c222f8c8ff5ba5c009dc477414cbfd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cofm3Bl-REtk95nUk9J2SQ.png"/></div></div></figure><p id="e546" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在 bloat _ demo 表上运行 Vacuum，看看是否清除了额外的存储空间。</p><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mx"><img src="../Images/42d7aec754f38360673d7b252b6555d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWVmVmbngJ5368hIH72UtQ.png"/></div></div></figure><p id="8a8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，没有一个存储空间是用吸尘器清理的。</p><p id="ec75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因—如上所述，vacuum 将从表中删除失效的(陈旧的)行，但不会回收这些存储，因为数据文件仍然包含这些存储。Vacuum 通过在存储文件(删除的行)中释放存储空间来提供可重用的存储空间。</p><p id="a110" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在检查我们的理论是否正确，真空自由空间是否可以使用。要验证这一点，请再次运行 update 命令，看看表是否占用了额外的空间。</p><p id="c2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以从下面的截图中看到，由于 update 命令使用了 vacuum 提供给我们的文件中的空间，所以表没有占用额外的空间。</p><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi my"><img src="../Images/63a428fbf8f1b4d70ce64042e784b1fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRZhAS87nFHvqHRw1M2Iqg.png"/></div></div></figure><p id="7e05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经使用了真空空间，让我们再次更新，看看额外的空间是否被表占用。</p><p id="cd71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于创建了新的 800 万行，并且所有早期的行都被标记为死行，因此表额外占用了 277MB。</p><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mz"><img src="../Images/aa76621d6415d3418970342dcd6916fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg8UnIVhcVEiqIY_6oWGtA.png"/></div></div></figure><h1 id="d40f" class="na kx in bd ky nb nc nd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq bi translated">解决索引膨胀问题的方法:</h1><ol class=""><li id="6b3c" class="ki kj in jm b jn lp jr lq jv lr jz ls kd lt kh kn ko kp kq bi translated">删除现有索引，然后重新创建。它会以最好的方式处理事情，但是一些间歇性的查询会受到影响。</li><li id="e5ef" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">重新索引已经创建的索引—这将消除膨胀的空间，但会使索引挂起(不可操作)，直到重新索引完全完成，最终使数据库在重建时效率低下。我们可以通过并发执行来优化重建索引的方式，这不会影响查询。</li></ol><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c839" class="kw kx in lz b gy md me l mf mg">Reindex index sales; ---&gt; Reindex index concurrently sales;</span></pre><p id="939f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的并发重新索引将在数据库中创建一个后缀为(_ccnew)的新索引，并跟踪所有的表更改。当一个新索引完全创建后，旧索引将被删除，表开始使用新创建的索引。</p><p id="8502" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">兼做索引的弊端:</strong></p><p id="a2b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果出现意外情况，并且重建过程需要停止或由于某些问题而停止，那么系统中将存在间歇性索引级别，并且会占用额外的空间。这些无效索引需要手动删除。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3e1d" class="kw kx in lz b gy md me l mf mg"><strong class="lz io">Query to find Invalid Indexes:</strong></span><span id="d9cb" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">SELECT</strong></span><span id="ee63" class="kw kx in lz b gy mh me l mf mg">c.relname <strong class="lz io">as</strong> index_name,</span><span id="6a37" class="kw kx in lz b gy mh me l mf mg">pg_size_pretty(pg_relation_size(c.<strong class="lz io">oid</strong>))</span><span id="2447" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">FROM</strong></span><span id="c1a8" class="kw kx in lz b gy mh me l mf mg">pg_index i</span><span id="8853" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">JOIN</strong> pg_class c <strong class="lz io">ON</strong> i.indexrelid = c.<strong class="lz io">oid</strong></span><span id="6320" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">WHERE</strong></span><span id="84b3" class="kw kx in lz b gy mh me l mf mg">c.relname <strong class="lz io">LIKE</strong>  '%_ccnew'</span><span id="16e0" class="kw kx in lz b gy mh me l mf mg"><strong class="lz io">AND</strong> <strong class="lz io">NOT</strong> indisvalid;</span></pre><h1 id="6651" class="na kx in bd ky nb nc nd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq bi translated">解决表格膨胀的方法:</h1><ol class=""><li id="47fd" class="ki kj in jm b jn lp jr lq jv lr jz ls kd lt kh kn ko kp kq bi translated"><strong class="jm io"> Vacuum Full : </strong>这将回收 float 和 stale 元组使用的所有空间，但反过来会产生许多问题，如表的锁定(挂起)，最终使它不是一个生产使用的解决方案。我们唯一可以使用它的时间是允许我们进行维护的应用程序停机时间。</li></ol><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0d34" class="kw kx in lz b gy md me l mf mg">VACCUM FULL bloat_demo;</span></pre><figure class="lu lv lw lx gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nr"><img src="../Images/802ef1a0d02b92fb96a1e8304c80c98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ac51vk_VZ5XnuwuQ-waoLA.png"/></div></div></figure><p id="ac56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以从表的大小中看到，553 MB 是可用的，因为真空已满。</p><p id="22e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io"> Pg Repack: </strong>这是一个生产就绪的解决方案，有助于在不停机的情况下清除膨胀和陈旧的数据。此扩展需要首先创建(安装),因为它仅在安装期间可用。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6b32" class="kw kx in lz b gy md me l mf mg"><strong class="lz io">CREATE</strong> EXTENSION pg_repack;</span></pre><p id="0625" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Pg _ re pack 如何工作？</strong></p><p id="0d98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它创建了一个新表，就像我们在重建索引中看到的那样，并将旧表中的所有数据复制到一个新表中，然后重建索引。完全复制完成后，新表充当主表，旧表被删除。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c4d4" class="kw kx in lz b gy md me l mf mg">pg_repack -k --table sales_info sales;</span><span id="1d2d" class="kw kx in lz b gy mh me l mf mg">sales_info = table name<br/>sales = database name</span></pre><p id="5c4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">pg _ repack 的缺点:</strong></p><ol class=""><li id="6961" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">在创建新表的过程中，由于相同的表被复制到存储器中，因此需要进行双重存储，因此我们需要在开始重新打包表之前检查存储器的可用性。</li><li id="b79a" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">如果重新包装过程在中间停止，那么我们需要手动删除间歇表。</li></ol><h2 id="83cd" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">Pg_repack 仍然是消除膨胀的最佳解决方案。</h2><p id="2d75" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated"><strong class="jm io">参考文献:</strong></p><p id="2023" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae mu" href="https://www.youtube.com/watch?v=qcInj-XW1Vc&amp;t=302s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=qcInj-XW1Vc</a></p></div></div>    
</body>
</html>