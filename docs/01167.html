<html>
<head>
<title>Locating Files and Directories in Linux System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Linux系统中定位文件和目录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/locating-files-and-directories-in-linux-system-63f03947486a?source=collection_archive---------29-----------------------#2020-06-25">https://blog.devgenius.io/locating-files-and-directories-in-linux-system-63f03947486a?source=collection_archive---------29-----------------------#2020-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1093d789870f366382bac0908793ab2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FG4ZJgBarREh1x1r"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">凯文·霍尔瓦特在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3b72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们已经学习了用于文件和目录的<a class="ae jz" href="https://medium.com/@yashsugandh/linux-navigation-for-beginners-8cfda137f78b" rel="noopener"> <strong class="kc io">导航</strong></a><a class="ae jz" href="https://medium.com/swlh/exploring-linux-system-7247c54084c7" rel="noopener"><strong class="kc io">探索</strong></a><a class="ae jz" href="https://medium.com/@yashsugandh/creating-files-and-directories-in-linux-system-9a5cebe1503d" rel="noopener"><strong class="kc io">创建</strong></a><a class="ae jz" href="https://medium.com/@yashsugandh/deleting-files-and-directories-in-linux-system-19d4d32e565" rel="noopener"><strong class="kc io">删除</strong> </a>，以及<a class="ae jz" href="https://dev.to/yashsugandh/(https://dev.to/yashsugandh/how-to-copy-move-and-rename-files-and-directories-in-linux-system-4kpo)" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">操纵</strong> </a>的命令。</p><p id="3c6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是不是感觉我们还是少了点什么？</p><p id="4ca3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，你是对的。我们仍然缺少在Linux系统中搜索文件的最重要的功能之一。</p><p id="8da1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两个最受欢迎和信任的文件搜索命令行工具是<code class="fe ky kz la lb b">locate</code>和<code class="fe ky kz la lb b">find</code>。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="c152" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1。</strong> <code class="fe ky kz la lb b"><strong class="kc io">locate</strong></code> <strong class="kc io">命令</strong></p><p id="cc1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定位命令用于搜索和定位文件。与同类产品相比，它查找文件的速度非常快。</p><p id="7ca1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">locate</code>命令的语法</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/8978bc50077f96ffcfd41c5333646634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*fasJGYs0mw3n6ffZYOs4Fw.png"/></div></figure><p id="5c4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用<code class="fe ky kz la lb b">locate</code>命令，我们只需要传递我们想要查找的文件名。</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/4dfa321e4f8affcdb3a0cc44430680ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38oJABg1C4_WWb8-bQcOvA.png"/></div></div></figure><p id="01ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们使用了<code class="fe ky kz la lb b">locate</code>命令来搜索文件“file _ to _ be _ located ”, locate命令返回了文件的位置。</p><p id="c2b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是定位命令是如何工作的呢？为什么这么快？</p><p id="cf5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">locate</code>之所以这么快是因为它没有从文件系统中读取被搜索的文件或目录名。</p><p id="36af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它实际上指的是一个数据库<strong class="kc io"> updatedb </strong>，由用户<strong class="kc io"> nobody </strong>创建，并由cronjob 每天自动更新<strong class="kc io">。</strong></p><p id="4f92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这是一个好方法，但它也有缺点。</p><p id="8719" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于数据库仅由cron作业更新，我们在数据库更新后创建的新文件对<code class="fe ky kz la lb b">locate command</code>不可见。</p><p id="afb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们可以使用命令<code class="fe ky kz la lb b">sudo updatedb</code>手动更新数据库。</p><p id="d5d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个如何手动更新<strong class="kc io"> updatedb </strong>的例子。</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/146e3e542ff47618c58b4fa704cce734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRuwhMqbC2qxdauK6JRl5A.png"/></div></div></figure><p id="31ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们使用命令<code class="fe ky kz la lb b">locate -S</code>来获取数据库的统计数据，这个数据库是<code class="fe ky kz la lb b">locate</code>命令用来搜索的。</p><p id="e529" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们使用命令<code class="fe ky kz la lb b">sudo updatedb</code>来更新数据库。</p><p id="61e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在完成了<code class="fe ky kz la lb b">sudo updatedb</code>命令后，我们再次使用了<code class="fe ky kz la lb b">locate -S</code>命令，发现数据库更新后文件的数量增加了。</p><p id="74b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好地理解，让我们再看一些例子</p><ul class=""><li id="4296" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">找到所有名为“textFile”的文件，不考虑其大小写</li></ul><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/1060ac3b698bb7545e01fc84ee0df2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3eNZalK1zkARqdsf_VHpQ.png"/></div></div></figure><p id="623b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们首先使用命令<code class="fe ky kz la lb b">locate textFile</code>获取所有名为“textFile”的文件。但是因为我们需要所有的结果，所以我们需要不区分大小写的结果</p><p id="9f7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们使用了<code class="fe ky kz la lb b">locate -i textFile</code> where</p><p id="104d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">locate</code>代表<strong class="kc io">定位命令</strong> <br/> <code class="fe ky kz la lb b">-i</code>代表<strong class="kc io">不区分大小写</strong> <br/> <code class="fe ky kz la lb b">.txt</code>代表所有的<strong class="kc io">文本文件</strong></p><ul class=""><li id="0b7f" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">找到所有文本文件，但将输出限制为10个</li></ul><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/aefd3a5a3fb3f9dc99e84a659db92dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_EWMjfOSmh3Zq1G-HtXKw.png"/></div></div></figure><p id="98b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们使用了命令<code class="fe ky kz la lb b">locate .txt -n 10</code>，其中</p><p id="f5bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">locate</code>代表<strong class="kc io">定位命令</strong> <br/> <code class="fe ky kz la lb b">.txt</code>代表所有的<strong class="kc io">文本文件</strong> <br/> <code class="fe ky kz la lb b">-n 10</code>代表我们想要的<strong class="kc io">条目数</strong>即<strong class="kc io"> 10 </strong></p><p id="46c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以使用长格式选项<code class="fe ky kz la lb b">--limit</code>代替<code class="fe ky kz la lb b">-n</code>来限制条目的数量。</p><ul class=""><li id="9577" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">计算Linux系统中文本文件的数量</li></ul><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/42c5d23504593a508f8879f9926eb8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0RgGy1nBUij7VG9nmDo4AQ.png"/></div></figure><p id="e488" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们使用命令<code class="fe ky kz la lb b">locate -c .txt</code>，其中</p><p id="8ebd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">locate</code>代表<strong class="kc io">定位命令</strong> <br/>代表<strong class="kc io">计数</strong>条目<br/>T20】代表所有<strong class="kc io">文本文件</strong></p><p id="7594" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请稍等，可能还有另一个问题，因为updatedb仅通过cronjob进行更新。</p><p id="2907" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们删除了一些文件，而数据库还没有更新，会发生什么？</p><p id="eddf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，在这种情况下，我们甚至会得到那些在当前系统中不存在的文件。</p><p id="c255" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们能做些什么来跳过这些文件吗？</p><p id="0ac0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，当然，让我们检查一下</p><ul class=""><li id="5fb9" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">计算Linux系统中当前存在的文本文件的数量</li></ul><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/23750090a722ce8f41b9e9ae4ae05e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*LCbyKIbYD1ip9iZhX4gcsg.png"/></div></figure><p id="573c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们使用了命令<code class="fe ky kz la lb b">locate -ec .txt</code>其中<br/> <code class="fe ky kz la lb b">locate</code>代表<strong class="kc io">定位命令</strong> <br/> <code class="fe ky kz la lb b">-e</code>代表<strong class="kc io">文件中已有的</strong>条目指定<br/> <code class="fe ky kz la lb b">c</code>代表<strong class="kc io">条目计数</strong><br/><code class="fe ky kz la lb b">.txt</code>代表所有的<strong class="kc io">文本文件</strong></p><p id="a9c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的例子中我们可以看到，以前的文本文件计数是<strong class="kc io"> 2932 </strong>，现在的计数是<strong class="kc io"> 2925 </strong>。</p><p id="9025" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在数据库最后一次更新后，7个文本文件被删除。</p><p id="5035" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，这就是关于<code class="fe ky kz la lb b">locate</code>命令的所有信息。</p><p id="33ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一篇文章中，我们将看看什么是<code class="fe ky kz la lb b">find</code>命令，它是如何工作的，它与<code class="fe ky kz la lb b">locate</code>命令有什么不同等等。</p><p id="e181" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望您理解了Linux中的<code class="fe ky kz la lb b">locate</code>命令行实用程序。如果有任何问题，请告诉我。</p></div></div>    
</body>
</html>