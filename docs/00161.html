<html>
<head>
<title>8 Most used functions of strings package in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中字符串包的 8 个最常用函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/8-most-used-functions-of-strings-package-in-go-9e5263739d49?source=collection_archive---------1-----------------------#2020-04-10">https://blog.devgenius.io/8-most-used-functions-of-strings-package-in-go-9e5263739d49?source=collection_archive---------1-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5bda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个故事列出了 Go 中字符串包最常用的函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fcb7723a816e6c12240dcb4d85526192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HizNkgbNFAf-HaYhcY59xQ.jpeg"/></div></div></figure><h1 id="341c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="c680" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">标准的 Go 库<em class="mf"> strings </em>包提供了许多与字符串相关的函数。这个博客列出了 Go 中 strings 包最常用的函数的描述，因为有很多可用的函数，而且不容易马上记住每一个，所以值得用书签标记，因为在需要的时候可能会很方便。下面是带有小示例代码片段函数列表。</p><p id="02c7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">注:</strong>我是围棋业余爱好者，如果你是围棋资深专业人士，在这里发现任何错误，请不要生气，如果你能指出错误，我会相应地纠正它们。</p><h1 id="e8f1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1 .比较</h1><p id="cfb4" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">按字典顺序比较两个字符串<a class="ae ml" href="https://en.wikipedia.org/wiki/Lexicographical_order" rel="noopener ugc nofollow" target="_blank">这个函数的结果是一个整数，可以是<code class="fe mm mn mo mp b">0, -1 or 1</code></a></p><p id="92e8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><p id="35b2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mm mn mo mp b">func Compare(a, b string) int</code></p><p id="ef79" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">示例:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="b4be" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.Compare("gopher19", "gopher20"))<br/>    fmt.Println(strings.Compare("gopher19", "gopher19"))<br/>    fmt.Println(strings.Compare("gopher20", "gopher19"))<br/>}<br/>​<br/>Output :<br/>-1<br/>0<br/>1</span></pre><h1 id="b663" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">2 .包含</h1><p id="9f5d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果要搜索的字符串中存在给定的子字符串，contains 函数将返回适当的布尔值。</p><p id="d2b3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="b494" class="mu ks iq mp b gy mv mw l mx my">func Contains(s, substr string) bool</span></pre><p id="3371" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">示例:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="f684" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.Contains("gopher-20", "20"))<br/>    fmt.Println(strings.Contains("gopher-20", "30"))<br/>    fmt.Println(strings.Contains("gopher-20", ""))<br/>    fmt.Println(strings.Contains("", ""))<br/>}<br/>​<br/>output:<br/>true<br/>false<br/>true<br/>true</span></pre><h1 id="5a39" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">3 .数数</h1><p id="0fe5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我发现这非常有用，尤其是在编码挑战中，他们要求你找出一个字符在一个字符串中重复的次数。</p><p id="3ce5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">该函数将两个字符串作为输入，检查第二个字符串参数在第一个字符串参数中出现的次数，并返回整数形式的 count。</p><p id="8719" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="3443" class="mu ks iq mp b gy mv mw l mx my">func Count(s, substr string) int</span></pre><p id="f958" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">示例:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="a12e" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.Count("gopher-gopher-gopher", "g"))<br/>    fmt.Println(strings.Count("gopher", "g"))<br/>}<br/>​<br/>output:<br/>3<br/>1</span></pre><h1 id="e103" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">4 .菲尔茨</h1><p id="9adc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你想用空白字符把一个字符串分割成一个字符串数组</p><p id="77e1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这个函数接受一个字符串作为输入，通过字符串中的空格字符分割成一个数组，并返回一个字符串数组。</p><p id="6bef" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="facd" class="mu ks iq mp b gy mv mw l mx my">func Fields(s string) []string</span></pre><p id="d7fb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">例如:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="b82e" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Printf("Fields are: %q", strings.Fields("gopher is sleeping."))<br/>}<br/>​<br/>output:<br/>Fields are: ["gopher" "is" "sleeping."]</span></pre><h1 id="3d64" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">5 .has 前缀</h1><p id="2f4a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">该函数接受两个字符串作为输入，并检查第二个参数字符串是否出现在第一个参数字符串的起始字符中。</p><p id="fb46" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">。HasPrefix </strong>有个弟弟叫<strong class="ll ir">。HasSuffix </strong>做了完全相同的事情，但是这次它检查字符串的结尾部分。</p><p id="7e19" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="48bd" class="mu ks iq mp b gy mv mw l mx my">func HasPrefix(s, prefix string) bool</span></pre><p id="5fe4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">例如:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="5f3e" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.HasPrefix("gopher", "go"))<br/>    fmt.Println(strings.HasPrefix("gopher", "java"))<br/>    fmt.Println(strings.HasPrefix("gopher", ""))<br/>}<br/>​<br/>output:<br/>true<br/>false<br/>true</span></pre><h1 id="9b7a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">6 .替换</h1><p id="52b1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个函数接受四个参数作为输入</p><ul class=""><li id="bcd5" class="mz na iq ll b lm mg lp mh ls nb lw nc ma nd me ne nf ng nh bi translated">罪犯字符串</li><li id="0fc9" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">旧弦</li><li id="96ba" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">新字符串</li><li id="d370" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">错误字符串中新字符串替换旧字符串的次数</li></ul><p id="b7b6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果 n &lt; 0 there is no limit on a number of replacements.</p><p id="b411" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">函数签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="9536" class="mu ks iq mp b gy mv mw l mx my">func Replace(s, old, new string, n int) string</span></pre><p id="904a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">例如:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="e020" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.Replace("no-banana no-banana no-banana", "no", "yes", 2))<br/>    fmt.Println(strings.Replace("no-banana no-banana no-banana", "no", "yes", -1))<br/>}<br/>​<br/>output:<br/>yes-banana yes-banana no-banana<br/>yes-banana yes-banana yes-banana</span></pre><p id="8086" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">另一个版本的<strong class="ll ir">。更换</strong>为<strong class="ll ir">。ReplaceAll </strong>基本上替换所有</p><h1 id="96f7" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">7 .裂开</h1><p id="b85a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">该函数将两个字符串作为输入，并基于第二个参数字符串返回一部分子字符串</p><p id="c4ae" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">函数签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="6c63" class="mu ks iq mp b gy mv mw l mx my">func Split(s, sep string) []string</span></pre><p id="ef0e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">举例:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="6ea8" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Printf("%q\n", strings.Split("gopher,19,gopher", ","))<br/>}<br/>​<br/>output:<br/>["gopher" "19" "gopher"]</span></pre><p id="8469" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">的变化很少。存在分裂的有哪些<a class="ae ml" href="https://golang.org/src/strings/strings.go?s=8004:8043#L310" rel="noopener ugc nofollow" target="_blank">。分割后</a>。<a class="ae ml" href="https://golang.org/src/strings/strings.go?s=6998:7045#L284" rel="noopener ugc nofollow" target="_blank"> SplitAfterN </a> <a class="ae ml" href="https://golang.org/src/strings/strings.go?s=6461:6503#L272" rel="noopener ugc nofollow" target="_blank">。SplitN </a></p><h1 id="578f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">8 .TrimSpace</h1><p id="e41a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">删除空格最常用的功能之一，这个函数接受一个字符串作为输入，并返回一个删除了前后空格的字符串。</p><p id="8cc9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">功能签名:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="be4e" class="mu ks iq mp b gy mv mw l mx my">func TrimSpace(s string) string</span></pre><p id="62c4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">示例:</strong></p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="cd29" class="mu ks iq mp b gy mv mw l mx my">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "strings"<br/>)<br/>​<br/>func main() {<br/>    fmt.Println(strings.TrimSpace(" \t\n Covid-19's vaccine will be invented and out soon to rescue us all from this insane. \n\t\r\n"))<br/>}<br/>​<br/>output:<br/>Covid-19's vaccine will be invented and out soon to rescue us all from this insane.<br/>​</span></pre><p id="9f5a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是我认为最常用的<strong class="ll ir">字符串</strong>函数的结尾，但是如果你认为有什么东西你认为必须放在这个列表中，请给我留言，我会把它放在这里。</p></div></div>    
</body>
</html>