<html>
<head>
<title>The swift model with Adaption Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适应设计模式的 swift 模型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-swift-model-with-adaption-design-pattern-6ac0b84cdd18?source=collection_archive---------12-----------------------#2020-06-10">https://blog.devgenius.io/the-swift-model-with-adaption-design-pattern-6ac0b84cdd18?source=collection_archive---------12-----------------------#2020-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0d26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管确保 API 数据格式良好是后端开发人员的责任，但是在模型层中添加一点自适应逻辑并没有什么坏处</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/60125023ae18457ebdfcf640dd995174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7DorTZcoNHWgK1v"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">凯文·Ku 在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e573" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名 iOS 应用程序开发人员，当我们从 API 接收数据时，最好总是处理 JSON 数据中的一些例外情况，如行丢失、空值和字符串转换等。</p><p id="ccb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我个人而言，我总是在模型层添加额外的代码来过滤或转换一些特殊情况，以确保逻辑/视图模型层可以接收正确的数据</p><p id="df0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一堆 JSON，其中缺少一些行。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="1eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与最后一个对象(" id": "390 ")相比，第一个(" id": "1 ")和第二个(" id": "2") JSON 对象缺少" year "和" mass "行。另外，第四个对象(“id”:“370”)缺少“地理位置”JSON 对象。</p><p id="b646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，我们可能需要拆分字符串(“year”:“1951–01–01t 00:00:00.000”)。虽然这些工作可以发生在 Logic/ViewModel 层，但是如果简单的操作可以在模型层完成，那就更有意义了。</p><p id="8ea4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，Swift 鼓励节省大量代码的函数式编程。因此，即使我们在模型中应用了很多逻辑，它看起来仍然很干净。</p><p id="8dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我认为卸下一点责任来避免大量的 ViewModel/Logic 类是合理的。</p><p id="789a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我处理这个特殊 JSON 的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="85d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1:我们有一个协议向逻辑/视图模型层呈现必要的数据，因为有时我们不需要处理所有的 API 数据。同时，如果有必要，我们可以只设置对值的“get”访问。</p><p id="937e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2:我们让模型实现可解码的协议，为转换 API 数据做好准备。我强烈建议将 API 数据复制到这个网站，以获得您需要的模型:</p><div class="le lf gp gr lg lh"><a href="https://app.quicktype.io/" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">即时解析任何语言的| quicktype</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">无论您使用的是 C#、Swift、TypeScript、Go、C++还是其他语言，quicktype 都会生成模型和辅助代码，用于…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">app.quicktype.io</p></div></div></div></a></div><p id="4842" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为您节省大量时间来检查所有 JSON 属性以找到特殊情况。</p><p id="e432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3:从 API 中检索数据后，我们扩展实现了陨石协议，以应用一些轻逻辑。正如我们从上面看到的，我们可以将逻辑绑定到值来处理空、缺失和字符串处理。</p><p id="411c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是应用这种模式的优势:</p><ul class=""><li id="2ca1" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在逻辑/视图模型层，我们只初始化陨石对象来获得常规数据</li><li id="65cf" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">如果 API 得到了更新，我们就不必麻烦 ViewModel 代码了。我们可以只更新模型层中的代码。</li><li id="25f6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">通过这样做，我们遵循了一个可靠的原则——接口分离原则，因为我们只向上层提供必要的方法和变量</li></ul><p id="63a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你了解设计模式，你会发现这是一种自适应设计模式，它允许现有类的接口被用作另一个接口，而无需修改源代码。</p><p id="3193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有兴趣阅读我的其他文章，欢迎查看我的<a class="ae lb" href="https://medium.com/@lee5187415" rel="noopener">个人资料</a>。如果您有任何问题、意见或建议，请通过<a class="ae lb" href="https://www.linkedin.com/in/lee-qi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p></div></div>    
</body>
</html>