<html>
<head>
<title>C# — Style Guide Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# —样式指南备忘单</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-style-guide-cheat-sheet-bd5c8abd557c?source=collection_archive---------0-----------------------#2020-12-27">https://blog.devgenius.io/c-style-guide-cheat-sheet-bd5c8abd557c?source=collection_archive---------0-----------------------#2020-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0b03d8db464b3395a3e50ff9b89b0a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*1RJ5Wvyh4vzbRZ3o.png"/></div></figure><p id="5758" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">编写漂亮、易懂的代码与编写产品代码一样重要。互联网上有许多不同的指南和指南。</p><p id="95e5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我试着把它们全部看完，然后整理出一张小抄。我只包括了那些影响代码风格的规则，并涵盖了大部分要点。</p><p id="4fd0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望你觉得这很有用！</p><h1 id="09f1" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">布局</h1><ul class=""><li id="8c6a" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">每行最多一条语句。</li><li id="cf8b" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">每条语句最多一次赋值。</li><li id="6cbf" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">缩进4个空格，无制表符。</li><li id="6c1e" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">列限制:120。</li><li id="0f50" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">打开大括号前换行。</li><li id="ff59" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">右括号和<code class="fe md me mf mg b">else</code>之间的换行。</li><li id="cff2" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated"><code class="fe md me mf mg b">if</code> / <code class="fe md me mf mg b">for</code> / <code class="fe md me mf mg b">while</code>后的空格等等。和逗号后。</li><li id="8efb" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">左括号后或右括号前没有空格。</li><li id="9905" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">运算符和所有其他运算符的每个操作数之间的一个空格。</li><li id="1672" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">在方法定义和属性定义之间至少添加一个空行。</li></ul><h1 id="9cc3" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">评论</h1><ul class=""><li id="c70e" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">将注释放在单独的一行，不要放在代码行的末尾。</li><li id="1dd4" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">在注释分隔符(//)和注释文本之间插入一个空格。</li></ul><h1 id="bf86" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">命名</h1><p id="0c9f" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mh ke kf kg mi ki kj kk mj km kn ko ig bi translated"><strong class="jt io">做:</strong></p><ul class=""><li id="cfb2" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko lu lv lw lx bi translated">类、方法、枚举、公共字段、公共属性、名称空间的名字:<code class="fe md me mf mg b">PascalCase</code>。</li><li id="b13f" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">局部变量名称，参数:<code class="fe md me mf mg b">camelCase</code>。</li><li id="99fe" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">私有、受保护、内部和受保护内部字段和属性的名称:<code class="fe md me mf mg b">_camelCase</code>。</li><li id="c604" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">命名约定不受const、static、readonly等修饰符的影响。</li><li id="7086" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">接口名称以<code class="fe md me mf mg b">I</code>开头，如<code class="fe md me mf mg b">IInterface</code>。</li><li id="1963" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">文件名和目录名为<code class="fe md me mf mg b">PascalCase</code>，如<code class="fe md me mf mg b">MyFile.cs</code>。</li><li id="a3c7" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">选择容易阅读的标识符名称，例如，名为<code class="fe md me mf mg b">HorizontalAlignment</code>的属性比<code class="fe md me mf mg b">AlignmentHorizontal</code>更容易阅读。</li><li id="6c7b" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">比起简洁，更喜欢可读性，例如属性名<code class="fe md me mf mg b">CanScrollHorizontally</code>比<code class="fe md me mf mg b">ScrollableX</code>(对X轴的模糊引用)更好。</li><li id="4e4d" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">使用语义有趣的名称，而不是特定于语言的关键字作为类型名称，例如<code class="fe md me mf mg b">GetLength</code>比<code class="fe md me mf mg b">GetInt</code>更好。</li></ul><p id="8927" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">请勿:</strong></p><ul class=""><li id="9744" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko lu lv lw lx bi translated">使用下划线、连字符或任何其他非字母数字字符。</li><li id="317d" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">使用匈牙利符号。</li><li id="7ec5" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">使用与广泛使用的编程语言的关键字相冲突的标识符。</li><li id="5e66" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">使用缩写或缩写作为标识符名称的一部分。</li><li id="c719" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">使用任何未被广泛接受的缩写，即使它们被广泛接受，也只在必要时使用。</li></ul><p id="6d40" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">论据:</strong></p><ul class=""><li id="513b" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko lu lv lw lx bi translated">如果参数是一个文字常量，并且在多个函数调用中使用了同一个常量，并且默认它们是相同的，那么使用一个命名的常量来使约束显式化，并保证它成立。</li><li id="61d8" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">用命名变量替换大型或复杂的嵌套表达式。</li><li id="cd61" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">考虑使用<a class="ae mn" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments" rel="noopener ugc nofollow" target="_blank">命名参数</a>来阐明调用点的参数含义。</li></ul><h1 id="ccd5" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><code class="fe md me mf mg b">var</code>关键字</h1><ul class=""><li id="7255" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">如果使用<code class="fe md me mf mg b">var</code>有助于提高可读性，可以避免使用嘈杂、明显或不重要的类型名。</li><li id="c5f5" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">当类型明显时——例如<code class="fe md me mf mg b">var apple = new Apple();</code>，或<code class="fe md me mf mg b">var request = Factory.Create&lt;HttpRequest&gt;();</code></li><li id="da20" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">对于只直接传递给其他方法的瞬态变量，例如<code class="fe md me mf mg b">var item = GetItem(); ProcessItem(item);</code></li></ul><h1 id="fa2e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">裁判出界</h1><ul class=""><li id="6b42" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">使用<code class="fe md me mf mg b">out</code>返回不属于输入的数据。</li><li id="595b" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">将<code class="fe md me mf mg b">out</code>参数放在方法定义中所有其他参数之后。</li><li id="355a" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated"><code class="fe md me mf mg b">ref</code>很少使用，当有必要改变输入时。</li><li id="c893" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">不要使用<code class="fe md me mf mg b">ref</code>作为传递结构的优化。</li><li id="f5d8" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">不要使用<code class="fe md me mf mg b">ref</code>将一个可修改的容器传递给一个方法。<code class="fe md me mf mg b">ref</code>仅当提供的容器需要用完全不同的容器实例替换时才需要。</li><li id="17d8" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">不要使用<code class="fe md me mf mg b">ref</code>或<code class="fe md me mf mg b">out</code>修饰符重载成员。</li></ul><h1 id="6eeb" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用元组作为返回类型</h1><ul class=""><li id="d30d" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">一般来说，比起<code class="fe md me mf mg b">Tuple&lt;&gt;</code>，更喜欢命名的类类型，特别是当返回复杂类型时。</li></ul><h1 id="b45d" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结构的默认值/null返回</h1><ul class=""><li id="6db9" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">首选返回一个“成功”布尔值和一个结构<code class="fe md me mf mg b">out</code>值。</li></ul><h1 id="740a" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">属性</h1><ul class=""><li id="2bca" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">使用后缀“attribute”命名自定义属性类</li><li id="e6be" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">属性应该出现在与它们相关联的字段、属性或方法的上一行，用换行符与成员隔开。</li><li id="31e2" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">多个属性应该用换行符隔开。这允许更容易地添加和删除属性，并确保每个属性都易于搜索。</li></ul><h1 id="5cbc" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结构和类:</h1><ul class=""><li id="66c5" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">几乎总是使用一个类。</li><li id="14e7" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">当该类型可以像其他值类型一样被处理时，请考虑使用struct，例如，如果该类型的实例很小并且通常是短暂的，或者通常嵌入在其他对象中。</li></ul><h1 id="e8b5" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">类成员排序</h1><p id="98e0" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mh ke kf kg mi ki kj kk mj km kn ko ig bi translated"><strong class="jt io">按以下顺序对类成员进行分组:</strong></p><ul class=""><li id="298d" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko lu lv lw lx bi translated">嵌套类、枚举、委托和事件。</li><li id="dfe3" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">静态、常量和只读字段。</li><li id="b7a1" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">字段和属性。</li><li id="4b89" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">构造函数和终结器。</li><li id="dd27" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">方法。</li></ul><p id="dbcb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">在每组中，各要素应按以下顺序排列:</strong></p><ul class=""><li id="e735" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko lu lv lw lx bi translated">公共的。</li><li id="6459" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">内部。</li><li id="700b" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">受保护的内部。</li><li id="5680" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">受到保护。</li><li id="b662" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">私人的。</li></ul><h1 id="3825" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">属性样式</h1><ul class=""><li id="6223" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">对于单行只读属性，尽可能使用表达式体属性(<code class="fe md me mf mg b">=&gt;</code>)。</li><li id="d60a" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">对于其他一切，使用旧的<code class="fe md me mf mg b">{ get; set; }</code>语法。</li></ul><h1 id="5ec5" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">常数</h1><ul class=""><li id="2f77" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">可以使用<code class="fe md me mf mg b">const</code>的变量和字段应该总是使用<code class="fe md me mf mg b">const</code>。</li><li id="f0d4" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">如果<code class="fe md me mf mg b">const</code>是不可能的，<code class="fe md me mf mg b">readonly</code>可以是一个合适的替代品。</li></ul><h1 id="b1bd" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">例外</h1><ul class=""><li id="437c" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">不要返回错误代码。</li><li id="3391" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">对于实现该模式的方法，使用前缀“Try”和布尔返回类型。</li></ul><h1 id="d35b" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">字符串插值vs <code class="fe md me mf mg b">String.Format()</code> vs <code class="fe md me mf mg b">String.Concat</code> vs <code class="fe md me mf mg b">operator+</code></h1><ul class=""><li id="1a3c" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">一般来说，使用最容易阅读的内容，尤其是日志和断言消息。</li><li id="64dd" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">请注意，链式<code class="fe md me mf mg b">operator+</code>连接会比较慢，并且会导致大量内存流失。</li><li id="2c72" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">如果性能是一个问题，那么对于多个字符串的连接，<code class="fe md me mf mg b">StringBuilder</code>会更快。</li></ul><h1 id="2bde" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">LINQ</h1><ul class=""><li id="bb4e" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">一般来说，更喜欢单行的LINQ调用和命令式代码，而不是长链的LINQ。混合命令式代码和沉重的LINQ通常很难读懂。</li><li id="5399" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">比起SQL风格的LINQ关键字，更喜欢成员扩展方法——例如，比起<code class="fe md me mf mg b">myList where x</code>，更喜欢<code class="fe md me mf mg b">myList.Where(x)</code>。</li></ul><h1 id="a84c" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">数组与列表</h1><ul class=""><li id="f9fc" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">一般来说，对于公共变量、属性和返回类型，最好使用<code class="fe md me mf mg b">List&lt;&gt;</code>而不是数组。</li><li id="309a" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">首选<code class="fe md me mf mg b">List&lt;&gt;</code>当容器的尺寸可以改变时。</li><li id="e699" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">当容器的大小是固定的并且在构造时是已知的时，最好使用数组。</li><li id="fb07" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">多维数组的首选数组。</li></ul><h1 id="5d9e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">IEnumerable vs IList vs IReadOnlyList</h1><ul class=""><li id="98c9" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">对于输入，尽可能使用最严格的集合类型，例如<code class="fe md me mf mg b">IReadOnlyCollection</code> / <code class="fe md me mf mg b">IReadOnlyList</code> / <code class="fe md me mf mg b">IEnumerable</code>作为方法的输入，而输入应该是不可变的。</li><li id="a8f7" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">对于输出，如果将返回容器的所有权转移给所有者，优先选择<code class="fe md me mf mg b">IList</code>而不是<code class="fe md me mf mg b">IEnumerable</code>。如果不转让所有权，则选择最具限制性的选项。</li></ul><p id="567a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以在下面找到更多规则和指南:</p><ol class=""><li id="1d08" class="ln lo in jt b ju jv jy jz kc mk kg ml kk mm ko mo lv lw lx bi translated">微软的C#编码惯例—<a class="ae mn" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/cs harp/programming-guide/inside-a-program/Coding-Conventions</a></li><li id="519b" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko mo lv lw lx bi translated">。微软的. Net设计指南—<a class="ae mn" href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/Design-Guidelines/</a></li><li id="d9de" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko mo lv lw lx bi translated">来自谷歌的C#风格指南—【https://google.github.io/styleguide/csharp-style.html T4】</li></ol></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="1c6e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">写出更漂亮的代码，感谢阅读！</p></div></div>    
</body>
</html>