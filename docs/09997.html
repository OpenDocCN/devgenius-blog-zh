<html>
<head>
<title>Rust — Simple, Clean Postgres Database Connection Library for working with any Project (APIs , Services)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">rust——简单、干净的 Postgres 数据库连接库，可用于任何项目(API、服务)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rust-implement-a-postgres-database-connection-library-for-working-with-any-project-apis-5c962b1bc0cb?source=collection_archive---------2-----------------------#2022-09-28">https://blog.devgenius.io/rust-implement-a-postgres-database-connection-library-for-working-with-any-project-apis-5c962b1bc0cb?source=collection_archive---------2-----------------------#2022-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93e8c4ab07daf2f9173f72b658b3702a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhbGXwDdA-QrYkJ8r4DgKA.jpeg"/></div></div></figure><p id="4d03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用数据库是 Web APIs 中最常见的功能之一。如果您正在构建一个应用程序并开始使用，选择 MySQL 或 Postgres 这样的 SQL 数据库通常是一个聪明的主意。大多数情况下，它承担了处理大量复杂问题的额外责任。本文将演示如何创建一个简单的库，它建立了与 Postgres 的连接，并提供了一个使用<code class="fe kw kx ky kz b">sqlx</code>库处理 Rust 的接口。这个库也可以用于 MySQL。我们的机箱可以作为数据库层在许多开发项目中重用。</p><h1 id="f3e0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">项目设置</h1><p id="31cd" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">首先，我们将为此创建一个新的 Rust 库。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="325f" class="ml lb iq kz b gy mm mn l mo mp">cargo new --lib database-lib</span></pre><p id="d4de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，编辑<code class="fe kw kx ky kz b">Cargo.toml</code>来添加使用 Postgres 的依赖项。对于这一个，我们将使用<code class="fe kw kx ky kz b">sqlx</code>作为我们的底层数据库库。我们还将使用一个助手库<code class="fe kw kx ky kz b">thiserror</code>从这个库中提供我们自己的错误抽象。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2a69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQLX 还提供了对不同数据库的良好抽象。入门是个可取的选择。</p><p id="39b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了编写我们的数据库连接库，我们将编写两个主要组件</p><ol class=""><li id="ddfd" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">错误解析和传播</li><li id="9e68" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">将作为 Postgres 连接池包装的数据库结构。</li></ol><p id="d142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，我们不会出于学习目的编写错误解析和传播。但是因为我们的目标是在我们构建的每个项目中使用它，我们可以开始正确、干净的方式，然后在它的基础上进行构建。</p><p id="3eb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，我们要为数据库提供一个基本的包装器，以便在将池移交给我们的应用程序之前，我们可以控制一些池设置。</p><p id="f893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将看到连接到数据库时可能发生的错误，然后继续创建连接。</p><h1 id="2d97" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">错误处理</h1><p id="5c88" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">由于种种原因，我们的图书馆可能无法与我们的数据库建立连接。可能是由于<strong class="ka ir">无效连接字符串</strong>、<strong class="ka ir">网络</strong> <strong class="ka ir">超时</strong>、<strong class="ka ir">无效池配置</strong>等原因。出于这个原因，我们在 Rust 中创建了自定义的错误枚举。这将负责解析和格式化底层错误。它还会传播底层错误，让应用程序处理任何细节。</p><p id="9e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着我们库的增长，我们可以实现更多的功能并减少应用程序开销。</p><p id="b9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先在我们的<code class="fe kw kx ky kz b">lib.rs</code>文件中定义下面的错误枚举。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e422" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用了一个第三方库<code class="fe kw kx ky kz b">thiserror</code>，它为错误显示提供了宏，并实现了定制错误所需的特征。</p><p id="94b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们的库只抛出两种类型的错误。我们可以在将来进一步扩展，使之更加具体。</p><p id="7fbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，是时候编写我们的数据库结构了。</p><h1 id="3810" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">数据库实现</h1><p id="86b9" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们的数据库结构很简单。当一个新的数据库被实例化时，我们初始化这个池，并从此拥有这个池。我们可以把这个游泳池提供给任何想使用它的人。为了简单起见，我们将只从数据库结构中提供一个共享的不可变引用。如果对可变池的需求增加，我们可以添加这个。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f3d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们还确保初始化时的所有错误都映射到我们的自定义错误，以便我们可以标准化该库。</p><p id="6893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们实现了这一点，我们现在就可以使用它来开始使用我们的数据库并查询它。这就是连接 Rust 中数据库所需的全部内容。如您所见，这只是几行代码。但是我们以一种在任何项目中都不用担心的方式组织了它。并且可以将它作为一个单独的板条箱来不断添加功能。这是一个干净的做法，可以在应用程序中使用。</p><h1 id="dac2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试</h1><p id="4528" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">到目前为止，我们已经定义了数据库。我们有一个关联的方法可以创建一个新的连接池。我们现在可以编写一个连接到这个数据库的测试，并开始使用它。</p><p id="bdd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个测试，它试图打开一个到 PostgreSQL 数据库的连接，并试图执行一个简单的<code class="fe kw kx ky kz b">select</code>。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8a68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试在不设置任何环境变量的情况下直接运行该测试。我们会看到这样的输出。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="be5e" class="ml lb iq kz b gy mm mn l mo mp">cargo test</span><span id="f6e8" class="ml lb iq kz b gy ng mn l mo mp">---- tests::test_database_connection_get stdout ----<br/>thread 'tests::test_database_connection_get' panicked at 'Database connection expected: InvalidConnectionString(EnvVar(NotPresent))', src/lib.rs:45:44<br/>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><span id="5c45" class="ml lb iq kz b gy ng mn l mo mp">failures:<br/>    tests::test_database_connection_get</span><span id="9e93" class="ml lb iq kz b gy ng mn l mo mp">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><span id="d905" class="ml lb iq kz b gy ng mn l mo mp">error: test failed, to rerun pass '--lib'</span></pre><p id="f051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到，我们的错误已经正确传播，现在可以在使用我们的库时由应用程序以干净的方式处理。</p><p id="4917" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，将环境变量设置为以下内容，并运行测试</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="67b7" class="ml lb iq kz b gy mm mn l mo mp">DATABASE_URL=postgres://postgres:postgres@localhost:5432/testdb?currentSchema=app cargo test </span></pre><p id="8417" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果连接成功，我们应该会看到一个成功的测试运行。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="3e2a" class="ml lb iq kz b gy mm mn l mo mp">running 1 test<br/>test tests::test_database_connection_get ... ok</span><span id="b813" class="ml lb iq kz b gy ng mn l mo mp">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.19s</span><span id="5a82" class="ml lb iq kz b gy ng mn l mo mp">Doc-tests database-lib</span><span id="18a6" class="ml lb iq kz b gy ng mn l mo mp">running 0 tests</span><span id="671d" class="ml lb iq kz b gy ng mn l mo mp">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span></pre><h1 id="4650" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最后</h1><p id="5054" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这是为 Postgres 编写一个简单、强大的数据库包装器的基本例子。我们现在可以在应用程序中的任何地方使用这个库，并设置环境变量来开始使用我们的数据库。如果这个库中需要，我们还可以为 MySQL 池和其他数据库连接缓存编写特性。</p><p id="9465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以此为基础，在接下来的几篇文章中，我将讨论如何使用 Postgres 和 Rust 创建高性能的 REST APIs。</p><blockquote class="nh ni nj"><p id="b13e" class="jy jz nk ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><strong class="ka ir">敬请关注，更多请关注我！</strong></p></blockquote></div></div>    
</body>
</html>