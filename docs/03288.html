<html>
<head>
<title>Better JavaScript — Class Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的 JavaScript —类继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-class-inheritance-5b0cd4bf4c5b?source=collection_archive---------14-----------------------#2020-10-19">https://blog.devgenius.io/better-javascript-class-inheritance-5b0cd4bf4c5b?source=collection_archive---------14-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7b854aa0e961d484ae87471947592e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bb-VFiO7m7osJ956"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进 JavaScript 代码的方法。</p><h1 id="0b40" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从子类构造函数中调用超类构造函数</h1><p id="d492" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了创建一个继承自父构造函数的构造函数，我们需要在子类构造函数中调用超类构造函数。</p><p id="9810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb49" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="170c" class="mn lc iq mj b gy ms mp l mq mr">Person.prototype.toString = function() {<br/>  return `Person ${this.name}`;<br/>}</span><span id="6fc4" class="mn lc iq mj b gy ms mp l mq mr">function Actor(name, role) {<br/>  Person.call(this, name);<br/>  this.role = role;<br/>}</span><span id="0334" class="mn lc iq mj b gy ms mp l mq mr">Actor.prototype = Object.create(Person.prototype);<br/>Actor.prototype.constructor = Actor;</span></pre><p id="63ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了服务于超类构造函数的<code class="fe mt mu mv mj b">Person</code>构造函数。</p><p id="003b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实例方法在<code class="fe mt mu mv mj b">prototype</code>属性中。</p><p id="58b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过调用<code class="fe mt mu mv mj b">Person</code>构造函数创建<code class="fe mt mu mv mj b">Actor</code>子类，然后设置自己的状态。</p><p id="6db7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe mt mu mv mj b">Object.create</code>创建原型，这样来自<code class="fe mt mu mv mj b">Person</code>的所有方法都被继承。</p><p id="9ce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe mt mu mv mj b">constructor </code>设置为<code class="fe mt mu mv mj b">Actor</code>，这样如果我们将<code class="fe mt mu mv mj b">instanceof</code>与<code class="fe mt mu mv mj b">Actor</code>实例一起使用，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1217" class="mn lc iq mj b gy mo mp l mq mr">new Actor('james', 'main') instanceof Actor</span></pre><p id="93a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么应该会返回<code class="fe mt mu mv mj b">true</code>。</p><p id="d992" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于继承，我们可以在一个<code class="fe mt mu mv mj b">Actor</code>实例中调用<code class="fe mt mu mv mj b">Person</code>方法。</p><p id="31da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们愿意的话，我们可以覆盖它们。</p><p id="ab21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a29d" class="mn lc iq mj b gy mo mp l mq mr">const str = new Actor('james', 'main').toString()</span></pre><p id="36ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可行的，我们得到<code class="fe mt mu mv mj b">'Person james’</code>作为<code class="fe mt mu mv mj b">str</code>的值。</p><p id="3102" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建超类和子类的一种不太容易出错的方法是使用类语法。</p><p id="838e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cec2" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="6b12" class="mn lc iq mj b gy ms mp l mq mr">  toString() {<br/>    return `Person ${this.name}`;<br/>  }<br/>}</span><span id="03d2" class="mn lc iq mj b gy ms mp l mq mr">class Actor extends Person {<br/>  constructor(name, role) {<br/>    super(name);<br/>    this.role = role;<br/>  }<br/>}</span></pre><p id="c28b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是我们以前拥有的。</p><p id="cdf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们是一样的。</p><p id="5351" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是课程版本更短，出错的机会更少。</p><p id="c402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">super</code>替换<code class="fe mt mu mv mj b">Person.call</code>方法调用。</p><p id="0768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">extends</code>与使用<code class="fe mt mu mv mj b">Object.create</code>并设置<code class="fe mt mu mv mj b">constructor</code>属性相同。</p><p id="3982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以类语法应该被使用，因为它被引入了，但是我们必须知道在它的下面，仍然是原型和构造函数。</p><h1 id="6c9e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">永远不要重用超类属性名</h1><p id="fa72" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用超类属性名。</p><p id="a19b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a064" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="0ad5" class="mn lc iq mj b gy ms mp l mq mr">Person.prototype.toString = function() {<br/>  return `Person ${this.name}`;<br/>}</span><span id="15bb" class="mn lc iq mj b gy ms mp l mq mr">function Actor(name, role) {<br/>  Person.call(this, name);<br/>  this.name = name;<br/>  this.role = role;<br/>}<br/>Actor.prototype = Object.create(Person.prototype);<br/>Actor.prototype.constructor = Actor;</span></pre><p id="1df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe mt mu mv mj b">Actor</code>和<code class="fe mt mu mv mj b">Person</code>中都使用了<code class="fe mt mu mv mj b">name</code>。</p><p id="8607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会造成两者之间的冲突。</p><p id="b315" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类应该知道超类使用的所有属性。</p><p id="6701" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该重新定义超类中的属性。</p><p id="8325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了类语法，我们可以只使用<code class="fe mt mu mv mj b">super</code>对象来引用超类的实例属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d45709901d163530e5ef0143a5cc3b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITkN7lcoUw5HeFlB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@kochangbok?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">昌博科</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="6e80" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="574d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类语法让我们避免了许多我们可以用子类和超类创建的错误。</p><p id="c983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，子类和超类中不应该有相同的实例属性名。</p></div></div>    
</body>
</html>