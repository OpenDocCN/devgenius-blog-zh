<html>
<head>
<title>Introduction to Generics in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 中的泛型介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-generics-in-typescript-e81ed146a330?source=collection_archive---------1-----------------------#2021-10-05">https://blog.devgenius.io/introduction-to-generics-in-typescript-e81ed146a330?source=collection_archive---------1-----------------------#2021-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c01" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是泛型，我们如何在 TypeScript 中使用它们？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b262506c62dba451e4ee0c1dc31ca92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xcECKqmYatDva24O"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="860b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">泛型是编程中一个强大的工具，可以帮助您防止代码重复。它们提供了一种创建可重用函数的方法，这些函数可以处理多种类型，而不是单一类型。</p><p id="597f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍 TypeScript 中的泛型。我们将通过一些基本的例子来看看如何使用它们。</p><p id="0def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉 TypeScript，请阅读下面的文章开始学习。</p><div class="ls lt gp gr lu lv"><a href="https://levelup.gitconnected.com/type-annotation-vs-type-inference-in-typescript-85ba2194ebe1" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">TypeScript 中的类型注释与类型推理</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">如何在 TypeScript 中向变量添加类型</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="0606" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">如何在 TypeScript 中使用泛型？</h1><p id="2e85" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了开始使用泛型，我们将看一看 TypeScript <a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics" rel="noopener ugc nofollow" target="_blank">文档</a>中所示的最基本的例子。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="2a4b" class="nt ms iq np b gy nu nv l nw nx">function identity(arg: number): number {<br/>  return arg;<br/>}</span><span id="8293" class="nt ms iq np b gy ny nv l nw nx">function identity(arg: string): string {<br/>  return arg;<br/>}</span></pre><p id="94d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有两个函数。一个接受一个数字作为参数并返回该数字；另一个接受一个字符串作为参数并返回该字符串。</p><p id="7c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循 TypeScript 的规则，在第一个<code class="fe nz oa ob np b">identity</code>函数中，我只能传入一个数字作为参数。如果我试图传递一个字符串或任何其他类型，我们会得到一个错误。在第二个<code class="fe nz oa ob np b">identity</code>函数中，我只能传入一个字符串作为参数。如果我试图传递一个数字或任何其他类型，我们将得到一个错误。</p><p id="3df2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将这两个函数合二为一来减少可重复的代码。一种方法是使用<code class="fe nz oa ob np b">any</code>类型。如果我们给<code class="fe nz oa ob np b">identity</code>函数的参数和返回值一种类型的<code class="fe nz oa ob np b">any</code>，我们可以传入任何我们想要的值。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="6883" class="nt ms iq np b gy nu nv l nw nx">function identity(arg: any): any {<br/>  return arg;<br/>}</span></pre><p id="9bc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以向这个函数传递一个数字或者一个字符串。然而，这种方法首先否定了使用 TypeScript 的理由。通过使用<code class="fe nz oa ob np b">any</code>类型，我们丢失了参数的类型信息。</p><p id="0ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的方法是在函数中添加一个类型变量。这就是泛型发挥作用的地方。我们可以通过在<code class="fe nz oa ob np b">&lt;&gt;</code>括号中传递一个类型来给函数添加一个类型变量。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="5d7d" class="nt ms iq np b gy nu nv l nw nx">function identity&lt;Type&gt;(arg: Type): Type {<br/>  return arg;<br/>}</span></pre><p id="f18b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们添加了一个名为<code class="fe nz oa ob np b">Type</code>的类型变量。类型变量正被用作参数类型和返回值类型。</p><p id="08ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们仍然可以传递一个数字或者一个字符串作为参数。这一次，我们可以显式地告诉 TypeScript 类型，它将被用作参数和返回值的类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4ded89faab0cfa4b7b43d98cf0dc8d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*0ep7s3FM6gvwBWQ_Vz-Lxg.png"/></div></figure><p id="bb4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者我们可以使用类型参数推断让 TypeScript 自动设置类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/22957ee04c7d438a2ced201f451ca5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*K3VaymnsoZxMYCRrX_EeMA.png"/></div></figure><h1 id="98fc" class="mr ms iq bd mt mu oe mw mx my of na nb jw og jx nd jz oh ka nf kc oi kd nh ni bi translated">如何创建通用约束？</h1><p id="848a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果我需要访问参数的属性或方法呢？例如，如果我想访问参数的<code class="fe nz oa ob np b">length</code>属性。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="49aa" class="nt ms iq np b gy nu nv l nw nx">function identity&lt;Type&gt;(arg: Type): Type {<br/>  console.log(arg.length)<br/>  return arg;<br/>}</span></pre><p id="fc72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，TypeScript 会抱怨这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/11b09843962ec65ea11fc7bf763768b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42dM7edQY2cTHwX8twDfZw.png"/></div></div></figure><p id="28ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，参数可以是传递给泛型函数的任何类型。这意味着它可以是字符串、数字或任何类型。如果参数是一个数字，<code class="fe nz oa ob np b">length</code>属性将不存在。这就是为什么我们会得到一个错误。</p><p id="284b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们可以创建一个描述约束的接口。这里我们可以说，参数必须有一个<code class="fe nz oa ob np b">length</code>属性，也就是一个<code class="fe nz oa ob np b">number</code>。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c32c" class="nt ms iq np b gy nu nv l nw nx">interface ArgWithLength {<br/>  length: number;<br/>}</span></pre><p id="9a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将在函数中扩展该类型，以包含该约束。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0418" class="nt ms iq np b gy nu nv l nw nx">function identity&lt;Type <strong class="np ir">extends ArgWithLength</strong>&gt;(arg: Type): Type {<br/>  console.log(arg.length)<br/>  return arg;<br/>}</span></pre><p id="c5b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 extends 关键字后，我们会看到错误已经消失了。这是因为我们添加了一个约束，即无论传递给函数的参数是什么，都必须有一个<code class="fe nz oa ob np b">length</code>属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/05372621ff33c450cf7cfb73afb7d265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blflPfutB16J0rn93XRWPw.png"/></div></div></figure><p id="31ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我试图将一个数字传递给<code class="fe nz oa ob np b">identity</code>函数，我们会得到一个 TypeScript 错误。这是因为数字没有<code class="fe nz oa ob np b">length</code>属性。但是，如果我们传递一个字符串或者数组，就没问题了。这是因为它们都有一个<code class="fe nz oa ob np b">length</code>属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/76a8433d7989a2190f36266a97f5d323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiQBStgYpoHQs9K-JcU9YQ.png"/></div></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3ef8" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="bae4" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">感谢阅读！我希望这篇文章对您开始使用 TypeScript 中的泛型有所帮助。当我第一次开始学习泛型时，它们看起来真的很复杂。但是在花一些时间学习它之后，它们实际上并不那么难理解。</p><p id="82fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">能够使用泛型是一个强大的工具，可以帮助您编写可重用的函数，并防止重复代码。</p><p id="4850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想继续学习更多关于 TypeScript 的知识，请查阅下面的文章。</p><div class="ls lt gp gr lu lv"><a href="https://javascript.plainenglish.io/typescript-tip-convert-an-array-of-strings-into-a-string-literal-union-type-ee46c2c6e337" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">TypeScript 提示:将字符串数组转换为字符串联合类型</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用“const”断言和索引访问类型</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="om l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>