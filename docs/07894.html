<html>
<head>
<title>Deployment Strategies 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署策略 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deployment-strategies-101-ee2badd60799?source=collection_archive---------1-----------------------#2022-05-01">https://blog.devgenius.io/deployment-strategies-101-ee2badd60799?source=collection_archive---------1-----------------------#2022-05-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b03f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<em class="ki">中级</em>系列，因为它涉及到理解<strong class="jm io">生产推广战略的基础知识，</strong>对于产品特性和产品如何推广给众多客户至关重要。</p><p id="3085" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="80a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/api-101-773ec501b485"><strong class="jm io">API 101</strong></a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"><strong class="jm io"><br/>异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078"><strong class="jm io">数据库 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/publisher-subscriber-pattern-101-a0dd921025b9"><strong class="jm io">发布者-订阅者</strong> </a> <strong class="jm io"> 101 </strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/00abf70b3928b25c6d22beca391e6d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnhacGFw-I7zEJcEvo76ag.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd la">部署阶段</strong></figcaption></figure><h1 id="42e1" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是部署策略？</h1><p id="d2ab" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">部署策略包括在生产环境中更新基础设施节点的一系列步骤，以优化<strong class="jm io"> <em class="ki">应用停机时间、客户功能爆炸半径、运行生产堆栈的运营和成本优势。</em> </strong>根据基础设施的分类，分为<strong class="jm io"> <em class="ki">计算、消息传递和数据库层</em> </strong>，应用不同的部署原则。</p><ul class=""><li id="70f0" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">对于数据库来说，模式中的<a class="ae kj" href="https://thorben-janssen.com/update-database-schema-without-downtime" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a><strong class="jm io"/>【版本控制】和避免删除列/数据是关键的指导原则。</li><li id="d725" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">对于消息传递层，在主动层为客户流量提供服务的同时，将向后兼容的模式更改部署到被动节点。</li></ul><p id="8496" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上述基础架构的非向后兼容变更，<strong class="jm io"> <em class="ki">数据复制/备份/迁移</em> </strong>是选择主要版本升级场景的关键要素。</p><ul class=""><li id="3a31" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">对于这篇博客，我们将把我们的协同作用放在计算层，这通常是在<strong class="jm io"> <em class="ki">虚拟机/Kubernetes pods/Docker 容器</em> </strong>之间的选择。使用正确的自动化工具集可以统一应用以下原则。</li></ul><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mr"><img src="../Images/1ad6751d75687a069e12fa60b82d42c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAfOoYkbFySSFfK09gpfqw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd la">AWS 上的多区域部署</strong></figcaption></figure><h1 id="7097" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署策略的类型</h1><p id="6bd0" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">为了对分布式体系结构的计算层所使用的部署策略进行分类，关键的分类元素是— <strong class="jm io"> <em class="ki"> %工件被部署到的服务器、部署期间应用程序的停机时间、活动/休眠服务器群的数量以及在给定 SLA 内回滚的能力</em> </strong>。结合使用上述因素，部署策略会有所不同，下面是一些流行的部署策略。</p><h2 id="3a68" class="ms lc in bd la mt mu dn lg mv mw dp lk jv mx my lo jz mz na ls kd nb nc lw nd bi translated">传统部署</h2><p id="af93" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在传统部署中，实时/生产堆栈中的所有服务器都一次性使用最新版本的代码进行更新。鉴于这种战略的性质，如果投入使用的时间相当长，它很容易同时出现<strong class="jm io">宕机</strong>，并且会因为功能/非功能性错误而影响整个客户群。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ne"><img src="../Images/1659e8627b7c334aee9460aa2ff87ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQfhSfqk08IC2iMLbeGJJA.jpeg"/></div></div></figure><p id="7e05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这用于传统业务/基础架构，其中实时流量为 24 小时<strong class="jm io">&lt;</strong>，几个小时的停机对业务来说没有运行其他任务关键型部署策略的<strong class="jm io">成本影响</strong>的风险。</p><h2 id="7f62" class="ms lc in bd la mt mu dn lg mv mw dp lk jv mx my lo jz mz na ls kd nb nc lw nd bi translated">蓝绿色部署</h2><p id="c24d" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">蓝色—绿色部署使用两个<strong class="jm io">同类堆栈/车队</strong>计算实例，部署不同版本的应用程序。这些堆栈的名称为<strong class="jm io">蓝色/绿色</strong>，部署策略将构件提升到<strong class="jm io">预活动堆栈</strong>，一旦端点的基本验证完成，堆栈将被翻转。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nf"><img src="../Images/91856258b205ac4d1784a7a8dc00871c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBkLkVYLG5s_FmIsrYLSgg.jpeg"/></div></div></figure><p id="1c46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用于具有实时 24*7 客户流量的任务关键型应用程序，蓝绿色侧重于整体体系结构的<strong class="jm io">运营和云成本</strong>方面。此外，在<strong class="jm io">预实时堆栈</strong>上的验证仅限于基本的健全性，一些客户用例仍然可以在实时堆栈上被发现。</p><h2 id="da7c" class="ms lc in bd la mt mu dn lg mv mw dp lk jv mx my lo jz mz na ls kd nb nc lw nd bi translated">金丝雀部署</h2><p id="b012" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">Canary 的部署体现在最新版本的构件逐渐推广到被称为<strong class="jm io">canaris</strong>的计算舰队子集。比如逐步推广到<strong class="jm io"> %的客户。</strong> Canary stacks 有助于在较小的爆炸半径内识别功能性和非功能性问题。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ng"><img src="../Images/cdfa9537fbabb0638f2723975b84198d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbNe67lyk4Fjmk1ds0iexQ.jpeg"/></div></div></figure><p id="0ee9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与蓝绿色部署相比，这是任务关键型应用程序的<strong class="jm io">成本最优</strong>选择，但是自动化和管道需要严格的自动化，以避免在整体生产部署中出现任何手动故障接触点。</p><h2 id="2d46" class="ms lc in bd la mt mu dn lg mv mw dp lk jv mx my lo jz mz na ls kd nb nc lw nd bi translated">A/B 部署</h2><p id="b9c8" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">A/B 部署基于客户流中设置的实验标志，为不同的客户子集启用多个版本的应用程序。<strong class="jm io">浏览器 Cookies、A/B 测试工具或独特的部署堆栈/车队</strong>是一些常用技术，用于识别符合版本/功能类型的客户。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1d1d5ba048900ddae241237b7d7af1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*fjKgFwEGSu3Cik-bZWnGAQ.jpeg"/></div></figure><h1 id="523f" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="4f2b" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们讨论了一些用于应用基础架构计算层的最常用方法，但是基于自动化技术和配置，可以根据产品需求进一步定制生产堆栈。虽然在<strong class="jm io">成本、停机时间和自动化/运营复杂性</strong>之间取得平衡对于团队来说是一个棘手的选择，但在<strong class="jm io">开发运维周期</strong>的早期定义这些有助于通过正确的指标衡量所有生产部署，从而在生产部署中实现基于数据的决策</p><p id="1914" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>