<html>
<head>
<title>Kafka : Producers-Consumers &amp; Partitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡:生产者-消费者&amp;分区</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kafka-producers-consumers-partitions-89229e675f5f?source=collection_archive---------17-----------------------#2022-06-26">https://blog.devgenius.io/kafka-producers-consumers-partitions-89229e675f5f?source=collection_archive---------17-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ul class=""><li id="ba7d" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">了解分区，消费者帮助你更快的学习卡夫卡。在这里，我们讨论卡夫卡的分区的行为。</li><li id="245e" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">为了更好地理解，需要讨论一些用例。</li></ul><p id="f856" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">用例 1: </strong></p><ul class=""><li id="79d4" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们来看一个有 3 个分区的题目。这里，我们在 G 组中有一个新的消费者。因此，这个消费者将从所有 3 个分区获得所有消息。</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/037e773683dda34f3a65304dd3dc28c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwRGRvHk4gsycN08Uf_JSg.png"/></div></div></figure><p id="6ccc" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">用例 2: </strong></p><ul class=""><li id="fdc8" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">那么如果我们在消费群体中再增加一个消费者会怎么样呢？</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi li"><img src="../Images/93e21755c0f45a756eebe79246f45d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3oOrTraqFkOk6xUY7f03g.png"/></div></div></figure><ul class=""><li id="584d" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">将消费者 2 添加到该组后，它将如上所述。</li></ul><p id="04be" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">用例 3:分区数量=消费者数量</strong></p><ul class=""><li id="eca6" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">因此，这里每个消费者将从单个分区读取消息。</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lj"><img src="../Images/040273a35e597a129edd840846ffa0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LNJ0bXX5mjtK6fbevaz6A.png"/></div></div></figure><p id="323a" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">用例 4:分区数量&lt;消费者数量</strong></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lk"><img src="../Images/d5039ea7d1bcb8351081be6ea5c2c1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izMbq14uE9RSZAOYNNHqHA.png"/></div></div></figure><blockquote class="ll lm ln"><p id="b591" class="kh ki lo jm b jn jo kj kk jp jq kl km lp kn ko kp lq kq kr ks lr kt ku kv jx ig bi translated">如果我们向组(单个主题)中再添加一个消费者，消费者 4 将是空闲的，根本收不到任何消息。</p><p id="c3e3" class="kh ki lo jm b jn jo kj kk jp jq kl km lp kn ko kp lq kq kr ks lr kt ku kv jx ig bi translated">因此，如果我们添加消费者 5、6、7 等，他们都将是闲置的，因为卡夫卡有一个规则，即消费者组内的消费者数量应该等于或小于同一主题中的分区数量。</p></blockquote><p id="1e53" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">用例 5:添加新的消费者群体</strong></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ls"><img src="../Images/50c1900a4827bd42641b38a19da4df32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnXMfXWfi9NRpDco11wJMw.png"/></div></div></figure><ul class=""><li id="9e95" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如果我们添加一个只有一个消费者的新消费者组“组 2 ”,组 2 将获得主题 T 中的所有消息。因此，这个组 2 独立于组 1 正在做的事情。</li></ul><h1 id="1ee6" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">分区重新平衡</h1><ul class=""><li id="53e7" class="jk jl in jm b jn mr jp ms jr mt jt mu jv mv jx jy jz ka kb bi translated">将分区所有权从一个用户更改到另一个用户称为重新平衡。这将非常有用，因为它允许我们轻松安全地添加和删除消费者。</li><li id="c013" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">但是当分区从一个消费者移动到另一个消费者时，消费者丢失了其当前的消息细节/消息状态。</li></ul><blockquote class="mw"><p id="fe72" class="mx my in bd mz na nb nc nd ne nf jx dk translated"><strong class="ak">心跳</strong> s:管理 kafka 组时，消费者服务商的心跳之间的预期时间。心跳用于确保使用者的会话保持活动状态，并在新的使用者加入、离开或空闲时提供重新平衡。</p></blockquote><ul class=""><li id="b573" class="jk jl in jm b jn ng jp nh jr ni jt nj jv nk jx jy jz ka kb bi translated">消费者组 ID:消费者组 ID 是集合中消费者组的标识符。</li><li id="55d9" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">组 ID 对于平衡分区非常重要。例如，如果我们有一个包含 4 个分区的主题。还将有两个具有相同 group-Id 的消费者，每个人将从 2 个分区中读取数据。</li><li id="b4aa" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">如果我们有两个具有不同组 id 的消费者，这两个消费者都将从 4 个分区中读取数据。在这种情况下，group-Id 就是如何定义从给定主题/分区读取的使用者组。</li></ul><p id="c353" class="pw-post-body-paragraph kh ki in jm b jn jo kj kk jp jq kl km jr kn ko kp jt kq kr ks jv kt ku kv jx ig bi translated"><strong class="jm io">提供密钥</strong>:因此，如果我们在消息中指定一个密钥，kafka 获取该密钥并将其应用于算法，然后根据模块结果决定它应该进入哪个主题，因此，如果您需要在流量实现中保证顺序，这将保证该分区内的顺序。</p><ul class=""><li id="b435" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如果你不提供钥匙，卡夫卡会进行循环赛。所以是这样的“一二三一二三一二三……”。<br/>但是这里的问题是，如果同一个客户的第一条消息发送到一个分区，第二条消息可能发送到第二个分区，第三条消息可能发送到第三个分区，即使在同一个客户内部，消息之间的顺序也无法保证，这是一个缺点。</li></ul></div></div>    
</body>
</html>