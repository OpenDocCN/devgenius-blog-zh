<html>
<head>
<title>How to Use Regular Expressions in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中如何使用正则表达式？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-regular-expressions-in-python-ee2e61cb3416?source=collection_archive---------2-----------------------#2022-05-24">https://blog.devgenius.io/how-to-use-regular-expressions-in-python-ee2e61cb3416?source=collection_archive---------2-----------------------#2022-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ad5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正则表达式或正则表达式需要一些时间来适应它。但是一旦你习惯了，你会发现 RegEx 对你的 Python 编程几乎是必不可少的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/095cee04de24e419db62cbac410c0800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnUqD-DP3izmpaHI5X-Zog.jpeg"/></div></div></figure><p id="dbb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将了解什么是正则表达式，正则表达式的用途，以及如何在 Python 中使用它。</p><h2 id="fa31" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">内容计划:</h2><ol class=""><li id="7cbb" class="ln lo in jm b jn lp jr lq jv lr jz ls kd lt kh lu lv lw lx bi translated"><a class="ae ly" href="#f968" rel="noopener ugc nofollow"> <em class="lz">什么是 RegEx？</em>T3】</a></li><li id="b216" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated"><a class="ae ly" href="#6896" rel="noopener ugc nofollow"> <em class="lz">正则表达式的语法</em> </a></li><li id="a61a" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated"><a class="ae ly" href="#61f2" rel="noopener ugc nofollow"> <em class="lz">如何在 Python 中使用 RegEx？</em> </a> <br/> 3.1 <a class="ae ly" href="#8e99" rel="noopener ugc nofollow"> <em class="lz">语法示例</em> </a> <br/> ⠀⠀3.1.1 <a class="ae ly" href="#ba9f" rel="noopener ugc nofollow"> <em class="lz">方括号([])</em><br/></a>⠀⠀3.1.2<em class="lz"/><a class="ae ly" href="#025b" rel="noopener ugc nofollow"><em class="lz">圆点(。)</em></a><br/>⠀⠀3.1.3<a class="ae ly" href="#4b3f" rel="noopener ugc nofollow"><em class="lz">\ w 和\ w</em></a><em class="lz">\ d 和\ d</em><br/>⠀⠀3.1.5<a class="ae ly" href="#bba0" rel="noopener ugc nofollow"><em class="lz">\ s 和\ s</em></a><br/>⠀⠀3.1.6<a class="ae ly" href="#c2e2" rel="noopener ugc nofollow"><em class="lz">^和\ a</em></a><br/>⠀⠀3.1.7<a class="ae ly" href="#422e" rel="noopener ugc nofollow"><em class="lz">$和\ z</em></a><br/>⠀⠀3.1.8<br/>)<br/>⠀⠀3.1.12<a class="ae ly" href="#f046" rel="noopener ugc nofollow"><em class="lz">*？, +?，还有呢？？</em></a><br/>⠀⠀3.1.13<a class="ae ly" href="#91c0" rel="noopener ugc nofollow"><em class="lz">重复次数{m }</em></a><br/>⠀⠀3.1.14<em class="lz"/><a class="ae ly" href="#8b17" rel="noopener ugc nofollow"><em class="lz">重复次数{m，n}</em></a><br/><a class="ae ly" href="#8c3e" rel="noopener ugc nofollow"><em class="lz">重复次数{ m，n }？</em></a><br/>⠀⠀3.1.16<a class="ae ly" href="#89c0" rel="noopener ugc nofollow"><em class="lz">圆括号()</em></a><br/>⠀⠀3.1.17<a class="ae ly" href="#1ae9" rel="noopener ugc nofollow"><em class="lz">竖线(| ) </em> </a></li><li id="370c" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated"><a class="ae ly" href="#b085" rel="noopener ugc nofollow"><em class="lz">RE 模块的主要功能</em></a><br/>4.1<a class="ae ly" href="#ef5e" rel="noopener ugc nofollow"><em class="lz">findall()函数</em></a><br/>4.2<a class="ae ly" href="#71a2" rel="noopener ugc nofollow"><em class="lz">split()函数</em> </a> <br/> 4.3 <a class="ae ly" href="#eb30" rel="noopener ugc nofollow"> <em class="lz"> sub()函数</em> </a></li><li id="5013" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated"><a class="ae ly" href="#a175" rel="noopener ugc nofollow"> <em class="lz">奖励给你</em> </a></li><li id="a298" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated"><a class="ae ly" href="#8038" rel="noopener ugc nofollow"> <em class="lz">结论</em> </a></li></ol></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="f968" class="mm kv in bd kw mn mo mp kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc bi translated">1.什么是正则表达式？</h1><p id="47e6" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated"><strong class="jm io">正则表达式(RegEx) </strong>是一个特殊的字符序列，它使用搜索模式来查找一个或一组字符串。它可以通过将文本与特定模式进行匹配来检测文本的存在与否，还可以将一个模式分成一个或多个子模式。Python 提供了<code class="fe ng nh ni nj b">re</code>模块，允许你在 Python 中使用 RegEx。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7c2e3b1a90367a0fc8a7d1bdb00a4a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwNPrfyimdsgjIW0iX-5VQ.jpeg"/></div></div></figure><h1 id="6896" class="mm kv in bd kw mn nl mp kz mq nm ms lc mt nn mv lf mw no my li mz np nb ll nc bi translated">2.正则表达式的语法</h1><p id="4a8a" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">正则表达式的语法分为两部分:<strong class="jm io">元字符</strong>和<strong class="jm io">特殊序列</strong>。让我们一起来看看。</p><h2 id="ca94" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">元字符:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a76f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">元字符</strong>被视为正则表达式的构成元素。正则表达式是匹配字符串中字符组合的模式。元字符在搜索模式时有特殊的含义，主要用于定义搜索标准和任何文本操作。</p><p id="378e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">特殊序列:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cdc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">特殊序列表示具有单向含义的基本预定义字符类。每个特殊序列使某些常见的设计更便于使用。</p><p id="7f01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，您可以使用序列<code class="fe ng nh ni nj b">'\d'</code>作为字符类<code class="fe ng nh ni nj b">'[0-9]'</code>的简化定义，这意味着它对应于 0 到 9 之间的任何数字。</p><p id="0fc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你现在不知道什么是有效的，不要担心！我们将检查每个案例中的一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/d590a7d71b05098bd2a1de7ef9c31c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcpjmsJvMZNmXhofbGXvww.png"/></div></div></figure><h1 id="61f2" class="mm kv in bd kw mn nl mp kz mq nm ms lc mt nn mv lf mw no my li mz np nb ll nc bi translated">3.如何在 Python 中使用 RegEx？</h1><p id="d6fd" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">在 Python 中使用 RegEx 需要导入<code class="fe ng nh ni nj b">re</code>模块。这个模块有几个功能。我们将使用<code class="fe ng nh ni nj b">re.search()</code>函数来看看<strong class="jm io">元字符</strong>和<strong class="jm io">特殊序列</strong>是如何工作的。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="8e99" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1 语法示例</h2><p id="bb94" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">最初，您应该知道<code class="fe ng nh ni nj b">re.search()</code>函数来看看例子。</p><h2 id="de2a" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">search()函数</h2><p id="7e31" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated"><code class="fe ng nh ni nj b">search()</code>函数在字符串中搜索匹配项，如果匹配就返回一个匹配对象。如果有多个匹配项，将只返回第一个匹配项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="ba9f" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.1 方括号([ ])</h2><blockquote class="nt nu nv"><p id="db62" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><em class="in">指定要匹配的唯一字符集。</em></p></blockquote><p id="665b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方括号<code class="fe ng nh ni nj b">'[]'</code>中的字符代表一个<strong class="jm io">字符类</strong>，一个应该匹配的枚举字符集。字符类元字符序列将对应于该类中包含的任何字符。</p><p id="7d88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以像这样列出单个字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="58f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">元字符序列<code class="fe ng nh ni nj b">'[aptg]’</code>匹配任何单个<code class="fe ng nh ni nj b">'a'</code>、<code class="fe ng nh ni nj b">'p'</code>、<code class="fe ng nh ni nj b">'t'</code>或<code class="fe ng nh ni nj b">'g'</code>字符。在这个例子中，正则表达式<code class="fe ng nh ni nj b">'Pi[aptg]'</code>匹配<code class="fe ng nh ni nj b">'Pip'</code>和<code class="fe ng nh ni nj b">'Pig'</code>(也匹配<code class="fe ng nh ni nj b">'Pit'</code>和<code class="fe ng nh ni nj b">'Pia'</code>)。</p><p id="3ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">字符类还可以包含由连字符<code class="fe ng nh ni nj b">'-’</code>分隔的字符范围，在这种情况下，它匹配范围内的任何单个字符。例如，<code class="fe ng nh ni nj b">'[a-z]'</code>是从<code class="fe ng nh ni nj b">'a'</code>到<code class="fe ng nh ni nj b">'z'</code>的任何小写字母字符，包括所有小写字母字符，而<code class="fe ng nh ni nj b">'[0-9]'</code>匹配任何数字字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5c5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样在上面的例子中，<code class="fe ng nh ni nj b">'[0-9][0-9]’</code>匹配两个数字的序列。匹配的<code class="fe ng nh ni nj b">'Pronounce 123'</code>字符串的第一部分是<code class="fe ng nh ni nj b">'12'</code>。</p><p id="ba20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过指定第一个字符<code class="fe ng nh ni nj b">'^'</code>来补充一个字符类，在这种情况下，它匹配不在集合中的任何字符。在以下示例中，<code class="fe ng nh ni nj b">'[^0-9]’</code>匹配任何非数字字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c20e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，match 对象显示字符串中不是数字的第一个字符是<code class="fe ng nh ni nj b">'h'</code>。</p><p id="58e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一个字符类中的<code class="fe ng nh ni nj b">'^'</code>字符不是第一个字符，那么它没有任何特殊意义，它匹配一个文字<code class="fe ng nh ni nj b">'^'</code>字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="025b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.2 点(。)</h2><blockquote class="nt nu nv"><p id="a18e" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><em class="in">指定一个通配符。</em></p></blockquote><p id="903f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'.’</code>元字符匹配除换行符之外的任何单个字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="32d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个正则表达式，<code class="fe ng nh ni nj b">'Pyt.on'</code>基本上意味着<code class="fe ng nh ni nj b">'Pyt'</code>字符，然后是除换行符之外的任何字符，然后是<code class="fe ng nh ni nj b">'on'</code>字符。在上面展示的第一个字符串中，<code class="fe ng nh ni nj b">'Python'</code>对应于模式，因为<code class="fe ng nh ni nj b">'.'</code>元字符匹配<code class="fe ng nh ni nj b">'h'</code>。</p><p id="a2ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二和第三根弦不匹配。在后一种情况下，即使在<code class="fe ng nh ni nj b">'Pyt'</code>和<code class="fe ng nh ni nj b">'hon'</code>之间有一个字符，它也是一个换行符，默认情况下，<code class="fe ng nh ni nj b">'.'</code>元字符不匹配换行符。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="4b3f" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.3 和</h2><blockquote class="nt nu nv"><p id="14ce" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">根据字符是否为单词字符进行匹配<em class="in">。</em></p></blockquote><p id="129c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\w'</code>匹配任何字母数字单词字符。单词字符是大写和小写字母、数字和下划线<code class="fe ng nh ni nj b">'_’</code>字符，因此<code class="fe ng nh ni nj b">'\w’</code>基本上是<code class="fe ng nh ni nj b">'[a-zA-Z0-9_]’</code>的快捷方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7939" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，字符串<code class="fe ng nh ni nj b">'#().%A&amp;*'</code>中单词的第一个字符是<code class="fe ng nh ni nj b">'A'</code>。</p><p id="17f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\W’</code>则相反。它匹配任何非单词字符，相当于<code class="fe ng nh ni nj b">'[^a-zA-Z0-9_]’</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，<code class="fe ng nh ni nj b">'#().%A&amp;*'</code>中的第一个非文字字符是<code class="fe ng nh ni nj b">'^'</code>。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="d6bf" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.4</h2><blockquote class="nt nu nv"><p id="a5c6" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">字符与十进制数的匹配<em class="in">。</em></p></blockquote><p id="9106" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\d’</code>匹配任何数字字符。<code class="fe ng nh ni nj b">'\D'</code>正相反。它适合所有不是小数的字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="122a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\d’</code>基本等于<code class="fe ng nh ni nj b">'[0-9]’</code>,<code class="fe ng nh ni nj b">'\D’</code>等于<code class="fe ng nh ni nj b">'[^0-9]'</code>。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="bba0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.5</h2><blockquote class="nt nu nv"><p id="fd08" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">根据字符是否代表<em class="in"> </em>空格<em class="in">进行匹配。</em></p></blockquote><p id="398f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\s'</code>匹配任何空白字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4dd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，与点<code class="fe ng nh ni nj b">’.’</code>元字符不同，<code class="fe ng nh ni nj b">'\s'</code>对应一个换行符。</p><p id="aa3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\S’</code>是<code class="fe ng nh ni nj b">'\s'</code>的反义词。它匹配任何非空白字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1b74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次，<code class="fe ng nh ni nj b">'\s’</code>和<code class="fe ng nh ni nj b">'\S'</code>认为换行符是空白。在上面的例子中，第一个非空白字符是<code class="fe ng nh ni nj b">'H'</code>。</p><p id="b203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">字符类的序列<code class="fe ng nh ni nj b">'\w’</code>、<code class="fe ng nh ni nj b">'\W’</code>、<code class="fe ng nh ni nj b">’\d'</code>、<code class="fe ng nh ni nj b">'\D’</code>、<code class="fe ng nh ni nj b">'\s’</code>和<code class="fe ng nh ni nj b">'\S’</code>也可以出现在方括号字符类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8346" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，<code class="fe ng nh ni nj b">'[\d\w\s]’</code>对应于任何数字、单词或空白字符。因为<code class="fe ng nh ni nj b">'\w’</code>包含了<code class="fe ng nh ni nj b">'\d'</code>，所以同样的字符类也可以表达成略短的<code class="fe ng nh ni nj b">'[\w\s]'</code>。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="c2e2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">^和\A</h2><blockquote class="nt nu nv"><p id="497d" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">将匹配锚定到字符串的开头。</p></blockquote><p id="4f8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当正则表达式解析器遇到<code class="fe ng nh ni nj b">'^'</code>或<code class="fe ng nh ni nj b">'\A’</code>时，解析器的当前位置必须在搜索字符串的开头，以便找到匹配。</p><p id="ea42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，regex <code class="fe ng nh ni nj b">'^pip'</code>指定<code class="fe ng nh ni nj b">'pip'</code>不能出现在搜索字符串中的任何地方，而是出现在开头:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="46d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\A’</code>功能相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="422e" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">和\Z</h2><blockquote class="nt nu nv"><p id="3db9" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">将一根火柴固定在一根绳子的末端。</p></blockquote><p id="6ef1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当正则表达式分析器遇到<code class="fe ng nh ni nj b">'$'</code>或<code class="fe ng nh ni nj b">'\Z’</code>时，分析器的当前位置必须在搜索字符串的末尾，这样它才能找到匹配项。上面的<code class="fe ng nh ni nj b">’$’</code>或<code class="fe ng nh ni nj b">'\Z'</code>必须是搜索字符串的结尾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个特例，<code class="fe ng nh ni nj b">'$'</code>(而不是<code class="fe ng nh ni nj b">'\Z’</code>)也匹配搜索字符串末尾的一个换行符之前的位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d5ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，<code class="fe ng nh ni nj b">'world'</code>严格来说并不在搜索字符串的末尾，因为它后面跟了一个额外的换行符。但是正则表达式分析器丢弃它，仍然称它为匹配。该异常对<code class="fe ng nh ni nj b">'\Z'</code>无效。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="3466" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">B 和 B</h2><blockquote class="nt nu nv"><p id="d868" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">将匹配锚定到单词边界。</p></blockquote><p id="9971" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\b’</code>断言正则表达式分析器的当前位置必须在一个单词末尾的开头。一个单词由一系列字母数字字符或下划线(<code class="fe ng nh ni nj b">'[a-zA-Z0-9_]’</code>)组成，与<code class="fe ng nh ni nj b">'\w’</code>字符类相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aa97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，匹配发生在第 4 行<strong class="jm io">和第 5 行</strong>，因为在<code class="fe ng nh ni nj b">'world'</code>的开头有一个字边界。在<strong class="jm io">行 6 </strong>上情况并非如此，因此匹配不成功。</p><p id="0a64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，在<strong class="jm io">第 14 行和第 15 行</strong>上有匹配，因为在<code class="fe ng nh ni nj b">'hello'</code>的结尾有一个字边界，而在<strong class="jm io">第 16 行</strong>上没有。</p><p id="becd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ng nh ni nj b">'&lt;regex&gt;’</code>的两端使用特殊序列<code class="fe ng nh ni nj b">'\b'</code>，当它作为一个完整的单词出现在搜索字符串中时，将匹配它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4cb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'\B’</code>与<code class="fe ng nh ni nj b">'\b’</code>相反。它断言分析器的当前位置必须是<em class="lz">而不是</em>在一个字的开头或结尾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b338" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，匹配发生在<strong class="jm io">行 6 </strong>上，因为在搜索字符串<code class="fe ng nh ni nj b">'helloworldfromPython'</code>中<code class="fe ng nh ni nj b">'world'</code>的开头或结尾没有字边界。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="93aa" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.9 星号(*)</h2><blockquote class="nt nu nv"><p id="981a" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">匹配前面正则表达式的零次或多次重复。</p></blockquote><p id="625e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，<code class="fe ng nh ni nj b">'a*'</code>匹配零个或多个<code class="fe ng nh ni nj b">'a'</code>字符。这意味着它将对应于一个空字符串<code class="fe ng nh ni nj b">''</code>、<code class="fe ng nh ni nj b">'a'</code>、<code class="fe ng nh ni nj b">'aa'</code>、<code class="fe ng nh ni nj b">'aaa'</code>等等。</p><p id="2f24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e0e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">第 4 行</strong>上，在<code class="fe ng nh ni nj b">'one'</code>和<code class="fe ng nh ni nj b">'two'</code>之间有零个<code class="fe ng nh ni nj b">'-'</code>字符。在<strong class="jm io">线 5 </strong>上有一个，在<strong class="jm io">线 6 </strong>上有两个。元字符<code class="fe ng nh ni nj b">'-*'</code>的序列在所有三种情况下都匹配。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="272c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.10 加号(+)</h2><blockquote class="nt nu nv"><p id="f457" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">匹配前面正则表达式的一个或多个重复项。</p></blockquote><p id="c46f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这类似于<code class="fe ng nh ni nj b">’*’</code>，但是量化的正则表达式必须至少出现一次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1acc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，上面的<code class="fe ng nh ni nj b">'one-*two’</code>匹配字符串<code class="fe ng nh ni nj b">'onetwo'</code>，因为<code class="fe ng nh ni nj b">'*'</code>元字符允许出现 0 次<code class="fe ng nh ni nj b">'-'</code>。<code class="fe ng nh ni nj b">'+’</code>元字符要求至少出现一次<code class="fe ng nh ni nj b">'-'</code>。这意味着在这种情况下<strong class="jm io">行 4 </strong>没有对应关系。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="913a" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.11 问号(？)</h2><blockquote class="nt nu nv"><p id="d219" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">匹配前面正则表达式的零次或一次重复。</p></blockquote><p id="3130" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，它类似于<code class="fe ng nh ni nj b">'*'</code>和<code class="fe ng nh ni nj b">’+’</code>，但是在这种情况下，只有前面的正则表达式出现 1 次或 0 次才匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b065" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有与<strong class="jm io">第 4 行和第 5 行</strong>的匹配。但是在<strong class="jm io">第 6 行</strong>上，有两个<code class="fe ng nh ni nj b">'-'</code>字符，匹配不成功。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="f046" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.12 *?, +?，还有呢？？</h2><blockquote class="nt nu nv"><p id="fa8f" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'*'</code>、<code class="fe ng nh ni nj b">’+’</code>和<code class="fe ng nh ni nj b">'?'</code>量词的非贪婪(或懒惰)版本。</p></blockquote><p id="178f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅在使用时，量词元字符<code class="fe ng nh ni nj b">’*’</code>、<code class="fe ng nh ni nj b">’+’</code>和<code class="fe ng nh ni nj b">'?'</code>都是<strong class="jm io">贪婪</strong>，这意味着它们产生尽可能长的匹配。以此为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ba15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正则表达式<code class="fe ng nh ni nj b">'&lt;.*&gt;’</code>实际上意味着:</p><ul class=""><li id="51a1" class="ln lo in jm b jn jo jr js jv nz jz oa kd ob kh oc lv lw lx bi translated">一个<code class="fe ng nh ni nj b">’&lt;’</code>字符</li><li id="367f" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated">那么任何字符序列</li><li id="407e" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated">然后是一个<code class="fe ng nh ni nj b">'&gt;'</code>字</li></ul><p id="b7ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是哪个<code class="fe ng nh ni nj b">’&gt;’</code>人物？有三种可能性:</p><ol class=""><li id="a5df" class="ln lo in jm b jn jo jr js jv nz jz oa kd ob kh lu lv lw lx bi translated">紧接在<code class="fe ng nh ni nj b">'Hello'</code>之后的那个</li><li id="3b0a" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated">紧接在<code class="fe ng nh ni nj b">'World'</code>之后的那个</li><li id="c7da" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh lu lv lw lx bi translated">紧接在<code class="fe ng nh ni nj b">'again'</code>之后的那个</li></ol><p id="e143" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<code class="fe ng nh ni nj b">’*’</code>元字符是贪婪的，它规定了可能的最长匹配，这包括了从<code class="fe ng nh ni nj b">'&gt;'</code>到<code class="fe ng nh ni nj b">'World'</code>之后的所有字符。您可以在 match 对象中看到这是结果对应。</p><p id="3ea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想要尽可能短的对应，那么使用非贪婪元字符序列<code class="fe ng nh ni nj b">'*?’</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fef6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，匹配以<code class="fe ng nh ni nj b">'Hello'</code>后的<code class="fe ng nh ni nj b">'&gt;'</code>字符结束。</p><p id="7a07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>你可以用正则表达式<code class="fe ng nh ni nj b">'&lt;[^&gt;]*&gt;’</code>做同样的事情，这意味着:</p><ul class=""><li id="4c66" class="ln lo in jm b jn jo jr js jv nz jz oa kd ob kh oc lv lw lx bi translated">一个<code class="fe ng nh ni nj b">'&lt;'</code>人物</li><li id="83b2" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated">那么除了<code class="fe ng nh ni nj b">'&gt;'</code>之外的任何字符序列</li><li id="c510" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated">然后是一个<code class="fe ng nh ni nj b">'&gt;'</code>字</li></ul><p id="bb34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于一些不支持惰性量词的旧分析器来说，这是唯一可用的选项。令人高兴的是，Python 的<code class="fe ng nh ni nj b">re</code>模块中的正则表达式分析器并非如此。</p><p id="3c71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有懒惰版本的<code class="fe ng nh ni nj b">'+'</code>和<code class="fe ng nh ni nj b">'?'</code>量词:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="110f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">线 4 和 5 </strong>上的前两个例子同上，仅使用<code class="fe ng nh ni nj b">’+’</code>和<code class="fe ng nh ni nj b">'+?'</code>代替<code class="fe ng nh ni nj b">'*'</code>和<code class="fe ng nh ni nj b">'*?’</code>。</p><p id="b85d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 6 行和第 7 行</strong>的最后一个例子略有不同。一般来说，<code class="fe ng nh ni nj b">?</code>元字符匹配前面正则表达式的 0 次或 1 次出现。贪婪的版本<code class="fe ng nh ni nj b">'?'</code>匹配 1 个事件，所以<code class="fe ng nh ni nj b">'Hi?’</code>匹配<code class="fe ng nh ni nj b">'Hi'</code>，后面跟一个<code class="fe ng nh ni nj b">'i'</code>。非贪婪版本<code class="fe ng nh ni nj b">'??’</code>匹配 0 次，所以<code class="fe ng nh ni nj b">'Hi??’</code>只匹配<code class="fe ng nh ni nj b">'H'</code>。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="91c0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.13 重复次数{m}</h2><blockquote class="nt nu nv"><p id="8fca" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">精确匹配前面正则表达式的<code class="fe ng nh ni nj b">m</code>次重复。</p></blockquote><p id="b08a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这类似于<code class="fe ng nh ni nj b">’*’</code>或<code class="fe ng nh ni nj b">’+’</code>，但是它精确地指定了前面的正则表达式必须出现多长时间才能匹配成功:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a304" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，<code class="fe ng nh ni nj b">'1/{3}1’</code>匹配<code class="fe ng nh ni nj b">'1'</code>，紧接着是 3 个<code class="fe ng nh ni nj b">'/'</code>字符实例，然后是第二个<code class="fe ng nh ni nj b">'1'</code>。当<code class="fe ng nh ni nj b">'1'</code>字符之间的斜杠少于或多于 3 个时，匹配失败。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="8b17" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.14 重复次数{m，n}</h2><blockquote class="nt nu nv"><p id="d77b" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">匹配前面的正则表达式从<code class="fe ng nh ni nj b">m</code>到<code class="fe ng nh ni nj b">n</code>的任意次数的重复，包括。</p></blockquote><p id="d581" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的例子中，量化的<code class="fe ng nh ni nj b">'&lt;regex&gt;’</code>是<code class="fe ng nh ni nj b">'-{2,4}’</code>。当<code class="fe ng nh ni nj b">'hi'</code>字符之间有 2、3 或 4 个破折号时匹配成功，否则匹配失败:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="8c3e" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.15 重复{m，n}？</h2><blockquote class="nt nu nv"><p id="2fad" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">非贪婪(懒惰)版的<code class="fe ng nh ni nj b">'{m,n}’</code>。</p></blockquote><p id="1926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">'{m,n}’</code>将匹配尽可能多的字符，<code class="fe ng nh ni nj b">'{m,n}?'</code>将匹配尽可能少的字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7e4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，<code class="fe ng nh ni nj b">'x{3,5}’</code>给出最长的可能匹配，因此它匹配 5 个<code class="fe ng nh ni nj b">'x'</code>字符。<code class="fe ng nh ni nj b">'x{3,5}?’</code>给出最短的匹配，这意味着它匹配 3。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="89c0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">圆括号( )</h2><p id="bc56" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">分组并不是分组约束的唯一有用的目标。大多数(但不是全部)分组结构也捕获搜索字符串中与该组匹配的部分。您可以通过各种方式获取捕获的部分或在以后引用它。</p><p id="1742" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得<code class="fe ng nh ni nj b">re.search()</code>返回的 match 对象吗？匹配对象有两个定义的方法，允许访问捕获的组:<code class="fe ng nh ni nj b">.groups()</code>和<code class="fe ng nh ni nj b">.group()</code></p><p id="9f2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> m.groups() </strong></p><blockquote class="nt nu nv"><p id="7061" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">返回一个元组，其中包含从正则表达式匹配中捕获的所有组。</p></blockquote><p id="b93e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个表达式<code class="fe ng nh ni nj b">'(\w+)’</code>对应一个单词字符序列。整个正则表达式<code class="fe ng nh ni nj b">'(\w+):(\w+):(\w+)'</code>将搜索字符串分成三个逗号分隔的部分。</p><p id="ef76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于表达式<code class="fe ng nh ni nj b">'(\w+)’</code>使用分组括号，相应的匹配部分被<strong class="jm io">捕获</strong>。要访问捕获的匹配，您可以使用<code class="fe ng nh ni nj b">.groups()</code>，它返回一个包含序列中所有捕获的匹配的元组:</p><pre class="kj kk kl km gt od nj oe of aw og bi"><span id="0cd2" class="ku kv in nj b gy oh oi l oj ok">&gt;&gt;&gt; reg_1.groups()<br/>('hello', 'world', 'again')</span></pre><p id="2cc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，元组包含搜索字符串中出现的部分，但不包含逗号。这是因为组成部分的单词字符在分组括号内，但逗号不在。您在返回部分之间看到的逗号是用于分隔元组中的值的标准分隔符。</p><p id="5833" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> m.group( &lt; n &gt; ) </strong></p><blockquote class="nt nu nv"><p id="211a" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">返回一个包含<code class="fe ng nh ni nj b">&lt;n&gt;th</code>捕获匹配的字符串。</p></blockquote><p id="f295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用一个参数，<code class="fe ng nh ni nj b">group()</code>返回一个捕获的匹配。请记住，参数是从 1 开始的，而不是从 0 开始的。因此，<code class="fe ng nh ni nj b">reg_1.group(1)</code>是第一个记录器匹配，<code class="fe ng nh ni nj b">reg_1.group(2)</code>是第二个记录器匹配，依此类推:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d4e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为捕获的匹配项的编号是从 1 开始的，并且没有任何编号为 0 的组，<code class="fe ng nh ni nj b">reg_1.group(0)</code>具有特殊的意义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8aee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">reg_1.group(0)</code>返回整个匹配，<code class="fe ng nh ni nj b">reg_1.group()</code>也做同样的事情。</p><p id="6411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> m.group( &lt; n &gt;，&lt; n &gt;，…) </strong></p><blockquote class="nt nu nv"><p id="e035" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">返回一个包含指定的捕获匹配的元组<em class="in">。</em></p></blockquote><p id="5db0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用多个参数，<code class="fe ng nh ni nj b">.group()</code>返回一个元组，该元组包含按给定顺序捕获的指定匹配项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="df57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是方便的速记。您可以自己创建匹配元组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b7e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种说法在功能上是相同的。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="1ae9" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">3.1.17 竖线(|)</h2><blockquote class="nt nu nv"><p id="df80" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">指定要匹配的一组备选项。</p></blockquote><p id="52cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">形式为<code class="fe ng nh ni nj b">'&lt;regex1&gt;|&lt;regex2&gt;|...|&lt;regexn&gt;'</code>的表达式最多对应一个指定的<code class="fe ng nh ni nj b">'&lt;regexi&gt;’</code>表达式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9271" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，<code class="fe ng nh ni nj b">'hello|world|again'</code>将匹配<code class="fe ng nh ni nj b">'hello'</code>、<code class="fe ng nh ni nj b">'world'</code>或<code class="fe ng nh ni nj b">'again'</code>中的任何一个。使用<code class="fe ng nh ni nj b">’|’</code>可以分隔任意数量的表达式。</p><p id="4c2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">交替是非贪婪的。正则表达式分析器按照从左到右的顺序查看由<code class="fe ng nh ni nj b">'|'</code>分隔的表达式，并返回找到的第一个匹配项。不测试其他表达式，即使其中一个会产生更长的匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="989b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，在<strong class="jm io">行 6 </strong>、<code class="fe ng nh ni nj b">'multi|play'</code>上指定的模式将在<code class="fe ng nh ni nj b">'multi'</code>或<code class="fe ng nh ni nj b">'play'</code>上匹配。返回的匹配是<code class="fe ng nh ni nj b">'multi'</code>，因为当从左向右扫描时，它首先出现，尽管<code class="fe ng nh ni nj b">'play'</code>可能是一个更长的匹配。</p><p id="057f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以组合交替、分组和所有其他元字符，以达到任何级别的复杂性。在下面的例子中，<code class="fe ng nh ni nj b">'(hello|world|again)+’</code>表示一个或多个字符串<code class="fe ng nh ni nj b">'hello'</code>、<code class="fe ng nh ni nj b">'world'</code>或<code class="fe ng nh ni nj b">'again'</code>的序列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="b085" class="mm kv in bd kw mn mo mp kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc bi translated">4.RE 模块的基本功能</h1><p id="10b6" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">你已经知道 RegEx 的<code class="fe ng nh ni nj b">search()</code>功能，但是你应该知道其他的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="ef5e" class="mm kv in bd kw mn mo mp kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc bi translated">4.1 findall()函数</h1><blockquote class="nt nu nv"><p id="8de1" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">findall()</code>函数返回一个包含所有匹配的列表。</p></blockquote><p id="19e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该列表按找到的顺序包含匹配项。如果没有找到结果，则返回一个空列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="71a2" class="mm kv in bd kw mn mo mp kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc bi translated">4.2 split()函数</h1><blockquote class="nt nu nv"><p id="9512" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">split()</code>函数返回一个列表，其中的字符串在每次匹配时都被拆分。</p></blockquote><p id="fb10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过指定<code class="fe ng nh ni nj b">maxsplit</code>参数来控制出现的次数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="eb30" class="mm kv in bd kw mn mo mp kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc bi translated">4.3 sub()函数</h1><blockquote class="nt nu nv"><p id="6f78" class="jk jl lz jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated"><code class="fe ng nh ni nj b">sub()</code>功能用您选择的文本替换匹配项。</p></blockquote><p id="d425" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用数字 9 替换每个空白字符。您可以通过指定<code class="fe ng nh ni nj b">count</code>参数来控制替换的数量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="a175" class="mm kv in bd kw mn nl mp kz mq nm ms lc mt nn mv lf mw no my li mz np nb ll nc bi translated">5.给你的奖金</h1><p id="c344" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">作为奖励，我想和你分享这张小抄，它会对你有用的。这里是你使用它所需要的一切，甚至更多。愿它永远触手可及！</p><div class="ol om gp gr on oo"><a href="https://drive.google.com/file/d/193lNx7lc6vjvjHkdeB64QSkmrXMjK63L/view?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd io gy z fp ot fr fs ou fu fw im bi translated">python-regular-expressions-cheat-sheet.pdf</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">编辑描述</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">drive.google.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="45fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且也为了测试你的 RegEx check <a class="ae ly" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">这个站点</a>的正确性！</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/1d0d16323cfd6f3dcc86d8da36c68694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ziL9Xwb_jnTgJp3"/></div></div></figure><h1 id="8038" class="mm kv in bd kw mn nl mp kz mq nm ms lc mt nn mv lf mw no my li mz np nb ll nc bi translated">6.结论</h1><p id="f164" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv nd jx jy jz ne kb kc kd nf kf kg kh ig bi translated">让我们结束这一切。现在你知道了:</p><ul class=""><li id="8ccc" class="ln lo in jm b jn jo jr js jv nz jz oa kd ob kh oc lv lw lx bi translated">正则表达式是干什么用的</li><li id="63df" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated">如何在 Python 中使用正则表达式</li><li id="a028" class="ln lo in jm b jn ma jr mb jv mc jz md kd me kh oc lv lw lx bi translated"><code class="fe ng nh ni nj b">re</code>模块的基本功能</li></ul><p id="a5f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且具有:</p><ul class=""><li id="3335" class="ln lo in jm b jn jo jr js jv nz jz oa kd ob kh oc lv lw lx bi translated">Python 正则表达式备忘单</li></ul><p id="a660" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lz">附言:如果你喜欢这篇文章，</em> <a class="ae ly" href="https://medium.com/@vlad.bashtannyk" rel="noopener"> <em class="lz">关注我</em> </a>，<em class="lz">点击几下“拍手”然后</em> <em class="lz">留下反馈。祝你好运，高效编程！谢谢大家！</em></p><p id="7a76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关注我<a class="ae ly" href="https://www.linkedin.com/in/vladyslav-bashtannyk/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> LinkedIn </em> </a> <em class="lz"> </em>和<em class="lz"/><a class="ae ly" href="https://twitter.com/VladyslavBasht2" rel="noopener ugc nofollow" target="_blank"><em class="lz">Twitter</em></a>！</p></div></div>    
</body>
</html>