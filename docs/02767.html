<html>
<head>
<title>Orchestration or Choreography</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编排或编排</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/orchestration-or-choreography-edb316cba7ff?source=collection_archive---------4-----------------------#2020-08-28">https://blog.devgenius.io/orchestration-or-choreography-edb316cba7ff?source=collection_archive---------4-----------------------#2020-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aa38ffad973f7fc88cea3cfcd2f73024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kZo82aGm4NlWiPeQ.png"/></div></div></figure><p id="e460" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">博客由三部分组成。</p><ol class=""><li id="c138" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">提醒基础知识。</li><li id="6ca0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">更侧重于混合方法的解释</li><li id="d549" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">展示了一个示例实现。</li></ol><h1 id="ec31" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">编排与编排</h1><p id="7d8d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated"><strong class="jx io">编排定义，</strong>在数据/业务实体处理管道中，编排器是负责管理节点和流程的组件。只有一个主机知道在给定的时刻应该执行哪个管道。这个编排器是唯一能够触发该执行的组件。</p><p id="fe22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">编排</strong>依赖于独立的微服务架构，其中每个服务都知道在一天的给定时刻做什么。这些服务不直接通信。相反，它们通过基于事件的架构间接对话。在这种情况下，每个服务都知道如何处理每个订阅的事件。</p><p id="08e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两种方法各有利弊。<em class="mk">orchestrator 提供了管道的统一视图</em>，但与编排相比，它的灵活性较差。另一方面，<em class="mk">编排使用松散耦合，有时无共享管道</em>比高度耦合的管道更难管理。尤其是当上下文随着每个新添加的服务和事件变得越来越复杂时。</p><p id="2a01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">流程编排方法可以与 DAG 工作流一起呈现。例如，允许拥有由整合来自我们不同合作伙伴的数据的步骤和一个最终 DAG 组成的管道，以对它们进行一些最终计算</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/275610a637ff0afadfc3b4646dc4f48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6unUbzoSgYl9m3FROF5DQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">编排示例</figcaption></figure><p id="42e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了说明编排模式，我们可以使用任何事件驱动的架构来集成上游/下游(合作伙伴)的数据，并触发最终的聚合作业。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/2b732443732d72d3cd371bb48978757e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kF25WubaQh1Xzs6rpEK9Ew.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">编排示例</figcaption></figure><p id="80a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也许示例没有清楚地显示出来，但是这两种方法略有不同。在基于编排的体系结构中，编排器以一定的时间间隔验证它是否可以启动合作伙伴的处理。通过编排，每个合作伙伴都有自己专用的数据管道，启动管道的逻辑由数据处理器 Lambda 函数在内部管理。</p><h1 id="f1ba" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">提议的混合解决方案</h1><p id="7e3f" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">编排具有基于服务已知事件的优势。因此，当一些输入数据不存在时，在它上面不会有任何处理动作。另一方面，得出这样一个流程的总体进度可见性可能是复杂的，特别是如果您想知道什么部分被执行了以及何时被执行。让我们看看我们是否能同时拥有两个世界。</p><p id="d5fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">混合解决方案方法仍然使用编排来执行处理逻辑，但是增加了中央状态管理器，称为 master。主模块负责将事件保存在事件存储中，然后与编排器进行通信，以提供一种集中的方式来可视化所发生的事情以及进度。</p><h1 id="8822" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">履行</h1><p id="d5c5" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">这个理论看起来很简单，但是以一种具体的方式混合这两个词要稍微复杂一些。让我们看看前面提到的本地事件驱动的数据处理示例的可行性。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/89e0a5c3ba7768999c2252d502f7fc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*811Guk2IqblXxSRVpx34OA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">混合溶液流</figcaption></figure><p id="21f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在该模式中，Lambda 函数仅充当生成事件的拦截器。它不包含任何处理逻辑，而是捕捉事件细节并将其发送给某个流代理。在编排者方面，有一个简单的流消费者，根据读取事件，可能触发 DAG。触发的 DAG 没有计划，因此只能通过外部触发器启动。消费者传递特定于给定执行的所有配置(在 Apache Airflow 的情况下，通过<em class="mk"> -c CONF </em>参数)。</p><p id="502d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编排和编排是完全相反的概念。前者使用单个控制器来管理作业的执行，而后者给了作业执行更多的自由。然而，两者可以混合使用，以获得两者的最佳效果。</p></div></div>    
</body>
</html>