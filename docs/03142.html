<html>
<head>
<title>React Hooks — Using a wrapper to memoize event handlers and to prevent unnecessary re-renders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩——使用包装器来记忆事件处理程序，并防止不必要的重新呈现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-hooks-using-a-wrapper-to-memoize-event-handlers-and-to-prevent-unnecessary-re-renders-9e7fbbc0f95c?source=collection_archive---------0-----------------------#2020-10-05">https://blog.devgenius.io/react-hooks-using-a-wrapper-to-memoize-event-handlers-and-to-prevent-unnecessary-re-renders-9e7fbbc0f95c?source=collection_archive---------0-----------------------#2020-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a35e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几周前，我遇到了React挂钩、事件处理程序和不必要的重新渲染的问题。使用类解决方案是相当琐碎的，使用钩子，没有那么多。</p><p id="1911" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们应用程序的简化要求:</p><ul class=""><li id="d760" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">显示项目列表。</li><li id="0641" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">每个项目都有一个输入字段。</li><li id="2f3c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">每个项目都有一个保存按钮。</li><li id="76cb" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">更改或保存一个项目不会导致其他项目的重新渲染。</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/d1b91a89e3f00866c7aca20e85696433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*Q9VoU7nbyyD5XUg4.png"/></div></figure><p id="a749" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，如果渲染是廉价的，那么每次重新渲染是完全有意义的。在这种特殊情况下，我们希望防止其他项目的重新渲染。</p><h1 id="4761" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们的数据集</h1><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="a957" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么使用React钩子会更困难？</h1><p id="7a26" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">下面的例子是呈现所有<code class="fe mj mk ml mm b">Item</code>组件的<code class="fe mj mk ml mm b">ItemList</code>组件的可能实现。</p><p id="8c0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<a class="ae mn" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> useCallback </a>钩子来记忆<code class="fe mj mk ml mm b">handleChange</code>函数。只有当其中一个依赖关系(在本例中为<code class="fe mj mk ml mm b">setItems</code>)发生变化时，才会重新创建该函数。到目前为止还好。</p><p id="6c3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是<code class="fe mj mk ml mm b">handleSave</code>函数没有被记忆。在每次渲染<code class="fe mj mk ml mm b">ItemList</code>时，都会创建一个新的<code class="fe mj mk ml mm b">handleSave</code>函数。因此，当一个<code class="fe mj mk ml mm b">Item</code>更新时，所有其他的<code class="fe mj mk ml mm b">Item</code>组件也会重新渲染。我们不能在这里使用<code class="fe mj mk ml mm b">useCallback</code>，因为<code class="fe mj mk ml mm b">handleSave</code>依赖于<code class="fe mj mk ml mm b">items</code>。<code class="fe mj mk ml mm b">items</code>当单个项目更新时，将始终改变。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="d2ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以尝试几个解决方案:</p><ul class=""><li id="aafb" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">改为将<code class="fe mj mk ml mm b">handleSave</code>的所有依赖项作为参数传递。在这种情况下，<code class="fe mj mk ml mm b">Item</code>组件也需要接收所有这些依赖项作为道具。</li><li id="85fa" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将整个项目对象传递给<code class="fe mj mk ml mm b">Item</code>组件。这将使<code class="fe mj mk ml mm b">Item</code>中的道具等式检查更加复杂，也更容易出错。</li><li id="6333" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">使用<code class="fe mj mk ml mm b">useRef()</code>钩子，每次改变<code class="fe mj mk ml mm b">items</code>时，将其写入ref，并在<code class="fe mj mk ml mm b">handleSave</code>函数内从ref读取<code class="fe mj mk ml mm b">items</code>。那么<code class="fe mj mk ml mm b">items</code>就不再是<code class="fe mj mk ml mm b">handleSave</code>的附属品了。</li><li id="1677" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将变量<code class="fe mj mk ml mm b">idToSave</code>保持在状态。在保存时设置<code class="fe mj mk ml mm b">idToSave</code>。然后用<code class="fe mj mk ml mm b">useEffect(() =&gt; { /* save */ }, [idToSave])</code>“反应式”触发保存功能。</li></ul><p id="09ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，我主张有一个更好的解决方案。🎉</p><h1 id="b5b0" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">首先，项目组件</h1><p id="97d8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们的<code class="fe mj mk ml mm b">Item</code>组件非常简单。它有一个保存和编辑状态。最需要注意的是<a class="ae mn" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">的反应。备忘录</a>部分。这是一个高阶组件，只有当其中一个道具改变时才会重新渲染。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="0138" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">诀窍是，项目包装</h1><p id="a4f3" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">通过使用一个<code class="fe mj mk ml mm b">ItemWrapper</code>组件，我们可以记住两个事件处理程序。结果是一个<code class="fe mj mk ml mm b">Item</code>组件，仅在单个<code class="fe mj mk ml mm b">item</code>改变时才重新呈现。</p><p id="a523" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它向树中添加了一个额外的组件，但是随着结构的增长而提供值。这也反映了我们的情况:每个条目都有一个保存功能，需要整个<code class="fe mj mk ml mm b">item</code>对象，但是<code class="fe mj mk ml mm b">Item</code>组件本身不需要。因此，您可能会将ItemWrapper视为save函数的提供者。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7a94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而<code class="fe mj mk ml mm b">ItemList</code>将变成:</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="a09d" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">还有一件事…</h1><p id="f9bc" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在这个例子中，我们将<code class="fe mj mk ml mm b">setItems</code>传递给<code class="fe mj mk ml mm b">ItemWrapper</code>，有更好的解决方案。您可以将<code class="fe mj mk ml mm b">handleChange</code>和<code class="fe mj mk ml mm b">handleSave</code>向上移动一步，但是我认为一个简单的<code class="fe mj mk ml mm b">reducer</code>会使这个例子更完整。</p><p id="bbbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，对于这个“Hello World”示例来说，所有这些可能感觉过于复杂，但是在更复杂的真实世界应用程序中，这种结构对我来说最有意义。</p><p id="aa5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的例子可以在下面找到，或者在CodeSandbox 的<a class="ae mn" href="https://codesandbox.io/s/billowing-monad-g7r4p?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">这里。</a></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mc md l"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="c626" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mv">原载于</em>【https://www.arthurvisser.com】<em class="mv"/><em class="mv">。</em></p></div></div>    
</body>
</html>