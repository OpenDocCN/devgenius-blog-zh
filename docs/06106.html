<html>
<head>
<title>Streamlit Tricks — Application Reruns on Every Widget Click? Here's What-To-Do</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化技巧——每次点击小工具时应用程序都会重新运行？下面是要做的事情</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/streamlit-python-tips-how-to-avoid-your-app-from-rerunning-on-every-widget-click-cae99c5189eb?source=collection_archive---------0-----------------------#2021-12-14">https://blog.devgenius.io/streamlit-python-tips-how-to-avoid-your-app-from-rerunning-on-every-widget-click-cae99c5189eb?source=collection_archive---------0-----------------------#2021-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cd57" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果您一直在使用 Streamlit 构建您的数据科学或机器学习 web 应用程序，您可能已经意识到，每当通过应用程序的小部件调用任何交互式更改时，Streamlit web 应用程序都会从 python 脚本的顶部到底部重新运行。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/c9010a8361fd862c5c519e581494f50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*HTcx6sxeJO7rLpZ7ka6vHw.png"/></div></figure><p id="a2ca" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在本文中，我将尝试通过代码片段和用例来强调那些可能的解决方法，这肯定会有助于克服 Streamlit web 应用程序的这种内在行为。</p><p id="8f65" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">👨🏾‍💻GitHub  ⭐️|🐦推特📹<a class="ae lg" href="https://www.youtube.com/@Avra_b" rel="noopener ugc nofollow" target="_blank">YouTube</a>|☕️<a class="ae lg" href="https://www.buymeacoffee.com/AvraCodes" rel="noopener ugc nofollow" target="_blank">buymeacoffee</a>|<a class="ae lg" href="https://ko-fi.com/avrabyt" rel="noopener ugc nofollow" target="_blank">ko-fi💜</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="7e99" class="lo lp in bd lq lr ls dn lt lu lv dp lw kt lx ly lz kx ma mb mc lb md me mf mg bi translated">任何 Streamlit Web 应用程序的默认行为(线性流)</h2><p id="6a01" class="pw-post-body-paragraph kk kl in km b kn mh jo kp kq mi jr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">让我们编写一个非常简单的 Streamlit 应用程序，绘制您的水果列表🍌 🍎🥭和演示了一个默认的线性流程⏬任何 Streamlit Web 应用程序的行为。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="07bb" class="lo lp in mn b gy mr ms l mt mu"># ---- Modules ------- <br/>import streamlit as st<br/>import pandas as pd<br/>import plotly.express as px</span><span id="ec97" class="lo lp in mn b gy mv ms l mt mu">st.header("Fruits List")</span><span id="38ca" class="lo lp in mn b gy mv ms l mt mu"># ---- Creating Dictionary ----<br/>_dic = { 'Name': ['Mango', 'Apple', 'Banana'],<br/>         'Quantity': [45, 38, 90]}</span><span id="1d0b" class="lo lp in mn b gy mv ms l mt mu">load = st.button('Load Data')</span><span id="f216" class="lo lp in mn b gy mv ms l mt mu">if load:<br/>   _df = pd.DataFrame(_dic)<br/>    st.write(_df)<br/>   <br/>   # ---- Plot types -------<br/>   opt = st.radio('Plot type :',['Bar', 'Pie'])</span><span id="d171" class="lo lp in mn b gy mv ms l mt mu">   if opt == 'Bar':<br/>      fig = px.bar(_df, x= 'Name',<br/>                   y = 'Quantity',title ='Bar Chart')<br/>      st.plotly_chart(fig)<br/>   <br/>   else:     <br/>      fig = px.pie(_df,names = 'Name',<br/>                   values = 'Quantity',title ='Pie Chart')<br/>      st.plotly_chart(fig)</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/dc31598d2a719e403e0e5c904e8285a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*p4IAXz04uXK0eiJpfqx8_g.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">这个简短的 GIF 显示了 Web 应用程序的非活动状态。按钮部件不允许应用程序进一步运行。</figcaption></figure><p id="217e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果我们观察上述 web 应用程序的行为，一旦其中一个单选按钮被触发，即这里的<code class="fe nf ng nh mn b">"Pie"</code>单选按钮，我们就看不到预期的结果，即我们的饼状图。这是因为当脚本重新运行时，<code class="fe nf ng nh mn b">"Load Data"</code>按钮处于<strong class="km io">非活动状态</strong> <strong class="km io">状态</strong>🔄由于单选按钮触发器。</p><p id="6068" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如何解决这个问题，可能的解决方法是什么？</p><h2 id="564c" class="lo lp in bd lq lr ls dn lt lu lv dp lw kt lx ly lz kx ma mb mc lb md me mf mg bi translated"><strong class="ak">使用 Streamlit 复选框小工具☑️ </strong></h2><p id="c7d8" class="pw-post-body-paragraph kk kl in km b kn mh jo kp kq mi jr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">一个简单的快速修复(<em class="ni">从用户界面的角度来看并不理想！</em>)将会是，使用<code class="fe nf ng nh mn b">st.checkbox</code>语法把你的<code class="fe nf ng nh mn b">"Load Data"</code>按钮部件换成一个复选框部件。这启用了应用程序的后续脚本的<strong class="km io">激活状态</strong>。这是什么意思？让我来演示一下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/2db6faff928da6e43296cb04b53e71c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JH0f6_FY-MDioUWWNjU0ng.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">这个简短的 GIF 显示了 Web 应用程序的活动状态。该复选框在每次重新运行时保持活动状态。</figcaption></figure><h2 id="01aa" class="lo lp in bd lq lr ls dn lt lu lv dp lw kt lx ly lz kx ma mb mc lb md me mf mg bi translated">使用 SessionState 控制 Streamlit 按钮⏹部件</h2><p id="7c62" class="pw-post-body-paragraph kk kl in km b kn mh jo kp kq mi jr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">另一个解决方法是将 button 小部件与 SessionState 结合起来，<code class="fe nf ng nh mn b">st.session_state</code>。为了控制按钮<code class="fe nf ng nh mn b">"Load Data"</code>的状态，我们将使用 SessionState，<code class="fe nf ng nh mn b">st.session_state</code>。这将保持按钮的<strong class="km io">活动状态</strong>，尽管单选按钮选项的变化会触发。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/c2ddb13003375a51b1b80005af8b21b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dmtFZ0D-Z11e39oieAcYaA.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">这个简短的 GIF 显示了 Web 应用程序的活动状态。这次的按钮部件允许应用程序进一步运行。怎么会？(<em class="nj">代码如下！</em>)</figcaption></figure><p id="ee29" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对代码的变化很好奇？让我们调查一下，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nk"><img src="../Images/f2dfcb88a99f7fa1a07db1d147890abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oV7BR5kK5r9v04OixxloWw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">我们的代码与最初的非常相似，除了<code class="fe nf ng nh mn b">st.session_state</code>的使用</figcaption></figure><p id="4c1b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">此外，我们不要忘记初始化，<code class="fe nf ng nh mn b">st.session_state</code>。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="ceb8" class="lo lp in mn b gy mr ms l mt mu"># --- Initialising SessionState ---<br/>if "load_state" not in st.session_state:<br/>     st.session_state.load_state = False<br/>...<br/>...</span></pre><h2 id="d9b0" class="lo lp in bd lq lr ls dn lt lu lv dp lw kt lx ly lz kx ma mb mc lb md me mf mg bi translated"><strong class="ak">在函数中包装你的代码</strong></h2><p id="c170" class="pw-post-body-paragraph kk kl in km b kn mh jo kp kq mi jr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">有时，您不希望计算部分在每次小部件更改时都重新运行，对吗？将代码中的计算部分封装在一个函数中，同时使用<code class="fe nf ng nh mn b">st.experimental_memo</code>或<code class="fe nf ng nh mn b">st.cache</code>语法，就可以达到这个目的。也请参考官方<a class="ae lg" href="https://docs.streamlit.io" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="c9c3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们操作代码，并将其封装在一个函数中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nl"><img src="../Images/e02dce9aa68e45d7262575b7b510a54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AtrTeCmukaVtOiSg-BbPA.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/2b431a2cef11fc47116628f9049bd82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fwDxX_8AFQDk67O76cZ1vQ.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">第一次运行应用程序时，计算部分将被执行(因此，我们会看到 info 消息！).然而，随着进一步的重新运行，计算部分将被跳过，从而加速应用程序的运行。</figcaption></figure><p id="aa1b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，上述几个变通办法，肯定会有助于调整 Streamlit 的线性工作流程，并有助于根据需要维护 web 应用程序的期望状态。</p><p id="d487" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是我与这篇文章相关的视频-</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="ceda" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="ni">嘿！我是 Avra，我喜欢编写代码并与大家分享。我做了几个与 Streamlit 相关的</em> <a class="ae lg" href="https://youtube.com/playlist?list=PLqQrRCH56DH8JSoGC3hsciV-dQhgFGS1K" rel="noopener ugc nofollow" target="_blank"> <em class="ni">视频</em> </a> <em class="ni">，可能你也会感兴趣。请检查它们，并随时分享您的反馈！</em></p><p id="7d19" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae lg" href="https://patreon.com/user?u=82100262&amp;utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=creatorshare_creator&amp;utm_content=join_link" rel="noopener ugc nofollow" target="_blank"> <em class="ni">也考虑成为我的 Patreon 会员？—您可以提前获得独家内容、代码或视频，一对一的 web 应用开发/相关讨论，与我就特定视频进行实时聊天，以及其他额外待遇。(仅供参考:基本级比 ChatGPT/月便宜 50%,这是人工智能无法提供的好处😉)</em> </a></p><p id="c448" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">👨🏾‍💻GitHub  ⭐️|🐦<a class="ae lg" href="https://twitter.com/avra_b" rel="noopener ugc nofollow" target="_blank">推特</a> |📹<a class="ae lg" href="https://www.youtube.com/@Avra_b" rel="noopener ugc nofollow" target="_blank">YouTube</a>|☕️<a class="ae lg" href="https://www.buymeacoffee.com/AvraCodes" rel="noopener ugc nofollow" target="_blank">buymeacoffee</a>|<a class="ae lg" href="https://ko-fi.com/avrabyt" rel="noopener ugc nofollow" target="_blank">ko-fi💜</a></p><p id="646d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="ni">这是我制作的另一个 Streamlit-Python 技巧视频，</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>