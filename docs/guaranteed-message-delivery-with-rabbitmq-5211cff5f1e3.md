# 用 RabbitMQ 保证消息传递

> 原文：<https://blog.devgenius.io/guaranteed-message-delivery-with-rabbitmq-5211cff5f1e3?source=collection_archive---------8----------------------->

![](img/d9ff04c103a4dff3f32fa661a04248d7.png)

micha Parzuchowski 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

RabbitMQ 是一个成熟稳定的消息服务器，它使用 AMQP 协议在生产者和消费者之间交换消息。

它可以服务于多种用例，包括:瞬态通道、扇出消息、联合等。

在这里，我将解释我最常见的用例的一些(可能是全部)配置和参数:保证工人作业队列的消息传递。

这意味着，如果消息被 RabbitMQ 接受，它将被使用，并且只有在确认后才从队列中删除。

这将包括交换、队列、消费者和生产者设置。也不会涉及 RabbitMQ 服务器的可靠性和集群。我也不关心订购，因为我大部分时间使用多个消费者。

# 快速 RabbitMQ 概述

要使用 rabbitmq，您需要打开一个到服务器的连接。在这个连接上，您可以打开一个或多个通道，这些通道是您用来发布和使用消息的。

建议您在一个渠道发布，在另一个渠道消费。此外，在大多数实现中，通道不是线程安全的，所以每个线程需要一个通道，或者确保同步其访问。

要“在 rabbitmq 上发布消息”,你需要将消息发布到交易所。交换接收消息并将其路由到队列。

要从 rabbitmq 获取消息，您需要从队列中获取。要删除消息，您可以确认或拒绝它们。您也可以 nack 和 requeue，将消息保留在队列中。

声明是创建交换和队列的行为。绑定是将交换连接到队列。

# 不丢失您的交换和队列

首先，我们需要确保我们的交换和队列能够经受住重启和断开连接，为此，我们要使我们的交换和队列“持久”。

对于 exchange，这意味着“持久=真”、“自动删除=假”和“内部=假”在声明时最好设置为参数。

对于 queue，这意味着在声明 queue 时，需要将“durable=true”、“auto-delete=false”和“exclusive=false”设置为参数。但是在下面的几个段落中有更多关于队列的论点。

这意味着交换和队列将继续存在，即使不再有客户端存在，并且在服务器重启的情况下。声明的交换和队列是持久的。

您还需要将交换绑定到队列，以使消息可访问。

# 不丢失被拒绝的邮件

现在，当消费消息失败时，它们会被拒绝。如果您想捕获那些失败的消息，您可以设置一个死信队列。

死信队列，伴随着死信交换，是一种从队列中捕获被拒绝的消息的方法。

您将它们设置为常规交换，通常以“.”为后缀。dlx”和以”结尾的队列。dlq”并绑定它们。还要记得让两者都耐用。

在声明队列时，将“x-dead-letter-exchange = exchange-name . dlx”和“x-dead-letter-routing-key=”设置为参数。

**交换和排队申报汇总**

你声明，按顺序:

*   持久的交换
*   失败消息的持久交换(dlx)
*   失败消息的持久队列(dlq)
*   将 dlx 绑定到 dlq
*   具有死信参数的持久队列
*   将第一个交换绑定到最后一个队列

当然，这是在单个交换到单个队列的情况下，如果您想要路由到多个队列，您需要重复 dlq 和队列步骤。

# 安全使用邮件

在 AMPQ，使用消息的方式实际上不止一种，但是最常用和推荐的方式是使用 consume 方法。

您应该将“自动确认”设置为 false，并确保仅在消息可以删除时确认消息。

如果你不能处理一个消息，你应该拒绝它，所以他们去 DLQ。

如果您未能确认或拒绝消息，它最终会回到队列中。

这将确保消息仅在您处理完之后才离开队列，并在失败时进入 dlq。

一旦你在 DLQ 消费并确认了一条消息，这条消息就会消失。您还可以将来自 DLQ 的消息推回到原始队列中进行重新处理。

# 安全发布

拥有持久的队列并不意味着持久的消息。消息仍将保留在内存中，并在重新启动或消息不可路由时丢失。

为了确保消息将被路由到一个队列，您将它设置为“mandatory=true”。这意味着，只有当消息在队列中结束时，publish 才会返回成功，如果消息不可路由，您会收到错误消息(比如在交换中没有绑定，或者路由关键字规则不正确)。

要确保消息进入磁盘，您需要设置“persistent=true”。这将确保 rabbitmq 将它写入队列中的磁盘。

最后。您应该等待消息被写入的确认。

还有交易等其他方法，但更快且推荐的方法是使用等待确认。

您在一个打开的通道上调用 confirm 或 wait_for_confirms 来等待 rabbitmq 确认在这个通道上发送的消息被写入了它们应该被写入的位置。

您可以等待每条消息，或者发布一批消息并等待一次。等待是每个频道。

使用“懒惰”消息来控制内存使用，使 rabbitmq 尽可能快地写入磁盘也是有用的。除非你使用仲裁队列，但这是另一个职位。

# 结论

这些都是我所知道的确保你的 rabbitmq 信息安全的措施。除了集群，但那是另一个故事。

重要的是要注意，我们增加的每一个坚持、每一个保证都会影响性能。直接的瞬时消息可能是你能走得最快的。也就是说，这仍然是一个非常快速和高效的消息服务器。

如果您密切关注内存消耗、磁盘空间和服务器的打开连接数，即使没有以上所有措施，RabbitMQ 也很可能不会让您失望。

我错过了什么吗？还有其他建议吗？