<html>
<head>
<title>Benchmarking Go Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基准测试 Go 代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/benchmarking-go-code-7c780e29a7f?source=collection_archive---------4-----------------------#2022-06-27">https://blog.devgenius.io/benchmarking-go-code-7c780e29a7f?source=collection_archive---------4-----------------------#2022-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0002" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经用 Go 编程一段时间了，你可能真的很喜欢它附带的工具。语言本身被有用的工具挤得满满的，比如<code class="fe ki kj kk kl b">go test</code>、<code class="fe ki kj kk kl b">go fmt</code>、<code class="fe ki kj kk kl b">go build</code>等等。我们之前已经检查过测试了。今天，我们将看看如何对我们的 Go 代码进行基准测试。</p><h1 id="e459" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么应该运行基准测试</h1><p id="105c" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">想知道你的代码运行有多快多高效吗？基准测试是检查代码性能的最直接的方法。Go 提供的基准测试工具主要关注以下几个方面:</p><ul class=""><li id="ccb7" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">每次操作花费的时间</li><li id="5faa" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">每次操作分配的内存</li></ul><p id="f0c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基准测试不是必须的，但是它们是检查瓶颈的好方法。此外，运行数字很有趣。如果你是一个内容创建者，你可能会每天查看你的 feed，记录你最近的帖子获得了多少新的浏览量。基准给了我类似的喜悦感。</p><h1 id="db57" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">插入排序与合并排序</h1><p id="6ca9" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在本教程中，我们将使用以下代码。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="3514" class="ml kn in kl b gy mm mn l mo mp">package main</span><span id="24d6" class="ml kn in kl b gy mq mn l mo mp">import (<br/>    "fmt"<br/>)</span><span id="ec76" class="ml kn in kl b gy mq mn l mo mp">func main() {<br/>    list := []int{3, 4, 1, 5, 2}<br/>    iList := insertionSort(list)<br/>    mList := mergeSort(list)<br/>    fmt.Println(iList, mList)<br/>}</span><span id="78ae" class="ml kn in kl b gy mq mn l mo mp">func insertionSort(list []int) []int {<br/>    for i, num := range list {<br/>        j := i - 1</span><span id="51d5" class="ml kn in kl b gy mq mn l mo mp">        for j &gt;= 0 &amp;&amp; num &lt; list[j] {<br/>            list[j+1] = list[j]<br/>            j -= 1<br/>        }<br/>        list[j+1] = num<br/>    }</span><span id="5a71" class="ml kn in kl b gy mq mn l mo mp">    return list<br/>}</span><span id="5e84" class="ml kn in kl b gy mq mn l mo mp">func mergeSort(list []int) []int {<br/>    if len(list) &gt; 1 {<br/>        mid := len(list) / 2<br/>        left := list[:mid]<br/>        right := list[mid:]</span><span id="f0c9" class="ml kn in kl b gy mq mn l mo mp">        mergeSort(left)<br/>        mergeSort(right)</span><span id="aa19" class="ml kn in kl b gy mq mn l mo mp">        i, j, k := 0, 0, 0</span><span id="b246" class="ml kn in kl b gy mq mn l mo mp">        for i &lt; len(left) &amp;&amp; j &lt; len(right) {<br/>            if left[i] &lt; right[j] {<br/>                list[k] = left[i]<br/>                i++<br/>            } else {<br/>                list[k] = right[j]<br/>                j++<br/>            }<br/>            k++<br/>        }</span><span id="219a" class="ml kn in kl b gy mq mn l mo mp">        for i &lt; len(left) {<br/>            list[k] = left[i]<br/>            i++<br/>            k++<br/>        }</span><span id="74cb" class="ml kn in kl b gy mq mn l mo mp">        for j &lt; len(right) {<br/>            list[k] = right[j]<br/>            j++<br/>            k++<br/>        }<br/>    }</span><span id="d595" class="ml kn in kl b gy mq mn l mo mp">    return list<br/>}</span></pre><p id="6c44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上是两种流行排序算法的实现:插入排序和合并排序。</p><p id="947e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插入排序是一种简单的排序算法，其工作原理如下:</p><ul class=""><li id="c7a8" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">从头开始遍历列表。</li><li id="31ea" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">如果当前数字小于前一个数字，将它移到前面，直到它变得大于前一个数字。</li></ul><p id="e012" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">合并排序采用不同的方法:</p><ul class=""><li id="ed50" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">把列表分成两半，这样你最后得到一个左列表和一个右列表。在左列表和右列表上递归地这样做。</li><li id="6172" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">当你不能再分的时候，把左列表和右列表按升序合并。</li><li id="dd82" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">合并列表，直到最后得到排序后的原始列表。</li></ul><p id="4748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些图表将帮助您更好地理解这两种类型。</p><ul class=""><li id="c77d" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">插入排序:</li></ul><figure class="md me mf mg gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9754cd8c11137257bfa64bfd58e4a650.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/0*3f1ucEySSycXPvJ3.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae mz" href="https://media.geeksforgeeks.org/wp-content/uploads/insertion_sort-recursion.png" rel="noopener ugc nofollow" target="_blank">https://media . geeks forgeeks . org/WP-content/uploads/insertion _ sort-recursion . png</a></figcaption></figure><ul class=""><li id="f16a" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">合并排序:</li></ul><figure class="md me mf mg gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/2f9fcfd8e14f040e910c5e139346b7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*voPe5NTAWFDbtTPy.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Merge_sort#/media/File:Merge_sort_algorithm_diagram.svg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Merge _ sort #/media/File:Merge _ sort _ algorithm _ diagram . SVG</a></figcaption></figure><h1 id="11fd" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">对代码进行基准测试</h1><p id="83d6" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">让我们编写我们的基准代码。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="0d61" class="ml kn in kl b gy mm mn l mo mp">package main</span><span id="1e74" class="ml kn in kl b gy mq mn l mo mp">import (<br/>    "fmt"<br/>    "math/rand"<br/>    "testing"<br/>)</span><span id="ac36" class="ml kn in kl b gy mq mn l mo mp">func BenchmarkInsertionSort(b *testing.B) {<br/>    inputSize := []int{10, 100, 1000, 10000, 100000}<br/>    for _, size := range inputSize {<br/>        b.Run(fmt.Sprintf("input_size_%d", size), func(b *testing.B) {<br/>            testList := make([]int, size)<br/>            for i := 0; i &lt; size; i++ {<br/>                testList[i] = rand.Intn(size)<br/>            }<br/>            b.ResetTimer()</span><span id="1285" class="ml kn in kl b gy mq mn l mo mp">            for i := 0; i &lt; b.N; i++ {<br/>                insertionSort(testList)<br/>            }<br/>        })<br/>    }<br/>}</span><span id="eba3" class="ml kn in kl b gy mq mn l mo mp">func BenchmarkMergeSort(b *testing.B) {<br/>    inputSize := []int{10, 100, 1000, 10000, 100000}<br/>    for _, size := range inputSize {<br/>        b.Run(fmt.Sprintf("input_size_%d", size), func(b *testing.B) {<br/>            testList := make([]int, size)<br/>            for i := 0; i &lt; size; i++ {<br/>                testList[i] = rand.Intn(size)<br/>            }<br/>            b.ResetTimer()</span><span id="16f3" class="ml kn in kl b gy mq mn l mo mp">            for i := 0; i &lt; b.N; i++ {<br/>                mergeSort(testList)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="d180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有基准代码都以<code class="fe ki kj kk kl b">BenchnmarkXxx</code>的格式命名，其中<code class="fe ki kj kk kl b">Xxx</code>是被基准测试的函数的名称，以大写字母开头。</p><p id="06cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用不同的输入大小来测试这两种排序算法。这些在<code class="fe ki kj kk kl b">inputSize</code>中定义。对于每个输入大小，我们启动一个<code class="fe ki kj kk kl b">b.Run</code>来触发单个基准。<code class="fe ki kj kk kl b">b.Run</code>接受两个参数:第一个是基准的名称，第二个是要运行的实际基准函数。<code class="fe ki kj kk kl b">fmt.Sprintf("input_size_%d", size)</code>是动态命名我们的基准的好方法，因为它会这样命名我们的基准:<code class="fe ki kj kk kl b">input_size_10</code>、<code class="fe ki kj kk kl b">input_size_100</code>等等。</p><p id="28a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以为每个输入大小创建一个基准函数，但是代码会变得不必要的长，所以使用<code class="fe ki kj kk kl b">b.Run</code>是惯用的方法。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="206b" class="ml kn in kl b gy mm mn l mo mp">testList := make([]int, size)<br/>for i := 0; i &lt; size; i++ {<br/>    testList[i] = rand.Intn(size)<br/>}<br/>b.ResetTimer()</span></pre><p id="de13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这部分填充了我们的测试数据。我们创建一个大小为<code class="fe ki kj kk kl b">size</code>的切片，并用随机整数填充它。我们最后调用<code class="fe ki kj kk kl b">b.ResetTimer</code>来重置我们的基准计时器。<code class="fe ki kj kk kl b">b.Run</code>在启动定时器时启动定时器，因此默认情况下，它将包括初始化数据所用的时间。这是一种误导，我们在运行基准测试之前重置了计时器。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="9019" class="ml kn in kl b gy mm mn l mo mp">for i := 0; i &lt; b.N; i++ {<br/>    mergeSort(testList)<br/>}</span></pre><p id="071f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是运行我们的<code class="fe ki kj kk kl b">mergeSort</code>函数的循环。循环运行<code class="fe ki kj kk kl b">b.N</code>时间，这是为产生稳定可靠的结果而计算的任意数字。这就像多次运行一个实验室，寻找不同数据点的平均数据，使结果更加精确。</p><p id="21f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们运行基准测试。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="dfe4" class="ml kn in kl b gy mm mn l mo mp">$ go test -bench=. -benchmem<br/>goos: linux<br/>goarch: amd64<br/>pkg: example.com/benchmarking<br/>cpu: Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz<br/>BenchmarkInsertionSort/input_size_10-8          127217533                9.369 ns/op           0 B/op          0 allocs/op<br/>BenchmarkInsertionSort/input_size_100-8         13812344                89.95 ns/op            0 B/op          0 allocs/op<br/>BenchmarkInsertionSort/input_size_1000-8         1508656               743.6 ns/op             0 B/op          0 allocs/op<br/>BenchmarkInsertionSort/input_size_10000-8         158587              7365 ns/op               0 B/op          0 allocs/op<br/>BenchmarkInsertionSort/input_size_100000-8             1        1296239500 ns/op               0 B/op          0 allocs/op<br/>BenchmarkMergeSort/input_size_10-8              14895802                76.45 ns/op            0 B/op          0 allocs/op<br/>BenchmarkMergeSort/input_size_100-8              1000000              1045 ns/op               0 B/op          0 allocs/op<br/>BenchmarkMergeSort/input_size_1000-8               89268             14178 ns/op               0 B/op          0 allocs/op<br/>BenchmarkMergeSort/input_size_10000-8               7522            156233 ns/op               0 B/op          0 allocs/op<br/>BenchmarkMergeSort/input_size_100000-8               678           1743882 ns/op               0 B/op          0 allocs/op<br/>PASS<br/>ok      example.com/benchmarking        15.215s</span></pre><p id="0345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们像运行测试一样运行<code class="fe ki kj kk kl b">go test</code>。然后我们传递这两个标志:</p><ul class=""><li id="c00f" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><code class="fe ki kj kk kl b">-bench</code>指定运行哪个基准函数。要运行所有程序，请通过<code class="fe ki kj kk kl b">-bench=.</code>。</li><li id="d07e" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><code class="fe ki kj kk kl b">-benchmem</code>显示每个操作分配了多少内存，以及发生了多少次分配。</li></ul><p id="2f73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在左侧，您可以看到基准函数的名称。末尾的<code class="fe ki kj kk kl b">-8</code>表示我们正在使用 8 个 CPU 内核。</p><p id="f0e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">旁边是一个巨大的数字，随着输入量的增加而减少。这些是你的<code class="fe ki kj kk kl b">b.N</code>，或者说基准测试运行你的函数的次数。我们称之为操作次数。</p><p id="15bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在它的右边，你可以看到每个操作的平均时间。这意味着对于函数的每次运行，大约需要 x 纳秒的时间。</p><p id="fccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后两列显示了每个操作使用的平均内存字节数，以及每个操作的分配数。</p><p id="0be3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到，对于 10，000 及以下的较小输入大小，插入排序更有效。然而，从这一点开始，合并排序更加有效。</p><p id="7a1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两者都是内存高效的，因为它们都不需要太多的内存分配。在围棋中，走片不耗费内存。更多关于指针 golang 中的片不分配任何内存？—堆栈溢出。</p><h1 id="6e48" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="c666" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">基准测试是检查代码是否高效运行的有用工具。这给我们留下了一个问题:这意味着如果我们从一开始就编写了一个优化良好的代码，我们就不需要对代码进行基准测试，对吗？在一个完美的世界里，这是真的。然而，和无数其他人一样，我建议不要这么做。</p><blockquote class="nf ng nh"><p id="7b3d" class="jk jl ni jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated"><em class="in">过早优化是万恶之源。</em></p><p id="f676" class="jk jl ni jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated"><em class="in"> —传奇计算机科学家、数学家唐纳德·克努特</em></p></blockquote><p id="ae5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">专注于编写可读的工作代码。如果开始遇到瓶颈，就运行基准测试。在许多情况下，可维护性比性能更重要，尤其是在现代计算机如此快速的情况下。</p><p id="a347" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读！你也可以在<a class="ae mz" href="https://dev.to/jpoly1219/benchmarking-go-code-1k23" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae mz" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这个帖子。</p></div></div>    
</body>
</html>