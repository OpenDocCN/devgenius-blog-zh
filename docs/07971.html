<html>
<head>
<title>5 Bad Testing Practices Seasoned Java Developers Don’t Like to See</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的 Java 开发人员不喜欢看到的 5 种不良测试实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-bad-testing-practices-seasoned-java-developers-dont-like-to-see-f430d15406fb?source=collection_archive---------5-----------------------#2022-05-07">https://blog.devgenius.io/5-bad-testing-practices-seasoned-java-developers-dont-like-to-see-f430d15406fb?source=collection_archive---------5-----------------------#2022-05-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="44de" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">下面是你应该知道的创建简洁和编写良好的测试的方法</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/213d7fc01d98af5346b621685580096b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uOw48Ol6scW5JDl4.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由来自<a class="ae ks" href="https://www.pexels.com/photo/woman-in-orange-long-sleeve-shirt-standing-beside-woman-in-black-long-sleeve-shirt-5439487/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae ks" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>拍摄</figcaption></figure><p id="50b7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">你每天都会看到糟糕的考试实践。</em> </strong></p><p id="1d26" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">开发者追逐虚荣的指标。代码覆盖率之类的对测试没有任何好处。你可以在这里阅读在这个故事中什么是更好的衡量标准。</em></strong></p><p id="f87a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">测试发现 bug。好的测试能及早发现 bug，而坏的测试会让它们飞来飞去。这就是为什么创建好的测试很重要。</em></strong></p><p id="0ea1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">让我们看看有哪些不好的测试实践，以及如何修复它们。</em></p><h1 id="632a" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">1.你不用存根</h1><p id="6fdf" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">你只在测试中使用模拟。</p><p id="8b83" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">虽然这些服务的目的很好，但要测试行为，它们并不是万能的。</p><p id="b5ec" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">假设您需要测试一个只用于生产的服务。</p><p id="9fa2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以你想测试 S3 的上传流程。您不想为您的单元测试 ping 实际的服务。但是你也想测试失败和成功的流程。</p><p id="4097" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您需要模拟客户端的每个方法。此外，您需要为每个模拟方法添加一个示例响应。</p><p id="41ee" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你会在测试中得到很多这样的陈述。这段代码是一个例子，不是一个实际的测试。</p><pre class="kh ki kj kk gu mn mo mp mq aw mr bi"><span id="3b52" class="ms lr ir mo b gz mt mu l mv mw">when(s3UploadClient.upload(any())).thenReturn(s3response);<br/>when(s3UploadClient.upload(new Failure())).thenThrow(new NotStoredException())</span></pre><p id="b973" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">在你模拟出他们之后，你需要测试他们的行为。而不是文件是否被实际上传。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="5a29" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">本期用存根修复。</em> </strong></p><p id="c32b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">存根可以根据输入提供想要的答案。</em>T25】</strong></p><p id="6c20" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有了存根，你可以很容易地改变、失败或抛出异常。你将永远依赖于客户端的真实界面。这样更容易维护<a class="ae ks" href="https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html" rel="noopener ugc nofollow" target="_blank">和<em class="lp">写在最后</em>和</a>。</p><p id="1d89" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">S3 上传流仅适用于更高的环境。例如，您的机器没有上传权限。理由很充分。所以树桩来帮忙。<strong class="kv is"> <em class="lp">存根可以不去外部服务测试上传流量。</em> </strong></p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="dd78" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">存根服务创建全面的测试。T41】</p><p id="ca55" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">模拟在测试库中有自己的位置，但是存根在上面一个级别。正如鲍勃<a class="ae ks" href="https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp">所说</em> </a>模仿是一种存根。所以为了更多的控制，使用存根，而不是模仿。</p><h1 id="4aa2" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">2.你有古怪的测试</h1><p id="b871" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">你运行了 20 次测试，但是有两次失败了。<em class="lp">这是我对古怪测试的粗略定义。</em></p><p id="a196" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">当然，您可以重试，直到成功。但这掩盖了问题，没有解决原因。</p><p id="4619" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">原因可能是环境、副作用或遗漏清理。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="9d43" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以看到很多解决这个问题的方法。</p><ul class=""><li id="3bf3" class="ne nf ir kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">重试，直到薄片测试通过</li><li id="e81c" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">将测试标记为进行中的工作</li><li id="ef3b" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">删除测试(尽管不推荐)</li><li id="fddd" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">有指数级的后退</li><li id="9de8" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">运行几次，测试失败时调试；如果远程调试可以做到这一点</li></ul></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="4f10" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你会发现最有效的方法是使用假货。<em class="lp">例如，测试环境。</em></p><blockquote class="ns nt nu"><p id="b181" class="kt ku lp kv b kw kx js ky kz la jv lb nv ld le lf nw lh li lj nx ll lm ln lo ik bi translated">假对象实际上有工作的实现。假货走了一些捷径，使它们不适合生产。内存数据库中的一个<a class="ae ks" href="https://martinfowler.com/bliki/InMemoryTestDatabase.html" rel="noopener ugc nofollow" target="_blank">就是一个很好的例子。—梅萨罗什</a></p></blockquote><p id="2683" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你启动环境，测试它，清理它，然后关闭它。这种短暂环境的一个很好的例子是测试容器。</p><p id="0952" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">测试容器将独立运行你的测试。隔离有助于解决问题，但也消除了副作用。</em>T13】</strong></p><h1 id="75b4" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">3.你的测试应该是一个代码描述</h1><blockquote class="ns nt nu"><p id="f859" class="kt ku lp kv b kw kx js ky kz la jv lb nv ld le lf nw lh li lj nx ll lm ln lo ik bi translated">如果你的代码丢失了，你可以从测试中获取代码——我的一个前辈</p></blockquote><p id="b20c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">不要追逐虚荣的度量，比如代码覆盖率。</em> </strong></p><p id="dd12" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您可能会遇到对测试没有影响的情况。并利用漏洞进行测试以提高代码覆盖率。</p><p id="d11f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">用测试描述代码。</em> </strong></p><p id="304e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你上的每一堂课都必须有一个好的描述性测试。如此具有描述性，以至于您可以从测试中重新创建代码。这是我在测试中唯一喜欢看到的指标。</p><h1 id="e36a" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">4.您的测试没有响应变化</h1><p id="0798" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">当你改变被测代码时，测试仍然通过。这意味着变化对测试没有任何影响。</em>T25】</strong></p><p id="f4a6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">如果这发生在你的测试中，那意味着测试有漏洞。 路径没有覆盖好，或者根本没有覆盖。因为变化没有让你的测试失败，所以你的测试并不好。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="aad9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">为什么会这样？</em></p><p id="7876" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">大多数开发人员测试是为了满足虚荣心指标。</em> </strong>等代码覆盖率。代码覆盖率并不能保护你不被改变，因为它是可以被欺骗的。</p><p id="43a8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">代码覆盖<a class="ae ks" href="https://www.youtube.com/watch?v=BK-DzCCFOR0&amp;ab_channel=DATAMINER" rel="noopener ugc nofollow" target="_blank"> <em class="lp">可游戏化</em> </a>:</p><ul class=""><li id="27e4" class="ne nf ir kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">故意地</li><li id="5a48" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">偶然</li></ul><p id="c166" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Nicolas <a class="ae ks" href="https://blog.frankel.ch/introduction-to-mutation-testing/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">提议</em> </a> <a class="ae ks" href="http://pitest.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">使用这个库</em> </a>进行突变测试。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="ea23" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你今天能做些什么来纠正这种行为呢？</p><p id="f0ac" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">稍微改变一下代码，看看测试会发生什么。此外，检查遗漏的断言，并添加好的断言。</p><p id="062c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">遵循好的测试模式。例如，遵循<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-i-survived-the-zombie-apocalypse-19905db22043"> <em class="lp">僵尸</em> </a>模式:</p><ul class=""><li id="845d" class="ne nf ir kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">z-零</li><li id="d52c" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">一个</li><li id="d8cd" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">M —许多(或更复杂)</li><li id="a86d" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">B —边界行为</li><li id="b0d0" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">I —接口定义</li><li id="b0d7" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">e——锻炼特殊行为</li><li id="965e" class="ne nf ir kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">简单的场景，简单的解决方案</li></ul><h1 id="aaf5" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">5.你不用假货</h1><p id="6b92" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">在前一篇技巧文章中，我们提到了假货。<em class="lp">什么是假货？</em></p><blockquote class="ns nt nu"><p id="5d55" class="kt ku lp kv b kw kx js ky kz la jv lb nv ld le lf nw lh li lj nx ll lm ln lo ik bi translated">Fakes 是它们所模仿的接口的完全内存实现。— <a class="ae ks" href="https://nedbatchelder.com/blog/201206/tldw_stop_mocking_start_testing.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="72ec" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">例如，<a class="ae ks" href="https://github.com/mockito/mockito/wiki/Using-Spies-(and-Fakes)" rel="noopener ugc nofollow" target="_blank"> <em class="lp">测试</em> </a> <code class="fe ny nz oa mo b"><a class="ae ks" href="https://github.com/mockito/mockito/wiki/Using-Spies-(and-Fakes)" rel="noopener ugc nofollow" target="_blank"><em class="lp">HttpRequest</em></a></code>的几种方法。</p><p id="0704" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因为有一个保存属性的映射，所以测试可以获取不同的属性键。你需要嘲笑每一个人。这时候假货就开始发挥作用了。</p><p id="1664" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以伪造一些测试方法。剩下的就不要说了。这里有一个例子。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ob oc l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://github.com/mockito/mockito/wiki/Using-Spies-(and-Fakes)" rel="noopener ugc nofollow" target="_blank"> <em class="od">来源</em> </a></figcaption></figure><p id="ec79" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">假货大多用于集成测试，因为他们在使用商业行为。最好自己做，因为不需要像 Mockito 这样的额外框架。</em></strong></p><p id="0723" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面用 Mockito  实现一个<a class="ae ks" href="http://blog.tremblay.pro/2017/09/mocks.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp">。</em></a></p><pre class="kh ki kj kk gu mn mo mp mq aw mr bi"><span id="89f0" class="ms lr ir mo b gz mt mu l mv mw">when(authorizer.authorize(any(), any())).thenAnswer(invocationOnMock -&gt; "Bob".equals(invocationOnMock.getArgument(0)));</span></pre><p id="f146" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">那么存根和假货有什么区别呢？</em> <a class="ae ks" href="http://blog.tremblay.pro/2017/09/mocks.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp">存根会返回固定答案</em> </a>，而且总是同一个答案。</p><pre class="kh ki kj kk gu mn mo mp mq aw mr bi"><span id="d615" class="ms lr ir mo b gz mt mu l mv mw">when(mock.authorize(any(), any()).thenReturn(true)</span></pre></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="3c94" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">你知道哪些糟糕的测试实践？请在评论中告诉我。</em></p></div></div>    
</body>
</html>