# 使用 NestJS 和 TypeORM 像专业人员一样记录日志

> 原文：<https://blog.devgenius.io/logging-like-a-professional-with-nestjs-and-typeorm-dc935f71ef8b?source=collection_archive---------0----------------------->

![](img/4d6d18af08c15f18c2f69b2da0119cd1.png)

我是一个日志狂，在我的日常工作中，我是 10 个前端专业人员中的一个后端/DevOps 开发人员，我幸存下来的原因之一是因为我想在这里向您展示的电源日志和监控。

它允许我在新的 bug 出现时收到一封电子邮件，再花 5-10 分钟了解到底发生了什么，然后发布一个补丁来修复它。而这一切(几乎)都不用在代码中写日志。

我将在这篇文章中与你分享我为它创建的架构，我非常希望得到你的反馈。所以，请随意在下面写评论。

我希望看到每个 Rest-API 的日志，就像这样:

*   请求输入(方法、URL、正文、标题— IP、用户代理等)
*   每个数据库查询(我可以在工作台中粘贴和运行的 SQL 查询)和返回的结果数据。
*   每个外部 API 请求(方法、URL、头、主体)和响应(状态、主体)。
*   响应输出(状态、正文、标题)。

我想使用中间件来实现它——这样我在开发过程中几乎不用担心日志记录，并且我拥有我需要的一切，不会忘记任何东西。

当您的日志以这种方式构建时——如果发生了一些错误，您只需阅读它们，就可以理解 95%的请求过程中到底发生了什么，并且您还可以准确地模拟本地服务器或 DB workbench 中发生了什么(只需粘贴查询)。

现在，在我们有了要为之奋斗的正确目标之后，让我们进入实施部分。

# 步骤 1 —我的日志类

我希望每个 API 调用保存自己的日志，因此我的 logger 类有@ injective({ Scope:Scope。REQUEST })，这意味着 NestJS 将为每个 API 调用创建一个该类的实例，并且它可以访问请求对象。

我将该类的日志保存在数组中(每个日志的开头都有一个时间戳)，并在两种情况下将其发送到云——当响应成功完成时，或者当我的异常过滤器捕获到错误时。我发现这是一种比将每个日志分别发送到云中更有效的方式。

# 步骤 2 —我的日志云(带监控)

我个人使用“ [Google cloud logging](https://cloud.google.com/logging) ”来记录日志(Google 购买了“Stackdriver”工具，并将其纳入他们的云服务中)，它每月免费提供 50GB 的日志，第一个月每额外 GB 的费用为 0.5 美元，如果你想节省更多时间，每月每 GB 0.1 美元。

他们有令人难以置信的工具来搜索日志中的任何字符串，当发生某些情况时，如发现 500 或 501 错误、内存问题等，您可以将警报作为电子邮件或推送通知。

如果您的服务器流量很大，并且您想节省成本，那么您可以只在异常过滤器中发送日志，并且从所有其他成功的请求中，您可以构建一个逻辑来随机发送 100 个中的 1 个或其他类似的逻辑。

# 步骤 3 —错误报告

我还使用了“[谷歌错误报告](https://cloud.google.com/error-reporting)”工具。在代码中，您可以选择向该工具发送错误报告，并且第一次发生时您会收到一封电子邮件(每种错误类型只发送一次)。然后你有一个仪表板，你可以看到它发生了多少次，并挖掘每个日志。您可以将此错误标记为知识(安静模式)或已解决。如果您将它们标记为已解决—如果再次发生，您将收到一封新的电子邮件。

我还为每个请求日志和错误报告添加了一个惟一的 ID，这样我就可以在日志中搜索发生错误的确切请求。

# **第四步** —请求-响应拦截器

[嵌套拦截器](https://docs.nestjs.com/interceptors)与用于拦截请求和响应的[中间件](https://docs.nestjs.com/middleware)不同，您可以实现一个代码，该代码将在路由处理请求之前运行，之后在响应发送回调用者之前运行。这是获取我们需要的数据并记录下来的正确而简单的方法。

同样，您也可以构建自己的服务来发送外部 API 请求，并自动记录请求参数、响应状态和数据。当你需要像 Google geolocation 或任何其他 API 的时候，使用这个服务是非常有用的。

# **步骤 5 —日志类型问题**

现在我们开始讨论主要问题——自动记录 TypeORM 的查询结果。我花了将近 2 个月的时间，直到我成功地实现了这个解决方案，我将很快在这里向您展示。

你可以把你自己的记录器注入到实现“TypeOrmLogger”接口的 TypeORM 中，他们允许这样做。但是问题是注入我们需要在一个地方同步保存所有请求日志的**请求范围**——因为 TypeORM 模块是一个全局单例服务，并且您不能将它与请求范围结合。

当我试图注入一个请求范围为 TypeORM logger 的 logger 服务时——它允许我访问请求对象，但只能访问服务器得到的第一个请求对象…

# **第六步——解决思路**

我的灵感来自于我在 Nest 的拦截器部分读到的面向方面编程(AOP)技术，其思想是在每次调用之前(和之后)包装一个函数并运行一段代码。

节点服务器是同步工作的，这意味着总是只有一段代码在运行(而不是像 Java 或 Python server 这样的线程并行运行)，每次它需要操作系统为它运行一个命令(await)——比如从数据库中读取——JS 引擎就可以自由地服务于事件循环中等待它的其他任务。当响应从数据库返回时，它被签名到事件循环，然后代码将完成它当前的任务。

现在，我的任务是构建一个自定义拦截器，拦截所有使用 TypeORM 发送查询的函数，并在任何时候执行之前，将 TypeORM 的记录器替换为请求范围的相同记录器。

# **第 7 步—实施该解决方案:**

我构建了一个自定义装饰器，放在每个与 TypeORM 交互的服务之上，它有存储库和请求范围记录器的构造器参数。

代码有点复杂，但是 with 很好地完成了这项工作，如果你想的话，你可以简单地使用它和一个装饰器。

# 技术挑战

为了让“@ LogTypeOrmCycle”装饰器工作，我必须在类的构造函数中注入“LoggingService ”,尽管我没有在类内部使用它——只是在装饰器中。

你知道如何在装饰器中直接注入“LoggingService”而不注入到类中吗？

日志服务是基于请求范围的，如果您有任何想法，欢迎在这里添加注释。

# 思想

在 NestJS 体系结构中，每个具有请求作用域的服务都是在每个请求到来时创建的，如果您将这个服务注入到另一个服务中，第二个服务也会成为请求作用域，尽管您没有提到它。

我不是代码性能方面的专家，但我只是认为那样做可能会浪费内存和 CPU，也许实现总是单例的方法更便宜，但每个函数调用类内部的请求范围拦截代码将替换请求对象为当前对象(类似于“componenetWillUpdate”…😉).

谢谢你读到这里！

我很乐意收到你的反馈和评论，如果你喜欢这篇文章，你可以鼓掌。你也可以直接在 israellev770@gmail.com 给我写信，或者通过 [LinkedIn](https://www.linkedin.com/in/israel-levkivker-4277b3153/) 联系我。

我邀请你通过链接阅读我的其他文章:

*   [有效的“干”开发示例(仅适用于懒惰的开发人员！)](https://medium.com/@israellev770/effective-dry-development-example-for-lazy-developers-only-5745df266938?source=friends_link&sk=070c06aec0750fb88b98366c6e9d1f08)
*   [如何写一个干净的服务器端代码(并保存 30%的代码)](/how-did-i-build-my-own-orm-for-mysql-with-python-inspired-by-nestjs-cf56cbaee7fd?source=friends_link&sk=ec293413ebbc735aa5cbf7a01119c408)