<html>
<head>
<title>Swift: Alternative to struct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift:struct的替代方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swift-alternative-to-struct-a4ace0678673?source=collection_archive---------14-----------------------#2020-06-28">https://blog.devgenius.io/swift-alternative-to-struct-a4ace0678673?source=collection_archive---------14-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8dc13c44438d5f258d4ab4fdeb80b49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zksx9ZF_uJnGoGAU4eUQpw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@iam_anih?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">夏嫣·胡伊津加</a>在<a class="ae jd" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="2f0d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，你正在创建一个应用程序，它应该跟踪分析事件。为此，您选择了一个事件跟踪系统(如Firebase)。</p><p id="6054" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个想法是创建一个将建模<code class="fe lb lc ld le b">AnalyticsEvent</code>的结构。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c169" class="ln lo jg le b gy lp lq l lr ls">struct <!-- -->AnalyticsEvent {<br/>   let userId: String<br/>   let hasAdditionalData: Bool<br/>   let additionalData: [String: String]<br/>   let hasFeedback: Bool<br/>   let feedbackContent: String<br/>   // rest of the properties<br/>}</span></pre><p id="3c13" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这是一个假设的情况，但它凸显了一个问题。因为struct可以包含多个值，如果一个命令中包含多个事件(例如<code class="fe lb lc ld le b">hasFeedback</code>和<code class="fe lb lc ld le b">hasAdditionalData</code>)，可能会出现错误。这揭示了不具有互斥属性的问题，因为事件可以同时处于两种不同的状态。</p><p id="52ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用枚举将属性分组到事例中可以使数据更加清晰。Swift提供了一种构造，您可以将值与类型相关联，以便构建更复杂的数据结构。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a34a" class="ln lo jg le b gy lp lq l lr ls">enum <!-- -->AnalyticsEvent {<br/>   case sendFeedback(userId: String, content: String)<br/>   case sendAdditionalData(userId: String, data: [String: String]<br/>   case connectAppleHealth(userId: String)<br/>   // rest of the cases<br/>}</span></pre><p id="bfba" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在每个案例中添加元组，可以更清楚地看出哪些属性属于同一个案例。现在可以构造一个合适的事件，而不用担心混合和匹配错误的值。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5732" class="ln lo jg le b gy lp lq l lr ls">let feedbackEvent = <br/>    <!-- -->AnalyticsEvent.sendFeedback(userId: "id", content: "content")</span></pre><p id="0a72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种类型的构造，开关盒可用于展开内部值:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f507" class="ln lo jg le b gy lp lq l lr ls">func logEvent(event: <!-- -->AnalyticsEvent<!-- -->) {<br/>   switch event {<br/>      case .sendFeedback(<!-- -->_: String, content: String<!-- -->): <br/>          print("\(content)")<br/>      // rest of the cases<br/>}</span><span id="0fe0" class="ln lo jg le b gy lt lq l lr ls">if case let <!-- -->AnalyticsEvent<!-- -->.sendFeedback(<!-- -->_, content<!-- -->) = event {<br/>   print("\(content)")<br/>}</span></pre><p id="e0db" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用开关，您需要用尽<code class="fe lb lc ld le b">AnalyticsEvent</code>的所有情况。如果你对具体案例感兴趣，你可以使用<code class="fe lb lc ld le b">if case let</code>结构。同样，可以使用<em class="lu">通配符</em>操作符来匹配特定的属性，使用该操作符可以告诉您不关心特定属性的值。</p><h2 id="e993" class="ln lo jg bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">带枚举的多态性</h2><p id="cc43" class="pw-post-body-paragraph kd ke jg kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">有时候你需要在多态的形式上有一些灵活性。这意味着你愿意混合任何类型，但这往往并不理想。由于您在编译时不知道类型，所以需要在运行时对类型<code class="fe lb lc ld le b">Any</code>进行检查，以查看它表示什么。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="91f5" class="ln lo jg le b gy lp lq l lr ls">let data: [Any] = [Date(), "string", 123]</span><span id="f419" class="ln lo jg le b gy lt lq l lr ls">for elem: Any in data {<br/>  switch elem {<br/>     case let stringVal as String: // handle string<br/>     case let intVal as Int: // handle integer<br/>     case let dateVal as Date: // handle date<br/>     default: // handle others<br/>  }<br/>}</span></pre><p id="2fea" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不知道你期望的是什么，你仍然可以使用<code class="fe lb lc ld le b">switch</code>来确定类型，但是你也必须为你不感兴趣的类型覆盖默认情况。当您不确定从服务器接收的数据时，最好使用<code class="fe lb lc ld le b">Any</code>。但是如果你事先知道类型，你可以使用enum作为编译时的安全防护。</p><p id="fb56" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您正在从服务器接收一个<code class="fe lb lc ld le b">Date</code>或<code class="fe lb lc ld le b">Range&lt;Date&gt;</code>。在这种情况下，您可以建立代表其中一个选项的<code class="fe lb lc ld le b">DateType</code>模型。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8906" class="ln lo jg le b gy lp lq l lr ls">enum DateType {<br/>   case concrete(Date)<br/>   case range(Range&lt;Date&gt;)<br/>}</span></pre><p id="cd85" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多亏了这种类型的建模，你现在可以用它来接收单个<code class="fe lb lc ld le b">DateType</code>甚至一个<code class="fe lb lc ld le b">DateType</code>的数组！数组的每个值可以包含多种类型中的一种，同时保持编译时安全。要对值进行操作，只需像前面的例子一样使用<code class="fe lb lc ld le b">switch</code>语句。</p><p id="818a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样你就安全了，如果你想修改<code class="fe lb lc ld le b">DateType</code>，编译器会警告你新的/丢失的情况。</p><h2 id="cb51" class="ln lo jg bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">用枚举子类化</h2><p id="0613" class="pw-post-body-paragraph kd ke jg kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">子类化是一个允许你建立数据层次的概念。例如，您可以使用<code class="fe lb lc ld le b">Pizza</code>来表示比萨屋中提供的所有类型的比萨。现在你可以吃一堆不同的菜:那不勒斯菜、加州菜、芝加哥深菜…</p><p id="200a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在理想情况下，对数据进行分层建模是有意义的，但在实践中，情况并非如此。有时，您需要处理不符合层次规则的边缘情况或异常。</p><p id="f91d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，让我们来模拟一个游戏。我们可以从单人游戏开始:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e43d" class="ln lo jg le b gy lp lq l lr ls">struct SinglePlayerGame {<br/>   let id: String<br/>   let numOfPlayers: Int<br/>   let weaponsCollected: [String]<br/>}</span></pre><p id="1523" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在想添加多人游戏，你可以很容易地做到这一点，因为许多属性是相似的。</p><figure class="lf lg lh li gt is gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e611cefef5c176a969a4ef71cbc81f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*w1aZh8SJC7r5Rgq-wOxWyA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">游戏等级</figcaption></figure><p id="915c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">引入的<code class="fe lb lc ld le b">Game</code>超类包含了<code class="fe lb lc ld le b">SinglePlayerGame</code>和<code class="fe lb lc ld le b">MultiPlayerGame</code>共有的属性。当像这样建模时，你被迫使用类。但这还不是最大的问题。如果你想添加新的游戏类型<code class="fe lb lc ld le b">AIGame</code>，它没有相同的属性，那么你需要重构整个数据模型。</p><p id="bd83" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用枚举，您可以绕过层次模型，但是您仍然可以选择传递单个<code class="fe lb lc ld le b">Game</code>类型。另外增加一个新的<code class="fe lb lc ld le b">Game</code>类型不会违反现有的游戏。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7d4d" class="ln lo jg le b gy lp lq l lr ls">enum Game {<br/>   case singlePlayer(SinglePlayerGame)<br/>   case multiPlayer(MultiPlayerGame)<br/>   case ai(AIGame)<br/>} <br/></span><span id="2e20" class="ln lo jg le b gy lt lq l lr ls">let aiGame = ...<br/>let game = Game.ai(aiGame)</span></pre><p id="f225" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当相似的类型开始出现分歧，或者您希望使用结构(而不仅仅是类)时，这种类型的子类化是最好的。这种方法的缺点是必须匹配整个应用程序中的所有案例。虽然它需要额外的工作，但它也是一个安全的防护措施，因为如果你忘记了什么，你会得到编译器的警告。另一个缺点是锁定模型，这意味着如果你提供/使用enum作为/来自第三方库，用户不能扩展它。</p><h2 id="d027" class="ln lo jg bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">更安全地使用字符串</h2><p id="6730" class="pw-post-body-paragraph kd ke jg kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">枚举通常与字符串一起使用。当一个枚举被定义为原始值类型时，所有被定义的事例在它们内部都带有一些值。具有原始值的枚举是通过将类型添加到枚举的声明中来定义的。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9cc1" class="ln lo jg le b gy lp lq l lr ls">enum Stage: String {<br/>    case production<br/>    case staging<br/>    case dev<br/>    case local<br/>}</span></pre><p id="be4e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以(如果您愿意)为每个事例添加原始值，但是像这样声明enum会为每个事例提供事例名称的值。</p><p id="2635" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，您希望将enum的值作为参数发送给服务器。通过访问raw value属性读取枚举的原始值来设置参数。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9b1d" class="ln lo jg le b gy lp lq l lr ls">let stage = Stage.production<br/>let params = ["stage" : stage.rawValue] // ["stage": "production"]</span></pre><p id="9c94" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将原始值赋给案例会引入Bug。编译器会继续工作，但不幸的是API不会。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9dfd" class="ln lo jg le b gy lp lq l lr ls">enum Stage: String {<br/>    case production = "prod"<br/>    case staging<br/>    case dev<br/>    case local<br/>}</span><span id="30ce" class="ln lo jg le b gy lt lq l lr ls">let stage = Stage.production<br/>let params = ["stage" : stage.rawValue] // ["stage": "prod"]</span></pre><p id="48a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过两种方式解决该问题:</p><ul class=""><li id="68c6" class="ms mt jg kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">谨慎行事，忽略枚举的原始值，并匹配枚举事例中的每个事例</li><li id="71d2" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">用单元测试覆盖代码以确保正确的行为</li></ul><p id="31bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您从服务器接收值，并且该值已被更改，该怎么办呢？这可以用自定义初始化器来处理</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="725b" class="ln lo jg le b gy lp lq l lr ls">enum Stage: String {<br/>    case production<br/>    case staging<br/>    case dev<br/>    case local</span><span id="80c0" class="ln lo jg le b gy lt lq l lr ls">    init?(rawValue: String) {<br/>       switch rawValue.lowercased() {<br/>          case "prod", "production": self = .production<br/>          case "qa", "staging": self = .staging<br/>          case "dev": self = .dev<br/>          case "local": self = .local<br/>          default: return nul<br/>       }<br/>    }<br/>}</span></pre><h2 id="8e98" class="ln lo jg bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">摘要</h2><ul class=""><li id="bfe4" class="ms mt jg kf b kg mm kk mn ko ng ks nh kw ni la mx my mz na bi translated">枚举有时是子类化的更好的选择</li><li id="a781" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">枚举给了你在编译时捕捉问题的能力</li><li id="25d3" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">通过转换为枚举，可以使处理字符串更加安全</li></ul></div></div>    
</body>
</html>