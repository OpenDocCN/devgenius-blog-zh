<html>
<head>
<title>Head First Java-Chapter 9 (constructors and garbage collection)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">head First Java-第 9 章(构造函数和垃圾收集)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/head-first-java-chapter-9-constructors-and-garbage-collection-8dd89d0135d6?source=collection_archive---------5-----------------------#2022-07-08">https://blog.devgenius.io/head-first-java-chapter-9-constructors-and-garbage-collection-8dd89d0135d6?source=collection_archive---------5-----------------------#2022-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cc9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们考虑对象时，我们是负责对象生命周期的人。我们决定何时以及如何建造它。我们决定何时放弃它。但是一旦它被放弃，垃圾收集器(gc)可以蒸发它，回收该对象正在使用的内存。</p><h2 id="bd33" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">栈和堆</strong></h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/6934bb226ac1351af36109bbaef51bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKDM-l2GbhI9wXJwiEU45w.png"/></div></div></figure><p id="2f7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Java 中，程序员关心两个内存区域，<strong class="jm io">对象所在的区域(堆)</strong>、<strong class="jm io">以及方法调用和局部变量所在的区域(堆栈)。</strong></p><p id="1d0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道所有的对象都存在于垃圾回收堆中。变量的位置取决于它是什么类型的变量。</p><p id="2735" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两种变量</p><ol class=""><li id="e06e" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">实例变量</li><li id="31cf" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">局部变量。</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mb"><img src="../Images/ad4fe5884739a18d43d016e6a620466f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqZ61nron3P3Fhqyb4wTPA.png"/></div></div></figure><p id="faca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法堆叠</strong></p><ul class=""><li id="e317" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh mc lt lu lv bi translated">调用该方法后，这些方法将被放在调用堆栈的顶部。实际上被推到堆栈上的新东西是堆栈框架，它保存方法的状态，包括正在执行哪一行代码，以及所有局部变量的值。</li><li id="556c" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh mc lt lu lv bi translated">位于堆栈顶部的方法始终是该堆栈当前运行的方法。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi md"><img src="../Images/f46f7da95e41ac73691d932e2720311a.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*WuJLe3WT5BKZ9oMF0MN-Nw.png"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi me"><img src="../Images/1ce109fc4e67a44322e4947dcbbf4966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2p5qos88266LI-teEGH8A.png"/></div></div></figure><p id="5de4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">要点</strong></p><blockquote class="mf mg mh"><p id="1298" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">Java 有两个我们关心的内存区域:堆栈和堆。</p><p id="7b8c" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">实例变量是在类内部而不是任何方法外部声明的变量。</p><p id="1284" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">局部变量是在方法或方法参数中声明的变量。</p><p id="6f3f" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">所有局部变量都存在于堆栈中，在对应于声明变量的方法的框架中。</p><p id="21dd" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">对象引用变量的工作方式就像原始变量一样——如果引用被声明为局部变量，它就进入堆栈。</p><p id="7687" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">所有对象都存在于堆中，不管引用是局部变量还是实例变量。</p></blockquote><p id="0871" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">回顾对象的 3 个步骤</strong></p><ol class=""><li id="785a" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">申报</li><li id="2061" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">创造</li><li id="01b6" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">作业</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8cf662bead726682732d792330c3406c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*zli9SvhajFHppuWqfD12Eg.png"/></div></figure><p id="a0ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我们是在调用一个名为 Duck()的方法吗？</strong></p><blockquote class="mf mg mh"><p id="6063" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated"><em class="in">否我们调用鸭子构造函数。</em></p></blockquote><ul class=""><li id="7f05" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh mc lt lu lv bi translated">调用构造函数的唯一方法是用关键字 new 后跟类名。JVM 找到该类并调用该类中的构造函数。</li></ul><p id="400e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑一个名为 Duck 的类。因此，当我们创建一个新的鸭子时，有两种方法来创建一个新的鸭子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d447443e10f6a84c04193ea93acb6bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*kQ98QaRWFMNLDwlUVDq27A.png"/></div></figure><p id="c134" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">知道尺寸就做鸭子:</strong></p><blockquote class="mf mg mh"><p id="a01e" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">Duck2 d =新 duck 2(15)；</p></blockquote><p id="8b08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">不知道大小就做鸭子:</strong></p><blockquote class="mf mg mh"><p id="a511" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">duck 2 D2 = new duck 2()；</p></blockquote><p id="82e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">重载和默认构造函数</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mo"><img src="../Images/53b7a3053dbd91698f603ae22e34c5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EZOACKe_x4ShZo8Icb_-w.png"/></div></div></figure><ul class=""><li id="74cf" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh mc lt lu lv bi translated">如果一个类中有多个构造函数，这些构造函数必须有不同的参数列表。论点单包括参数的顺序和类型。只要它们不同，你就可以有不止一个构造函数。</li></ul><p id="2f16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要点</p><blockquote class="mf mg mh"><p id="e697" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">实例变量存在于它们所属的对象中，在堆上。</p><p id="ac18" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">如果实例变量是对对象的引用，那么引用和它所引用的对象都在堆上。</p><p id="1733" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">构造函数是当你对一个类类型说 new 时运行的代码。</p><p id="871a" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">构造函数必须与类同名，并且不能有返回类型。</p><p id="a3d8" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">您可以使用构造函数来初始化正在构造的对象的状态(即实例变量)。</p><p id="1e48" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">如果你没有在你的类中放入一个构造函数，编译器会放入一个默认的构造函数。</p><p id="e2cc" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">默认构造函数总是无参数构造函数。</p><p id="a668" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">如果您在类中放置一个构造函数(任何构造函数),编译器将不会构建默认的构造函数。</p><p id="1837" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">如果你想要一个无参数的构造函数，并且你已经放入了一个带参数的构造函数，你将不得不自己构建这个无参数的构造函数。</p><p id="c0a4" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">如果可能的话，总是提供一个无参数的构造函数，让程序员更容易创建一个工作对象。提供默认值。重载的构造函数意味着你的类中有不止一个构造函数。</p><p id="02df" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">重载的构造函数必须有不同的参数列表。<br/>不能有两个具有相同参数列表的构造函数。自变量列表包括自变量的顺序和/或类型。</p><p id="cc38" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">实例变量被赋予一个默认值，即使你没有明确地赋予一个。对于原语，默认值为 0/0.0/false，对于引用，默认值为 null。</p></blockquote><p id="c71c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">关于构造函数的四件事</strong></p><ol class=""><li id="cb2c" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">构造函数是当有人对类类型说 new 时运行的代码</li></ol><blockquote class="mf mg mh"><p id="bb49" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">鸭 d =新鸭()；</p></blockquote><p id="601b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.构造函数必须与类同名，并且没有返回类型</p><blockquote class="mf mg mh"><p id="8720" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">公共鸭(int size) { }</p></blockquote><p id="b346" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.如果你没有在你的类中放入一个构造函数，编译器会放入一个默认的构造函数。默认构造函数总是无参数构造函数。</p><blockquote class="mf mg mh"><p id="53a2" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">公鸭(){ }</p></blockquote><p id="cd70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.只要参数列表不同，您的类中可以有多个构造函数。一个类中有多个构造函数意味着你重载了构造函数。</p><blockquote class="mf mg mh"><p id="ac64" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">公鸭(){ }</p><p id="e9dd" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">公共鸭(int size) { }</p><p id="71de" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">公共鸭(字符串名){ }</p><p id="0af8" class="jk jl mi jm b jn jo jp jq jr js jt ju mj jw jx jy mk ka kb kc ml ke kf kg kh ig bi translated">public Duck(String name，int size) { }</p></blockquote><p id="521f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">物体构造</strong></p><p id="1e2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们想象一个制作河马的场景。所以制造河马也意味着制造动物和物体的部分。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0b98534f94a2371174b51d3cb2b6f52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*d6Xl7HLtfHgGn-PmDfE80g.png"/></div></figure><ol class=""><li id="ed51" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">另一个类的代码说 new Hippo()和 Hippo()构造函数进入堆栈顶部的堆栈框架。</li><li id="07b0" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">Hippo()调用超类构造函数，将 Animal()构造函数推到堆栈顶部。</li><li id="d4cd" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">Animal()调用超类构造函数，因为它将 Object()构造函数推到堆栈的顶部，因为 Object 是 Animal 的超类。</li><li id="686f" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">Object()完成，其堆栈帧从堆栈中弹出。执行返回到 Animal()构造函数，然后在 Animal 对其超类构造函数的调用之后的行上继续执行。</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mq"><img src="../Images/d23ebe11cadbdbb36af69b4f211f377f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RKj9MojAz3jIvxicBv_Cw.png"/></div></div></figure><p id="c6c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个物体能存在多久？</p><ul class=""><li id="cf7b" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh mc lt lu lv bi translated">对象的寿命完全取决于引用它的引用的寿命。所以是引用被标识为“活的”，对象在堆上仍然是活的。如果引用死了，对象也会死。</li></ul><p id="f190" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个变量存在多久？</p><ul class=""><li id="1f39" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh mc lt lu lv bi translated">这取决于变量是局部变量还是实例变量。下面的代码展示了一个局部变量的生命。在这个例子中，变量是一个原始变量，但是无论它是原始变量还是引用变量，变量的生命周期都是相同的。</li></ul></div></div>    
</body>
</html>