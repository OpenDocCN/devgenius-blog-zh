<html>
<head>
<title>Java/Kotlin/GraalVm and Golang. What is the situation. The most performant frameworks, memory consuming, easy to develop.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java/Kotlin/GraalVm 和 Golang。是什么情况。最具性能的框架，消耗内存，易于开发。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-kotlin-graalvm-and-golang-7fb979ef4c03?source=collection_archive---------2-----------------------#2022-12-20">https://blog.devgenius.io/java-kotlin-graalvm-and-golang-7fb979ef4c03?source=collection_archive---------2-----------------------#2022-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="a9bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有很多故事说 Golang 比 Java 快。我看到了许多基准测试，它们什么也没说，只是比较特定的框架。</p><p id="d508" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">目前 Java 的行业标准是 Spring。它是一个庞然大物，与轻量级 Golang 框架相比没有任何意义。Spring 的主要目标是标准化大型应用程序的开发，并为开发人员提供针对业务逻辑的能力。相反，Golang 用于微服务。它没有如此庞大的框架。</p><p id="8f0c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">同样让我们看看 https://www.techempower.com/benchmark。在前 20 个版本中有很多轻量级的 Java 框架，但是没有 Golang 框架。Java 是高度可定制，设计成可以在任何地方运行。java 也有 GraalVm 来解决 AOT 问题，减少内存消耗，从而降低基础设施成本。</p><p id="1f9c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我想至少为我自己回答这个问题:)。</p><p id="632d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将尝试指出 3 个领域中最轻量级和高性能的框架:</p><ol class=""><li id="5fd8" class="kq kr in jt b ju jv jy jz kc ks kg kt kk ku ko kv kw kx ky bi translated">Http 服务器</li><li id="f252" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko kv kw kx ky bi translated">序列化/反序列化</li><li id="5294" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko kv kw kx ky bi translated">数据库驱动程序</li></ol><p id="cd9b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对 3 个方面进行分析:易于开发、内存消耗和性能</p><p id="d5a1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从商业角度来看，场景是无用的，但技术场景尽可能全面:</p><ul class=""><li id="3f87" class="kq kr in jt b ju jv jy jz kc ks kg kt kk ku ko le kw kx ky bi translated">发送带有 4 个字段的用户创建请求:id，姓名，电子邮件，年龄</li><li id="199d" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">反序列化请求</li><li id="716b" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">在 Pstgres 数据库中创建用户</li><li id="8269" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">从数据库中选择用户</li><li id="7a90" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">删除用户</li><li id="4a80" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">序列化选定的用户</li><li id="b1f5" class="kq kr in jt b ju kz jy la kc lb kg lc kk ld ko le kw kx ky bi translated">发送响应</li></ul></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="8f8f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak"> Jvm HTTP 解决方案</strong></h1><p id="4df8" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">For Development 将把 Kotlin 作为主要的编程语言</p><p id="12c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于 HTTP 服务器毫无疑问会采取普通 Netty 服务器没有任何额外的框架+反应器，方便地使用 Mono 和 Flux。java 方 VertX 的<a class="ae kp" href="https://www.techempower.com/benchmark" rel="noopener ugc nofollow" target="_blank"> techempower </a>基准测试的领导者之一使用它。我也每天使用它，非常熟悉:)</p><p id="e73c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">将避免代理、Beans 和其他 java 常用的东西。只是手动启动。对于我的版本，gradle 将添加以下几行:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="32c0" class="mr lg in mn b be ms mt l mu mv">implementation(platform("io.projectreactor:reactor-bom:2022.0.0-RC1"))<br/>implementation("io.projectreactor.netty:reactor-netty-core")<br/>implementation("io.projectreactor.netty:reactor-netty-http")</span></pre><p id="589c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">主文件看起来像这样:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="3a34" class="mr lg in mn b be ms mt l mu mv">fun main() {<br/>    val port = 8089<br/>    val server = HttpServer.create()<br/>        .route { routes: HttpServerRoutes -&gt;<br/>            routes.post(<br/>                "/api"<br/>            ) { request, response -&gt; Handler.handle(request, response) }<br/>        }<br/>        .host("0.0.0.0")<br/>        .port(port)<br/>        .bindNow()<br/><br/>    println("Starting on port $port ...")<br/><br/>    server.onDispose()<br/>        .block()<br/>}</span></pre><p id="8dd1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如我提到的，我的微服务将有一个端点，可以处理所有传入的请求。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="0ec5" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Jvm 序列化解决方案</h1><p id="9bc7" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">T <a class="ae kp" href="https://www.techempower.com/benchmark" rel="noopener ugc nofollow" target="_blank"> echempower </a> benchmark 有 tab，专门用于序列化。从这个选项卡中，我可以得出有趣的结论。例如 Vertx 在所有基准测试中都很高，除了序列化。它为此使用了杰克逊。可能大部分 java 框架都在使用它。我开始寻找现成的、性能更好的东西。我找到了这个基准:<a class="ae kp" href="https://github.com/fabienrenaud/java-json-benchmark" rel="noopener ugc nofollow" target="_blank">https://github.com/fabienrenaud/java-json-benchmark</a></p><p id="e3eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">根据这个基准测试<a class="ae kp" href="https://github.com/ngs-doo/dsl-json" rel="noopener ugc nofollow" target="_blank">，dsl-json </a>是 Java 世界中序列化性能的领导者。千万不要去这个图书馆。<br/>但是检查其他的基准测试，我发现串行化并不是 java 最强的部分。:)【https://github.com/kostya/benchmarks<br/><a class="ae kp" href="https://github.com/kostya/benchmarks" rel="noopener ugc nofollow" target="_blank">你看领导果然是铁锈和 C++。但是这个库可以认为是最快的。添加到 gradle 文件:</a></p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="85b7" class="mr lg in mn b be ms mt l mu mv">implementation("com.dslplatform:dsl-json-java8:1.9.9")<br/>kapt("com.dslplatform:dsl-json-java8:1.9.9")</span></pre><p id="7de7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">和请求处理器:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="5c21" class="mr lg in mn b be ms mt l mu mv">// Init object mappper<br/>val objectMapper = DslJson(Settings.withRuntime&lt;Any&gt;().includeServiceLoader())<br/>......................................<br/>request.receive()<br/>                .aggregate()<br/>                .asByteArray()<br/>                .map { bytes -&gt; objectMapper.deserialize(UserDto::class.java, bytes.inputStream()) }<br/>.......................................................<br/>// serialization stuff for the response<br/> .map {<br/>                    val outputStream = ByteArrayOutputStream()<br/>                    objectMapper.serialize(it, outputStream)<br/>                    outputStream.toByteArray()<br/>                }</span></pre><p id="68b6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这之后，我尝试了一个简单的场景，用普通的 json 接收请求，反序列化它，打印到控制台，再次序列化并发送响应。创建了 docker 容器并执行了 apache 基准测试:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="3a11" class="mr lg in mn b be ms mt l mu mv">// warm up jvm<br/>ab -p performance/test.json -T application/json -c 100 -n 20000 http://localhost:8089/api<br/>// regular benchmark<br/>ab -p performance/test.json -T application/json -c 100 -n 2000000 http://localhost:8089/api</span></pre><p id="0b73" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最佳转速为 18K 转/秒，中等转速约为 16K 转/秒</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="870f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加 GraalVm</h1><p id="b29f" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">我猜 jvm 的性能很高，但是内存使用和工件大小呢？我如何降低基础设施成本？我想这是在微服务架构中使用 java 的主要人员的主要问题。因为 java 不是关于低内存消耗的。让我们试着用 GraalVm 解决这个问题…..</p><p id="06ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我估计很多人都可以这么想:)。对我来说，这和欢迎来到地狱是一样的:)</p><p id="1568" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我的目标是得到一个可执行的二进制文件。我需要静态图像。当然，默认情况下，没有什么对我有用。:)</p><p id="9c9c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在 Oracle 文档中我找到了如何安装<a class="ae kp" href="https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/native-image/StaticImages/" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/graalvm/enterprise/20/docs/reference-manual/native-image/static images/</a></p><p id="002c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">花了几个小时在我的 Ubuntu 上设置<code class="fe mw mx my mn b">musl-gcc</code>编译器和 zlib。我不知道 windows 用户是如何克服我在安装时发现的这么多问题的。终于让它工作了，但这并不是我冒险的结束。我花时间从编译中排除不同的类</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="0c13" class="mr lg in mn b be ms mt l mu mv">--initialize-at-run-time</span></pre><p id="ad4f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我使用的库也有很多代理类，这就是为什么需要在编译中添加 reflection-config.json 和一个标志。默认情况下，Netty 不是编译的。需要调查那里的存储库并逐个解决问题，创建了这个反射配置。</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="f057" class="mr lg in mn b be ms mt l mu mv">-H:ReflectionConfigurationResources=${.}/reflection-config.json</span></pre><p id="ed0e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">loke 中的初始化次数如下:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="38d1" class="mr lg in mn b be ms mt l mu mv">..................................<br/>{<br/>  "name": "io.netty.channel.epoll.EpollServerSocketChannel",<br/>  "methods": [<br/>    { "name": "&lt;init&gt;", "parameterTypes": [] }<br/>  ]<br/>},<br/>...........................................</span></pre><p id="1648" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">还有 JNI 配置</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="0ac9" class="mr lg in mn b be ms mt l mu mv">-H:JNIConfigurationResources=${.}/jni-config.json</span></pre><p id="1526" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所有这些东西都可以在知识库中找到。</p><p id="e7e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后命令:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="f244" class="mr lg in mn b be ms mt l mu mv">export PATH={{TOOLCHAIN_DIR}}/bin:$PATH &amp;&amp; {{JAVA_HOME}}/bin/native-image - static - libc=musl - no-fallback -cp ./build/libs/fast-http-1.0-SNAPSHOT-all.jar -H:Name=app -H:Class=com.fasthttp.MainKt -H:+JNI -H:+ReportUnsupportedElementsAtRuntime</span></pre><p id="b863" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">已被执行，我得到了本地图像。还安装了 upx 实用程序来压缩 Linux 二进制文件，并为我的 Netty 服务器安装了 5.5 mb 大小的二进制文件。</p><p id="ede6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们打包到 docker 并执行 Apache 基准测试。正如所料，我得到的结果在性能方面比 JIT 版本更差。</p><p id="837b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最佳执行速度约为 14K r/s。一般情况下，速度约为 12K r/s。图像越小，性能也越低。:)</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="6f95" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">JVM 数据库驱动程序</h1><p id="05cb" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">这是最简单的解决方案。只需访问<a class="ae kp" href="https://www.techempower.com/benchmarks/#section=data-r21&amp;test=query" rel="noopener ugc nofollow" target="_blank">https://www.techempower.com/benchmarks/#section=data-r21&amp;测试=查询</a>。在用于 dingle 查询的基准中，postgres vertx 驱动程序位于第二个位置，对于多个查询，它位于第三个位置。看起来不错，它比 c++和 rust libs 的大部分都要好，而且是异步的。只需添加到 gradle 文件:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="fae2" class="mr lg in mn b be ms mt l mu mv">implementation("io.vertx:vertx-pg-client:4.3.5")</span></pre><p id="b91c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不幸的是，要编译 GraalVm 版本，需要添加几个库:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="9d3c" class="mr lg in mn b be ms mt l mu mv">implementation("com.ongres.scram:common:2.1")<br/>implementation("com.ongres.scram:client:2.1")</span></pre><p id="4787" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">GraalVm 版本也面临日期序列化的问题。在使用 Locale.Root 运行时，DataTypeCodec 类失败。我找到了有关本机运行的此问题的几个解释。</p><p id="045e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">无法在 lib 中直接解决这个类的问题，所以用我自己的同名同包的类覆盖了它:)。对 java 有好处。</p><p id="e626" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">实现非常简单。创建的普通 SQL 常量:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="fd3b" class="mr lg in mn b be ms mt l mu mv">const val GET_USER = """SELECT * FROM users as u<br/>WHERE u.id=%d"""<br/><br/>const val INSERT_USER = """INSERT INTO users (name, email, age)<br/>values ('%s', '%s', %d) RETURNING id"""<br/><br/>const val DELETE_USER = """DELETE FROM users as u<br/>WHERE u.id=%d"""</span></pre><p id="4b31" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">而初始化只是创建连接:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="7bba" class="mr lg in mn b be ms mt l mu mv">init {<br/>    val connectOptions = PgConnectOptions().setPort(5432)<br/>        .setHost("db")<br/>        .setDatabase("postgres")<br/>        .setUser("postgres")<br/>        .setPassword("postgres");<br/>    val poolOptions = PoolOptions().setMaxSize(5)<br/>    client = PgPool.client(connectOptions, poolOptions);<br/>}</span></pre><p id="657c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">查询实现也很简单:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="ab90" class="mr lg in mn b be ms mt l mu mv">val  future: Future&lt;RowSet&lt;Row&gt;&gt; = client<br/>    .query(String.format(DELETE_USER, usr.id))<br/>    .execute()</span></pre><p id="b5ca" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对 db 的每个查询都应该返回 Mono。我不能使用 Mono.fromFuture()，因为 Vertx Future 不是一个可完成的 future，但是我查看了代码，发现我可以从 vertx future 获得 CompletionStage，这样我就可以用 Mono.fromCompletionStage(..)</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="7f4f" class="mr lg in mn b be ms mt l mu mv">Mono.fromCompletionStage(future.toCompletionStage())</span></pre><p id="70e8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这之后，我可以使用单声道和通量的东西进行任何转换。资源库中提供了完整的代码。</p><p id="db03" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最终获得端到端工作的解决方案。这就是 java。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="4246" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Golang HTTP 解决方案</h1><p id="9e9b" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">幸运的是，Golang 没有太多的解决方案:)。围棋通常只有一条路。但是这里有两个解决方案。Golang 拥有强大的 http 库。但是为了性能，存在 fasthttp lib。关于 Techempower 基准测试，性能最好的是基于该库的光纤。我决定采用 fasthttp 进行测试，原因如下:【https://github.com/valyala/fasthttp<a class="ae kp" href="https://github.com/valyala/fasthttp" rel="noopener ugc nofollow" target="_blank">。与 Kotlin 的实现非常相似:</a></p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="698a" class="mr lg in mn b be ms mt l mu mv">func main() {<br/>   fmt.Println("Starting server on ", "8089")<br/>   err := fasthttp.ListenAndServe(":8089", Handle)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>}</span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="93d2" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Golang 电子监管解决方案</h1><p id="5286" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">对于序列化，我使用了与 java 相同的基准。https://jsoniter.com/发现了<a class="ae kp" href="https://jsoniter.com/" rel="noopener ugc nofollow" target="_blank"/>。Per benchmarks 为 golang 提供了最高性能的序列化/反序列化库。它在几个地方优于 java 版本。同样，jsoniter  java 版本也存在，但由于某些原因，它没有在基准测试中提到:(。</p><p id="7a7d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，这个库与标准库兼容。只需要调用这个结构:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="7fa8" class="mr lg in mn b be ms mt l mu mv">var json = jsoniter.ConfigCompatibleWithStandardLibrary</span></pre><p id="0f20" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以使用性能更高的常规方法:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="84b4" class="mr lg in mn b be ms mt l mu mv">b := ctx.Request.Body()<br/>user := dto.User{}<br/>if err := json.Unmarshal(b, &amp;user); err != nil {<br/>.........<br/></span></pre><pre class="mz mm mn mo bn mp mq bi"><span id="449f" class="mr lg in mn b be ms mt l mu mv">b, err = json.Marshal(&amp;usr)<br/>...........</span></pre><p id="8752" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码可以在资源库中找到。已执行 Apache 基准测试。GraalVm 版本的结果甚至更差，但已经很接近了。</p><p id="dd12" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最好的执行速度大约是 13K 转/秒。一般来说，大约是 8K 转/秒。有趣的是，似乎 Netty 做了这个神奇的表演。:) .但是压缩后的二进制文件大小减少了两倍，即 2.5 mb。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="9e33" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Golang 数据库驱动程序</h1><p id="6581" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">我决定使用与 java 相同的方法。一些低水平和高性能的 postgres。与 pgx 驱动程序一起使用的是一个低级的高性能接口，它公开了 PostgreSQL 特有的特性。同样的方法。创建了 3 个常量并执行了普通的 sql 查询。扫描也是手动进行的。</p><p id="8b17" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">举个例子。代码可在回购中获得。非常简单，不需要额外的解释:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="19a8" class="mr lg in mn b be ms mt l mu mv">import . "github.com/jackc/pgx/v5/pgxpool"<br/><br/>....<br/>dbPool, err := New(context.Background(), dbString)<br/>.........<br/>usr := dto.User{}<br/> err = con.QueryRow(ctx, GET_USER, id).Scan(<br/>  &amp;usr.Id,<br/>  &amp;usr.Username,<br/>  &amp;usr.Email,<br/>  &amp;usr.Age,<br/> )</span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="7504" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">测试结果</strong></h1><p id="022c" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">让我们试着分析一下这个例子:</p><ol class=""><li id="7d45" class="kq kr in jt b ju jv jy jz kc ks kg kt kk ku ko kv kw kx ky bi translated"><strong class="jt io">神器尺寸:</strong></li></ol><p id="6ee9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java JIT: jar 文件是 12 MB。当然结果 docker 容器会更大。我们需要有 JVM 在里面。</p><p id="805e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java AOT(GraalVm):粗略的二进制文件大小为 49Mb。但是用 upx 工具压缩后，我有 11Mb。</p><p id="b5cd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Golang:粗略的二进制大小为 14 Mb。压缩后，它有 5.5Mb</p><p id="30f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.<strong class="jt io">码头集装箱尺寸:</strong></p><p id="e8fd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java JIT:它有最大的容器——306 MB</p><p id="65e9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java AOT(GraalVm): 30Mb</p><p id="6343" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">戈朗:17 兆字节</p><p id="855c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.<strong class="jt io"> Apache 性能指标评测:</strong></p><p id="fdfd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我执行了以下脚本:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="c629" class="mr lg in mn b be ms mt l mu mv">ab -p performance/test.json -T application/json -c 100 -n 20000 http://localhost:8089/api<br/>ab -p performance/test.json -T application/json -c 100 -n 1000000 http://localhost:8089/api</span></pre><p id="6e95" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先是预热应用程序。这对 java 很重要。:)</p><p id="b1d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，我尝试将内存限制为 50 Mb。Java (AOP &amp; JIT)因 OOM 而失败。Golang 即使是 20 Mb 也没问题，性能没有明显下降。对于 10 Mb 的内存来说甚至还可以。</p><p id="bf43" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">java 的最小内存是 100Mb。这就是为什么每个应用程序的 Docker 将从以下设置开始:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="1b45" class="mr lg in mn b be ms mt l mu mv">docker run -it -d --memory=100m --cpus=4 -p 8089:8089 --network fast-http ${image name}<br/><br/>// postgres and container should be in the same network</span></pre><p id="da4a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">游戏开始:) :</p><ol class=""><li id="490f" class="kq kr in jt b ju jv jy jz kc ks kg kt kk ku ko kv kw kx ky bi translated"><strong class="jt io"> Java AOT (GraalVm): </strong></li></ol><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="a42e" class="mr lg in mn b be ms mt l mu mv">Memory usage: <br/>  Cold start: "Out of the box it allocates 75 Mb from the beginning"<br/>  When tests started: "It was 99 Mb all the time test was running"<br/>  CPU: "Intensive usage. Always shown more than 100 %." - 150 - 250<br/>RPS: <br/>  1. For first 20K requests it shown 1172 reqests/second<br/>  2. For the main benchmark it shown 337  requests/second - seems single instance of postgres is overloaded. But I haven't seen any high load on postgres side</span></pre><p id="49d0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.戈朗:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="87a1" class="mr lg in mn b be ms mt l mu mv">Memory usage: <br/>  Cold start: "Out of the box it allocates 2 Mb from the beginning"<br/>  When tests started: "It was 22 Mb all the time test was running"<br/>  CPU: "High Intensive usage. Always shown more than 100 %." - 250 - 330<br/>RPS: <br/>  1. For first 20K requests it shown 259 reqests/second<br/>  2. For the main benchmark it shown 223  requests/second - stable. Not familiar with pgx driver</span></pre><p id="432f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.<strong class="jt io"> Java JIT: </strong></p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="767d" class="mr lg in mn b be ms mt l mu mv">Memory usage: <br/>  Cold start: "Out of the box it allocates 34Mb from the beginning"<br/>  When tests started: "It was 75 Mb all the time test was running"<br/>  CPU: "Low Intensive usage. From the beginning was about 62%. Then when JVM warms up it become 45% or even lower" 30% some time<br/>RPS: <br/>  1. For first 20K requests it shown 1185 reqests/second<br/>  2. For the main benchmark it shown 332  requests/second - same as for AOT. Guess have some DB limitations </span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="f21d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="4412" class="pw-post-body-paragraph jr js in jt b ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko ig bi translated">正如所料，jvm 需要资源。Golang 可以在非常有限的资源下工作。</p><p id="30fb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">与 JIT 相比，GraalVM 无疑解决了工件大小的问题，但是在编译阶段的环境中增加了很多复杂性。如果你认为可以在 GraalVM 下编译普通的 JVM 应用程序，这是不正确的。与 golang 相比，这是一种痛苦。</p><p id="0166" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用 GraalVM 进行开发需要时间。每次都可以喝咖啡休息一下:)。为了加快速度，我在开发时使用普通的 JVM。但不能保证它会与 AOT 合作。:)</p><p id="c3ee" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">golang 的错误管理简直是地狱。但这可能是我来自 Java 世界。:)</p><p id="7c49" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">易于开发:我看不出 Java JIT 和 Golang 有什么困难。Golang 的编译速度当然是最高的。不会有咖啡刹车:)。对于 GraalVM 来说，这并不容易。应该花更多的时间让这些东西工作起来。</p><p id="442b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">性能。对于所选的框架，Java 优于 Golang。但我想对于更常见的选择情况可能是相反的。也许如果我尝试调整 JVM，结果会有所不同。</p><p id="4a8c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">同时，我试着在 Rust 中实现这个东西，在所有优化之后，工件的大小小于 1Mb。:)</p><p id="0ff3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句。<em class="na">关于性能结果没用:)。为项目选择具体的堆栈是更复杂的任务，与那里描述的内容无关。</em></p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="70d5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">存储库可用</p><div class="nb nc gp gr nd ne"><a href="https://github.com/aviplayer/fast-web-java" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">GitHub - aviplayer/fast-web-java:调查性能 java</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns nt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://github.com/aviplayer/fast-http-golang" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">GitHub-avi player/fast-http-Golang:Golang 性能困扰</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns nt ne"/></div></div></a></div><p id="5b84" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于配置、编译和执行，我使用了 justfile。请将 Justfiles 顶部的变量更改为您的路径。</p><p id="19f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">需要在考试前开始 postgres。只需 cd 到 infra 目录并运行 docker compose up -d</p><p id="aeeb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后从项目的根开始:</p><p id="d87f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于 java JIT:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="16db" class="mr lg in mn b be ms mt l mu mv">just docker-java</span></pre><p id="bde4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于 java AOT 来说，所有这些怪异的设置都完成了:)</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="41a8" class="mr lg in mn b be ms mt l mu mv">just docker-native</span></pre><p id="5da4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于 Golang 来说，从项目的根</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="6ea8" class="mr lg in mn b be ms mt l mu mv">just run</span></pre><p id="292c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要从 java 项目的根目录执行测试:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="4946" class="mr lg in mn b be ms mt l mu mv">just test</span></pre></div></div>    
</body>
</html>