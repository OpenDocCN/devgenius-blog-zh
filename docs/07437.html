<html>
<head>
<title>Design relationships between Django models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django 模型之间的设计关系</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-relationships-between-django-models-11ce7960e2ec?source=collection_archive---------4-----------------------#2022-03-25">https://blog.devgenius.io/design-relationships-between-django-models-11ce7960e2ec?source=collection_archive---------4-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/68a933473ab51022ee22a555fa821025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WST8h5D2uOoRf23aK5nmng.png"/></div></div></figure><p id="3935" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，我们需要在数据之间建立某种关系。这使得查询和获取数据变得更加容易。与例如博客帖子和类别或/和博客标签有关系也是有意义的。</p><p id="d01a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我之前的教程<a class="ae kt" href="https://mjovanc.com/quick-guide-of-the-python-web-framework-django-f7b7bcdecb57" rel="noopener ugc nofollow" target="_blank">中，我们已经使用 Django 完成了一个简单的博客应用程序，我们将继续在这个基础结构和实现的基础上添加更多内容。</a></p><p id="7601" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，关于以下的一些基本知识是必要的。我们需要弄清楚我们需要什么样的关系。我们需要考虑使用的关系有:</p><ul class=""><li id="de2d" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">一对一</strong></li><li id="5eaa" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">一对多</strong></li><li id="b48d" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">多对多</strong></li></ul><p id="5480" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更清楚地理解它的含义，可以在下面举例说明:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/bd17aeb2053593b087ca23a348370e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4a5Rjzu09JGBEv1EsJ_fQ.png"/></div></div></figure><p id="e0f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一对一</strong>——所以一家汽车公司有且只有一款车型，而一款车型有且只有一辆汽车。</p><p id="1110" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一对多</strong> —一个医生可以有多个病人，但是一个病人只有一个医生(也可以是多对多)</p><p id="e36d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">多对多</strong> —一个学生有很多科目，很多科目可以被很多学生使用。</p><p id="3c6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经解决了这个问题，我们将开始考虑如何设计我们的博客应用程序。我们需要一个博客帖子(正如我们之前已经实现)，博客类别和博客标签模型。那么我们应该如何看待它们之间的关系呢？一个建议和我们将如何做是使用以下:</p><ul class=""><li id="03dc" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">博客类别</strong> — <strong class="jx io">博客发布</strong>(多对多)</li><li id="5edf" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">博客标签</strong> — <strong class="jx io">博客发布</strong>(多对多)</li></ul><p id="6b4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要在 BlogCategory 和 BlogPost 之间建立一种多对多的关系，因为会有许多博客文章被附加到许多不同的类别，反之亦然。</p><p id="fb1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也需要我们的博客标签和博客文章之间的相同类型的关系。</p><h1 id="2251" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Django 的关系类型</h1><p id="015e" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">因此，在 Django 中，有上述类型的关系，其中每一种都有大量的文档，说明如何用好的例子来使用它们。所以我不会在这里过多地讨论它，因为我也会参考文档。查看本文底部的参考资料，找到它们的链接。</p><h2 id="a209" class="mq lo in bd lp mr ms dn lt mt mu dp lx kg mv mw mb kk mx my mf ko mz na mj nb bi translated">Django 文档中的一对一示例</h2><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="f9c7" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from</strong> <strong class="nd io">django.db</strong> <strong class="nd io">import</strong> models<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Place</strong>(models.Model):<br/>    name = models.CharField(max_length=50)<br/>    address = models.CharField(max_length=80)<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> "<strong class="nd io">%s</strong> the place" % self.name<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Restaurant</strong>(models.Model):<br/>    place = models.OneToOneField(<br/>        Place,<br/>        on_delete=models.CASCADE,<br/>        primary_key=<strong class="nd io">True</strong>,<br/>    )<br/>    serves_hot_dogs = models.BooleanField(default=<strong class="nd io">False</strong>)<br/>    serves_pizza = models.BooleanField(default=<strong class="nd io">False</strong>)<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> "<strong class="nd io">%s</strong> the restaurant" % self.place.name<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Waiter</strong>(models.Model):<br/>    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)<br/>    name = models.CharField(max_length=50)<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> "<strong class="nd io">%s</strong> the waiter at <strong class="nd io">%s</strong>" % (self.name, self.restaurant)</span></pre><p id="1e65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们处理一对一关系时，我们使用<strong class="jx io"> OneToOneField </strong>字段类型并连接模型名称，在本例中是在示例位置，并使用<strong class="jx io"> CASCADE </strong>类型的方法<strong class="jx io"> on_delete </strong>。</p><h2 id="586b" class="mq lo in bd lp mr ms dn lt mt mu dp lx kg mv mw mb kk mx my mf ko mz na mj nb bi translated">Django 文档中的多对一示例</h2><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="0e23" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from</strong> <strong class="nd io">django.db</strong> <strong class="nd io">import</strong> models<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Reporter</strong>(models.Model):<br/>    first_name = models.CharField(max_length=30)<br/>    last_name = models.CharField(max_length=30)<br/>    email = models.EmailField()<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> "<strong class="nd io">%s</strong> <strong class="nd io">%s</strong>" % (self.first_name, self.last_name)<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Article</strong>(models.Model):<br/>    headline = models.CharField(max_length=100)<br/>    pub_date = models.DateField()<br/>    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> self.headline<br/><br/>    <strong class="nd io">class</strong> <strong class="nd io">Meta</strong>:<br/>        ordering = ['headline']</span></pre><p id="5677" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当使用多对一关系时，我们使用<strong class="jx io">外键</strong>字段类型，并描述它应该连接到什么模型，以及使用<strong class="jx io"> on_delete </strong>类型。通常是<strong class="jx io">级联</strong>。这意味着当我们删除一篇文章时，我们也会删除记者数据。</p><h2 id="8089" class="mq lo in bd lp mr ms dn lt mt mu dp lx kg mv mw mb kk mx my mf ko mz na mj nb bi translated">Django 文档中的多对多示例</h2><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="4666" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from</strong> <strong class="nd io">django.db</strong> <strong class="nd io">import</strong> models<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Publication</strong>(models.Model):<br/>    title = models.CharField(max_length=30)<br/><br/>    <strong class="nd io">class</strong> <strong class="nd io">Meta</strong>:<br/>        ordering = ['title']<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> self.title<br/><br/><strong class="nd io">class</strong> <strong class="nd io">Article</strong>(models.Model):<br/>    headline = models.CharField(max_length=100)<br/>    publications = models.ManyToManyField(Publication)<br/><br/>    <strong class="nd io">class</strong> <strong class="nd io">Meta</strong>:<br/>        ordering = ['headline']<br/><br/>    <strong class="nd io">def</strong> __str__(self):<br/>        <strong class="nd io">return</strong> self.headline</span></pre><h1 id="ae7a" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建 Django 模型</h1><p id="0497" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">因此，让我们开始在现有项目中实现这一点。确保从这里从现有的存储库克隆存储库(使用分支<strong class="jx io">快速指南</strong>):<a class="ae kt" href="https://github.com/mjovanc/medium-django/tree/quick-guide" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-django/tree/quick-guide</a></p><p id="1f56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要忘记创建你的虚拟环境，如果不确定的话，可以查看之前的教程。</p><p id="ea9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经添加了 BlogPost 类，我们需要在主应用程序的<strong class="jx io"> models.py </strong>文件中再添加两个类 BlogCategory 和 BlogTag:</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="a6e1" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">class</strong> <strong class="nd io">BlogTag</strong>(models.Model):<br/>    name = models.CharField(verbose_name=_('Title'), max_length=100)<br/>    created = models.DateTimeField(verbose_name=_('Created Date'), auto_now_add=True, blank=True, null=True)<br/>    updated = models.DateTimeField(verbose_name=_('Updated Date'), auto_now_add=True, blank=True, null=True)</span><span id="9880" class="mq lo in nd b gy nl ni l nj nk"><strong class="nd io">def __str__</strong>(self):<br/>        <strong class="nd io">return</strong> self.name<br/>     <br/>    class <strong class="nd io">Meta</strong>:<br/>        verbose_name = _('Blog Tag')<br/>        verbose_name_plural = _('Blog Tags')<br/><br/><br/><strong class="nd io">class</strong> <strong class="nd io">BlogCategory</strong>(models.Model):<br/>    name = models.CharField(verbose_name=_('Title'), max_length=100)<br/>    created = models.DateTimeField(verbose_name=_('Created Date'), auto_now_add=True, blank=True, null=True)<br/>    updated = models.DateTimeField(verbose_name=_('Updated Date'), auto_now_add=True, blank=True, null=True)<br/>    <br/>    <strong class="nd io">def __str__</strong>(self):<br/>        <strong class="nd io">return</strong> self.name</span><span id="3c7e" class="mq lo in nd b gy nl ni l nj nk"><strong class="nd io">    class</strong> <strong class="nd io">Meta</strong>:<br/>        verbose_name = _('Blog Category')<br/>        verbose_name_plural = _('Blog Categories')</span></pre><p id="3820" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们创建了两个非常简单的类，它们包含名称、创建日期和更新日期等字段。我们还添加了 __string__ 方法，当我们在管理区域中使用带有关系对象的模型时，该方法将返回 name 字段，稍后我们将更直观地了解这意味着什么。我们还添加了元类来定义详细名称和详细复数名称，这样在我们的管理区看起来会更好。</p><h1 id="93f6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建模型之间的关系</h1><p id="7bcd" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">所以让我们把使它相互关联的东西加起来。首先看看我们当前的代码，大致了解一下我们得到了什么:</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="2df0" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from django.db</strong> import models<br/><strong class="nd io">from django.utils.translation import</strong> gettext_lazy as _<br/><br/><br/><strong class="nd io">class BlogTag</strong>(models.Model):<br/>    name = models.CharField(verbose_name=_('Title'), max_length=100)<br/>    created = models.DateTimeField(verbose_name=_('Created Date'), auto_now_add=True, blank=True, null=True)<br/>    updated = models.DateTimeField(verbose_name=_('Updated Date'), auto_now_add=True, blank=True, null=True)<br/><br/>    <strong class="nd io">def __str__</strong>(self):<br/>        <strong class="nd io">return</strong> self.name<br/><br/>    <strong class="nd io">class Meta</strong>:<br/>        verbose_name = _('Blog Tag')<br/>        verbose_name_plural = _('Blog Tags')<br/><br/><br/><strong class="nd io">class BlogCategory</strong>(models.Model):<br/>    name = models.CharField(verbose_name=_('Title'), max_length=100)<br/>    created = models.DateTimeField(verbose_name=_('Created Date'), auto_now_add=True, blank=True, null=True)<br/>    updated = models.DateTimeField(verbose_name=_('Updated Date'), auto_now_add=True, blank=True, null=True)<br/><br/>    <strong class="nd io">def __str__</strong>(self):<br/>        <strong class="nd io">return</strong> self.name<br/><br/>    <strong class="nd io">class Meta</strong>:<br/>        verbose_name = _('Blog Category')<br/>        verbose_name_plural = _('Blog Categories')<br/><br/><br/><strong class="nd io">class BlogPost</strong>(models.Model):<br/>    title = models.CharField(verbose_name=_('Title'), max_length=100)<br/>    text = models.TextField(verbose_name=_('Description'), max_length=1000, blank=True)<br/>    created = models.DateTimeField(verbose_name=_('Created Date'), auto_now_add=True, blank=True, null=True)<br/>    updated = models.DateTimeField(verbose_name=_('Updated Date'), auto_now_add=True, blank=True, null=True)<br/>    categories = models.ManyToManyField(BlogCategory)<br/>    tags = models.ManyToManyField(BlogTag)<br/><br/>    <strong class="nd io">def __str__</strong>(self):<br/>        <strong class="nd io">return</strong> self.title<br/><br/>    <strong class="nd io">class Meta</strong>:<br/>        verbose_name = _('Blog Post')<br/>        verbose_name_plural = _('Blog Posts')</span></pre><p id="c37e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，由于我们需要 BlogPost 类和 BlogTag 以及 BlogPost 和 BlogCategory 之间的多对多关系，我们将在 BlogPost 类上定义两个新字段。将这些放在更新字段下:</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="df2c" class="mq lo in nd b gy nh ni l nj nk">categories = models.ManyToManyField(BlogCategory)<br/>tags = models.ManyToManyField(BlogTag)</span></pre><p id="5356" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">配置就这么多了。这就是 Django 的神奇之处，它是如此容易构建。</p><h1 id="878a" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">进行迁移并迁移到数据库</h1><p id="f294" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">现在我们只需要进行迁移，因此在项目的根目录下运行以下命令。确保您在虚拟环境中处于激活状态。</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="9db7" class="mq lo in nd b gy nh ni l nj nk">python manage.py makemigrations<br/>python manage.py migrate</span></pre><p id="c5a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过访问数据库来验证它是否有效。我个人的经验是，它显示它已被迁移，但从来没有这样做，检查一下总是好的！</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8f93252315f07d020a11d61d244406da.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*Pvnf3e-nanV_fOI2BhmKSA.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">迁移后的数据库表</figcaption></figure><p id="b5a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们现在看到了四个新表。我们有两个耦合表<strong class="jx io">main _ blogpost _ categories</strong>和<strong class="jx io"> main_blogpost_tags </strong>。这些很重要，因此它们可以连接实体之间的关系。</p><h1 id="5579" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">将模型注册到管理区</h1><p id="e03d" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">现在，我们将这些模型注册到管理区，这样我们就可以在数据库中添加一些数据，并添加一些关系。目前，我们已经将 BlogPost 添加到主应用程序目录中的<strong class="jx io"> admin.py </strong>文件中:</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="0b00" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from django.contrib</strong> import admin<br/><strong class="nd io">from .models import</strong> BlogPost<br/><br/><br/><strong class="nd io">@admin.register</strong>(BlogPost)<br/><strong class="nd io">class BlogPostAdmin</strong>(admin.ModelAdmin):<br/>    list_display = (<br/>        'id',<br/>        'title',<br/>        'created',<br/>        'updated',<br/>    )</span></pre><p id="3dfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将做类似的事情，但我们需要添加一些其他的东西，以便在管理区更清楚:</p><pre class="lj lk ll lm gt nc nd ne nf aw ng bi"><span id="9548" class="mq lo in nd b gy nh ni l nj nk"><strong class="nd io">from django.contrib import</strong> admin<br/><strong class="nd io">from .models import</strong> BlogTag, BlogCategory, BlogPost<br/><br/><br/><strong class="nd io">@admin.register</strong>(BlogTag)<br/><strong class="nd io">class BlogTagAdmin</strong>(admin.ModelAdmin):<br/>    list_display = (<br/>        'id',<br/>        'name',<br/>        'created',<br/>        'updated',<br/>    )<br/>    list_per_page = 25<br/>    date_hierarchy = 'created'<br/><br/><br/><strong class="nd io">@admin.register</strong>(BlogCategory)<br/><strong class="nd io">class BlogCategoryAdmin</strong>(admin.ModelAdmin):<br/>    list_display = (<br/>        'id',<br/>        'name',<br/>        'created',<br/>        'updated',<br/>    )<br/>    list_per_page = 25<br/>    date_hierarchy = 'created'<br/><br/><br/><strong class="nd io">@admin.register</strong>(BlogPost)<br/><strong class="nd io">class BlogPostAdmin</strong>(admin.ModelAdmin):<br/>    list_display = (<br/>        'id',<br/>        'title',<br/>        'created',<br/>        'updated',<br/>    )<br/>    list_per_page = 25<br/>    date_hierarchy = 'created'</span></pre><p id="28c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们使用快速入门指南中的<strong class="jx io"> list_display </strong>来选择应该显示哪些字段。我们还可以添加一个 exclude 属性，这将默认添加除了字段之外的所有内容<em class="nr">。然后我们有一个简单易懂的<strong class="jx io"> list_per_page </strong>属性，所以我们设置 25，这似乎是每页的合理数量。然后我们还有一个<strong class="jx io"> date_hierarchy </strong>，我们按照创建日期对对象进行排序。</em></p><p id="100c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经完成了管理员配置，我们将转到<a class="ae kt" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a>/admin，输入您的用户名和密码，现在让我们检查一下:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/c0a367a945a29e94e037be7e6732c857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Tj29hYHurMawQVcK3j8Hw.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">Django 仪表板</figcaption></figure><p id="2f27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们看到，我们现在有博客类别，博客文章和博客标签的主要部分。所以让我们从添加博客类别开始:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/accdb68bb9ed1c0dab01165506d4031f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb-g4Rd6-jHTTZA-PBMx2w.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">添加博客类别</figcaption></figure><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/a079db1678e4478feef048038be9e52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Fq5xSJxkqerSriPvHqfeg.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">博客类别列表</figcaption></figure><p id="cd7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们对博客标签做同样的事情:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/57af89ade198aec187559dbc66c0fb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4__bDiue9j-RHrfCpnIpBQ.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">添加博客标签</figcaption></figure><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/41b445577e2207a2f09194c24f84296a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txVIsauNSU4-HzN1QDOhMw.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">博客标签列表</figcaption></figure><p id="e1da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很好，最后一步是添加实际的博客文章，并将这些对象附加到它上面:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/1729fdf2046b91663b689d0c0687d124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tcxuS-wsOpQrbdYmo3C_A.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">添加博客文章</figcaption></figure><p id="9f51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们看到列出了类别和标签。这些列表是多选列表，因此我们可以为博客文章选择许多不同的类别或标签。你可以使用类别作为<strong class="jx io">外键</strong>以及<strong class="jx io">多对一</strong>关系，这样你只能选择一个类别，但是我认为有时候你需要多个类别来适应内容。</p><h1 id="4589" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">摘要</h1><p id="3eff" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">本教程到此为止。希望你觉得有用。我将在未来报道更多的 Django 教程，所以请继续关注我的 LinkedIn 文章:<a class="ae kt" href="https://www.linkedin.com/in/marcuscvjeticanin/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/marcuscvjeticanin/</a></p><p id="7e45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢！:)</p><h1 id="af03" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">资源</h1><ul class=""><li id="23d4" class="ku kv in jx b jy ml kc mm kg nt kk nu ko nv ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/mjovanc/medium-django/tree/relationships" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-django/tree/relationships</a></li><li id="c47b" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://docs.djangoproject.com/en/4.0/topics/db/examples/one_to_one/" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/4.0/topics/db/examples/one _ to _ one/</a></li><li id="5d2d" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://docs.djangoproject.com/en/4.0/topics/db/examples/many_to_one/" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/4.0/topics/db/examples/many _ to _ one/</a></li><li id="8f02" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://docs.djangoproject.com/en/4.0/topics/db/examples/many_to_many/" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/4.0/topics/db/examples/many _ to _ many/</a></li></ul></div></div>    
</body>
</html>