<html>
<head>
<title>Reading and writing a JSON file in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Rust 中读写 JSON 文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reading-and-writing-a-json-file-in-rust-2731da8d6ad0?source=collection_archive---------1-----------------------#2022-03-02">https://blog.devgenius.io/reading-and-writing-a-json-file-in-rust-2731da8d6ad0?source=collection_archive---------1-----------------------#2022-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将向您介绍在 RUST 中解析和编写 JSON 文件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5c52ca70e592f44e6dca018e507395d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXvuphM-RCQUb8fR"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@tengyart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">腾雅特</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名软件开发人员/工程师，我相信您一定听说过 JSON 文件或 JSON 格式。<strong class="jp ir">J</strong>ava<strong class="jp ir">S</strong>script<strong class="jp ir">O</strong>object<strong class="jp ir">N</strong>rotation，也就是众所周知的<strong class="jp ir"> JSON </strong>，是一种流行的轻量级数据交换格式，人和机器都可以轻松地读取和写入。</p><p id="2b37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON 由于其简单性和对不同编程语言的易用性，这些年来越来越受欢迎。JSON 经常被用作模拟数据存储需求的原型工具，或者直接用作数据存储。</p><p id="37aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个 JSON 文件的例子，其中包含了一些关于<strong class="jp ir"> Missy 的饮食</strong>的信息(如果你不知道 Missy 是谁，我邀请你在这里阅读我以前的任何一篇文章<a class="ae lb" href="https://medium.com/@anismousse" rel="noopener">。<strong class="jp ir"> PS:请不要告诉她我公开了她的饮食团</strong></a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">密西日常饮食和行为的秘密信息</figcaption></figure><p id="2351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，该文件包含一个匿名对象，该对象包含两个数组，<strong class="jp ir"> food，</strong>和<strong class="jp ir"> missy_food_schedule。</strong><strong class="jp ir">食物</strong>数组包含了所有大小姐喜欢的食物，<strong class="jp ir"> missy_food_schedule </strong>有大小姐 2022 年 2 月最后三天的饮食时间表以及更多绝密信息。</p><p id="a4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们如何解析这个 JSON 文件来提取一些需要的信息呢？更新这些信息并保存我们的修改？</p><p id="22f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Rust 中，我们可以用两种不同的方法解析 JSON 文件:</p><ul class=""><li id="67c7" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">动态方法:</strong>这里的假设是我们并不完全理解 JSON 文件中的数据，所以我们的程序必须动态地检查任何数据字段的存在和类型。</li><li id="d064" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir">静态方法:</strong>这里假设我们完全理解 JSON 文件中存在的数据，所以我们将使用反序列化来检查任何字段的存在和类型。</li></ul><h2 id="4e0b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma jy mb mc md kc me mf mg kg mh mi mj mk bi translated">JSON 文件的动态解析</h2><p id="ce31" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">为了动态解析 JSON 文件，我们将使用 crate <strong class="jp ir"> serde_json </strong>(更多信息<a class="ae lb" href="https://docs.serde.rs/serde_json/" rel="noopener ugc nofollow" target="_blank">在这里</a>)。这个板条箱需要添加到我们的<strong class="jp ir"> Cargo.toml </strong>的 dependencies 部分下。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用于动态解析 JSON 文件的项目的 Cargo.toml</figcaption></figure><p id="8aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的程序是为了动态解析文件<strong class="jp ir"> missy_secrets.json </strong>而创建的，它将 missy 在 2 月最后三天消耗的食物数量翻倍，以反映更准确的现实:)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用于静态解析 JSON 文件的项目的 main.rs</figcaption></figure><p id="5c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，在使用每个元素之前，我们需要检查它的存在和类型。这会导致一些复杂而冗长的代码行。</p><p id="9a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写和保存 JSON 文件是一个简单的操作，如我们示例中的第 28 行到第 32 行所示。</p><p id="2d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了执行这个程序，我们传递第一个参数<strong class="jp ir"> missy_secrets.json </strong>文件，第二个参数将是在更新 missy 每天消耗的食物数量后创建的新 json 文件的名称(<strong class="jp ir">miss _ secrets _ dynamic . JSON</strong>)。</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="3fea" class="ls lt iq mr b gy mv mw l mx my">cargo run missy_secrets.json miss_secrets_dynamic.json</span></pre><p id="f1db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序执行的结果将是以下 JSON 文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">动态解析后更新的 JSON 文件</figcaption></figure><p id="4741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可能已经意识到的，对象'<strong class="jp ir"> missy_food_shcedule </strong>'中的每一项的'<strong class="jp ir"> quantity </strong>值都如预期的那样增加了一倍。</p><h2 id="aacd" class="ls lt iq bd lu lv lw dn lx ly lz dp ma jy mb mc md kc me mf mg kg mh mi mj mk bi translated">静态解析 JSON 文件</h2><p id="294f" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">当我们确定 JSON 文件结构时，我们<strong class="jp ir">应该</strong>使用静态类型技术来解析我们的文件。静态解析会直接将 JSON 文件中的数据转换成一些 Rust 对象。</p><p id="f8f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这样的目标，我们将使用板条箱<strong class="jp ir"> serde </strong>(更多信息<a class="ae lb" href="https://docs.serde.rs/serde/index.html" rel="noopener ugc nofollow" target="_blank">此处</a>)、<strong class="jp ir"> serde_derive </strong>(更多信息<a class="ae lb" href="https://docs.serde.rs/serde_derive/index.html" rel="noopener ugc nofollow" target="_blank">此处</a>)、<strong class="jp ir"> </strong>和<strong class="jp ir"> serde_json </strong>(用于动态解析 json 文件的板条箱)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用于静态解析 JSON 文件的项目的 Cargo.toml</figcaption></figure><p id="a055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是对同一个 JSON 文件执行静态解析的源代码，和以前一样，该程序的目标是让 Missy 消耗的食物数量翻倍。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用于动态解析 JSON 文件的项目的 main.rs</figcaption></figure><p id="f5a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可能已经意识到的，我们创建了三个结构，在<strong class="jp ir"> missy_secrets.json </strong>文件中每个对象类型一个。</p><p id="1057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从面向对象编程的角度来看，结构实际上等同于类。任何链接到结构或类型的行为都是通过 Rust 的<strong class="jp ir">特征</strong>引入的(在我过去的一篇文章<a class="ae lb" href="https://anismousse.medium.com/why-you-should-learn-rust-fa52d0139b85" rel="noopener">中有更多关于这方面的内容，这里是</a>)。</p><p id="e6a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的代码源中，每个结构前面都有以下属性:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="4d54" class="ls lt iq mr b gy mv mw l mx my">#[derive(Deserialize, Serialize, Debug)]</span></pre><ul class=""><li id="1e81" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">需要<strong class="jp ir">反序列化</strong>特征来将 JSON 字符串解析(即读取)到这个结构中。</li><li id="d1a2" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">需要使用<strong class="jp ir"> Serialize </strong>特征将这个结构格式化(即写入)成一个 JSON 字符串。</li><li id="7f88" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir"> Debug </strong>特性用于在调试跟踪中打印一个结构。</li></ul><p id="9c3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用下面的命令运行这个程序将产生 JSON 文件的更新版本。</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="74ca" class="ls lt iq mr b gy mv mw l mx my">cargo run missy_secrets.json miss_secrets_static.json</span></pre><p id="7093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以看到，这个例子更加简洁。创建一些结构来表示 JSON 文件中的每个对象，这允许我们直接提取所有数据，而无需检查任何元素的存在或类型。</p><p id="7bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法更具可塑性、可维护性，并且易于扩展。</p><p id="a0ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们更改 JSON 文件中的一个现有对象，我们只需要在程序中表示该对象的结构中做同样的修改。</p><p id="c656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在 JSON 结构中添加一个新元素，我们只需要创建一个新的结构来表示这个新元素。</p><h2 id="872d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma jy mb mc md kc me mf mg kg mh mi mj mk bi translated">结论</h2><p id="636d" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">由于多样化的板条箱，在 Rust 中利用 JSON 文件是一项可实现的任务，使我们的生活更加轻松。</p><p id="6bb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写 JSON 文件是一项简单的任务，但是当我们解析和利用现有 JSON 文件中的一些信息时，复杂性就显现出来了。</p><p id="4770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该总是以静态解析 JSON 文件为目标，假设我们完全理解文件中存在的各种项目以及与每个元素相关联的类型。</p><p id="db2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文提到 JSON 文件通常是模拟任何数据存储需求的良好起点。Rust 确实有一些非常酷的板条箱，可以帮助你与 Redis(板条箱<a class="ae lb" href="https://docs.rs/redis/latest/redis/" rel="noopener ugc nofollow" target="_blank"> redis </a>)、PostgresSQL(板条箱<a class="ae lb" href="https://docs.rs/postgres/0.15.2/postgres/" rel="noopener ugc nofollow" target="_blank"> postgres </a>)等数据库进行交互。</p><p id="1f84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，欢迎鼓掌、订阅、评论！！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/fe818324b4b5cbd72b1122c99932f23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hk-AKbfaRQVRJ5dtQZavBA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">米西幸福地不知道我与世界分享了她的饮食秘密</figcaption></figure><h2 id="db74" class="ls lt iq bd lu lv lw dn lx ly lz dp ma jy mb mc md kc me mf mg kg mh mi mj mk bi translated">资源</h2><p id="cdfc" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我过去关于铁锈的文章:<a class="ae lb" href="https://medium.com/@anismousse" rel="noopener">这里</a>。</p><p id="71d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON 官方页面:<a class="ae lb" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="7582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON 的基本介绍:<a class="ae lb" href="https://www.w3schools.com/js/js_json_intro.asp" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="a1ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rust 的结构:<a class="ae lb" href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" rel="noopener ugc nofollow" target="_blank">此处为</a>。</p><p id="d939" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">铁锈的特性:<a class="ae lb" href="https://doc.rust-lang.org/book/ch10-02-traits.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>