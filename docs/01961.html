<html>
<head>
<title>How MVC Frameworks Taught Us Bad Habits — Part 1 ActiveRecord</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC 框架如何教会我们坏习惯——第 1 部分 ActiveRecord</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-mvc-frameworks-taught-bad-habits-part-1-activerecord-6f2858efcc16?source=collection_archive---------12-----------------------#2020-07-15">https://blog.devgenius.io/how-mvc-frameworks-taught-bad-habits-part-1-activerecord-6f2858efcc16?source=collection_archive---------12-----------------------#2020-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="647f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让我们回顾过去，试图弄清楚框架是如何教会我们不去注意错误的事情的。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/f3f105aeac59093f67f89852b0b23852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*TsclgsI38_jAVCYU00HSRA.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">坏习惯</figcaption></figure><h1 id="1811" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="ded8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们回到 200X。这是 MVC 框架的繁荣时期。Ruby on Rails，Django，ZendFramework，Spring 等。不同编程语言中的各种框架创建、复制并改进了各种特性。</p><p id="1099" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">框架在 web 开发中迈出了巨大的一步。他们给这个行业带来了很多好的东西，禁止为开发者做坏事。使用框架让初学者很容易开始。我的网页开发职业生涯始于 2007 年。几年来，我一直在使用这些框架，而没有考虑这些框架提供的架构和工具。</p><p id="24dd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们如此习惯于使用框架，以至于我们很难想象可能会有任何替代选项。他们无意中教会我们依赖他们使用的方法。问题是适用于中小型应用的<strong class="li io">方法并不适用于大型应用</strong>。反之亦然。因此，如果您正在处理中小型应用程序，您没有什么可担心的。但是，如果您觉得您的应用程序已经缺少了以前的灵活性，欢迎您。</p><p id="ca5e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我想分享一些我看到的框架无法有效处理的大型应用程序的缺点。我希望你从不同的角度看待熟悉的事物</p><p id="a632" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们从 ActiveRecord 模式开始。并不是所有的框架都使用它。因此，如果您最喜欢的框架使用存储库模式，那么一切都很好。你可以跳过这篇文章。</p><h1 id="1609" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">我们为什么喜欢 ActiveRecord</h1><p id="186d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">还记得在 15 分钟内创建一个博客有多酷吗？当时，许多框架提供了 CLI 甚至 Web 界面，用于在一个动作中创建模型、控制器和视图。你得到了一个和这个相似的骨架。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="8c5c" class="mm kp in mi b gy mn mo l mp mq">def<!-- --> <!-- -->create<br/>  <strong class="mi io">@user</strong> <!-- -->= User.new(user_params)<br/>  if<!-- --> <strong class="mi io">@user</strong>.save<br/>    redirect_to <strong class="mi io">@user<br/>  </strong>else<br/>    render <em class="mr">'new'<br/>  </em>end<br/>end</span></pre><p id="fc08" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe ms mt mu mi b">Convention Over Configuration</code>和<code class="fe ms mt mu mi b">Keep It Simple</code>是主要规则。构建这样一个简单代码的基础是 ActiveRecord。不是所有，但是非常多的框架使用和使用活动记录，不提供任何替代</p><p id="51ec" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在你可以在各种框架指南中找到非常相似的代码。代码简短而优雅。那么 ActiveRecord 有什么问题呢？</p><h1 id="5b08" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">ActiveRecord 怎么了</h1><p id="87c9" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">乍一看，非常方便和直观。实际上<strong class="li io">当你处理简单的应用程序时，它非常好用。</strong></p><p id="1601" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">但是在现实生活中，创建新用户或订单不仅仅是写入数据库。如果我们谈论的是用户创建——这是一个复杂的注册过程。让我们估计一下在注册过程中可能会出现哪些附加操作:</p><ul class=""><li id="47dc" class="mv mw in li b lj mc lm md lp mx lt my lx mz mb na nb nc nd bi translated">保存头像</li><li id="099a" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">来自第三方来源的预填充数据</li><li id="ea83" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">重要的验证—呼叫第三方</li><li id="269f" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">不同的注册场景——通过 FB 注册、通过邀请函注册、通过表格注册等</li><li id="3492" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">附加验证—电话号码验证、信用卡的分配和验证</li><li id="b8dc" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">黑名单检查</li><li id="6a71" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">附加 post 逻辑——通知其他服务关于新用户的信息</li><li id="7dc1" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">等等</li></ul><p id="bc34" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">订单创建、预约安排、甚至邮件创建等——在现实生活中，业务逻辑比乍看起来要复杂得多。ActiveRecord 如何应对所有这些商业规则？</p><h2 id="3ac8" class="mm kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">扩展您的验证规则</h2><p id="86de" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这些框架提供了广泛的验证能力。您的验证规则像杂草一样生长，试图跟上业务规则。(PHP 和 Yii1)</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="7b82" class="mm kp in mi b gy mn mo l mp mq">&lt;?php <br/><br/>class Yii1Model <br/>{<br/>    public function rules()<br/>    {<br/>        return array(<br/>            // Required fields<br/>            array('customer', 'required', 'message' =&gt; Yii::t('rezdy', 'Please create or select a customer'), 'on' =&gt; 'create, update'),<br/><br/>            // Safe on booking form<br/>            array('customer, customer[mailingAddress], additionalFields, paymentOption, payFullAmount', 'safe', 'on' =&gt; 'bookingForm, partners'),<br/>            array('customerAgreedToTermsAndConditions', 'safe', 'on' =&gt; 'bookingForm'),<br/><br/>            // Safe on create and update<br/>            array('status, surcharge, sourceChannel, agentUserName', 'safe', 'on' =&gt; 'create, update'),<br/>            array('internalNotes, resellerComments, resellerReference, agentUserName', 'safe', 'on' =&gt; 'partners'),<br/><br/>            // Safe on commissions report<br/>            array('startTime, endTime, dateRange, resellerId, reconciled, lastInvoice', 'safe', 'on' =&gt; 'commissionDetails'),<br/><br/><br/>            // Top level fields with children<br/>            array('customer, items, paymentDetails, creditCard', 'safe'),<br/>            array('status, searchString, startTime, endTime, dateRange, productId, paymentStatus, entityState', 'safe', 'on' =&gt; 'search'),<br/><br/>            // Special fields<br/>            array('date', 'date'),<br/>            array('customer[phone], customer[mobile]', 'match', 'pattern' =&gt; '/^([0-9+() -])+$/'),<br/><br/>            // Trim<br/>            array('comments, internalNotes, voucherCode, resellerComments, resellerReference', 'filter', 'filter' =&gt; [$this, 'sanitize']),<br/><br/>            // Email validation<br/>            array('customer[email]', 'ext.validators.EmailValidator', 'allowEmpty' =&gt; true),<br/><br/>            //Check for TC agreement<br/>            array('customerAgreedToTC', 'ext.validators.EConditionalValidator', 'conditionalRules' =&gt; array('companySettings[explicitAgreementToTermsAndPolicy]', 'compare', 'compareValue' =&gt; true), 'rule' =&gt; array('required'), 'on' =&gt; 'bookingForm'),<br/>            // Max length<br/>            array('email, customer[email]', 'length', 'max' =&gt; 254),<br/>            array('customer[phone]', 'length', 'max' =&gt; 25),<br/>            array('customer[firstName], customer[lastName], customer[mailingAddress][addressLine], customer[mailingAddress][addressLine2], customer[mailingAddress][city], customer[mailingAddress][state]', 'length', 'max' =&gt; 200),<br/>            array('customer[mailingAddress][countryCode]', 'length', 'max' =&gt; 4),<br/>            array('customer[mailingAddress][postCode]', 'length', 'max' =&gt; 10),<br/>        );<br/>    }<br/>}</span></pre><p id="c3b7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果您的模型处理嵌套或相对模型，我们还可以添加一些选项。Ruby on Rails</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="0e0c" class="mm kp in mi b gy mn mo l mp mq"><strong class="mi io"># </strong><a class="ae nu" href="https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html" rel="noopener ugc nofollow" target="_blank">https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html</a><strong class="mi io"><br/>class Member &lt; ActiveRecord::Base</strong><br/>  has_many :posts<br/>  accepts_nested_attributes_for :posts, allow_destroy: <strong class="mi io">true, </strong> update_only: <strong class="mi io">true</strong>, reject_if: proc { |attributes| attributes['title'].blank? }<br/><strong class="mi io">end</strong></span></pre><p id="83e0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果你需要一些更新后的逻辑，你可以用</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="b1e7" class="mm kp in mi b gy mn mo l mp mq">class<!-- --> <!-- -->PictureFile &lt; ApplicationRecord<br/>  after_commit <strong class="mi io">:delete_picture_file_from_disk</strong>, on: <strong class="mi io">:destroy</strong></span><span id="9e99" class="mm kp in mi b gy nv mo l mp mq">  def<!-- --> <!-- -->delete_picture_file_from_disk<br/>    if<!-- --> <!-- -->File.exist?(filepath)<br/>      File.delete(filepath)<br/>    end<br/>  end <br/>end</span></pre><p id="96b3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">你的模特知道如何</p><ul class=""><li id="bb9c" class="mv mw in li b lj mc lm md lp mx lt my lx mz mb na nb nc nd bi translated">验证不同场景的用户输入</li><li id="2283" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">将更新保存到数据存储</li><li id="a17f" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">找到适合不同场景的模型</li><li id="0d31" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">更新甚至验证相关模型</li><li id="f368" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">制定一些更新后的逻辑(通常与当前领域没有直接关系)</li></ul><p id="c8d5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我错了，请纠正我，但是一个非常常见的模式是这样的</p><ul class=""><li id="b60d" class="mv mw in li b lj mc lm md lp mx lt my lx mz mb na nb nc nd bi translated">你需要一个新功能</li><li id="0194" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">您在数据库中创建新表</li><li id="3403" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">在您的代码库中创建一个允许进行 CRUD 操作的模型</li><li id="64c8" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">您不断地将与该领域模型相关的功能添加到单个类中</li></ul><p id="a00c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果您的项目继续发展，新的需求定期出现，几个月后您会发现您的<code class="fe ms mt mu mi b">models </code>文件夹有 200 多个类。你所有的模特都互相认识。</p><p id="6d21" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">毕竟，你会得到像<a class="ae nu" href="https://gist.github.com/radzserg/79a2eaeacd247fec2c12128f60b9b4e3" rel="noopener ugc nofollow" target="_blank">这个</a>一样的怪物。只是它太大了，不能放在这里，但看看吧。承认这一点有点尴尬，但这部作品的作者是我🤫。写于 2014 年左右。但是我见过更大的模型。</p><p id="5d8b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如此巨大的<strong class="li io">模型打破了单一责任原则</strong>。方法的数量不再允许我们的大脑有效地使用它(找出<a class="ae nu" href="https://medium.com/@radzserg/why-is-it-hard-for-a-brain-to-understand-spaghetti-code-278d9b5d760c" rel="noopener">为什么大脑很难理解意大利面条代码</a>)。最后，你的班级有 1K 或 10K 线已经不重要了。甚至考虑到你可以一直处理 Ctrl+F，这种方法的主要问题- <strong class="li io">一切都是紧密耦合的</strong>。现在你开始意识到你的代码极度缺乏灵活性(虽然你仍然可以抵制它)。你需要检查更多的地方，以确保你不会打破任何东西。问题是，这是一个相当典型的代码，在 2020 年的现在很常见。当一个团队和代码成长时，你开始理解现在的变化需要更多的时间。而<strong class="li io">当初很方便的现在缺乏灵活性</strong>。</p><h1 id="c969" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">ActiveRecord 只是一个工具</h1><p id="f600" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">您曾经不得不将应用程序从一个框架移植到另一个框架吗？平时那么费劲，什么都从零开始更容易。而这些问题的罪魁祸首就是紧耦合模型。</p><p id="9878" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">像<code class="fe ms mt mu mi b">AcriveRecord</code>这样的模式已经成为一些框架中事实上的标准。我们没有围绕业务规则构建领域层，而是按照提供的指南，围绕提供的工具(如 ActiveRecord)构建业务规则。您的业务规则不关心您是使用 ActiveRecord 还是 Repository 模式，您是使用 Mysql 还是 DynamoDB。<strong class="li io">业务规则仍然是您系统的一个组成部分</strong>，而活动记录只是一个工具。作为开发人员，我们可以改变保存数据的方式，我们可以改变存储方式，但我们不能改变业务规则。生意决定规则。我们为这些业务规则构建应用程序。</p><p id="781e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">业务规则不应该依赖于工具。您必须首先设计实现您的业务规则的高层组件。然后才拿起低级工具。而不是相反。数据库只是一个你可以改变的细节。</strong></p><h1 id="2f61" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">如何正确地做它</h1><p id="8eee" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">假设您需要实现应用程序中处理订单的部分。订单是在上一步中创建的，现在您需要付款。您有以下要求:</p><ul class=""><li id="b35d" class="mv mw in li b lj mc lm md lp mx lt my lx mz mb na nb nc nd bi translated">您需要验证用户输入</li><li id="f042" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">您需要重新计算总金额，并确保它与我们在上一步中显示的金额相匹配</li><li id="a903" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">通过 X 支付网关处理支付</li><li id="8fab" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">更新数据库中的订单状态</li><li id="e503" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">将新订单通知仓库模块</li><li id="4596" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">为客户发送收据</li></ul><p id="2e68" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">与其在数据库中创建一个新表和相关的 ActiveModel，不如让我们用这些高层次的需求做一个草稿</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3ddb" class="mm kp in mi b gy mn mo l mp mq">class class OrderService {<br/>    public Order processOrder(Order order) {<br/>        <em class="mr">// validate input<br/>        // re-calculate total amount with TAX and make sure that the match previous price<br/>        // process payment<br/>        // update order state in DB<br/>        // notify warehouse<br/>        // send receipt<br/>    </em>}</span><span id="2495" class="mm kp in mi b gy nv mo l mp mq">    public createOrder(...)  {}<br/>}</span></pre><p id="ab05" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如您所见，保存数据只是众多步骤中的一步。高层操作和它们之间的相互作用现在更重要了。我想推迟保存数据的组件的实现。我该怎么做？</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="6dd7" class="mm kp in mi b gy mn mo l mp mq">public class OrderService {<br/>    priivate final OrderRepository repository;<br/>    public OrderService(OrderRepository repository) {<br/>        this.repository = repository;<br/>    }<br/><br/>    public Order processOrder(Order order) {<br/>        <em class="mr">this.orderValidator.validate(order);<br/>        Long total = this.orderPrice.calculateTotal(order);<br/>        if (!total.equal(order.getTotal())) {<br/>            throw new OrderPriceException("Price has been changed")<br/>        }<br/>        try {<br/>            this.stripePaymentGateway.processOrder(order);<br/>        } catch (StripeException exception) {<br/>            // <br/>        </em>}</span><span id="9efc" class="mm kp in mi b gy nv mo l mp mq"><em class="mr">        </em><strong class="mi io"><em class="mr">order = </em>this.repository.confirm(order);</strong></span><span id="1c1e" class="mm kp in mi b gy nv mo l mp mq">        this.applicationEventPublisher.publishEvent(new OrderConfirmed(order));<em class="mr"><br/>        this.customerNotifier.sendOrderReceipt(order);<br/>    </em>}<br/>    public createOrder(...)  {}<br/>}</span></pre><p id="9a18" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">其中 OrderRepository 是一个接口，甚至不是真正的实现。我使用了<a class="ae nu" href="https://martinfowler.com/eaaCatalog/repository.html" rel="noopener ugc nofollow" target="_blank">存储库</a>模式。好了，现在我准备好测试我的订单服务了。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="550f" class="mm kp in mi b gy mn mo l mp mq">@ExtendWith(MockitoExtension.class)<br/>public class ChargeServiceTest {<br/><br/>    @Mock<br/>    private OrderRepository orderRepository;<br/><br/>    @InjectMocks<br/>    private OrderService orderService;<br/><br/>    @Test<br/>    public void testProcessOrderSuccess() {<br/>        // test validation<br/>        // test order price recalculation<br/>        // etc<br/>        <em class="mr">when</em>(orderRepository.confirm(order)).thenReturn(order);<br/>    }<br/>}</span></pre><p id="af34" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们能够构建和测试实现业务规则的高级组件。</p><p id="74e9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">注:</strong></p><ul class=""><li id="f005" class="mv mw in li b lj mc lm md lp mx lt my lx mz mb na nb nc nd bi translated">我不需要数据库或与 DynamoDB 或任何其他存储的集成来做到这一点</li><li id="2fc9" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">代码不依赖于框架或特定的库来处理数据库。</li><li id="e71c" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">这很容易测试。我们将 OrderRepository 视为另一个单元。它将接受另一项测试。由于我们不需要将数据写入真实的数据库，所以测试是单元的和快速的。</li><li id="96a3" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">组件的结构使用对业务和开发人员来说很清楚的通用语言</li></ul><p id="8377" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我们想将我们的应用程序迁移到新的框架中，我们只需照原样复制代码，它就会继续工作。它没有任何硬编码的依赖关系。</p><p id="fac4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">等等，但是我们实际上需要将数据保存到存储器中。我们需要一个真正的实现。真的吗？哦，对了。好了，补充一下吧。这些天你更喜欢什么？Mysql 或 DynamoDb</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3b1f" class="mm kp in mi b gy mn mo l mp mq"><a class="ae nu" href="http://twitter.com/Repository" rel="noopener ugc nofollow" target="_blank">@Repository</a><br/>public class MysqlOrderRepository implements OrderRepository {<br/> <br/>    <a class="ae nu" href="http://twitter.com/PersistenceContext" rel="noopener ugc nofollow" target="_blank">@PersistenceContext</a><br/>    private EntityManager entityManager;</span><span id="127b" class="mm kp in mi b gy nv mo l mp mq"><a class="ae nu" href="http://twitter.com/Transactional" rel="noopener ugc nofollow" target="_blank">    @Transactional</a><br/>    public void confirm(Order order) {<br/>        order.setConfirmed(true);         <br/>        this.entityManager.persist(person);<br/>    } <br/>}</span></pre><h1 id="b5d9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><ul class=""><li id="f3a1" class="mv mw in li b lj lk lm ln lp nw lt nx lx ny mb na nb nc nd bi translated">尽管 ActiveRecord 违反了 SRP 并倾向于耦合组件，但它仍然是中小型应用程序的好选择。</li><li id="6656" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">ActiveRecord 只是一个工具。始终关注备选方案，并根据业务需求选择您需要的方案。</li><li id="b15c" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">尽管存储库和实体更好😛</li><li id="bba1" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">基于业务规则设计应用程序。高层重要，低层细节可以延后。</li></ul></div></div>    
</body>
</html>