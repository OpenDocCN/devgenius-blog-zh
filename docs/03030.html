<html>
<head>
<title>Micro Frontends — Macro Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微观前端—宏观挑战</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/micro-frontends-macro-challenges-7f0918bc5b?source=collection_archive---------3-----------------------#2020-09-22">https://blog.devgenius.io/micro-frontends-macro-challenges-7f0918bc5b?source=collection_archive---------3-----------------------#2020-09-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk"><p id="2a97" class="jl jm in bd jn jo jp jq jr js jt ju dk translated"><em class="jv">或者，我是如何在现实世界<em class="jv">中实现微前端</em>并幸存下来讲述它的</em></p></blockquote><figure class="jx jy jz ka kb kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi jw"><img src="../Images/8c0949aed2dc4b1d0e39e3190c4619fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEEzMP3Il6iBIn2Jeyq_zA.jpeg"/></div></div></figure></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="5e09" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">作为开发人员，您可能听说过微服务架构。<br/>每个人都喜欢并理解微服务的好处，但微服务通常是一个“后端话题”，前端开发人员并没有真正参与其中。<br/>这是事实，直到几年前微前端架构出现。事实上，在技术趋势流行指南<a class="ae ln" href="https://www.thoughtworks.com/radar" rel="noopener ugc nofollow" target="_blank"> ThoughtWorks Radar </a>中的当前状态是<a class="ae ln" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" rel="noopener ugc nofollow" target="_blank">“采用”</a>，这是最高的推荐级别。作为一名全栈开发者，我对前端世界有一种吸引力，爱上了微前端概念。</p><p id="56ba" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">一旦我和我的团队有机会创建第一个微前端，我们就抓住了这个机会。</p><p id="7d1a" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">在本文中，我将首先介绍使用微前端架构的优势，以及在现实世界中的大型系统上构建微前端所面临的挑战。</p><h1 id="06f0" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">那么，什么是微前端呢？</h1><figure class="mm mn mo mp gt kc"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d157" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">在这篇<a class="ae ln" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">文章</a>中，Martin Fowler这样定义微前端:</p><blockquote class="ms mt mu"><p id="2764" class="kq kr mv ks b kt ku kv kw kx ky kz la mw lc ld le mx lg lh li my lk ll lm ju ig bi translated"><em class="in">“一种架构风格，其中可独立交付的前端应用程序被组合成一个更大的整体”</em></p></blockquote><p id="ce2e" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">在我看来，微前端是一种允许你在<strong class="ks io">客户端</strong>应用中使用微服务架构(具有所有好处)的架构。</p><h1 id="2c6c" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">优势及其对我们的作用</h1><figure class="mm mn mo mp gt kc"><div class="bz fp l di"><div class="mz mr l"/></div></figure><p id="4a79" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">让我们添加一些背景知识。想象你在一家有很多项目的大公司工作。其中一个项目，也就是你正在做的项目，已经成为一个巨大的前端:复杂，需要满足许多需求，有许多特性。<br/>monolith应用程序内部的业务焦点经常变化，因此项目代码库不断增长，结果是应用程序的不同部分获得了或多或少的开发焦点。</p><p id="5edd" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">因此，我们选择在monolith应用程序上开发这个新的XL功能，作为一个微前端。微前端是一个独立的存储库，monolith应用程序将是微前端的托管应用程序。</p><p id="4f83" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">现在我们在同一页上，让我们从我的角度谈谈微前端的优势，以及我们如何着手实施它。</p><p id="5f87" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">独立团队</strong></p><p id="8cbc" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我的团队有近10名成员，包括全栈开发人员、QA工程师和一名产品经理。<br/>假设我们已经开发了新的XL功能，作为monolith应用程序的一部分。我们可能会从团队中选择3名成员，并给他们分配该功能。但是这三个成员仍然对monolith应用程序负责，因此，他们会被monolith应用程序其他部分的背景噪音，特别是bug分散注意力。</p><p id="c627" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">微前端的团队是一个独立的团队，比开发和维护monolith应用程序所需的团队小得多。这个较小的团队在日常工作中完全专注于新项目。</p><p id="551b" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">how<br/></strong>我们创建了一个新的更小的团队，包含2名开发人员、QA工程师和产品经理，从头开始构建微前端。由于独立团队可以完全专注于微前端，因此微前端的建设进度快速而高效。另外，独立团队也是一个自治团队，包含2名全栈开发人员，因此该团队可以在不依赖其他团队的情况下完成工作。</p><p id="b981" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">简单有序的代码库</strong></p><p id="8ffd" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">什么<br/> </strong>与整体相比，微前端本身要小得多，也更容易管理。此外，微前端从遗留代码全新开始。</p><p id="187a" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我们创建了一个比monolith小得多的新存储库，而不是进一步扩展monolith。我们的MF已经在生产中成功运行，我们设法保持它的代码库小、简单和清晰。</p><p id="73a9" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">独立部署和减少构建时间</strong></p><p id="aa47" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">什么<br/> </strong>微前端构建和部署是独立的过程，因此发布周期可以比monolith应用程序短。<br/>此外，像许多自然现象一样，虫子是生活中的事实。它们可能会随着包含任何变更的每个发行版潜入您的系统。更小的更集中的发布加上积极的测试套件降低了部署风险。</p><p id="1855" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我们为微前端创建了一个新的构建和部署流程。在第一个版本中，我们必须同时部署monolith和micro frontend，但是在那之后，micro frontend版本就独立了。</p><p id="a43f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">(为你)使用最好的技术</strong></p><p id="075b" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">选择“最适合你的技术”可能听起来很明显，但在大型项目中，你通常不会改变核心技术，例如用React替换Angular或用Mobx替换Redux。<br/>新技术不断涌现，micro frontend允许您在不影响系统其他部分的情况下，单独并逐步集成这些新技术。新技术可能是尖端技术，但不一定，它应该是最适合你需求的技术。<br/>即使它与monolith应用程序是不同的技术。</p><p id="4dcb" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">方法<br/> </strong>我们选择用我们认为最适合这个项目的方式来实现微前端。<br/>例如，我们可以自由地将样式组件用于我们的样式，并将MobX用作状态管理器——在monolith应用程序中没有使用这些组件，我们有CSS模块和Redux。</p><p id="a0c2" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">所有这些优势和我们所做的事情使我们能够快速前进，更加灵活地应对变化，并设计和执行更好的新业务渠道解决方案。</strong></p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="98c2" class="lo lp in bd lq lr na lt lu lv nb lx ly lz nc mb mc md nd mf mg mh ne mj mk ml bi translated">挑战以及我们如何面对挑战</h1><figure class="mm mn mo mp gt kc"><div class="bz fp l di"><div class="mz mr l"/></div></figure><p id="a477" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我们选择通过Javascript方法使用运行时集成来实现微前端架构。monolith应用程序在运行时集成了微前端，这意味着微前端的变化会立即出现在monolith应用程序上。我们不需要部署monolith应用程序来查看微前端的变化，就像在其他方法(如构建时集成)中一样。<br/>有更多有效的方法，每种方法都有其优点，重要的是选择适合您需求的方法，所有方法和优点都可以在这里<a class="ae ln" href="https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches" rel="noopener ugc nofollow" target="_blank">找到</a>。<br/>此外，为了完全独立于monolith应用程序，我们决定使用自己的后端和数据库实现微前端服务——BFF，后端用于前端技术。</p><p id="f175" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">那么，让我们来谈谈我们所面临的挑战。</p><p id="8c5f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">在微前端实施用户权限和角色。</strong></p><p id="cb91" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">这是我们面临的最具挑战性的话题。<br/>微前端位于monolith应用程序内部，它拥有与monolith应用程序中相同的角色和权限的相同用户。<br/>例如，有编辑权限的用户可以在微前端进行编辑，只有查看权限的用户不能。经过几次讨论，我们为这个话题提出了三种不同的解决方案。</p><p id="7606" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">授权服务<br/> 这个解决方案是最灵活的解耦解决方案，它需要创建一个完全独立的服务来负责我们项目中的授权。<br/>该服务将为monolith和micro frontend提供授权服务。</p><p id="d8d1" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">包括用户对JWT令牌的许可<br/> </strong>微前端与monolith应用程序位于同一个域中，JWT令牌(正如我们所使用的)保存在浏览器cookie中。在此解决方案中，我们希望在JWT令牌中包含用户权限。我们可以用monolith应用程序中的权限对令牌进行编码，并在微前端用相同的密钥对其进行解码，以验证用户是否得到授权。</p><p id="80c6" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">授权中间件<br/> </strong>在这个解决方案中，我们计划在微前端后端创建一个授权中间件。客户端对后端的每个API调用都被转发到monolith的授权后端。这种方法防止了微前端后端服务的授权逻辑的任何复制。</p><p id="77d9" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我们最终选择了第三种“授权中间件”解决方案。<br/>第一种解决方案需要在monolith应用程序上做大量工作，出于显而易见的原因，我们希望避免这种情况。<br/>第二个解决方案被拒绝，因为由于monolith的广泛授权模式，我们无法估计JWT令牌将有多大<br/>第三个解决方案和选择的解决方案更容易实现，我们可以准确估计它需要多长时间而不会出现意外。</p><p id="0357" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">管理微前端和monolith app之间的共享数据。</strong></p><p id="6e48" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">尽管我们很想避免项目之间的耦合，但我们发现由于产品需求，这真的很难做到。事实上，我们发现自己面临着一个巨大的困境:什么对我们更重要？耦合服务并保持其简单性与分离服务以获得部署的独立性。<br/>我们考虑了两个选项:<br/>第一个选项，为monolith应用程序和micro frontend使用相同的数据库，以获得从两个应用程序使用共享数据的能力。<br/>第二种选择，从monolith的数据库中克隆一小部分到微前端的数据库中，并使monolith的数据库和我们的数据库始终保持同步。<br/>经过几次讨论，我们意识到独立部署对我们来说更有价值。因此，我们选择了第二个选项，使用迁移脚本克隆数据库，并使用我们已经了解的事件基础平台Kafka来更新数据库。</p><p id="078b" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io">微前端和monolith app之间UX设计的一致性。</strong></p><p id="a085" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">最初，我们计划在两个应用程序中使用我们的共享组件UI库。这将帮助我们坚持我们的monolith应用程序设计，并节省我们的开发时间。我们的UI库不是最好的解决方案，组件的设计也有点“过时”。当我们试图从微前端使用这个库时，我们意识到这个UI库差不多有5MB重。这个5MB是微前端重量的5倍多(它的重量不到1MB)。我们可以努力减小UI库的大小。然而，在过去，在微前端实现之前，我们确实讨论过重新设计monolith应用程序，但它从未比其他任务具有足够高的优先级，因此我们从未找到时间来做这件事。</p><p id="5b28" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">这让我们开发了一个新的酷炫设计的微前端。微前端的新设计对客户来说是完美的，反馈非常积极，因为“新的更好！”。<br/>产品经理对新的UI设计非常着迷，并要求我们更改monolith应用程序中的UI设计，以与微前端保持一致。</p><p id="dbfb" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated"><strong class="ks io"> <em class="mv">微前端与monolith app之间的通信。</em> </strong></p><p id="e0f4" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">正如我之前提到的，我们知道我们必须在服务之间进行通信。两个服务之间有几种通信方式，比如浏览器自定义事件、地址栏参数和客户端的props注入。在服务器端，还有一些最为人所知的是服务器到服务器的API和事件。</p><p id="7154" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">作为我们在设计阶段努力的直接结果，我们只需要更新整个建筑的很小一部分。在客户端，我们选择从monolith应用程序向微前端(反应方式)注入props，以便限制和封装它们之间的依赖关系。在服务器端，我们选择从微前端发布事件，并使用Kafka events从monolith应用程序中消费它。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="c048" class="lo lp in bd lq lr na lt lu lv nb lx ly lz nc mb mc md nd mf mg mh ne mj mk ml bi translated">综上</h1><p id="61f9" class="pw-post-body-paragraph kq kr in ks b kt nf kv kw kx ng kz la lb nh ld le lf ni lh li lj nj ll lm ju ig bi translated">我意识到建立一个微前端的理由必须是强大的，非常合理的，因为我们在项目之间确实有一些耦合，耦合会使事情变得更加困难，因为monolith应用程序的变化需要微前端的变化，反之亦然。</p><p id="c10f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">然而，微前端方法帮助我们作为一个团队实现了启动这个项目的主要目标——在monolith应用程序中快速开发与新业务通道相关的新功能。此外，绿地项目允许您自由选择最适合您需求的技术。这个项目确实提供了个人知识和技能成长的机会，也让我的团队在创新方面处于更好的位置。</p><figure class="mm mn mo mp gt kc"><div class="bz fp l di"><div class="mz mr l"/></div></figure><p id="05a6" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ju ig bi translated">我希望你喜欢阅读，我的经历让你重新思考，哪怕是一点点，关于你系统的当前架构。</p></div></div>    
</body>
</html>