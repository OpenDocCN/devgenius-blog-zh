<html>
<head>
<title>Functional JavaScript — Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript —生成器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-javascript-generators-d7a4de661c9c?source=collection_archive---------5-----------------------#2020-11-22">https://blog.devgenius.io/functional-javascript-generators-d7a4de661c9c?source=collection_archive---------5-----------------------#2020-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9bd4dcd6dbd772020b58d5b0fcb555bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CNOu92khBrMj219A"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@jeisblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·黑眼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ae05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是一种函数式语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript生成器。</p><h1 id="4785" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回调地狱</h1><p id="be2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有些函数像:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="52fe" class="mn lc iq mj b gy mo mp l mq mr">let sync = () =&gt; {<br/>  //..<br/>}<br/>let sync2 = () =&gt; {<br/>  //...<br/>}<br/>let sync3 = () =&gt; {<br/>  //...<br/>}</span></pre><p id="c7aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且每个函数都是同步的，那么我们可以一个一个地调用它，用我们的方式组合它们。</p><p id="0143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果它们是异步的，那么我们就不能逐个调用。</p><p id="a22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数可能有一个回调函数，让我们在得到结果时调用这个回调函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c309" class="mn lc iq mj b gy mo mp l mq mr">let async1 = (fn) =&gt; {<br/>  //...<br/>  fn( /* result data */ )<br/>}<br/>let async2 = (fn) =&gt; {<br/>  //...<br/>  fn( /* result data */ )<br/>}<br/>let async3 = (fn) =&gt; {<br/>  //...<br/>  fn( /* result data */ )<br/>}</span></pre><p id="bcc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想按顺序调用它们，我们必须这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3fe9" class="mn lc iq mj b gy mo mp l mq mr">async1(function(x) {<br/>  async2(function(y) {<br/>    async3(function(z) {<br/>      //...<br/>    });<br/>  });<br/>});</span></pre><p id="4ce5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，我们的代码中有很多嵌套。</p><p id="2673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得把这个弄干净。</p><h1 id="e543" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机</h1><p id="8116" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用生成器清理这些代码。</p><p id="5dcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个生成器函数，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f04c" class="mn lc iq mj b gy mo mp l mq mr">function* gen() {<br/>  return 'foo';<br/>}</span></pre><p id="8df0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器函数由关键字<code class="fe ms mt mu mj b">function*</code>表示。</p><p id="184f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用它来创建一个生成器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f142" class="mn lc iq mj b gy mo mp l mq mr">let generator = gen();</span></pre><p id="5205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">generatorResult</code>对象有<code class="fe ms mt mu mj b">next</code>方法来返回我们生成的值。</p><p id="ce44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回的对象具有<code class="fe ms mt mu mj b">value</code>和<code class="fe ms mt mu mj b">done</code>属性。</p><p id="79ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5bc0" class="mn lc iq mj b gy mo mp l mq mr">generator.next().value</span></pre><p id="dcef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe ms mt mu mj b">'foo'</code>。</p><p id="7a66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二次调用<code class="fe ms mt mu mj b">next</code>将返回一个<code class="fe ms mt mu mj b">value</code>为<code class="fe ms mt mu mj b">undefined</code>的对象。</p><p id="5bd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">yield</code>关键字是一个新的关键字，它将为<code class="fe ms mt mu mj b">next</code>方法带来价值。</p><p id="6c49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<code class="fe ms mt mu mj b">yield</code>语句的值将按照它们被列出的顺序返回。</p><p id="87b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">yield</code>暂停函数的执行，并将结果发送回调用者。</p><p id="087d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后下次调用<code class="fe ms mt mu mj b">next</code>时，运行<code class="fe ms mt mu mj b">next</code> yield语句。</p><p id="bd3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="32c6" class="mn lc iq mj b gy mo mp l mq mr">function* gen() {<br/>  yield 'first';<br/>  yield 'second';<br/>  yield 'third';<br/>}</span><span id="8bb1" class="mn lc iq mj b gy mv mp l mq mr">let generator = gen();</span></pre><p id="caa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个<code class="fe ms mt mu mj b">generator.next()</code>调用返回:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5f1d" class="mn lc iq mj b gy mo mp l mq mr">{value: "first", done: false}</span></pre><p id="9137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后第二次呼叫返回:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7c29" class="mn lc iq mj b gy mo mp l mq mr">{value: "second", done: false}</span></pre><p id="4355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三次呼叫返回:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="df44" class="mn lc iq mj b gy mo mp l mq mr">{value: "third", done: false}</span></pre><p id="a0b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四次呼叫返回:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d4c8" class="mn lc iq mj b gy mo mp l mq mr">{value: undefined, done: true}</span></pre><p id="f9d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明生成器没有更多的值要返回。</p><p id="93f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">done</code>属性表示生成器是否已经返回了所有的值。</p><p id="226f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦<code class="fe ms mt mu mj b">done</code>是<code class="fe ms mt mu mj b">true</code>，我们就知道什么时候停止调用<code class="fe ms mt mu mj b">next</code>。</p><h1 id="fc87" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数据传递给生成器</h1><p id="fab7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以将数据传递给生成器。</p><p id="c221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点，我们创建了一个带有<code class="fe ms mt mu mj b">yield</code>语句的生成器函数，该语句后面没有值。</p><p id="f579" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7be6" class="mn lc iq mj b gy mo mp l mq mr">function* fullName() {<br/>  const firstName = yield;<br/>  const lastName = yield;<br/>  console.log(`${firstName} ${lastName}`);<br/>}</span></pre><p id="922d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个后面没有值的<code class="fe ms mt mu mj b">yield</code>语句，所以它将接受我们传递给<code class="fe ms mt mu mj b">next</code>的值。</p><p id="85fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="593b" class="mn lc iq mj b gy mo mp l mq mr">const fn = fullName();<br/>fn.next()<br/>fn.next('mary')<br/>fn.next('jones')</span></pre><p id="8a47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了生成器函数。</p><p id="f598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们叫<code class="fe ms mt mu mj b">next</code>来启动发电机。</p><p id="a94b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们就可以开始向生成器传递值了。</p><p id="1f55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a9a" class="mn lc iq mj b gy mo mp l mq mr">fn.next('mary')</span></pre><p id="607b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向第一个<code class="fe ms mt mu mj b">yield</code>语句传递一个值。</p><p id="ec39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们对第二个做同样的事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3388" class="mn lc iq mj b gy mo mp l mq mr">fn.next('jones')</span></pre><p id="ecdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们从控制台日志中得到<code class="fe ms mt mu mj b">'mary jones'</code>。</p><h1 id="658c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步代码和生成器</h1><p id="f88c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>语法是基于生成器创建的。</p><p id="c158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa07" class="mn lc iq mj b gy mo mp l mq mr">const getData = async () =&gt; {<br/>  const res = await fetch('https://api.agify.io/?name=michael')<br/>  const data = await res.json();<br/>  console.log(data);<br/>}</span></pre><p id="230f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>语法。</p><p id="2fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">await</code>暂停<code class="fe ms mt mu mj b">getData</code>的执行，直到结果出现。</p><p id="d2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以它的作用类似于<code class="fe ms mt mu mj b">yield</code>。</p><p id="6dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们逐行运行我们的异步代码。</p><p id="140a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是<code class="fe ms mt mu mj b">await</code>只对承诺起作用。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c906fa4a66cc865040b7aa5401f40278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9xl-QHt8fpsEpLlp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="5327" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7be9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用生成器按顺序返回项目。</p><p id="ca4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回一个结果后，该函数暂停，并在请求下一个结果时恢复。</p><p id="8a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺的<code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>语法基于生成器语法。</p></div></div>    
</body>
</html>