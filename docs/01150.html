<html>
<head>
<title>Break Free: React Portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挣脱束缚:反应门户</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/break-free-react-portals-6e7f37069d59?source=collection_archive---------12-----------------------#2020-06-25">https://blog.devgenius.io/break-free-react-portals-6e7f37069d59?source=collection_archive---------12-----------------------#2020-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/adfc780df7bbe9262b3d37936f1e55e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IvpT7lBmn9gSxPjm"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Artem Sapegin 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="53b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的5-10年里，单页应用程序(SPA)已经成为一种常见的web开发技术。由于它们的速度、交互性、多功能性和丰富的开发者社区；spa是快速部署现代web应用程序的绝佳选择。此外，它们减少了对持续的、昂贵的和冗长的网络调用的需求，这是多页面应用程序的特征。</p><p id="7ad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，水疗也有局限性。对异步Javascript (AJAX)调用的依赖使得搜索引擎优化(SEO)变得困难，因为搜索引擎依赖于页面中结构化的稳定内容进行索引。spa更容易受到跨站点脚本(XSS)的攻击，并且过度依赖Javascript来提供用户体验，这可能会在客户端被无意地停用。最后，使用状态而不是页面来处理数据的变化，限制了多菜单和复杂分层体验的丰富性。或者更糟的是，状态会变得如此纠缠不清，以至于错误令人沮丧地隐藏在代码库的深处。</p><p id="a5fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个快速营销和不断变化的消费者口味的时代，成功是通过抓住我们客户的注意力来衡量的。因此，赋予熟悉的用户界面/UX模式一定的重要性是合理的，但是平衡这种熟悉性和新鲜感也同样重要。由于spa对于多页面应用有几个相当大的限制，让我们来探讨如何处理其中一个问题:有限的多菜单和复杂的分层体验。JS通过实现门户。</p><p id="d4ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">背景</p><p id="6185" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">DOM通过提供一个连接性的“树状”框架来存放信息，并在文档中产生锚点(通常称为节点),从而为网页或Web应用程序提供结构。由于这种结构的等级性质，任何特定站点的元素都倾向于遵循可预测的“流程”。从这个意义上说，flow用于描述元素在网页或webapp上呈现的顺序，通常是父子或兄弟姐妹关系。在父子关系的情况下，子元素通常包含在父元素中。同样，这种关系的普遍性和可预测性既有益又无聊；有用而失去的机会。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">父母就是不理解</figcaption></figure><p id="bc5f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">门户网站</p><p id="684a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这些关系形成了React.js应用程序(以及一般的web)的基本结构，但React通过实现门户提供了一种摆脱单调的方法。门户为子组件提供了打破父子关系的能力。通过避开受约束的关系并有效地摆脱其在DOM树中的预期位置，程序员可以决定将子元素附加到网页上的任何其他位置。门户甚至能够在最重要的根节点之外添加元素，根节点是react应用程序中呈现的所有元素和组件的祖先节点。</p><p id="3a9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React开发人员可能会发现通过以下步骤在他们的项目中实现门户很容易:</p><ol class=""><li id="e40c" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">在react应用程序用来呈现UI的&lt; div id=‘root’ &gt;结构之外创建一个HTML元素。这个文件通常可以在react应用程序的公共文件夹中找到，作为一个index.html文件。</li></ol><pre class="ky kz la lb gt ln lo lp lq aw lr bi"><span id="ba66" class="ls lt in lo b gy lu lv l lw lx">// index.html</span><span id="11df" class="ls lt in lo b gy ly lv l lw lx">&lt;body&gt;<br/>   &lt;noscript&gt;<br/>   &lt;/noscript&gt;</span><span id="ffda" class="ls lt in lo b gy ly lv l lw lx">&lt;div id='root'&gt; &lt;/div&gt;<br/>&lt;div id='portal'&gt; &lt;/div&gt;</span><span id="8f69" class="ls lt in lo b gy ly lv l lw lx">&lt;/body&gt; </span></pre><p id="c385" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.在react应用程序中的任何位置创建将利用门户功能的组件，作为子组件。</p><pre class="ky kz la lb gt ln lo lp lq aw lr bi"><span id="08e3" class="ls lt in lo b gy lu lv l lw lx">// Modal.js</span><span id="f90f" class="ls lt in lo b gy ly lv l lw lx">import React from 'react';</span><span id="c3c5" class="ls lt in lo b gy ly lv l lw lx">class Modal extends React.Component {</span><span id="87ee" class="ls lt in lo b gy ly lv l lw lx">   render(){</span><span id="392d" class="ls lt in lo b gy ly lv l lw lx">      return ( // leave this empty for now )</span><span id="01ce" class="ls lt in lo b gy ly lv l lw lx">   }</span><span id="2506" class="ls lt in lo b gy ly lv l lw lx">}</span><span id="917d" class="ls lt in lo b gy ly lv l lw lx">export default Modal;</span></pre><p id="2b32" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.通过导入ReactDOM向该组件添加额外的功能。在基本的react应用中，ReactDOM一般只能在index.js文件中看到。</p><pre class="ky kz la lb gt ln lo lp lq aw lr bi"><span id="6e0a" class="ls lt in lo b gy lu lv l lw lx">// Modal.js</span><span id="7b49" class="ls lt in lo b gy ly lv l lw lx">import React from 'react';<br/>import ReactDOM from 'react-dom';</span><span id="a556" class="ls lt in lo b gy ly lv l lw lx">class Modal extends React.Component {</span><span id="e062" class="ls lt in lo b gy ly lv l lw lx">   render(){</span><span id="9d54" class="ls lt in lo b gy ly lv l lw lx">      return ( // leave this empty for now )</span><span id="cd3e" class="ls lt in lo b gy ly lv l lw lx">   }</span><span id="0ccd" class="ls lt in lo b gy ly lv l lw lx">}</span><span id="4ade" class="ls lt in lo b gy ly lv l lw lx">export default Modal;</span></pre><p id="314a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.返回ReactDOM的createPortal方法作为子组件的返回值。与ReactDOM提供的render方法类似，createPortal方法接受两个参数:将被呈现的JSX和将接收JSX的节点。</p><pre class="ky kz la lb gt ln lo lp lq aw lr bi"><span id="44b6" class="ls lt in lo b gy lu lv l lw lx">//Modal.js</span><span id="e9a6" class="ls lt in lo b gy ly lv l lw lx">class Modal extends React.Component {</span><span id="59b6" class="ls lt in lo b gy ly lv l lw lx">   render(){</span><span id="8840" class="ls lt in lo b gy ly lv l lw lx">      return ReactDOM.createPortal(&lt;div className='Modal'&gt; Hello Portal &lt;/div&gt;,  document.getElementById('portal'))</span><span id="90bd" class="ls lt in lo b gy ly lv l lw lx">   }</span><span id="ebc3" class="ls lt in lo b gy ly lv l lw lx">}</span><span id="9aaa" class="ls lt in lo b gy ly lv l lw lx">export default Modal;</span></pre><p id="a758" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.包括App.js文件中的模态组件，或者您希望调用门户并启动react应用程序的任何地方。</p><pre class="ky kz la lb gt ln lo lp lq aw lr bi"><span id="85da" class="ls lt in lo b gy lu lv l lw lx">//App.js</span><span id="6ff6" class="ls lt in lo b gy ly lv l lw lx">import React from 'react';<br/>import Modal from './Modal';</span><span id="d736" class="ls lt in lo b gy ly lv l lw lx">class App extends React.Component {</span><span id="3700" class="ls lt in lo b gy ly lv l lw lx">   render(){</span><span id="1287" class="ls lt in lo b gy ly lv l lw lx">      return (&lt;div&gt; </span><span id="118b" class="ls lt in lo b gy ly lv l lw lx">         &lt; Modal /&gt;</span><span id="1796" class="ls lt in lo b gy ly lv l lw lx">      &lt;/div&gt;)</span><span id="e37b" class="ls lt in lo b gy ly lv l lw lx">   }</span><span id="24fc" class="ls lt in lo b gy ly lv l lw lx">}</span><span id="27d0" class="ls lt in lo b gy ly lv l lw lx">export default App;</span></pre><p id="c7f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管在App组件中呈现模态组件，React还是将模态组件附加到createPortal方法中选择的节点。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/24fdf217783a1f6cecdcf96de1feed5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NutTK4u0kkeJNYolrMTU0Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">追加到<div id="‘portal’">的模态</div></figcaption></figure><p id="cb9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有趣的是，模态组件作为<div id="‘portal’">节点的子节点呈现在DOM上，它仍然是App组件的子节点。这样，尽管它在DOM树中的位置不同，它仍然是React树的一部分。</div></p><p id="e921" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么为什么要使用门户呢？</p><p id="1acd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">门户通常与模态、弹出窗口、工具提示或任何其他应该放弃其父位置和/或样式的元素一起使用。由于DOM的层次结构和CSS的级联性质，子元素继承了在它们的父元素上定义的位置和样式。例如，如果父组件有大小限制，如最大高度或最大宽度，子组件也将有这些相同的样式规则。门户的另一个典型用例是当父元素具有<em class="ma">溢出:隐藏</em>或<em class="ma"> z-index </em>样式，但程序员希望子元素从父容器中脱离出来。想要提供特殊体验或在特定交互上突出某些信息的开发人员可能会发现门户提供了完美的实现解决方案。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mb ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">挣脱</figcaption></figure><p id="9de1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个考虑是门户不会改变事件传播。从门户内部触发的事件将传播或冒泡到<em class="ma"> React树中的祖先。</em>捕获或阻止事件气泡必须由开发人员根据具体情况来处理。</p><p id="913e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结论</p><p id="42ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Web开发是不断变化的。新技术可能来来去去，但它们总是旨在解决同一个挑战:对于开发人员来说，实现他们想要的体验的最佳方式是什么。在SPAs时代，React的门户方法带来了许多开发人员可能不知道的额外灵活性。当然，CSS可以用来颠覆用户的期望，并提供一些独特性。例如，position属性可用于重新排列元素的流向。但是React为开发人员提供了打破DOM的一流方法——让我们使用它。</p><p id="ed2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">奖金</p><p id="a837" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到“使用它”，我已经创建了一个<a class="ae jz" href="https://github.com/epittab/modal_example" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>，在react中有一个工作模态组件。请随意使用、重用、复制或签出代码。快乐编码。</p><p id="8d7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">参考</p><div class="mc md gp gr me mf"><a href="https://reactjs.org/docs/portals.html" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">门户-反应</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">门户提供了一种一流的方法来将子节点呈现到一个DOM节点中，该节点存在于…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">reactjs.org</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jt mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://ozitag.com/blog/spa-advantages" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">网络开发技术博客| OZiTAG网络专家</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">软件世界一直在不断发展。就在几年前，台式机和笔记本电脑还是主要的…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">ozitag.com</p></div></div></div></a></div><div class="mc md gp gr me mf"><a href="https://arxiv.org/abs/cs/0610094" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">将多页面Web应用程序迁移到单页面AJAX界面</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">最近，出现了一种新的用于创建交互式web应用程序的web开发技术，称为AJAX。在这个…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">arxiv.org</p></div></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.webfx.com/blog/web-design/website-statistics-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">2020年网站统计:网页设计需要知道的10个关键数据</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">你是否希望在2020年为你的企业设计一个全新的网页？如果是这样，你必须知道你需要做什么…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.webfx.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt jt mf"/></div></div></a></div></div></div>    
</body>
</html>