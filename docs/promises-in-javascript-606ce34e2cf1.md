# Javascript 中的承诺

> 原文：<https://blog.devgenius.io/promises-in-javascript-606ce34e2cf1?source=collection_archive---------15----------------------->

![](img/7bc70516ab9dcd94bdadb86de2dc821d.png)

承诺是 javascript 的一个重要方面。任何时候你进行异步调用，不管是来自你的客户端应用程序还是服务器，我保证“promise”会让事情对你来说容易得多，但是承诺很难理解，至少对我来说是这样。一旦我们爬上理解承诺之山，景色将是壮丽的。那我们就开始吧，好吗？

# 承诺

承诺就像它们的名字一样。javascript 中的 Promise 是一个向您承诺异步操作结果的对象。假设您想从 api 获取所有订单的数据，这显然不会是一个即时的过程，需要一些时间来获取数据，持续时间可能取决于数量，但会有延迟，因此您返回的不是错误或部分数据，而是一个承诺，您可以使用它来获取结果或相应的错误。让我们用一个例子来理解上面的案例。
当我们发出获取数据的请求时，我使用流行的[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)来获取一些数据并分析我们得到的响应。

![](img/1c4b8525bc9db40445432531722107ae.png)

嗯，我们这里有什么！一个对象和一个承诺，这个术语看起来有点熟悉。我们看到另一件有趣的事，“已满”表示应许的状态。我们可以有三种承诺状态。
1。待定
2。履行了
3。Reject
正如你可能从名字中推断的那样，Pending 状态发生了，当承诺仍然在幕后工作时，我们请求的任何动作都还没有完成来提供给我们结果。在上面的例子中，我们只向 API 查询一个商品，所以在我们打印出“something”对象之前，承诺就已经实现了。我们将在本文后面模拟这种情况。敬请期待！
进入“已完成”状态，这意味着我们的异步操作成功了，但是结果在哪里呢？在等式“then()”中引入另一个元素，当 promise 返回结果或错误时，就会调用这个函数。then()函数被提供了承诺的结果和错误，然后它调用内部定义的具有该值的函数。很复杂对吧！让我们来看一个例子，以便更好地了解情况。带着我们已经实现的承诺向前努力，让我们试着看看它的结果。

![](img/fc3fd5101fd60b014b00d2194a345c94.png)

好的，我们在我们的承诺上附加了一个 then()函数，它收到了一个成功的结果，我们正在打印这个结果。如果这是一个错误，那么带有错误参数的()函数就会被执行。等待，但我们看到的是，结果是另一个“承诺”。我们现在要干嘛？。别担心，promises 给了我们链接多个异步调用的功能。因此，promise 的结果是另一个异步调用，我们可以在函数中执行异步元素，相应的结果将在下一个 then 调用中收到。再次，变得有点乱！让我们再次回到我们的例子。

```
something.then(result=>result.json()).then(result=>console.log(result));
{userId: 1, id: 1, title: ‘delectus aut autem’, completed: false}
```

我们将另一个 then 函数链接到我们之前的函数，我们将从第一个 promise 获得的正文流转换为 json，这是一个异步调用，当该调用完成时，我们的下一个 then 函数被调用，结果是，瞧，我们最终得到了结果。这基本上总结了我们对状态以及如何处理它们的讨论。我们将进一步探究拒绝状态。

到目前为止，我们已经处理了如何处理承诺，它的各个阶段。但是我们如何自己创造一个承诺，因为有时我们需要创造一个承诺。让我们在下一节探讨这个问题。

# 创造承诺

```
let promise = new Promise(function(resolve, reject){
///asynchronous operation})
```

上面的语法是一个承诺的原型。我们来分解一下。每当我们创建一个承诺，我们传递一个函数给它，一旦承诺被创建，这个函数就被调用。这个函数，为了方便起见，我们称它为“可执行函数”，接收两个回调，resolve 和 reject，我们一会儿再回到这些函数。让我们回滚到我们的可执行函数，因此它包含了我们需要执行的任何操作，一旦完成，如果操作成功，它就调用 resolve，如果操作失败，就调用 reject。让我们试着模拟一个例子。

![](img/e0b5b974b48c0eaa514241433e459eb6.png)

在可执行函数中，我设置了一个 1 分钟的超时，当超时结束时，我们调用 resolve 函数，结果是一个字符串。
我们在这个例子中遇到了两件事，我们还没有看到承诺的待定状态，所以这个例子展示了这一点。一旦我们创建了一个承诺，我们就会看到它处于挂起状态，因为可执行函数内部的代码仍未完成，并被称为 resolve 函数。当 resolved 被调用时，我们得到返回值。
让我们看看可执行函数内部的操作何时失败。

![](img/8470f8faf2187b4690c6b7911708b449.png)

正如您在上面看到的，在我们的超时函数中，完成后我们用错误值调用 reject，这意味着承诺将收到一个错误。

希望这对你有帮助。如有任何疑问，请随时联系我们，不要忘记鼓掌。:D