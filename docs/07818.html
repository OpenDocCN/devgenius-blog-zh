<html>
<head>
<title>How to use gorilla/mux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 gorilla/mux</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-gorilla-mux-cbecaf8c6840?source=collection_archive---------8-----------------------#2022-04-25">https://blog.devgenius.io/how-to-use-gorilla-mux-cbecaf8c6840?source=collection_archive---------8-----------------------#2022-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6191" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到我的指南，<em class="ki">Golang Web 开发简介</em>。上一次，我们看了如何为我们的 web 应用程序编写处理程序。既然我们知道了多路复用器和处理程序是如何工作的，是时候使用一个更复杂的工具了。虽然 Go 确实有一个令人惊叹的<code class="fe kj kk kl km b">net/http</code>包，但是<code class="fe kj kk kl km b">gorilla/mux</code>提供的某些功能让我们的生活变得更加轻松。事不宜迟，让我们进入第 3 部分。</p><h1 id="d8d5" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我为什么要使用这个包？</h1><p id="6bc8" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">如果标准库这么好，我们为什么还要费心去使用<code class="fe kj kk kl km b">gorilla/mux</code>？有几个原因。</p><ul class=""><li id="e45b" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">它可以从 URL 路径中提取变量。</li><li id="8701" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">它支持 subrouters，您可以使用它对相似的路由进行分组。</li><li id="8ea8" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">您可以通过域、前缀、方法等来匹配路由。</li><li id="462b" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">学习曲线并不陡峭，这要感谢实现了<code class="fe kj kk kl km b">http.Handler</code>接口的包，使它与标准库兼容。</li></ul><p id="76da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有更多功能我没有在这里列出，但这些是最常用的功能。<code class="fe kj kk kl km b">gorilla/mux</code>是一个成熟的软件包，拥有丰富的文档和广泛的用户基础，所以当你遇到困难时，更容易获得在线帮助。</p><h1 id="4b86" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">导入包</h1><p id="6cdc" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">要使用<code class="fe kj kk kl km b">gorilla/mux</code>，需要导入。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="3c6d" class="mm ko in km b gy mn mo l mp mq">package main</span><span id="7284" class="mm ko in km b gy mr mo l mp mq">import (<br/>    "github.com/gorilla/mux"<br/>)</span></pre><p id="7d92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将它导入到您的<code class="fe kj kk kl km b">main.go</code>文件后，我们需要安装它。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="2b8e" class="mm ko in km b gy mn mo l mp mq">go mod init example.com/mywebapp</span><span id="1a82" class="mm ko in km b gy mr mo l mp mq">go mod tidy</span></pre><p id="d71d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先用第一个命令初始化我们的<code class="fe kj kk kl km b">go.mod</code>文件。URL 还不重要。我们不会将它托管在远程存储库中。如果我们正在开发一个供其他人使用的库，这个 URL 将是到您的远程 repo 的路径，比如<code class="fe kj kk kl km b">github.com/username/mypackage</code>。</p><p id="0abd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦创建了一个<code class="fe kj kk kl km b">go.mod</code>文件，我们使用第二行来检查和更新依赖关系。<code class="fe kj kk kl km b">go mod tidy</code>通常用于修剪不必要的依赖项，但它对于添加缺失的依赖项也很有用。</p><p id="b21f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在已经安装好了，我们可以开始使用这个包了！</p><h1 id="e520" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">让我们来看一个例子</h1><p id="c5f3" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">我们将构建一个图书馆(如图书)管理应用程序，用户可以在其中搜索本系列的书籍和作者。它类似于 Kindle 或 Barnes &amp; Noble 商店，尽管要简单得多。</p><p id="30f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的网络应用将支持这些操作:</p><ul class=""><li id="961e" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">用户可以获得所有书籍的数据。</li><li id="0af9" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">用户可以通过他们的 ISBNs 获得每本书的数据。</li><li id="115b" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">用户可以添加新书。</li><li id="7aa1" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">用户可以更新现有的图书数据。</li><li id="61f1" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">用户可以删除图书。</li></ul><p id="fc76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，如果您的普通客户可以自由使用，其中一些操作将是毁灭性的。想象一下，我去 Kindle 电子书商店，把他们一半的图书馆都抹掉。但是，由于身份验证和授权超出了本指南的范围，我们将假设此 web 应用程序的用户是经理和管理员。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="2116" class="mm ko in km b gy mn mo l mp mq">package main</span><span id="d595" class="mm ko in km b gy mr mo l mp mq">import (<br/>    "fmt"<br/>    "log"<br/>    "net/http"</span><span id="6f65" class="mm ko in km b gy mr mo l mp mq">    "github.com/gorilla/mux"<br/>)</span><span id="bf0c" class="mm ko in km b gy mr mo l mp mq">func main() {<br/>    r := mux.NewRouter()</span><span id="22e9" class="mm ko in km b gy mr mo l mp mq">    r.HandleFunc("/", homeHandler)</span><span id="1e20" class="mm ko in km b gy mr mo l mp mq">    booksSubR := r.PathPrefix("/books").Subrouter()</span><span id="15de" class="mm ko in km b gy mr mo l mp mq">    booksSubR.HandleFunc("/all", AllHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/{isbn}", IspnHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/new", NewHandler).Methods(http.MethodPost)<br/>    booksSubR.HandleFunc("/update", UpdateHandler).Methods(http.MethodPut)<br/>    booksSubR.HandleFunc("/delete/{isbn}", DeleteIspnHandler).Methods(http.MethodDelete)</span><span id="ee7a" class="mm ko in km b gy mr mo l mp mq">    log.Fatal(http.ListenAndServe(":8090", r))<br/>}</span></pre><p id="9a81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经读过我以前的指南，这段代码看起来会很熟悉。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="9de4" class="mm ko in km b gy mn mo l mp mq">// using gorilla/mux<br/>r := mux.NewRouter()<br/>r.HandleFunc("/", homeHandler)</span></pre><p id="4208" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先创建我们的 mux 并注册一个端点。在 vanilla Go 中，我们将通过这样做来完成:</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="1f04" class="mm ko in km b gy mn mo l mp mq">// using net/http<br/>mux := http.NewServeMux()<br/>mux.HandleFunc("/", homeHandler)</span></pre><p id="51a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意到代码是多么的相似吗？这都归功于<code class="fe kj kk kl km b">gorilla/mux</code>实现了<code class="fe kj kk kl km b">http.Handler</code>接口，使其与<code class="fe kj kk kl km b">net/http</code>标准库兼容。</p><p id="6ab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是有趣的部分。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="858d" class="mm ko in km b gy mn mo l mp mq">booksSubR := r.PathPrefix("/books").Subrouter()</span></pre><p id="2637" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">匹配路线</em>和<em class="ki">副路线</em>的概念在此发挥作用。第一种方法是<code class="fe kj kk kl km b">PathPrefix()</code>，匹配以<code class="fe kj kk kl km b">/books</code>开头的路线，比如<code class="fe kj kk kl km b">/books/all</code>或者<code class="fe kj kk kl km b">/books/new</code>。现在，这本身是可用的，但如果我们将这些路线分组会更好。我们通过调用<code class="fe kj kk kl km b">Subrouter()</code>方法进行分组。上面的代码将创建一个子路由器，它匹配只以<code class="fe kj kk kl km b">/books</code>开头的路由。它不会处理任何其他路线，例如<code class="fe kj kk kl km b">/home</code>或<code class="fe kj kk kl km b">/welcome</code>。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="22db" class="mm ko in km b gy mn mo l mp mq">booksSubR.HandleFunc("/all", booksAllHandler).Methods(http.MethodGet)<br/>booksSubR.HandleFunc("/{isbn}", booksIspnHandler).Methods(http.MethodGet)</span></pre><p id="950e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这大体上和普通的<code class="fe kj kk kl km b">HandleFunc</code>一样，但是有额外的特性。</p><p id="9ab2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后面的<code class="fe kj kk kl km b">Methods()</code>方法将路由限制为只接受某些 HTTP 请求类型。在这种情况下，我们只接受<code class="fe kj kk kl km b">GET</code>请求。</p><p id="6f62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，看一下第二行。<code class="fe kj kk kl km b">isbn</code>就是我们所说的<em class="ki"> URL 参数</em>。这些是路径中的变量，稍后可以在我们的处理函数中提取。因此，如果我向<code class="fe kj kk kl km b">/books/000-00-00000-00-0</code>发送一个请求，我将能够提取<code class="fe kj kk kl km b">000-00-00000-00-0</code>作为一个变量，然后用它做一些事情。</p><p id="f0a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等，如果我们向<code class="fe kj kk kl km b">/books/all</code>发送请求，子路由器如何判断<code class="fe kj kk kl km b">all</code>是否是 ISBN？当我们有如上所述的冲突路线时，就会出现这些情况。我们的 subrouter 将按照从上到下的顺序匹配请求，因此将首先匹配<code class="fe kj kk kl km b">/all</code>，然后由<code class="fe kj kk kl km b">/{isbn}</code>匹配其余的请求。</p><p id="764e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多冲突的路线不是一个好的习惯，你应该尽量避免这些。但是，如果有必要，我们可以在 URL 参数中添加一个模式。</p><pre class="me mf mg mh gt mi km mj mk aw ml bi"><span id="41ad" class="mm ko in km b gy mn mo l mp mq">booksSubR.HandleFunc("/{isbn:^[0-9]{3}[-]{1}[0-9]{2}[-]{1}[0-9]{5}[-]{1}[0-9]{2}[-]{1}[0-9]{1}$}", booksIspnHandler).Methods(http.MethodGet)</span></pre><p id="7703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能看起来有点疯狂，但它所做的就是允许匹配 ISBN-13 格式的变量(任何看起来像<code class="fe kj kk kl km b">000-00-00000-00-0</code>的东西)。如果你知道如何写正则表达式，你可以用它来实现一个模式。</p><h1 id="2767" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="7cec" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">我们学习了如何使用<code class="fe kj kk kl km b">gorilla/mux</code>，以及如何使用它的一些定义特性，比如模式匹配、URL 参数和子程序。还有其他的路由器包，像<code class="fe kj kk kl km b">httprouter</code>和<code class="fe kj kk kl km b">go-chi</code>。我从来没试过用这些，但是我听过很多好东西。请随意试用它们！</p><p id="15f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你读这篇文章的时候觉得有趣。在下一篇文章中，我将把我们的 web 应用程序连接到数据库，并执行一些查询。对于你们中的一些人来说，这个指南的速度可能太慢了，但是我故意让它慢一些，以便这个指南更容易理解。请理解！</p><p id="5cca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae ms" href="https://dev.to/jpoly1219/how-to-use-gorillamux-359k" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae ms" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank"> my personal site </a>上阅读这篇文章。</p></div></div>    
</body>
</html>