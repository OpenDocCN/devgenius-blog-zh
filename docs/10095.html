<html>
<head>
<title>When K8s pods are stuck mounting large volumes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当 K8s pods 无法装载大量数据时</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/when-k8s-pods-are-stuck-mounting-large-volumes-2915e6656cb8?source=collection_archive---------2-----------------------#2022-10-07">https://blog.devgenius.io/when-k8s-pods-are-stuck-mounting-large-volumes-2915e6656cb8?source=collection_archive---------2-----------------------#2022-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7a149feb8c25098c3d8dd84f1ffd4f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPVZqnw7e_48Yex4NWTJkg.jpeg"/></div></div></figure><div class=""/><p id="197a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我们在 AWS/EKS 上部署 Loki 时遇到了以下问题。在每次部署或重启 Loki Pod 时，安装持久卷的时间越来越长。在我们的生产集群上，开始时有几分钟的延迟，结束时将近 25 分钟。由于对此没有解决方案，我们尽可能避免新的部署，因为我们知道这不是一个可接受的变通办法。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8155" class="lc ld iy ky b gy le lf l lg lh">Events:<br/>Type    Reason      Age      From              Message<br/>— — — — — — — — — — — — -<br/>Normal  Scheduled   23m50s   default-scheduler Successfully assigned default/filecr34t0r-0 to ip-100–64–8–204.eu-central-1.compute.internal<br/>Normal  SuccessfulAttachVolume 23m48s attachdetach-controller AttachVolume.Attach succeeded for volume “pvc-ef3366b8-464c-11ed-b878-0242ac120002”<br/><strong class="ky iz">Warning FailedMount  </strong><strong class="ky iz">5m43s (x6 over 18m)</strong><strong class="ky iz"> kubelet Unable to attach or mount volumes: unmounted volumes=[vol], unattached volumes=[vol kube-api-access-7wzcs]: timed out waiting for the condition</strong><br/>Normal  Pulled       106s   kubelet            Container image “grafana/loki:2.6.1” already present on machine<br/>Normal  Created      106s   kubelet            Created container loki<br/>Normal  Started      106s   kubelet            Started container loki</span></pre><p id="f897" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我开始调查这件事。在测试和生产中，我们使用自动调配的 gp3 卷。AWS 卷监视器显示在装载期间有大量的 I/O 活动。测试卷大约有 130 万个文件，装载大约需要 7 分钟。在生产时，该卷有 430 万个，装载需要 24 分钟。好的，它似乎与文件的数量相关。使用 gp3 s 3000 iOPs，我们可以进行以下计算:</p><ul class=""><li id="4b3e" class="li lj iy jx b jy jz kc kd kg lk kk ll ko lm ks ln lo lp lq bi translated">测试:1300000/3000/60 = 7.2 分钟</li><li id="529e" class="li lj iy jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated">产品 4300000/3000/60 = 23.8 分钟</li></ul><p id="f9db" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过搜索 K8s 文档和博客，我找到了解决方案:Kubernetes 递归地改变每个卷的内容的所有权和权限，以匹配挂载该卷时 Pod 的<code class="fe lw lx ly ky b">securityContext</code>中指定的<code class="fe lw lx ly ky b">fsGroup</code>。对于大型卷，检查和更改所有权和权限会花费大量时间，从而减慢 Pod 启动速度。</p><p id="5f60" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过<code class="fe lw lx ly ky b">securityContext</code>中的<code class="fe lw lx ly ky b">fsGroupChangePolicy</code>字段，您可以控制 Kubernetes 检查和管理一个卷的所有权和权限的方式。可能的值:</p><ul class=""><li id="5a04" class="li lj iy jx b jy jz kc kd kg lk kk ll ko lm ks ln lo lp lq bi translated"><em class="lz"> OnRootMismatch </em>:仅当根目录的权限和所有权与卷的预期权限不匹配时，才更改权限和所有权。这有助于缩短更改卷的所有权和权限所需的时间。</li><li id="17e3" class="li lj iy jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated"><em class="lz"> Always </em>:挂载卷时，始终更改卷的权限和所有权。</li></ul><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="28e2" class="lc ld iy ky b gy le lf l lg lh">template:<br/>  spec:<br/>    containers:<br/>      ...<br/>    securityContext:<br/>      fsGroup: 10001<br/>      runAsGroup: 10001<br/>      runAsNonRoot: true<br/>      runAsUser: 10001<br/>      <strong class="ky iz">fsGroupChangePolicy: "OnRootMismatch"</strong></span></pre><p id="ec3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这一修改，我们的 Loki 实例的启动时间变回到两分钟以内。</p><p id="7253" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只有在您的部署或 StatefulSet 已经配置了一个<code class="fe lw lx ly ky b">securityContext</code>的情况下才适用，希望您已经完成了。😉</p><p id="330e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">附录:大量的文件是由 Loki 产生的，这是因为自定义标签的使用过于自由。同时，我们减少了标签的数量，随着文件数量的减少，Grafana 中的查询也变得更快了。</p></div></div>    
</body>
</html>