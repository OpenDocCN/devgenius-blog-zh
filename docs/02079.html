<html>
<head>
<title>JavaScript Best Practices — Arrays, Todos, and Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践——数组、待办事项和回调</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-arrays-todos-and-callbacks-3f4f5e1489b9?source=collection_archive---------23-----------------------#2020-07-18">https://blog.devgenius.io/javascript-best-practices-arrays-todos-and-callbacks-3f4f5e1489b9?source=collection_archive---------23-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd8b65d0c9323b77940ceb9ea3a44f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r5CR_7cqrJ6LXApf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@marius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marius Masalar </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="d8e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向待办事项注释添加过期条件</h1><p id="6157" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们必须做注释，我们可以给它添加过期条件，这样 ESLint 就会选择它们，如果它们过期了，就会抛出一个错误。</p><p id="f7fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="caf2" class="mn lc iq mj b gy mo mp l mq mr">// TODO [2019-11-15]: fix this</span></pre><p id="6db6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有 ISO 8601 格式的日期和任务描述。</p><h1 id="23bd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">显式比较值的<code class="fe ms mt mu mj b">length</code>属性</h1><p id="2299" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">显式比较 value 的<code class="fe ms mt mu mj b">length</code>属性比不比较清楚。</p><p id="095c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c245" class="mn lc iq mj b gy mo mp l mq mr">if (string.length) {}<br/>if (array.length) {}</span></pre><p id="6e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9522" class="mn lc iq mj b gy mo mp l mq mr">if (string.length &gt; 0) {}<br/>if (array.length &gt; 0) {}</span></pre><p id="46fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显式地将它们与 0 进行比较。</p><h1 id="6c0a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件名的大小写样式</h1><p id="4905" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">文件名的大小写样式应该一致。</p><p id="9493" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用烤肉串做任何事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6795" class="mn lc iq mj b gy mo mp l mq mr">foo-bar.js</span></pre><p id="06e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以使用骆驼案例。</p><p id="3839" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="067d" class="mn lc iq mj b gy mo mp l mq mr">fooBar.js</span></pre><p id="fccb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以用蛇的例子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7b0" class="mn lc iq mj b gy mo mp l mq mr">foo_bar.js</span></pre><p id="0559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以用帕斯卡的例子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0eab" class="mn lc iq mj b gy mo mp l mq mr">FooBar.js</span></pre><h1 id="bf21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe ms mt mu mj b">.</code>导入索引文件</h1><p id="1a02" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在导入一个<code class="fe ms mt mu mj b">index.js</code>文件，我们不需要显式地写文件名。</p><p id="714b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="605b" class="mn lc iq mj b gy mo mp l mq mr">const module = require('./index');</span></pre><p id="1d6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c729" class="mn lc iq mj b gy mo mp l mq mr">const module= require('./');</span></pre><p id="85d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="33b8" class="mn lc iq mj b gy mo mp l mq mr">const m = require('.');</span></pre><p id="50ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3e0c" class="mn lc iq mj b gy mo mp l mq mr">const m = require('./foo');</span></pre><h1 id="0cdd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">除了<code class="fe ms mt mu mj b">String</code>、<code class="fe ms mt mu mj b">Number</code>和<code class="fe ms mt mu mj b">Boolean</code>之外，所有内置构造器都使用<code class="fe ms mt mu mj b">new</code></h1><p id="3dd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">几乎所有的构造函数都需要<code class="fe ms mt mu mj b">new</code>关键字，除了<code class="fe ms mt mu mj b">String</code>、<code class="fe ms mt mu mj b">Number</code>和<code class="fe ms mt mu mj b">Boolean</code>，</p><p id="a5dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该使用构造函数来创建原始值</p><p id="904c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们不用<code class="fe ms mt mu mj b">new</code>来使用它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2b9" class="mn lc iq mj b gy mo mp l mq mr">const str = String(123);</span></pre><p id="4f23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2287" class="mn lc iq mj b gy mo mp l mq mr">const list = new Array(10);</span></pre><p id="2fa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为使用带有<code class="fe ms mt mu mj b">String</code>、<code class="fe ms mt mu mj b">Number</code>或<code class="fe ms mt mu mj b">Boolean</code>的<code class="fe ms mt mu mj b">new</code>创建对象，而不是原始值。</p><h1 id="92e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe ms mt mu mj b">Use Array.isArray()</code>而不是<code class="fe ms mt mu mj b">instanceof Array</code></h1><p id="d4b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">Array.isArray</code>比<code class="fe ms mt mu mj b">instanceof Array</code>更健壮。</p><p id="6f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">instanceof Array</code>不能跨领域或跨背景工作。</p><p id="177d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不能在浏览器中不同的框架或窗口之间工作，也不能在 Node 中的<code class="fe ms mt mu mj b">vm</code>模块之间工作。</p><p id="b7b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2128" class="mn lc iq mj b gy mo mp l mq mr">array instanceof Array;</span></pre><p id="e97d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b77" class="mn lc iq mj b gy mo mp l mq mr">Array.isArray(array);</span></pre><h1 id="acb5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe ms mt mu mj b">console.log</code>参数之间没有前导空格</h1><p id="00eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不需要<code class="fe ms mt mu mj b">console.log</code>参数之间的前导空格。</p><p id="e731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是把尾随空格。</p><p id="3acf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="283b" class="mn lc iq mj b gy mo mp l mq mr">console.log('abc' , 'def');</span></pre><p id="6a03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="60a4" class="mn lc iq mj b gy mo mp l mq mr">console.log('abc', 'def');</span></pre><h1 id="bf13" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将函数引用直接传递给迭代器方法</h1><p id="410f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该创建自己的回调，而不是直接传递函数引用。</p><p id="57a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6029" class="mn lc iq mj b gy mo mp l mq mr">[1, 2, 3].map(fn);</span></pre><p id="099a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="230c" class="mn lc iq mj b gy mo mp l mq mr">[1, 2, 3].map(c =&gt; fn(c)));</span></pre><p id="0652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以控制传递给<code class="fe ms mt mu mj b">fn</code>的参数，而不是总是将数组条目作为第一个参数，将索引作为第二个参数，将数组作为第三个参数。</p><p id="325e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于任何其他接受回调的函数调用。</p><p id="63ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望通过创建自己的函数来控制传入的参数，</p><h1 id="cfa1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用可以用<code class="fe ms mt mu mj b">for-of</code>线圈代替的<code class="fe ms mt mu mj b">for</code>线圈</h1><p id="3983" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们可以使用 for-of 循环来遍历一个对象，那么我们应该这样做。</p><p id="deaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="15ae" class="mn lc iq mj b gy mo mp l mq mr">for (let index = 0; index &lt; arr.length; index++) {<br/>  const element = arr[index];<br/>  console.log(element);<br/>}</span></pre><p id="7ca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4f8e" class="mn lc iq mj b gy mo mp l mq mr">for (const element of array) {<br/>  console.log(element);<br/>}</span></pre><p id="8609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干净多了。</p><h1 id="0214" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Unicode 转义而不是十六进制转义</h1><p id="127c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了清晰和一致，我们应该使用 Unicode 转义而不是十六进制转义。</p><p id="8d46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9fb" class="mn lc iq mj b gy mo mp l mq mr">const foo = '\x1B';</span></pre><p id="fb72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bf2a" class="mn lc iq mj b gy mo mp l mq mr">const foo = '\u001B';</span></pre><h1 id="101b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有嵌套的三元表达式</h1><p id="cd0f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">嵌套的三元表达式很难读懂，所以我们不应该有。</p><p id="3ae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2503" class="mn lc iq mj b gy mo mp l mq mr">const foo = i &gt; 39 ? i &lt; 100 ? true : true: false;</span></pre><p id="3b82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aac9" class="mn lc iq mj b gy mo mp l mq mr">const foo = (x === 1) ? 'foo' : 'bar';</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/4910a79f988d18251e666b09967bf783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mjJhG3IJR_WITj8u"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="8f31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f8b4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在正则表达式中使用 Unicode 转义而不是十六进制转义。</p><p id="c814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">三元表达式很难读，我们不应该有。</p><p id="9e35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ESLint 可以检查 todo 注释的截止日期。</p><p id="8897" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件名的大小写应该一致。</p><p id="7cd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该定义自己的回调，而不是传入函数引用。</p><p id="3dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于遍历可迭代对象，for-of 循环比 for 循环好得多。</p></div></div>    
</body>
</html>