<html>
<head>
<title>JSON in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的 JSON</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/json-in-go-94c2aacc9467?source=collection_archive---------2-----------------------#2022-03-27">https://blog.devgenius.io/json-in-go-94c2aacc9467?source=collection_archive---------2-----------------------#2022-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="41b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Golang 中的 JSON 包介绍</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae45ee9e7fdf8402f3bcc8dc23d46fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K6WW2rs3T5Kq9cDR.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://caraguna.com<a class="ae ky" href="https://caraguna.com/mengenal-apa-itu-json-javascript-object-notation/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h1 id="de1e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 是什么？</h1><p id="e3f6" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Json 代表 JavaScript 对象符号，JSON 是一种交换数据格式的结构，其格式类似于 JavaScript 中的对象。JSON 是创建 RESTful API 应用程序时最常用的交换数据格式。我不会谈论更多关于 Json 的细节。详情请阅读 Json 官网【https://www.json.org/json-en.html T4】。</p><h1 id="4f48" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 代码结构示例</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/5a36a280d68e724207ecf4c923f29df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*RGCWBslCGfQ7722d3_3ECA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Json 代码结构示例</figcaption></figure><p id="373e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据上面的例子，我们可以看到 Jason 对象可以包含一个数组或者一个对象。在看到上面的代码结构后，你可能会发现 Json 是最理想的数据交换格式的原因，因为它容易由人类 <strong class="jm io">读取&amp;</strong>编写，也容易由机器 <strong class="jm io">解析&amp;</strong>。</p><h1 id="959d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">围棋中的 JSON</h1><p id="d71b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 Go 中，Json 包在你安装 Go 编译器的时候就已经包含了。你可以在 Go 中把你的数据转换成 Json(编码)或者 reverse(解码)。Json 包的详情可以在官方 go 包网站<a class="ae ky" href="https://pkg.go.dev/encoding/json" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">https://pkg.go.dev/encoding/json</strong></a>看到。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="602c" class="kz la in bd lb lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw bi translated">编码 JSON</h1><p id="1d85" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Go 已经提供了一个将数据转换成 Json 格式的函数，你可以使用<code class="fe mp mq mr ms b">json.Marshal(interface{})</code>将你的数据转换成 Json。可以从任何数据类型转换成 Json，因为 Marshal 函数的参数是一个接口。Marshal 函数将返回两个值，有<strong class="jm io">编码为字节数组的结果([]byte) </strong>和<strong class="jm io">错误。</strong>请看 json 编码的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="9e79" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解码 JSON</h1><p id="2f22" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Decode 是 Encode 的反向操作，可以用<code class="fe mp mq mr ms b">json.Unmarshal(byte[], interface{})</code>将 Json 转换成 Go 数据类型。也就是 byte[]作为 Json 数据，接口是存储转换结果的地方。解组函数只返回一个错误。要获得解码的数据，您可以调用<strong class="jm io">接口变量</strong>。有关详细信息，请参见下面的示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="2368" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 对象</h1><p id="349f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 Go 中，Json 对象表示为 Struct 数据类型。请参见为 Json 对象创建结构的示例。</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="60d7" class="mz la in ms b gy na nb l nc nd">type Address struct {<br/>    Street string<br/>    Country string<br/>    PostalCode string<br/>}</span></pre><p id="085e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还可以看到如何在 Go 中初始化 Json 对象的例子</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="9702" class="mz la in ms b gy na nb l nc nd">address := Address{<br/>    Street:     "Tipar",<br/>    Country:    "Indonesia",<br/>    PostalCode: "12345",<br/>}</span></pre><h1 id="c544" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 数组</h1><p id="c0d1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Json 中的 Array 类似于 JavaScript 中的 array，可以包含原始数据类型或复杂数据类型(对象或数组)。在 Go Json 数组中表示为一个片。从 Json 到 Json 的转换将由 Json 包使用 slice 数据类型自动完成。请看 Json 中使用数组的例子。</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="efb5" class="mz la in ms b gy na nb l nc nd">type Address struct {<br/>    Street     string<br/>    Country    string<br/>    PostalCode string<br/>}</span><span id="b23b" class="mz la in ms b gy ne nb l nc nd">type Customer struct {<br/>    FirstName    string<br/>    MiddleName   string<br/>    LastName     string<br/>    Hobbies      []string<br/>    Addresses    []Address<br/>}</span></pre><p id="5f10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码显示了<strong class="jm io">的爱好</strong>属性是包含一个数组的字符串而<strong class="jm io">的地址</strong>属性是包含一个数组的另一个名为<strong class="jm io">的对象的地址。</strong></p><p id="73f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请看如何初始化包含数组&amp; object 的对象的例子</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="9e06" class="mz la in ms b gy na nb l nc nd">customer := Customer{<br/>    FirstName: “Achmad”,<br/>    MiddleName: “Rizky”,<br/>    LastName: “Syahrani”,<br/>    Hobbies: []string{“Praying”, “Coding”, “Reading”},<br/>    Address: []Address{<br/>             {<br/>                 Street: “Tipar”,<br/>                 Country: “Indonesia”,<br/>                 PostalCode: “12345”,<br/>             },<br/>             {<br/>                 Street: “Rawa Ungu”,<br/>                 Country: “Indonesia”,<br/>                 PostalCode: “12345”,<br/>             },<br/>         },<br/>}</span></pre><h1 id="f279" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 标签</h1><p id="1a08" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">默认情况下，struct 和 Json 的属性将根据相同的属性名进行映射(区分大小写)。有时我们会遇到 Json 和 Struct 在命名属性风格上存在差异的情况，比如我们想在 Json 中使用 snake_case，而在 Struct 中使用 PascalCase 或 camelCase。你可以用<strong class="jm io">标签反射来解决这个问题。</strong>您可以在结构的属性旁边添加标记反射。通过标签反射，json 包将在解码和编码时自动在 Json 和 struct 之间转换属性名。请举出使用标记反射的例子。</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="69fa" class="mz la in ms b gy na nb l nc nd">type Product struct {<br/>    Id string `json:”id”`<br/>    Name string `json:”name”`<br/>    ImageURL string `json:”image_url”`<br/>}</span></pre><h1 id="9b8b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 地图</h1><p id="bfb6" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">有时在使用 Json 时，我们会发现 Json 数据是动态的。这意味着属性是不可预测的。在这种情况下使用 struct 会面临一个困难，因为在 struct 中你必须指定所有的属性。但是不要担心，在这种情况下，您仍然可以使用 map 数据类型。自动地，json 中的属性将作为 map 中的键，而 Json 中的值将作为 map 中的值。但是，因为值是一个接口，所以如果你想得到值，你必须转换值的数据类型。而且地图数据类型不支持 Json 标签。请看下面的例子，我可以用地图添加任意多的密钥。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="eb75" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">流式解码器</h1><p id="e131" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">有时 Json 数据来自 io。读者输入，如文件、网络、正文请求。Json 包有一个从流阅读器读取数据的特性。要创建 Json 解码器，你可以使用函数<code class="fe mp mq mr ms b">json.NewDecoder(reader)</code>，然后如果你想从阅读器中读取输入并转换成 Go 数据类型，你可以使用函数<code class="fe mp mq mr ms b">Decode(interface{})</code>。请看使用流解码器的例子。</p><p id="b8e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我想解码来自<code class="fe mp mq mr ms b">product.json</code>的包含以下数据的 Json</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="dcae" class="mz la in ms b gy na nb l nc nd">{<br/>    “id”: “P001”,<br/>    “name”: “Macbook M1”,<br/>    “image_url”: “https://example.com/images.png"<br/>}</span></pre><p id="1a78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用下面的代码来解码<code class="fe mp mq mr ms b">product.json</code>Go 数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="d275" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">流式编码器</h1><p id="4d40" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">除了解码器之外，还支持 Json 包将数据从 io.Writer 编码到 Json 中，所以我们不需要将一个 Json 数据存储到一个 string 和[]byte 变量中，可以直接用 io.writer 写。要创建 Json 编码器，您可以使用函数<code class="fe mp mq mr ms b">json.NewEncoder(writer)</code>，然后如果您想将数据作为 Json 直接写入写入器，您可以使用函数<code class="fe mp mq mr ms b">Encode(interface{})</code>。请举出使用流式编码器的例子。</p><p id="f249" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我想用文件名<code class="fe mp mq mr ms b">NewProduct.json</code>将我的数据编码成一个 Json</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5a33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上面的代码，你将得到一个名为<code class="fe mp mq mr ms b">NewProduct.json</code>的新 json 文件，其中包含以下数据。</p><pre class="kj kk kl km gt mv ms mw mx aw my bi"><span id="3761" class="mz la in ms b gy na nb l nc nd">{<br/>    “id”:”P001",<br/>    “name”:”Macbook M1",<br/>    “image_url”:”https://example.com/images.png"<br/>}</span></pre></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><blockquote class="nf ng nh"><p id="e603" class="jk jl ni jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">参考:<br/>T5】Golang Json by PZN</p></blockquote></div></div>    
</body>
</html>