<html>
<head>
<title>A Guided Tour of gRPC with Protocol Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带协议缓冲区的 gRPC 指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-guided-tour-of-grpc-with-protocol-buffers-a8400b1ab361?source=collection_archive---------3-----------------------#2022-04-28">https://blog.devgenius.io/a-guided-tour-of-grpc-with-protocol-buffers-a8400b1ab361?source=collection_archive---------3-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="fed9" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">gRPC 和 Protobuf 简介:</h1><p id="4bfd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">gRPC 是一个现代化的开源高性能远程过程调用(RPC)框架，最初于 2015 年在谷歌开发。gRPC 使用 HTTP 2.0 作为其底层传输协议。</p><p id="f6a4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Protobuf 是最广泛使用的接口定义语言，也是 gRPC 的消息交换格式，我们通常以 proto 文件的形式存储数据和函数契约。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/6aa499e0fab1629ea33d4b4c9454cf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fzPTvrTtsJhcpP8M-Uy-A.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">来源:<a class="ae mb" href="https://golangexample.com/" rel="noopener ugc nofollow" target="_blank">https://golangexample.com/</a></figcaption></figure><p id="8a3a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Proto 编译器(protocol)使用序列化格式为。proto 文件以及特定于语言的运行时库，让系统表现为一个接口，公开外部系统调用的过程(像任何其他 RPC 模型一样)。</p><p id="1b11" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">协议缓冲区提供了一种语言中立、平台中立、可扩展的机制，用于以向前兼容和向后兼容的方式序列化结构化数据。</p><p id="22f0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在用 gRPC 和 Protobuf 设计我们的解决方案之前，我们应该记住的一个重要事实是:协议缓冲区倾向于假设整个消息可以一次加载到内存中，并且不大于一个对象图。在处理较大的数据(大于几兆字节)时，由于数据的多个序列化副本，Protobuf 可能会导致内存使用量出现惊人的峰值。</p><p id="2671" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">好吧！理论到此为止。让我们深入到使用 gRPC 和协议缓冲区实现一个小的动手项目。</p><h1 id="9996" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置指南:</h1><p id="a165" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在我们的本地环境中设置 Protobuf 需要遵循一些步骤。我使用的是 macOS Mojave 10.14.6，我的机器上已经安装了 go1.17.1。我用自制软件安装了协议缓冲区。为此发出的命令是:</p><blockquote class="mc md me"><p id="8287" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">brew 安装 go <br/> brew 安装 protobuf</p></blockquote><p id="6e4b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们应该确保在<em class="mf">中正确地完成路径映射。bash_profile </em>文件，以便<em class="mf">protocol</em>编译器可以找到所需的插件。我使用了下面四行代码。</p><blockquote class="mc md me"><p id="591a" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">export go root =/usr/local/go<br/>export GOPATH = $ HOME/go<br/>export GOBIN = $ GOPATH/bin<br/>export PATH = $ PATH:$ go root:$ GOPATH:$ GOBIN</p></blockquote><p id="38c0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后，执行下面的命令，让上面的更改生效。</p><blockquote class="mc md me"><p id="aa57" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated"><code class="fe mj mk ml mm b">source ~/.bash_profile</code></p></blockquote><p id="4b2b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">或者，我们也可以在终端上使用下面的命令，用 GOPATH 设置和导出$PATH 变量的新值:</p><blockquote class="mc md me"><p id="57a0" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">导出路径="$PATH:$(go env GOPATH)/bin "</p></blockquote><p id="fd70" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们需要使用下面两个命令分别安装主<em class="mf"> grpc </em>包和<em class="mf">protocol-gen-go-grpc</em>包，以便使用 grpc 的协议缓冲区。</p><blockquote class="mc md me"><p id="3136" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">去安装 google.golang.org/protobuf/cmd/protoc-gen-go@latest<br/>去安装 google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</p></blockquote><h1 id="fe05" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动手::订单计费服务:</h1><p id="542d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"/></p><blockquote class="mn"><p id="8e03" class="mo mp in bd mq mr ms mt mu mv mw lf dk translated"><em class="mx">如果订单是一份“</em> <strong class="ak"> <em class="mx">食品</em> </strong> <em class="mx">”订单，我们应将送货费视为 25.0 印度卢比</em></p><p id="3cb7" class="mo mp in bd mq mr ms mt mu mv mw lf dk translated"><em class="mx">如果订单是“杂货”订单，我们应该将送货费视为 50.0 印度卢比</em></p><p id="3bf3" class="mo mp in bd mq mr ms mt mu mv mw lf dk translated"><em class="mx">如果订单是“时尚”订单，我们应考虑 15.0 印度卢比的送货费</em></p><p id="b3e5" class="mo mp in bd mq mr ms mt mu mv mw lf dk translated"><em class="mx">此外，对于所有其他类型的订单，我们应将送货费视为 10.0 印度卢比</em></p></blockquote><p id="2387" class="pw-post-body-paragraph ki kj in kk b kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb nc ld le lf ig bi translated">我们还需要遵循一个约束条件，在这个约束条件下，我们应该限制系统在订单交付给客户之前准备订单总额的账单。</p><p id="2922" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">上述问题陈述中提到的用例完全是肤浅的。我认为这是一个简单的业务用例，因此很容易解释。</p><p id="6f85" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">解决方案</strong>:我创建了一个名为<em class="mf"> /go-orders </em>的文件夹来保存构建这个项目所需代码的<em class="mf"> </em>实现。这个文件夹是在我的本地系统中除了 GOROOT 位置(/usr/local/go)之外的地方创建的。</p><p id="5eb3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们将在其中创建<em class="mf"> protos </em>包，然后创建一个名为 orderBillingService.proto 的. proto 文件，以声明请求/响应数据结构(消息)和名为 CalculateOrderTotalForBilling 的 rpc 函数声明。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nd"><img src="../Images/8c1bf74aad8dd9aea397d673cb9674fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ6_6831I7teUU2SNBI2JQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated"><strong class="bd jm">orderbillingservice . proto</strong>的实现快照</figcaption></figure><p id="76ee" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请记住在你的原型文件中使用下面一行。否则，您可能会面临编译问题。<em class="mf"> go_package </em>变量应包含 go 包的完整导入路径，它将保存为<code class="fe mj mk ml mm b">.proto</code>文件生成的代码。</p><blockquote class="mc md me"><p id="5476" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">option go _ package = "github.com/go-orders/protos"；</p></blockquote><p id="def9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们已经完成了我们的原型文件(<strong class="kk io">orderbillingservice . proto</strong>)的定义，我们可以使用下面的命令编译它以生成<strong class="kk io"> .pb.go </strong>文件:</p><blockquote class="mn"><p id="348c" class="mo mp in bd mq mr ms mt mu mv mw lf dk translated"><em class="mx">协议外出=。-go _ opt = paths = source _ relative-go-grpc _ out =。-go-grpc _ opt = paths = source _ relative protos/orderbillingservice . proto</em></p></blockquote><p id="9346" class="pw-post-body-paragraph ki kj in kk b kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb nc ld le lf ig bi translated">现在，我们可以看到，在成功编译 orderBillingService.proto 文件后，protos 包下自动生成了两个新的<em class="mf"> pb.go </em>文件，分别命名为<strong class="kk io">orderBillingService _ grpc . Pb . go</strong>和<strong class="kk io">orderBillingService . Pb . go</strong>。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b9a4c3b92091f637095987842e5f582d.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*znfAZTDmqZc5jENsv87kWg.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">go-orders 的项目结构</figcaption></figure><p id="f272" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们将实现<em class="mf">服务器</em>包中的代码来构建 gRPC 服务器。该 gRPC 服务器将运行在<strong class="kk io"><em class="mf">localhost:4040</em></strong><em class="mf">(因为我们已经在该端口上创建了一个监听器)</em>上，以使用客户端发送的请求。这也将包含在上面的原型文件中声明的 rpc 函数的业务逻辑。</p><div class="lm ln lo lp gt ab cb"><figure class="nf lq ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/a7909bd1777e012a2b15b628a866a57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rWXM0RfrhC35l2mKn3N3eA.png"/></div></figure><figure class="nf lq ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/af3a1f34f394e691ffa6bbed048c770f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*J2vpCYndzwWndhPNEdDzJA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk nl di nm nn translated">gRPC 服务器实现代码</figcaption></figure></div><p id="1b95" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是我开发这个项目时的终端截图。我在这里分享它，因为它可能会成为有用的参考。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi no"><img src="../Images/8145f4adcd1ce4c3c9a3ff36882ac40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Al7G8_csRgihz6Qbd9Fo4Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">终端中正在运行的命令列表的快照</figcaption></figure><p id="e23e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们使用命令"<strong class="kk io"><em class="mf">go run server/main . go</em></strong>"运行 gRPC 服务器。我们会注意到，我们的系统将请求允许接受<em class="mf"> localhost:4040 </em>上的传入网络。我们应该允许它，这样客户机现在就可以调用 gRPC 函数，根据我们的问题陈述获得必要的输出。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi np"><img src="../Images/3c990d5ae4a7f6408e09bf67208999f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQ01FIc1KJTr8wH4uZHMxQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">运行我们的<strong class="bd jm"> gRPC 服务器</strong>时的终端快照</figcaption></figure><p id="d14c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，随着我们的 gRPC 服务器成功运行。我们将通过在 proto 文件中名为<strong class="kk io"> OrderBillingRequest </strong>的数据结构(消息)中传递所需的属性，来尝试调用名为<strong class="kk io">CalculateOrderTotalForBilling</strong>的 RPC 函数。此外，我们还应该观察到，我们从 gRPC 服务器获得的响应符合我们的原型文件中定义的<strong class="kk io">orderbillingresson</strong>的数据结构。</p><p id="2895" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我将使用<a class="ae mb" href="https://github.com/bloomrpc/bloomrpc" rel="noopener ugc nofollow" target="_blank"> BloomRPC </a>，一个用于 GRPC 服务的开源 GUI 客户端，通过传递<strong class="kk io"> OrderBillingRequest </strong>的两个不同值来触发对运行在 localhost:4040 上的 gRPC 服务器的调用。我们可以在下面看到相应的响应也被生成。</p><div class="lm ln lo lp gt ab cb"><figure class="nf lq nq nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/be12ccd381c08a6783a588f748d47461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*b7Rb0HZgEScRJ0LMo-FbtA.png"/></div></figure><figure class="nf lq nr nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/04d2f812c03fbadba0bf633c6255038f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*_C4n8eeTJARsVuRO4ZleVA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk nl di nm nn translated">请求/响应的 BloomRPC 截图，其中为<strong class="bd jm">食品</strong> &amp; <strong class="bd jm">杂货</strong>订单计算<strong class="bd jm">订单总计</strong></figcaption></figure></div><p id="788b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">根据问题陈述，在 gRPC 函数<strong class="kk io">calculateordotoltotalforbilling</strong>的实现中，我们保留了一个约束，如果订单还没有<strong class="kk io">交付</strong>，我们将拒绝计算 OrderTotal，相反，我们将返回默认输出 0 作为 orderTotal 以及响应中的失败消息。</p><p id="8a9e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是我们将<strong class="kk io">iso order delivered</strong>标记为“<strong class="kk io"> false </strong>”的用例示例，我们可以在输出中看到<strong class="kk io"> orderTotal </strong>为零，消息告诉我们失败背后的原因。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ns"><img src="../Images/096c4816d90694e9a8b070a5966324a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zdn8_EnhZvdyg0TyL71w3Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">由于订单<strong class="bd jm">未交付</strong>，系统拒绝计算该订单的账单</figcaption></figure><p id="31d3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，让我们看看如何以编程方式调用这个 gRPC 服务器。我们已经声明了一个名为“<strong class="kk io">客户端</strong>的包，还定义了一个名为<strong class="kk io">runCalculateOrderTotalForBilling</strong>的方法，该方法最终将调用 gRPC 服务器的<strong class="kk io">CalculateOrderTotalForBilling</strong>函数来获取结果。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nt"><img src="../Images/86a5d77cc0d33accaf24f86033f92df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IYKerP3zRNyfvR5QSec3Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">客户端中<strong class="bd jm">runCalculateOrderTotalForBilling</strong>函数的定义</figcaption></figure><p id="cd91" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对 gRPC 服务器的调用将通过调用编译 proto 文件期间生成的函数<strong class="kk io">NewOrderBillingServiceClient</strong>来实现。该函数存在于<strong class="kk io">orderBillingService _ grpc . Pb . go</strong>文件中，并接收 ClientConnInterface 的一个对象作为输入。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nu"><img src="../Images/1364ae25a369af304e340e2039d2e5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbWj9rq03gnzC9XMlJl0Hw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">orderBillingService_grpc.pb.go 的快照，其中突出显示了<strong class="bd jm">neworderbillingservice client</strong>函数</figcaption></figure><p id="fec0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还在客户机的 main()函数中实现了逻辑，以便为下面两组输入参数调用 gRPC 服务器。</p><blockquote class="mc md me"><p id="024b" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">runCalculateOrderTotalForBilling(客户端，614352，500.0，“食物”，true)</p><p id="f06f" class="ki kj mf kk b kl lg kn ko kp lh kr ks mg li kv kw mh lj kz la mi lk ld le lf ig bi translated">runCalculateOrderTotalForBilling(客户端，987654，1000.0，“杂货店”，true)</p></blockquote><p id="021f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，让我们使用命令"<strong class="kk io"><em class="mf">go run client/main . go</em></strong>"来运行客户端，我们可以看到，输出是按照上面两个函数调用的顺序生成和打印的。</p><div class="lm ln lo lp gt ab cb"><figure class="nf lq nv nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/7deda2f7f89cdfabf30faf22fc36bace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*IZwhiLHsX9yhniKkLaF_3w.png"/></div></figure><figure class="nf lq nw nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/7859cd7aae80a451f86912154fb9fa5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*WB2qKT1d5XZlHhHL0tVg6g.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk nx di ny nn translated">client/main.go 文件的定义和运行后的输出</figcaption></figure></div><p id="1528" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">好的多基。！希望我能够阐述我们如何构建第一个简单的 gRPC 服务器的过程，其中在客户端和服务器之间的数据序列化/反序列化期间使用协议缓冲区。</p><p id="132d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">感谢阅读。希望你喜欢我的旅程。请随时分享您对本文的反馈。</p><h1 id="24b3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考资料:</h1><div class="nz oa gp gr ob oc"><a href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">概述|协议缓冲区| Google 开发者</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">协议缓冲区提供了一种语言中立、平台中立、可扩展的机制，用于在…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">developers.google.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq lv oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://en.wikipedia.org/wiki/GRPC" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">gRPC -维基百科</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">(gRPC 远程过程调用)也称为 Google 远程过程调用(或 good Remote Procedure Call)是一个开放的…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div></div></div>    
</body>
</html>