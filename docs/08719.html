<html>
<head>
<title>Dependency Injection: Guice Overview and Example - Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入:Guice 概述和示例-第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-injection-design-pattern-and-google-guice-examples-part-1-534d248025d2?source=collection_archive---------5-----------------------#2022-07-05">https://blog.devgenius.io/dependency-injection-design-pattern-and-google-guice-examples-part-1-534d248025d2?source=collection_archive---------5-----------------------#2022-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="a279" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">概观</h1><p id="658c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">依赖注入(DI)是一种提供客户端依赖而不是后者显式获取它们的方法。DI 是一种设计模式，其中类的依赖关系被注入到类中。为了应用 DI，我们必须注入(绑定)请求它们的客户机的依赖项。在本文中，我们不仅可以手动实例化客户端类，还可以使用框架(Guice)来自动执行这些任务。</p><p id="4326" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">DI 有两个主要好处:</p><ul class=""><li id="ff81" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">将应用程序代码中的类分离，以便于维护和扩展。</li><li id="9bf3" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">使单元测试更容易。</li></ul><p id="fe28" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">Guice 是一个开源的基于 Java 的 DI 框架。</p><blockquote class="md me mf"><p id="99b3" class="kl km mg kn b ko lj kq kr ks lk ku kv mh ll ky kz mi lm lc ld mj ln lg lh li ij bi translated">简而言之，Guice 减少了在 Java 代码中对工厂和 new 的需求。把 Guice 的@Inject 当做新的 new。在某些情况下，您仍然需要编写工厂，但是您的代码不会直接依赖于它们。您的代码将更易于更改、单元测试和在其他上下文中重用。</p><p id="525c" class="kl km mg kn b ko lj kq kr ks lk ku kv mh ll ky kz mi lm lc ld mj ln lg lh li ij bi translated">Guice 支持 Java 的类型安全特性，尤其是在 Java 5 中引入的特性，比如泛型和注释。您可能认为 Guice 填补了核心 Java 缺失的特性。理想情况下，语言本身会提供大部分相同的特性，但是在这样的语言出现之前，我们有 Guice。</p><p id="4c3a" class="kl km mg kn b ko lj kq kr ks lk ku kv mh ll ky kz mi lm lc ld mj ln lg lh li ij bi translated">Guice 帮助你设计更好的 API，Guice API 本身就是一个很好的例子。Guice 不是厨房水槽。我们用至少三个用例来证明每个特性。当有疑问时，我们就把它排除在外。我们构建通用功能，使您能够扩展 Guice，而不是将每个功能添加到核心框架中。</p><p id="ba40" class="kl km mg kn b ko lj kq kr ks lk ku kv mh ll ky kz mi lm lc ld mj ln lg lh li ij bi translated">Guice 旨在使开发和调试更容易、更快，而不是更难、更慢。在这种情况下，Guice 避开了惊喜和魔法。不管有没有工具，你都应该能够理解代码，尽管工具可以让事情变得更简单。当错误发生时，Guice 会额外生成有用的消息。</p></blockquote><h1 id="2bb4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">依赖注入示例</h1><p id="c678" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个例子展示了不使用任何框架的 DI 的核心功能。这个例子有一个由具体类(Lion 类)实现的接口动物:</p><p id="d223" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">带功能语音的动物接口():</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="50e4" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">public interface </strong>Animal {<br/>  String voice();<br/>}</span></pre><p id="e055" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">Lion 类实现了动物接口的语音功能，返回“grrrrr”。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="69f0" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">public final class </strong>Lion <strong class="mp ir">implements </strong>Animal {<br/>  @Override<br/>  <strong class="mp ir">public </strong>String voice() { <strong class="mp ir">return "grrrrr"</strong>; }<br/>}</span></pre><p id="22aa" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">ZooKeeper 类的构造函数将有一个动物作为参数，还有 getAnimal()的方法</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fef2" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">public final class </strong>ZooKeeper {<br/>  <strong class="mp ir">private final </strong>Animal <strong class="mp ir">animal</strong>;<br/><br/>  <strong class="mp ir">public </strong>ZooKeeper(Animal animal) {<br/>    <strong class="mp ir">this</strong>.<strong class="mp ir">animal </strong>= animal;<br/>  }<br/><br/>  <strong class="mp ir">public </strong>Animal getAnimal() {<br/>    <strong class="mp ir">return animal</strong>;<br/>  }<br/>}</span></pre><p id="f6a8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在主应用程序中，我们将绑定它们:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3b30" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">public class </strong>App {<br/>  <strong class="mp ir">public static void </strong>main(String[] args) {<br/>    ZooKeeper zooKeeper = <strong class="mp ir">new </strong>ZooKeeper(<strong class="mp ir">new </strong>Lion());<br/>    System.<strong class="mp ir"><em class="mg">out</em></strong>.println(zooKeeper.getAnimal().voice());<br/>  }<br/>}</span></pre><p id="808d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">它将打印输出:grrrrr</p><p id="9155" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">从上面的例子中我们可以看到，这是阿迪的实现，没有任何框架或库。我们称之为 DI 的原因是因为 ZooKeeper 类不知道它所调用的动物:</p><ul class=""><li id="30f9" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">ZooKeeper 类依赖于 Animal 接口而不是 Lion 实现，所以这些类是解耦的。</li><li id="dd7e" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">在单元测试实现时，单元测试用例可以将一个模拟动物传递给动物园管理员，使单元测试更容易，而无需了解动物种类的细节。</li></ul><h1 id="0884" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">指南示例</h1><p id="3d8f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">理解了上面的 DI 示例之后，在这一节中，我们将介绍如何用 Guice 实现同样的功能。让我们回顾一下下面这个使用 Guice 实现的例子。请注意，这只是一个简单的例子，用 Guice 演示 DI 概念。如果项目的代码有许多依赖项，Guice 的主要优势就体现出来了。</p><p id="50f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在 Maven central 上<a class="ae mc" href="https://mvnrepository.com/artifact/com.google.inject/guice" rel="noopener ugc nofollow" target="_blank">可以使用</a><a class="ae mc" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Guice </a>。要使用 Guice，我们需要在 Maven 中将这个依赖项添加到 pom.xml 文件中:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d151" class="mt jo iq mp b gy mu mv l mw mx">&lt;<strong class="mp ir">dependencies</strong>&gt;<br/>  &lt;<strong class="mp ir">dependency</strong>&gt;<br/>    &lt;<strong class="mp ir">groupId</strong>&gt;com.google.inject&lt;/<strong class="mp ir">groupId</strong>&gt;<br/>    &lt;<strong class="mp ir">artifactId</strong>&gt;guice&lt;/<strong class="mp ir">artifactId</strong>&gt;<br/>    &lt;<strong class="mp ir">version</strong>&gt;4.1.0&lt;/<strong class="mp ir">version</strong>&gt;<br/>  &lt;/<strong class="mp ir">dependency</strong>&gt;<br/>&lt;/<strong class="mp ir">dependencies</strong>&gt;</span></pre><p id="cba0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，当我们让 Guice 创建一个类的实例时，它会找到标有@Inject 的构造函数。如果 Guice 可以找到，它会将该构造函数的参数理解为类的依赖项，并将注入它。参考下面的示例代码，看看我们如何注入来让 Guice 为构造函数注入一个动物:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4c51" class="mt jo iq mp b gy mu mv l mw mx">import <a class="ae mc" href="https://source.corp.google.com/piper///depot/google3/third_party/java_src/jsr330_inject/java/javax/inject/package-info.java;rcl=458814561;l=155" rel="noopener ugc nofollow" target="_blank">javax.inject</a>.<a class="ae mc" href="https://source.corp.google.com/piper///depot/google3/third_party/java_src/jsr330_inject/java/javax/inject/Inject.java;rcl=458814561;l=185" rel="noopener ugc nofollow" target="_blank">Inject</a>;<br/><strong class="mp ir">public final class </strong>ZooKeeper {<br/>  <strong class="mp ir">private final </strong>Animal <strong class="mp ir">animal</strong>;<br/><br/>  @Inject<br/>  ZooKeeper(Animal animal) {<br/>    <strong class="mp ir">this</strong>.<strong class="mp ir">animal </strong>= animal;<br/>  }<br/><br/>  <strong class="mp ir">public </strong>Animal getAnimal() {<br/>    <strong class="mp ir">return animal</strong>;<br/>  }<br/>}</span></pre><p id="c6ac" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">Guice 还支持回退注入。但是，我们应该显式声明并标记@Inject to 构造函数，以澄清该类是由 Guice 创建的，如下面的示例 Lion 类:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4de7" class="mt jo iq mp b gy mu mv l mw mx">import <a class="ae mc" href="https://source.corp.google.com/piper///depot/google3/third_party/java_src/jsr330_inject/java/javax/inject/package-info.java;rcl=458814561;l=155" rel="noopener ugc nofollow" target="_blank">javax.inject</a>.<a class="ae mc" href="https://source.corp.google.com/piper///depot/google3/third_party/java_src/jsr330_inject/java/javax/inject/Inject.java;rcl=458814561;l=185" rel="noopener ugc nofollow" target="_blank">Inject</a>;<br/><strong class="mp ir">public final class </strong>Lion <strong class="mp ir">implements </strong>Animal {<br/>  @Inject Lion(){}<br/>  @Override<br/>  <strong class="mp ir">public </strong>String voice() { <strong class="mp ir">return "grrrrr"</strong>; }<br/>}</span></pre><p id="c995" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">其次，下面的代码告诉 Guice 如何通过继承 Guice AbstractModule 来了解依赖关系，并覆盖 configure()函数。这个函数将让 Guice 实例化实现类的一个实例。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3723" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">import </strong>com.google.inject.AbstractModule;<br/><br/><strong class="mp ir">public final class </strong>AnimalModule <strong class="mp ir">extends </strong>AbstractModule {<br/>  @Override<br/>  <strong class="mp ir">protected void </strong>configure() {<br/>    bind(Animal.<strong class="mp ir">class</strong>).to(Lion.<strong class="mp ir">class</strong>);<br/>  }<br/>}</span></pre><p id="6070" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，在我们有了具有依赖关系的@Inject 构造函数和提供依赖关系的 AbstractModule 类之后，我们通过调用 Guice.createInjector()创建一个注入器来将它们联系在一起。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d658" class="mt jo iq mp b gy mu mv l mw mx"><strong class="mp ir">import </strong>com.google.inject.Guice;<br/><strong class="mp ir">import </strong>com.google.inject.Injector;<br/><br/><strong class="mp ir">public class </strong>App {<br/>  <strong class="mp ir">public static void </strong>main(String[] args) {<br/>    Injector injector = Guice.<em class="mg">createInjector</em>(<strong class="mp ir">new </strong>AnimalModule());<br/>    ZooKeeper zooKeeper = injector.getInstance(ZooKeeper.<strong class="mp ir">class</strong>);<br/><br/>    System.<strong class="mp ir"><em class="mg">out</em></strong>.println(zooKeeper.getAnimal().voice());<br/>  }<br/>}</span></pre><p id="b789" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，这将打印到输出:grrrrr</p><p id="9946" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这是上面示例的 Java Maven 项目结构:</p><figure class="mk ml mm mn gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi my"><img src="../Images/ff12375a5a8317df60e4609af1f30150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0HjIYQXqxRwXBCBynf1zQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Java 项目结构</figcaption></figure><h1 id="0663" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="0392" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们讨论了在 Java 应用程序中实现自动化 DI 任务的 Guice 的基本功能。我希望这个关于 Guice 功能的基本概述能帮助大家继续学习，并能应用到你的项目中。</p><p id="0162" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，我将撰写本系列的第 2 部分，这样我们就可以看到 Guice 如何帮助在项目中更容易地实现单元测试。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="3e58" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你喜欢这个故事，请<a class="ae mc" href="https://medium.com/@techisbeautiful" rel="noopener">关注</a>、<a class="ae mc" href="https://medium.com/subscribe/@techisbeautiful" rel="noopener">让我</a>成为第一个收到我下一个故事邮件的人。</p><p id="9af3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><a class="ae mc" href="https://medium.com/@techisbeautiful/membership" rel="noopener">你可以在这里</a>成为媒介会员，就可以<strong class="kn ir">无限制访问</strong>媒介平台上的每一个故事。如果你使用上面的链接，它也支持我，因为我有一个来自 Medium 的小佣金。谢谢大家！</p><h1 id="d068" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">参考</h1><p id="6d59" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">[1]<a class="ae mc" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank">https://github.com/google/guice</a></p></div></div>    
</body>
</html>