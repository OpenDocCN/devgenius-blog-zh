<html>
<head>
<title>API development with type-safety across the entire stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨整个堆栈的类型安全 API 开发</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/api-development-with-type-safety-across-the-entire-stack-1589f182d0d6?source=collection_archive---------7-----------------------#2022-01-22">https://blog.devgenius.io/api-development-with-type-safety-across-the-entire-stack-1589f182d0d6?source=collection_archive---------7-----------------------#2022-01-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f1f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一年前，我在 GoCardless 工作，制作一个<a class="ae ki" href="https://gocardless.com/solutions/instant-bank-pay/" rel="noopener ugc nofollow" target="_blank">开放式银行产品</a>的原型。</p><p id="d603" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这是我在一段时间内完成的第一个产品工作(这不是 Kubernetes 操作符或数据库工具),所以重温 API 开发场景是明智的，如果有更好的选择，我不想像以前那样做事情。</p><p id="3217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的预感是对的 API 场景<em class="kj">已经</em>向前移动了。在查看了各种工具之后，我们采用了一个名为<a class="ae ki" href="https://goa.design/" rel="noopener ugc nofollow" target="_blank"> Goa </a>的工具，它帮助我们构建了一个令我震惊的 API。</p><p id="4f2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几乎不费吹灰之力，果阿就帮助了:</p><ul class=""><li id="1f2e" class="kk kl in jm b jn jo jr js jv km jz kn kd ko kh kp kq kr ks bi translated">快速迭代 API 设计</li><li id="6b1d" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">生成类型安全的服务器实现，保证与 API 规范一致</li><li id="c853" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">产生传输规范，如 OpenAPI 规范</li><li id="c797" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">…从中我们可以生成类型化的 API 客户端和文档</li></ul><p id="73eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一年后，我现在在<a class="ae ki" href="https://incident.io/" rel="noopener ugc nofollow" target="_blank"> incident.io </a>工作，在那里我的第一个贡献就是使用 Goa 来增强我们的 API。事实证明这是非常有价值的，尤其是对于一个想要快速行动而不是打破常规的初创企业。</p><p id="207c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章解释了工具链是如何工作的，以及当你采用它时你可以免费得到的一切。</p><h1 id="f307" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">API 设计</h1><p id="5d90" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">所以你有一个产品想法，它需要一个 API。</p><p id="0643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Goa 的一切都是从“设计”开始的，在这里您使用 Goa DSL 来指定服务和方法，以及它们所使用的类型。</p><p id="2c9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">借用我在 incident.io 的工作，假设我们想要一个 API 来创建一个事件。这可能是这样的:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8691" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">package</strong> design<br/><br/><strong class="mg io">import</strong> (<br/>  <strong class="mg io">.</strong> "goa.design/goa/v3/dsl"<br/>)<br/><br/><strong class="mg io">var</strong> Incident <strong class="mg io">=</strong> Type("Incident", <strong class="mg io">func</strong>() {<br/>  Attribute("id", String, "Unique identifier for the incident", <strong class="mg io">func</strong>() {<br/>    Example("01FDAG4SAP5TYPT98WGR2N7W91")<br/>  })<br/>  Attribute("name", String, "Name of the incident", <strong class="mg io">func</strong>() {<br/>    Example("Full service outage")<br/>  })<br/>  Required(<br/>    "id",<br/>    "name",<br/>  )<br/>})<br/><br/><strong class="mg io">var</strong> _ <strong class="mg io">=</strong> Service("Incidents", <strong class="mg io">func</strong>() {<br/>  Description("Manage incidents")<br/><br/>  HTTP(<strong class="mg io">func</strong>() {<br/>    Path("/api/incidents")<br/>  })<br/><br/>  Method("Create", <strong class="mg io">func</strong>() {<br/>    Description("Create a new incident")<br/><br/>    Payload(<strong class="mg io">func</strong>() {<br/>      Reference(Incident)<br/>      Attribute("name")<br/>    })<br/><br/>    Result(Incident)<br/><br/>    HTTP(<strong class="mg io">func</strong>() {<br/>      POST("/")<br/>    })<br/>  })<br/>})</span></pre><p id="c379" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们定义了一个<code class="fe mp mq mr mg b">Incident</code>类型和一个<code class="fe mp mq mr mg b">Incidents</code>服务，以及一个接受事件名称并返回一个<code class="fe mp mq mr mg b">Incident</code>的<code class="fe mp mq mr mg b">Create</code>方法。所有这些定义都是从传输中抽象出来的，用<code class="fe mp mq mr mg b">HTTP</code>块将应用程序概念绑定到 HTTP 调用。</p><p id="86d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这个例子包含了 HTTP 绑定，但是如果您更喜欢用 gRPC 绑定来服务您的 API，那么您也可以轻松地包含 gRPC 绑定。这是 Goa 的优势之一，作者真正理解 API，并为每一个支持的传输创建了可靠的抽象，很少泄漏。</p><p id="abbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到我们的例子:现在我们有一个设计，但是没有实现。我们将使用 Goa 对其余部分进行编码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a950" class="mk kz in mg b gy ml mm l mn mo">$ goa gen github.com/lawrencejones/goa-example/api/design -o api<br/>api/gen/http/incidents/server/encode_decode.go<br/>api/gen/http/incidents/server/paths.go<br/>api/gen/http/incidents/server/server.go<br/>api/gen/http/incidents/server/types.go<br/>api/gen/http/openapi.json<br/>api/gen/incidents/client.go<br/>api/gen/incidents/endpoints.go<br/>api/gen/incidents/service.go</span></pre><p id="f33d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来分解一下:</p><ul class=""><li id="b135" class="kk kl in jm b jn jo jr js jv km jz kn kd ko kh kp kq kr ks bi translated"><code class="fe mp mq mr mg b">api/gen/incidents</code>包含事件服务的应用程序级接口，独立于传输的一切。我们将在构建服务时实现这些接口。</li><li id="ff9e" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated"><code class="fe mp mq mr mg b">api/gen/http/incidents</code>将 HTTP 级别的概念(HTTP 请求、HTTP 响应类型)绑定到与传输无关的服务接口。<code class="fe mp mq mr mg b">encode_decode.go</code>是关于从 XML/JSON/etc 到 Go-native 类型，所以开发者可以避免传输问题。</li><li id="e768" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated"><code class="fe mp mq mr mg b">api/gen/http/openapi.json</code>是 API 的 OpenAPI 规范。</li></ul><p id="3e5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Goa 生成的应用程序界面应该不足为奇:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b83c" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">package</strong> incidents<br/><br/><strong class="mg io">type</strong> Service <strong class="mg io">interface</strong> {<br/>  <em class="kj">// Create a new incident</em><br/>  Create(context<strong class="mg io">.</strong>Context, <strong class="mg io">*</strong>CreatePayload) (res <strong class="mg io">*</strong>Incident, err <strong class="mg io">error</strong>)<br/>}<br/><br/><em class="kj">// Incident is the result type of the Incidents service Create method.</em><br/><strong class="mg io">type</strong> Incident <strong class="mg io">struct</strong> {<br/>  <em class="kj">// Unique identifier for the incident</em><br/>  ID <strong class="mg io">string</strong><br/>  <em class="kj">// Name of the incident</em><br/>  Name <strong class="mg io">string</strong><br/>}</span></pre><p id="b7d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为实现这个 API 设计的开发人员，剩下要做的就是编写一个满足这个接口的实现。</p><p id="1bef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来像这样:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2d46" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">package</strong> api<br/><br/><strong class="mg io">import</strong> (<br/>  "context"<br/>  "github.com/lawrencejones/goa-example/api/gen/incidents"<br/>  "github.com/google/uuid"<br/>)<br/><br/><strong class="mg io">func</strong> NewIncidents() incidents<strong class="mg io">.</strong>Service {<br/>  <strong class="mg io">return</strong> <strong class="mg io">&amp;</strong>incidentsService{}<br/>}<br/><br/><strong class="mg io">type</strong> incidentsService <strong class="mg io">struct</strong> {<br/>}<br/><br/><strong class="mg io">func</strong> (svc <strong class="mg io">*</strong>incidentsService) Create(ctx context<strong class="mg io">.</strong>Context, payload <strong class="mg io">*</strong>incidents<strong class="mg io">.</strong>CreatePayload) (<strong class="mg io">*</strong>incidents<strong class="mg io">.</strong>Incident, <strong class="mg io">error</strong>) {<br/>  inc <strong class="mg io">:=</strong> incidents<strong class="mg io">.</strong>Incident{<br/>    ID<strong class="mg io">:</strong>   uuid<strong class="mg io">.</strong>NewString(),<br/>    Name<strong class="mg io">:</strong> payload<strong class="mg io">.</strong>Name,<br/>  }<br/><br/>  <strong class="mg io">return</strong> <strong class="mg io">&amp;</strong>inc, nil<br/>}</span></pre><p id="c4c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你习惯了这种模式——设计、生成、实现——逐步构建你的 API 就变得非常容易了。该流程强调构建任何 API 的最重要部分，即设计，实现被简化为修复编译器错误(<code class="fe mp mq mr mg b">*incidentsService does not implement incidents.Service (missing Create method)</code>)。</p><p id="2f0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是最难的部分——从这里开始，一切都很容易。</p><h1 id="fe69" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">生成客户端</h1><p id="fff4" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">使用 API 设计来生成后端类型，编译器将保证我们的实现是一致的，您可以完全相信生成的 API 规范是正确的和最新的。</p><p id="1c93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了忠实的规范，比如 OpenAPI 规范，我们可以用它们来生成 API 客户端。我工作过的大多数项目在 TypeScript 中都有一个前端组件，它可以从保证与服务器实现一致的强类型客户端中受益。</p><p id="7ca3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank"> OpenAPI 生成器</a>可以在这里帮到你。它附带了许多生成器，这些生成器使用 OpenAPI 规范来构建各种风格(语言、框架等)的客户端。</p><p id="3e83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择正确的发电机是关键，因为质量可能不一致。我们在<a class="ae ki" href="https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/typescript-fetch.md" rel="noopener ugc nofollow" target="_blank"> typescript-fetch </a>上取得了成功，这是一个普通的 typescript 客户端，与 Goa 生产的传统<code class="fe mp mq mr mg b">openapi.yml</code>配合得最好:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="bc78" class="mk kz in mg b gy ml mm l mn mo">$ make clients/typescript<br/>java -jar openapi-generator-cli.jar \<br/>    generate \<br/>        --generator-name typescript-fetch \<br/>        --input-spec api/gen/http/openapi.json \<br/>        --skip-validate-spec \<br/>        --additional-properties npmName=goa-example,typescriptThreePlus=true,modelPropertyNaming=original \<br/>        --output clients/typescript<br/><br/>[main] INFO  o.o.codegen.DefaultGenerator - Generating with dryRun=false<br/>[main] INFO  o.o.codegen.DefaultGenerator - OpenAPI Generator: typescript-fetch (client)<br/>[main] INFO  o.o.codegen.DefaultGenerator - Generator 'typescript-fetch' is considered stable.<br/>[main] INFO  o.o.codegen.TemplateManager - writing file /Users/lawrence/Projects/goa-example/clients/typescript/src/models/IncidentsCreateRequestBody.ts<br/>...</span></pre><p id="f854" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在您有了一个 API 客户端，为集成商提供了使用他们选择的语言的理想体验:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e072" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">import</strong> { IncidentsApi, Configuration } <strong class="mg io">from</strong> "clients/typescript";<br/><br/><strong class="mg io">const</strong> client <strong class="mg io">=</strong> IncidentsApi(<strong class="mg io">new</strong> Configuration());<br/><strong class="mg io">const</strong> incident <strong class="mg io">=</strong> <strong class="mg io">await</strong> client<br/>  .incidentsCreate({<br/>    createRequestBody: {<br/>      name: "Full service outage",<br/>    },<br/>  });<br/><br/>alert(`Created incident with ID=${incident.id}`);</span></pre><p id="d9e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript 只是数百个生成器中的一个——完整列表见这里的<a class="ae ki" href="https://openapi-generator.tech/docs/generators/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6094" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">前端优势</h1><p id="8513" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在 incident.io，我们有一个 monorepo，同时包含前端 web 应用程序(<code class="fe mp mq mr mg b">client</code>)和后端实现(<code class="fe mp mq mr mg b">server</code>)，后端使用 Goa 公开一个 API 供前端使用。</p><p id="e4e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">引入 Goa 的好处有很多，但是在构建前端表单时，Goa + TypeScript 客户端确实大放异彩。我们使用<a class="ae ki" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank"> react-hook-form </a>作为前端表单组件，它有 TypeScript 绑定，所以你可以强类型化你的表单域。</p><p id="886b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个 TypeScript 客户端，我们可以用客户端类型参数化 react-hook-forms，允许 TypeScript 编译器告诉我们何时我们的表单定义与我们的 API 定义不匹配:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5e31" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">import</strong> { useClient } <strong class="mg io">from</strong> "contexts/ClientContext";<br/><strong class="mg io">import</strong> { IncidentsCreateRequestBody } <strong class="mg io">from</strong> "clients/typescript";<br/><br/><strong class="mg io">const</strong> IncidentCreateForm <strong class="mg io">=</strong> ({<br/>  closeCallback,<br/>}: {<br/>  <strong class="mg io">closeCallback</strong>: () <strong class="mg io">=&gt;</strong> <strong class="mg io">void</strong>;<br/>}): React.ReactElement <strong class="mg io">|</strong> <strong class="mg io">null</strong> <strong class="mg io">=&gt;</strong> {<br/>  <strong class="mg io">const</strong> client <strong class="mg io">=</strong> useClient();<br/><br/>  <strong class="mg io">const</strong> { register, handleSubmit } <strong class="mg io">=</strong> useForm<strong class="mg io">&lt;</strong>IncidentsCreateRequestBody<strong class="mg io">&gt;</strong>();<br/><br/>  <strong class="mg io">const</strong> onSubmit <strong class="mg io">=</strong> (body: IncidentsCreateRequestBody) <strong class="mg io">=&gt;</strong> {<br/>    client<br/>      .incidentsCreate({createRequestBody: body})<br/>      .then(() <strong class="mg io">=&gt;</strong> {<br/>        closeCallback();<br/>      });<br/>  };<br/><br/>  <strong class="mg io">return</strong> (<br/>    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;<br/>      &lt;input {...register("name")} /&gt;<br/>      &lt;input type="submit" /&gt;<br/>    &lt;/form&gt;<br/>  );<br/>}</span></pre><p id="f96b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此之前，构建使用 API 的表单需要注意产生与后端一致的请求。对该 API 进行修改将需要手动审查前端代码，以找到 API 的所有使用，希望您在部署之前发现它们。</p><p id="19c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个有 Goa 和生成客户端的世界中，您可以:</p><ol class=""><li id="8190" class="kk kl in jm b jn jo jr js jv km jz kn kd ko kh ms kq kr ks bi translated">调整 Goa 设计</li><li id="80f7" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh ms kq kr ks bi translated">生成后端类型和前端客户端(<code class="fe mp mq mr mg b">make api/gen clients/typescript</code>)</li><li id="4f48" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh ms kq kr ks bi translated">修复后端编译器错误</li><li id="bab0" class="kk kl in jm b jn kt jr ku jv kv jz kw kd kx kh ms kq kr ks bi translated">修复前端编译器错误</li></ol><p id="d611" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将事件字段<code class="fe mp mq mr mg b">name</code>改为<code class="fe mp mq mr mg b">description</code>，我们将立即得到一个关于表单的编译器错误:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="117b" class="mk kz in mg b gy ml mm l mn mo">IncidentCreateForm.tsx:21:20 - error TS2322:<br/>        Type '"name"' is not assignable to type '"description" | "severity_id"'.<br/><br/>21      register("name")<br/>         ~~</span></pre><p id="bda7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不能夸大这是多么有用，特别是对于最大化开发人员的生产力和对变化的信心。</p><p id="2ca1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在更新规范(OpenAPI 等)在任何意义上都是可选的项目中，它将不可避免地与现实脱节。</p><p id="544b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本质上，这个工具链非常有价值，因为您可以相信 API 规范是准确的。这一保证意味着围绕 OpenAPI 的整个工具生态系统变得更加引人注目。</p><p id="f614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅举一个例子，<a class="ae ki" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger </a>可以为 OpenAPI 规范生成真正高质量的文档。</p><p id="42f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的大多数果阿项目都有一个<code class="fe mp mq mr mg b">make docs</code>目标:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="59e1" class="mk kz in mg b gy ml mm l mn mo">$ make docs<br/>docker run --platform=linux/amd64 -p 4000:4000 --rm -v "$<strong class="mg io">(</strong>pwd<strong class="mg io">)</strong>/api:/api" -it quay.io/goswagger/swagger:v0.28.0 \<br/>                serve --no-open --port=4000 --host=0.0.0.0 /api/gen/http/openapi.json<br/>2022/01/22 17:57:24 serving docs at http://localhost:4000/docs</span></pre><p id="45fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是您获得付费产品所需的所有文档:</p><figure class="mb mc md me gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/fe3131f5abd52564330caa7af3f352fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d5XbtYW0I-y2pYtC.png"/></div></div></figure><h1 id="4e16" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这一切感觉太简单了</h1><p id="f7c1" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">当我在 2015 年第一次加入 GoCardless 时，我们刚刚构建了 crank，这是一个从<a class="ae ki" href="https://json-schema.org/draft/2019-09/json-schema-hypermedia.html" rel="noopener ugc nofollow" target="_blank"> JSON hyperschema </a>生成 API 客户端库的内部工具。</p><p id="488f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一家(当时)认为他们的产品是 API 的公司，这是显而易见的。Crank 帮助我们维护了一套跨多种语言的客户端库，并自动生成我们的文档，这些文档通常是称赞和产品推荐的来源。</p><p id="b082" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不过，维护 crank 并不有趣。到 2021 年我离开的时候，crank 仍然在构建我们的客户端库和文档，尽管它是每个人都喜欢讨厌的工具。</p><p id="72a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到这一点，找到一个需要几天时间来设置并提供惊人的开发体验的工具链就像是一种欺骗。我们的内部 API 拥有可以与 API 产品相媲美的文档，这是我永远不会不惊叹的。</p><p id="1ecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 incident.io 中采用这些工具是我们能够如此快速地行动，并如此自信地进行产品变更的主要原因之一。无论您使用什么语言，找到一个类似的工具链并尝试一下——我可以毫无保留地推荐它！</p><p id="1f17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">在</em><a class="ae ki" href="https://news.ycombinator.com/item?id=30039988" rel="noopener ugc nofollow" target="_blank"><em class="kj">hacker news</em></a><em class="kj">上讨论这个帖子。如果你喜欢这个帖子并想看更多，请关注我</em><a class="ae ki" href="https://twitter.com/lawrjones" rel="noopener ugc nofollow" target="_blank"><em class="kj">@ lawrjones</em></a><em class="kj">。</em></p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="cf58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">原载于 2022 年 1 月 22 日</em><a class="ae ki" href="https://blog.lawrencejones.dev/goa" rel="noopener ugc nofollow" target="_blank"><em class="kj">https://blog . Lawrence Jones . dev</em></a><em class="kj">。</em></p></div></div>    
</body>
</html>