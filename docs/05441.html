<html>
<head>
<title>React Code Splitting, Bundling, Lazy loading and Suspens — beginner guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React代码分割、捆绑、延迟加载和暂停——初学者指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-code-splitting-bundling-lazy-loading-and-suspens-all-you-need-to-know-beginner-guide-c6e122454db6?source=collection_archive---------4-----------------------#2021-08-11">https://blog.devgenius.io/react-code-splitting-bundling-lazy-loading-and-suspens-all-you-need-to-know-beginner-guide-c6e122454db6?source=collection_archive---------4-----------------------#2021-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7e33" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React捆绑优化变得简单</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/674d93908075bb035da72c6869515710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tEyUkXBHScyg1cS5"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c436" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">什么是代码捆绑和拆分，为什么需要它？</h1><h2 id="4705" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated"><strong class="ak">代码捆绑</strong></h2><p id="741d" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">是将应用程序的所有文件捆绑成一个文件(捆绑包)的过程，在该文件中，应用程序可以立即提供给客户端。</p><h2 id="fa55" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated"><strong class="ak">代码拆分</strong></h2><p id="02ba" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">是将包/构建文件分割成更小的块，根据需要提供给客户机的过程。</p><h2 id="df35" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated"><strong class="ak">我们为什么需要拆分？</strong></h2><p id="818a" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">基本上是因为我们不想给客户提供他们可能永远不需要或者在以后阶段(不是在最初的几毫秒内)需要的代码。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="2b5a" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">React代码捆绑…和拆分</h1><p id="b7d3" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">绑定和拆分的概念存在于React中，事实上React文档专门讲述了如何优化React应用程序以支持代码拆分。</p><p id="1df6" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">React生态系统本身有一些很酷的开箱即用的解决方案，它们也利用了这些概念，像<a class="ae ks" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> CRA </a>、<a class="ae ks" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">下一个</a>和<a class="ae ks" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank">盖茨比</a>这样的工具可以做最少的工作，以非常少的配置获得应用程序的优化构建文件。</p><h2 id="9b00" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated">React代码分割是如何工作的</h2><p id="9603" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">要回答这个问题，我们需要对一些著名而神秘的工具有一个总体的了解:<br/>1-<a class="ae ks" href="https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules" rel="noopener ugc nofollow" target="_blank"><strong class="mc io">web pack</strong></a>:一个捆绑工具，做一些很酷的事情，其中一个就是根据一些配置捆绑和拆分你的代码。<br/> 2- <a class="ae ks" href="https://babeljs.io/docs/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="mc io">巴别塔</strong> </a>:一个移植工具，非常适合像ECMS - &gt; CJS这样的事情转换。-阅读更多关于它的内容-<br/>3-<a class="ae ks" href="https://rollupjs.org/guide/en/#overview" rel="noopener ugc nofollow" target="_blank"><strong class="mc io">roll up</strong></a>:一个工具，它能做一些令人惊奇的事情，其中之一就是将JS模块(ECMS)移植到commonJS (CJS)。</p><p id="8cdd" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">Webpack是一个到处都在使用的著名工具，所以我们将继续这篇文章，深入研究它的工作原理以及如何使用webpack优化我们的应用程序。</p><p id="fb4e" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">现在，如果您正在使用create-react-app或NextJs，您可能不需要在webpack或任何其他捆绑工具中进行任何直接配置，因为这些工具已经预先设置了完成工作的webpack——尽管您可能希望查看这些工具的文档以了解如何扩展web pack的这些预先配置的设置。但是，如果您没有使用上面提到的任何工具，那么您应该从以下几点开始:</p><h2 id="471b" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated">Webpack自己会变魔术</h2><p id="4bea" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">您所需要做的就是指定一个入口点和输出目录，您的文件应该被打包到这个目录中。以下是webpack文件的一个片段:</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="caba" class="ll ku in nl b gy np nq l nr ns">const path = require('path');<br/>module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'bundle.js',<br/>    path: path.resolve(__dirname, 'dist'),<br/>  },<br/>};</span></pre><p id="9868" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">所以这将把<code class="fe nt nu nv nl b">index.js </code>和它所有的依赖项捆绑到一个名为<code class="fe nt nu nv nl b">bundle.js</code>的文件中，并把它放在一个名为<code class="fe nt nu nv nl b">root-folder/dist</code>的文件夹中</p><p id="1351" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">现在和我一起想一想，如果我们的应用程序很大呢？捆绑会超级大对吧？那又怎样？<br/>一个巨大的包文件意味着更慢的TTFB(到达第一个字节的时间),这意味着用户将在页面上显示任何内容之前等待一段时间。</p><p id="f0c7" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">我们肯定可以通过webpack进行优化，我们有(2)个推荐选项:</p><h2 id="1950" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated">Webpack动态导入:</h2><p id="8d94" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">只提供用户访问页面时第一次看到的内容，其余的内容可以在以后提供(或者按需提供，或者通过并行加载)。这被称为动态导入，顾名思义，它使用异步导入机制，将每个异步导入的代码拆分到自己单独的文件中。让我们看一个例子:</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="cf55" class="ll ku in nl b gy np nq l nr ns">async function getComponent() {<br/>  const element = document.createElement('div');<br/>  const { default: _ } = await import('lodash');<br/>  <br/>   const element = document.createElement('div');<br/>   element.innerHTML = _.join(['Hello', 'webpack'], ' ');<br/><br/>   return element;<br/>}</span><span id="d5ed" class="ll ku in nl b gy nw nq l nr ns">(async () =&gt; {<br/>  <!-- -->const Component = await getComponent();<br/>  ReactDOM.render( &lt;Component /&gt;,document.getElementById('some-id'))<br/>})()</span></pre><p id="77ca" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">让我们假设您有一个使用<code class="fe nt nu nv nl b">lodash</code>的组件，我们想单独加载该组件及其依赖关系(<code class="fe nt nu nv nl b">lodash</code>)，所以我们构建了一个动态导入<code class="fe nt nu nv nl b">lodash</code>的函数，它将告诉webpack将<code class="fe nt nu nv nl b">lodash’s</code>代码拆分到它自己的文件中。这将使我们的组件包文件变得更小，从而在客户端花费更少的时间来加载。-如果您不熟悉async/await语法，您可以在这里阅读更多信息-</p><h2 id="4079" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated">Webpack共享模块:</h2><p id="7d19" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">如果我们有3个页面使用了名为<code class="fe nt nu nv nl b">moment</code>的第三方库，我们想为每个页面制作3个包</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="7be5" class="ll ku in nl b gy np nq l nr ns">const path = require('path');<br/>module.exports = {<br/>  entry: {<br/>   firstPage: ./src/firstPage.js, <br/>   secondPage: ./src/secondPage.js<br/>   thirdPage: ./src/thirdPage.js<br/>  }<br/>  ...<br/>};</span></pre><p id="dfc0" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">当Webpack运行文件并分别捆绑每个页面时，它将遍历每个页面(定义为入口点)并捆绑其代码和它使用的任何依赖项)这意味着<code class="fe nt nu nv nl b">moment</code>将与3个页面捆绑在一起，换句话说，它将被复制3次。我们可以增强上面的代码片段，将<code class="fe nt nu nv nl b">moment</code>分割成它自己的块，并在每个文件中都需要它。</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="fba0" class="ll ku in nl b gy np nq l nr ns">const path = require('path');<br/>module.exports = {<br/> firstPage: {<br/>  import: './src/firstPage.js',<br/>  dependOn: 'shared',<br/> },<br/> secondPage: {<br/>  import: './src/secondPage.js',<br/>  dependOn: 'shared',<br/> },<br/> thirdPage: {<br/>  import: './src/thirdPage.js',<br/>  dependOn: 'shared',<br/> },</span><span id="9a96" class="ll ku in nl b gy nw nq l nr ns"> shared: 'lodash',<br/>};</span></pre><p id="6912" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated"><a class="ae ks" href="http://Prefetching/Preloading modules" rel="noopener ugc nofollow" target="_blank">阅读更多关于预取/预加载模块的信息</a></p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="07d1" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">什么是懒装？</h1><p id="cffc" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">还记得我们的动态导入示例吗？我们基本上是在稍后阶段加载<code class="fe nt nu nv nl b">lodash</code>，但是这里要注意的一点是，加载<code class="fe nt nu nv nl b">lodash</code>不需要用户交互，这意味着每次页面刷新时，我们都会再次调用获取<code class="fe nt nu nv nl b">lodash</code>，而不管组件是否已经在页面上呈现(装载)，这并不是真正的最佳选择。</p><p id="7d0c" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">惰性加载将拆分带到了下一个层次，它只在组件(代码脚本)执行时获取所需的块。有一些利用webpack本身的本地方法可以做到这一点，但是因为这篇文章是关于react的，所以让我们来看看React的方法。</p><h1 id="f892" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><code class="fe nt nu nv nl b">React.Lazy() and React.suspens</code></h1><p id="023b" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">React有它的<code class="fe nt nu nv nl b">lazy()</code>功能，可以让我们动态加载任何组件，但是只有当它的调用程序/导入程序第一次挂载时。让我们看看下面的例子</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="8e9c" class="ll ku in nl b gy np nq l nr ns">const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;<br/>const Button = () =&gt; &lt;button&gt;Button&lt;/button&gt;</span><span id="e1aa" class="ll ku in nl b gy nw nq l nr ns">const Body = ({children}) =&gt; (<br/> &lt;div&gt;<br/>  ...<br/>  {children}<br/> &lt;/div&gt;<br/>);</span><span id="a98a" class="ll ku in nl b gy nw nq l nr ns">---------------------------------------------------</span><span id="e47b" class="ll ku in nl b gy nw nq l nr ns">import Header from './Header';<br/>import Body from './Header';<br/>import Button from './Button';</span><span id="3492" class="ll ku in nl b gy nw nq l nr ns">const App = () =&gt;(<br/> &lt;div&gt;<br/>  &lt;Header/&gt;<br/>  &lt;Body&gt;<br/>   &lt;/Button&gt;<br/>  &lt;/Body&gt;<br/> &lt;/div&gt;<br/>);</span></pre><p id="1de3" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">在这个例子中，我们将<code class="fe nt nu nv nl b">Header</code>和<code class="fe nt nu nv nl b">Body </code>组件导入到我们的应用程序中，<code class="fe nt nu nv nl b">Body</code>组件导入并使用另一个组件<code class="fe nt nu nv nl b">Button </code>。当我们捆绑我们的应用程序时，这两个组件将在一个捆绑包中，并将立即加载。</p><p id="7151" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">怎样才能懒加载<code class="fe nt nu nv nl b">Button</code>？换句话说，我们怎样才能让组件只在<code class="fe nt nu nv nl b">Body</code>第一次挂载/渲染后加载。</p><p id="59db" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">我们简单地使用<code class="fe nt nu nv nl b">React.Lazy()</code>——如果我们在客户端提供应用程序。<br/>*注意:您可能需要一些babel配置来转换导入语法</p><pre class="kd ke kf kg gt nk nl nm nn aw no bi"><span id="8a17" class="ll ku in nl b gy np nq l nr ns">import Header from './Header';<br/>import Body from './Header';<br/>// import Button from './Button';<br/>const Button = React.lazy(() =&gt; import('<!-- -->./Button<!-- -->'));</span><span id="da2a" class="ll ku in nl b gy nw nq l nr ns">const App = () =&gt;(<br/> &lt;div&gt;<br/>  &lt;Header/&gt;<br/>  &lt;Body&gt;<br/>   &lt;/Button&gt;<br/>  &lt;/Body&gt;<br/> &lt;/div&gt;<br/>);</span></pre><p id="c374" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">如果您正在加载您的组件服务器端呢？看看<a class="ae ks" href="https://github.com/gregberge/loadable-components" rel="noopener ugc nofollow" target="_blank">@可加载</a></p><h2 id="ec70" class="ll ku in bd kv lm ln dn kz lo lp dp ld lq lr ls lf lt lu lv lh lw lx ly lj lz bi translated">什么是React悬疑，用来做什么？</h2><p id="3369" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">要回答这个问题，让我们回头看看上面的惰性加载示例，在加载<code class="fe nt nu nv nl b">Button</code>组件时会向用户显示什么？基本没什么！对吗？嗯<code class="fe nt nu nv nl b">suspens</code>是为了确保用户看到一些东西，表明一些东西正在被加载。点击阅读更多关于如何使用<a class="ae ks" href="https://github.com/gregberge/loadable-components" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="11d8" class="pw-post-body-paragraph ma mb in mc b md nf jo mf mg ng jr mi lq nh mk ml lt ni mn mo lw nj mq mr ms ig bi translated">使用<code class="fe nt nu nv nl b">suspens</code>的一个很好的用例是基于路径分块/分割代码，或者构建一个组件，它的UI严重依赖于从API获取的数据。这样<code class="fe nt nu nv nl b">suspens</code>可以同时显示装载骨架。</p><h1 id="be69" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">总结和奖金</h1><p id="ffba" class="pw-post-body-paragraph ma mb in mc b md me jo mf mg mh jr mi lq mj mk ml lt mm mn mo lw mp mq mr ms ig bi translated">分裂或分块这个术语听起来可能有些挑衅，但它绝对是一个方便且非常强大的概念，使得web应用程序变得更加轻便和易于呈现。然而，我们需要确保我们均匀地分割块，并避免以任何方式中断用户体验。还有很多其他工具和技术可以用来实现公平的拆分工作，比如<a class="ae ks" href="https://www.split.io/" rel="noopener ugc nofollow" target="_blank"> Split.io </a>和<a class="ae ks" href="https://rollupjs.org/guide/en/#overview" rel="noopener ugc nofollow" target="_blank"> Rollup.js </a>。这些工具可能适用于更复杂的应用程序。</p></div></div>    
</body>
</html>