<html>
<head>
<title>Authorization using OPA (Open Policy Agent) with Gateway and Sidecar pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用具有网关和边车模式的OPA(开放策略代理)进行授权</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/authorization-using-opa-open-policy-agent-with-gateway-and-sidecar-pattern-3bc906dc3b33?source=collection_archive---------0-----------------------#2021-05-26">https://blog.devgenius.io/authorization-using-opa-open-policy-agent-with-gateway-and-sidecar-pattern-3bc906dc3b33?source=collection_archive---------0-----------------------#2021-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f8ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保护应用程序非常重要。很多时候，保护应用程序成为事后的想法，因为应用程序开发团队专注于实现业务特性。商业用户对新特性的加入感到兴奋。然而，他们不会总是注意到应用程序团队为保护应用程序所做的艰苦工作。</p><p id="4028" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当涉及到保护服务时，有两个重要的术语:(1)认证和(2)授权</p><p id="dd46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">认证</strong> </a>:一种断言用户身份的方式。当用户通过身份验证后，应用程序就会知道他们是谁。</p><p id="f88a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://en.wikipedia.org/wiki/Authorization" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">授权</strong> </a> <strong class="jm io"> : </strong>这个阶段发生在用户被认证之后。这是一种断言经过身份验证的用户拥有适当级别的访问权限/特权来操作服务的方式。</p><p id="be5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是关于<strong class="jm io">授权</strong>，以及我们如何使用<a class="ae ki" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> OPA(开放策略代理)</a>来保护<a class="ae ki" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Kubernetes </strong> </a>平台中的应用程序。这篇博客假设你已经知道OPA的好处，以及<em class="kj">策略作为代码</em>如何帮助改进服务的操作、审计、治理等。</p><h1 id="4045" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">紧密耦合授权</h1><p id="23d4" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">当开发人员构建并发布一个应用程序时，最简单的应用程序托管形式如下所示。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/649e9909a669c8061557a9a4ad712d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*rOhhJ-uUjn92Dr5Hzs-GQg.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">未经授权的应用程序</figcaption></figure><p id="1558" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该应用程序没有任何授权，任何经过身份验证的人都可以访问它。很明显，不够安全，保安都在嚷嚷！开发人员选择他们所选择的框架或编程语言中最好的，并在他们的代码中实现授权逻辑。因此，现在应用程序托管看起来如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/a08a57279e9c6af34d0ddad03fa12e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*Eo0w2diz05i47fxaXm-REA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">代码中嵌入了授权的应用程序</figcaption></figure><p id="23ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！这个应用程序是安全的，每个人，包括安全人员，都很高兴。商业最终在生产中得到他们的特征。</p><p id="4f20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法在处理整体应用程序时非常有用。然而，在基于微服务的环境中，事情变得困难和复杂。一些挑战包括:</p><ul class=""><li id="1d0a" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">业务应用程序代码与安全代码紧密耦合。更改业务功能可能会意外更改安全策略。</li><li id="45aa" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">授权逻辑在每个微服务中以不同的方式实现。随着开发人员移动团队，他们将不得不学习实现。</li><li id="8d0f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">根据需要，微服务将用不同的语言编写Scala、Go、Java、NodeJS、.Net，Python等。当来自安全的需求到来时，同样的事情必须在每个微服务中实现多次。</li><li id="eb39" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">随着关注点转移到运行时检测或预防，即更动态的测试，安全审计成为一项具有挑战性的任务，因此成本更高。</li><li id="ae7d" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">跨微服务的授权策略的关联非常困难</li><li id="101d" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">…以及更多</li></ul><p id="8dbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鉴于企业总是希望将特性推送到客户的生产环境中，紧密耦合的授权方法可能会减慢特性从开发人员的机器到生产环境的交付。</p><h1 id="465f" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">从应用程序代码中分离授权策略</h1><p id="e959" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">这就是OPA拯救团队的地方。授权策略从代码中提取出来，使用OPA策略语言编写，并存储在减压阀文件中。应用代码具有<em class="kj">零</em>授权逻辑，并且仅具有与业务特征相关的代码。所有授权都委托给OPA服务。应用程序托管看起来如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/efd8c4ec394a706ac65f66090dd0cd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acnCWmECmi2xfWRWf3PpyQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">特使和OPA保护的应用程序</figcaption></figure><p id="7c5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，两个集装箱作为辅助集装箱添加到箱中(即边车模式)。它们拦截所有到应用程序容器的流量，只允许授权的流量到达应用程序容器(即网关模式)。</p><p id="6e2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>是为云原生应用设计的开源边缘和服务代理，与OPA类似，也是CNCF支持的项目。</p><p id="0074" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Envoy将拦截所有到达应用程序容器的流量，并使用gRPC调用OPA容器。OPA容器内置了已编译的应用程序策略，它将使用传入负载中的信息(例如，JWT令牌、已验证的id、报头、主体等)来提供决策。如果决定是“允许”，那么代理将允许流量到达应用容器。如果决定是“拒绝”，那么特使将阻止该请求，并用403(未授权)响应代码进行响应。</p><p id="5ec7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法有很多好处:</p><ul class=""><li id="2af8" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">授权策略在应用程序代码之外，在它们自己的Git存储库中。</li><li id="6c8b" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">应用程序开发人员不能错误地更改策略代码，将服务置于风险之中。</li><li id="6bf6" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">不管应用代码是用什么语言编写的，微服务的所有策略都是用OPA的rego语言编写的。</li><li id="b84f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">安全审计和治理变得更加容易。安全评估越来越靠左，静态代码分析会发现漏洞。</li><li id="60d4" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">可以更放心地推出应用功能。默认情况下，缺少适当的策略将会拒绝对新功能的访问。因此，从开发者的机器到产品的更快的旅程。</li></ul><h1 id="eb62" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">将授权策略从应用基础架构中分离出来</h1><p id="4bf3" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">既然授权策略已经分离，我们都在享受好处，但是属于<em class="kj">应用</em>和<em class="kj">授权策略</em>的基础设施仍然存在耦合。这本身不是一个大问题。但这意味着，每当策略发生变化时，我们还必须部署整体基础架构组件，即应用程序单元。在容器化或Kubernetes环境中，容器的重启是正常的，应用程序必须(我重复一遍，必须)被设计为处理重启。如果应用程序对重启很敏感，那么我冒昧地说，这是考虑不周或者开发人员太懒了。</p><p id="c575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我们仍然可以改进托管模式，并进一步将策略基础架构与应用程序代码分离。在这种情况下，托管模式可能如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/d92f1c6670ba7814bb53a9c3e568ce8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTLSsJK_VXN_aTfQnrmKIw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">通过Envoy保护应用程序，通过远程策略保护OPA</figcaption></figure><p id="577f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里遵循相同的侧车和网关模式。特使将拦截所有流量，OPA将提供决定。根据决定，要么允许请求到达应用程序，要么用403响应代码响应客户端。</p><p id="977f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种模式中，策略不是嵌入在OPA sidecar中，而是远程发布，例如<a class="ae ki" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache httpd server </a>，AWS S3，GCP bucket，Nexus repository，Artifactory等。OPA服务将缓存捆绑包，并使用捆绑包的<a class="ae ki" href="https://en.wikipedia.org/wiki/HTTP_ETag" rel="noopener ugc nofollow" target="_blank"> ETag </a>定期检查更新的策略捆绑包。即使远程服务关闭，OPA服务也能继续正常运行。</p><p id="5943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法的一些优点:</p><ul class=""><li id="a086" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">应用基础设施不知道策略变化，即使非云原生或重启敏感的应用也使用OPA。</li><li id="4871" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">平台级、跨应用程序等策略的捆绑和角色扮演将变得更加容易</li></ul><h1 id="22ad" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">摘要</h1><p id="e738" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">上面的博客关注的是基于HTTP的流量，但是同样的模式也可以应用于gRPC和TCP流量。上述模式也可以在Kubernetes之外实现，但可能不像在Kubernetes中那样容易。</p><p id="20d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">https://gitlab.com/cloud.yantra.oss/opa-gateway-sidecar<a class="ae ki" href="https://gitlab.com/cloud.yantra.oss/opa-gateway-sidecar" rel="noopener ugc nofollow" target="_blank">的代码库展示了上述模式。</a></p><p id="d98b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在以后的博客中，我还将展示:</p><ul class=""><li id="8c15" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如何在Kubernetes集群中使用OPA保护<a class="ae ki" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>和<a class="ae ki" href="https://pulsar.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Pulsar </a>。</li><li id="779f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">如何根据OPA策略有选择地呈现客户端UI</li></ul></div></div>    
</body>
</html>