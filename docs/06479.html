<html>
<head>
<title>10 mistakes to avoid when using std::vector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用std::vector时要避免的10个错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/10-mistakes-to-avoid-when-using-std-vector-274043ca157c?source=collection_archive---------1-----------------------#2022-01-11">https://blog.devgenius.io/10-mistakes-to-avoid-when-using-std-vector-274043ca157c?source=collection_archive---------1-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8e6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++中使用的默认容器是std::vector，以防你没有充分的理由使用其他容器。尽管这可能是标准库中最常用的部分，但在使用它时，有几个陷阱不仅仅是初学者可能会陷入的。</p><h2 id="010a" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (1)创建一个有大小的向量，当你需要的是容量【正确性，效率】</strong></h2><p id="148f" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">以下代码有什么问题？</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="d28a" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;std::string&gt; strs(10);<br/>for(size_t i=0; i&lt;strs.size(); ++i) {<br/>    strs[i] = std::to_string(i);<br/>}</span></pre><p id="f575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是我们实际上创建了10个空字符串，只是为了在循环中给它们分配新的字符串。</p><p id="e2d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现<a class="ae lt" href="http://coliru.stacked-crooked.com/a/8e97887b9db10141" rel="noopener ugc nofollow" target="_blank">与</a>相同的正确方法是:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b7b5" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;std::string&gt; strs;<br/>strs.reserve(10);<br/>for(size_t i=0; i&lt;10; ++i) {<br/>    strs.push_back(std::to_string(i));<br/>}</span></pre><p id="c88d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设置大小而不是容量也可能导致实际的错误，如果我们创建一个比我们需要的更大的向量，并使用向量大小作为元素计数的指示(这就是大小的含义)。然而，我们在vector中管理的元素的实际“真实”数量更少。</p><h2 id="36af" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">(2) <strong class="ak">未设置容量，需要时更好【效率】</strong></h2><p id="4de3" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">以下代码有什么问题？</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="ba7f" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;std::string&gt; strs;<br/>for(size_t i=0; i&lt;1000; ++i) {<br/>    strs.push_back(std::to_string(i));<br/>}</span></pre><p id="8cbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，向量可能需要在循环中多次调整大小。如果你知道，或者甚至可以有一个正确的猜测，向量的大小——提前使用它！</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/95d8dfb7fc778c975ce6c1d65ac83346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ckhA3twzH23PXBen"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Jan Antonin Kolar 在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1f0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们想从文件中读取行。我们可能有一个有根据的猜测，行数是文件的大小除以40。我们可以添加一个<code class="fe mg mh mi ll b">Max_Line_Count</code>常数边界作为安全措施。然后，在将行读入向量之前，我们可以提前预留容量:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="2556" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;std::string&gt; v;<br/>v.reserve(std::min(file_size / 40, Max_Line_Count));<br/>// ... read lines into the vector using push_back</span></pre><p id="2643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果向量是长期存在的，您可能希望使用以下方法将向量缩小到所需的容量:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="fbac" class="ki kj in ll b gy lp lq l lr ls">v.shrink_to_fit(); // shrink the vector to the required capacity</span></pre><p id="98fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，如果向量不是长期存在的，并且您没有预见到内存问题，就让它保持原样。对<code class="fe mg mh mi ll b">shrink_to_fit</code>的调用代价很高，因为它可能需要重新分配和移动/复制所有项目。</p><h2 id="041f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (3)手动将向量中的值初始化为零【冗余代码，效率】</strong></h2><p id="25ca" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">以下代码有什么问题？</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="e25f" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;int&gt; v(size);<br/>for(size_t i=0; i&lt;size; ++i) {<br/>    v[i] = 0;<br/>}</span></pre><p id="49a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的答案是可以通过调用<code class="fe mg mh mi ll b">std::fill</code>来更优雅、更有效地完成，那么这不是正确的答案。答案是这个循环是多余的，因为向量元素在默认情况下是零初始化的。不需要循环。</p><p id="0415" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">附带说明:从C++98开始，以上是正确的，但是基于不同的向量构造器，直到C++11，它是基于cppreference 中的<a class="ae lt" href="https://en.cppreference.com/w/cpp/container/vector/vector" rel="noopener ugc nofollow" target="_blank">向量的构造器#3:</a></p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="3c26" class="ki kj in ll b gy lp lq l lr ls">explicit vector(size_type count, const T&amp; value = T(), const Allocator&amp; alloc = Allocator());</span></pre><p id="f270" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从C++11开始，它基于cppreference 中的<a class="ae lt" href="https://en.cppreference.com/w/cpp/container/vector/vector" rel="noopener ugc nofollow" target="_blank"> vector的构造函数#4(例如，对于C++20):</a></p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="8c21" class="ki kj in ll b gy lp lq l lr ls">constexpr explicit vector(size_type count, const Allocator&amp; alloc = Allocator());</span></pre><h2 id="8b0d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (4)假设用[ ]访问坏索引会抛出【潜在bug】</strong></h2><p id="0123" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">下面的<a class="ae lt" href="http://coliru.stacked-crooked.com/a/2b33caf67d6a3c8a" rel="noopener ugc nofollow" target="_blank">代码</a>编译运行成功:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="1417" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;int&gt; v(1);<br/>assert (v[0] + v[1] == 0);</span></pre><p id="de91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，它可能会崩溃，但在许多情况下，它不会，因为未定义的行为并不一定会崩溃。不要假设您会在测试期间捕获这些潜在的错误，它们可能会逃脱到生产中。静态代码分析以及运行时清理程序可能有助于发现这样的错误。</p><p id="738a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们用<code class="fe mg mh mi ll b">-fsanitize=address</code>、<code class="fe mg mh mi ll b">g++</code>或<code class="fe mg mh mi ll b">clang</code>、<a class="ae lt" href="http://coliru.stacked-crooked.com/a/6893fcf1ddca9a6d" rel="noopener ugc nofollow" target="_blank">运行上面的例子，我们将得到</a>:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="acc1" class="ki kj in ll b gy lp lq l lr ls">==4155==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x000000400e5b bp 0x7fffa419bfc0 sp 0x7fffa419bfb8<br/>READ of size 4 at 0x602000000014 thread T0<br/>#0 0x400e5a in main (/tmp/1640625996.1503701/a.out+0x400e5a)<br/>…</span></pre><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mj"><img src="../Images/77e8eda1c97a4e5f50c8d38e3d96e152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ms4HW5op9oVYAcFc"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">照片由<a class="ae lt" href="https://unsplash.com/@michaeljinphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">晋振伟</a>在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d905" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种选择是使用<code class="fe mg mh mi ll b">vector::at</code>而不是<code class="fe mg mh mi ll b">[]</code>，后者有边界检查。然而，那些追求每一点性能的人可能会取消这个选项，进行额外的内部检查。无论如何，底线是vector的[]与C-array的[]相比并不安全。</p><h2 id="e7f1" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (5)在同一位置擦除和插入，而不是赋值【效率】</strong></h2><p id="586a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我们编写的代码有时倾向于模仿我们试图实现的故事的语义。假设这个故事是，一个人需要从一个向量中移除，以便在相同的位置添加另一个向量。可以实现以下内容:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="a226" class="ki kj in ll b gy lp lq l lr ls">template&lt;typename C, typename T1 = C::value_type,<br/>                     typename T2 = C::value_type&gt;<br/>void replace(C&amp; v, T1&amp;&amp; remove, T2&amp;&amp; replaceWith) {<br/>    auto itr =<br/>        std::find(v.begin(), v.end(), std::forward&lt;T1&gt;(remove));<br/>    if(itr != v.end()) {<br/>        itr = v.erase(itr);<br/>        v.insert(itr, std::forward&lt;T2&gt;(replaceWith));<br/>    }<br/>}</span></pre><p id="827d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果在vector中管理的类型没有阻塞它的赋值，我们可以用下面的方法得到<a class="ae lt" href="http://coliru.stacked-crooked.com/a/9f4b0751ef079729" rel="noopener ugc nofollow" target="_blank">同样的结果</a>:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="c4ff" class="ki kj in ll b gy lp lq l lr ls">template&lt;typename C, typename T1 = C::value_type,<br/>                     typename T2 = C::value_type&gt;<br/>void replace(C&amp; v, T1&amp;&amp; remove, T2&amp;&amp; replaceWith) {<br/>    auto itr =<br/>        std::find(v.begin(), v.end(), std::forward&lt;T1&gt;(remove));<br/>    if(itr != v.end()) {<br/>        *itr = std::forward&lt;T2&gt;(replaceWith);<br/>    }<br/>}</span></pre><p id="4ab3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">诚然，这两个功能是不一样的，但对于几乎任何实际目的来说，它们会有相同的结果，第二个更有效。</p><h2 id="ad94" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (6)在基于范围的过程中改变向量【错误】</strong></h2><p id="acb7" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">你们中的许多人会立即发现下面的代码是不好的，当我们在基于范围的for循环中改变向量时，会遇到未定义的行为:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="d6ba" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;int&gt; v = {1, 2, 3};<br/>for(auto i : v) {<br/>    if(i % 2) v.push_back(i);<br/>}</span></pre><p id="048e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要问题是调用<code class="fe mg mh mi ll b">push_back</code>可能需要增加向量的容量，因此向量可能需要重新分配，而我们仍然在旧的分配上迭代。</p><p id="5639" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，即使发生了重新分配，导致从释放的内存中读取，这当然是一种未定义的行为，<a class="ae lt" href="http://coliru.stacked-crooked.com/a/bcd1d84c2e31579f" rel="noopener ugc nofollow" target="_blank">它仍然可以运行而不会崩溃</a>。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mk"><img src="../Images/182ad4d05244df678163826a32778a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zpYsiCBdi3IkwT0y"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">由<a class="ae lt" href="https://unsplash.com/@mocno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mocno Fotografia </a>在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="79ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们用<code class="fe mg mh mi ll b">-fsanitize=address</code>，在<code class="fe mg mh mi ll b">g++</code>或<code class="fe mg mh mi ll b">clang</code>，<a class="ae lt" href="http://coliru.stacked-crooked.com/a/83e03c639f48bf60" rel="noopener ugc nofollow" target="_blank">上运行上面的例子，我们将得到</a>:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="153a" class="ki kj in ll b gy lp lq l lr ls">==3078==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000014 at pc 0x000000401e80 bp 0x7ffcc0c63040 sp 0x7ffcc0c63038<br/>READ of size 4 at 0x602000000014 thread T0<br/>#0 0x401e7f in main (/tmp/1640634028.6327093/a.out+0x401e7f)<br/>…</span></pre><h2 id="c0f2" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (7)使用失效的迭代器或指针【Bug】</strong></h2><p id="1ae4" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">前面的例子已经展示了在基于范围的for中使用无效迭代器，同时改变了向量。但这并不是唯一的情况。</p><p id="49fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在添加或删除项目时，持有向量的迭代器或指向向量数据内部某个位置的指针并不是罕见的错误。如果在指向的位置之前删除了一个项目，或者如果向量的大小超过了它的容量，那么指向向量中一个位置的迭代器、引用和指针将会失效。</p><p id="9894" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，持有指数并不总是合适的解决方案。如果删除或添加该索引之前的项目<em class="ml">,该索引也可能无效。当向量改变时，如果你需要在外部保持向量中的位置，这可能是你需要移动到列表的情况之一。</em></p><h2 id="19bd" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (8)不释放分配[内存泄漏] </strong></h2><p id="6b6a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">诚然，<code class="fe mg mh mi ll b">std::vector</code>管理它自己的分配，但是如果你的vector持有指向已分配内存的指针，这个内存不会被vector释放，释放它是你的责任。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="6fc6" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;Shape*&gt; vec;<br/>vec.push_back(new Rectangle());<br/>vec.push_back(new Circle());<br/>// it’s the programmer’s responsibility to release<br/>// the Rectangle and Circle allocated above</span></pre><p id="4646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<code class="fe mg mh mi ll b">std::unique_ptr</code>可以派上用场的地方，它帮助您管理分配，并在vector失效时自动释放它们:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="1a07" class="ki kj in ll b gy lp lq l lr ls">std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; vec;<br/>vec.push_back(std::make_unique&lt;Rectangle&gt;());<br/>vec.push_back(std::make_unique&lt;Circle&gt;());<br/>// the Rectangle and Circle allocated above<br/>// would be automatically released by unique_ptr</span></pre><h2 id="07bd" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (9)冗余清洗循环[ </strong>冗余代码，<strong class="ak">效率】</strong></h2><p id="0777" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">有些人不喜欢在离开后留下一片狼藉，他们觉得在离开前必须做一些清理工作。</p><p id="2112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在编码中，这可能会变得低效，如下例所示:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="16a3" class="ki kj in ll b gy lp lq l lr ls">class ShapeStore {<br/>    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;<br/>public:<br/>    ~ShapeStore() {<br/>        shapes.clear(); // &lt;= redundant and costly<br/>    }<br/>};</span></pre><p id="26f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">载体无论如何都会死亡并被释放。如果你想知道上面的析构函数的代价是什么，因为我们只是显式地进行清理，而不是在向量到达它自己的析构函数时进行同样的清理，那么在这种情况下代价很高，因为你只是通过实现一个你实际上不需要的析构函数，放弃了你的类及其成员的默认移动操作。我们将用最后一个项目来讨论向量及其元素的移动操作。</p><h2 id="79c6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak"> (10)冗余复印——而不是移动【效率】</strong></h2><p id="7ab4" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">如果可以移动，就不要复制。对于向量本身和它的元素来说都是如此。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mm"><img src="../Images/5210371edc64f91941945dce2605a84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z8W-Ka6S3tqLalsP"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Anton Maksimov 5642.su 在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0d0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移动矢量比复制矢量效率高得多。和移动元素也可能更有效，这取决于向量中保存的实际数据。</p><p id="3e9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">导致代码避免移动向量的原因:</p><ul class=""><li id="f6c2" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">在保存向量的类中没有移动操作(移动构造函数和移动赋值)。例如，如果您实现了一个析构函数或声明了一个虚析构函数(即使您是用=default来实现的),并因此退出了零规则，而没有恢复默认的移动操作或实现它们，就可能会发生这种情况。</li><li id="0b69" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">传递一个没有额外用途的本地向量，而不调用std::move(嗯，这与传递任何可以移动的本地资源是一样的，忘记调用std::move)，如下例所示:</li></ul><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="e28a" class="ki kj in ll b gy lp lq l lr ls">void foo() {<br/>    auto widgets = widgetsFromDb(); // a container, e.g. a vector<br/>    for(auto&amp; widget : widgets) {<br/>        widget-&gt;doYourThing();<br/>    }<br/>    // doAdditionalStuffWithWidgets(widgets); // oops, copying<br/>    <br/>    // this is the proper way to pass our container on,<br/>    // as we don't need it anymore:<br/>    doAdditionalStuffWithWidgets(std::move(widgets));<br/>}</span></pre><p id="3763" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">导致代码避免移动向量中的元素的原因:</p><ul class=""><li id="d201" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">忘记在元素类move构造函数上添加<code class="fe mg mh mi ll b">noexcept</code>，这会导致vector的resize复制元素而不是移动它们。</li><li id="51a3" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">向vector传递一个没有额外用途的局部变量，而不调用std::move(嗯，这与传递任何可以移动的局部资源是一样的，只是忘记了调用std::move)，如下例所示:</li></ul><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b7fc" class="ki kj in ll b gy lp lq l lr ls">void foo() {<br/>    auto widget = getWidgetFromDb(); // a single widget<br/>    widget-&gt;doYourThing();<br/>    // vec.push_back(widget); // oops, copying<br/>    <br/>    // this is the proper way to pass the widget,<br/>    // as we don't need it anymore:<br/>    vec.push_back(std::move(widget));<br/>}</span></pre><p id="27bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，可以补充的是，如果元素可以被放置到向量中，使用<code class="fe mg mh mi ll b">emplace_back</code>应该比<code class="fe mg mh mi ll b">push_back</code>更好。</p><ul class=""><li id="a8b4" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">通过复制而不是移出，将向量中的元素弹出到变量中:</li></ul><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="5f74" class="ki kj in ll b gy lp lq l lr ls">// wrong way - inefficient:<br/>auto val = vec.back(); // copying<br/>vec.pop_back();</span><span id="a033" class="ki kj in ll b gy nb lq l lr ls">// wrong way - undefined behavior:<br/>auto&amp; val = vec.back(); // reference is OK<br/>vec.pop_back(); // but now the reference is invalidated</span><span id="fe6a" class="ki kj in ll b gy nb lq l lr ls">// right way, efficient and correct:<br/>auto val = std::move(vec.back()); // allow call of move if available<br/>vec.pop_back();</span></pre></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="5673" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">最后</h2><p id="e6d9" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">大多数C++程序员都非常熟悉<code class="fe mg mh mi ll b">std::vector</code>以及本文中提供的大部分技巧。然而，您仍然可以在产品代码中找到上述列表中的错误。如果没有适当的静态代码分析器或仔细的代码审查，这些缺陷可能很难发现。因此，睁大你的眼睛，对出现的问题进行代码审查，但是记住，不出现这些问题的最好方法是从一开始就避免它们。</p></div></div>    
</body>
</html>