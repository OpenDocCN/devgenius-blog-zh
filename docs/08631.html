<html>
<head>
<title>Infinite Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限数据结构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/infinite-data-structures-9c193789dae6?source=collection_archive---------8-----------------------#2022-06-29">https://blog.devgenius.io/infinite-data-structures-9c193789dae6?source=collection_archive---------8-----------------------#2022-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e6e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 scheme 和 lazy evaluation 形成无限列表</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f63b6bab8d2e8d11248a0d20ce9ba258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5KlQtw0CRrWRqMtwvyPXA.jpeg"/></div></div></figure><h1 id="2365" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">工具</h1><p id="20e1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我将在本指南中使用球拍编程语言。它是 scheme 的一种扩展方言，但是大部分代码应该可以直接转移到 R5RS-R7RS scheme。我相信概念可以在 scheme 之外有用和实现，它只是我选择使用的工具。Haskell 内置了无限列表，其他 Lisps 和函数式语言如 Javascript 当然可以用来实现无限列表。甚至<a class="ae lx" href="https://stackoverflow.com/questions/13910259/list-with-infinite-elments" rel="noopener ugc nofollow" target="_blank"> Python </a>也可以使用相似或完全不同的方法制作无限列表。</p><h1 id="8af2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">惰性评估和流</h1><p id="ed1d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">显然，计算机没有无限的内存，所以整个无限的数据结构不能简单地存储在内存中。有些元素可以在内存中进行赋值，但有些必须保留，直到我们需要它们。将表达式求值延迟到需要该值时进行，这称为惰性求值。</p><h2 id="2c5c" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">延迟评估</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="60ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们想延迟一个表达式的求值，我们可以把它包装在一个 lambda 中。那么在我们对 lambda 求值并强制它的主体求值之前，它不会被求值。这可以通过定义一个冻结宏来实现，冻结宏只是将一个表达式包装在一个 lambda 中以延迟它的扩展。然后，解冻接受一个包装在 lambda 中的表达式(冻结表达式)并强制求值。</p><p id="ba25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:这些函数通常被称为延迟和强制，但我在这里选择了不同的名称，以便不与内置函数冲突，并提供一个可视的图像。</p><h2 id="da42" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">流</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1fe3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">流是一个缺点列表，其中尾部的评估被延迟/冻结，直到它需要被评估——一个懒惰列表。我们将永远有可用的头部，而对尾部的评估是冻结的。当我们要尾巴的时候，它会解冻，给我们一个价值。这很可能是另一个流，头部有一个值，尾部有一个冻结的表达式。这允许我们创建无限列表。上面给出了流的各种列表函数的定义，它们的行为类似于同名的列表函数，但是根据需要冻结和解冻尾部的求值。</p><h1 id="d679" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">无限列表！</h1><p id="cb37" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">最简单的无限流是全 1 流。这被定义为</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9cce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo mp b">ones</code>实际上是一个无限列表。我发现有两种方法可以对正在发生的事情进行推理。</p><h2 id="825e" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">声明式方法</h2><p id="5462" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这种方法可以说是最漂亮的，但需要一些信任，而且开始时有点令人费解。透过陈述性的镜头来看问题需要看我们告诉计算机做什么，而不一定是它如何做。</p><p id="9caa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设无限个一的流存在。姑且称之为<code class="fe mm mn mo mp b">ones</code>。根据定义，这个流的头必须是 1。所以我们很容易得到<code class="fe mm mn mo mp b">(define ones (stream-cons 1 _))</code>，但是现在我们需要弄清楚它的尾巴是什么。如果流有无限个 1，那么它的尾部一定是一个无限个 1 的流。幸运的是，我们已经有了一连串的:<code class="fe mm mn mo mp b">ones</code>！所以我们得到了<code class="fe mm mn mo mp b">(define ones (stream-cons 1 ones))</code></p><h2 id="4aaa" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">命令式方法</h2><p id="0db2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">透过命令式镜头看问题需要看计算机实际上是如何评估表达式的。</p><p id="2919" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看看<code class="fe mm mn mo mp b">ones</code> : <code class="fe mm mn mo mp b">(define ones (stream-cons 1 ones))</code>的定义。这个定义是递归的——它引用自身。如果我们用它的定义替换表达式中的<code class="fe mm mn mo mp b">ones</code>会怎么样？因为我们只交换了一个变量和它的定义，这将产生一个等价的表达式。</p><p id="f26d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo mp b">(equal? ones (stream-cons 1 ones))</code> —按定义<br/> <code class="fe mm mn mo mp b">(equal? ones (stream-cons 1 <em class="mq">(stream-cons 1 ones)</em>))</code> —按个的定义<br/> <code class="fe mm mn mo mp b">(equal? ones (stream-cons 1 (stream-cons 1 <em class="mq">(stream-cons 1 ones)</em>)))</code> —按个的定义</p><p id="d3d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种扩展可以一直持续到无穷大，幸运的是这个列表很懒，所以只有当我们请求它的时候，它才会一直持续到无穷大。但是通过研究它，很明显这将产生一个无限的列表。</p><h1 id="642b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">流添加</h1><p id="ff25" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们定义一个函数 stream-add，它向下扫描两个流，将相应的元素加在一起，然后返回新的流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2a28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在一串二进制数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a41e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">声明式推理，将两个结果流全部加在一起。强制性推理，stream-add 将每个流的头部加在一起(1 + 1 = 2)，然后添加尾部。尾部也是 1，所以一直向下就是 1 + 1 = 2。</p><h1 id="43c4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">日益增加的复杂性</h1><p id="1344" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">到目前为止，我们的无限列表虽然是无限的，但并不十分有趣。让我们试着做一个自然数流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h2 id="12d5" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">陈述推理</h2><p id="1503" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">假设自然数流存在。姑且称之为<code class="fe mm mn mo mp b">nats</code>。根据定义，这个流的头必须是 1。所以我们很容易得到<code class="fe mm mn mo mp b">(define nats (stream-cons 1 _))</code>，但是现在我们需要弄清楚它的尾巴是什么。列表的尾部现在必须是<code class="fe mm mn mo mp b">'(2 3 4 5 6 7 8 …)</code>。这个列表是自然数和 1 的流的加法。幸运的是我们已经拥有了这两样东西。因此我们以<code class="fe mm mn mo mp b">(define nats (stream-cons 1 (stream-add ones nats)))</code>结束</p><h2 id="4277" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">命令推理</h2><p id="8fb9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们看看<code class="fe mm mn mo mp b">nats</code> : <code class="fe mm mn mo mp b">(define nats (stream-cons 1 (stream-add ones nats)))</code>的定义。这个定义是递归的——它引用自身。如果我们用它的定义替换表达式中的<code class="fe mm mn mo mp b">(stream-add ones nats)))</code>呢。这将产生一个等效的表达式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c6e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这导致了自然数的形成。同样，因为这是一条尾巴不会像这样延伸到无穷远处的河流，所以它只会在我们要求的时候进行评估。这样，列表实际上是无限的，但是我们不需要无限的内存来存储它。</p><h1 id="fb1e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Fibonacci 数</h1><p id="2764" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这就是我认为这一概念进入下一个层次的地方。斐波那契数列</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b857" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看为什么会这样。再次，假设斐波那契数列存在。姑且称之为<code class="fe mm mn mo mp b">fibs</code>。<br/>谎言是无限的列表<code class="fe mm mn mo mp b">'(0 1 1 2 3 5 8 13 21 ...)</code>。我们再来看看<code class="fe mm mn mo mp b">(stream-cdr fibs)</code> : <br/> <code class="fe mm mn mo mp b">'(1 1 2 3 5 8 13 21 34 ...)</code>。当我们将这两个流加在一起时，我们得到<code class="fe mm mn mo mp b">'(1 2 3 5 8 13 21 34 55)</code>。所以<code class="fe mm mn mo mp b">(equal? (stream-add fibs (stream-cdr fibs)) (stream-cdr (stream-cdr fibs)))</code>。</p><p id="cd6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo mp b">fibs</code>的前两个元素根据定义是 0 和 1，因此称为<code class="fe mm mn mo mp b">(define fibs (stream-cons 0 (stream-cons 1 _)))</code>。现在我们只需要弄清楚这条小溪的尾巴是什么；换言之什么<code class="fe mm mn mo mp b">(stream-cdr (stream-cdr fibs))</code>。不过，我们已经有了定义！让我们把之前发现的关于<code class="fe mm mn mo mp b">fibs</code>的属性塞住。我们得到<code class="fe mm mn mo mp b">(define fibs (stream-cons 0 (stream-cons 1 (stream-add fibs (stream-cdr fibs)))))</code>。在我看来，这个流非常漂亮，它让我们看到了函数式编程和惰性评估的潜在力量和优雅。</p><p id="32d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这个陈述性推理仍然令人困惑(起初对我来说是这样)，你也可以用命令式推理向自己证明这是正确的。我将把这个留给读者做练习。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="57db" class="ku kv in bd kw kx my kz la lb mz ld le lf na lh li lj nb ll lm ln nc lp lq lr bi translated">继续的</h1><p id="33a3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这个故事是第一部分。第二部分到了<a class="ae lx" href="https://eric-breyer.medium.com/infinite-data-structures-part-2-6662f143e3b9" rel="noopener">这里</a>。它进一步进入了更多的无限列表和质数无限列表的压轴戏。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="c7d3" class="ku kv in bd kw kx my kz la lb mz ld le lf na lh li lj nb ll lm ln nc lp lq lr bi translated">关于作者</h1><p id="a7e5" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae lx" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>以及<a class="ae lx" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae lx" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>