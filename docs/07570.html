<html>
<head>
<title>Async Communication 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步通信 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-communication-101-b04d5c95333a?source=collection_archive---------6-----------------------#2022-04-06">https://blog.devgenius.io/async-communication-101-b04d5c95333a?source=collection_archive---------6-----------------------#2022-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d97f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论<strong class="jm io">云</strong>概念的系列文章的一部分，面向的是入门知识有限的读者。这篇文章属于<em class="ki">中级</em>系列，因为它涉及到构建异步通信和相关的基本概念。</p><p id="15f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云系列中的一些早期博客如下:</p><p id="b0fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/load-balancing-101-8251350c033f"> <strong class="jm io">负载均衡 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-101-634ef4f8ed1b"><strong class="jm io">缓存 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078"><strong class="jm io">数据库 101 </strong> </a></p><h1 id="28d9" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是异步通信？</h1><p id="d90c" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">异步是业务应用程序的两个不同组件之间的通信模式，不需要实时交互。原则上，发送方根据客户动作在队列/主题中丢弃消息，接收方根据设置的<a class="ae kj" href="https://en.wikipedia.org/wiki/Time_to_live" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki"> TTL(生存时间)</em> </strong> </a>和交付语义读取相同的内容，以继续业务流。</p><p id="47ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与使用<a class="ae kj" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki"> REST API 的</em> </strong> </a>构建的传统同步模式不同，在传统同步模式中，端到端 API 响应是分布式架构中所有组件可用性的一个因素，异步系统可以独立扩展，以满足高端<strong class="jm io"> <em class="ki">(每秒事务数)</em> </strong>需求。然而，同时它的主要缺点是消息传递的可靠性和再次重放数据的需要。因此，现代体系结构倾向于遵循一种混合模型，使用异步和同步模式来满足可伸缩体系结构的端到端非功能性需求。</p><h1 id="7d57" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">异步与同步通信流</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/d3de17ac9eddb94c507f5cff453a715b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_NicaOBNacr48t9MBjhnQ.png"/></div></div></figure><h2 id="0c72" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">顺序流程</h2><ol class=""><li id="47e2" class="ml mm in jm b jn li jr lj jv mn jz mo kd mp kh mq mr ms mt bi translated">客户端根据业务流程调用<em class="ki">微服务 1 </em>作为<strong class="jm io"> HTTPS GET/POST </strong>请求。</li><li id="64f2" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><em class="ki">微服务 1 </em>内部调用<em class="ki">微服务 2 </em>来获取关于业务功能的信息，作为<strong class="jm io"> HTTPS GET/POST </strong>请求。</li><li id="8165" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><em class="ki">微服务 2 </em>内部调用<em class="ki">微服务 3 </em>来获取关于业务功能的信息，作为<strong class="jm io"> HTTPS GET/POST </strong>请求。</li><li id="cbf2" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">一旦<em class="ki">微服务 3 </em>发回响应，同样由<em class="ki">微服务 2 </em>和<em class="ki">微服务 1 </em>依次链接回客户端。</li></ol><p id="64b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总往返时间是第 1 步、第 2 步、第 3 步、第 4 步针对端到端 API 延迟所用的时间。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mz"><img src="../Images/185686463990d97f7a5b949d9a377970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J8gVk8l6wGnUoUcvDJzHg.jpeg"/></div></div></figure><h2 id="91cf" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">顺序流程</h2><ol class=""><li id="fc49" class="ml mm in jm b jn li jr lj jv mn jz mo kd mp kh mq mr ms mt bi translated">客户端根据业务流程调用<em class="ki">微服务 1 </em>作为<strong class="jm io"> HTTPS GET/POST </strong>请求。</li><li id="937f" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><em class="ki">微服务 1 </em>在消息总线中发布一个<em class="ki">事件 1 </em>来交付客户载荷。</li><li id="d909" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><em class="ki">微服务 2 </em>读取<strong class="jm io"> </strong> <em class="ki">事件 1 </em> <strong class="jm io"> </strong>并在消息总线中发布一个<em class="ki">事件 2 </em> <strong class="jm io"> </strong>来交付修改后的净荷。</li><li id="aa75" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><em class="ki">微服务 3 </em>读取<strong class="jm io"> </strong> <em class="ki">事件 2 </em> <strong class="jm io"> </strong>并在消息总线中发布一个<em class="ki">事件 3 </em> <strong class="jm io"> </strong>以将确认传递回<em class="ki">微服务 1 </em>。</li></ol><p id="b138" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的往返时间是第 1 步和第 2 步所用的时间，以及客户机得到确认的时间。</p><h1 id="d011" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">异步通信术语表</h1><h2 id="9b26" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">制片人/出版商</h2><p id="3ac9" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">生成消息并在消息传递基础结构中排队的客户端。</p><h2 id="1306" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">消费者/订户</h2><p id="e840" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">接收消息并在消息传递基础结构中将其出队的客户端。</p><h2 id="bb7e" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">主题</h2><p id="054f" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">主题是消息基础设施中的逻辑分类，用于组织给定业务需求的消息。一个或多个订阅者可以阅读来自单个主题的消息。</p><h2 id="b456" class="lz kl in bd km ma mb dn kq mc md dp ku jv me mf ky jz mg mh lc kd mi mj lg mk bi translated">长队</h2><p id="1d11" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">与主题类似，队列充当发布者/订阅者的消息存储库，主要区别在于它主要服务于一个订阅者，而不是主题广播用例中的多个订阅者。</p><h1 id="9eec" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">例子</h1><p id="20f3" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">以便在本地系统上使用 docker 运行轻量级消息代理系统的示例 Docker 应用程序。</p><div class="na nb gp gr nc nd"><a href="https://github.com/amit894/docker-images/tree/main/images/kafka" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">docker-images/images/Kafka at main Amit 894/docker-images</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">回购是为了学习码头工人。通过在 GitHub 上创建帐户，为 amit894/docker-images 开发做出贡献。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr lx nd"/></div></div></a></div><h1 id="14aa" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">摘要</h1><p id="e508" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">异步通信已经成为公共云或私有云上分布式和可扩展部署的重要组成部分。根据定制应用的需要，基于队列或主题的消息平台都可以用在端到端功能架构中。其中比较流行的有以下几个——<a class="ae kj" href="https://aws.amazon.com/messaging/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">AWS Messaging</strong></a>、<a class="ae kj" href="https://azure.microsoft.com/en-us/solutions/messaging-services/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Azure Messaging </strong> </a>和<a class="ae kj" href="https://spring.io/guides/gs/messaging-gcp-pubsub/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> GCP Messaging。</strong>T11】</a></p><p id="148a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系 https://about.me/amit_raj</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">的任何一个链接。</em></a></p></div></div>    
</body>
</html>