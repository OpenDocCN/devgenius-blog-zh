<html>
<head>
<title>Best of Modern JavaScript — Strings and Symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——字符串和符号</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-strings-and-symbols-6b7e343d0fde?source=collection_archive---------10-----------------------#2020-09-15">https://blog.devgenius.io/best-of-modern-javascript-strings-and-symbols-6b7e343d0fde?source=collection_archive---------10-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31146da9362e0d9fd2ce2e42ef6ce79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kWtIIxu3-mady1Wd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ocollet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olivier Collet </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 的核心特性。</p><h1 id="1b85" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">新的字符串方法</h1><p id="4f93" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">新的字符串方法包括代码点和模板文字方法。</p><p id="a918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个<code class="fe me mf mg mh b">String.raw</code>方法返回一个字符串的原始版本。</p><p id="47c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9599" class="mq lc iq mh b gy mr ms l mt mu">String.raw`\n`</span></pre><p id="a26b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回字符串的原始版本。</p><p id="5f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">斜线没有被解释。</p><p id="ffca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于模板文字的函数称为模板标签。</p><p id="f088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">String.fromCodepoint</code>方法从给定的代码点返回一个字符串。</p><p id="6ab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3696" class="mq lc iq mh b gy mr ms l mt mu">String.fromCodePoint(9731, 9733, 9842)</span></pre><p id="df24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2c43" class="mq lc iq mh b gy mr ms l mt mu">"☃★♲"</span></pre><p id="fa8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b"> String.prototype.normalize</code>方法让我们将具有相同值的代码点组合组合在一起。</p><p id="f6a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a0c" class="mq lc iq mh b gy mr ms l mt mu">'\u00F1'.normalize('NFC')</span></pre><p id="fd52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f2c" class="mq lc iq mh b gy mr ms l mt mu">"ñ"</span></pre><p id="ab21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">'NFC'</code>是规范化字符串的格式，也是默认的格式。</p><p id="6484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着规范分解之后是规范合成。</p><h1 id="adb3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">标志</h1><p id="3284" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号是 ES6 的一个新的基本类型。</p><p id="641e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Symbol</code>工厂函数来创建它。</p><p id="01d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b673" class="mq lc iq mh b gy mr ms l mt mu">const<!-- --> foo <!-- -->=<!-- --> <!-- -->Symbol('<!-- -->foo<!-- -->');</span></pre><p id="b0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次我们给工厂打电话，都会产生一个新的符号。</p><p id="a902" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以没有两个符号是相同的。</p><p id="52b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些作为唯一属性键很有用。</p><p id="94c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe me mf mg mh b">Symbol.iterator</code>符号是用于创建可迭代对象的特殊符号。</p><p id="4539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2957" class="mq lc iq mh b gy mr ms l mt mu">const iterableObject = {<br/>  [Symbol.iterator]() {<br/>    //···<br/>  }<br/>}<br/>for (const x of iterableObject) {<br/>  console.log(x);<br/>}</span></pre><p id="09aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建对象并用 for-of 循环遍历它。</p><p id="a062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用它们作为常数来表示概念。</p><p id="2ef3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cbcf" class="mq lc iq mh b gy mr ms l mt mu">const COLOR_RED = Symbol('red');<br/>const COLOR_GREEN = Symbol('green');<br/>const COLOR_BLUE = Symbol('blue');</span><span id="b97e" class="mq lc iq mh b gy mv ms l mt mu">function getValue(color) {<br/>  switch (color) {<br/>    case COLOR_RED:<br/>      return 1;<br/>    case COLOR_BLUE:<br/>      return 2;<br/>    case COLOR_GREEN:<br/>      return 2;<br/>    default:<br/>      throw new Error('Unknown color: ');<br/>  }<br/>}</span></pre><p id="c797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须使用从<code class="fe me mf mg mh b">Symbol</code>创建的变量来引用一个符号，因为每次我们调用<code class="fe me mf mg mh b">Symbol</code>时都会创建一个新的符号。</p><p id="cefc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">符号不能被强制为字符串。</p><p id="e055" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下内容不起作用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="521e" class="mq lc iq mh b gy mr ms l mt mu">const foo = Symbol('foo');<br/>const str = foo + '';</span></pre><p id="d175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b0e" class="mq lc iq mh b gy mr ms l mt mu">const foo = Symbol('foo');<br/>const str = `${foo}`;</span></pre><p id="b8aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两个示例中，我们都将得到错误“未捕获的类型错误:无法将符号值转换为字符串”。</p><p id="183c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">toString</code>来转换。</p><p id="d7df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a724" class="mq lc iq mh b gy mr ms l mt mu">const foo = Symbol('foo');<br/>const str = foo.toString();</span></pre><p id="3cdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">str</code>就是<code class="fe me mf mg mh b">'Symbol(foo)’</code>。</p><p id="052c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下操作可识别符号:</p><ul class=""><li id="37d5" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe me mf mg mh b">Reflect.ownKeys()</code></li><li id="1400" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">通过<code class="fe me mf mg mh b">[]</code>的属性访问</li><li id="faa7" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">Object.assign()</code></li></ul><p id="74e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下忽略了作为键的符号:</p><ul class=""><li id="74ba" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe me mf mg mh b">Object.keys()</code></li><li id="a114" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">Object.getOwnPropertyNames()</code></li><li id="799a" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">for-in</code>循环</li></ul><p id="b9b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol</code>的字符串参数是可选的。</p><p id="54c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切符号都是独一无二的，所以:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2c4f" class="mq lc iq mh b gy mr ms l mt mu">Symbol() === Symbol()</span></pre><p id="8aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">false</code>。</p><p id="2650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">typeof</code>操作符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4889" class="mq lc iq mh b gy mr ms l mt mu">typeof Symbol()</span></pre><p id="80c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">'symbol'</code>。</p><p id="9cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码将符号用作属性键:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="884b" class="mq lc iq mh b gy mr ms l mt mu">const FOO = Symbol();<br/>const obj = {<br/>  [FOO]: 123<br/>};</span></pre><p id="389a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用它来定义方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2c61" class="mq lc iq mh b gy mr ms l mt mu">const FOO = Symbol();<br/>const obj = {<br/>  [FOO](){}<br/>};</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/32a5b37944b4a503e306e28d1bde63b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VDWWHfsBQX0GGIaG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@byamrit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Amrit Sangar </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="d39b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0c40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6 可以正确识别所有 Unicode 字符。</p><p id="64a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它还引入了用作唯一标识符的符号数据类型。</p></div></div>    
</body>
</html>