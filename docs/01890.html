<html>
<head>
<title>What is Unit Testing ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是单元测试？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-unit-testing-4925e77ea455?source=collection_archive---------41-----------------------#2020-07-13">https://blog.devgenius.io/what-is-unit-testing-4925e77ea455?source=collection_archive---------41-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b105" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解自动化软件开发测试的最小方面</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e291af2e601167574eff33738438a657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTJj_q7zBUN5DsnE_Wf0JA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">费伦茨·阿尔马西在<a class="ae ks" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2009" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">单元是指你软件中的一段代码</strong>。</p><p id="439c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这段代码可以有不同的行数，可以用任何编程语言编写。通俗地说，用不同的输入值运行一段代码，然后断言每次运行的输出，这叫做<strong class="kv io">单元测试</strong>。</p><p id="928f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大多数编程语言都支持模块化，使用模块化将代码分成块。在 Javascript 中，这些分离的块被称为模块。这些模块可以使用<em class="lp">导入</em> / <em class="lp">导出</em>(从 ES6)或<em class="lp">要求</em> / <em class="lp">模块创建。</em></p><p id="0b22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">(<em class="lp">对于这篇文章，我将参考 Javascript </em>来谈论“单元测试”)</p><p id="1aeb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在 Javascript 中，单元测试是通过从测试中调用导出的(公共)方法/属性来完成的。未导出的方法/属性不能直接测试。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="bb82" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">为什么要进行单元测试？</h2><p id="8a06" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">想象一下，将软件交给客户，它已经在 4 个不同的环境中通过了多轮手动测试。假设在生产环境中出现了一个小问题，开发团队只需要花几分钟就可以解决，但是要花 10 天才能将修复升级到生产环境中。这是一个问题，因为无论你要修复什么 bug，除非它们一起发布，否则每个 bug 都需要 10 天的人工测试。如果产品的功能增加，手工测试的工作量也会增加。为了解决这个问题，自动化测试被引入。</p><p id="4f0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">单元测试提供了自动化，减少了手工测试的工作量和发布时间。这有助于向客户快速发布特性/缺陷。单元测试是衡量软件质量和增加客户信任度的标准之一。</p><p id="e668" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">自动化测试可以是单元测试、集成测试、端到端测试、UI 测试或完整性测试。但是单元测试占据了测试金字塔的大部分份额，因为它们易于编写、运行和测量。他们在运行中花费最少的时间，这就是为什么最具成本效益。由于软件中的所有模块都是相互依赖的，单元测试提供了第一层防御来捕捉开发和发布阶段出现的回归/错误。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="fda1" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">改进单元测试的技巧</h2><p id="757b" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">单元测试根据给定的输入检查函数的流程，并返回输出。对于无状态函数，每个唯一的输入值将产生一个特定的输出，但对于有状态函数，情况可能并非如此。有状态函数很难测试，因为每次运行都会操作数据库中的记录，更新缓存或触发计时器。</p><p id="939e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">单元测试的先决条件是模拟所有的依赖关系，并孤立地测试特定的功能/模块。</p><ul class=""><li id="d178" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">针对多个输入值进行测试</li><li id="fb81" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">针对不同类型的输入值进行测试</li><li id="1d85" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">断言是否调用了模仿/依赖</li><li id="f5a2" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">断言调用模拟/依赖项的次数</li><li id="d6f8" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">针对预期输出进行断言</li></ul></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="dcda" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">测试生命周期中的阶段</h2><p id="4124" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">设置</em> </strong>:</p><ul class=""><li id="eec7" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">在运行测试之前设置配置(beforeAll)</li><li id="8397" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">在运行每个测试之前设置配置(每个测试之前)</li></ul><p id="d43c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">执行</em> </strong></p><ul class=""><li id="1510" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">运行单元测试</li></ul><p id="a950" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">T9】拆机 T11】</strong></p><ul class=""><li id="84a4" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">每次试运行后清理/完成工作</li><li id="f594" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">所有试运行后清理/完成工作(毕竟)</li></ul><h2 id="2c4b" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">单元测试的组件</h2><ul class=""><li id="08cf" class="mv mw in kv b kw mq kz mr lc nj lg nk lk nl lo na nb nc nd bi translated">测试创作(茉莉、Jest、摩卡)</li><li id="db71" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">Mocks (Sinon，Jasmine，Jest)</li><li id="d201" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">断言和匹配器(柴，茉莉，笑话)</li><li id="e4ce" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">试跑者(茉莉、杰斯特、摩卡)</li><li id="a60f" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">覆盖报告(伊斯坦布尔、Wallaby、纽约市)</li></ul><p id="b805" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在某些情况下，专门的库/包支持特定的组件，而其他时候一个库就足以执行所有的操作。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="cb24" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">例子</h2><p id="66f7" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">有趣的部分来了，在下面的例子中，我假设了一个简单的函数，它将两个数字相加，如果参数值中的任何一个是<em class="lp"> null </em>、<em class="lp"> undefined </em>或<em class="lp"> falsy </em>，就会抛出错误。</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="6c9a" class="lx ly in nn b gy nr ns l nt nu">// sum.js</span><span id="8e77" class="lx ly in nn b gy nv ns l nt nu">module.exports = function sumTwoNumbers(a, b) {<br/>  if (a &amp;&amp; b) {<br/>    return +(a + b)<br/>  }</span><span id="ebc9" class="lx ly in nn b gy nv ns l nt nu">throw new Error('Either A or B not defined, null or false')<br/>}</span></pre><p id="37e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于上述功能，这不是测试用例的穷举集。</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="7b3d" class="lx ly in nn b gy nr ns l nt nu">// test.js</span><span id="9746" class="lx ly in nn b gy nv ns l nt nu">const sum = require('sum')</span><span id="82db" class="lx ly in nn b gy nv ns l nt nu">describe('Sum of two numbers', () =&gt; {<br/>  test('when A and B are numbers', () =&gt; {<br/>    expect(sum(2, 3)).toBe(5)<br/>  })</span><span id="366a" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are strings', () =&gt; {<br/>    expect(sum('2', '3')).toBe(23)<br/>  })</span><span id="3541" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are boolean true', () =&gt; {<br/>    expect(sum(true, true)).toBe(2)<br/>  })</span><span id="658d" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a number and B is boolean true', () =&gt; {<br/>    expect(sum(2, true)).toBe(3)<br/>  })</span><span id="a89b" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a string and B is a number', () =&gt; {<br/>    expect(sum('4', 3)).toBe(43)<br/>  })</span><span id="18ee" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a number and B is empty array', () =&gt; {<br/>    expect(sum(2, [])).toBe(2)<br/>  })</span><span id="e70c" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a string and B is empty array', () =&gt; {<br/>    expect(sum('2', [])).toBe(2)<br/>  })</span><span id="72bd" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a number and B is empty object', () =&gt; {<br/>    expect(sum(2, {})).toBe(NaN)<br/>  })</span><span id="bffd" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a string and B is empty object', () =&gt; {<br/>    expect(sum('2', {})).toBe(NaN)<br/>  })</span><span id="d303" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a string and B is boolean true', () =&gt; {<br/>    expect(sum('2', true)).toBe(NaN)<br/>  })</span><span id="5259" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are boolean false', () =&gt; {<br/>    expect(sum(false, false)).toThrow('Either A or B not defined, null or false')<br/>  })</span><span id="3da6" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are null', () =&gt; {<br/>    expect(sum(null, null)).toThrow('Either A or B not defined, null or false')<br/>  })</span><span id="4613" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are undefined', () =&gt; {<br/>    expect(sum(undefined, undefined)).toThrow('Either A or B not defined, null or false')<br/>  })</span><span id="1df8" class="lx ly in nn b gy nv ns l nt nu">  test('when A and B are not passed', () =&gt; {<br/>    expect(sum()).toThrow('Either A or B not defined, null or false')<br/>  })</span><span id="5ebc" class="lx ly in nn b gy nv ns l nt nu">  test('when A is a number and B is not passed', () =&gt; {<br/>    expect(sum(2)).toThrow('Either A or B not defined, null or false')<br/>  })<br/>})</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="7a16" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">结论</h2><blockquote class="nw"><p id="0e6b" class="nx ny in bd nz oa ob oc od oe of lo dk translated">"质量是免费的，但只对那些愿意花大价钱购买的人开放."—德马科和李斯特</p></blockquote><p id="117c" class="pw-post-body-paragraph kt ku in kv b kw og jo ky kz oh jr lb lc oi le lf lg oj li lj lk ok lm ln lo ig bi translated">在软件开发中，产品质量至关重要，单元测试在其中扮演着重要角色。为了交付更高质量的产品，目标是 100%的测试覆盖率，实现并维护它们。</p></div></div>    
</body>
</html>