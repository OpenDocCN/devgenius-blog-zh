# 科特林流-什么，为什么和如何？

> 原文：<https://blog.devgenius.io/kotlin-flows-what-why-and-how-e9054327f795?source=collection_archive---------2----------------------->

> 随波逐流吧！！

![](img/1d814888d9b8db3337ef0ee81d1a4a48.png)

作为一名 Android 开发人员，我们无法逃脱周围的协同程序。说到协程，我们经常会遇到另一个问题，在 kotlin 中我们称之为 ***流*** 。听起来很酷，但它的功能确实如此。所以为什么不从基础开始探索和了解这些酷的科特林流呢？

在本文中，我们将尝试回答以下关于科特林流的问题

*   什么是心流，它们有什么作用？
*   我们为什么要使用它们？
*   我们应该如何使用它们？
*   取消基础
*   流程转换

> 如果你还没有开始，是时候开始了！

## 什么是心流，它们有什么作用？

流动基本上是一些值序列的发射。是的，这就是花。就像我们有生活数据，我们有流动。虽然有一些差异我们不会在这里讨论，但是你可以开始理解心流是如何工作的。

考虑这样一个场景，我们希望在不阻塞主线程的情况下，在一些计算之后，一个接一个地打印一些接收到的值序列。让我们看看如何才能实现它。

***带常规功能***

函数返回一个整数列表，我们立刻得到输出，这是同步的。所以这不能完全满足我们的需要。

***同***

我们修改示例函数以返回一个序列，每个值等待 1。这里我们看到，在输出中，所有的值都打印出来后，输出了" *main end"* 。这意味着这也是同步的，我们必须寻找另一个工作。

***带暂停功能***

挂起函数也是常规函数，它在协程范围内顺序操作，直到被提供挂起计算。所以即使这样也帮不了我们。

***同***

现在我们修改我们的 *example()* 函数来给出一个流。在输出中，我们看到“ *main end* ”在 flow 收集它的值之前打印出来，这表明 flow 没有阻塞我们的主线程并异步运行。

此外，我们注意到，现在 *example()* 函数不是一个挂起函数，它立即返回，我们继续以异步方式收集流。

这就是流量的用处。它们为我们提供了对异步值流支持。在本文的后面，我们将看到如何利用流做更多的事情。

## 我们为什么要使用它们？

我们可以在许多场景中使用流，特别是当我们有一些后台任务正在进行，并且它根据任务的一些状态发出一些数据，并且我们需要对这些状态做出反应时。

它们可能有用的几个场景如下:

***用况***

考虑进行一个 api 调用，其中我们的 UI 根据 api 调用的响应进行更新，即我们收到一个错误或成功，或者 api 调用已经开始，我们需要显示一些加载的 UI。我们这里有三个不同的状态要捕捉，所以 flow 是一个很好的选择。

***在流式 API 中***

如果我们使用一些流式 API，并且需要经常捕获事件，那么在这种情况下，flow 就可以派上用场。

***为事件或数据状态***

像 MutableSharedFlow、MutableStateFlow 这样的流类型可以分别用于 UI 的事件和状态更新。

## 我们应该如何使用它们？

到目前为止，我们已经对流动的内容和原因有了一些基本的了解。现在让我们来了解一下流的'*'如何'*。

首先如何使用流量。嗯！通过简单地在流构建器中编写代码，或者通过使用 ***asFlow()*** 转换任何集合/序列。

是的，就这么简单。请注意，该函数没有被挂起。这意味着函数通过给我们一个操作流来立即返回。

有趣且重要的一点是，流只有在被收集后才开始执行，也就是说，在我们为流设置收集器之前，它们不会开始执行。

> 这就是为什么流动是冷流。

如果我们收集流量两次，那么它将再次发出值。考虑下面的代码:

它的输出是:

耶！太酷了。让我们继续前进。

## 取消基础

我们知道协同程序遵循合作取消。以同样的方式流动也坚持合作取消。

> 如果您不了解协程的基础知识，那么请阅读这里的[和这里的](/kotlin-coroutines-what-why-how-99529c951a2e)和[您不会失望的。](/kotlin-coroutines-job-and-timeout-d7b8c5416d69)

正如我们所看到的，一旦时间到了，流不会发出值，我们在时间限制内只能得到一个值。

## 流程转换

可以使用操作符来转换流，就像我们对集合和序列所做的那样。这些运算符应用于上游流并返回下游流。这些操作符是冰冷的，就像流量一样。

考虑这个例子，流发出 10 个值，但是在上游使用操作符，我们创建了一个新的下游。

*   筛选运算符筛选出值。
*   Map 运算符将 int 值转换为延迟 1 秒的字符串值。
*   然后最后收集打印结果。

这里需要注意的一件重要事情是，操作符是针对每个发出的值顺序执行的。

你可以寻找更多的操作符来从一个给定的流中创建新的流，这就是流转换的含义。

哇哦。现在我们对 kotlin 中的流有了一些更好的理解，是时候开始学习流了。我们将在以后的文章中讨论更多关于流的内容，但是现在这已经足够了。

> 如果你想了解协程的基础知识，请查看我的文章[这里](/kotlin-coroutines-what-why-how-99529c951a2e)和[这里](/kotlin-coroutines-job-and-timeout-d7b8c5416d69)。

目前就这些了！敬请期待！

通过 medium(如果内容对您有帮助)或 [github](https://github.com/aqua30) 与我联系，并订阅电子邮件以同步了解更多关于 Android 的有趣话题。

直到下一次…

干杯！