<html>
<head>
<title>React Lifecycle methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应生命周期方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-lifecycle-methods-41cfb4c31bea?source=collection_archive---------9-----------------------#2021-12-20">https://blog.devgenius.io/react-lifecycle-methods-41cfb4c31bea?source=collection_archive---------9-----------------------#2021-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d83064935042661cfdb0f3e0fb3eb5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YePVzjkjsadOqzQ03wl5kA.png"/></div></div></figure><p id="4e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在学习React，刚刚进入类组件的世界，你一定遇到过“生命周期方法”这个词。本文将探索这些生命周期方法。如果你像我以前一样从事过android开发，生命周期方法可能对你来说有些熟悉，类似于android中的应用程序生命周期。但是如果你还没有，不要担心，我们试着一起一个一个的探索，爬上眼前的这座小山峰。</p><h1 id="0e84" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是生命周期方法？</h1><p id="e3d2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当我们使用类组件时，React会提供给我们一些方法，这些方法如果在我们的应用程序中定义，会在不同的预定义时间点自动执行。<br/>其中最常见的一种是渲染，你现在一定碰到过这个。我们可以简单地将这些生命周期方法分为三类，安装、更新和卸载。我们将逐一探讨每一个类别。</p><h2 id="d96f" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated"><em class="mi">安装</em></h2><p id="d641" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当组件被挂载时，挂载类别下的方法被调用。这些方法是:<br/> 1。构造函数()<br/> 2。render() <br/> 3。componentDidMount()</p><p id="823b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据React官方文档，前三种方法是最常用的安装方法。当一个组件被安装时，这些方法按上述顺序被调用。下面是启动基本React应用程序时的控制台输出。[本文使用的代码附在最后]</p><blockquote class="mj mk ml"><p id="965a" class="jv jw mm jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">构造函数被调用<br/>渲染被调用<br/>组件被调用挂载</p></blockquote><h2 id="3310" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">构造器</h2><p id="2baf" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如预期的构造函数类似于我们在编程语言中已经看到很久的构造函数，通常用于初始化状态或其他在以后需要的变量。我们通常避免在构造函数中进行任何数据密集型调用，这并不是说它有任何影响，只是它符合React社区编码标准。如果我们不必初始化state或prop，我们可以选择省略定义构造函数的方法。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="363e" class="lw ku in mv b gy mz na l nb nc">constructor(props){<br/>   state = {latitude:null, variable2:null);<br/>   this.prop.variable3 = undefined;<br/>}</span></pre><p id="3066" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然我们将构造函数放在“安装”类别下，但是构造函数实际上是在组件被安装之前被调用的。</p><h2 id="ae3b" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">提供；给予</h2><p id="e046" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">render()是我们的老朋友，只是简单地用来返回JSX内容。这是类组件所需的唯一方法，其余的方法可以根据需要使用。当我们使用“setState”更新状态时，也会调用它。当我们从ComponentDidMount()函数获得状态更新时，将再次调用render函数，这一次,“纬度”变量的更新值将显示在屏幕上。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7759" class="lw ku in mv b gy mz na l nb nc">render(){<br/> return &lt;div&gt; {this.state.latitude} &lt;div&gt;</span></pre><h2 id="673b" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">组件安装</h2><p id="3b2f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于数据/时间密集型调用，我们通常使用componentDidMount()，假设您希望获得用户的位置，此方法将是进行该调用的好选择。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="099c" class="lw ku in mv b gy mz na l nb nc">componentDidMount()<br/>{<br/>window.navigator.geolocation.getCurrentPosition(<br/>(position) =&gt; {<br/>this.setState({latitude:position.coords.latitude})<br/>},<br/>(err)=&gt; {<br/>this.setState({errorMessage:err.message})<br/>})<br/>}</span></pre><p id="fa7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们从地理位置API获取位置，并将状态变量“latitude”更新为获取的值。在构造函数和呈现方法之后调用此方法。</p><h1 id="e0f1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">更新</h1><p id="6e96" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当状态或属性被更新时，一些生命周期方法被调用，这些方法在下面被提及:<br/> 1。shouldComponentUpdate() <br/> 2。【T2渲染()】3。componentDidUpdate()</p><p id="6e4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当组件更新被触发时，这些函数按上述顺序被调用。</p><h2 id="6451" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">shouldComponentUpdate</h2><p id="c407" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">顾名思义，shouldComponentUpdate处理组件是否应该更新。默认情况下，它返回值true，如果声明为false，将导致render和componentDidUpdate等后续函数不会被触发。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6b49" class="lw ku in mv b gy mz na l nb nc">shouldComponentUpdate()<br/>{<br/> return false;<br/>}</span></pre><p id="4c6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果返回true，则在shouldComponentUpdate之后调用render。这是我们在安装部分已经讨论过的内容。</p><h2 id="61fc" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">componentDidUpdate</h2><p id="c360" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">顾名思义，这个函数在组件更新时被调用。例如，如果您更新了一个状态的值，那么这个函数将被调用。componentDidUpdate通常也适用于需要某种状态更新的数据密集型调用。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="313b" class="lw ku in mv b gy mz na l nb nc">componentDidUpdate(){<br/>console.log(‘ComponentDidUpdate called’);<br/>}</span></pre><p id="4bde" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们获取纬度并更新它时，我们从上面的函数componentDidMount更新状态，一旦我们更新了状态，componentDidUpdate就会被调用。</p><p id="4e88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来自控制台的输出(在函数componentDidMount中添加了控制台日志语句)</p><blockquote class="mj mk ml"><p id="5601" class="jv jw mm jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">index.js:17 componentDidMount被调用<br/>index . js:21 ComponentDidUpdate被调用</p></blockquote><p id="37bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们在使用生命周期方法时遇到的最常见的方法。如果你觉得这有帮助，别忘了鼓掌。</p><p id="bdb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的代码片段:【https://github.com/archi14/Lifecycle-methods T4】</p></div></div>    
</body>
</html>