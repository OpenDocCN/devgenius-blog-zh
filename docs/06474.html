<html>
<head>
<title>Reinvent the Wheel Ep. 1: Removing Unused Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新发明轮子。1:删除未使用的文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-tale-of-over-engineering-ep-1-removing-unused-files-dc6dc55fd761?source=collection_archive---------16-----------------------#2022-01-10">https://blog.devgenius.io/a-tale-of-over-engineering-ep-1-removing-unused-files-dc6dc55fd761?source=collection_archive---------16-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7826f059f64df4ec2f0e40f4d9618837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PC4r1YSSbxvkJEjE_eCbw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://burst.shopify.com/@ndekhors?utm_campaign=photo_credit&amp;amp;utm_content=Picture+of+Hands+Typing+Code+On+Laptop+%E2%80%94+Free+Stock+Photo&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">妮可·德·霍斯</a>从<a class="ae jz" href="https://burst.shopify.com/onlinelearning?utm_campaign=photo_credit&amp;amp;utm_content=Picture+of+Hands+Typing+Code+On+Laptop+%E2%80%94+Free+Stock+Photo&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">爆</a></figcaption></figure><p id="b722" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">骑了 15 分钟的摩托车到办公室后，没有什么比一杯新鲜的矿泉水更好了。这是一个阳光明媚的星期一早晨，甚至没有一丝即将下雨的迹象。很明显，在我的背包上没有防雨罩的情况下骑车是个不错的天气，但是没有手套和防晒霜就不适合骑车了。</p><p id="1327" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">23 GB 免 500 GB。如果不是因为丢失的文档和我 mac 上 documents 文件夹中每个文件旁边的下载图标，我不会注意到这一点。当你在 PlatformIO 上反复使用 Node.js、Next.js、React、Arduino 等技术栈时，磁盘的可用空间量迅速下降就不足为奇了。</p><p id="c664" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个叫 ncdu 的工具告诉我哪个项目占用的空间超过百兆。它还让我逐个删除<code class="fe ky kz la lb b">node_modules</code>或<code class="fe ky kz la lb b">.pio</code>目录。</p><p id="a230" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如何在打开 ncdu 的同时不用手动按键盘上的箭头键和 D 键就能快速删除全部呢？</p><p id="0b82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名软件工程师，将这一漫长而乏味的过程自动化的冲动高得离谱。但是，等到你有重新发明一种工具的冲动，而这种工具实际上已经存在了很长时间，只是后来才意识到这一点，并问自己“为什么我没有使用它？？?"。</p><p id="9bbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，我写了一个 CLI 工具，用来删除当前工作目录下名称与 CLI 标志值相匹配的每个目录。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="814f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我有一段时间没用围棋了。我都不记得上次我用围棋做项目是什么时候了。所以，我用<code class="fe ky kz la lb b">go mod github.com/alwint3r/janithor</code>命令创建了一个项目。</p><p id="077c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，你没看错，请不要问我为什么选择这个名字。</p><p id="d185" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我需要一种方法:</p><ul class=""><li id="6d5b" class="lj lk in kc b kd ke kh ki kl ll kp lm kt ln kx lo lp lq lr bi translated">获取当前工作目录</li><li id="7e47" class="lj lk in kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr bi translated">获取我想从命令行参数中删除的目录的名称</li><li id="7b66" class="lj lk in kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr bi translated">遍历当前目录树，收集我想要删除的目录的绝对路径，并将它们放在一个字符串片(数组)上</li><li id="bac3" class="lj lk in kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr bi translated">迭代切片并从文件系统中实际删除每个条目。</li></ul><p id="eba9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了获得当前的工作目录，我可以使用<code class="fe ky kz la lb b">os</code>包中的<code class="fe ky kz la lb b">Getcwd</code>函数</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="1445" class="mf mg in lb b gy mh mi l mj mk">cwd, err := os.Getcwd()</span></pre><p id="a73e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我使用这一行来获取我想要删除的目录名:</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="15f6" class="mf mg in lb b gy mh mi l mj mk">var folderName = flag.String("dir", "", "The folder that will be removed");</span></pre><p id="8a59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我定义了一个函数，可以用来查找每个目录的绝对路径，该目录的名称存储在变量<code class="fe ky kz la lb b">folderName</code>中。</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="5d89" class="mf mg in lb b gy mh mi l mj mk">func walk(base, target string, entry fs.DirEntry, output *[]string) error {</span><span id="7c07" class="mf mg in lb b gy ml mi l mj mk">// ...</span><span id="c73a" class="mf mg in lb b gy ml mi l mj mk">}</span></pre><p id="3986" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数接受<code class="fe ky kz la lb b">base</code>作为当前工作目录或当前工作目录中的任何目录。<code class="fe ky kz la lb b">target</code>存储我想要删除的目录的名称，而<code class="fe ky kz la lb b">entry</code>参数保存当前工作目录的信息。最后，<code class="fe ky kz la lb b">output</code>参数是一个指向字符串数组切片的指针，这样我就可以添加我想要删除的目录的每个绝对路径。如果一切正常，那么函数将返回 nil，否则它将返回我使用的标准库包的函数返回的任何错误。</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="a387" class="mf mg in lb b gy mh mi l mj mk">var fullPath string<br/>if entry == nil {<br/>    fullPath = base<br/>} else {<br/>    fullPath = path.Join(base, entry.Name())<br/>}</span></pre><p id="9945" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我检查条目是否为零。如果是 nil，那么我假设 base 是当前工作目录或者<code class="fe ky kz la lb b">cwd</code>。否则，<code class="fe ky kz la lb b">fullPath</code>将被设置为<code class="fe ky kz la lb b">entry</code>的绝对路径。它可以是文件或目录。</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="6112" class="mf mg in lb b gy mh mi l mj mk">if entry != nil &amp;&amp; entry.IsDir() &amp;&amp; entry.Name() == target {<br/>    *output = append(*output, fullPath)</span><span id="5c17" class="mf mg in lb b gy ml mi l mj mk">    return nil<br/>}</span></pre><p id="60ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我检查<code class="fe ky kz la lb b">entry</code>是否是一个名称与我想要删除的目录的名称相匹配的目录。如果为 true，将绝对路径添加到输出切片并返回 nil，从而中断递归。</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="641e" class="mf mg in lb b gy mh mi l mj mk">if entry == nil || entry.IsDir() {<br/>    dirEntry, err := os.ReadDir(fullpath)</span><span id="715b" class="mf mg in lb b gy ml mi l mj mk">    if err != nil {<br/>        return err<br/>    }</span><span id="b182" class="mf mg in lb b gy ml mi l mj mk">    for _, dir := range dirEntry {<br/>        walk(fullPath, target, dir, output)<br/>    }<br/>}</span></pre><p id="bf3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果程序当前位于<code class="fe ky kz la lb b">cwd</code>或<code class="fe ky kz la lb b">cwd</code>内的任何目录，则读取当前目录的条目，并递归遍历每个条目，直到满足之前的停止条件。现在功能完成了。</p><p id="463d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下几行位于 main 函数内部</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="c813" class="mf mg in lb b gy mh mi l mj mk">deleteList := make([]string, 0)</span><span id="0e91" class="mf mg in lb b gy ml mi l mj mk">walk(cwd, *folderName, nil, &amp;deleteList);</span><span id="d88c" class="mf mg in lb b gy ml mi l mj mk">for _, dir := range deleteList {<br/>    err := os.RemoveAll(file)<br/>    // .. error handling<br/>}</span></pre><p id="3b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我需要从<code class="fe ky kz la lb b">os</code>包中调用<code class="fe ky kz la lb b">RemoveAll</code>函数来删除一个目录及其内容。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="e3c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！</p><p id="436b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了简洁起见，这里没有列出完整的代码。如果您有兴趣，可以稍后查看 GitHub 资源库中的完整源代码。</p><p id="8843" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它像预期的那样工作，我在 mac 上删除了几十个<code class="fe ky kz la lb b">.pio</code>和<code class="fe ky kz la lb b">node_modules</code>目录，并设法恢复了超过 10 GB 的可用空间。</p><p id="d9a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，它可以工作，但是我知道我可以通过在终端窗口上运行这一行命令来完成同样的事情吗？</p><pre class="lx ly lz ma gt mb lb mc md aw me bi"><span id="091c" class="mf mg in lb b gy mh mi l mj mk">find . -type d -name .pio -exec rm -rf {} \;</span></pre><p id="8320" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我做到了。</p><p id="f5a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在花不到 30 分钟的时间写自己的工具之前，我想到了吗？不，我没有。这种事经常发生。</p><p id="e7ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名软件工程师，我需要被提醒的是，我不必在每次遇到可以自动解决的问题时都制作自己的工具。必须有一个现有的工具来完成这项工作，并且很可能比我自己的工具好得多。</p><p id="768e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我后悔做了吗？绝对没有。</p><p id="2663" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我设法重新学习如何用 Go 编程语言编码，并利用其丰富的标准库包。而你，一个随机而奇妙的互联网人，你知道我最后一次使用递归是什么时候吗？</p><p id="35fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有吗？我也不知道。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="64f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！请不要犹豫给我你的反馈，尤其是对我的破烂英语。这对我意义重大。</p><div class="mm mn gp gr mo mp"><a href="http://github.com/alwint3r/janithor" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">GitHub - alwint3r/janithor</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">从当前工作目录中删除目录及其所有内容。示例:移除。pio 目录这将…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>