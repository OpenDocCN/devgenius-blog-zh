<html>
<head>
<title>Memory management in Rust — Part 1: Ownership and Moves</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 中的内存管理—第 1 部分:所有权和移动</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ownership-and-moves-in-rust-4a9c6f02108d?source=collection_archive---------3-----------------------#2022-07-08">https://blog.devgenius.io/ownership-and-moves-in-rust-4a9c6f02108d?source=collection_archive---------3-----------------------#2022-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Rust 中的内存管理介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e5fa1da1144d29ee23746d1b160c2961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuBay538y_dpWD07nLqhYg.jpeg"/></div></div></figure><p id="cdc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要担心；我并不是想向你推销最新的 Titok 舞或者拥有一栋房子的好处或不便之处等等。我们将回顾编程语言 Rust 中的概念<strong class="kt ir">所有权</strong>和<strong class="kt ir">移动</strong>。</p><p id="ef27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我 2022 年的第一篇文章之一，<a class="ae ln" href="https://anismousse.medium.com/why-you-should-learn-rust-fa52d0139b85" rel="noopener"> <em class="lo">你为什么学锈！</em> </a>我提到过 Rust 最吸引人的一个特点就是它的<strong class="kt ir">安全性</strong>。我们将深入我们最喜欢的编程语言的安全方面，并试图理解内存是如何管理的。</p><h1 id="3c7b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">内存管理</h1><p id="d69b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">编程语言通常由它们如何处理内存管理来定义。</p><p id="6cb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lo">在完美的世界里，一个编程语言应该能够随意分配内存，同时保证指向一个已经被释放的对象的指针(悬空指针)不能被使用。</em> </strong></p><p id="48c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我们并不是生活在一个完美的世界中，所以一些编程语言如 Python 或 Java 选择将移除悬空指针的责任委托给一个<strong class="kt ir">垃圾收集器；</strong>还有，其他的，比如 C 或 C++，简单来说(🤣)<strong class="kt ir">让你负责释放内存</strong>。</p><p id="eb89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rust 通过<strong class="kt ir">限制</strong>如何在程序中使用指针采取了不同的方法。<strong class="kt ir">所有权</strong>和<strong class="kt ir">移动</strong>的概念定义了那些限制。</p><h1 id="96f2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">所有权</h1><p id="45b3" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">所有权的概念是由编译时检查(Cargo)强制实施的 Rust 的核心概念，可以用下面的内容来描述:<strong class="kt ir"> <em class="lo">每个值都有一个确定其生存期的唯一所有者</em> </strong>。<strong class="kt ir"> <em class="lo">当拥有者被释放时，拥有的价值也被释放。</em> </strong></p><p id="9b57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单来说，变量拥有它的值，变量被丢弃，值也随之被丢弃。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">可变所有权示例</figcaption></figure><p id="faec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了跟踪所有权关系，Rust 保留了一些<strong class="kt ir"> <em class="lo">树</em> </strong>，其中所有者是父代，拥有的值是子代，每棵树的最终父代是一个变量。</p><p id="eaa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当一个变量被删除时(例如，超出范围)，Rust 会将它从所有权树中删除，确保该变量及其所有拥有的值都被有效地删除。</p><p id="abca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是另一个例子，它直观地展示了相关的 Rust 树:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">可变所有权的另一个例子</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/12503b59a95e17b353ca120354a5f5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8uFGKXg9jzRrSPt91UJUA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Rust 的树可视化表示</figcaption></figure><p id="501f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，对于这个例子，当<code class="fe mt mu mv mw b">missy_foods_items</code>超出范围时，Rust 将丢弃其树中的所有元素。</p><p id="108f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个概念相对简单，但也很有限制性。例如，当我们从现有的价值中创造新的价值时会发生什么？</p><p id="b242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面就来拯救一下<strong class="kt ir"> <em class="lo">招式</em> </strong>。</p><h1 id="1996" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">移动</h1><p id="9122" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">Rust 中的<strong class="kt ir">移动</strong>概念为所有权角色提供了灵活性。</p><p id="d50c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于大多数类型，赋值、传递或返回值不会复制它，而是由<strong class="kt ir">移动</strong>它。</p><p id="43a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lo">初始源将其值所有权让给目标，从而变得未初始化。目标源现在完全拥有该价值并决定其寿命。</em> </strong></p><p id="1a7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，Rust 中的<strong class="kt ir">赋值</strong>概念可能有点混乱。</p><p id="f09f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rust 中的赋值操作是廉价的，因为我们将值移动到一个新的所有者之下，并且未初始化前一个所有者(类似于 python shallow copy，注意，由于有了<strong class="kt ir"> one owner </strong>规则，我们不需要记录所有引用)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Rust 中的失败赋值</figcaption></figure><p id="30e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的示例代码生成以下编译错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/500f4ae068c30e9d68995a9f28d21150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6jBxnYoDvxNr7gvKmYDXA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">分配失败后的货物输出</figcaption></figure><p id="dda0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们详细看看为什么我们会有这个错误。</p><p id="9da5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，创建一个包含 Missy 最喜欢的食物项目的向量，并归宏<code class="fe mt mu mv mw b">vec!</code>所有。然后，这个宏将放弃它对向量的所有权，转而支持变量<code class="fe mt mu mv mw b">food</code>，并且不初始化它自己。</p><p id="21fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照类似的赋值逻辑，在示例代码的第 3 行，变量<code class="fe mt mu mv mw b">food</code>也将放弃其对 vector 的所有权，转而支持变量<code class="fe mt mu mv mw b">maybe_real_food</code>并取消其自身的初始化。</p><p id="ec4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，在第 4 行，当我们试图给变量<code class="fe mt mu mv mw b">real_food</code>赋值<code class="fe mt mu mv mw b">food</code>时，cargo 表达了它的不满，因为在这个阶段<code class="fe mt mu mv mw b">food</code>是未定义的(它的值已经被移到变量<code class="fe mt mu mv mw b">maybe_real_food</code>)。</p><p id="f217" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 Rust 中，我们需要明确我们的意图。如果我们的目标是在 C++中有一个类似的赋值操作(深度拷贝的执行取决于所涉及的值)，我们必须更加精确:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">深层拷贝赋值</figcaption></figure><p id="1c5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们前面提到的，一个<strong class="kt ir"> <em class="lo"> move </em> </strong>保持其源未初始化，这对于一个特定类型的引用可能是有问题的，比如一个 vector。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">向量元素提取失败</figcaption></figure><p id="55a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，Rust 为这个问题提供了不同的解决方案，包括方法<code class="fe mt mu mv mw b">std::mm::replace</code>允许您从向量中提取一个值并用不同的值替换它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">成功提取向量元素</figcaption></figure><h1 id="331f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">更多的灵活性:复制类型和 Rc 和 Arc 指针</h1><p id="39db" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果您之前没有注意到，在我的所有例子中，在构建我的 vector 时，我们调用方法<code class="fe mt mu mv mw b">to_string</code>来获得一个由<code class="fe mt mu mv mw b">String</code>对象组成的 vector，这些对象是分配在内存堆部分的复杂结构。</p><p id="6c7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很重要，因为除了<strong class="kt ir"> <em class="lo">复制类型</em> </strong>之外，大多数类型都可以移动，复制类型包括整型、浮点型、字符型和布尔型。赋值操作继续复制值，而不是移动它。</p><p id="b4a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，Rust 还引入了<strong class="kt ir"> Rc </strong>和<strong class="kt ir"> Arc </strong>指针，引用计数器指针提供了支持多重所有权的灵活性(更多关于<a class="ae ln" href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noopener ugc nofollow" target="_blank"> Arc </a>和<a class="ae ln" href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html" rel="noopener ugc nofollow" target="_blank"> Rc </a>)，类似于 python。</p><h1 id="aa2b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">最后</h1><p id="11e9" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">理解所有权和移动概念是理解 Rust 本身的基础，因为它们定义了它的核心原则。</p><p id="000e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以想象，Rust 是一种严格按值传递的编程语言。</p><p id="b1a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它很容易跟踪变量和值之间的关系(<strong class="kt ir">所有权</strong>)，同时通过<strong class="kt ir">移动、复制类型、Rc/Arc 指针和引用借用</strong>(我下一篇文章的主题)的概念提供灵活性，以在保证安全的同时产生足够的解决方案。</p><blockquote class="my"><p id="c181" class="mz na iq bd nb nc nd ne nf ng nh lm dk translated">“安全的代码允许你冒更大的风险”(艾米丽·邓纳姆)</p></blockquote><p id="3b1d" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">铁锈明显的坚硬是它如此强大的原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/3e75f075254e078bcd0effe4f18476a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-OmNztoVlRNTy1C6kKUYA.jpeg"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">在对我表演了一个 Rust 的动作后，Missy 声称拥有我在沙发上的位置。</figcaption></figure><p id="bd1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一如既往，欢迎一切反馈；👋,👍欢迎光临！！</p><p id="3e24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，如果你像我一样喜欢 Rust，并且有兴趣建立一个 meetup 群组，请告诉我！！下面是我的<a class="ae ln" href="https://twitter.com/home?lang=en" rel="noopener ugc nofollow" target="_blank">推特</a>:</p><h2 id="d85e" class="no lq iq bd lr np nq dn lv nr ns dp lz la nt nu mb le nv nw md li nx ny mf nz bi translated">其他资源:</h2><p id="7d12" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated"><em class="lo">生锈</em>:https://www.rust-lang.org/learO'·雷利<em class="lo">还好</em>:<a class="ae ln" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/book/</a></p><p id="32b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">与奥莱利的 Rust 速成班</em>:<a class="ae ln" href="https://learning.oreilly.com/videos/ultimate-rust-crash/9781800563902/" rel="noopener ugc nofollow" target="_blank">https://learning . oreilly . com/videos/ultimate-Rust-crash/9781800563902/</a></p><p id="9849" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">Rust 的温柔介绍:</em><a class="ae ln" href="https://stevedonovan.github.io/rust-gentle-intro/readme.html" rel="noopener ugc nofollow" target="_blank">https://Steve Donovan . github . io/Rust-gentle-intro/readme . html</a></p></div></div>    
</body>
</html>