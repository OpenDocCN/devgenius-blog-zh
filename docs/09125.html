<html>
<head>
<title>LeetCode — Combination Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —组合和</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-combination-sum-92a964a6b7ad?source=collection_archive---------7-----------------------#2022-07-31">https://blog.devgenius.io/leetcode-combination-sum-92a964a6b7ad?source=collection_archive---------7-----------------------#2022-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="3407" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题陈述</h1><p id="8285" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">给定一个由<strong class="kk io">个不同的</strong>个整数<em class="lg">个候选数</em>和一个目标整数<em class="lg">个目标数</em>组成的数组，返回所有<em class="lg">个候选数</em>的<strong class="kk io">个唯一组合</strong>的列表，其中所选数字的总和为目标数。您可以以任何顺序返回<strong class="kk io">中的组合</strong>。</p><p id="b142" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">同一个<strong class="kk io">号码可以从<em class="lg">候选号码</em>和<strong class="kk io">中无限次选择</strong>。如果至少一个所选数字的频率不同，则两个组合是唯一的。</strong></p><p id="45cb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">保证</strong>对于给定的输入，总计为<em class="lg">目标</em>的唯一组合的数量少于<em class="lg"> 150 </em>个组合。</p><p id="ff89" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">例 1: </strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="426b" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2, 3, 6, 7], target = 7<br/>Output: [[2, 2, 3], [7]]<br/>Explanation:<br/>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br/>7 is a candidate, and 7 = 7.<br/>These are the only two combinations.</span></pre><p id="a477" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">例二:</strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3a1d" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2, 3, 5], target = 8<br/>Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]</span></pre><p id="bff8" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">例 3: </strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="89d6" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2], target = 1<br/>Output: []</span></pre><p id="1a7f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">约束:</strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f008" class="lv jl in lr b gy lw lx l ly lz">- 1 &lt;= candidates.length &lt;= 30<br/>- 1 &lt;= candidates[i] &lt;= 200<br/>- All elements of candidates are distinct.<br/>- 1 &lt;= target &lt;= 500</span></pre><h1 id="4c4c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">说明</h1><h2 id="1953" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">强力方法</h2><p id="1872" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">强力方法是生成所有组合，并验证数组中的元素总和是否达到目标。</p><p id="d2e8" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">但上述程序的时间复杂度将为<strong class="kk io"> O(N ) </strong>。</p><h2 id="18c8" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">追踪</h2><p id="9216" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这类问题可以使用回溯来解决。我们编写了一个递归函数，其中我们一直将数组元素附加到一个临时数组(称为 current ),并一直跟踪这个临时数组中元素的总和。在递归函数中，我们保留了两种基本情况。</p><ol class=""><li id="e457" class="ml mm in kk b kl lh kp li kt mn kx mo lb mp lf mq mr ms mt bi translated">第一个基本情况是检查临时数组中元素的总和是否等于目标值。如果是，我们返回并将临时数组附加到最终结果中。</li><li id="a632" class="ml mm in kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">第二个基本情况是检查总和是否超过我们刚刚返回的目标元素。</li></ol><p id="32fa" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们检查一下算法，以便清楚地理解上面的方法。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="27c0" class="lv jl in lr b gy lw lx l ly lz">- initialize the result as a 2D array<br/>  initialize current as an array<br/><br/>  // n = index, at start it will be 0.<br/>  // sumTillNow = sum of the current elements in the array, at the start it will be 0<br/>  // current = current list of elements in the array, at the start it will be an empty array []<br/>- call combinationSumUtil(result, candidates, n, target, sumTillNow, current)<br/><br/>- return result<br/><br/>// combinationSumUtil function<br/>- if sumTillNow == target<br/>  // append current to result<br/>  - result.push_back(current)<br/><br/>- if sumTillNow &gt; target<br/>  - return<br/><br/>- loop for i = n; i &lt;= candidates.size() - 1; i++<br/>  // append candidates array ith element to the current array<br/>  - current.push_back(candidates[i])<br/><br/>  - sumTillNow += candidates[i]<br/><br/>  // call the function recursively<br/>  - combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/><br/>  - sumTillNow -= current[current.size() - 1]<br/><br/>  // remove the last element from the array<br/>  - current.pop_back()</span></pre><p id="34aa" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们来看看我们在<strong class="kk io"> C++ </strong>、<strong class="kk io"> Golang </strong>和<strong class="kk io"> Javascript </strong>中的解决方案。</p><h2 id="b1d8" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">C++解决方案</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a074" class="lv jl in lr b gy lw lx l ly lz">class Solution {<br/>public:<br/>    void combinationSumUtil(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, int n, int target, int sumTillNow, vector&lt;int&gt;&amp; current) {<br/>        if(sumTillNow == target) {<br/>            result.push_back(current);<br/>        }<br/><br/>        if(sumTillNow &gt; target) {<br/>            return;<br/>        }<br/><br/>        for(int i = n; i &lt;= candidates.size() - 1; i++) {<br/>            current.push_back(candidates[i]);<br/>            sumTillNow += candidates[i];<br/><br/>            combinationSumUtil(result, candidates, i, target, sumTillNow, current);<br/><br/>            sumTillNow -= current[current.size() - 1];<br/>            current.pop_back();<br/>        }<br/>    }<br/><br/>    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {<br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/>        vector&lt;int&gt; current;<br/><br/>        combinationSumUtil(result, candidates, 0, target, 0, current);<br/>        return result;<br/>    }<br/>};</span></pre><h2 id="9f99" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">戈朗溶液</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="38f1" class="lv jl in lr b gy lw lx l ly lz">func combinationSumUtil(result *[][]int, candidates []int, n, target, sumTillNow int, current []int) {<br/>    if sumTillNow == target {<br/>        *result = append(*result, append([]int{}, current...))<br/>        return<br/>    }<br/><br/>    if sumTillNow &gt; target {<br/>        return<br/>    }<br/><br/>    for i := n; i &lt;= len(candidates) - 1; i++ {<br/>        current = append(current, candidates[i])<br/>        sumTillNow = sumTillNow + candidates[i]<br/><br/>        combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/><br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>        current = current[:len(current) - 1]<br/>    }<br/>}<br/><br/>func combinationSum(candidates []int, target int) [][]int {<br/>    result := make([][]int, 0)<br/><br/>    combinationSumUtil(&amp;result, candidates, 0, target, 0, []int{})<br/><br/>    return result<br/>}</span></pre><h2 id="911b" class="lv jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">Javascript 解决方案</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2e67" class="lv jl in lr b gy lw lx l ly lz">var combinationSum = function(candidates, target) {<br/>    let result = [];<br/><br/>    const combinationSumUtil = (candidates, n, target, sumTillNow, current) =&gt; {<br/>        if(sumTillNow === target) {<br/>            result.push([...current]);<br/>        }<br/><br/>        if(sumTillNow &gt; target) {<br/>            return;<br/>        }<br/><br/>        for(let i = n; i &lt;= candidates.length - 1; i++){<br/>            current.push(candidates[i]);<br/>            sumTillNow += candidates[i];<br/><br/>            combinationSumUtil(candidates, i, target, sumTillNow, current);<br/><br/>            sumTillNow -= current[current.length - 1];<br/>            current.pop();<br/>        }<br/>    }<br/><br/>    combinationSumUtil(candidates, 0, target, 0, []);<br/><br/>    return result;<br/>};</span></pre><p id="ceb1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们试运行一下我们的算法。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0b6e" class="lv jl in lr b gy lw lx l ly lz">Input: candidates = [2, 3, 6, 7]<br/>       target = 7<br/><br/>// combinationSum function<br/>Step 1: vector&lt;vector&lt;int&gt;&gt; result<br/>        vector&lt;int&gt; current<br/><br/>Step 2: combinationSumUtil(result, candidates, 0, target, 0, current)<br/><br/>// combinationSumUtil function<br/>Step 3: if sumTillNow == target<br/>           0 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           0 &gt; 7<br/>           false<br/><br/>        loop for int i = n; i &lt;= candidates.size() - 1<br/>             i = 0<br/>             i &lt;= 4 - 1<br/>             0 &lt;= 3<br/>             true<br/><br/>             current.push_back(candidates[i])<br/>             current.push_back(candidates[0])<br/>             current.push_back(2)<br/>             current = [2]<br/><br/>             sumTillNow += candidates[i]<br/>                         = sumTillNow + candidates[0]<br/>                         = 0 + 2<br/>                         = 2<br/><br/>             combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>             combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 2, [2])<br/><br/>Step 4: if sumTillNow == target<br/>           2 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           2 &gt; 7<br/>           false<br/><br/>        loop for int i = n; i &lt;= candidates.size() - 1<br/>             i = 0<br/>             i &lt;= 4 - 1<br/>             0 &lt;= 3<br/>             true<br/><br/>             current.push_back(candidates[i])<br/>             current.push_back(candidates[0])<br/>             current.push_back(2)<br/>             current = [2, 2]<br/><br/>             sumTillNow += candidates[i]<br/>                         = sumTillNow + candidates[0]<br/>                         = 2 + 2<br/>                         = 4<br/><br/>             combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>             combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 4, [2, 2])<br/><br/>Step 5: if sumTillNow == target<br/>           4 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           4 &gt; 7<br/>           false<br/><br/>        loop for int i = n; i &lt;= candidates.size() - 1<br/>             i = 0<br/>             i &lt;= 4 - 1<br/>             0 &lt;= 3<br/>             true<br/><br/>             current.push_back(candidates[i])<br/>             current.push_back(candidates[0])<br/>             current.push_back(2)<br/>             current = [2, 2, 2]<br/><br/>             sumTillNow += candidates[i]<br/>                         = sumTillNow + candidates[0]<br/>                         = 4 + 2<br/>                         = 6<br/><br/>             combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>             combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 6, [2, 2, 2])<br/><br/>Step 6: if sumTillNow == target<br/>           6 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           6 &gt; 7<br/>           false<br/><br/>        loop for int i = n; i &lt;= candidates.size() - 1<br/>             i = 0<br/>             i &lt;= 4 - 1<br/>             0 &lt;= 3<br/>             true<br/><br/>             current.push_back(candidates[i])<br/>             current.push_back(candidates[0])<br/>             current.push_back(2)<br/>             current = [2, 2, 2, 2]<br/><br/>             sumTillNow += candidates[i]<br/>                         = sumTillNow + candidates[0]<br/>                         = 6 + 2<br/>                         = 8<br/><br/>             combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>             combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 8, [2, 2, 2, 2])<br/><br/>Step 7: if sumTillNow == target<br/>           8 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           8 &gt; 7<br/>           true<br/>           return<br/><br/>           we backtrack to step 6 and continue<br/><br/>Step 8: combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 8, [2, 2, 2, 2])<br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>                   = 8 - current[4 - 1]<br/>                   = 8 - current[3]<br/>                   = 8 - 2<br/>                   = 6<br/><br/>        current.pop_back()<br/>        current = [2, 2, 2]<br/><br/>        i++<br/>        i = 1<br/><br/>        i = 1<br/>        i &lt;= 4 - 1<br/>        1 &lt;= 3<br/>        true<br/><br/>        current.push_back(candidates[i])<br/>        current.push_back(candidates[1])<br/>        current.push_back(3)<br/>        current = [2, 2, 2, 3]<br/><br/>        sumTillNow += candidates[i]<br/>                    = 6 + candidates[1]<br/>                    = 6 + 3<br/>                    = 9<br/><br/>        combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>        combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 9, [2, 2, 2, 3])<br/><br/>Step 9: if sumTillNow == target<br/>           9 == 7<br/>           false<br/><br/>        if sumTillNow &gt; target<br/>           9 &gt; 7<br/>           true<br/>           return<br/><br/>           we backtrack to step 8 and continue<br/><br/>Step 10:combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 9, [2, 2, 2, 3])<br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>                   = 9 - current[4 - 1]<br/>                   = 9 - current[3]<br/>                   = 9 - 3<br/>                   = 6<br/><br/>        current.pop_back()<br/>        current = [2, 2, 2]<br/><br/>        i++<br/>        i = 2<br/><br/>        i = 2<br/>        i &lt;= 4 - 1<br/>        2 &lt;= 3<br/>        true<br/><br/>        current.push_back(candidates[i])<br/>        current.push_back(candidates[2])<br/>        current.push_back(6)<br/>        current = [2, 2, 2, 6]<br/><br/>        sumTillNow += candidates[i]<br/>                    = 6 + candidates[2]<br/>                    = 6 + 6<br/>                    = 12<br/><br/>        combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>        combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 12, [2, 2, 2, 6])<br/><br/>Step 11: if sumTillNow == target<br/>           12 == 7<br/>           false<br/><br/>         if sumTillNow &gt; target<br/>           12 &gt; 7<br/>           true<br/>           return<br/><br/>           we backtrack to step 10 and continue<br/><br/>Step 12:combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 9, [2, 2, 2, 3])<br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>                   = 12 - current[4 - 1]<br/>                   = 12 - current[3]<br/>                   = 12 - 6<br/>                   = 6<br/><br/>        current.pop_back()<br/>        current = [2, 2, 2]<br/><br/>        i++<br/>        i = 3<br/><br/>        i = 3<br/>        i &lt;= 4 - 1<br/>        3 &lt;= 3<br/>        true<br/><br/>        current.push_back(candidates[i])<br/>        current.push_back(candidates[3])<br/>        current.push_back(7)<br/>        current = [2, 2, 2, 7]<br/><br/>        sumTillNow += candidates[i]<br/>                    = 6 + candidates[3]<br/>                    = 6 + 7<br/>                    = 13<br/><br/>        combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>        combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 13, [2, 2, 2, 7])<br/><br/>Step 13: if sumTillNow == target<br/>           13 == 7<br/>           false<br/><br/>         if sumTillNow &gt; target<br/>           13 &gt; 7<br/>           true<br/>           return<br/><br/>           we backtrack to step 12 and continue<br/><br/>Step 14:combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 9, [2, 2, 2, 3])<br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>                   = 13 - current[4 - 1]<br/>                   = 13 - current[3]<br/>                   = 13 - 7<br/>                   = 6<br/><br/>        current.pop_back()<br/>        current = [2, 2, 2]<br/><br/>        i++<br/>        i = 4<br/><br/>        i = 3<br/>        i &lt;= 4 - 1<br/>        4 &lt;= 3<br/>        false<br/><br/>        We return to Step 5 directly<br/><br/>Step 15:combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 6, [2, 2, 2])<br/>        sumTillNow = sumTillNow - current[len(current) - 1]<br/>                   = 6 - current[3 - 1]<br/>                   = 6 - current[2]<br/>                   = 6 - 2<br/>                   = 4<br/><br/>        current.pop_back()<br/>        current = [2, 2]<br/><br/>        i++<br/>        i = 1<br/><br/>        i = 1<br/>        i &lt;= 4 - 1<br/>        1 &lt;= 3<br/>        true<br/><br/>        current.push_back(candidates[i])<br/>        current.push_back(candidates[1])<br/>        current.push_back(3)<br/>        current = [2, 2, 3]<br/><br/>        sumTillNow += candidates[i]<br/>                    = 4 + candidates[1]<br/>                    = 4 + 3<br/>                    = 7<br/><br/>        combinationSumUtil(result, candidates, i, target, sumTillNow, current)<br/>        combinationSumUtil([][], [2, 3, 6, 7], 0, 7, 7, [2, 2, 3])<br/><br/>Step 16:if sumTillNow == target<br/>           7 == 7<br/>           true<br/><br/>           result.push_back(current)<br/>           result.push_back([2, 2, 3])<br/><br/>           result = [[2, 2, 3]]<br/><br/>Similarly, we iterate over all other elements and get the result as<br/>[[2, 2, 3], [7]]</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="7ad8" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><em class="lg">原载于</em><a class="ae ng" href="https://alkeshghorpade.me/post/leetcode-combination-sum" rel="noopener ugc nofollow" target="_blank"><em class="lg">https://alkeshghorpade . me</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>