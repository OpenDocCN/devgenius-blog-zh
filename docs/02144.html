<html>
<head>
<title>Singleton Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 C++中的单例设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singleton-design-pattern-in-modern-c-faa90630fe30?source=collection_archive---------21-----------------------#2020-07-20">https://blog.devgenius.io/singleton-design-pattern-in-modern-c-faa90630fe30?source=collection_archive---------21-----------------------#2020-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ccb4197aebac2290ec77a1ad29a1cebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4fOx0rIZjDaw0nqlc1rrA.png"/></div></div></figure><p id="fcec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在软件工程中，创造性的设计模式处理对象创建机制，也就是说，试图以适合情况的方式创建对象。对象创建的基本或普通形式会导致设计问题或增加设计的复杂性。在这篇关于创造性设计模式的文章中，我们将看看在编程面试中最讨厌的&amp;最常被问到的设计模式。这是现代 C++中的单一设计模式，批评它的可扩展性和可测试性。我还将介绍与 Singleton 完全相反的 Multiton 设计模式。</p><blockquote class="kt ku kv"><p id="9a51" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><em class="in"> /！\:这篇文章最初发表在我的博客上。如果你有兴趣接收我的最新文章，</em> <a class="ae la" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="in">请报名参加我的简讯</em> </a> <em class="in">。</em></p></blockquote><p id="7629" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一句，如果你还没有看过我关于创造性设计模式的其他文章，那么下面是列表:</p><ol class=""><li id="6751" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/factory-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">工厂</strong> </a></li><li id="5975" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/builder-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">建造者</strong> </a></li><li id="b398" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/prototype-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">原型</strong> </a></li><li id="16f9" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/singleton-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">单胎</strong> </a></li></ol><p id="18e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe lp lq lr ls b">override</code>、<code class="fe lp lq lr ls b">final</code>、<code class="fe lp lq lr ls b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;(大部分时间)在单一标准屏幕尺寸下可消耗。我也更喜欢<code class="fe lp lq lr ls b">struct</code>而不是<code class="fe lp lq lr ls b">class</code>，只是为了节省代码行，有时不写<code class="fe lp lq lr ls b">public:</code>，也故意忽略<a class="ae la" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae la" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe lp lq lr ls b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="8e17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kw">注:</em> </strong></p><ul class=""><li id="6f53" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae la" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="cbbe" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您在本系列文章中遇到的所有这些代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 之前的<a class="ae la" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代 C++ </a>特性)。因此，如果你没有获得最新的编译器，你可以使用<a class="ae la" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>，它也已经预装了 boost 库。</li></ul><h1 id="19c3" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">目的</h1><blockquote class="kt ku kv"><p id="1886" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">创建一个&amp;在任何时间点一个类只有一个实例。</strong></p></blockquote><ul class=""><li id="6940" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">Singleton 设计模式确保一个类只有一个实例，并提供对该实例的全局访问点。当只有一个对象需要协调整个系统的动作时，这很有用。</li><li id="35c2" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">因此，从本质上讲，单例设计模式只不过是指定一个生命周期。</li></ul><h1 id="08f1" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">C++中的单例设计模式示例</h1><ul class=""><li id="296a" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">所以使用单例设计模式的动机是相当明显的。我们系统中的一些组件只需要有一个实例。例如，一个从构造函数加载到内存中的数据库&amp;然后给出关于其内容的信息。一旦它被加载，你真的不想要一个以上的实例，因为没有意义。</li><li id="4d1b" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您还想防止您的客户/API 用户制作那个<a class="ae la" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">对象</a>的任何额外副本。下面是 C++中单例设计模式的一个简单例子。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="db98" class="nf lv in ls b gy ng nh l ni nj">/* country.txt <br/>Japan<br/>1000000<br/>India<br/>2000000<br/>America<br/>123500<br/>*/<br/>class SingletonDatabase {<br/>    std::map&lt;std::string, int32_t&gt;  m_country;</span><span id="0a41" class="nf lv in ls b gy nk nh l ni nj">    SingletonDatabase() {<br/>        std::ifstream ifs("country.txt");</span><span id="07df" class="nf lv in ls b gy nk nh l ni nj">        std::string city, population;<br/>        while (getline(ifs, city)) {<br/>            getline(ifs, population);<br/>            m_country[city] = stoi(population);<br/>        }<br/>    }</span><span id="7678" class="nf lv in ls b gy nk nh l ni nj">public:<br/>    SingletonDatabase(SingletonDatabase const &amp;) = delete;<br/>    SingletonDatabase &amp;operator=(SingletonDatabase const &amp;) = delete;</span><span id="1644" class="nf lv in ls b gy nk nh l ni nj">    static SingletonDatabase &amp;get() {<br/>        static SingletonDatabase db;<br/>        return db;<br/>    }</span><span id="e971" class="nf lv in ls b gy nk nh l ni nj">    int32_t get_population(const std::string &amp;name) { return m_country[name]; }<br/>};</span><span id="386b" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    SingletonDatabase::get().get_population("Japan");<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="6ab2" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">从设计的角度来看，这里需要注意以下几点:</li><li id="3de1" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">私有构造函数</li><li id="40ee" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">删除了<a class="ae la" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a> &amp; <a class="ae la" href="http://www.vishalchovatiya.com/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制赋值运算符</a></li><li id="dbae" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">静态对象创建和静态访问方法</li></ul><h1 id="14b2" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">单例的可测性问题</h1><ul class=""><li id="3d1d" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">我们有了单例数据库，假设我们决定使用这个数据库来做一些研究，我们实际上创建了一个名为<code class="fe lp lq lr ls b">SingletonRecordFinder</code>的新类，它将从参数中提供的城市名称集合中找到总人口，如下所示。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="ec52" class="nf lv in ls b gy ng nh l ni nj">struct SingletonRecordFinder {<br/>    static int32_t total_population(const vector&lt;string&gt;&amp;   countries) {<br/>        int32_t result = 0;<br/>        for (auto &amp;country : countries)<br/>            result += SingletonDatabase::get().get_population(country);<br/>        return result;<br/>    }<br/>};</span></pre><ul class=""><li id="06fb" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">但是让我们假设我们决定要测试<code class="fe lp lq lr ls b">SingletonRecordFinder</code>，这是所有问题出现的地方。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="dfb6" class="nf lv in ls b gy ng nh l ni nj">vector&lt;string&gt; countries= {"Japan", "India"}; // Strongly tied to data base entries<br/>TEST(1000000 + 2000000, SingletonRecordFinder::total_population(countries));</span></pre><ul class=""><li id="cf38" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">不幸的是，因为我们与真实的数据库紧密相连，没有办法替代这个数据库。我必须使用来自实际文件的值。当稍后这些条目改变时，您的测试将开始失败，因为您可能没有更新代码。这将是一个持续的问题。</li><li id="812f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">此外，这不是一个单元测试，而是一个集成测试，因为我们不仅要测试我们的代码，还要测试一个不是好设计的生产数据库。</li><li id="9646" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">当然有一个更好的方法来实现这个特殊的构造，这样我们仍然可以使用单例，但是如果需要的话，我们可以用一些我们自己的虚拟数据来提供单例实现的替代方案。</li></ul><h1 id="60c8" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">依赖注入的单例设计模式</h1><ul class=""><li id="4098" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">我们在测试<code class="fe lp lq lr ls b">SingletonRecordFinder</code>时遇到的问题是，我们本质上依赖于数据库如何提供数据的细节，因为我们直接依赖于单例数据库，事实上它是单例的。</li><li id="523c" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">所以我们为什么不在接口或抽象类上使用一点点<a class="ae la" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>！</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="5aa0" class="nf lv in ls b gy ng nh l ni nj">struct Database { // Dependency <br/>    virtual int32_t get_population(const string&amp; country) = 0;<br/>};</span><span id="026a" class="nf lv in ls b gy nk nh l ni nj">class SingletonDatabase : Database {<br/>    map&lt;string, int32_t&gt;    m_countries;</span><span id="6b6a" class="nf lv in ls b gy nk nh l ni nj">    SingletonDatabase() {<br/>        ifstream ifs("countries.txt");</span><span id="694c" class="nf lv in ls b gy nk nh l ni nj">        string city, population;<br/>        while (getline(ifs, city)) {<br/>            getline(ifs, population);<br/>            m_countries[city] = stoi(population);<br/>        }<br/>    }</span><span id="b1ff" class="nf lv in ls b gy nk nh l ni nj">public:<br/>    SingletonDatabase(SingletonDatabase const &amp;) = delete;<br/>    SingletonDatabase &amp;operator=(SingletonDatabase const &amp;) = delete;</span><span id="9c2a" class="nf lv in ls b gy nk nh l ni nj">    static SingletonDatabase &amp;get() {<br/>        static SingletonDatabase db;<br/>        return db;<br/>    }</span><span id="7f1b" class="nf lv in ls b gy nk nh l ni nj">    int32_t get_population(const string &amp;country) { return m_countries[country]; }<br/>};</span><span id="2ec9" class="nf lv in ls b gy nk nh l ni nj">class DummyDatabase : public Database {<br/>    map&lt;string, int32_t&gt;    m_countries;<br/>public:<br/>    DummyDatabase() : m_countries{{"alpha", 1}, {"beta", 2}, {"gamma", 3}} {}<br/>    int32_t get_population(const string &amp;country) { return m_countries[country]; }<br/>};</span><span id="2f33" class="nf lv in ls b gy nk nh l ni nj">/* Testing class ------------------------------------------------------------ */<br/>class ConfigurableRecordFinder {<br/>    Database&amp;       m_db;  // Dependency Injection<br/>public:<br/>    ConfigurableRecordFinder(Database &amp;db) : m_db{db} {}<br/>    int32_t total_population(const vector&lt;string&gt; &amp;countries) {<br/>        int32_t result = 0;<br/>        for (auto &amp;country : countries)<br/>            result += m_db.get_population(country);<br/>        return result;<br/>    }<br/>};<br/>/* ------------------------------------------------------------------------- */</span><span id="8116" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    DummyDatabase db;<br/>    ConfigurableRecordFinder rf(db);<br/>    rf.total_population({"Japan", "India", "America"});<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="5a1c" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">由于依赖注入即<code class="fe lp lq lr ls b">Database</code>接口，我们的以下两个问题都得到了解决:</li></ul><ol class=""><li id="f82e" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">我们已经完成了适当的单元测试，而不是集成测试，</li><li id="48d2" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">现在我们的测试类并没有直接绑定到 Singleton。所以没有必要根据数据库的变化一遍又一遍地改变我们的单元测试。</li></ol><h1 id="fbac" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">多音设计模式</h1><ul class=""><li id="4809" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">Multiton 是 singleton 的变体，但与它没有直接联系。请记住，singleton 阻止您拥有额外的实例，而 Multiton 设计模式设置了某种键-值对，并限制了实例创建的数量。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="7895" class="nf lv in ls b gy ng nh l ni nj">enum class Importance { PRIMARY, SECONDARY, TERTIARY };</span><span id="cb5f" class="nf lv in ls b gy nk nh l ni nj">template &lt;typename T, typename Key = std::string&gt;<br/>struct Multiton {<br/>    static shared_ptr&lt;T&gt; get(const Key &amp;key) {<br/>        if (const auto it = m_instances.find(key); it != m_instances.end()) { // C++17<br/>            return it-&gt;second; <br/>        }<br/>        return m_instances[key] = make_shared&lt;T&gt;();<br/>    }</span><span id="3074" class="nf lv in ls b gy nk nh l ni nj">private:<br/>    static map&lt;Key, shared_ptr&lt;T&gt;&gt;  m_instances;<br/>};</span><span id="979b" class="nf lv in ls b gy nk nh l ni nj">template &lt;typename T, typename Key&gt;<br/>map&lt;Key, shared_ptr&lt;T&gt;&gt;     Multiton&lt;T, Key&gt;::m_instances; // Just initialization of static data member<br/></span><span id="d376" class="nf lv in ls b gy nk nh l ni nj">struct Printer {<br/>    Printer() { cout &lt;&lt; "Total instances so far = " &lt;&lt; ++InstCnt &lt;&lt; endl; }</span><span id="205f" class="nf lv in ls b gy nk nh l ni nj">private:<br/>    static int InstCnt;<br/>};<br/>int Printer::InstCnt = 0;<br/></span><span id="6b46" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    using mt = Multiton&lt;Printer, Importance&gt;;</span><span id="5207" class="nf lv in ls b gy nk nh l ni nj">    auto main = mt::get(Importance::PRIMARY);<br/>    auto aux = mt::get(Importance::SECONDARY);<br/>    auto aux2 = mt::get(Importance::SECONDARY); // Will not create additional instances<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="f44f" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如您所见，我们有三台打印机，即主打印机、二级打印机和三级打印机，它们的访问和实例化由<code class="fe lp lq lr ls b">Multiton</code>控制。我希望代码的其余部分是不言自明的。</li></ul><h1 id="ae6d" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">单体设计模式的好处</h1><ol class=""><li id="9ce6" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lg lh li lj bi translated">单例设计模式对于应用程序配置非常有帮助，因为配置可能需要全局访问，并且应用程序配置的未来扩展可以整合在一个位置。</li><li id="ab42" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">该类的第二个常见用途是更新旧代码以在新架构中工作。由于开发人员可能已经自由地使用了全局变量，将它们转移到一个类中并使其成为单例，可以作为将程序内联到更强的面向对象结构的中间步骤。</li><li id="1ef0" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">单体设计模式还增强了可维护性，因为它提供了对特定实例的单点访问。</li></ol><h1 id="ebd0" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见问题汇总</h1><p id="0974" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated"><strong class="jx io">单例设计模式有什么不好？</strong></p><ul class=""><li id="c62f" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">Singleton 对象在应用程序的生存期内保存状态。这对测试是不利的，因为你可能最终会遇到测试需要排序的情况，这对于单元测试来说是一个大禁忌。为什么？因为每个单元测试都应该相互独立。</li><li id="2f1d" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">单例对象导致代码紧密耦合。这使得猜测测试场景下的预期结果变得相当困难，正如我们在上面的数据库示例中看到的那样。但是你可以通过使用依赖注入和单例设计模式来克服它。</li><li id="1dd4" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">想象一下这样一种情况，有一个并发应用程序从应用程序的每个部分访问 Singleton 对象，如果使用互斥体或任何其他同步原语，它只是混合了一些东西或减慢了它的速度。</li></ul><p id="172d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">实现单体设计模式的正确方法是什么？</strong></p><p id="c803" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现 singleton 的正确方法是依赖注入，所以不要直接依赖于 Singleton，你可以考虑依赖于一个抽象(比如一个接口)。我也鼓励你使用同步原语(比如互斥、信号量等)来控制访问。</p><p id="6cda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么时候应该使用单例设计模式？</strong></p><ul class=""><li id="ace1" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">通常，Singleton 用于硬件接口使用限制。例如，打印机的数量是有限的，所以在这种情况下，使用 singleton 或 multiton 设计模式来管理访问。</li><li id="8ee7" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">单例设计模式也广泛应用于管理配置或属性文件以管理访问。</li><li id="1f9c" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">我们可以将缓存用作单例对象，因为它可以有一个全局引用点，并且对于所有将来对缓存对象的调用，客户端应用程序将使用内存中的<a class="ae la" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">对象</a>。</li></ul><p id="0afb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议、疑问或者想说</a> <code class="fe lp lq lr ls b"><a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>