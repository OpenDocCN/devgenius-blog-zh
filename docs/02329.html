<html>
<head>
<title>Concurrency in Go — Using Goroutines and WaitGroups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的并发性—使用 Goroutines 和 WaitGroups</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrency-in-go-using-goroutines-and-waitgroups-26f5a6a9109e?source=collection_archive---------2-----------------------#2020-07-29">https://blog.devgenius.io/concurrency-in-go-using-goroutines-and-waitgroups-26f5a6a9109e?source=collection_archive---------2-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1755d15e01b3133c765290a2b5d5dd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XA2FgXsvoi0lOibEfI-m6w.jpeg"/></div></div></figure><p id="cac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我每周系列<em class="kw">学习围棋</em>的第十一篇。上周我谈到了在围棋中<a class="ae kx" href="https://www.martincartledge.io/sorting-data-in-go/" rel="noopener ugc nofollow" target="_blank">排序数据。本周我将讨论 Go 中的并发性是如何工作的。在我真正深入到并发这个主题之前，我觉得我需要区分一下并发和并行，因为它们经常被混淆。我还将解释一些允许我们使用并发性的 Go 语言。这些部分是 Go 例程和 Go 语句。</a></p><h1 id="47cd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">并发</h1><blockquote class="lw lx ly"><p id="8882" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">一个程序的各个部分不按顺序或按部分顺序运行(执行)而不影响最终结果的能力</p></blockquote><ul class=""><li id="7456" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">设计用于同时处理多个任务</li><li id="def2" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">能够同时在多项任务上取得进展，但不能同时进行<em class="kw">和</em></li><li id="9591" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">可以和 1 核 CPU 一起工作；但是，系统决定何时开始每项任务</li><li id="ac76" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">跨共享变量正确实现所需的微妙之处使得并发变得困难</li></ul><h1 id="767b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">平行</h1><blockquote class="lw lx ly"><p id="c611" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">同时执行多项计算的能力</p></blockquote><ul class=""><li id="b62e" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">旨在同时完成多项任务</li><li id="e885" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">能够在多核 CPU 中执行多项任务</li><li id="94b0" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">必须拥有多核 CPU</li></ul><h1 id="156b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Go 中的并发性</h1><ul class=""><li id="d34e" class="mc md iq ka b kb mq kf mr kj ms kn mt kr mu kv mh mi mj mk bi translated">共享值在<a class="ae kx" href="https://gobyexample.com/channels" rel="noopener ugc nofollow" target="_blank">通道</a>上传递</li><li id="e731" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">从不在单独的执行线程上共享</li><li id="8bbf" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">不是通过共享内存来交流，而是通过交流来共享内存</li></ul><h1 id="1460" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">围棋套路</h1><ul class=""><li id="9610" class="mc md iq ka b kb mq kf mr kj ms kn mt kr mu kv mh mi mj mk bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Multiplexing" rel="noopener ugc nofollow" target="_blank">多路复用</a></li><li id="ed9e" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">与函数或方法一起使用</li><li id="2f62" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">与<code class="fe mv mw mx my b">go</code>关键字一起使用</li></ul><h1 id="74c6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Go 语句</h1><ul class=""><li id="c938" class="mc md iq ka b kb mq kf mr kj ms kn mt kr mu kv mh mi mj mk bi translated">在同一个地址空间内，作为控制或 Go 例程的独立并发线程，从函数调用的执行开始</li><li id="311f" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">必须是函数或方法调用</li><li id="8562" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">如果函数有返回值，那么当函数完成时，返回值将被丢弃</li></ul><p id="6ef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始讨论如何在 Go 中使用<em class="kw">并发</em>之前，我想我们应该讨论一下在 Go 中编写<em class="kw">并发</em>代码的几个要点。其中几个支柱是<em class="kw"> Goroutines </em>和<em class="kw">频道</em></p><h1 id="33b1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">戈鲁廷斯</h1><blockquote class="lw lx ly"><p id="2e93" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="iq">一个轻量级的执行线程</em></p></blockquote><p id="d7c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，什么是 Goroutine？我为什么要关心它们？以下是一些需要考虑的事项:</p><ul class=""><li id="514c" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">Goroutines 是非阻塞的(<em class="kw">异步</em>)</li><li id="6b43" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">由于是异步的，多个 goroutines 可以并发运行<em class="kw"/>(多个片段同时运行，不会影响最终结果)</li><li id="8e4b" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">如果你想等你的<em class="kw"> Goroutine </em>完成后再继续，你可以使用一个<em class="kw"> WaitGroup </em>(我们将在后面的文章中介绍)</li></ul><p id="3177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个使用传统函数(阻塞)和一些<em class="kw"> Goroutines </em>(非阻塞)的例子，以更好地说明它们在我们的 Go 代码中的位置</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="33c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下正在发生的事情:</p><blockquote class="lw lx ly"><p id="c963" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="iq">快速提示:我们正在导入</em> <code class="fe mv mw mx my b"><em class="iq">time</em></code> <em class="iq">包，因为我们需要等待一秒钟，以便让我们的</em> Goroutines <em class="iq">完成。记住，他们不是阻塞(同步)；因此，我们需要</em>等待<em class="iq">他们完成计算。</em></p></blockquote><p id="471b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们导入将在本例中使用的<code class="fe mv mw mx my b">time</code>包，只是为了等待我们的<em class="kw"> Goroutines </em>完成。我发现使用等待组更加普遍，我们将在后面的文章中讨论这些</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1f9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建两个函数，<code class="fe mv mw mx my b">countToFive</code>和<code class="fe mv mw mx my b">countToThree</code>，这两个函数都需要一个类型为<code class="fe mv mw mx my b">string</code>的参数<code class="fe mv mw mx my b">wasCalledBy</code>。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="20bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<code class="fe mv mw mx my b">wasCalledBy</code>参数调用我们的<em class="kw"> Goroutine </em>将有助于说明 Go 如何执行这些<em class="kw">Go routine</em></p><p id="f3b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx my b">func</code> <code class="fe mv mw mx my b">main</code>内部，我直接调用<code class="fe mv mw mx my b">countToFive</code>函数，没有使用<em class="kw"> Goroutine </em></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如论点所说，我没有使用<code class="fe mv mw mx my b">go</code>关键字并创建一个<em class="kw">go routine</em>；因此，这段代码将是同步的，并阻塞我们的执行线程</p><p id="616d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一行，我创建了一个<em class="kw"> Goroutine </em>。通过调用同一个函数并将关键字<code class="fe mv mw mx my b">go</code>放在函数标识符的前面，我很容易做到这一点</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我通过将关键字<code class="fe mv mw mx my b">go</code>放在函数标识符前面来启动另一个<em class="kw"> Goroutine </em>。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="076a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保我们的<em class="kw"> Goroutines </em>完成，我们正在使用<code class="fe mv mw mx my b">time</code>包以便让<em class="kw">休眠</em>一秒钟。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2dee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您希望在我们的日志中看到什么？你希望这些<em class="kw"> Goroutines </em>以什么顺序运行？</p><p id="94eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出可能会让你吃惊，但是，我希望它能阐明<em class="kw"> Goroutines </em>能给你的一些力量。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c231" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前 5 行不应该让你感到惊讶，我们正在调用一个没有使用<em class="kw"> Goroutine </em>的函数；因此，它以同步(阻塞)方式运行。</p><p id="36fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，接下来的几行应该会引起一些人的注意。您是否注意到我们的<code class="fe mv mw mx my b">countToThree</code>函数在<code class="fe mv mw mx my b">countToFive</code>之前记录了一个项目？</p><p id="516a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是 T21 的力量。Go 运行时允许我们编写能够以并发方式执行的代码。</p><h1 id="6eed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">等待组</h1><p id="8b27" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">使用 Go 时，使用<em class="kw"> WaitGroups </em>等待多个<em class="kw"> Goroutines </em>结束是常见的做法。<em class="kw"> WaitGroup </em>是<em class="kw">型</em>，是<code class="fe mv mw mx my b">sync</code>包的一部分。</p><p id="ab3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> WaitGroups </em>附带了一些您会经常使用的功能。其中最重要的是<code class="fe mv mw mx my b">Add</code>和<code class="fe mv mw mx my b">Done</code>。让我来告诉你如何使用这些。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c672" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一行一行地回顾一下正在发生的事情:</p><p id="a617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我前面提到的，由于<em class="kw"> WaitGroup </em>是从<code class="fe mv mw mx my b">sync</code>包中调用的，我们需要确保导入它</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们用标识符<code class="fe mv mw mx my b">countRoutine</code>创建一个函数，它有两个参数:<code class="fe mv mw mx my b">string</code>类型的<code class="fe mv mw mx my b">upTo</code>和指向<code class="fe mv mw mx my b">sync.WaitGroup</code>的指针<code class="fe mv mw mx my b">wg</code></p><blockquote class="lw lx ly"><p id="a067" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="iq">注意:</em> WaitGroups <em class="iq">只能作为指针</em>传递给函数</p></blockquote><p id="3d8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数内部，我们创建了一个 for 循环，并进行迭代，直到达到传递给函数的<code class="fe mv mw mx my b">upTo</code>值。为了让<em class="kw">等待组</em>知道<em class="kw"> Goroutine </em>已经完成，我们运行<code class="fe mv mw mx my b">Done()</code>函数</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="413c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们创建一个标识符为<code class="fe mv mw mx my b">count</code>的函数，带有一个类型为<code class="fe mv mw mx my b">int</code>的参数<code class="fe mv mw mx my b">upTo</code>。我们在这个函数中有相同的 for 循环，唯一的区别是我们没有使用<em class="kw"> WaitGroup </em>，因为这是<em class="kw">而不是</em>一个<em class="kw"> Goroutine </em></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="830e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx my b">main</code>函数内部，我们使用<code class="fe mv mw mx my b">var</code>关键字创建一个变量，并给这个变量赋予类型<code class="fe mv mw mx my b">sync.WaitGroup</code>的标识符<code class="fe mv mw mx my b">wg</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了告诉 Go 运行时关于我们的<em class="kw"> WaitGroup </em>我们必须添加一个。我们可以通过使用<code class="fe mv mw mx my b">Add()</code>函数轻松做到这一点，该函数接受一个类型为<code class="fe mv mw mx my b">int</code>的参数，该参数表示您想要添加多少个<em class="kw">等待组</em>。对于这个例子，我们只有一个<em class="kw"> Goroutine </em>，所以我们将只添加一个:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用<code class="fe mv mw mx my b">go</code>关键字来启动<code class="fe mv mw mx my b">countRoutine</code>作为<em class="kw"> Goroutine </em>，并传递<code class="fe mv mw mx my b">10</code>作为我们的<code class="fe mv mw mx my b">upTo</code>参数，传递<em class="kw"> WaitGroup </em>指针(<code class="fe mv mw mx my b">&amp;wg</code>作为我们的<code class="fe mv mw mx my b">wg</code>参数</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0d6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用<code class="fe mv mw mx my b">count</code>函数，它将是一个同步的阻塞函数</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能是需要记住的最重要的部分之一。正如你看到的，我们在<code class="fe mv mw mx my b">main</code>的最后一行调用了一个<code class="fe mv mw mx my b">Wait()</code>函数。这个函数让 Go 运行时知道我们还有<em class="kw"> Goroutines </em>没有完成，并让我们的程序继续运行。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我前面提到的，我们让 Go 运行时知道我们的<em class="kw"> Goroutine </em>已经完成的方法是在我们的<em class="kw"> Goroutine </em>的末尾调用<code class="fe mv mw mx my b">Done()</code>函数。一旦我们这样做了，Go 运行时知道它可以退出程序。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="a7fd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概括起来</h1><p id="ac4f" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">通过使用<em class="kw"> Goroutines </em>的能力，配合<em class="kw"> WaitGroups </em>的帮助，我们可以在 Go 中编写<em class="kw">并发</em>代码。很酷吧。我把这个话题分成了两部分，因为我还有很多关于编写并发 Go 代码和 Go 提供给我们使用的工具的内容要向你展示。下周我将谈论<em class="kw">通道、互斥和竞争条件</em>。到时候见！</p></div></div>    
</body>
</html>