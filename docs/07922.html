<html>
<head>
<title>HTML5 RSS Reader: writing the first web components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML5 RSS 阅读器:编写第一个 web 组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/html5-rss-reader-writing-the-first-web-components-949eec88dbf9?source=collection_archive---------11-----------------------#2022-05-03">https://blog.devgenius.io/html5-rss-reader-writing-the-first-web-components-949eec88dbf9?source=collection_archive---------11-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e77c83e09506b678db50f2f9c3bf4cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7245hPAT8Tp4cHbe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">丹-克里斯蒂安·pădureț在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">开始编写</a>一个简单的 RSS 阅读器应用程序，在后端使用 Rust，在前端只使用现代的 Javascript 和 CSS。当然，这个练习只是回顾了现代浏览器支持的最新功能，并暗示了未来我们不一定需要 Webpack、缩小、捆绑和 UI 框架。</p><p id="ad28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们探讨了<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f"/>一种仅在需要时导入 CSS 的方法。这次我们将使用本地 Javascript 模块对 Javascript 做同样的事情。既然我们的响应式模拟用户界面已经准备好了，我们也知道我们想要什么样子，让我们开始构建我们的第一个 HTML5 web 组件:<code class="fe lb lc ld le b">CustomList</code>。</p><h2 id="9a72" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">规划 HTML5 web 组件</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/c792ad23a7747e8995a203f58b49d981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ReAjy8Q_EgV2TQRi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@jacksonsophat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克逊·苏</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像 React 一样，HTML5 web 组件是类。就像老年人的反应一样。然而，HTML5 web 组件的第一个好处是直接继承了原生 HTML 类。例如，我们的<code class="fe lb lc ld le b">CustomList</code>类将扩展<code class="fe lb lc ld le b">HTMLUListElement</code>。这将是一个无序列表，所以它将使用普通的<code class="fe lb lc ld le b">&lt;ul&gt;</code>标签。然而，为了说明它不仅仅是一个<code class="fe lb lc ld le b">&lt;ul&gt;</code>，我们将像这样添加<code class="fe lb lc ld le b">is</code>属性:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="1eba" class="lf lg iq le b gy mh mi l mj mk">&lt;ul is="custom-list"&gt;</span></pre><p id="22c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以编写<code class="fe lb lc ld le b">&lt;custom-list&gt;</code>并且它会工作，但是如果你想通过编程克隆或创建一个<code class="fe lb lc ld le b">CustomList</code>，这个类将不会被实例化，构造函数也不会被调用(至少在 Firefox 中)。您将获得一个具有所有已定义属性和方法的<code class="fe lb lc ld le b">CustomList</code>对象，但是您必须自己初始化它。但是，如果您以编程方式创建<code class="fe lb lc ld le b">&lt;ul&gt;</code>并将<code class="fe lb lc ld le b">CustomList</code>指定为<code class="fe lb lc ld le b">is</code>属性，它将会工作。此外，所有 HTML5 官方示例都使用了<code class="fe lb lc ld le b">is</code>语法，所以这可能是开发人员打算如何使用 web 组件。</p><p id="7b6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表中当然会有项目，我们希望允许它有不同类型的项目。所以我们将有一个通用的<code class="fe lb lc ld le b">CustomListItem</code>类，可以扩展成<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>，每一个都有自己的特性。为此，我们需要为列表指定一个项目模板:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="e681" class="lf lg iq le b gy mh mi l mj mk">&lt;ul is="custom-list"&gt;<br/>  &lt;template&gt;&lt;li is="custom-list-item"&gt;&lt;/li&gt;&lt;/template&gt;<br/>&lt;/ul&gt;</span></pre><p id="b5bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表必须支持添加项目，当添加项目时，我们只需克隆模板内容并添加我们在那里指定的任何项目。让我们看看如何写这些。</p><h2 id="6e41" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">自定义列表</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/80b3a13fd62fd056490edd48a655f029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WHXAAm4qyZI81841"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">凯利·西克玛在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lb lc ld le b">CustomList</code>将有两个主要功能:添加项目和选择项目。我们将放置一个<code class="fe lb lc ld le b">value</code>属性来指示当前选择的内容，并将它添加到可观察属性列表中:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="802b" class="lf lg iq le b gy mh mi l mj mk">export class CustomList extends HTMLUListElement {<br/>  static get observedAttributes() {<br/>    return ['value'];<br/>  }</span><span id="4295" class="lf lg iq le b gy mm mi l mj mk">  get value() {<br/>    return this.getAttribute('value');<br/>  }<br/>  set value(newValue) {<br/>    this.setAttribute('value', newValue);<br/>  }</span><span id="47a4" class="lf lg iq le b gy mm mi l mj mk">  constructor() {<br/>    super();</span><span id="5ee1" class="lf lg iq le b gy mm mi l mj mk">    this.classList.add('custom-list');<br/>    this.addEventListener('click', (e) =&gt; {<br/>      const selection = e.target.closest('li.custom-list-item');<br/>      this.value = selection.dataset.item;<br/>    });<br/>  }</span><span id="a2c8" class="lf lg iq le b gy mm mi l mj mk">  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === "value") {<br/>      if (oldValue) {<br/>        const selection = this.querySelector(`li[data-item="${oldValue}"]`);<br/>        if (selection) selection.deselect();<br/>      }</span><span id="4bf8" class="lf lg iq le b gy mm mi l mj mk">      if (newValue) {<br/>        const selection = this.querySelector(`li[data-item="${newValue}"]`);<br/>        if (selection) selection.select();<br/>      }</span><span id="6bd8" class="lf lg iq le b gy mm mi l mj mk">      this.dispatchEvent(new Event("change"));<br/>    }<br/>  }<br/>}</span><span id="3215" class="lf lg iq le b gy mm mi l mj mk">customElements.define("custom-list", CustomList, { extends: "ul" });</span></pre><p id="f5ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静态的<code class="fe lb lc ld le b">observedAttributes</code> getter 检索被监视的属性的变化:在我们的例子中只有一个属性，即<code class="fe lb lc ld le b">CustomList</code>值。对于<code class="fe lb lc ld le b">value</code>属性，我们也有一个 getter 和一个 setter，它只是链接到<code class="fe lb lc ld le b">value</code> HTML 属性。在 HTML 语言中，这看起来像这样:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="4ef9" class="lf lg iq le b gy mh mi l mj mk">&lt;ul is="custom-list" value="The Verge"&gt;&lt;/ul&gt;</span></pre><p id="63b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是处理我们的<code class="fe lb lc ld le b">observedAttributes</code>变化的<code class="fe lb lc ld le b">attributeChangedCallback</code>。处理程序提供属性名、旧值和新值。这里我们用<code class="fe lb lc ld le b">oldValue</code>取消选择项目，并选择新的。</p><p id="98fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来是类构造函数。因为我们从<code class="fe lb lc ld le b">&lt;ul&gt;</code>继承，所以我们需要调用<code class="fe lb lc ld le b">super()</code>来确保基类被初始化。我们将一个 CSS 类添加到我们的 web 组件中，这样我们就可以使用 CSS 样式来识别它。不幸的是，您不能使用<code class="fe lb lc ld le b">:is(custom-list)</code>选择器来瞄准<code class="fe lb lc ld le b">CustomList</code>。你只能用它来选择像<code class="fe lb lc ld le b">:is(section)</code>或<code class="fe lb lc ld le b">:is(div)</code>这样的原生 HTML 标签。所以为了正确地定位一个<code class="fe lb lc ld le b">CustomList</code>，我们必须使用普通的 CSS 类。我们还为<code class="fe lb lc ld le b">click</code>添加了一个事件处理程序，它会将列表的<code class="fe lb lc ld le b">value</code>属性更改为选中的内容。</p><p id="975c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将我们的<code class="fe lb lc ld le b">CustomList</code>注册到<code class="fe lb lc ld le b">customElements</code>列表中，让每个人都知道我们新的 web 组件。注意我们的<code class="fe lb lc ld le b">CustomList</code>不做任何额外的 UI 相关的事情。它只是一个支持和处理项目选择的普通<code class="fe lb lc ld le b">&lt;ul&gt;</code>。</p><h2 id="5fe4" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">自定义列表项</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/a73a5cc8fe3bb5ca1399d4f11a29bbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hJqvOFqpj3lXhuEQtGk3w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">项目结构在左侧的类</figcaption></figure><p id="4d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们构建我们的<code class="fe lb lc ld le b">CustomListItem</code>类。这将延长<code class="fe lb lc ld le b">HTMLLIElement</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="3786" class="lf lg iq le b gy mh mi l mj mk">export class CustomListItem extends HTMLLIElement {<br/>  get data() {<br/>    return this.dataset;<br/>  }<br/>  get dataItem() {<br/>    return this.dataset.item;<br/>  }</span><span id="4f62" class="lf lg iq le b gy mm mi l mj mk">  set data(newValue) {<br/>    this.innerText = newValue;<br/>    this.dataset.item = newValue;<br/>  }</span><span id="0716" class="lf lg iq le b gy mm mi l mj mk">  constructor() {<br/>    super();<br/>    this.classList.add("custom-list-item");<br/>  }</span><span id="35d2" class="lf lg iq le b gy mm mi l mj mk">  select() {<br/>    this.classList.add("selected");<br/>  }<br/>  deselect() {<br/>    this.classList.remove("selected");<br/>  }<br/>  isSelected() {<br/>    return this.classList.contains("selected");<br/>  }<br/>}</span><span id="f1fe" class="lf lg iq le b gy mm mi l mj mk">customElements.define("custom-list-item", CustomListItem, { extends: "li" });</span></pre><p id="5dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表项也没有额外的 UI 来显示，只有便利类<code class="fe lb lc ld le b">custom-list-item</code>,所以我们可以用 CSS 更好地定位它。接下来，列表项只保存显示为<code class="fe lb lc ld le b">innerText</code>的数据。所以基本上当我们调用<code class="fe lb lc ld le b">listItem.data = “something”</code>时，得到的 UI 元素会是一个<code class="fe lb lc ld le b">&lt;li&gt;something&lt;/li&gt;</code>。</p><p id="c1c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还看到这些数据被放入了<code class="fe lb lc ld le b">li</code>数据集中。更重要的是，数据集应该有一个<code class="fe lb lc ld le b">item</code>属性，这是一种标识符，在本例中它就是数据。<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>将有一个标识符，用于识别所选择的提要或文章。</p><p id="9c3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们只有一些处理项目选择的行为，它只是将一个选择的类添加到<code class="fe lb lc ld le b">&lt;li&gt;</code>中。这对于所有项目都是一样的，选择逻辑也是一样的。</p><h2 id="c325" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">向自定义列表添加项目</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5e3efb1b4260dc1b3d03f9a2c7e2d24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jm0yySrlh6fyA_UrLMSk5w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">略微改进的自定义列表</figcaption></figure><p id="dbdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都差不多准备好了。我们有了<code class="fe lb lc ld le b">CustomList</code>和<code class="fe lb lc ld le b">CustomListItem</code>，但是我们需要一个在<code class="fe lb lc ld le b">CustomList</code>中加载项目的方法。让我们给我们的<code class="fe lb lc ld le b">custom-list.js</code>添加一些方法:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="d23c" class="lf lg iq le b gy mh mi l mj mk">export class CustomList extends HTMLUListElement {<br/>  ...<br/>  <br/>  setItems(items) {<br/>    this.clearItems();<br/>    if (items) <br/>      for (const element of items) this.addItem(element);<br/>  }<br/>  addItem(item) {<br/>    const template = this.querySelector("template");<br/>    const templateNode = template.content.firstElementChild;<br/>    const node = templateNode.cloneNode(true);</span><span id="b06b" class="lf lg iq le b gy mm mi l mj mk">    this.appendChild(node);<br/>    node.data = item;<br/>  }<br/>  clearItems() {<br/>    this.value = "";<br/>    for (const element of this.querySelectorAll("li.custom-list-item")) element.remove();<br/>  }</span><span id="f026" class="lf lg iq le b gy mm mi l mj mk">  ...<br/>}</span></pre><p id="13b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">setItems</code>方法只是接受一个项目数组(例如字符串),并为每个项目调用<code class="fe lb lc ld le b">addItem</code>。然后，<code class="fe lb lc ld le b">addItem</code>做我们最初说过的事情:它克隆模板内容并将该项添加到列表中。这样，不管模板包含什么，列表都是一样的:克隆和添加。列表完全不知道模板包含什么。</p><h2 id="8d0d" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">一点造型</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/a146c50f2a9d041b62f9b5562817f189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPivaz-0hhx4EtTxYdTgLA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CustomListItem 样式</figcaption></figure><p id="78bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们看上面的截图，我们可以在左边的树中看到项目结构，我们可以看到组件的模式:Javascript 文件中的组件定义，然后是 CSS 文件中的组件样式。那么让我们来看看<code class="fe lb lc ld le b">CustomList</code>的风格:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="eb88" class="lf lg iq le b gy mh mi l mj mk">ul.custom-list.alternate-odd li:nth-child(odd) {<br/>  background-color: #0001;<br/>}</span></pre><p id="856a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表的风格非常简单。我们只为带有额外的类<code class="fe lb lc ld le b">alternate-odd</code>的列表定义了一种样式，其中我们替换了奇数项的背景。没有<code class="fe lb lc ld le b">alternate-odd</code>类的<code class="fe lb lc ld le b">CustomList</code>没有任何额外的样式。让我们看看<code class="fe lb lc ld le b">CustomListItem</code>的风格:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="4fcc" class="lf lg iq le b gy mh mi l mj mk">li.custom-list-item {<br/>  cursor: pointer;<br/>  white-space: nowrap;<br/>  text-overflow: ellipsis;<br/>  overflow-x: clip;<br/>  margin-bottom: 0.6em;<br/>}</span><span id="639c" class="lf lg iq le b gy mm mi l mj mk">li.custom-list-item.selected {<br/>  text-shadow: var(--selection-shadow);<br/>}</span></pre><p id="76dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，没有什么特别的只是一些阴影应用于选定的项目。我们也不允许项目文本在多行上断开。</p><h2 id="da48" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">应用自定义元素</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5f8693231474d4368ca4e1e522dbe131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sl76Gjb4Il2QMZ19glT7MQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在 index.html 使用自定义列表</figcaption></figure><p id="8720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止还不错:我们有自己的定制 web 组件，现在我们只需在我们的<code class="fe lb lc ld le b">index.html</code>中替换它们:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="6932" class="lf lg iq le b gy mh mi l mj mk">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;RSS Reader&lt;/title&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><span id="148b" class="lf lg iq le b gy mm mi l mj mk">    &lt;link rel="stylesheet" href="index.css"&gt;<br/>    &lt;link rel="icon" href="favicon.svg"&gt;</span><span id="f155" class="lf lg iq le b gy mm mi l mj mk">    &lt;script type="module" src="index.js"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;nav&gt;<br/>      &lt;ul id="feeds" is="custom-list"&gt;&lt;/ul&gt;<br/>    &lt;/nav&gt;<br/>    &lt;main&gt;<br/>      &lt;ul id="articles" is="custom-list"&gt;&lt;/ul&gt;<br/>      &lt;a class="back" href="#"&gt;Back&lt;/a&gt;<br/>    &lt;/main&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1ee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们就此打住，我们的<code class="fe lb lc ld le b">CustomList</code>和<code class="fe lb lc ld le b">CustomListItem</code>将不会加载，因为它们没有被引用。我们还必须用数据填充列表。让我们在<code class="fe lb lc ld le b">index.js</code>中这样做:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="3331" class="lf lg iq le b gy mh mi l mj mk">import { CustomList } from "../shared/components/custom-list.js";<br/>import { CustomListItem } from "../shared/components/custom-list-item.js";</span><span id="5306" class="lf lg iq le b gy mm mi l mj mk">document<br/>  .getElementById("feeds")<br/>  .setItems(["The Verge", "Ars Technica", "Hacker News"]);</span><span id="ab54" class="lf lg iq le b gy mm mi l mj mk">document<br/>  .getElementById("articles")<br/>  .setItems(["Article1", "Article2", "Article3", "Article4"]);</span><span id="5f33" class="lf lg iq le b gy mm mi l mj mk">document.getElementById("feeds").addEventListener("click", (e) =&gt; {<br/>  document.body.classList.add("feed-selected");<br/>  <br/>  const selection = document.querySelector("#feeds li.selected");<br/>  if (selection) selection.classList.remove("selected");</span><span id="bd5f" class="lf lg iq le b gy mm mi l mj mk">  e.target.closest("li").classList.add("selected");<br/>});</span><span id="a923" class="lf lg iq le b gy mm mi l mj mk">document.getElementById("articles").addEventListener("click", (e) =&gt; {<br/>  const selection = document.querySelector("#articles li.selected");<br/>  <br/>  if (selection) selection.classList.remove("selected");<br/>  e.target.closest("li").classList.add("selected");<br/>});</span><span id="be91" class="lf lg iq le b gy mm mi l mj mk">document.querySelector(".back").addEventListener("click", () =&gt; {<br/>  document.body.classList.remove("feed-selected");<br/>});</span></pre><p id="f4f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lb lc ld le b">index.css</code>也要改变。我们之前在那里定义了<code class="fe lb lc ld le b">li</code>和<code class="fe lb lc ld le b">ul</code>样式，但是现在它们被移到了<code class="fe lb lc ld le b">custom-list.css</code>和<code class="fe lb lc ld le b">custom-list-item.css</code>中，所以让我们来清理一下:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="b627" class="lf lg iq le b gy mh mi l mj mk">@import url(/shared/styles/base.css);<br/>@import url(/shared/components/custom-list.css);<br/>@import url(/shared/components/custom-list-item.css);</span><span id="1875" class="lf lg iq le b gy mm mi l mj mk">a.back {<br/>  display: none;<br/>}</span><span id="8501" class="lf lg iq le b gy mm mi l mj mk">@media (max-width: 710px) {<br/>  main {<br/>    display: none;<br/>  }</span><span id="e056" class="lf lg iq le b gy mm mi l mj mk">  body.feed-selected nav {<br/>    display: none;<br/>  }<br/>  body.feed-selected main {<br/>    display: block;<br/>  }</span><span id="e00b" class="lf lg iq le b gy mm mi l mj mk">  a.back {<br/>    display: block;<br/>    padding-top: 2em;<br/>  }<br/>}</span></pre><p id="ef51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这一切是怎么回事:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/31a99e24bbc7ef708dfa18e63fcbd6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npcA9EHAslFjtnCd3Hjv1A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">改进的 RSS 阅读器应用程序，现在使用 web 组件</figcaption></figure><p id="4c63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变化不大。我们丢失了文章的<code class="fe lb lc ld le b">&lt;details&gt;</code>标签，但下次构建专用的<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code> web 组件时，我们会改变这一点。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="7766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚编写了我们的第一个 web 组件，我们还使用了本地 Javascript 模块导入，消除了对 web 编译器或模块框架的需要。当然，房间里有一只大象，我们没有使用的 web 组件的影子 DOM:我们将在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-shadow-dom-of-an-html5-web-component-d99af7844192">未来</a>谈论它。</p><p id="caef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-specialized-web-components-8c8a972e681a">下次</a>我们将创建两个专门的<code class="fe lb lc ld le b">CustomListItem</code>类，我们将进一步解释 Javascript 模块是如何工作的。代码一如既往地在<a class="ae kc" href="https://github.com/raduzaharia-medium/html5-rss-reader-web-components" rel="noopener ugc nofollow" target="_blank"> Github </a>上可用。下次见！</p></div></div>    
</body>
</html>