# Floyd-Warshall 全对最短路径矩阵乘法

> 原文：<https://blog.devgenius.io/floyd-warshall-all-pairs-shortest-path-matrix-multiplication-1ae24f3312e4?source=collection_archive---------5----------------------->

![](img/ccffa60eea22bcb52840ad6fffa8d104.png)

Floyd-Warshall 算法的目标是使用动态规划在一棵树中寻找最短路径。让我们从一个例子开始。

![](img/014c2ad91df3065d3b77801170148afe.png)

Floyd-Warshall 算法从收集初始权重并将其放入矩阵开始。由于有 4 个顶点，矩阵将有 4 行和 4 列。

![](img/6973d3757a3df4b91ba3b911dd548142.png)

从顶点 1 开始，该算法收集从 1 到其他 3 个顶点的初始权重。如果没有直接路径，它将为自己放置一个 0 和无穷大。从 1 到自身的边权重为 0。从 1 到 2 的边权重是 10。由于没有从 1 到 3 的直接路径，该算法将无穷大作为占位符。从 1 到 4 的边权重是 5。

![](img/9b7cc212feb1b824babf1fce3af83586.png)

第一行完成，接下来 Floyd-Warshall 算法将在顶点 2 上工作，这对应于第二行。从 2 到 1 没有直接的路径，所以放置无穷大。从 2 到自身的权重为 0。从 2 到 3 没有直接的路径，所以放置无穷大。最后，从 2 到 4 的边权重是 9。

![](img/aa005edc0c2d7759070775c88e1a1e03.png)

接下来，Floyd-Warshall 算法将在对应于第三行的顶点 3 上工作。从 3 到 1 的边权重是-2。从 3 到 2 的边权重是 4。从 3 到自身的边权重为 0。最后，从 3 到 4 的边权重是无穷大，因为从 3 到 4 没有直接路径。

![](img/cf210bd4c7164aa0ba97b40c92a24b1c.png)

最后一行对应于最后一个顶点，即顶点 4。应用类似的原理。从 4 到 1 的权重是无穷大，因为从 4 到 1 没有直接路径。从 4 到 2 的边权重是-3。从 4 到 3 的边权重是 1，从 4 到自身的权重是 0。

![](img/ca83c42b762cd2f64313cef03cdd0b7b.png)

现在，初始矩阵 D *0* 已经创建，Floyd-Warshall 算法将生成矩阵 D *1* 到 D *4* 。虽然详尽无遗，我的目标是为您提供这个过程的每一步。为了生成 D *1* ，算法将使用 D *0* 并查看是否有从 2 到 3 的更短方法，例如，从 2 到 1，然后从 1 到 3。由于算法正在构建 D *1* ，第一行和第一列被锁定，无法修改。观察对角线，它们都是 0，所以对角线不会改变，因为在所提供的图中不存在自循环。开始之前，D *1* 看起来会像下面的矩阵。

![](img/0b9162926813585ceb04c44ef270d075.png)

矩阵中的空白字段是 Floyd-Warshall 算法将关注的字段。

为了获得 D *1* 第 2 行第 3 列的值，执行以下操作:

*   (2，3)的值从 D *0* 中检索
*   将值 D *0* (2，3)与值 D *0* (2，1) + D *0* (1，3)的总和进行比较。**顶点 1 是这个图的中间顶点**，这意味着你将总是通过 1 来生成 D1。

![](img/6b9cc4bd020bb8df22fedbd2bd8f5f3a.png)

*   D *0* (2，3) = D *0* (2，1) + D *0* (1，3): ∞ = ∞ + ∞
*   无穷保持在 D *1* (2，3)的位置

接下来，算法将集中于 D *1* (2，4)

![](img/572f4eabca5db71603912f64ef4b5683.png)

由于 D *0* (2，4)小于 D *0* (2，1) + D *0* (1，4)，所以将 9 的值放入 D *0* (2，4)。

![](img/3558245da968b4435cb818bafb8b817c.png)

接下来，算法将关注 D *1* (3，2)。

![](img/2a61e33fbcdfd827f8998433be6e9348.png)

由于 D *0* (3，2)小于 D *0* (3，1) + D *0* (1，2)，所以为 D *1* (3，2)保留 4。

![](img/68b653ea57613611b54e83a058d51041.png)

接下来，算法重点是 D *1* (3，4)。

![](img/4075dfe3a8c41d8ee7a425fcf9e58519.png)

由于 D *0* (3，4) > D *0* (3，1) + D *0* (1，4)，字段 D *1* (3，4)更新为 3。

![](img/8da032797c27307c01a7395a1fe3cb16.png)

接下来，算法重点是 D *1* (4，2)。

![](img/69e49298d81f4ba64ead522107f85752.png)

由于 D *0* (4，2) < D *0* (4，1) + D *0* (1，2)，所以为 D *1* (4，2)保留-3。

![](img/274e55ae930d0cbfb86f30feaaf83b3f.png)

最后，Floyd-Warshall 算法查看 D *1* (4，3)。

![](img/37c4efcb44356fb51ff15fa85e6caa0b.png)

由于 D *0* (4，3) < D *0* (4，1) + D *0* (1，3)，所以为 D *1* (4，3)保留 1。

![](img/6627d0c991b85fffa52c69a24e22af09.png)

经过所有这些步骤，D *1* 终于完成。接下来，Floyd-Warshall 算法将创建 D *2* ，D *3* ，D *4* 。为了创建 D *2* ，算法以 D *1* 矩阵为起点，填入保证不变的数据。在这一步中保证不变的字段是对角线、第二行和第二列的值。

![](img/997ff0fa1bb46b2e6ac601ee18b314f7.png)

Floyd-Warshall 算法从通过 2 检查 D *2* (1，3)开始。

![](img/23184fc26a6c5c3c20ab0f7aed0f1193.png)

由于 D *1* (1，3) = D *1* (1，2) + D *1* (2，3)，∞为 D *1* (1，3)保留。

![](img/33566cf1d41b4f2f004db3ed6406fa68.png)

接下来，算法重点是 D *2* (1，4)。

![](img/e6efae3428f7a2b84853564f768628a1.png)

由于 D *1* (1，4) < D *1* (1，2) + D *1* (2，4)，所以保留 5。

![](img/f25813c84a14408df5916d2fede751f2.png)

接下来，该算法关注 D2(3，1)。

![](img/27ff5cf374a5e9077e9a8cf732984827.png)

由于 D *1* (3，1) < D *1* (3，2) + D *1* (2，1)，-2 被保留。

![](img/086e1605331e8242b65ed658e5ad67cd.png)

接下来，算法重点是 D *2* (3，4)。

![](img/2ed76b7be9adfba4a7feb38107c6248e.png)

由于 D *1* (3，4) < D *1* (3，2) + D *1* (2，4)，所以为 D *2* (3，4)保留 3。

![](img/c59ed16a1a2b1550bdd9d871da39f139.png)

接下来，Floyd-Warshall 算法通过遍历顶点 2 来关注 D *2* (4，1)。

![](img/1a655ad7bc5c6963b7ec56f6b8a891ed.png)

由于 D *1* (4，1) = D *1* (4，2) + D *1* (2，1)，所以 D *1* 到 D *2* 没有变化。

![](img/9991fe133b8c4c28bb9bee5cf52cc1cb.png)

最后，算法检查 D *2* (4，3)。

![](img/87f4ac01cc1a63761e4c9b4bb39319bf.png)

由于 D *1* (4，3) < D *1* (4，2) + D *1* (2，3)，所以保留 1。

![](img/932ef8cd6e8139cd4882bf12e3acfccb.png)

Floyd-Warshall 算法完成 D *2* 矩阵；接下来是 T2 3 号 T3。为了创建 D *3* ，算法以 D *2* 矩阵为起点，填入保证不变的数据。在这一步中保证不变的字段是对角线、第三行和第三列的值。

![](img/2819966ba5822b33de531adfc4322e08.png)

Floyd-Warshall 算法从通过顶点 3 的**检查 D *3* (1，2)开始。**

![](img/e8ff31fc2de902c5608241b72baf601d.png)

由于 D *2* (1，2) < D *2* (1，3) + D *2* (3，1)，10 被保留。

![](img/31d9b90126cb097d7a43da850dfe47ef.png)

接下来，算法重点是 D *3* (1，4)。

![](img/43e4d0e8f4be3e2440499aa05593a50f.png)

由于 D *2* (1，4) < D *2* (1，3) + D *2* (3，4)，所以保留 5。

![](img/ecb5b9b68181b461ff147503ae352f13.png)

接下来，算法重点是 D *3* (2，1)。

![](img/3c8e8dae1b7c44ed4f29c5688ed1a950.png)

由于 D *2* (2，1) = D *2* (2，3) + D *2* (3，1)，所以没有变化。

![](img/4e86aa0d58f2f8d521a1ea678ff4b2a7.png)

接下来，算法重点是 D *3* (2，4)。

![](img/d9a0aa936e55f189b71c84aef19315c2.png)

由于 D *2* (2，4) < D *2* (2，3) + D *2* (3，4)，所以保留 9。

![](img/943656229ce58d381fc4575f87e6142a.png)

接下来，算法的重点是 D *3* (4，1)。

![](img/5d38e41414c132265e08cc8dcbbbc1b4.png)

由于 D *2* (4，1) > D *2* (4，3) + D *2* (3，1)，D *3* (4，1)更新为-1。

![](img/514e3e490678ba4dcbc287e50b4ac38a.png)

最后，算法检查 D *3* (4，2)。

![](img/2cb1af41bfe2c9d968ac4f4d8004e4e8.png)

由于 D *2* (4，2) < D *2* (4，3) + D *2* (3，2)，-3 被保留，算法完成 D *3* 矩阵的构造。

![](img/cbc696114fe2fb679a3399372ce00a60.png)

Floyd-Warshall 算法终于成功了。为了构造 D *4* ，算法以 D *3* 矩阵为起点，填入保证不变的数据。在这一步中保证不变的字段是对角线、第四行和第四列的值。

![](img/07aed696317422b1903829e980527281.png)

Floyd-Warshall 算法通过遍历顶点 4 来检查 D *4* (1，2) **开始。**

![](img/42e7b573c9d3a75597a402c256b89be3.png)

由于 D *3* (1，2) > D *3* (1，4) + D *3* (4，2)，D *4* (1，2)更新为新值 2。

![](img/d3477ebf91235539300b4ffb0f4b2588.png)

接下来，算法重点是 D *4* (1，3)。

![](img/053e059839f91a2ef81e1a92d70c5fde.png)

由于 D *3* (1，3) > D *3* (1，4) + D *3* (4，3)，D *4* (1，3)更新为新值 6。

![](img/fad7286753809c65970511d549f4c843.png)

接下来，算法重点是 D *4* (2，1)。

![](img/8b2a9e5933e5a98733d0421f8cf8c880.png)

由于 D *3* (2，1) > D *3* (2，4) + D *3* (4，1)，D *4* (2，1)更新为新值 8。

![](img/f60d8db784e01326b3da3b1c4eed89f4.png)

接下来，算法重点是 D *4* (2，3)。

![](img/e2bb7bd77a85857d548faab9c4f465d1.png)

由于 D *3* (2，3) > D *3* (2，4) + D *3* (4，3)，D *4* (2，3)更新为新值 10。

![](img/50ea93b9a54190ae0ee3a7fdfcf5e524.png)

接下来，算法重点是 D *4* (3，1)。

![](img/a534ea6487d5374549ba513c36e2a010.png)

由于 D *3* (3，1) < D *3* (3，4) + D *3* (4，1)，-2 被保留。

![](img/521c5f8f284b928cddd7a19d798a0329.png)

最后，Floyd-Warshall 算法的重点是 D *4* (3，2)。

![](img/c99fc9b25834d50eda37ff9fcc151e7e.png)

由于 D *3* (3，2) > D *3* (3，4) + D *3* (4，2)，D *4* (3，2)更新为新值 0，算法完成。

![](img/7b34ee524223cb04fe21b3431e092537.png)

纵观整个过程，Floyd-Warshall 算法产生以下矩阵:

![](img/6d55a07e94da5a46a02be962be5ebf26.png)

如果您通过将矩阵 D *4* 与树进行比较来检查矩阵 D*4*的值，您将看到从每个顶点到每个顶点的最短路径被找到。有些顶点可以一跳到达，有些要两跳，有些甚至要三跳。

![](img/19272b18d5339297eff3696a091c17ab.png)

*如果你喜欢你所读的，看看我的书，* [*算法说明*](https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&me=&qid=1586643862) *。*

![](img/12b0c850e0bb863545f825746af3dee0.png)

迪诺·卡希奇目前是 [LSBio(寿命生物科学公司)](https://www.lsbio.com/)、[绝对抗体](https://absoluteantibody.com/)、 [Kerafast](https://www.kerafast.com/) 、[珠穆朗玛生物科技](https://everestbiotech.com/)、[北欧 MUbio](https://www.nordicmubio.com/) 和 [Exalpha](https://www.exalpha.com/) 的 IT 负责人。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。

你可以在 [LinkedIn](https://www.linkedin.com/in/dinocajic/) 上联系他，在 [Instagram](https://instagram.com/think.dino) 上关注他，或者[订阅他的媒体出版物](https://dinocajic.medium.com/subscribe)。

阅读 Dino Cajic(以及 Medium 上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。