<html>
<head>
<title>How to combine Servant and React Admin, part 3 : Display a single comment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何组合Servant和React Admin，第3部分:显示单个注释</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-combine-servant-and-react-admin-part-3-display-a-single-comment-510006e8744a?source=collection_archive---------39-----------------------#2020-06-24">https://blog.devgenius.io/how-to-combine-servant-and-react-admin-part-3-display-a-single-comment-510006e8744a?source=collection_archive---------39-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7bcd7534937338173411a6c6a38511e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiQO0skRqGNTtSlAfnAwLw.jpeg"/></div></div></figure><h1 id="8d8f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="27be" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的<a class="ae lu" href="https://propellant.tech/blogs/servant-and-react-admin-2/" rel="noopener ugc nofollow" target="_blank">上一篇博客</a>以一个非常简单的REST服务器和一个可以列出评论的UI结束，就是这样。让我们扩展一下，用GET请求获取单个注释！</p><h1 id="7c45" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在仆人中获取资源</h1><p id="de37" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">GET请求本身相当接近我们已经拥有的内容。让我们回忆一下我们目前的类型:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="df0d" class="me jz iq ma b gy mf mg l mh mi">type WebApi = "comments" :&gt; Get '[ JSON] (ListHeaders [Comment])</span></pre><p id="e4b6" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们将首先增加第二条休息路线。其次，GET请求必须指定一个它想要检索的单个<code class="fe mo mp mq ma b">comment </code>,因此它需要某种惟一的id。同样，如果找不到那个<code class="fe mo mp mq ma b">comment </code>，我们应该能够指示失败。</p><p id="ea00" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在仆人端，它看起来像这样:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7c62" class="me jz iq ma b gy mf mg l mh mi">type WebApi<br/>   = "comments" :&gt; Get '[ JSON] (ListHeaders [Comment]) <br/>   :&lt;|&gt; "comments" :&gt; Capture "id" Int :&gt; Get '[ JSON] Comment</span></pre><p id="c626" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这里已经有一些东西要打开了。尽管我们的意图可能相当清楚，但还是有一些新的因素。</p><p id="ecd1" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最引人注目的是工会运营商<code class="fe mo mp mq ma b">:&lt;|&gt;</code>。它表示我们定义的两个路由应该集中在一个API类型中。您可以将其视为类型级别的<code class="fe mo mp mq ma b">( ,)</code>-操作符。事实上，当你忘记实现API的一部分时，你会看到一个类似嵌套元组结构的编译错误，试图告诉你哪里做错了。</p><p id="1691" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">下一个新事物是<code class="fe mo mp mq ma b">Capture </code>型。<code class="fe mo mp mq ma b">Capture </code>尝试将url的一个子路由解析成您指定的类型，在本例中是一个<code class="fe mo mp mq ma b">Int</code>。这里的“id”字符串只是提供信息，可以在为Servant Api类型生成文档时使用。我们稍后会谈到这一点。</p><h1 id="a544" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实现服务器</h1><p id="8119" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我们现在尝试编译，我们会看到以下错误:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a824" class="me jz iq ma b gy mf mg l mh mi">* Couldn't match type 'Handler (ListHeaders [Comment])' with 'Handler (Headers ' [TotalCountHeader] [Comment]) :&lt;|&gt; (Int -&gt; Handler Comment)' Expected type: Server WebApi Actual type: Handler (ListHeaders [Comment])</span></pre><p id="6f13" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">您已经可以看到union运算符的效果。当我们增加第三条路线时，它将变得更加直言不讳。这个错误有效地告诉我们，请通过在<code class="fe mo mp mq ma b">Handler Monad</code>中提供从<code class="fe mo mp mq ma b">Int </code>到<code class="fe mo mp mq ma b">Comment</code>的函数来实现服务器。</p><p id="1811" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">请注意，您不再需要解析捕获的子路由。</p><p id="1ac6" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">所以，我们开始吧:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e549" class="me jz iq ma b gy mf mg l mh mi">module Server where<br/><br/>import Servant<br/>import ApiType<br/>import Network.Wai.Handler.Warp (run)<br/>import Comment<br/>import Cors<br/>import qualified Data.List as L<br/>import Data.Maybe (fromJust)<br/><br/>fixedComments :: [Comment]<br/>fixedComments = [Comment 1 "A comment", Comment 2 "Another comment"]<br/><br/>listComments :: Handler (ListHeaders [Comment])<br/>listComments = return $ addHeader 2 fixedComments<br/><br/>getComment :: Int -&gt; Handler Comment<br/>getComment requestedId = <br/>  let maybeComment = L.find (\comment -&gt; Comment.id comment == requestedId) fixedComments in<br/>  return $ fromJust maybeComment<br/><br/>server ::  Server WebApi<br/>server = listComments :&lt;|&gt; getComment</span></pre><p id="a1d7" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们改变了很多东西。</p><p id="1124" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">首先，我们提取了变量<code class="fe mo mp mq ma b">fixedComments</code>中的所有注释，因此它既可以在<code class="fe mo mp mq ma b">listComments</code>中使用，也可以在<code class="fe mo mp mq ma b">getComment</code>中使用。</p><p id="f803" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">其次，有一个实现get功能的<code class="fe mo mp mq ma b">getComment</code>函数。它获取一个id，查找它，如果没有找到它，<code class="fe mo mp mq ma b">fromJust</code>函数将抛出一个异常。</p><p id="4254" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最有趣的部分是，您看到我们的union操作符在<code class="fe mo mp mq ma b">server</code>方法中返回。</p><p id="ab77" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">请注意，如果您没有传递一个可以被解析为<code class="fe mo mp mq ma b">Int</code>的“key ”, Servant将已经用一个400进行了回答，并且您不再需要在<code class="fe mo mp mq ma b">getComment </code>函数中处理那个错误，让我们来演示一下:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4acd" class="me jz iq ma b gy mf mg l mh mi">curl -i http://localhost:8082/comments/asdf </span><span id="a457" class="me jz iq ma b gy mr mg l mh mi">HTTP/1.1 400 Bad Request Transfer-Encoding: chunked Date: Sat, 30 May 2020 09:46:36 GMT Server: Warp/3.3.10</span></pre><h2 id="bfc3" class="me jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">union运算符</h2><p id="6c2b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上面的服务器片段归结为实现我们用union操作符定义的服务器api，方法是对具有正确签名(对应于我们在定义中使用的签名)的函数应用相同的union操作符。</p><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我认为值得注意的是，我们用来创建API类型的同一个操作符，在类型级别上，也可以用在函数上，但是我们不是定义服务器类型，而是提供函数来实现它。</p><h1 id="dd87" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">错误处理</h1><p id="1526" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">目前，我们将返回500内部服务器错误，以防GET请求无法检索我们的<code class="fe mo mp mq ma b">comment</code>。这是因为我们应用的<code class="fe mo mp mq ma b">fromJust</code>函数将抛出一个异常，这个异常将被服务器循环转换成一个500。</p><p id="97d1" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这当然远非最佳，但是让我们回忆一下本系列的第一篇博客<a class="ae lu" href="https://propellant.tech/blogs/servant-and-react-admin-1/" rel="noopener ugc nofollow" target="_blank">中的处理程序monad可以用来执行IO以及返回ServantError。</a></p><p id="afb6" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最简单的方法是使用servant-server库中预制的错误类型，并通过使用MonadError中的<a class="ae lu" href="http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error.html#v:throwError" rel="noopener ugc nofollow" target="_blank"> throwError </a>从getComment函数中返回这些错误类型。我们这样做的唯一原因是，处理程序monad实现了这个类型类。</p><p id="3256" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们像这样改变我们的<code class="fe mo mp mq ma b">getComment </code>函数:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3cc3" class="me jz iq ma b gy mf mg l mh mi">getComment :: Int -&gt; Handler Comment<br/>getComment requestedId = <br/>  let maybeComment = L.find (\comment -&gt; Comment.id comment == requestedId) fixedComments in<br/>  maybe (throwError err404) return maybeComment</span></pre><p id="c992" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><a class="ae lu" href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Maybe.html#v:maybe" rel="noopener ugc nofollow" target="_blank">也许</a>函数不需要太多解释，如果存在它将返回<code class="fe mo mp mq ma b">comment </code>或者如果不存在返回错误类型。</p><p id="018f" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在，这些<code class="fe mo mp mq ma b">errXXX </code>函数都返回非常标准的响应，例如<code class="fe mo mp mq ma b">err404</code>实现是这样的:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2a40" class="me jz iq ma b gy mf mg l mh mi">err404 :: ServerError<br/>err404 = ServerError { errHTTPCode = 404<br/>                    , errReasonPhrase = "Not Found"<br/>                    , errBody = ""<br/>                    , errHeaders = []<br/>                    }</span></pre><p id="0d5b" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这就达到了目的，但是更好的做法是具体说明还没有发现什么。对于更具描述性的错误，我们将把我们的<code class="fe mo mp mq ma b">getComment</code>函数改为:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="af9a" class="me jz iq ma b gy mf mg l mh mi">getComment :: Int -&gt; Handler Comment<br/>getComment requestedId = <br/>  let maybeComment = L.find (\comment -&gt; Comment.id comment == requestedId) fixedComments in<br/>  maybe (throwError err404 {errBody = BSLazy.pack $ "Could not retrieve comment with id " ++ show requestedId}) return maybeCommen</span></pre><p id="a05f" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">当然，我们需要<code class="fe mo mp mq ma b">import Data.ByteString.Lazy.Char8 as BSLazy</code>来实现这一点。如果我们愿意，我们也可以改变原因短语，就像我们编辑errBody一样。</p><p id="56d1" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">注意，<code class="fe mo mp mq ma b">errHeaders</code>不像Api类型中的头那样改变ServerError的类型。在这里，它们归结为一组字符串。</p><p id="1e36" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">让我们再次用旋度来演示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e495" class="me jz iq ma b gy mf mg l mh mi">curl -i http://localhost:8082/comments/2 </span><span id="bfb6" class="me jz iq ma b gy mr mg l mh mi">HTTP/1.1 200 OK Transfer-Encoding: chunked Date: Sat, 30 May 2020 09:46:25 GMT Server: Warp/3.3.10 Content-Type: application/json;charset=utf-8 { "content":"Another comment","id":2}</span></pre><p id="1ca7" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">并且在不存在id的情况下:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ec2c" class="me jz iq ma b gy mf mg l mh mi">curl -i http://localhost:8082/comments/3 </span><span id="4a95" class="me jz iq ma b gy mr mg l mh mi">HTTP/1.1 404 Not Found Transfer-Encoding: chunked Date: Sat, 30 May 2020 09:46:26 GMT Server: Warp/3.3.10 Could not retrieve comment with id 3</span></pre><h1 id="3066" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从反应管理员获取</h1><p id="7b0e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在让我们回到React Admin。我们想要显示我们的<code class="fe mo mp mq ma b">comment</code>，React Admin有一个方便的特性，它可以根据返回的JSON猜测显示组件的布局。</p><p id="5dfb" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们将应用组件更改为:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1810" class="me jz iq ma b gy mf mg l mh mi">const App = () =&gt; (<br/>    &lt;Admin dataProvider={dataProvider}&gt;<br/>        &lt;Resource name="comments" list={CommentsList} show={ShowGuesser}/&gt;<br/>    &lt;/Admin&gt;<br/>);</span></pre><p id="3635" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">使用<code class="fe mo mp mq ma b">ShowGuesser </code>作为处理单个<code class="fe mo mp mq ma b">comment</code>的“显示”功能的组件。</p><p id="70fe" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">该组件不仅会猜测布局，还会在浏览器的控制台中打印出来，因此打开开发人员工具并见证:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a9e6" class="me jz iq ma b gy mf mg l mh mi">Guessed Show:<br/><br/>export const CommentShow = props =&gt; (<br/>    &lt;Show {...props}&gt;<br/>        &lt;SimpleShowLayout&gt;<br/>            &lt;TextField source="content" /&gt;<br/>            &lt;TextField source="id" /&gt;<br/>        &lt;/SimpleShowLayout&gt;<br/>    &lt;/Show&gt;<br/>);</span></pre><p id="70c7" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这是一个非常实用的方法，可以毫不费力地从一个像样的组件开始。我们可以在事后改变它。目前，这很适合我们，我们现在唯一要改变的是切换文本字段的顺序，首先显示id。</p><p id="7511" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">因此，我们的React组件显示我们的<code class="fe mo mp mq ma b">comment </code>将如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="da39" class="me jz iq ma b gy mf mg l mh mi">export const CommentsShow = props =&gt; (<br/>    &lt;Show {...props}&gt;<br/>        &lt;SimpleShowLayout&gt;<br/>            &lt;TextField source="id"/&gt;<br/>            &lt;TextField source="content"/&gt;<br/>        &lt;/SimpleShowLayout&gt;<br/>    &lt;/Show&gt;<br/>);</span></pre><p id="9622" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><code class="fe mo mp mq ma b">SimpleShowLayout </code>是最常用的节目布局之一。另一个选项是<code class="fe mo mp mq ma b">TabbedShowLayout</code>，更多信息见react管理教程中的<a class="ae lu" href="https://marmelab.com/react-admin/Show.html" rel="noopener ugc nofollow" target="_blank">。我们需要使用一个现有的显示布局，以便我们的组件可以在<code class="fe mo mp mq ma b">Resource </code>组件的“show”属性中使用。</a></p><p id="e7f6" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">如果我们现在将该属性更新为:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3979" class="me jz iq ma b gy mf mg l mh mi">&lt;Resource name="comments" list={CommentsList} show={CommentsShow}/&gt;</span></pre><p id="84c8" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们将能够点击列表概览中的<code class="fe mo mp mq ma b">comment </code>并放大单个<code class="fe mo mp mq ma b">comment</code>。</p><p id="7c90" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这个博客的源代码可以在<a class="ae lu" href="https://gitlab.com/KasperJanssens/servant-blog/-/tags/v0.2" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="fd42" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="d8ab" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，这就结束了一个GET请求。在下一篇博客中发表。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="70ff" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><em class="nk">最初发布于</em><a class="ae lu" href="https://propellant.tech/blogs/servant-and-react-admin-3/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://propellant . tech</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>