<html>
<head>
<title>A “C” Static Library Article</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一篇“C”静态库文章</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-and-use-a-c-static-library-fcf7b20e6302?source=collection_archive---------9-----------------------#2020-07-05">https://blog.devgenius.io/how-to-create-and-use-a-c-static-library-fcf7b20e6302?source=collection_archive---------9-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3004cfce22702fdc1d727971d421519e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MorFUg3-4Dxr8i3KnCK3OQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">当被程序调用时，静态库总是可用的</figcaption></figure><blockquote class="jz ka kb"><p id="0d27" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在本文中，我将解释什么是静态库，它们是如何工作的，如何创建一个静态库，以及计算机程序如何使用静态库。</p></blockquote><p id="8d94" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io">我们为什么需要库:</strong>T3】软件的代码是由很多函数组成的；函数有点像迷你程序，可以被另一个程序调用来执行输入的计算或修改。</p><p id="31d5" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">为了用 C 代码解释以上内容，我将创建一个名为<strong class="kf io"> mult() </strong>的函数，将两个数字相乘，并将结果存储在一个名为“结果”的变量中:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a0b4" class="ln lo in lj b gy lp lq l lr ls">int main(void)<br/>{<br/>int x = 4;<br/>int y = 6;<br/>int result;</span><span id="a639" class="ln lo in lj b gy lt lq l lr ls">result = mult(x, y);<br/>return (0);<br/>}</span></pre><p id="e594" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">所以这个程序只有在编译器知道函数<strong class="kf io"> mult() </strong>的情况下才会编译；通常，程序员可以在 main 函数之上定义并创建一个函数<strong class="kf io"> mult() </strong>，这样编译器就可以在程序本身中找到它。它可能看起来像这样:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3f17" class="ln lo in lj b gy lp lq l lr ls">int mult(int a, int b)<br/>{<br/>return (a * b);<br/>}</span><span id="ccb8" class="ln lo in lj b gy lt lq l lr ls">int main(void)<br/>{<br/>int x = 4;<br/>int y = 6;<br/>int result;</span><span id="073b" class="ln lo in lj b gy lt lq l lr ls">result = mult(x, y);<br/>return (0);<br/>}</span></pre><p id="00c9" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io"> mult() </strong>函数将两个变量(x，y)相乘并返回一个结果，还有更复杂的函数，它们甚至会变得很长，通常会使程序难以阅读，当<strong class="kf io"> main() </strong>函数之上有许多函数时，甚至会变得更复杂。</p><p id="645f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">这就是静态库变得方便的地方，你可以把一个库想象成一个书籍的集合，每本书都是一个函数，比如<strong class="kf io"> mult() </strong>，任何可以访问这个库的人都可以阅读它，通常它们很容易阅读。</p><p id="9ba2" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io">静态库如何工作？</strong></p><p id="2214" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">静态库只是包含函数的目标文件的集合，这些函数通常用符号和地址来索引，就像一本书的目录表，这样更容易找到函数。</p><p id="541f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">通常，在创建可执行文件之前，静态库在编译阶段的链接阶段被加入到程序的主模块中。在一个静态库成功链接到一个程序的主模块后，可执行文件将包含<em class="ke">主程序和库。</em></p><p id="833a" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io">如何创建它们？</strong></p><p id="caad" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">静态库是使用一种类型的归档软件创建的，例如"<strong class="kf io"> ar" </strong>命令，该命令使用<strong class="kf io">带一个或多个目标文件。o" </strong>文件扩展名，并将其压缩，生成一个文件扩展名为<strong class="kf io">的存档文件。一个"</strong>这是我们的静态库。</p><p id="6057" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我们必须考虑到，在我们使用 ar 命令之前，我们必须有一些对象文件给它，这样做的方法是使用一个我们希望包含在我们的库中的函数，并在 GNU 编译<strong class="kf io"> (gcc) </strong>时使用<strong class="kf io">-c "</strong>命令来停止编译过程，这样该命令的输出将由<strong class="kf io">产生。c" </strong>文件扩展名为<strong class="kf io"> "o." </strong>文件扩展名，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5100" class="ln lo in lj b gy lp lq l lr ls">$ gcc -c mult.c   // resulting a mult.o object file! magic!!</span></pre><p id="3bea" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">现在我们有了带有<strong class="kf io">的目标文件。o " </strong>文件扩展名，我们可以继续将它们归档，并使用<strong class="kf io"> "ar" </strong>创建一个静态库，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c4af" class="ln lo in lj b gy lp lq l lr ls">$ ar -rc libforme.a mult.o</span></pre><p id="e46a" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">现在我们已经创建了一个名为“libforme.a”的静态库。在它里面将是我们的<strong class="kf io"> mult() </strong>函数，这个函数已经在前面通过<strong class="kf io">“gcc”</strong>命令被转换成一个目标文件。</p><blockquote class="jz ka kb"><p id="c29d" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io"> -rc </strong> comamnd 选项创建归档文件时不发出警告，并替换库中任何预先存在的同名目标文件。</p></blockquote><p id="f352" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">存档自动组织库的索引，但是为了确保索引将组织库，我们使用命令<strong class="kf io"> "ranlib" </strong>在存档中创建并存储一个索引，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e6db" class="ln lo in lj b gy lp lq l lr ls">$ ranlib libforme.a</span></pre><p id="9580" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在由可重定位目标文件的档案的成员定义的每个符号的索引列表中，这是命令<strong class="kf io">“nm”</strong>变得方便的时候，因此我们可以看到目标文件<strong class="kf io">。o" </strong>文件扩展名，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cad9" class="ln lo in lj b gy lp lq l lr ls">$ nm libforme.a</span><span id="0bda" class="ln lo in lj b gy lt lq l lr ls">// sample output</span><span id="8644" class="ln lo in lj b gy lt lq l lr ls">mult.o:</span><span id="43dc" class="ln lo in lj b gy lt lq l lr ls">000000000000002e T mult</span></pre><p id="291e" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">既然我们已经创建了一个对象文件，将它们压缩到库中并建立索引，就可以在我们的库中使用了。</p><p id="6b96" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io">如何使用它们？</strong></p><p id="28cd" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果我们想在这篇文章中编译 C 程序，使用<strong class="kf io"> mult() </strong>来存储两个数字的值:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3b90" class="ln lo in lj b gy lp lq l lr ls">int main(void)<br/>{<br/>int x = 4;<br/>int y = 6;<br/>int result;</span><span id="b4fc" class="ln lo in lj b gy lt lq l lr ls">result = mult(x, y);<br/>return (0);<br/>}</span></pre><p id="92bb" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果我们试图编译这个程序，我们会得到这样一个错误信息:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="26df" class="ln lo in lj b gy lp lq l lr ls">gcc my_function.c</span><span id="b27b" class="ln lo in lj b gy lt lq l lr ls">// oops something is wrong!! //</span><span id="c344" class="ln lo in lj b gy lt lq l lr ls">/tmp/ccGLAk66.o: In function `main':</span><span id="5b60" class="ln lo in lj b gy lt lq l lr ls">my_function.c:(.text+0x27): <strong class="lj io">undefined reference to `mult'</strong></span><span id="b679" class="ln lo in lj b gy lt lq l lr ls">collect2: error: ld returned 1 exit status</span></pre><p id="e29f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">所以编译器不知道<strong class="kf io"> mult() </strong>函数是什么。我们需要解释程序来查看静态库中的<strong class="kf io"> mult() </strong>函数，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="abdf" class="ln lo in lj b gy lp lq l lr ls">gcc my_function.c -L. -lforme -o my_program</span></pre><p id="b709" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">让我们来分解这个命令:</p><ul class=""><li id="d851" class="lu lv in kf b kg kh kk kl lb lw lc lx ld ly la lz ma mb mc bi translated"><strong class="kf io"> -L </strong>表示“在目录中查找库文件”</li><li id="889b" class="lu lv in kf b kg md kk me lb mf lc mg ld mh la lz ma mb mc bi translated"><strong class="kf io">。</strong>(‘L’后面的点)代表当前工作目录</li><li id="7e24" class="lu lv in kf b kg md kk me lb mf lc mg ld mh la lz ma mb mc bi translated"><strong class="kf io"> -l </strong>表示“与此库文件链接”</li><li id="48ef" class="lu lv in kf b kg md kk me lb mf lc mg ld mh la lz ma mb mc bi translated">forme 是我们图书馆的名字。请注意，我们省略了“lib”前缀和“”。一个“分机。链接器将这些部分附加回库的名称，以创建要查找的文件名。</li><li id="3a0f" class="lu lv in kf b kg md kk me lb mf lc mg ld mh la lz ma mb mc bi translated"><strong class="kf io"> -o my_function </strong>表示“命名可执行文件<strong class="kf io"> my_function </strong></li></ul><blockquote class="jz ka kb"><p id="521d" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果一切顺利，结果将是一个名为 my_function 的可执行文件，它使用 libforme.a 静态库中包含的<strong class="kf io"> mut() </strong>函数。</p></blockquote><p id="6a52" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果您有任何问题、意见或建议，请随时通过 Twitter @MrTechi 联系我</p></div></div>    
</body>
</html>