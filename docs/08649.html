<html>
<head>
<title>Terraform — Provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terraform —提供商</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/terraform-provider-aa57ade59eec?source=collection_archive---------10-----------------------#2022-06-30">https://blog.devgenius.io/terraform-provider-aa57ade59eec?source=collection_archive---------10-----------------------#2022-06-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="a294" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Terraform provider 深潜</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/d23d7e7407a0ba91c2ae8c8530edb967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*WKH6WBCGef7dkGxE8MC-pA.png"/></div></figure><p id="dac3" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Terraform 被设计为一个多云基础设施协调工具。与绑定到 AWS 平台的 CloudFormation 不同，Terraform 可以同时编排各种云平台或其他基础设施的资源。</p><p id="41aa" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Terraform 实现多云编排的方式是提供者插件机制。它的架构看起来像:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lk"><img src="../Images/eac322a14d2c71ba7e5e237da93c3e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BhA6qSz7erxcBRrH.png"/></div></div><figcaption class="lp lq gk gi gj lr ls bd b be z dk translated">图片来自<a class="ae lt" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> terrafrom </a></figcaption></figure><p id="418e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Terraform 使用哈希公司开发的 go-plugin 库(<a class="ae lt" href="https://github.com/hashicorp/go-plugin" rel="noopener ugc nofollow" target="_blank">https://github.com/hashicorp/go-plugin</a>)。本质上，每个提供者插件都是一个独立的进程，通过 rpc 与 Terraform 进程一起调用。</p><p id="94e2" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成由数据和资源组成的图(graph)，然后通过 rpc 调用这些数据和资源对应的提供者插件；插件框架定义了各种数据和资源，实现了相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，也可以通过调用 Http(s) API 直接操作目标平台。</p><h1 id="510c" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">提供商基础知识</h1><p id="88bc" class="pw-post-body-paragraph ko kp ir kq b kr mm js kt ku mn jv kw kx mo kz la lb mp ld le lf mq lh li lj ik bi translated">写完代码之后，应用之前，我们先执行<code class="fe mr ms mt mu b">terraform init</code>命令。它将分析代码中使用的提供者，并尝试在本地下载提供者插件。</p><p id="3d66" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">如果我们查看执行了<code class="fe mr ms mt mu b">terraform init</code>命令的文件夹，我们会发现有一个<code class="fe mr ms mt mu b">.terraform</code>文件夹:</p><pre class="kh ki kj kk gu mv mu mw mx aw my bi"><span id="df88" class="mz lv ir mu b gz na nb l nc nd">.<br/>├── providers<br/>│   └── registry.terraform.io<br/>│       └── hashicorp<br/>│           └── aws<br/>│               └── 4.18.0<br/>│                   └── darwin_amd64<br/>│                       └── terraform-provider-aws_v4.18.0_x5<br/>└── terraform.tfstate</span><span id="1780" class="mz lv ir mu b gz ne nb l nc nd">8 directories, 3 files</span></pre><p id="57b1" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">有时候下载一些提供者很慢，或者开发环境中有很多 Terraform 项目，每个项目都有自己单独的插件文件夹，非常浪费磁盘，那么我们可以使用插件缓存。</p><p id="8d66" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">有两种方法可以启用插件缓存:</p><ul class=""><li id="6974" class="nf ng ir kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated">配置<code class="fe mr ms mt mu b">TF_PLUGIN_CACHE_DIR</code>环境变量</li><li id="edae" class="nf ng ir kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">使用 CLI 配置文件<code class="fe mr ms mt mu b">.terraformrc</code></li></ul><p id="7c98" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">当启用插件缓存时，每当执行<code class="fe mr ms mt mu b">terraform init</code>命令时，Terraform 引擎将首先检查缓存文件夹中是否已经存在所需的插件，如果是，它将把缓存的插件复制到当前工作目录中的<code class="fe mr ms mt mu b">.terraform</code>文件夹。</p><h1 id="b9b7" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">提供商搜索</h1><p id="d408" class="pw-post-body-paragraph ko kp ir kq b kr mm js kt ku mn jv kw kx mo kz la lb mp ld le lf mq lh li lj ik bi translated">要了解哪些提供商被正式接受，有两种方法:</p><p id="e353" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">第一种方式</strong>是访问<a class="ae lt" href="https://www.terraform.io/docs/providers/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform 官方提供商文档</a>，其中列出了主流提供商:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj nt"><img src="../Images/f0217257308f4d524a61d4f6a6c52e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sLGzRL8u1qfXEYHJ.png"/></div></div></figure><p id="a79a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">第二种方法</strong>是去<a class="ae lt" href="https://registry.terraform.io/browse/providers" rel="noopener ugc nofollow" target="_blank"> registry.terraform.io </a>搜索:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj nu"><img src="../Images/cd91996cc7adebf2e18e8e8b7365a70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsoNOYjuTwKYXPhXW6-mcw.png"/></div></div></figure><p id="945d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">目前建议在注册表中搜索提供者，因为社区开发的大量提供者都在那里注册。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lk"><img src="../Images/87007bb4b0f3bb97cc95a6b2cc53c6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1_3GDwmiLuRZZV2A.png"/></div></div></figure><h1 id="6aae" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">提供商声明</h1><p id="7c97" class="pw-post-body-paragraph ko kp ir kq b kr mm js kt ku mn jv kw kx mo kz la lb mp ld le lf mq lh li lj ik bi translated">要执行一组 Terraform 代码，必须在代码中声明相关的提供者。许多提供者需要在声明时传递一些要使用的关键信息。例如:</p><pre class="kh ki kj kk gu mv mu mw mx aw my bi"><span id="cec8" class="mz lv ir mu b gz na nb l nc nd">terraform {<br/>  required_providers {<br/>    ucloud    = {<br/>      source  = "ucloud/ucloud"<br/>      version = "&gt;=1.24.1"<br/>    }<br/>  }<br/>}<br/><br/>provider "ucloud" {<br/>  public_key  = "your_public_key"<br/>  private_key = "your_private_key"<br/>  project_id  = "your_project_id"<br/>  region      = "cn-bj2"<br/>}</span></pre><p id="65cc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在这个提供者声明中，首先在 terraform 部分<code class="fe mr ms mt mu b">required_providers</code>声明这个代码必须被调用<code class="fe mr ms mt mu b">ucloud</code>才能被执行。</p><p id="f23b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">中的<code class="fe mr ms mt mu b">required_providers</code>插件声明还声明了源代码所需插件的版本约束，在本例中为<code class="fe mr ms mt mu b">version = "&gt;=1.24.1"</code>。Terraform 插件的版本号采用了 MAJOR.MINOR.PATCH 的语义格式。</p><p id="ab64" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">版本约束通常使用运算符和版本号来表示约束条件。条件可以用逗号拼接，表示 AND 关联，如“&gt; = 1.2.0，&lt; 2.0.0”。可用的运算符有:</p><ul class=""><li id="599e" class="nf ng ir kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated"><code class="fe mr ms mt mu b">=</code>(或者不带=，直接用版本号):只允许一个特定的版本号，不允许和其他条件组合</li><li id="c101" class="nf ng ir kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated"><code class="fe mr ms mt mu b">!=</code>:不允许特定版本号</li><li id="180f" class="nf ng ir kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated"><code class="fe mr ms mt mu b">&gt;,&gt;=,&lt;,&lt;=</code>:与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li><li id="10f0" class="nf ng ir kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated"><code class="fe mr ms mt mu b">~&gt;</code>:锁定主版本号和次版本号，允许补丁号大于等于特定版本号，例如<code class="fe mr ms mt mu b">~&gt;0.9</code>相当于<code class="fe mr ms mt mu b">&gt;=0.9</code>、<code class="fe mr ms mt mu b">&lt;1.0</code>、<code class="fe mr ms mt mu b">\~&gt;0.8.4</code>相当于<code class="fe mr ms mt mu b">&gt;=0.8.4, &lt;0.9</code></li></ul><p id="b2af" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Terraform 会检查当前的工作环境或者插件缓存，看看是否有满足版本约束的插件。如果没有，Terraform 会尝试下载。如果 Terraform 不能获得任何满足版本约束的插件，那么它拒绝继续任何后续操作。</p><h1 id="5886" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">内置提供程序</h1><p id="c014" class="pw-post-body-paragraph ko kp ir kq b kr mm js kt ku mn jv kw kx mo kz la lb mp ld le lf mq lh li lj ik bi translated">大多数提供者是以插件的形式单独发布的，但是目前有一个提供者内置在主 Terraform 流程中，那就是<code class="fe mr ms mt mu b">terraform_remote_state</code>数据源。由于提供者是内置的，所以在使用它的时候不需要在 terraform 中声明<code class="fe mr ms mt mu b">required_providers</code>。这个内置提供程序的源地址是<code class="fe mr ms mt mu b">terraform.io/builtin/terraform</code>。</p><h1 id="1faf" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">多个提供者实例</h1><p id="68db" class="pw-post-body-paragraph ko kp ir kq b kr mm js kt ku mn jv kw kx mo kz la lb mp ld le lf mq lh li lj ik bi translated"><code class="fe mr ms mt mu b">provider</code>部分声明了该提供商所需的各种配置。我们还可以声明相同类型的多个提供者，并给出不同的本地名称:</p><pre class="kh ki kj kk gu mv mu mw mx aw my bi"><span id="2162" class="mz lv ir mu b gz na nb l nc nd">terraform {<br/>  required_version = "&gt;=0.13.5"<br/>  required_providers {<br/>    ucloudbj  = {<br/>      source  = "ucloud/ucloud"<br/>      version = "&gt;=1.24.1"<br/>    }<br/>    ucloudsh  = {<br/>      source  = "ucloud/ucloud"<br/>      version = "&gt;=1.24.1"<br/>    }<br/>  }<br/>}<br/><br/>provider "ucloudbj" {<br/>  public_key  = "your_public_key"<br/>  private_key = "your_private_key"<br/>  project_id  = "your_project_id"<br/>  region      = "cn-bj2"<br/>}<br/><br/>provider "ucloudsh" {<br/>  public_key  = "your_public_key"<br/>  private_key = "your_private_key"<br/>  project_id  = "your_project_id"<br/>  region      = "cn-sh2"<br/>}<br/><br/>data "ucloud_security_groups" "default" {<br/>  provider = ucloudbj<br/>  type     = "recommend_web"<br/>}<br/><br/>data "ucloud_images" "default" {<br/>  provider          = ucloudsh<br/>  availability_zone = "cn-sh2-01"<br/>  name_regex        = "^CentOS 6.5 64"<br/>  image_type        = "base"<br/>}</span></pre><p id="58bb" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们还可以使用别名来区分同一提供者的不同实例:</p><pre class="kh ki kj kk gu mv mu mw mx aw my bi"><span id="0971" class="mz lv ir mu b gz na nb l nc nd">terraform {<br/>  required_version = "&gt;=0.13.5"<br/>  required_providers {<br/>    ucloud    = {<br/>      source  = "ucloud/ucloud"<br/>      version = "&gt;=1.24.1"<br/>    }<br/>  }<br/>}<br/><br/>provider "ucloud" {<br/>  public_key  = "your_public_key"<br/>  private_key = "your_private_key"<br/>  project_id  = "your_project_id"<br/>  region      = "cn-bj2"<br/>}<br/><br/>provider "ucloud" {<br/>  alias       = "ucloudsh"<br/>  public_key  = "your_public_key"<br/>  private_key = "your_private_key"<br/>  project_id  = "your_project_id"<br/>  region      = "cn-sh2"<br/>}<br/><br/>data "ucloud_security_groups" "default" {<br/>  type = "recommend_web"<br/>}<br/><br/>data "ucloud_images" "default" {<br/>  provider          = ucloud.ucloudsh<br/>  availability_zone = "cn-sh2-01"<br/>  name_regex        = "^CentOS 6.5 64"<br/>  image_type        = "base"<br/>}</span></pre><p id="d4a2" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">与多个本地名称相比，使用别名允许我们区分一个提供者的不同实例。注意，每个没有别名属性的提供者声明<strong class="kq is">都是一个<strong class="kq is">默认的</strong>提供者声明。没有显式指定提供程序的数据和资源使用与默认资源名称的第一个单词对应的提供程序。</strong></p></div></div>    
</body>
</html>