<html>
<head>
<title>Node.js Best Practices — Scaling and Technology</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 最佳实践—扩展和技术</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-scaling-and-technology-567eff4a231c?source=collection_archive---------3-----------------------#2020-08-26">https://blog.devgenius.io/node-js-best-practices-scaling-and-technology-567eff4a231c?source=collection_archive---------3-----------------------#2020-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2959dd3a56ad81dc42bc265c9c1993cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K83LelKmSrQC0hgI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@yunmai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> i 云脉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="8e0b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 npm 脚本</h1><p id="730e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 NPM 脚本来放置构建、测试和启动应用程序的脚本。</p><p id="d2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以在一个命令中输入更少的内容来完成所有这些任务。</p><p id="54ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把我们的脚本放在<code class="fe me mf mg mh b">package.json</code>中是为了让我们的生活更容易。</p><p id="d6ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以把:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1cf8" class="mq lc iq mh b gy mr ms l mt mu">"scripts": {<br/>  "preinstall": "node preinstall.js",<br/>  "postintall": "node postintall.js",<br/>  "build": "webpack",<br/>  "postbuild": "node index.js",<br/>  "postversion": "npm publish"<br/>}</span></pre><p id="a7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就可以用<code class="fe me mf mg mh b">npm run preinstall</code>、<code class="fe me mf mg mh b">npm run postinstall</code>等来运行它们。</p><p id="8dd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要运行多个命令，我们可以使用<code class="fe me mf mg mh b">&amp;&amp;</code>。</p><p id="df07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Webpack、Nodemon 等命令行工具。应该作为本地开发依赖项运行，以避免冲突。</p><h1 id="cb20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用环境变量</h1><p id="c28c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使我们的应用程序可配置，以便我们可以在任何环境中运行它们。</p><p id="388e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在不同的地方设置它们，包括启动应用程序的命令:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5d3b" class="mq lc iq mh b gy mr ms l mt mu">NODE_ENV=production MONGO_URL=mongo://localhost:27017 nodemon index.js</span></pre><p id="92ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者在 Nodemon 自己的配置中，也就是<code class="fe me mf mg mh b">nodemon.json</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="222f" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "env": {<br/>    "NODE_ENV": "production",<br/>    "MONGO_URL": "mongo://localhost:27017/accounts"<br/>  }<br/>}</span></pre><p id="b9ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，不要为我们的应用程序检查任何秘密。</p><h1 id="4de3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件循环</h1><p id="29f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们需要执行长时间运行的任务，那么我们需要在事件循环中对它们进行排队。</p><p id="3bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种方法可以做到这一点。</p><p id="43ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">setImmediate</code>和<code class="fe me mf mg mh b">setTimeout</code>都运行在下一个事件循环周期。</p><p id="dfc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">nextTick</code>工作在同一个周期。</p><h1 id="6ff7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用类继承</h1><p id="15ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe me mf mg mh b">extends</code>关键字，类语法使继承变得更容易。</p><p id="de24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它确保我们调用父构造函数，并让我们继承东西而不用直接使用原型。</p><p id="9c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管类语法是原型的语法糖，但它使我们的生活更容易。</p><h1 id="fe53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">恰当地命名事物</h1><p id="cab3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该恰当地给事物命名，这样我们就不必向人们解释它们的含义。</p><p id="5b43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0a36" class="mq lc iq mh b gy mr ms l mt mu">const foo = require('morgan')<br/>// ...<br/>app.use(foo('dev'))</span></pre><p id="a2b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e56" class="mq lc iq mh b gy mr ms l mt mu">const logger = require('morgan')<br/>// ...<br/>app.use(logger('dev'))</span></pre><h1 id="732d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 JavaScript？</h1><p id="68c9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用像 TypeScript 这样的 JavaScript 扩展来使我们的生活更加轻松。</p><p id="5c0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们经常让我们用各种 JavaScript 做不到的方式限制数据类型。</p><p id="de47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript 还提供了其他方便的特性，如接口和类型别名，以限制我们的对象的结构。</p><p id="ff6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也有类型守卫来推断类型。</p><p id="3772" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript 编译器最早可以编译到 ES3 的 JavaScript 版本。</p><p id="6ca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该满足任何人的需求。</p><h1 id="988a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快速中间件</h1><p id="572a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Express 中间件让我们可以将 Express 应用模块化。</p><p id="4a33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多 Express 附加组件作为中间件提供。</p><p id="ae70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括用于解析请求体的 body-parser 等等。</p><p id="6e75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">路线也是中间件。</p><p id="339e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们让我们轻松地构建我们的 Express 应用程序。</p><p id="bd6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该知道如何创造和使用它们。</p><h1 id="a228" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按比例增加</h1><p id="7ba7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们依赖于节点中的异步代码，这样我们运行的代码不会阻碍其他部分的运行。</p><p id="541e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只有一个线程，所以在这段代码完成之前，我们不能运行其他任何东西。</p><p id="1a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用处理器的多个内核，我们必须创建一个集群。</p><p id="af52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PM2 是一个简单的进程管理器，让我们可以轻松地创建集群。</p><p id="dda7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="90c2" class="mq lc iq mh b gy mr ms l mt mu">npm i -g pm2</span></pre><p id="7504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来安装它。</p><p id="8ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4f50" class="mq lc iq mh b gy mr ms l mt mu">pm2 start server.js -i 4</span></pre><p id="1f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用 4 个实例运行<code class="fe me mf mg mh b">server.js</code>,每个实例在其自己的内核上运行。</p><p id="2d13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有针对 Dockerized 应用程序的<code class="fe me mf mg mh b">pm2-docker</code>。</p><p id="885e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fcbc" class="mq lc iq mh b gy mr ms l mt mu"># ...<br/><br/>RUN npm install pm2 -g<br/><br/>CMD ["pm2-docker", "app.js"]</span></pre><p id="d4d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来运行它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/408196fe0ddfee0d8a53db26b2a584e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2XziT-nYsT6BPkTw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@nickkarvounis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·卡沃尼斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d2a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="13b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以与流程管理器一起扩展，一些方便的技巧会帮助我们更容易地开发。</p></div></div>    
</body>
</html>