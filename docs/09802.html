<html>
<head>
<title>How to run BLAZINGLY fast JavaScript code with Bun, Rust and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Bun、Rust 和 Go 运行速度惊人的 JavaScript 代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-run-blazingly-fast-javascript-code-with-bun-rust-and-go-2e645cf579b5?source=collection_archive---------4-----------------------#2022-09-14">https://blog.devgenius.io/how-to-run-blazingly-fast-javascript-code-with-bun-rust-and-go-2e645cf579b5?source=collection_archive---------4-----------------------#2022-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/899d38fd874a1a452cfbb32a805f9bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n07BubeIA5VmQFNaTEoarQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@valerieblanchett" rel="noopener ugc nofollow" target="_blank">瓦莱丽·布兰切特的图片</a></figcaption></figure><p id="8c08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你听说过 Bun 吗？没有吗？好吧，你会有所收获的。Bun 是一个新的、速度惊人的 JavaScript 运行时，它利用了苹果的 JavaScript 引擎 JavaScript Core，而不是 Node.js 今天使用的 V8 引擎。也是用齐格语写的。如果这是 Bun 不可思议的速度的一部分，这已经超出了这个故事的范围。</p><p id="9759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Bun 使之变得非常简单的是使用 FFI，或外国函数接口。这意味着，我们能够运行用 C/C++、Rust、Go 等编程语言编写的代码。</p><p id="9f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，你或者有一个用不同语言编写的库，或者你因为某些原因(速度、底层等等)需要使用不同的语言。您可以从编译语言中导出函数，您可以在 JavaScript 中运行这些函数。如果您追求速度，请记住，如果计算量很小，可能会有一点开销，这意味着您可能会更好地在 JavaScript 中运行它，尽管我自己没有在这方面采取任何措施。</p><p id="7706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 Bun 处于测试阶段，情况可能会有所变化。我建议你去<a class="ae kc" href="https://bun.sh" rel="noopener ugc nofollow" target="_blank"> https://bun.sh </a>看看那里的安装选项。</p><h2 id="e03b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">要求</h2><ul class=""><li id="6809" class="lu lv iq kf b kg lw kk lx ko ly ks lz kw ma la mb mc md me bi translated">小圆面包</li><li id="c332" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">Go 编译器</li><li id="e512" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">Rust 编译器</li></ul><p id="4502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建一个新的 Bun 项目，我们将运行<code class="fe mk ml mm mn b">bun init</code></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="8c45" class="lb lc iq mn b gy mw mx l my mz">~/  bun init                                                              ✔  10:54:57<br/>bun init helps you get started with a minimal project and tries to guess sensible defaults. Press ^C anytime to quit</span><span id="d996" class="lb lc iq mn b gy na mx l my mz">package name (bun):<br/>entry point (index.ts):</span><span id="601a" class="lb lc iq mn b gy na mx l my mz">Done! A package.json file was saved in the current directory.<br/> + index.ts<br/> + .gitignore<br/> + tsconfig.json (for editor auto-complete)<br/> + README.md</span><span id="e71e" class="lb lc iq mn b gy na mx l my mz">To get started, run:<br/>  bun run index.ts</span></pre><p id="7d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Bun 为我们创建了一堆文件。您可能已经注意到了<code class="fe mk ml mm mn b">index</code>文件是在 typescript 中。默认情况下，Bun 使用 typescript。</p><h2 id="537e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">面包和铁锈 FFI</h2><p id="4c80" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们编写一个快速计算器/加法器函数，它使用 Rust 将两个数相加。在程序开始时初始化二进制函数可能是个好主意，所以我们将在 IIFE 中加载所有内容(立即调用函数表达式)</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1866" class="lb lc iq mn b gy mw mx l my mz">// index.ts</span><span id="58c2" class="lb lc iq mn b gy na mx l my mz">import { dlopen, FFIType, <strong class="mn ir"><em class="ne">suffix </em></strong>} from 'bun:ffi'<br/><br/>const FFI = (() =&gt; {<br/>    const rustLib = dlopen(`librust_file.${<strong class="mn ir"><em class="ne">suffix</em></strong>}`, {<br/>        add: {<br/>            args: [FFIType.i32, FFIType.i32],<br/>            returns: FFIType.i32,<br/>        }<br/>    })<br/><br/>    return {<br/>        rust: rustLib.symbols,<br/>    }<br/>})()</span></pre><p id="48df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mk ml mm mn b">dlopen`</code>将二进制库加载到 JavaScript 中。我们还描述了哪些函数将从二进制文件中导出，并导入到我们的 JavaScript 中，以及哪些类型的参数和函数的返回类型。</p><p id="b274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图运行这个程序，我们会得到一个错误，说明它无法找到或打开库。这很好。这意味着代码试图找到生锈的文件。<code class="fe mk ml mm mn b">suffix</code>将根据您使用的操作系统动态添加。因为我运行的是 Mac，所以后缀会是<code class="fe mk ml mm mn b">dylib</code>。也支持<code class="fe mk ml mm mn b">so</code>和<code class="fe mk ml mm mn b">dll</code>。在编译 rust 应用程序时，请记住这一点。</p><p id="0d5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们写一份快速防锈申请。在项目的根目录下，创建一个文件<code class="fe mk ml mm mn b">rust_file.rs</code></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="b2af" class="lb lc iq mn b gy mw mx l my mz">// rust_file.rs</span><span id="3d65" class="lb lc iq mn b gy na mx l my mz">#[no_mangle]<br/>pub extern "C" fn add(a: i32, b: i32) -&gt; i32 {<br/>    a + b<br/>}</span></pre><p id="04fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 Rust 是一种编译语言，我们不知道一旦编译后文件名会是什么，所以<code class="fe mk ml mm mn b">no_mangle</code>有助于保持文件名不变。我们还告诉编译器，这个函数将是公共的。</p><p id="7608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以直接用 rust comiler 来编译。使用适用于您的操作系统的输出文件类型。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5e74" class="lb lc iq mn b gy mw mx l my mz">~/  rustc --crate-type cdylib rust_file.rs</span></pre><p id="2475" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们再次运行我们的 Bun 程序，我们会注意到之前看到的错误已经消失了。这意味着 Rust 程序已经成功加载到我们的 JavaScript 程序中。酷！</p><p id="8a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我们的<code class="fe mk ml mm mn b">FFI</code>功能:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2d8a" class="lb lc iq mn b gy mw mx l my mz"><strong class="mn ir"><em class="ne">console</em></strong>.log(FFI.rust.add(1, 2))</span></pre><p id="15e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行你的程序，输出应该是<code class="fe mk ml mm mn b">3</code>。非常酷！计算是由 Rust 处理的。</p><h2 id="1231" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">FFE 面包和 Go</h2><p id="fe58" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">大多数 Rust 示例直接取自 Bun 文档。我是 Go 编程语言的粉丝。Bun 文档没有提到任何关于从 Bun 运行 golang 代码的内容。我们能从 Bun 运行 Go 代码吗？好吧，让我们来看看！</p><p id="eb86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从扩展我们的<code class="fe mk ml mm mn b">FFI</code>函数来加载一个 Go 应用程序开始。</p><p id="d526" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe mk ml mm mn b">FFI</code>中，我们将把 Go 应用程序加载到一个<code class="fe mk ml mm mn b">goLib</code>变量中，并以与 Rust 应用程序相同的方式返回它:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="b936" class="lb lc iq mn b gy mw mx l my mz">const FFI = (() =&gt; {<br/>    ....<br/>    const goLib = dlopen(`goFile.${<strong class="mn ir"><em class="ne">suffix</em></strong>}`, {<br/>        Add: {<br/>            args: [FFIType.i32, FFIType.i32],<br/>            returns: FFIType.i32,<br/>        },<br/>    })<br/><br/>    return {<br/>        rust: rustLib.symbols,<br/>        go: goLib.symbols<br/>    }<br/>})()</span></pre><p id="ae4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，除了<code class="fe mk ml mm mn b">Add</code>中的大写<code class="fe mk ml mm mn b">A</code>外，该代码与 Rust 应用程序相同。让我们看看是否可以创建一个 Go 应用程序来为我们做同样的计算。</p><p id="9eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在项目的根目录下创建一个文件<code class="fe mk ml mm mn b">goFile.go</code></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5fce" class="lb lc iq mn b gy mw mx l my mz">// goFile.go</span><span id="0831" class="lb lc iq mn b gy na mx l my mz">package main<br/><br/>func main(){}<br/><br/>func Add(x int, y int) int {<br/>return x + y<br/>}</span></pre><p id="1af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在导出一个函数<code class="fe mk ml mm mn b">Add</code>，它接受两个整型数，并将结果作为一个整型数返回。让我们构建程序:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ced9" class="lb lc iq mn b gy mw mx l my mz">~/  go build -buildmode=c-shared -o goFile.dylib goFile.go</span></pre><p id="eb74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行 Bun 程序，编译器会告诉我们<code class="fe mk ml mm mn b">Add</code>函数丢失了。原因可能显而易见，也可能不明显，但是如果您查看您的目录，您会注意到没有 C 头文件。所以我们需要做的是添加足够的信息，这样 Go 编译器也可以生成一个头文件。</p><p id="3cfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过导入一个名为<code class="fe mk ml mm mn b">C</code>的 Go 库来解决这个问题，并在导出的函数上显式添加一个注释:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="a7b4" class="lb lc iq mn b gy mw mx l my mz">// goFile.go</span><span id="54e2" class="lb lc iq mn b gy na mx l my mz">package main <br/><br/>import "C" // &lt;- new <br/><br/>func main(){}<br/><br/><em class="ne">//export Add &lt;- new<br/></em>func Add(x int, y int) int {<br/>return x + y<br/>}</span></pre><p id="233f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们运行相同的构建命令，头文件将被正确创建，并且我们能够成功加载 Go 程序。</p><p id="8e3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编辑我们的<code class="fe mk ml mm mn b">index.ts</code>文件来记录我们的 Go 结果:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="71f1" class="lb lc iq mn b gy mw mx l my mz"><strong class="mn ir"><em class="ne">// index.ts<br/>.....</em></strong></span><span id="2ee8" class="lb lc iq mn b gy na mx l my mz"><strong class="mn ir"><em class="ne">console</em></strong>.log('Rust:', FFI.rust.add(1, 2))<br/><strong class="mn ir"><em class="ne">console</em></strong>.log('Go:', FFI.go.Add(3, 4))</span></pre><p id="1b87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行我们的程序:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f52d" class="lb lc iq mn b gy mw mx l my mz"> bun run index.ts            <br/>Rust: 3<br/>GO: 7</span></pre><p id="edbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只讨论了如何处理数字。Go 和 Rust 功能实际上是相同的。弦乐怎么样？</p><p id="bd5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串有点难处理，部分原因是 C 语言中不存在我们在更高级的编程语言中习惯使用的字符串类型(但也因为它们的编码不同。(<a class="ae kc" href="https://github.com/oven-sh/bun#strings-cstring" rel="noopener ugc nofollow" target="_blank">更多信息见 Bun docs </a>)</p><p id="9feb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们定义如何导入一个处理字符串的 Go 函数。在我们的<code class="fe mk ml mm mn b">FFI</code>函数中，我们将向<code class="fe mk ml mm mn b">goLib</code>添加一个新函数</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4778" class="lb lc iq mn b gy mw mx l my mz">const goLib = dlopen(`goFile.${<strong class="mn ir"><em class="ne">suffix</em></strong>}`, {<br/>    ....<br/>    Greet: {<br/>        args: [FFIType.cstring],<br/>        returns : FFIType.cstring,<br/>    }<br/>})</span></pre><p id="5844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们将使用的类型是<code class="fe mk ml mm mn b">cstring</code>。该函数将接受一个名称作为字符串，并返回一个问候，也是一个字符串。我们将前往我们的 Go 文件并添加我们的新函数</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="6c0e" class="lb lc iq mn b gy mw mx l my mz">// goFile.go</span><span id="5767" class="lb lc iq mn b gy na mx l my mz">....<br/>import (<br/>    "unsafe"<br/>)<br/>....</span><span id="2225" class="lb lc iq mn b gy na mx l my mz">//export Greet<br/>func Greet(name *C.char) *C.char {<br/>    cstr := C.CString("Hey from Go, " + C.GoString(name) + "!")<br/>    defer C.free(unsafe.Pointer(cstr))<br/>    return cstr<br/>}</span></pre><p id="0f80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从参数中创建并返回一个<code class="fe mk ml mm mn b">C string</code>。由于这将被编译成 C 库，我们需要记住释放所使用的内存。</p><p id="5be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图在此时构建我们的 Go 程序，我们会得到一个错误:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="67d6" class="lb lc iq mn b gy mw mx l my mz">could not determine kind of name for C.free</span></pre><p id="3a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何解决这个问题？事实证明，我们不仅能够构建 C 头文件和库，还能够将它们包含在我们的 Go 代码中！让我们导入 C 标准库。我们就在 C 导入上面做:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7395" class="lb lc iq mn b gy mw mx l my mz">// goFile.go</span><span id="00c4" class="lb lc iq mn b gy na mx l my mz">....</span><span id="d956" class="lb lc iq mn b gy na mx l my mz"><em class="ne">// #include &lt;stdlib.h&gt;<br/></em>import "C"</span><span id="3e6f" class="lb lc iq mn b gy na mx l my mz">....</span></pre><p id="98f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完美。构建是成功的。让我们讨论一下如何在我们的 JavaScript 应用程序中使用它。</p><p id="2f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以尝试像之前使用加法器功能一样使用它:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1159" class="lb lc iq mn b gy mw mx l my mz"><strong class="mn ir"><em class="ne">console</em></strong>.log('Greeter:', FFI.go.Greet('Stephan'))</span></pre><p id="2f4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望它能给我们一个好的欢迎信息。相反，我们得到一个错误，告诉我们做错了。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="912b" class="lb lc iq mn b gy mw mx l my mz">To convert a string to a pointer, encode it as a buffer</span></pre><p id="32bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在处理比我们通常在 JavaScript 中发现的更低级的数据，正如前面提到的，C 和 JavaScript 中的字符串是完全不同的动物。为了解决这个问题，我们可以用字符串创建一个缓冲区</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4b9b" class="lb lc iq mn b gy mw mx l my mz">// index.ts</span><span id="78c2" class="lb lc iq mn b gy na mx l my mz">....</span><span id="e1a9" class="lb lc iq mn b gy na mx l my mz">const nameBuffer = <strong class="mn ir"><em class="ne">Buffer</em></strong>.from("John Doe", "utf-8")</span></pre><p id="bb35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 C 字符串在<code class="fe mk ml mm mn b">utf-8</code>中，我们确保缓冲区也在。</p><p id="fd2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行我们的程序，它不会崩溃！然而，输出不是真的可以理解…</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1bcc" class="lb lc iq mn b gy mw mx l my mz">Greeter:  O$��</span></pre><p id="786a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果是，我们的欢迎函数返回一堆东西，而不是我们预期的值。它还返回一个指向我们输出的指针:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5bc1" class="lb lc iq mn b gy mw mx l my mz">// index.ts</span><span id="f4af" class="lb lc iq mn b gy na mx l my mz">.....</span><span id="e23f" class="lb lc iq mn b gy na mx l my mz">const nameBuffer = <strong class="mn ir"><em class="ne">Buffer</em></strong>.from("John Doe", "utf-8")<br/>const { ptr } = FFI.go.Greet(nameBuffer)<br/><strong class="mn ir"><em class="ne">console</em></strong>.log(ptr)</span></pre><p id="03d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产出:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="d29f" class="lb lc iq mn b gy mw mx l my mz">0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052150168576707</span></pre><p id="0ce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个对我们没有意义的长数字(不应该有意义)。我们可以用指针创建一个新的<code class="fe mk ml mm mn b">Cstring:</code></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="70b2" class="lb lc iq mn b gy mw mx l my mz">const nameBuffer = <strong class="mn ir"><em class="ne">Buffer</em></strong>.from("John Doe", "utf-8")<br/>const { ptr } = FFI.go.Greet(nameBuffer)<br/>const greeting = new CString(ptr)<br/><strong class="mn ir"><em class="ne">console</em></strong>.log(greeting)</span></pre><p id="4058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产出:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1dc0" class="lb lc iq mn b gy mw mx l my mz">Hey from Go, John Doe!</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="1a7e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">临终遗言</h2><p id="9d74" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">非常酷。想象一下从 JavaScript 运行 C 代码是多么容易！Bun 还声称运行速度比 nap 快 5 倍，比 Deno 快 100 倍，这真是令人震惊。</p><p id="585f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，Bun 还没有准备好生产，但我肯定不能等到它！</p><p id="31eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个在芬兰的小冒险。<br/>你也可以在<a class="ae kc" href="https://github.com/sbvalois/bun-go-rust-blog" rel="noopener ugc nofollow" target="_blank">https://github.com/sbvalois/bun-go-rust-blog</a>找到这篇博文的回购</p><p id="0f40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次见！斯蒂芬·巴克伦德·瓦卢瓦</p></div></div>    
</body>
</html>