<html>
<head>
<title>Linked Lists : Go-lang and Python implementations.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表:Go-lang 和 Python 实现。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-lists-go-lang-and-python-implementations-b918b7657f57?source=collection_archive---------11-----------------------#2022-07-21">https://blog.devgenius.io/linked-lists-go-lang-and-python-implementations-b918b7657f57?source=collection_archive---------11-----------------------#2022-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="abd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">前奏</strong></p><p id="e605" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表为基于数组的序列提供了另一种选择，即链表。基于数组的序列和链表都以特定的顺序保存元素，但是这种特性的实现在两者之间有很大的不同。</p><p id="3878" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组提供了一种更集中的表示方式，一大块内存能够容纳对许多元素的引用。另一方面，链表依赖于更加分布式的体系结构，其中称为节点的轻量级对象用于表示链表的每个单独元素。</p><p id="c8d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表中的每个节点维护对其组成元素的引用，以及对相邻节点的一个或多个引用，这取决于它是单链表实现还是双链表实现。这种表示允许我们共同表示序列的线性顺序。</p><h1 id="d89d" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">单链表</h1><p id="388c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">下面我们将给出单链表在 python 和 Go-lang 中的队列实现，现在这可以扩展到栈和树的双链表。</p><p id="d9de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">记忆使用</strong></p><p id="be72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与双向链表相比，单向链表占用更少的内存，因为它只需要一个指向其后继链表的指针。每个指针变量保存一个元素的地址，指针占用 4 个字节；因此，指针变量在单链表中占用的内存空间是 4 个字节。所以内存也按照 O(n)扩展，n 表示元素的数量，每个指针的 4 个字节保持不变。</p><p id="a49b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">时间复杂度</strong></p><p id="fcd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单链表的访问时间为 0(1)，搜索时间为 O(n)，因为我们必须在一个方向上从第一个到最后一个遍历整个链表，所以在最坏情况和平均情况下，它的插入时间为 O(n)，删除时间为 O(n)。</p><p id="19c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Go-lang 单链表队列实现</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="8295" class="lu kj in lq b gy lv lw l lx ly">package main</span><span id="a711" class="lu kj in lq b gy lz lw l lx ly">import "fmt"</span><span id="ae56" class="lu kj in lq b gy lz lw l lx ly">type Node struct {<br/>    element int<br/>    next    *Node<br/>}<br/>type GoLinkedQue struct {<br/>    head *Node<br/>    tail *Node<br/>    size int<br/>}</span><span id="9d30" class="lu kj in lq b gy lz lw l lx ly">func (l *GoLinkedQue) Len() int {<br/>    return l.size<br/>}</span><span id="16b1" class="lu kj in lq b gy lz lw l lx ly">func (l *GoLinkedQue) is_empty() bool {<br/>    if l.size == 0 {<br/>        return true<br/>    }<br/>    return false<br/>}</span><span id="cc1c" class="lu kj in lq b gy lz lw l lx ly">func (l GoLinkedQue) First() (int, error) {<br/>    if l.head == nil {<br/>        return 0, fmt.Errorf("The Queue is empty !")<br/>    }<br/>    return l.head.element, nil<br/>}</span><span id="541c" class="lu kj in lq b gy lz lw l lx ly">func (l GoLinkedQue) Last() (int, error) {<br/>    if l.head == nil {<br/>        return 0, fmt.Errorf("The Queue is empty !")<br/>    }<br/>    if l.size == 1 {<br/>        return l.head.element, nil<br/>    }<br/>    return l.tail.element, nil<br/>}</span><span id="18c9" class="lu kj in lq b gy lz lw l lx ly">func (l *GoLinkedQue) dequeue() int {<br/>    if l.is_empty() {<br/>        fmt.Errorf("The Queue is empty !")<br/>    }<br/>    answer := l.head.element<br/>    l.head = l.head.next<br/>    l.size--<br/>    if l.is_empty() {<br/>        l.tail = nil<br/>    }<br/>    return answer</span><span id="4f02" class="lu kj in lq b gy lz lw l lx ly">}<br/>func (l *GoLinkedQue) enqueue(e int) *Node {<br/>    newest := &amp;Node{<br/>        element: e,<br/>        next:    nil,<br/>    }<br/>    if l.is_empty() {<br/>        l.head = newest<br/>    } else {<br/>        l.tail.next = newest<br/>    }<br/>    l.tail = newest<br/>    l.size++<br/>    return newest<br/>}</span><span id="d992" class="lu kj in lq b gy lz lw l lx ly">func main() {<br/>    queue := GoLinkedQue{}<br/>    queue.enqueue(100)<br/>    queue.enqueue(200)<br/>    queue.enqueue(300)<br/>    queue.enqueue(400)<br/>    queue.enqueue(500)<br/>    queue.enqueue(600)<br/>    firstval, _ := queue.First()<br/>    lastval, _ := queue.Last()<br/>    fmt.Println("Length = ", queue.Len())<br/>    fmt.Println("First Element :", firstval)<br/>    fmt.Println("Last Element  :", lastval)<br/>    fmt.Println("Is Queue empty:", queue.is_empty())<br/>    queue.dequeue()<br/>    queue.dequeue()<br/>    queue.dequeue()<br/>    queue.dequeue()<br/>    queue.dequeue()<br/>    queue.dequeue()<br/>        fmt.Println("Length =", queue.Len())<br/>        fmt.Println("Is Queue empty:", queue.is_empty())    <br/>}</span></pre><p id="77a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你在 go-lang-playground 运行上面的代码，你会得到下面的结果</p><p id="aab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="32be" class="lu kj in lq b gy lv lw l lx ly">Length =  6<br/>First Element : 100<br/>Last Element  : 600<br/>Is Queue empty: false<br/>Program exited.</span></pre><p id="d0a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">下面用 Python 实现一个队列结构的单链表</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9132" class="lu kj in lq b gy lv lw l lx ly">1 class PythonLinkedQueue:                                                                                                                                            <br/>  2     """ A python implementation of a queue data structure using a 'singly linked-list' for storage."""<br/>  3 <br/>  4     class _Node:<br/>  5         """"Lightweight, non-public class for storing  a single Nodes attributes."""<br/>  6         __slots__ = "_element", "_next"<br/>  7 <br/>  8         <br/>  9         def __init__(self, element, next):<br/> 10             """"Instantiate a single Node object."""<br/> 11             self._element = element<br/> 12             self._next    = next<br/> 13 <br/> 14     <br/> 15     def __init__(self):<br/> 16         """Create an empty queue."""<br/> 17         self._head = None<br/> 18         self._tail = None<br/> 19         self._size = 0<br/> 20 <br/> 21 <br/> 22     def __len__(self):<br/> 23         """Return the number of elements in the queue."""<br/> 24         return self._size<br/> 25 <br/> 26     def is_empty(self):<br/> 27         """Return True if the queue is empty. """<br/> 28         return self._size == 0<br/> 29 <br/> 30     def first(self):<br/> 31         """Return but do not remove the element that sits at the front of the queue."""<br/> 32         if self.is_empty():<br/> 33             raise Empty("The Queue is Empty!")<br/> 34         return self._head._element<br/> 35 <br/> 36     def last(self):<br/> 37         """ Return butt do not remove the element that sits at the back of  the queue."""<br/>  38         if self.is_empty():<br/> 39             raise Empty("The Queue is Empty!")<br/> 40         elif self._size == 1:<br/> 41             return self._head._element<br/> 42         else:<br/> 43             return  self._tail._element<br/> 44 <br/> 45     def dequeue(self):<br/> 46         """Remove and return the first element of the queue(FIFO)"""<br/> 47         if self.is_empty():<br/> 48             raise Empty('Queue is empty')<br/> 49         result =  self._head._element<br/> 50         self._head = self._head._next<br/> 51         self._size -= 1<br/> 52         if self.is_empty():<br/> 53             self._tail = None<br/> 54         return result<br/> 55 <br/> 56     def enqueue(self, e):<br/> 57         """Add an element to the back of the queue. """<br/> 58         newest = self._Node(e, None)<br/> 59         if self.is_empty():<br/> 60             self._head = newest<br/> 61         else:<br/> 62             self._tail._next = newest<br/> 63         self._tail = newest<br/> 64         self._size += 1</span></pre><h1 id="61dc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">双向链表</h1><p id="5300" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在单个喜欢的列表中，每个节点维护一个对紧随其后的节点的引用。单链表的这种不对称带来了明显的局限性。例如不能有效地从列表的尾部删除一个节点，或者甚至我们不能从内部位置执行一个任意的节点，如果仅仅给定一个对该节点的引用，因为我们不能确定紧接在我们想要删除的节点之前的节点。</p><p id="2af7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是双向链表出现的地方。为了提供更大的对称性，我们定义了一个链表，其中每个节点都保持一个对它之前的节点的显式引用和对它之后的节点的引用。</p><p id="b12e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">内存使用量</strong></p><p id="e40d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个列表实现在单个节点中保存两个地址，一个地址指向前一个节点，另一个地址指向下一个节点。因此，两个指针变量占用的空间是 8 个字节。这个空间也必然会按照 O(n)扩展，n 代表链表当前拥有的节点数，每个节点占用每个节点 8 个字节的常量。</p><p id="897e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">时间复杂度</strong></p><p id="3872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在平均时间和最坏情况下，该双向链表的插入时间复杂度为 O(1)，删除时间复杂度为 O(1)，搜索时间复杂度为 O(n)，访问时间复杂度为 O(n)。</p><p id="e8d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用双向链表实现 deque 数据结构。Deque 是一种类似队列的数据结构，支持在队列的前端和后端插入和删除。</p><p id="ee13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">割台和拖车哨兵</strong></p><p id="c2de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了避免在双向链表的边界附近操作时的一些特殊情况，在链表的两端添加特殊的节点是有帮助的:在链表的开头添加一个头节点，在链表的结尾添加一个尾节点。这些“虚拟”节点被称为哨兵(或守卫)，它们不存储主<br/>序列的元素。</p><p id="dcd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用 python 实现</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="5651" class="lu kj in lq b gy lv lw l lx ly">1 class _DoublyLinkedBase:<br/>  2     """"A base class providing a doubly linked list representation."""                                                                                              <br/>  3 <br/>  4     class _Node:<br/>  5         """A lightweight, non public class for storing a doubly linked node"""<br/>  6         __slots__ = "_element","_next","_prev"<br/>  7 <br/>  8         def __init__(self, elment, prev, next):<br/>  9             self._element = element<br/> 10             self._prev    = prev<br/> 11             self._next    = next<br/> 12 <br/> 13     def __init__(self):<br/> 14         """Create ane empty list."""<br/> 15 <br/> 16         self._header  = self._Node(None, None, None)<br/> 17         self._trailer = self._Node(None, None, None)<br/> 18         self._header._next = self._trailer<br/> 19         self._header._prev = self._header<br/> 20         self._size = 0<br/> 21 <br/> 22     def  __len__(self):<br/> 23         """Return the number of elements in the list."""<br/> 24         return self._size<br/> 25 <br/> 26 <br/> 27     def is_empty(self):<br/> 28         """Return True if list is empty."""<br/> 29         return self._size == 0<br/> 30 <br/> 31     def _insert_between(self, e, predecessor, successor):<br/> 32         """Add element e between two existing nodes and return new node."""<br/> 33         newest = self._Node(e, predecessor, successor)<br/> 34         predecessor._next = newest<br/> 35         successor._prev = newest<br/> 36         self._size += 1                                                                                                                                             <br/> 37         return newest <br/> 38 <br/> 39     def _delete_node(self, node):<br/> 40         """ Delete nonsentinel node from the list and return its element."""<br/> 41         predecessor = node._prev<br/> 42         successor = node._next<br/> 43         predecessor._next = successor<br/> 44         successor._prev = predecessor<br/> 45         self._size -= 1<br/> 46         element = node._element<br/> 47         node._prev = node._next = node._element = None<br/> 48         return element</span></pre><p id="f4a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的基类由下面的类继承:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="e532" class="lu kj in lq b gy lv lw l lx ly">1 class LinkedDeque(_DoubleLinkedBase):<br/>  2     """ Double-ended queue implemented based on a doubly linked list."""                                                                                            <br/>  3 <br/>  4     def first(self):<br/>  5         """Return but do not remmove the element at the front of th deque."""<br/>  6         if self.is_empty():<br/>  7             raise Empty("Deque is empty")<br/>  8         return self._header._next._element<br/>  9 <br/> 10 <br/> 11     def last(self):<br/> 12         """Return but do not remove the element at the back of the deque."""<br/> 13         if self.is_empty():<br/> 14             raise Empty("Deque is empty")<br/> 15 <br/> 16         return self._trailer._prev._element<br/> 17 <br/> 18 <br/> 19     def insert_first(self, e):<br/> 20         """Add an element to the front of the deque."""<br/> 21         self._insert_between(e, self._header, self._header._next)<br/> 22 <br/> 23     def insert_last(self, e):<br/> 24         """Add an element to the backk of the deque."""<br/> 25         self._insert_between(e, self._trailer._prev, self._trailer)<br/> 26 <br/> 27     def delete_first(self):<br/> 28         """Remove and return the lement from the front of the deque."""<br/> 29         if self.is_empty():<br/> 30             raise Empty("Deque is empty")<br/> 31         return self._delete_node(self._header._next)<br/> 32 <br/> 33     def delete_last(self):<br/> 34         """Remove and return the element from the back of the deque."""<br/> 35         <br/> 36         if self.is_empty():                                                                                                                                         <br/> 37             raise Empty("Deque is empty") <br/> 38         return self._delete_node(self._trailer._prev)<br/> 39</span></pre><p id="8259" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在 Go-lang 中使用双向链表实现 deque 数据结构，我们实现如下</p><p id="63d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在 Go-lang 实现。</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="11de" class="lu kj in lq b gy lv lw l lx ly">package main</span><span id="a5bc" class="lu kj in lq b gy lz lw l lx ly">import "fmt"</span><span id="18ee" class="lu kj in lq b gy lz lw l lx ly">type Node struct {<br/>    element int<br/>    prev    *Node<br/>    next    *Node<br/>}</span><span id="55eb" class="lu kj in lq b gy lz lw l lx ly">type GoDoublyLinkedQue struct {<br/>    header  *Node<br/>    trailer *Node<br/>    size int<br/>}</span><span id="bf37" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) Len() int {<br/>    return l.size<br/>}</span><span id="72bc" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) is_empty() bool {<br/>    if l.size == 0 {<br/>        return true<br/>    }<br/>    return false<br/>}</span><span id="8a03" class="lu kj in lq b gy lz lw l lx ly">func (l GoDoublyLinkedQue) First() (int, error) {<br/>    if l.header.next == l.trailer {<br/>        return 0, fmt.Errorf("The Queue is empty !")<br/>    }<br/>    return l.header.next.element, nil<br/>}</span><span id="07e8" class="lu kj in lq b gy lz lw l lx ly">func (l GoDoublyLinkedQue) Last() (int, error) {<br/>    if l.trailer.prev == l.header {<br/>        return 0, fmt.Errorf("The Queue is empty !")<br/>    }<br/>    return l.trailer.prev.element, nil<br/>}</span><span id="fa37" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) insert_between(e int, predecessor, sucessor *Node) *Node {<br/>    newest := &amp;Node{<br/>        element: e,<br/>        prev:    predecessor,<br/>        next:    sucessor,<br/>    }<br/>    predecessor.next = newest<br/>    sucessor.prev = newest<br/>    l.size++<br/>    return newest<br/>}</span><span id="1d76" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) delete_node(node *Node) int {<br/>    predecessor := node.prev<br/>    sucessor := node.next<br/>    predecessor.next = sucessor<br/>    sucessor.prev = predecessor<br/>    l.size--<br/>    velement := node.element<br/>    node.prev = nil<br/>    node.next = nil<br/>    node.element = 0<br/>    return velement<br/>}</span><span id="3b52" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) insert_first(e int) *Node {<br/>    node := l.insert_between(e, l.header, l.header.next)<br/>    return node</span><span id="cc68" class="lu kj in lq b gy lz lw l lx ly">}</span><span id="4190" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) insert_last(e int) *Node {<br/>    node := l.insert_between(e, l.trailer.prev, l.trailer)<br/>    return node<br/>}</span><span id="c98d" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) delete_first() int {<br/>    if l.is_empty() {<br/>        fmt.Errorf("The Deque is empty")<br/>    }<br/>    element := l.delete_node(l.header.next)<br/>    return element<br/>}</span><span id="c72b" class="lu kj in lq b gy lz lw l lx ly">func (l *GoDoublyLinkedQue) delete_last() int {<br/>    if l.is_empty() {<br/>        fmt.Errorf("The deque is empty")<br/>    }<br/>    element := l.delete_node(l.trailer.prev)<br/>    return element<br/>}</span><span id="4112" class="lu kj in lq b gy lz lw l lx ly">func main() {<br/>    deque := GoDoublyLinkedQue{}<br/>    deque.header = &amp;Node{<br/>        element: 0,<br/>        prev:    nil,<br/>        next:    nil,<br/>    }<br/>    deque.trailer = &amp;Node{<br/>        element: 0,<br/>        prev:    nil,<br/>        next:    nil,<br/>    }<br/>    deque.header.next = deque.trailer<br/>    deque.trailer.prev = deque.header<br/>    deque.insert_first(100)<br/>    deque.insert_last(500)<br/>    firstVal, _ := deque.First()<br/>    lastVal, _ := deque.Last()<br/>    fmt.Println("Length = ", deque.Len())<br/>    fmt.Println("Is deque empty: ", deque.is_empty())<br/>    fmt.Println("First Element :", firstVal)<br/>    fmt.Println("Last Element  :", lastVal)<br/>    deque.delete_last()<br/>    deque.delete_first()<br/>    fmt.Println("Is deque empty: ", deque.is_empty())<br/>}</span></pre><p id="33fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码导致</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="b801" class="lu kj in lq b gy lv lw l lx ly">Length =  2<br/>Is deque empty:  false<br/>First Element : 100<br/>Last Element  : 500<br/>Is deque empty:  true</span><span id="be55" class="lu kj in lq b gy lz lw l lx ly">Program exited.</span></pre><p id="313b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再见，一会儿见。</p></div></div>    
</body>
</html>