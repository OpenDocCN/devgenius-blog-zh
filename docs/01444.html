<html>
<head>
<title>Merge Sort JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并排序 JavaScript</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/merge-sort-javascript-bd3f94772fab?source=collection_archive---------16-----------------------#2020-07-03">https://blog.devgenius.io/merge-sort-javascript-bd3f94772fab?source=collection_archive---------16-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/dd47634848589e77b3095b09b093d1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/0*d_M9xkfKwMCZws7Y.gif"/></div></figure><p id="5d4b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一名程序员，经常会遇到需要以某种方式进行排序的问题。无论是过滤你想呈现在页面上的数据，还是为下一次大型面试学习数据结构和算法，排序都是必不可少的。</p><p id="2b8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我主要关注合并排序:一种被认为是最有效的排序算法之一的算法。合并排序的工作原理是分而治之。也就是说，它重复地将一个数组分解成几个子数组，直到每个子数组都由一个元素组成，然后将这些子数组合并成一个有序的数组(见下图)。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/3b6461e4cd1644ce225dcb4a64fb690e.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/0*ekqK_brg_DoyuE80.gif"/></div></figure><p id="825d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">合并排序算法通常使用两个独立的子程序递归求解:一个分裂子程序和一个合并子程序。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/751e4c3a994380a9ecc328ede80537df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*OuPrPtHz11arh5hD8J4ojg.png"/></div></figure><p id="8ec5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了理解这两个子例程如何生成合并排序的重要性，让我们首先检查“merge”函数。假设给你两个排序的数组，并要求你将它们合并成一个排序的数组。实现这一点的方法如下:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/0fefdeec4037947ae61e31241f02dc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*CWtnX8sNS6nWa2NrSaf_Hw.png"/></div></figure><p id="305d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本质上…:-)</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/9d02a62e5a39b5eb14051291e0927501.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*1gjgj7h7ovewozf5.gif"/></div></figure><p id="df9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用 JavaScript 写的，看起来像:</p><pre class="kt ku kv kw gt la lb lc ld aw le bi"><span id="c3d5" class="lf lg iq lb b gy lh li l lj lk">function merger(left, right) {<br/>  const results = [];<br/>  while (left.length &amp;&amp; right.length) {<br/>    if (left[0] &lt; right[0]) {<br/>      results.push(left.shift());<br/>    } else {<br/>        results.push(right.shift());<br/>    }<br/>  }<br/>  return [...results, ...left, ...right];<br/>}</span></pre><p id="b682" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我已经展示了如何合并两个已排序的数组，我们可以对一个未排序的数组进行排序，方法是将它分成两个独立的数组，分别进行排序，然后对这两个数组调用合并函数(如上)。这是合并排序的第二个子例程的工作方式。它获取输入数组并将其分成尽可能小的块，即一个只有一个元素的数组。因为只有一个元素的数组已经是一个“排序数组”，所以以有序的方式将每个元素合并在一起是很容易的。</p><p id="5a79" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">换句话说，</p><ol class=""><li id="aec2" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">将给定数组分成两半，</li><li id="7b91" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">在每一半上递归调用除法函数，</li><li id="860e" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">合并结果。</li></ol><pre class="kt ku kv kw gt la lb lc ld aw le bi"><span id="b051" class="lf lg iq lb b gy lh li l lj lk">function mergeSort(arr) {<br/>  if (arr.length === 1) {<br/>    return arr;<br/>  }<br/>  const center = Math.floor(arr.length / 2);<br/>  const left = arr.slice(0, center);<br/>  const right = arr.slice(center); <br/>  return merge(mergeSort(left), mergeSort(right));<br/>}</span></pre><p id="14b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那还不算太糟！</p><p id="e51c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要考虑一个有趣的小细节:合并排序算法在最坏和最好的情况下都具有相同的时间复杂度，因为即使数组是预先排序的，该算法仍然必须执行完整的过程来确定数据是否排序。</p><p id="bc63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请在下面评论您认为的时间复杂度，以及您如何看待自己在项目中使用合并排序！</p><p id="77bf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">资源</p><p id="1a7a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">编码面试训练营:算法和数据结构</p></div></div>    
</body>
</html>