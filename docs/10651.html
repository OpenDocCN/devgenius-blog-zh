<html>
<head>
<title>Coding GraphQL service using Nest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用嵌套编码 GraphQL 服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/coding-graphql-service-using-nest-b646695b7b7f?source=collection_archive---------11-----------------------#2022-11-19">https://blog.devgenius.io/coding-graphql-service-using-nest-b646695b7b7f?source=collection_archive---------11-----------------------#2022-11-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c72c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天我们将看看如何在 Nest 中开发用户服务。然而，我们已经在 express 中编写了类似的服务，您可以在这里查看<a class="ae ki" href="https://medium.com/@sofikul.m/coding-graphql-services-eafd9235fdf7" rel="noopener"/>。</p><h1 id="9342" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">要求</h1><p id="0b92" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">要求是创建一个具有以下功能支持的用户服务</p><ul class=""><li id="a4ea" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">创造用户</li><li id="dfb2" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">查找所有用户[受“管理员”用户保护]</li><li id="6ec0" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">登录功能</li></ul><h1 id="a530" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">技术栈</h1><p id="edae" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们将用来构建这个 GraphQL 服务的技术堆栈</p><ul class=""><li id="e2fd" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">嵌套 Js</li><li id="dd51" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">Apollo GraphQL 服务器</li><li id="1401" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">GraphQL 库</li></ul><p id="0874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说得够多了，我们将马上着手实施。深呼吸，专注于接下来的部分:)</p><h1 id="4be7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">项目结构</h1><p id="eb6c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Nest Js 框架给了我们非常结构化的代码库，我们将使用默认的结构。</p><h1 id="9706" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">项目开发</h1><h1 id="ebdc" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#01 图表 SQL 模式</h1><p id="ea8c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">GraphQL 模式是客户端可以从 GraphQL API 请求的数据的描述。它还定义了客户机可以用来从 GraphQL 服务器读取和写入数据的查询和变异函数。Nest 给了我们拥有模块化模式的自由。</p><p id="c6d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">验证模式将位于 src/auth/auth.types.graphql 下，用户模式将位于 src/user/user.types.graphql 等下。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="c185" class="mj kk in mf b be mk ml l mm mn">type Query {<br/>  login(user: LoginUserInput!): LoginResult!<br/>  refreshToken: String!<br/>}<br/><br/>type LoginResult {<br/>  user: User!<br/>  token: String!<br/>}<br/><br/>input LoginUserInput {<br/>  username: String<br/>  email: String<br/>  password: String!<br/>}</span></pre><pre class="mo me mf mg bn mh mi bi"><span id="5521" class="mj kk in mf b be mk ml l mm mn">scalar Date<br/>scalar ObjectId<br/><br/>type Query {<br/>  users: [User!]!<br/>  user(username: String, email: String): User!<br/>  forgotPassword(email: String): Boolean<br/>}<br/><br/>type Mutation {<br/>  createUser(createUserInput: CreateUserInput): User!<br/>  updateUser(fieldsToUpdate: UpdateUserInput!, username: String): User!<br/>  addAdminPermission(username: String!): User!<br/>  removeAdminPermission(username: String!): User!<br/>  resetPassword(username: String!, code: String!, password: String!): User!<br/>}<br/><br/>type User {<br/>  username: String!<br/>  email: String!<br/>  permissions: [String!]!<br/>  createdAt: Date!<br/>  updatedAt: Date!<br/>  lastSeenAt: Date!<br/>  enabled: Boolean!<br/>  _id: ObjectId!<br/>}<br/><br/>input CreateUserInput {<br/>  username: String!<br/>  email: String!<br/>  password: String!<br/>}<br/><br/>input UpdateUserInput {<br/>  username: String<br/>  email: String<br/>  password: UpdatePasswordInput<br/>  enabled: Boolean<br/>}<br/><br/>input UpdatePasswordInput {<br/>  oldPassword: String!<br/>  newPassword: String!<br/>}</span></pre><h1 id="91c1" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#02 在应用模块中配置 Apollo 服务器</h1><p id="0b1e" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们将采用模式优先的方法。要使用模式优先的方法，首先要向 options 对象添加一个<code class="fe mp mq mr mf b">typePaths</code>属性。<code class="fe mp mq mr mf b">typePaths</code>属性指出了<code class="fe mp mq mr mf b">GraphQLModule</code>应该在哪里寻找您将要编写的 GraphQL SDL 模式定义文件。这些文件将在内存中合并；这允许您将模式分成几个文件，并将它们放在它们的解析器附近。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="184d" class="mj kk in mf b be mk ml l mm mn">GraphQLModule.forRoot&lt;ApolloDriverConfig&gt;({<br/>  driver: ApolloDriver,<br/>  typePaths: ['./**/*.graphql'],<br/>}),</span></pre><p id="e9c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您通常还需要对应于 GraphQL SDL 类型的类型脚本定义(类和接口)。手动创建相应的 TypeScript 定义是多余和乏味的。它让我们失去了单一的真理来源——SDL 内部的每一个变化都迫使我们调整打字稿的定义。为了解决这个问题，<code class="fe mp mq mr mf b">@nestjs/graphql</code>包可以从抽象语法树中自动生成 TypeScript 定义(<a class="ae ki" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>)。要启用此功能，请在配置<code class="fe mp mq mr mf b">GraphQLModule</code>时添加<code class="fe mp mq mr mf b">definitions</code>选项属性。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="ff3e" class="mj kk in mf b be mk ml l mm mn">GraphQLModule.forRoot&lt;ApolloDriverConfig&gt;({<br/>      driver: ApolloDriver,<br/>      typePaths: ['./**/*.graphql'],<br/>      context: ({ req }: any) =&gt; ({ req }),<br/>      definitions: {<br/>        path: join(process.cwd(), 'src/graphql.classes.ts'),<br/>        outputAs: 'class',<br/>      },<br/>}),</span></pre><p id="50ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述方法在应用程序每次启动时动态生成 TypeScript 定义。或者，最好构建一个简单的脚本来按需生成这些内容。例如，假设我们创建了下面的脚本<code class="fe mp mq mr mf b">generate-typings.ts</code></p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="af26" class="mj kk in mf b be mk ml l mm mn">import { GraphQLDefinitionsFactory } from '@nestjs/graphql';<br/>import { join } from 'path';<br/><br/>const definitionsFactory = new GraphQLDefinitionsFactory();<br/>definitionsFactory.generate({<br/>  typePaths: ['./src/**/*.graphql'],<br/>  path: join(process.cwd(), 'src/graphql.classes.ts'),<br/>  outputAs: 'class',<br/>  watch: true,<br/>  emitTypenameField: true,<br/>  skipResolverArgs: true,<br/>});</span></pre><p id="98d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在您可以按需运行这个脚本。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="7d22" class="mj kk in mf b be mk ml l mm mn">$ ts-node generate-typings</span></pre><p id="9d45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用<a class="ae ki" href="https://www.apollographql.com/blog/announcement/platform/apollo-sandbox-an-open-graphql-ide-for-local-development/" rel="noopener ugc nofollow" target="_blank"> Apollo 沙箱</a>而不是<code class="fe mp mq mr mf b">graphql-playground</code>作为本地开发的 GraphQL IDE，请使用以下配置:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="c8ce" class="mj kk in mf b be mk ml l mm mn">import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';<br/>import { Module } from '@nestjs/common';<br/>import { GraphQLModule } from '@nestjs/graphql';<br/>import { ApolloServerPluginLandingPageLocalDefault } from 'apollo-server-core';<br/><br/>@Module({<br/>  imports: [<br/>    GraphQLModule.forRoot&lt;ApolloDriverConfig&gt;({<br/>      driver: ApolloDriver,<br/>      playground: false,<br/>      plugins: [ApolloServerPluginLandingPageLocalDefault()],<br/>    }),<br/>  ],<br/>})<br/>export class AppModule {}</span></pre><p id="db7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的配置是</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="3fa5" class="mj kk in mf b be mk ml l mm mn">GraphQLModule.forRoot&lt;ApolloDriverConfig&gt;({<br/>      driver: ApolloDriver,<br/>      typePaths: ['./**/*.graphql'],<br/>      installSubscriptionHandlers: true,<br/>      playground: false,<br/>      plugins: [ApolloServerPluginLandingPageLocalDefault()],<br/>      context: ({ req }: any) =&gt; ({ req }),<br/>      definitions: {<br/>        path: join(process.cwd(), 'src/graphql.classes.ts'),<br/>        outputAs: 'class',<br/>      },<br/>    }),</span></pre><h1 id="a605" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#03 编写一个模块</h1><p id="fdda" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们将有不同的模块。让我们以认证模块为例。模块结构如下所示</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="c298" class="mj kk in mf b be mk ml l mm mn">auth<br/>  auth.interface.ts.  --&gt; All the types will be defined here<br/>  auth.module.ts.     --&gt; Module config<br/>  auth.resolver.ts.   --&gt; All the resolver functions<br/>  auth.service.ts.    --&gt; Service file to contains the business logics<br/>  auth.types.graphql  --&gt; Schema definition<br/> </span></pre><p id="d1b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">登录查询的示例代码</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="3abe" class="mj kk in mf b be mk ml l mm mn">@Query('login')<br/>  async login(@Args('user') user: LoginUserInput): Promise&lt;LoginResult&gt; {<br/>    const result = await this.authService.validateUserByPassword(user);<br/>    if (result) return result;<br/>    throw new AuthenticationError(<br/>      'Could not log-in with the provided credentials',<br/>    );<br/> }</span></pre><p id="87e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的代码可以在资源库中找到。</p><p id="b592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将开发几个 auth guards，并在我们的解析器中使用它来保护查询和变异访问。转到授权/守卫文件夹找到所有的授权守卫。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="00c1" class="mj kk in mf b be mk ml l mm mn">import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';<br/>import { Observable } from 'rxjs';<br/>import { GqlExecutionContext } from '@nestjs/graphql';<br/>import { User } from '../../graphql.classes';<br/>import { UsersService } from '../../users/users.service';<br/>import { AuthenticationError } from 'apollo-server-core';<br/><br/>// Check if username in field for query matches authenticated user's username<br/>// or if the user is admin<br/>@Injectable()<br/>export class AdminGuard implements CanActivate {<br/>  constructor(private usersService: UsersService) {}<br/><br/>  canActivate(context: ExecutionContext): boolean {<br/>    const ctx = GqlExecutionContext.create(context);<br/>    const request = ctx.getContext().req;<br/>    if (request.user) {<br/>      const user = &lt;User&gt;request.user;<br/>      if (this.usersService.isAdmin(user.permissions)) return true;<br/>    }<br/>    throw new AuthenticationError(<br/>      'Could not authenticate with token or user does not have permissions',<br/>    );<br/>  }<br/>}</span></pre><pre class="mo me mf mg bn mh mi bi"><span id="a967" class="mj kk in mf b be mk ml l mm mn">@Query('users')<br/>@UseGuards(JwtAuthGuard, AdminGuard)<br/>async users(): Promise&lt;UserDocument[]&gt; {<br/>   return await this.usersService.getAllUsers();<br/>}</span></pre><h1 id="e6e8" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#04 在开发模式下运行代码</h1><p id="83b3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">运行下面的命令启动开发服务器。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="348a" class="mj kk in mf b be mk ml l mm mn">npm run start</span></pre><h1 id="2b96" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#05 测试 API</h1><p id="d535" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Apollo server 提供了内置文档和平台，可以非常快速轻松地测试这些特性。</p><p id="0771" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运动场将在端点<code class="fe mp mq mr mf b">baseurl/graphql</code>可用，例如<a class="ae ki" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/graph QL</a></p><figure class="ma mb mc md gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/a94dccb0b69150b1fdbfbc661f908ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3owzfSA_VDLoEo83o7QRRA.png"/></div></div></figure><p id="01d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们在模式中定义的那样，我们的用户查询是受保护的，只有“admin”用户才能访问。所以要访问它，你需要在<code class="fe mp mq mr mf b">Authorization</code>头中传递令牌。(执行<code class="fe mp mq mr mf b">login</code>查询将获得的令牌)</p><figure class="ma mb mc md gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/2a75c9e0f96381deac6fc79266b125f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWKRa2aSG8eZaQ3v1Ei8tw.png"/></div></div></figure><h1 id="6836" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">#06 参考</h1><p id="2285" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">👨‍💻完整的源代码可以在<a class="ae ki" href="https://github.com/Sofiukl/my-todos-bucket-nestjs-gql" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="b522" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">下一步是什么</h1><p id="f8ad" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">你可以阅读我已经发表的其他 GraphQL 文章来了解更多。</p><blockquote class="nb"><p id="6a7d" class="nc nd in bd ne nf ng nh ni nj nk kh dk translated">继续学习！</p></blockquote></div></div>    
</body>
</html>