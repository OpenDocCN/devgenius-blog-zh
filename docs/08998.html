<html>
<head>
<title>5 Concurrency Patterns in GO to Enhance your next Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GO 中的 5 种并发模式来增强您的下一个项目</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-useful-concurrency-patterns-in-golang-8dc90ad1ea61?source=collection_archive---------0-----------------------#2022-07-24">https://blog.devgenius.io/5-useful-concurrency-patterns-in-golang-8dc90ad1ea61?source=collection_archive---------0-----------------------#2022-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bc873cd3cc8f58fc5c200c39a549b52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOYJZ07npQzv4HhHBzDPcA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae jz" href="https://unsplash.com/s/photos/developer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4356" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并发编程是 Golang 提供的最有趣的特性之一。</p><p id="100b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并发背后的思想是同时处理不同的任务，它减轻了诸如在需要很长时间运行或完成的任务中被阻塞的问题。在 GO 中利用这一特性的主要工具有:</p><ul class=""><li id="d802" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">GO 例程:它由一个独立运行的函数组成。我们可以把它想象成运行在另一个轻量级廉价线程中的进程。</li><li id="c093" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">通道:它们提供了一种在并发运行的函数之间进行通信的方式，并在必要时使它们同步。</li></ul><p id="7202" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GO 例程与通道相结合，提供了一种执行独立任务并在它们之间进行通信的简单方法。</p><p id="a05b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我做 GO 开发人员的时候，我遇到过一些并发模式，它们解决了我们通常会遇到的常见问题。在这篇文章中，我将与你分享其中的五个，我相信它们可能会到来。</p><p id="deb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">待选完成结构</strong></p><p id="854d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在讨论模式本身之前。我认为将您的注意力吸引到一个相对简单的结构是很重要的，这个结构将在本文中广泛使用。</p><p id="f3c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行和管理多个例程时，我们需要小心防止程序中的任何泄漏。一般来说，当一个 GO 例程留在我们的程序中，即使我们不再需要它，也会发生泄漏。解决方案是向例程发送一个信号，让它知道它可以退出。</p><p id="d32b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现这一点最常见的方法是将 for-select 循环与一个单独的通道结合起来，该通道向 GO 例程发送关闭信号。通常我们称之为<strong class="kc io"> done </strong>通道。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6f36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本例中，当我们在单独的 GO 例程中运行函数<strong class="kc io"> printIntegers </strong>时，它将开始监听<strong class="kc io"> integerStream </strong>通道。每当我们不再需要后台运行的<strong class="kc io"> printIntegers </strong>函数时，我们可以通过简单地关闭<strong class="kc io"> done </strong>通道来消除它。</p><p id="8fd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，我们可以使用上下文包来获得相同的效果:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="8a90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以通过我关于如何在 Go 中使用上下文包的博客文章来了解更多关于上下文包的特性。</p><p id="a9c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当上下文被取消时，<strong class="kc io"> printIntegers </strong>函数将退出。考虑到这一点，我们可以开始探索其他模式，因为这个 for-select-done 结构将成为它们的构建块。</p><ol class=""><li id="99f7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated"><strong class="kc io">扇入模式</strong></li></ol><p id="c2c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们从多个渠道接收数据。我们可能希望将来自几个源的数据重定向到一个流中。</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/8665eee6e05e4a22b9da41f923978543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppljh5BBJmyfAqFHL2bGzQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">扇入模式图。作者图片</figcaption></figure><p id="11b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最终，我们只需要管理一个数据源通道，而不是许多。这个模式出现在 Rob Pike 关于<em class="lu"> GO 的并发模式</em>的演讲中。你可以在 Youtube 上查看。</p><p id="f09f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实践中，可以通过设置一个新的输出通道并为每个数据源运行一个 GO 例程来实现，这只是另一个通道。</p><p id="041a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个 GO 例程将负责监听特定的通道，并将接收到的数据转发到输出通道。通过这种方式，我们将所有的渠道整合成一个单一的渠道。下面的代码显示了实现细节:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="4c28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分解上面的代码:</p><ol class=""><li id="f4ac" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">一开始，我们设置了一个<strong class="kc io"> waitGroup </strong>，它应该等待 for 循环中生成的所有侦听器完成。</li><li id="677d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">在 for 循环中，我们将迭代<strong class="kc io"> n </strong>次，其中<strong class="kc io"> n </strong>是作为输入接收的 fetchers 的数量。在每一次迭代中，我们将启动一个新的 GO 例程来监听 fetcher。</li><li id="0982" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">监听器例程由 for-select-done 结构组成。在每次迭代中，要么它将发送新数据到<strong class="kc io"> combinedFetcher </strong>通道，要么它将在上下文取消时退出。</li><li id="2233" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">最后，我们运行另一个 GO 例程作为清理。在关闭<strong class="kc io"> combinedFetcher </strong>通道之前，它等待所有监听器完成。</li></ol><p id="e49b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="kc io">从流中取前 n 个值</strong></p><p id="b350" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们只需要从通道中获取前 5、10 或前<strong class="kc io"> n </strong>值时，下一个模式可能会有用。</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/2b1455c6b789465ab3b70f35375f6cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5n4ASXKLWLntb17eueTQpA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">取前 N 个值。作者图片</figcaption></figure><p id="280e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想法是创建一个有限量输出的通道。假设我们正在从数据流中读取消息，我们只对前 5 条消息感兴趣。还有，让我们考虑一下，我们对数据源本身没有控制权，我们只能从中读取数据。这个模式给出了这个问题的解决方案:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="626a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分解函数<strong class="kc io">内部发生的事情 takeFirstN </strong>:</p><ol class=""><li id="b0cf" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">我们创建一个新的通道来传递接收到的数据。</li><li id="2c4e" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">创建了一个新的 GO 例程。此外，它还会延迟<strong class="kc io">取料通道</strong>的关闭。</li><li id="9579" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">在 GO 例程中，for-select 和 done 模式已经过修改。我们不是运行无限的 for 循环，而是通过输入<strong class="kc io"> n. </strong>来限制它的迭代次数</li></ol><p id="939c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作示例:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="97c8" class="mb mc in lx b gy md me l mf mg">0<br/>1<br/>2<br/>3<br/>4</span></pre><p id="7d38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们能够从<strong class="kc io"> range10 </strong>通道获得前 5 个输入，而无需关闭它或做任何类似的事情。</p><p id="aba3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.<strong class="kc io">认购模式</strong></p><p id="43b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种模式基于 Google I/O 2013——高级 Go 并发模式对话(你可以在这里观看<a class="ae jz" href="https://www.youtube.com/watch?v=QDDwwePbDtw&amp;t=299s" rel="noopener ugc nofollow" target="_blank"/>)。这种模式与这里展示的是一样的，只是做了一些修改，让我看得更清楚。</p><p id="af4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想听一个定期发生的事件。例如:我们需要每 15 秒从一个 API 获取更新。这种模式使用一个只负责交付新数据的订阅接口:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="c999" class="mb mc in lx b gy md me l mf mg">type Subscription interface {<br/>  Updates() &lt;-chan Item<br/>}</span></pre><p id="b097" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，我们将使用另一个接口作为抽象来获取我们需要的数据:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="b0d6" class="mb mc in lx b gy md me l mf mg">type Fetcher interface {<br/>  Fetch() (Item, error)<br/>}</span></pre><p id="9fd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于其中的每一个，我们都有一个具体的类型来实现它们。</p><p id="e587" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于订阅:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="cc4a" class="mb mc in lx b gy md me l mf mg">func NewSubscription(ctx context.Context, fetcher Fetcher, freq int) Subscription {<br/>  s := &amp;sub{<br/>    fetcher: fetcher,<br/>    updates: make(chan Item),<br/>  }</span><span id="2edf" class="mb mc in lx b gy mh me l mf mg">// Running the Task Supposed to fetch our data<br/>  go s.serve(ctx, freq)</span><span id="c3cb" class="mb mc in lx b gy mh me l mf mg">  return s<br/>}</span><span id="b8df" class="mb mc in lx b gy mh me l mf mg">type sub struct {<br/>  fetcher Fetcher<br/>  updates chan Item<br/>}</span><span id="e32f" class="mb mc in lx b gy mh me l mf mg">func (s *sub) Updates() &lt;-chan Item {<br/>  return s.updates<br/>}</span></pre><p id="622a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将更详细地介绍在<strong class="kc io"> serve </strong>方法中发生了什么。</p><p id="b062" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于 fetcher:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="64fd" class="mb mc in lx b gy md me l mf mg">func NewFetcher(uri string) Fetcher {<br/>  f := &amp;fetcher{<br/>    uri: uri,<br/>  }</span><span id="c021" class="mb mc in lx b gy mh me l mf mg">  return f<br/>}</span><span id="0807" class="mb mc in lx b gy mh me l mf mg">type fetcher struct {<br/>  uri   string<br/>}</span></pre><p id="0131" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">内发球法</strong></p><p id="09b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> serve </strong>方法由 for-select-done 类型的循环组成:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="dc46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把它分解一下，以了解那里发生了什么:</p><ol class=""><li id="c6e2" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">第一个 select case 将由 time ticker 定期激活。关于 fetcher，我们将在另一个 GO 例程中运行 fetch 作业，这样如果它花费的时间更长，我们就不会被阻塞。</li><li id="1392" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">当获取结果最终准备好发送时，它将在第二个选择情况下被接收。如果有错误，它将从 select 语句中断，并等待下一次迭代。</li><li id="523f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">第三种情况是等待上下文终止的标准情况。</li></ol><p id="8b91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.5 <strong class="kc io">订阅模式修改</strong></p><p id="8d57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显示的订阅模式对我来说非常有效。实际上，它有一个不那么容易捕捉的 bug。</p><p id="e14c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第 26 行中，我们向<strong class="kc io">更新</strong>通道发送数据，订户正在等待接收。问题是:如果订阅者没有准备好读取数据，那一行代码将保持阻塞状态。</p><p id="cf26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">幸运的是，有一种方法可以避免这个问题，那就是在 select 语句中将该行转换成一个单独的 case。</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="1820" class="mb mc in lx b gy md me l mf mg">case s.updates &lt;- fetched:</span></pre><p id="b4ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并在 for-select 循环之前声明提取的变量。</p><p id="5359" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果提取的数据没有准备好发送呢？</p><p id="a6e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实证明，这里可以使用<strong class="kc io">零通道</strong>的属性。每当我们试图写入一个零通道，它将保持阻塞。</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="171e" class="mb mc in lx b gy md me l mf mg">var fetchResponseStream chan Item<br/>fetched := Item{//Some data here//}</span><span id="225d" class="mb mc in lx b gy mh me l mf mg">fetchResponseStream &lt;- fetched // it blocks here</span></pre><p id="1ff4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们将创建一个布尔值<strong class="kc io"> pending </strong>来跟踪获取的项目是否可以发送:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="4784" class="mb mc in lx b gy md me l mf mg">var fetched Item<br/>var fetchResponseStream chan Item<br/>var pending bool</span><span id="09ba" class="mb mc in lx b gy mh me l mf mg">...<br/>for {<br/>  if pending {<br/>    fetchResponseStream = s.updates<br/>  } else {<br/>    fetchResponseStream = nil    <br/>  }<br/>  select {<br/>  ...<br/>  <br/>  case: fetchResponseStream &lt;- fetched:<br/>    pending = false</span></pre><p id="8ce8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将所有东西放在一起:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5bea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了<strong class="kc io">待定</strong>变量和<strong class="kc io"> fetchResponseStream </strong>通道，我们就能够降低在某个选择案例中被阻塞的可能性。</p><p id="5354" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在主功能中:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3b5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">地图，滤镜</strong></p><p id="ce35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们处理数据流时，我们可能希望对传入的值进行操作。乘法，除法，限制在一个固定的界限，有许多可能性。</p><p id="f840" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在现代 Javascript 中，数组有一些内置的方法，如<strong class="kc io"> map </strong>和<strong class="kc io"> filter、</strong>，用于操作或选择数组中的数据。为什么不应用这个概念来处理来自通道的流呢？</p><p id="9eb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4。地图图案</strong></p><p id="d3dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在简单乘以 2 的例子中:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/fd03cccb250414ce0482a51e9e3ec89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSCP98F3h0601GGK2K8hkQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">地图模式图。作者图片</figcaption></figure><p id="33ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了简单起见，我们假设输入和输出的数据类型是整数通道。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="620f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码解释:</p><ol class=""><li id="6ec1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">它首先创建一个新的通道，启动一个新的 GO 例程，并推迟通道关闭。</li><li id="8063" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">for-select-done 循环监听<strong class="kc io">输入流</strong>。</li><li id="e4ae" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">我们检查<strong class="kc io"> inputStream </strong>是否关闭，如果是，函数返回。</li><li id="048a" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">另一个 select 语句在里面，它将等待<strong class="kc io"> done </strong>信号或者能够将数据转发到<strong class="kc io"> mappedStream </strong>通道。这最后一步很重要，以确保当 done 通道发送其信号时，GO 例程将始终退出。</li></ol><p id="6186" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个小的区别是，我们使用一个 done 通道来终止 GO 例程，而不是上下文。</p><p id="06d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当构建一个必须经过多个阶段的数据管道时，这种模式可能会派上用场。它允许我们将不同的操作逻辑分成几个步骤。</p><p id="7c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作示例:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="f461" class="mb mc in lx b gy md me l mf mg">0<br/>10<br/>20<br/>30<br/>40<br/>50<br/>60<br/>70<br/>80<br/>90</span></pre><p id="02a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 5。过滤模式</strong></p><p id="428c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个整数流，我们只想得到大于 10 的值。我们可以应用这种模式让我们感兴趣的值通过:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/5d98b8421c5c385aec558369e22a8923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5seZhc1matbFDX-mCMzRg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">过滤模式。作者图片</figcaption></figure><p id="95f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像在 Map 模式中一样，我们将假设输入和输出类型是整数的通道，但是它可以扩展到任何其他类型:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="24fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们基本上拥有与图<strong class="kc io">模式</strong>相同的结构，唯一的区别是<strong class="kc io">操作符</strong>函数返回一个布尔值。如果它返回 true，那么，把它发送到输出流，否则，我们就丢弃它。</p><p id="edfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作示例:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="ae91" class="mb mc in lx b gy md me l mf mg">0<br/>2<br/>4<br/>6<br/>8</span></pre><p id="0cbc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="67f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这五种模式是构建更大更复杂的 Golang 应用程序的基础。这些是解决您在 GO 中处理并发时可能遇到的问题的解决方案。此外，您可以修改、扩展和创建基于它们的新模式！</p><p id="5dd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你坚持到最后！如果这篇文章对你有帮助，可以考虑在<a class="ae jz" href="https://medium.com/@leonardo5621_66451" rel="noopener"> Medium </a>上关注我，了解更多类似的故事！</p><p id="cbae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">参考文献</strong></p><p id="c8b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我用来写这个故事的参考资料:</p><ul class=""><li id="dab0" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">围棋中的并发性凯瑟琳·考克斯-布戴，第四章。Go 中的并发模式。可在:<a class="ae jz" href="https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/ch04.html" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/concurrency-in-go/9781491941294/ch04 . html</a></li><li id="d8a6" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">Rob Pike 的 Google I/O 2012-Go 并发模式演讲。上市地点:<a class="ae jz" href="https://www.youtube.com/watch?v=f6kdp27TYZs" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=f6kdp27TYZs</a></li><li id="83f7" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">Google I/O 2013—same er aj mani 的高级 Go 并发模式。可在:<a class="ae jz" href="https://www.youtube.com/watch?v=QDDwwePbDtw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=QDDwwePbDtw</a></li></ul></div></div>    
</body>
</html>