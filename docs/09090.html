<html>
<head>
<title>Terraform — Backend Dynamic Configuration and Version Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terraform —后端动态配置和版本控制</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/terraform-backend-dynamic-configuration-and-version-control-2c1c26da2316?source=collection_archive---------2-----------------------#2022-07-29">https://blog.devgenius.io/terraform-backend-dynamic-configuration-and-version-control-2c1c26da2316?source=collection_archive---------2-----------------------#2022-07-29</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="dd4c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Terraform 后端文件管理</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/6d422df5199a8ac49489a521a6aaa27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jvAHYTFCRMCqfAPsCdU5Q.png"/></div></div></figure><p id="bff8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我的上一篇 Terraform 文章:“<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/terraform-state-management-85bc622f731c"> Terraform —状态管理</a>”中，我谈到了基本的 Terraform 状态管理，并给出了一个如何使用 AWS S3 作为后端配置的例子。</p><h1 id="e505" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">动态后端配置</h1><p id="2c93" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">一些读者注意到，我到目前为止所写的代码中的配置项基本上都是硬编码的。Terraform 支持运行时变量的动态赋值吗？答案是肯定的，Terraform 可以通过变量 variable 将值传递给提供者、数据和资源。</p><p id="2edd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是，有一个例外，那就是后端配置。后端配置只允许硬编码，或者不传递值。</p><p id="5d85" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这个问题是由 Terraform 运行时本身的运行顺序造成的。直到 2019 年 5 月，官方才给出解决方案，即“部分配置”。</p><p id="e8b1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">简而言之，我们不在后端语句中给出具体的配置:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="31ae" class="mr lq ir mn b gz ms mt l mu mv">terraform {<br/>  required_version = "~&gt;0.13.5"<br/>  required_providers {<br/>    ucloud = {<br/>      source  = "ucloud/ucloud"<br/>      version = "&gt;=1.22.0"<br/>    }<br/>  }<br/>  backend "consul" {<br/><br/>  }<br/>}</span></pre><p id="b4d2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">而是在另一个单独的文件中给出相关的配置。例如，我们在工作目录中创建一个名为<code class="fe mw mx my mn b">backend.hcl</code>的文件:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="9e0a" class="mr lq ir mn b gz ms mt l mu mv">address = "localhost:8500"<br/>scheme  = "http"<br/>path    = "my-ucloud-project"</span></pre><p id="7a11" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">本质上，我们将原来属于后端 consul 部分的属性分配代码重新定位到一个单独的<code class="fe mw mx my mn b">hcl</code>文件中，然后在执行 terraform init 时添加 backend-config 参数:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="0d99" class="mr lq ir mn b gz ms mt l mu mv">$ terraform init -backend-config=backend.hcl</span></pre><p id="0a04" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这样也能初始化成功。通过这种打补丁的方式，我们可以重用他人预先编写的 Terraform 代码，并以单独的 backend-config 文件的形式传入我们自己的后端配置信息，以便在执行过程中进行初始化。</p><h1 id="ec98" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">后端权限控制和版本控制</h1><p id="bcf8" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">后端本身不设计任何权限和版本控制，完全取决于具体的后端实现。</p><p id="0fa9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">以 AWS S3 为例，我们可以为不同的桶设置不同的 iam，防止开发人员和测试人员直接操作生产环境，或者给某些人状态信息的只读权限。</p><p id="96af" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，我们还可以启用 S3 版本控制功能，以防我们误修改了状态文件(Terraform 命令行有修改状态的相关说明)。</p><p id="c07b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你在寻找一个实现的例子，可以参考我上一篇文章“<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/terraform-state-management-85bc622f731c"> Terraform —状态管理</a>”关于如何为 Terraform 后端配置 AWS S3 和 dynamo DB。</p><h1 id="79c2" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">状态的独立存储</h1><p id="be7e" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">现在我们已经讨论了后端，是时候讨论另一个问题了。假设我们的 Terraform 代码可以创建一个公共基础设施，比如云中的<code class="fe mw mx my mn b">EKS</code>、<code class="fe mw mx my mn b">ECS</code>或<code class="fe mw mx my mn b">EMR</code>集群，那么我们可能必须为许多团队创建和维护这些相似但独立的集群，或者我们希望为部署的应用程序维护四个不同的环境，如开发、测试、预发布和生产。</p><p id="f535" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么如何实现不同的部署，将状态文件彼此分开存储和管理呢？</p><p id="6e80" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一个简单的方法是把它们分成不同的文件夹进行存储。让我们来看看下图:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mz"><img src="../Images/167bc96a76a6dac2763df119c5a69a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHAPfn1E2jo3Zm9dIzyFhA.png"/></div></div></figure><p id="09b2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以将不同产品的不同部门使用的基础架构划分到不同的文件夹中，在文件夹中维护相同的代码文件，配置不同的后端配置，并将状态文件保存在不同的后端。<strong class="ku is">这种方法可以给出最大程度的隔离，缺点是我们需要复制很多份相同的代码</strong>。</p><p id="2250" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">第二种更轻量级的方法是 workspace。<strong class="ku is">注意，Terraform 开源版的工作空间和 Terraform 云服务的工作空间其实是两个不同的概念。</strong>这里介绍的是开源版本的工作区。</p><p id="8719" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Workspace 允许我们在同一个文件夹中使用相同的后端配置，但是保持任意数量的相互隔离的状态文件。在我们之前使用 AWS S3 作为后端的例子中:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj na"><img src="../Images/8a9f82437f042b9bd56d8dcb380ab5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0eV8WZ80nKIUbaTE.png"/></div></figure><p id="4b85" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">目前我们有一个名为<code class="fe mw mx my mn b">terraform.state</code>的状态文件。然后，我们在工作目录中执行如下命令:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="bf29" class="mr lq ir mn b gz ms mt l mu mv">$ terraform workspace list<br/>* default</span><span id="6202" class="mr lq ir mn b gz nb mt l mu mv">$ terraform workspace new feature1<br/>Created and switched to workspace "feature1"!</span><span id="bf6d" class="mr lq ir mn b gz nb mt l mu mv">You're now on a new, empty workspace. Workspaces isolate their state,<br/>so if you run "terraform plan" Terraform will not see any existing state<br/>for this configuration.</span><span id="8f3b" class="mr lq ir mn b gz nb mt l mu mv">$ terraform workspace list<br/>  default<br/>* feature1</span></pre><p id="9bd9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">通过调用 workspace 命令，我们成功地创建了一个名为<code class="fe mw mx my mn b">feature1</code>的工作空间。此时我们观察<code class="fe mw mx my mn b">.terraform</code>文件夹:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/78b8e20a610ad4d233fbbdedff99f1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*-AIlUg-e-xYeHvO5Wh10DA.png"/></div></figure><p id="08f6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们会找到一个环境文件，它的内容是<code class="fe mw mx my mn b">feature1</code>。这实际上是 Terraform 用来保存当前上下文正在使用的工作空间的文件。</p><p id="6d72" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在，在 AWS S3 存储桶中，您将看到一个名为“env:”的新路径已经创建:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nd"><img src="../Images/3c1160f4dec84e3ae6fdcdf3cb9812e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57meiWaC0qGiTRpbt61i4Q.png"/></div></div></figure><p id="d974" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在这个新的工作区中，已经有一个<code class="fe mw mx my mn b">terraform.tfstate</code>文件，这意味着状态已经被成功地写入到<code class="fe mw mx my mn b">feature1</code>的状态文件中。</p><p id="6552" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以使用以下命令查询当前后端下的所有工作区:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="8c70" class="mr lq ir mn b gz ms mt l mu mv">$ terraform workspace list<br/>  default<br/>* feature1</span></pre><p id="2639" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们有两个工作空间，default 和 feature1，我们目前正在开发 feature1。我们可以使用以下命令切换回默认值:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="f080" class="mr lq ir mn b gz ms mt l mu mv">$ terraform workspace select default<br/>Switched to workspace "default".</span></pre><p id="def4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以使用以下命令确认我们成功切换回了默认设置:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="9479" class="mr lq ir mn b gz ms mt l mu mv">$ terraform workspace show<br/>default</span></pre><p id="72ea" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以使用以下命令删除功能 1:</p><pre class="kh ki kj kk gu mm mn mo mp aw mq bi"><span id="0fc2" class="mr lq ir mn b gz ms mt l mu mv">$ terraform workspace delete feature1<br/>Deleted workspace "feature1"!</span></pre><p id="e289" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">再次查看 S3 桶，您会发现 feature1 的状态文件已被删除:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ne"><img src="../Images/98afe1845ca7b5a0c86dc6fffd2e13ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7G0cWFxM-6lkmLlFhpH0g.png"/></div></div></figure><h1 id="37d3" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">文件夹与工作区</h1><p id="92fd" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">与多文件夹隔离方法相比，基于工作空间的隔离更简单。你只需要保存一段代码。您不需要在代码中为工作区编写额外的代码。您可以使用命令行在不同的工作空间之间来回切换。</p><p id="642d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是，Workspace 的缺点也很明显。由于所有工作区的后端配置都是一样的，所以对某个工作区有读写权限的人可以读取同一后端路径下的所有其他工作区；此外，工作区是隐式配置的(调用命令行)，所以有时人们会忘记他们正在哪个工作区工作。</p><p id="9a57" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Terraform 对于 Workspace 的官方场景是，有时候开发者想要对现有的基础设施做一些改变，进行一些测试，但是不想直接冒险修改现有的环境。这时候他就可以用 Workspace 复制一个与现有环境完全一致的并行环境，在这个并行环境中做一些改变，进行测试和实验。</p><p id="6fa9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">工作空间对应于源代码管理模型中的主干-分支模型。如果团队想要维护不同产品之间的不同基础设施，或者开发、测试、预发布和生产环境，最好使用不同的文件、文件夹和不同的后端配置进行管理。</p></div></div>    
</body>
</html>