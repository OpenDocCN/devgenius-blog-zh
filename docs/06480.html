<html>
<head>
<title>Why is multi-threaded Python so slow?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程 Python 为什么这么慢？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-is-multi-threaded-python-so-slow-f032757f72dc?source=collection_archive---------2-----------------------#2022-01-11">https://blog.devgenius.io/why-is-multi-threaded-python-so-slow-f032757f72dc?source=collection_archive---------2-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d525" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多线程 Python 为什么这么慢？真相和可能的解决方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/280e12c1216554cc088dfeebde285f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNqGaC86BPvVrHoK9vAs_g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">戴维·克洛德在<a class="ae ky" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="508c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a6a1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">与人们的预期相反，由于 Python 全局解释器锁(GIL)，当使用多线程来计算纯 CPU 绑定的 Python 代码时，人们不会看到整体处理时间的减少。官方文档解释说，GIL 是阻止线程完全并发执行的瓶颈，导致 CPU 利用率不足[ <a class="ae ky" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae ky" href="https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]。</p><p id="8e8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了有效地使用 CPU，需要避开 GIL，使用<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mc">ProcessPoolExecutor</em></a>或<a class="ae ky" href="https://docs.python.org/3.8/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> Process </em> </a>模块<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#processpoolexecutor" rel="noopener ugc nofollow" target="_blank"> 3 </a>，<a class="ae ky" href="https://docs.python.org/3.8/library/multiprocessing.html#introduction" rel="noopener ugc nofollow" target="_blank"> 4 </a>。以下代码示例展示了如何使用<em class="mc"> ProcessPoolExecutor </em>和<em class="mc"> Process </em>模块代替<a class="ae ky" href="https://docs.python.org/3.8/library/threading.html#threading.Thread" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> Thread </em> </a>和<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mc">ThreadPoolExecutor</em></a>模块来减少整体处理时间。或者，也可以调用不是用 Python 编写的包，比如 NumPy 或 SciPy，以便更有效地利用 CPU [ <a class="ae ky" href="https://scipy-cookbook.readthedocs.io/items/ParallelProgramming.html" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]。</p><h1 id="b766" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">介绍</h1><p id="58fe" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当我开始使用 Python 时，经常有人警告我它的多线程太慢了。有人告诉我 Python 本质上是单线程的。受到彻底的警告后，我决定谨慎行事，基本上从不使用<a class="ae ky" href="https://docs.python.org/3.8/library/threading.html#module-threading" rel="noopener ugc nofollow" target="_blank"> <em class="mc">线程</em> </a>包，而是选择使用<a class="ae ky" href="https://docs.python.org/3.8/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> asyncio </em> </a>包中的功能，我偶尔会根据需要将它与<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mc">ProcessPoolExecutor</em></a>模块结合使用。因此，Python 多线程速度慢的问题并没有给我带来太大的不便，因为我所需的处理更多地受到 I/O 的限制，这意味着大多数时候我只需要等待外部 I/O，asyncio sleep 非常适合这种情况。</p><p id="09ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而最近好奇心战胜了我，我决定自己验证一下多线程 Python 是否真的像我被误导的那样慢。在下面的部分中，我将展示我在查阅官方文档和做一些我自己的测试后的发现。</p><h1 id="fcb3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Python 真的是单线程吗？</h1><p id="14fb" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">首先，我想确定 Python 是否能够产生线程。因此，我准备了一个非常简单的 Python 多线程测试用例，以便在多核 CPU 上执行。代码被执行，任务管理器被监控以查看父进程是否产生了任何可被操作系统识别的线程。测试显示进程产生的线程肯定存在。下面是任务管理器输出的屏幕截图。因此，很明显 Python 确实具有多线程能力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/489585d217a43a4e395d460bde255ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sC1y69EfFQa_hi9qAT78WA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="me">显示 Python 进程及其线程的任务管理器。</em></figcaption></figure><h1 id="ddc4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">关于多线程，官方文档是怎么说的？</h1><p id="c8f1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">多处理包的文档页面声明:“<em class="mc">多处理包提供了本地和远程并发，通过使用子进程而不是线程有效地避开了全局解释器锁。因此，多处理模块允许程序员在一台给定的机器上充分利用多个处理器。</em> " [ <a class="ae ky" href="https://docs.python.org/3.8/library/multiprocessing.html#introduction" rel="noopener ugc nofollow" target="_blank"> 4 </a></p><p id="cf4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，下面是关于 FAQ 页面上的 GIL 的内容:“<em class="mc">这并不意味着您不能在多 CPU 机器上很好地使用 Python！你只需要创造性地将工作分成多个进程，而不是多个线程。新的 concurrent.futures 模块中的 ProcessPoolExecutor 类提供了一种简单的方法……</em>"[<a class="ae ky" href="https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">2</a>]</p><p id="f72a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，Python 社区的成员有时会指出他们对多线程 Python 代码的明显性能不佳感到沮丧。Juergen Brendel 在给吉多·范·罗苏姆(Python 的创始人)的一封公开信中写道:“<em class="mc">对于那些不熟悉这个问题的人来说:GIL 是 Python 解释器中的一个锁，它有效地防止了多线程被并行执行，即使是在多核或多 CPU 系统上！</em> " [ <a class="ae ky" href="https://www.snaplogic.com/blog/an-open-letter-to-guido-van-rossum-mr-rossum-tear-down-that-gil" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]</p><p id="4d74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，毫无疑问，由于 GIL，多线程 Python 无法以最佳方式利用多核 CPU。文档建议使用过程来代替。</p><h1 id="be46" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">一系列测试</h1><p id="2bd6" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">为了独立验证文档中关于最佳并发性的建议，我们准备了一系列测试来进行评估。所有测试都用纯 Python 编写，执行相同的 CPU 绑定代码，但使用不同的并发策略。这些测试是:</p><ul class=""><li id="6689" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">测试 1:在没有任何线程或并发方式的情况下，连续执行一个函数八次。这是基线测试。</li><li id="48ed" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">测试 2:使用模块<em class="mc">线程</em>同时执行一个函数八次。</li><li id="7270" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">测试 3:使用模块<em class="mc"> ThreadPoolExecutor </em>执行一个函数八次。</li><li id="3e23" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">测试 4:在 asyncio 循环中使用模块<em class="mc"> ThreadPoolExecutor </em>执行一个函数八次。</li><li id="9b88" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">测试 5:使用模块<em class="mc"> ProcessPoolExecutor </em>执行一个函数八次。</li><li id="a165" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">测试 6:在 asyncio 循环中使用模块<em class="mc"> ProcessPoolExecutor </em>执行一个函数八次。</li></ul><p id="c23d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个测试重复十次，记录平均总处理时间用于比较。测试源代码可通过<a class="ae ky" href="https://github.com/PhiCygni/is-multi-threaded-python-slow" rel="noopener ugc nofollow" target="_blank">Github repo</a>获得。</p><h1 id="761c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 1:完全串行执行</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="be8b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 2:使用线程模块</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="8164" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 3:使用 ThreadPoolExecutor 模块</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="61f8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 4:在 asyncio 循环中使用 ThreadPoolExecutor</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="3343" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 5:使用 ProcessPoolExecutor 模块</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="23e2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试 6:在 asyncio 循环中使用 ProcessPoolExecutor</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="5c2d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">试验结果</h1><p id="071b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">测试结果显示，与多进程代码甚至串行执行相比，多线程代码确实要慢得多。令人惊讶的是，完全没有并发性的基线测试胜过了所有的线程测试。</p><p id="ea5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试结果还显示，如文档中所述，与线程解决方案相比，使用进程将提供更好的 CPU 利用率。使用流程后，总体处理时间大大减少，这一点显而易见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/5c61e5bdee6c4c7e8e64f64d5538f829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3P0UZvi6hL-Q3C-l2ullFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">测试结果显示了每种并发方法的平均总处理时间。</figcaption></figure><h1 id="fc7e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="7ef5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">利用 Python <a class="ae ky" href="https://docs.python.org/3.8/library/threading.html#threading.Thread" rel="noopener ugc nofollow" target="_blank"> <em class="mc">线程</em> </a>或<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mc">ThreadPoolExecutor</em></a>模块运行纯 CPU 绑定代码不会导致真正的并发执行。事实上，非线程化的完全序列化设计将优于线程化设计。这是因为 Python GIL 是阻止线程完全并发运行的瓶颈。通过使用<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mc">ProcessPoolExecutor</em></a>或<a class="ae ky" href="https://docs.python.org/3.8/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> Process </em> </a>模块，可以实现最佳的 CPU 利用率，这些模块可以避开 GIL，使代码更加并发地运行。</p><h1 id="3a6c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">参考</h1><p id="d217" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">[1]<a class="ae ky" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/GlobalInterpreterLock</a></p><p id="edd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[2]<a class="ae ky" href="https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/FAQ/library . html # can-t-we-get-rid-of-the-global-interpreter-lock</a></p><p id="ed0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[3]h<a class="ae ky" href="https://docs.python.org/3.8/library/concurrent.futures.html#processpoolexecutor" rel="noopener ugc nofollow" target="_blank">ttps://docs . python . org/3.8/library/concurrent . futures . html # processpoolexecutor</a></p><p id="ff84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[4]<a class="ae ky" href="https://docs.python.org/3.8/library/multiprocessing.html#introduction" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.8/library/multi processing . html #简介</a></p><p id="2e61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[5]<a class="ae ky" href="https://scipy-cookbook.readthedocs.io/items/ParallelProgramming.html" rel="noopener ugc nofollow" target="_blank">https://scipy-cookbook . readthedocs . io/items/parallel programming . html</a></p><p id="9e48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[6]<a class="ae ky" href="https://www.snaplogic.com/blog/an-open-letter-to-guido-van-rossum-mr-rossum-tear-down-that-gil" rel="noopener ugc nofollow" target="_blank">https://www . snap logic . com/blog/an-open-letter-to-Guido-van-rossum-Mr-rossum-tear-down-that-Gil</a></p></div></div>    
</body>
</html>