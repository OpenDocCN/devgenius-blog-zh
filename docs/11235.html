<html>
<head>
<title>Simple Min Max Chess AI in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的简单最小最大国际象棋人工智能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simple-min-max-chess-ai-in-python-2910a3602641?source=collection_archive---------0-----------------------#2022-12-27">https://blog.devgenius.io/simple-min-max-chess-ai-in-python-2910a3602641?source=collection_archive---------0-----------------------#2022-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bbce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来到我的 Python 象棋教程系列的第 2 部分！在本教程中，我们将探索下棋的最小最大算法的基础。在第 3 部分中，我们将在这个基础上进行改进。让我们开始吧！</p><p id="c3c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一部分:<a class="ae ki" href="https://medium.com/dev-genius/simple-interactive-chess-gui-in-python-c6d6569f7b6c" rel="noopener">https://medium . com/dev-genius/simple-interactive-chess-GUI-in-python-c 6d 6569 f 7 b 6 c</a></p><p id="443d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三部:【https://link.medium.com/UzqUcdVzbwb T2】</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="2b30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Min Max 是一种搜索算法，可用于确定双人游戏(如国际象棋)中的最佳走法。它的工作原理是考虑两个玩家所有可能的移动(给定一定的“深度”)，并选择最大化当前玩家价值同时最小化对手价值的移动。</p><p id="26be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中,“价值”一词可以简单地定义为每件物品的价值总和。对此最常见的定义如下:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/77f62cf06fca617b22abc9f234d4aad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*hbz9s_uLNhrP3yLJIK8i2A.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">棋子价值(维基百科)</figcaption></figure></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="kr ks kt ku gt lc ld le bn lf lg bi"><span id="9475" class="lh li in ld b be lj lk l ll lm">import chess<br/>from Simple_Display import main, main_one_agent, main_two_agent<br/>import random<br/>from copy import deepcopy<br/><br/>#an agent that moves randommly<br/>def random_agent(BOARD):<br/>    return random.choice(list(BOARD.legal_moves))<br/><br/>scoring= {'p': -1,<br/>          'n': -3,<br/>          'b': -3,<br/>          'r': -5,<br/>          'q': -9,<br/>          'k': 0,<br/>          'P': 1,<br/>          'N': 3,<br/>          'B': 3,<br/>          'R': 5,<br/>          'Q': 9,<br/>          'K': 0,<br/>          }<br/>#simple evaluation function<br/>def eval_board(BOARD):<br/>    score = 0<br/>    pieces = BOARD.piece_map()<br/>    for key in pieces:<br/>        score += scoring[str(pieces[key])]<br/><br/>    return score<br/><br/>#this is min_max at depth one<br/>def most_value_agent(BOARD):<br/><br/>    moves = list(BOARD.legal_moves)<br/>    scores = []<br/>    for move in moves:<br/>        #creates a copy of BOARD so we dont<br/>        #change the original class<br/>        temp = deepcopy(BOARD)<br/>        temp.push(move)<br/><br/>        scores.append(eval_board(temp))<br/><br/>    if BOARD.turn == True:<br/>        best_move = moves[scores.index(max(scores))]<br/><br/>    else:<br/>        best_move = moves[scores.index(min(scores))]<br/><br/>    return best_move</span></pre><p id="ae43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第一个代码块是最简单形式的最小最大算法。函数<strong class="jm io"> most_value_agent </strong>搜索可能的移动列表，并使用<strong class="jm io"> eval_board </strong>函数为结果游戏状态分配分数。</p><p id="17bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会看到，我们并不总是试图最大化这个得分函数，因为它取决于我们是否在寻找黑或白的最佳移动。白色的最佳分数是可能的最大值，而黑色的最佳分数是可能的最小值。我们可以这样做，因为国际象棋是一个零和游戏(<a class="ae ki" href="https://en.wikipedia.org/wiki/Zero-sum_game" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Zero-sum_game</a>)。</p><p id="eb28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定这个基础代理，我们可以用一个随机移动的代理来测试它，这是结果。(黑棋随机移动)</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/0b63464c53afd68ee2a4825100e4bf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lYnfHJ9-5tLf5cueRutVXQ.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">深度 1 的最小最大值(白色)与随机移动的代理(黑色)</figcaption></figure><pre class="kr ks kt ku gt lc ld le bn lf lg bi"><span id="82a4" class="lh li in ld b be lj lk l ll lm">def min_max2(BOARD):<br/>    moves = list(BOARD.legal_moves)<br/>    scores = []<br/><br/>    for move in moves:<br/>        temp = deepcopy(BOARD)<br/>        temp.push(move)<br/>        temp_best_move = most_value_agent(temp)<br/>        temp.push(temp_best_move)<br/>        scores.append(eval_board(temp))<br/><br/>    if BOARD.turn == True:<br/>        <br/>        best_move = moves[scores.index(max(scores))]<br/><br/>    else:<br/>        best_move = moves[scores.index(min(scores))]<br/><br/>    return best_move<br/><br/><br/>def min_maxN(BOARD,N):<br/>    moves = list(BOARD.legal_moves)<br/>    scores = []<br/><br/>    for move in moves:<br/>        temp = deepcopy(BOARD)<br/>        temp.push(move)<br/><br/>        if N&gt;1:<br/>            temp_best_move = min_maxN(temp,N-1)<br/>            temp.push(temp_best_move)<br/><br/>        scores.append(eval_board(temp))<br/><br/>    if BOARD.turn == True:<br/>       <br/>        best_move = moves[scores.index(max(scores))]<br/><br/>    else:<br/>        best_move = moves[scores.index(min(scores))]<br/><br/>    return best_move<br/>        <br/># a simple wrapper function as the display only gives one imput , BOARD<br/>def play_min_maxN(BOARD):<br/>    N=3<br/>    return min_maxN(BOARD,N)</span></pre><p id="ccca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第二个代码块扩展了<strong class="jm io">most _ value _ agent</strong>,通过进一步搜索，而不仅仅是立即行动。我们的<strong class="jm io"> min_max2 </strong>函数是深度为 2 的 Min Max 算法，这意味着它预测未来 2 步棋，并使其最有价值的棋步基础成为对手最有价值的棋步。</p><p id="f109" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以递归地实现这个过程到我们想要的任何深度 N。这个实现如<strong class="jm io"> min_maxN、</strong>所示，带有一个小包装函数<strong class="jm io"> play_min_maxN </strong>以代理的形式保存它。</p><p id="3e12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们测试这段代码，我们很快就会发现，计算深度大于 4 的<strong class="jm io"> min_maxN </strong>可能需要几分钟。因此，我们将不得不考虑其他方法来提高代理的性能。</p><p id="01ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与此同时，我们可以看看一个最小最大深度 3(白色)对随机移动代理(黑色)的游戏。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/fd8d835f96fc38b5f28a89a9adb824f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pfyKG_d96P45uMYRuqINrw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">我们可以看到它真的不是很好</figcaption></figure><p id="229c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看到这一点，我们可以指出几个关键缺陷:</p><ul class=""><li id="02a0" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">人工智能对其实际获胜条件没有概念(将死)</li><li id="9ad6" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">它没有像上面那样通过重复来绘画的概念</li><li id="b3a3" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">由于深度很低，几乎所有的移动都是同等的，所以总是选择移动列表中的第一个移动(通常是棋盘最右边的一个棋子)</li><li id="4d52" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">因此，它没有一个良好的开放的概念，如占用空间</li></ul><p id="af10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些想法以及更多内容将在第 3 部分中探讨。</p></div></div>    
</body>
</html>