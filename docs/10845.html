<html>
<head>
<title>Tossing a Coin With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用反作用力抛硬币</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tossing-a-coin-with-react-js-673be020e01c?source=collection_archive---------17-----------------------#2022-12-03">https://blog.devgenius.io/tossing-a-coin-with-react-js-673be020e01c?source=collection_archive---------17-----------------------#2022-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f9bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用 React、TailwindCSS 和 Firebase 托管可视化概率实验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d6b54dc92d357a88be535b30963753f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nIkTsDIGt2kz0Udc7M5yA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Dall-e 提示:一个扔硬币的机器人，数字艺术</figcaption></figure><p id="c7f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最近开始了一段旅程来提升我的网络开发技能。一个好的旧的 PHP/Bootstrap/JavaScript 设置托管在最新最好的共享托管产品上没有错，但我希望它的使用是一个积极的选择，而不是我的唯一选择。</p><div class="lr ls gp gr lt lu"><a rel="noopener  ugc nofollow" target="_blank" href="/a-basic-react-tailwind-and-firebase-deployment-fc96fcf43b6"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">基本的反应、顺风和火力基地部署</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">脱离多年标准共享主机的刺激</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">blog.devgenius.io</p></div></div><div class="md l"><div class="me l mf mg mh md mi kp lu"/></div></div></a></div><p id="0b2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在使用 React、Firebase 和 TailwindCSS 之后，我开发了<a class="ae mj" href="https://probabilityexperiments.com/" rel="noopener ugc nofollow" target="_blank">概率实验</a>，一个简单的抛硬币项目，作为应用我的理论知识和对以下概念的理解的一种方式:</p><ul class=""><li id="2544" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">使用 useState 钩子管理 React 中的状态，并通过组件树传递属性</li><li id="d564" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">基于状态处理程序有条件地呈现组件，例如打开和关闭模态元素。</li><li id="139e" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">在 React 上下文中使用本地 JavaScript map()方法</li><li id="fca8" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">在顺风 css 中使用前缀的响应式设计，例如 sm:bg-color-red-100</li><li id="f896" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">通过谷歌域名购买域名并指向 Firebase 主机。</li></ul><p id="ad8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终的结果非常简单。游客反复点击一个按钮，显示一个新的硬币，并更新基本统计数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/62d628406711fd2028c4ff4d0db6ee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aVtJlazFI1OESdXfE8ETyw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在 React 应用程序中投掷硬币的演示</figcaption></figure><h1 id="3b83" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">组件树</h1><p id="133e" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">React 的核心是关于组件——由 HTML、CSS 和可能的 JavaScript 逻辑组成的可重用构建块。</p><p id="79e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的站点的根是包含 React 应用程序所有子组件的<code class="fe nw nx ny nz b">&lt;App /&gt;</code>组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/d8f3eb2855cf9ec2781c0d9647ba147e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nwl4z-TP2phjk3lvP0jxAA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">概率实验的成分树图</figcaption></figure><p id="7502" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将来，我可能会添加更多抛硬币以外的场景，但是现在<code class="fe nw nx ny nz b">&lt;Experiments /&gt;</code>只包含两个子组件:<code class="fe nw nx ny nz b">&lt;CoinControls /&gt; </code>和<code class="fe nw nx ny nz b">&lt;CoinResults /&gt;</code>。</p><p id="a2bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>包含该网站的整体导航条，标题，统计以及按钮，以抛硬币的组件。它还包含隐藏的模态，直到用户单击信息图标。</p><h2 id="d943" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">使用 useState 钩子管理状态并通过组件树传递属性</h2><p id="41f5" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">在使用 React 时，有更高级的方法来管理状态，比如使用<code class="fe nw nx ny nz b">useReducer</code>、<code class="fe nw nx ny nz b">useContext</code>甚至通过 Redux 这样的整个库，但是我想探索用<code class="fe nw nx ny nz b">useState</code>钩子在组件之间保存和传递状态的基本思想。</p><p id="58fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，当按下 flip 按钮时，<code class="fe nw nx ny nz b">useState</code>与在各种组件之间传递的道具一起工作，触发硬币出现在结果部分，并更新统计数据。</p><p id="0055" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">&lt;Experiment /&gt;</code>组件包含一个<code class="fe nw nx ny nz b">coins</code>数组，它跟踪头部和尾部，以及更新和重置数组的函数:</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="91f5" class="or na iq nz b be os ot l ou ov">// INSIDE &lt;Experiment /&gt;<br/><br/>const [coins, setCoins] = useState([]);<br/><br/>const addCoinHandler = (coin) =&gt; {<br/>    setCoins((prevCoins) =&gt; {<br/>      return [coin, ...prevCoins];<br/>    });<br/>  };<br/><br/>const clearCoinsHandler = () =&gt; {<br/>    setCoins([]);<br/>  };</span></pre><p id="90a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">处理函数通过<code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>组件中的属性传递，同样硬币数组也传递给<code class="fe nw nx ny nz b">&lt;CoinResults /&gt;</code></p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="fd8b" class="or na iq nz b be os ot l ou ov">&lt;CoinControls onAddCoin={addCoinHandler} onReset={clearCoinsHandler} /&gt;</span></pre><pre class="ow on nz oo bn op oq bi"><span id="0a93" class="or na iq nz b be os ot l ou ov">&lt;CoinResults coins={coins} /&gt; </span></pre><p id="fbbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">处理函数通过<code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>组件中的 props 来访问；<code class="fe nw nx ny nz b">props.onAddCoin</code>和<code class="fe nw nx ny nz b">props.onReset</code>成为指向一个函数的指针，该函数实际上是在父组件<code class="fe nw nx ny nz b">&lt;Experiment /&gt;</code>中定义的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/23fcb817f75be3dbb17fc924f6e31bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*qoF5BKBicGhnHk-5HZ8dwQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">道具如何在父元素和子元素之间传递的示意图</figcaption></figure><p id="3f65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>内部，<code class="fe nw nx ny nz b">flipCoin</code>和<code class="fe nw nx ny nz b">reset</code>函数被定义，这些函数利用了从<code class="fe nw nx ny nz b">&lt;Experiment /&gt;</code>通过 props 传入的处理程序。这些新功能通过 props 进一步向下传递到组件树中:<code class="fe nw nx ny nz b">&lt;CoinFlip flip = {flipCoin} reset={reset}/&gt;</code>。</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="1e71" class="or na iq nz b be os ot l ou ov">// INSIDE &lt;CoinControls /&gt; <br/><br/>const flipCoin = () =&gt; {<br/>    const coin = Math.floor(Math.random() * 2);<br/>    if (coin === 0) {<br/>      setHeads(heads + 1);<br/>    } else {<br/>      setTails(tails + 1);<br/>    }<br/>    props.onAddCoin(coin);<br/>};<br/><br/>const reset = () =&gt; {<br/>    setHeads(0);<br/>    setTails(0);<br/>    setPHeads((0).toFixed(5));<br/>    setPTails((0).toFixed(5));<br/>    props.onReset();<br/>};</span></pre><p id="1d21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，单击<code class="fe nw nx ny nz b">&lt;CoinFlip /&gt;</code>组件中的一个按钮，调用其父组件<code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>中定义的<code class="fe nw nx ny nz b">flipCoin</code>函数，该函数又将一个新的头或尾硬币传递到组件树的更高处，最终到达<code class="fe nw nx ny nz b">&lt;Experiment /&gt;</code>中的硬币数组。</p><h2 id="96a4" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">基于状态处理程序的组件的有条件呈现</h2><p id="9ad4" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">任何 web 应用程序的一个关键方面是根据上下文隐藏和显示元素，在过去，我的实现在这方面相当笨拙。</p><p id="edd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React 中组件的条件呈现非常简单。它的使用示例如下所示:当标题旁边的 info 按钮被按下时，一个包含掷硬币概率细节的模态被添加到组件树中，然后当用户单击“OK”按钮或灰色周围区域时被移除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/fec041ff8e6b559a221e45b27fb33b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r_1Fis6Wwjmu014vYdYNMA.gif"/></div></div></figure><p id="cf9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TailwindCSS 使得样式化模态组件变得非常容易，<code class="fe nw nx ny nz b">className</code>被用来代替通常的<code class="fe nw nx ny nz b">class</code>属性。内容是通过 props 动态设置的，如果我设法添加更多的概率场景，可以很容易地改变组件的用途。</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="e187" class="or na iq nz b be os ot l ou ov">// INSIDE &lt;Modal /&gt;<br/>const Modal = (props) =&gt; {<br/>  <br/>   const backdrop = "fixed top-0 left-0 w-full h-full bg-black bg-opacity-80 z-1";<br/>  <br/>   const modal = "p-6 fixed w-5/6 lg:w-2/4 left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white rounded-lg shadow-lg z-100";<br/>  <br/>   const close = "py-2 px-8 text-center text-2xl border-4 cursor-pointer border-gray-600 bg-gray-100 rounded-lg w-24 h-12 flex justify-center items-center";<br/>  <br/>   return (<br/>    &lt;div&gt;<br/>      &lt;div className={backdrop} onClick={props.info}&gt;&lt;/div&gt;<br/>      &lt;div className={modal}&gt;<br/>        &lt;h1 className="text-4xl border-b-2"&gt;{props.title}&lt;/h1&gt;<br/>        &lt;p className="pt-4"&gt;<br/>          {props.description}<br/>        &lt;/p&gt;<br/>        &lt;p className="pt-4 text-center text-2xl"&gt;{props.formula}&lt;/p&gt;<br/>        &lt;p className="pt-4 text-center text-2xl"&gt;{props.formula2}&lt;/p&gt;<br/>        &lt;div className="flex justify-center p-4"&gt;<br/>            &lt;div className={close} onClick={props.info}&gt;OK&lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="a456" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">点击信息图标、灰色背景或“确定”按钮，触发<code class="fe nw nx ny nz b">&lt;CoinControls /&gt;</code>组件中的<code class="fe nw nx ny nz b">infoHandler</code>功能，并在<code class="fe nw nx ny nz b">info</code>常量时切换状态。这个布尔值位于 JavaScript 逻辑操作符<code class="fe nw nx ny nz b">&amp;&amp;</code>的左边，使模态组件在<code class="fe nw nx ny nz b">info</code>处于 true 状态时出现。</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="f9a7" class="or na iq nz b be os ot l ou ov">// INSIDE &lt;CoinControls /&gt; <br/>const [info, setInfo] = useState(false);<br/><br/>  //Funtion to display modal<br/>  const infoHandler = () =&gt; {<br/>    setInfo(!info);<br/>  };<br/><br/>// THEN SOMEWHAT LATER...<br/><br/>{info &amp;&amp; (<br/>        &lt;Modal<br/>          info={infoHandler}<br/>          title={modalTitle}<br/>          description={modalDescription}<br/>          formula={modalFormula}<br/>          formula2={modalFormula2}<br/>        /&gt;<br/>      )<br/>}</span></pre><h2 id="958d" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">在 React 上下文中使用原生 JavaScript map()方法</h2><p id="66ef" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">硬币数组只是一个 1 和 0 的列表，每次按下翻转按钮时都会添加到这个列表中。如上所述，列表通过 props 传递给<code class="fe nw nx ny nz b">&lt;CoinResults /&gt;</code>。</p><p id="f218" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用 array <code class="fe nw nx ny nz b">map()</code>方法，硬币出现在结果窗格中，并根据项目是 1 还是 0 有条件地应用样式；使用三元运算符<code class="fe nw nx ny nz b">condition ? IfTrue : IfFalse</code>，正面(0)显示为红色，反面(1)显示为红色</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="845b" class="or na iq nz b be os ot l ou ov">//INSIDE &lt;CoinResults /&gt;<br/><br/>const CoinResults = (props) =&gt; {<br/>    const h = "h-16 bg-red-100 border-2 border-red-600 rounded-full w-16 flex items-center justify-center text-4xl";<br/>    const t = "h-16 bg-amber-100 border-2 border-amber-600 rounded-full w-16 flex items-center justify-center text-4xl";<br/><br/>//Elsewhere ...<br/><br/>    {props.coins.map((coins, index) =&gt; (<br/>          &lt;div key={index} className={coins===0?h:t} &gt;<br/>              &lt;div className={coins===0?" flex select-none text-red-300":"flex text-amber-300"}&gt;<br/>                  {coins === 0 ? "H" : "T"}<br/>              &lt;/div&gt;<br/>           &lt;/div&gt;<br/>       ))};</span></pre><p id="36df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TailwindCSS 实用工具 classed 使分配一堆类变得容易。在某些地方，我把它们直接写到 JSX 表达式中，但是当它们变得相当长时，我把它们存储在它们自己的常量中，以便于整体阅读。</p><h2 id="a916" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">在尾部使用前缀的响应式设计</h2><p id="8077" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">在我最近的项目中，我选择使用 Bootstrap 作为我的 CSS 框架，虽然这使样式变得非常容易，但负面影响是我的网站会立即被识别为 Bootstrap。</p><p id="e00a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个项目的一个关键目标是在类中使用前缀来辅助响应式设计。这被证明非常容易实现。</p><p id="d944" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需一个简单的前缀，我就能确保网站从面向大屏幕的水平布局切换到面向移动设备的垂直布局。这是通过一个简单的<code class="fe nw nx ny nz b">md:</code>前缀实现的，该前缀说明了一种仅适用于中等及以上尺寸的款式。</p><pre class="kg kh ki kj gt on nz oo bn op oq bi"><span id="002a" class="or na iq nz b be os ot l ou ov">&lt;!-- INSIDE &lt;Experiments /&gt; --&gt;<br/><br/>&lt;div className="grid md:grid-cols-3"&gt;<br/>        &lt;CoinControls ... /&gt;<br/>        &lt;CoinResults  .../&gt; <br/>&lt;/div&gt;<br/><br/>&lt;!-- INSIDE &lt;CoinControls /&gt; --&gt;<br/>&lt;div className="md:col-span-1 ..."&gt;<br/>   ...<br/>&lt;/div&gt; <br/><br/>&lt;!-- INSIDE &lt;CoinResults /&gt; (props ommitted) --&gt;<br/>&lt;div className="md:col-span-2 ..."&gt;<br/>   ...<br/>&lt;/div&gt;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/dfc92c736dce5ad1d5c0cf0a2c6096a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6UCKma-nL6is7_5No7rtZA.gif"/></div></div></figure><p id="d60e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加前缀的方法同样适用于任何样式。</p><h2 id="8810" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">通过谷歌域名购买域名并指向 Firebase 主机</h2><p id="0306" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">这个项目的最终目标是将一个定制域指向 Firebase 上的一个项目。这也被证明是非常直接的。在 Firebase 托管面板中，我只需按照提示“添加自定义域”即可。从那里，我能够购买一个域名，并将其指向我的项目，免费的 SSL 和所有。如果这是你想要实现的目标，那么只需看看谷歌的指南就行了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/764654930d386c79495a5d557952bd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drcwDw8HQl0fb9JZzW9Vog.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">“添加自定义域”向导</figcaption></figure><h2 id="0bef" class="ob na iq bd nb oc od dn nf oe of dp nj le og oh nl li oi oj nn lm ok ol np om bi translated">最后的想法</h2><p id="8323" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">建立这个项目是一次很好的学习经历，我希望在将来能建立更多的概率实验。此外，反复抛硬币并看到结果回来比我想象的更有吸引力。我这样做了很多次，以至于我开始怀疑随机性是否真的是随机的，因为结果经常会偏离你所期望的 0.5。</p><p id="ab88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的代码是<a class="ae mj" href="https://github.com/reveleigh/probability-experiments" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="d50e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我喜欢写我的项目、学习和发现。如果你喜欢这篇文章，考虑关注我，看看我的其他帖子。</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/age-of-awareness/my-dog-ate-my-copilot-d9e3595018cd" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">我女儿以后有逾期作业也不会有压力</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">除非狗吃了她的副驾驶</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="pb l mf mg mh md mi kp lu"/></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://medium.com/age-of-awareness/where-my-teacher-mind-went-when-given-early-access-to-dall-e-2-b09b62278821" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">当我的老师提前接触到 Dall-E 2 时，他的思想去了哪里</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">从文本描述中生成真实的图像是一个反向的罗夏墨迹测试</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="pc l mf mg mh md mi kp lu"/></div></div></a></div><div class="lr ls gp gr lt lu"><a rel="noopener  ugc nofollow" target="_blank" href="/raspberry-pi-powered-flying-geese-clock-ebde0c76ffe6"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">树莓皮动力飞鹅时钟</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">用 Python 编程并通过 MQTT 控制的 led 灯让这种传统的被子图案栩栩如生</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">blog.devgenius.io</p></div></div><div class="md l"><div class="pd l mf mg mh md mi kp lu"/></div></div></a></div></div></div>    
</body>
</html>