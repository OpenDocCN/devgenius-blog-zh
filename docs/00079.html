<html>
<head>
<title>JavaScript Promises: A gentle introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 承诺:温和的介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-promises-a-gentle-introduction-8fec479c2998?source=collection_archive---------0-----------------------#2019-10-19">https://blog.devgenius.io/javascript-promises-a-gentle-introduction-8fec479c2998?source=collection_archive---------0-----------------------#2019-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d094a8360dfccb31d512c2592ce32e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVREWrORMvqmxOIz43vLjw.png"/></div></div></figure><p id="e165" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个新程序员在开始他们的旅程后都会偶然发现一些要点，其中之一就是承诺。</p><h2 id="6f94" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">让我给你一些介绍，你首先必须知道为什么要使用它们！</h2><p id="04e0" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">JavaScript 是一种单线程语言，不同于 Java 或其他多线程语言。这意味着只有一个线程在循环，寻找要执行的代码。这个线程一步一步地运行所有的代码，一行一行地运行，直到结束并停止。这一切都进行得很顺利，直到您编写的代码是同步的！你可能会问，没有任何延迟就执行的代码是同步代码吗？将打印带到控制台，在 div 数组上循环，您就明白了！另一方面，异步任务可能需要一些时间来执行，这反过来会使您的主线程等待，直到它完成执行。异步任务的例子可以是从外部数据源提取数据，或者将文件上传到服务器，使用 web worker(它允许您创建多个线程，让我们把它留到以后再说)等。因此，我们需要注意它们是如何执行的，这样你的用户就不会以为你的应用崩溃了就跑了。异步执行某些功能基本上意味着让主线程做其他事情，直到任务解决。</p><p id="daa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TL；DR →当您同步执行某个任务时，您会等待它完成，然后再继续执行另一个任务。当您异步执行某项任务时，您可以在它完成之前继续执行另一项任务。</p><blockquote class="lr ls lt"><p id="87ae" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">“Promise 对象用于延迟和异步计算”。-MDN</p></blockquote></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="fc82" class="mf ku in bd kv mg mh mi ky mj mk ml lb mm mn mo le mp mq mr lh ms mt mu lk mv bi translated">还有其他方法来处理异步任务，但是使用承诺是如何有效的呢？</h1><p id="0834" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">处理此类任务最常用的替代模式是通过函数回调。我们知道 JavaScript 是一种函数式编程语言，一旦第一个任务完成，我们可以使用回调的力量来执行其他任务。回调基本上是说，“完成后再做”。</p><p id="41da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如何使用回调来处理异步任务:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="95ba" class="kt ku in nb b gy nf ng l nh ni">function loadImage(src, parent, callback){<br/>  let img = document.createElement('img');<br/>  img.src = src;<br/>  img.onload = callback;<br/>  parent.appendchild(img);<br/>}</span></pre><p id="19c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">loadImage 函数简单地从 src 加载图像，然后调用回调函数来做它应该做的事情。乍一看，这似乎是一个很好的模式，但是一旦我们有更多的图像要加载，这就变得很麻烦了。想想看，嵌套的回调将继续加载图像，我们必须显式地定义它们。下面的代码片段说明了这一点:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="327c" class="kt ku in nb b gy nf ng l nh ni">loadImg('img1.jpg', imgContainer, function(){<br/>  loadImg('img2.jpg', imgContainer, function(){<br/>    loadImg('img3.jpg', imgContainer, function(){<br/>      loadImg('img4.jpg', imgContainer)<br/>      }<br/>    }<br/>  }<br/>)</span></pre><p id="5085" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是 4 个图像，想想当你有更多的图像要加载时的场景，这种场景通常被开发人员称为“末日回调金字塔”。</p><p id="a27f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，不是这样的，这种模式中的错误处理是痛苦的。</p><p id="be72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最佳实践是假设任何操作都可能在任何时候失败，尤其是异步操作。如果有错误，回调应该接收什么？如果有 JavaScript 错误怎么办？还是网络错误？你必须为每一次回调分配接球。我告诉过你，痛苦。</p><h1 id="16ff" class="mf ku in bd kv mg nj mi ky mj nk ml lb mm nl mo le mp nm mr lh ms nn mu lk mv bi translated">作为救世主的承诺</h1><p id="558b" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">让我们来看看如何使用承诺来解决上述问题。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="bd69" class="kt ku in nb b gy nf ng l nh ni">let sequence = get('example.json)<br/>  .then(doSomething)<br/>  .then(doSomething)</span></pre><p id="8076" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是给你一个承诺是如何工作的概念，我们还没有深入研究承诺，但是你仍然可以知道这段代码会做什么。不是吗？</p><h2 id="e5e3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">承诺可以有四种状态:</h2><ol class=""><li id="ee05" class="no np in jx b jy lm kc ln kg nq kk nr ko ns ks nt nu nv nw bi translated">完成(解决):成功了</li><li id="7c4b" class="no np in jx b jy nx kc ny kg nz kk oa ko ob ks nt nu nv nw bi translated">被拒:没用</li><li id="761c" class="no np in jx b jy nx kc ny kg nz kk oa ko ob ks nt nu nv nw bi translated">待定:仍在等待</li><li id="5d9f" class="no np in jx b jy nx kc ny kg nz kk oa ko ob ks nt nu nv nw bi translated">已解决:履行或拒绝</li></ol></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="4f6d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">语法:</h2><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3591" class="kt ku in nb b gy nf ng l nh ni">new Promise(function(resolve, reject){<br/>  if(workDone){<br/>    resolve()<br/>  }else{<br/>    reject()<br/>  }<br/>})</span></pre><p id="e659" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Promise 是一个构造函数，你可以把它存储为一个变量，也可以在你创建它的时候对它进行处理。</p><p id="315c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您向 promise 传递一个带有两个参数的函数，resolve 和 reject。这两个是回调，用于指定承诺何时实现或拒绝。</p><h2 id="c06d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">你传递什么来 resolve()和 reject()？</h2><p id="ffa5" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当 resolve 或 reject 被调用时，承诺被解决，此时链的下一部分，通常是. then()或。然后执行 catch()，传递给 resolve 或 reject 的任何值都将被传递给后续的。然后()或。catch()。(我们接下来会谈到它们。)</p><p id="acac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:如果没有传递任何东西给 resolve 或 reject，那么这完全没问题，链中的下一个链接只是接收 undefined。</p><p id="4ae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，你可以通过任何事情来解决和拒绝。但是你能通过一个承诺吗？是的，你可以。如果传递的值是一个承诺，那么传递的承诺将首先执行，然后无论它解析为什么值，都将传递给链中的下一个链接。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="d75c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:一个承诺只能解决一次，这意味着你不能给它两次解决的机会。我是说你可以，只是第二个不行。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="de08" class="kt ku in nb b gy nf ng l nh ni">new Promise(function(resolve, reject {<br/>  resolve("First"); // Works<br/>  resolve("Second); // Doesn't work<br/>})</span></pre><p id="54ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要给出的另一个类比是把承诺想象成你的代码周围的一个 try/catch 块，它将在一个不可预知的时间结束。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="4deb" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">连锁承诺/使用。然后()和。catch():</h2><p id="361f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">异步工作很少是孤立的，因此，您可能有许多相互依赖的异步操作。使用 Promise API。然后()也返回承诺。所以如果可以的话。然后()取消最初的承诺，你可以。然后()关闭。那么()是因为它们也是承诺。</p><p id="cde9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员通常使用术语“then-able”来描述 then()中的承诺。任何返回. then()的方法或对象都是“thenable”。</p><p id="1a42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，其他一些库也包含可命名对象。</p><p id="d9fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回想一下我们谈到的第一个例子，它说明了。那么()很清楚:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="756b" class="kt ku in nb b gy nf ng l nh ni">let sequence = get('example.json)<br/>  .then(doSomething)<br/>  .then(doSomething)</span></pre><p id="6440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当创建一个异步工作链时，链中的每个后续链接要么接收前一个承诺的已实现值，要么接收前一个承诺的返回值。then()函数。</p><p id="ba31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，您可以将从一个异步方法收集的信息传递给下一个异步方法。</p><p id="3ba2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">能够链接这些变量是一种非常强大的技术，可以简化复杂的异步工作序列。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="ed4d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">更深入地探究链接:</h2><p id="1ebe" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">看看这两段代码:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6c9d" class="kt ku in nb b gy nf ng l nh ni">get('example.json')<br/>  .then(resolveFunc)<br/>  .catch(rejectFunc)</span></pre><p id="8d75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且，</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6fc8" class="kt ku in nb b gy nf ng l nh ni">get('example.json')<br/>  .then(resolveFunc)<br/>  .then(undefined, rejectFunc)</span></pre><p id="d77b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">他们基本上在做同样的事情。</p><p id="7dc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">的完整函数签名。catch()是:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d6b4" class="kt ku in nb b gy nf ng l nh ni">.then(undefined, rejectFunc)</span></pre><p id="5c6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">的完整函数签名。那么()就是:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="47fd" class="kt ku in nb b gy nf ng l nh ni">get('example.json').then(resolveFunc, rejectFunc)</span></pre><p id="f175" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果在此解析之前没有 resolveFunc 和承诺，则此。然后()被一遍又一遍地跳过。然后调用()。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d255aa1797e3d8b113a442bd5df2f7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*j_2ZJcuErm0DQN8FCQD8hQ.png"/></div></figure></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="aa34" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">所有承诺:</h2><p id="b847" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">还有最后一个许诺法，你要学会用→。全部()</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="b8f8" class="kt ku in nb b gy nf ng l nh ni">Promise.all(arrayOfPromises)<br/>  .then(function(arrayOfValues){<br/>    //your code<br/>  }<br/>)</span></pre><p id="5c66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它接受一个承诺数组，执行这些承诺，然后按照与原始承诺相同的顺序返回一个值数组。如果所有的承诺都解决了，那么只有它有效。即使一个承诺不能解决，所有的失败。</p><p id="e3de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，arrayOfPromises 和 arrayOfValues 的顺序应该相同。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="2a4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结论:承诺是非常强大的，因为它们是可组合的，是一个完美 JS 开发的好工具。</p><p id="74d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这有所帮助。</p><p id="0921" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">别忘了你可以点击那个拍手图标 50 次。</p></div></div>    
</body>
</html>