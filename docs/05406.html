<html>
<head>
<title>Top Node.js Best Practices to Enhance Your Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Top Node.js增强项目结构的最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-node-js-best-practices-to-enhance-your-project-structure-9048ef5ecbc0?source=collection_archive---------0-----------------------#2021-08-04">https://blog.devgenius.io/top-node-js-best-practices-to-enhance-your-project-structure-9048ef5ecbc0?source=collection_archive---------0-----------------------#2021-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">目录:</strong></p><p id="330c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.介绍</p><p id="3fbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.Node.js项目结构的8个最佳实践！</p><p id="38c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.1.为您的项目构建文件夹组合</p><p id="cf8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.2.离散市场逻辑和API路线</p><p id="40ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.3.练习服务层</p><p id="72d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.4.工作线程</p><p id="9418" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.5.子进程</p><p id="9998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.6.应用依赖注入</p><p id="155b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.7.主导单元测试</p><p id="b232" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.8.练习第三方服务请求的附加层</p><p id="2d8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.最好应用Node.js实践:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fd443edac05657d8b2ca7c5b9205c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ri8W3LSfnLHSFVd-ghUbw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ilyapavlov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊利亚·巴甫洛夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding-project-structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">简介</strong></p><p id="fddd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js是市场上最令人惊讶的新技术之一，这迅速标志着它的辉煌，它已经发展成为过去十年中最流行的web开发框架之一。</p><p id="69da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Javascript有几个崇拜者，因为Node.js，许多开发人员可以不用浏览器编写Javascript代码，并构建服务器端web应用程序，这些应用程序肯定是非阻塞的、轻量级的、安全的、健壮的和可伸缩的。</p><p id="2adf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们将讨论和探索Node.js <a class="ae ky" href="https://www.tatvasoft.com/blog/node-js-best-practices/" rel="noopener ugc nofollow" target="_blank">最佳实践</a>。Node.js中的编程有两个方面——关于框架的内部机制和设计有效且可持续的Node.js应用程序的最佳开发实践。</p><p id="5dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解这些Node.js的实践有多神奇，首先我们需要努力学习一个框架的内部工作方式，这不仅有助于深入了解框架本身的过程和中间点，也有助于深入了解流行的编程范例和设计选择。</p><p id="4ba3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着时间的推移，这些较低层次的洞察力和知识会以编写代码的方式显示出来，并推动我们了解如何优化应用程序的加速和性能。</p><p id="a6cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js在幕后工作的一个重要方面是它的单线程、基于事件电路的设备，用于执行异步代码。我们将在本帖中更深入地探讨这一点。</p><p id="b389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将通过8个最佳实践帮助您确定Node.js的范围，这将是您在开始新的Node.js项目时需要记住的主要因素。这些组成了构建健壮应用程序的不同方面，包括整体结构、文件夹构建、模块化、编写完整代码、管理省份等等。</p><p id="6222" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某种形式上，这是我们对构建Node.js模块的理解的推断，以构建特定的基本规则和指导方针，为我们的项目构建坚如磐石的基础。</p><p id="d1b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章主要关注Node.js项目的组成。我们将概括介绍最佳应用程序设计，并讨论一些项目结构最佳实践，以帮助您构建Node.js应用程序。</p><p id="ef9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">node . js项目结构的8个最佳实践</strong></p><p id="8aa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来讨论一下什么是应用结构流程？这是一个规则和常见实践的集合，有助于开发Node.js开发人员的参与。</p><p id="8b87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面描述的Node.js项目架构最佳实践可以作为一个备忘单，帮助您为即将到来的项目发现优秀的架构课程。</p><ol class=""><li id="65ba" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">为您的项目构建文件夹组合</li></ol><p id="8bec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道应用中的每个部分需要多精确——如果你想要市场上最好的——文件夹是分类基本元素的理想地方。特别是，我们需要建立一个非常重要的划分，这就引出了我们下面的规则。</p><p id="3365" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.离散市场逻辑和API路线</p><p id="807e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像Express.js这样的框架非常棒。它们为我们提供了管理应用程序、方面和路线的不可思议的特性。有了这样的帮助，把我们的市场逻辑放到API路线中可能会很有意思。</p><p id="5886" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这将立即使他们成为庞大的，统一的部分，将暴露自己任性，费力阅读，并倾向于解散。另外，不要忽视应用程序的可测试性将会降低，从而导致开发时间延长。</p><p id="f8bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个时期，您可能会质疑解决这个问题的方法，以及您可以将业务逻辑清晰而智能地放在哪里。因此，为了避免这个问题，我们首先将它们分开，然后将它们放在我们的服务层，让我们了解一下如何操作。</p><p id="34cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.练习服务层</p><p id="de05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们所有市场逻辑的存储点。这是一个类的组合，所有的类都有自己的系统，它们将执行我们应用程序的核心逻辑。在这一层中，您需要忽略的唯一元素是到达数据库的内容；这应该由数据入口层来处理。</p><p id="fa5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们已经建立了这三个基本规则，接下来可以这样用图形描述结果:</p><ul class=""><li id="1021" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh li lf lg lh bi translated">背离API路线的市场逻辑</li><li id="f1c8" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated">从我们的API路线中脱离我们的市场逻辑。</li><li id="9d70" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated">然后可以显示下面的文件夹结构，将我们转回到直接规则1:节点应用程序的文件夹构造</li></ul><p id="bd76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这最后一部分，我们还可以发现关于我们的结构构思时的另外两个规则。</p><p id="3235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.工作线程</p><p id="2c63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工作线程有利于处理CPU密集型JavaScript方法。</p><p id="2fee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，不要将它们应用于输入/输出密集型服务。Node.js管理异步输入/输出比使用操作符更有效，正如Node.js文档中所定义的。</p><p id="8119" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在代码中，当我们在中央应用程序线程上时，开发人员可以创建一个Worker构造函数的实例。然后，我们将在else表单中处理CPU密集型业务，并用parentPort.postMessage('早安！')</p><p id="ba7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.子进程</p><p id="42a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管<a class="ae ky" href="https://dev.to/santhu210/is-node-js-really-single-threaded-16jj" rel="noopener ugc nofollow" target="_blank">是单线程的，</a> Node.js可以生成子进程来负责任务。尽管少量使用是有效的，但是过多的子进程会大大降低代码的完整性。</p><p id="a558" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">子进程从你的CPU上的保险开始，类似于内存消耗，这实践了你的机器的绑定支持。因此，重要的是不要生成比你机器中的元素更多的子进程。</p><p id="aeed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.应用依赖注入</p><p id="ebc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js充满了惊人的特性和附件，让开发人员的生活更加简单。但是，正如我们所理解的，由于可测试性和编程可管理性方面可能出现的困难，在大部分季节中，操作依赖项可能会相当麻烦。</p><p id="1fa3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一个解决方案，它被称为依赖注入。</p><p id="7196" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是一种软件配置模式，将一个或添加的依赖项或服务注入或通过背书转移到一个依赖对象中。</p><p id="f552" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过在Node.js应用程序中使用依赖注入，您可以做以下几件事情:</p><ul class=""><li id="0719" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh li lf lg lh bi translated">使用DI，您可以简化系统测试过程，将依赖项直接转移到您喜欢练习的模块，而不是硬编码它们</li><li id="e161" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated">避免无用的模块耦合，构建更易于管理的支持</li><li id="5bed" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated">刺激你的git-flow。接下来，您确定您的接口，它们将保持原样，因此您可以撤回任何合并战</li></ul><p id="ce57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果使用没有依赖注入的Node会怎么样？</p><p id="e890" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是可以管理的，但是作为一种方法来处理我们的代码仍然不是很合适。如果我们要求您修改此测试以利用示例数据库，将会出现问题。因为我们需要修改我们的代码来适应这个新的需求。</p><p id="e0f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.主导单元测试</p><p id="578f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们知道我们已经在我们的区域下进行了依赖注入，我们也可以为项目执行单元测试。测试是改进应用程序的一个特别关键的步骤。</p><p id="92e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">包括最终结果在内的整个项目流程都依赖于它，因为错误的代码会减少开发方法并造成其他困难。</p><p id="73e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试应用程序的一个简单方法是按部分检查它们，其目的是分离一段代码并检查其准确性。</p><p id="6f8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当它是关于过程化编程时，一个系统可能是一个排他的函数或方法。这个过程通常由编写代码的开发人员来完成。</p><p id="a7be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种方法，您将获得以下好处:</p><ul class=""><li id="06af" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh li lf lg lh bi translated"><strong class="jm io">高级代码质量:</strong>单元测试提高了代码的质量，帮助您在代码进入其他开发步骤之前识别出您可能忽略的困难。它将检测边缘情况，并让您编写更可靠的代码</li><li id="0a6a" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated"><strong class="jm io">病毒发现较早:</strong>这里的问题定位在非常初级的阶段。由于测试是由解决代码问题的开发人员继续实现的，错误将会被更早地检测出来，您将能够避开非常耗时的调试方法</li><li id="b3bd" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh li lf lg lh bi translated"><strong class="jm io">成本压缩:</strong>应用程序中的缺陷越少，调试花费的时间就越短，这意味着项目花费的资金就越少。时间在这里是一个主要的关键因素，因为这一宝贵的部分现在可以被指定为体现我们产品的独特功能</li></ul><p id="b47d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8.练习第三方服务请求的附加层</p><p id="1407" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，在我们的应用程序中，我们可能需要请求第三方服务来重新获得特定数据或完成一些服务。但是，如果我们不把这个命令放到一个不同的特定层，我们可能会进入代码的失控部分，因为代码太大而无法处理。</p><p id="8864" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决这个困难的一个简单方法是实践发布/订阅模式。这个设备是一个消息传递模型，在这个模型中，我们有对象来传递消息，邀请发布者，以及使它们成为命名订阅者的东西。</p><p id="02cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">公关人员不会把信息直接传送给特定的接收者。相反，他们会将发布的信息描述成特定的形式，而不了解哪些订户在与他们进行交易。</p><p id="26e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，订阅者会表现出与一个或多个团体交易的热情，并且只收到他们关心的消息——所有这些都不知道外面有哪些商人。</p><p id="6e78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好应用Node.js实践:</p><p id="19a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们介绍了Node.js架构的最佳实践——我们发现了它的单线程架构和用于管理异步代码的事件循环工具。</p><p id="536e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，它过渡到学习开发一个健壮的、可持续的、可伸缩的Node.js应用程序所需的不同方面。</p><p id="e51f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提到的8个最佳实践涵盖了从如何合理地构建项目到日志记录、实验、格式化、林挺到编写异步代码等等的所有内容。</p><p id="3e5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然您已经了解了构建可靠、健壮的Node.js应用程序的所有相关内容，那么继续前进，完成您在当前项目中研究的所有内容，或者从头开始构建一个应用程序，并将它们分发到业务领域。</p></div></div>    
</body>
</html>