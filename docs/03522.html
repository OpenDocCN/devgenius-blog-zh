<html>
<head>
<title>Understanding Function Closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 JavaScript 中的函数闭包</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-function-closures-in-javascript-200d406a70d0?source=collection_archive---------3-----------------------#2020-11-14">https://blog.devgenius.io/understanding-function-closures-in-javascript-200d406a70d0?source=collection_archive---------3-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="51d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript 中的函数闭包及实例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dfb4a85c02ca45f7204148f0c0d38ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pKL9_taBw6c3Ynjg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@arifriyanto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arif Riyanto </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c86c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是终结？</h1><p id="dc10" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">闭包是每个 JavaScript 开发人员都应该知道的概念。它允许您从内部函数访问外部函数的范围。在 JavaScript 中，闭包是在每次创建函数时创建的。准确理解闭包将有助于您编写更好、更高效、更干净的代码。</p><p id="8c88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将通过实际例子来探索 JavaScript 中的函数闭包。让我们开始吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/ac9a6378293e3ba100322fa66df3beea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZL6-d4knjWOzpOr0D1pcQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://mehdiouss315.medium.com/" rel="noopener">迈赫迪·奥西德</a>与❤️️一起创作的图像。</figcaption></figure><h1 id="21c9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">全局和局部变量</h1><p id="33a7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript 变量可以属于局部或全局范围。然而，全局变量可以通过<strong class="lq ir">闭包</strong>成为局部(私有)变量。</p><p id="1d06" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个<code class="fe mq mr ms mt b">function</code>可以访问函数中定义的所有变量，就像这样:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="c34b" class="my kx iq mt b gy mz na l nb nc">function myFunction() {<br/>  var a = 4;<br/>  return a * a;  //16.<br/>}</span></pre><p id="d43f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它还可以访问函数外部定义的变量。看看下面的例子:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="d6fc" class="my kx iq mt b gy mz na l nb nc">var a = 4;<br/>function myFunction() {<br/>  return a * a;   //16.<br/>}</span></pre><p id="94a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第一个例子中，变量<code class="fe mq mr ms mt b">a</code>是局部的，它只能在定义它的函数内部使用。另一方面，第二个例子中的变量是全局的，它可以被页面上(和窗口中)的所有脚本使用(和更改)。</p><h1 id="acb7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可变寿命</h1><p id="8e7f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">全局变量一直存在，直到页面被丢弃，就像当您导航到另一个页面或关闭窗口时。</p><p id="544e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">局部变量的寿命很短。它们是在调用函数时创建的，在函数完成时被删除。</p><h1 id="6d50" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一个反困境的例子</h1><p id="df32" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设你想用一个变量来计数，你想让这个计数器对所有函数都可用。你可以使用一个全局变量和一个<code class="fe mq mr ms mt b"><strong class="lq ir">function</strong></code>来增加计数器:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="2168" class="my kx iq mt b gy mz na l nb nc">// Initiate counter<br/>var counter = 0;<br/><br/>// Function to increment counter<br/>function add() {<br/>  counter += 1;<br/>}<br/><br/>// Call add() 3 times<br/>add();<br/>add();<br/>add();<br/><br/>// The counter should now be 3</span></pre><p id="3cc6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但这里的问题是，外面的任何代码都可以改变计数器，而不需要调用<code class="fe mq mr ms mt b"><strong class="lq ir">add()</strong></code>。计数器应该在<code class="fe mq mr ms mt b">add()</code>函数的本地，以防止其他代码改变它。看看下面的例子:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="5829" class="my kx iq mt b gy mz na l nb nc">// Initiate counter<br/>var counter = 0;<br/><br/>// Function to increment counter<br/>function add() {<br/>  var counter = 0;<br/>  counter += 1;<br/>}<br/><br/>// Call add() 3 times<br/>add();<br/>add();<br/>add();<br/><br/>//The counter should now be 3. But it is 0</span></pre><p id="4d72" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是行不通的，因为我们显示的是全局计数器，而不是本地计数器。我们可以移除全局计数器，并通过让函数返回它来访问局部计数器。</p><p id="f017" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看看这个例子:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="aaad" class="my kx iq mt b gy mz na l nb nc">// Function to increment counter<br/>function add() {<br/>  var counter = 0;<br/>  counter += 1;<br/>  return counter;<br/>}<br/><br/>// Call add() 3 times<br/>add();<br/>add();<br/>add();<br/><br/>//The counter should now be 3. But it is 1.</span></pre><p id="2ce1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它没有再次工作，因为我们每次调用该函数时都会重置本地计数器。一个 JavaScript <strong class="lq ir">内部函数</strong>可以解决这个问题。</p><p id="4bc1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下面的例子中，内部函数<code class="fe mq mr ms mt b">plus()</code>可以访问父函数中的变量<code class="fe mq mr ms mt b">counter</code>:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="3df9" class="my kx iq mt b gy mz na l nb nc">function add() {<br/>  var counter = 0;<br/>  function plus() {counter += 1;}<br/>  plus();   <br/>  return counter;<br/>}</span></pre><p id="dd13" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们能从外部接触到<code class="fe mq mr ms mt b">plus()</code>功能，这可能已经解决了计数器的难题。</p><p id="41a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还需要找到一种只执行一次<code class="fe mq mr ms mt b">counter =0</code>的方法。因此，这里我们需要一个 JavaScript <strong class="lq ir">闭包</strong>。</p><h1 id="b93a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">JavaScript 闭包</h1><p id="0329" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">看看下面的例子:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="0f36" class="my kx iq mt b gy mz na l nb nc">var add = (function () {<br/>  var counter = 0;<br/>  return function () {counter += 1; return counter}<br/>})();<br/><br/>add();<br/>add();<br/>add();<br/><br/>// the counter is now 3</span></pre><p id="4f3f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，变量<code class="fe mq mr ms mt b">add</code>被分配给一个自调用函数的返回值。自调用函数只运行一次。它将计数器设置为零(0)并返回一个函数表达式。这样，add 就变成了一个函数，它可以访问父作用域中的计数器。</p><p id="e6e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这被称为 JavaScript <strong class="lq ir">闭包。</strong>它使得函数拥有“私有”变量成为可能。计数器受匿名函数的作用域保护，只能使用 add 函数进行更改。</p><h1 id="3a17" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="99ca" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">闭包只是一个可以访问父作用域的函数，即使在父函数关闭之后。此外，我们使用闭包主要是为了在 JavaScript 中实现封装、迭代器和 singleton。这只是理解函数闭包的一个简单介绍，你需要从其他资源中学习更多。</p><p id="f92a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读这篇文章。</p><h1 id="2c3e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多阅读</h1><div class="nd ne gp gr nf ng"><a href="https://medium.com/javascript-in-plain-english/5-javascript-functional-programming-concepts-that-you-should-know-c96f14b02a87" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">你应该知道的 5 个 JavaScript 函数式编程概念</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">带有实际例子的函数式编程概念</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div></div></div>    
</body>
</html>