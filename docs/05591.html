<html>
<head>
<title>How to Deep Merge JavaScript Objects?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何深度合并 JavaScript 对象？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-deep-merge-javascript-objects-12a7235f5573?source=collection_archive---------2-----------------------#2021-09-14">https://blog.devgenius.io/how-to-deep-merge-javascript-objects-12a7235f5573?source=collection_archive---------2-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/007a0463dd945b488666b3ed799bb09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oH-I0xNUF8f1T98c"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@clayton_cardinalli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱顿·卡迪纳利</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.assign</code>方法或 spread 操作符让我们浅层合并 JavaScript 对象。</p><p id="9f20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着只有第一层被合并，但是更深的层仍然引用原始对象。</p><p id="ea7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度合并确保我们合并到另一个对象中的对象的所有级别都被复制，而不是引用原始对象。</p><p id="79ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何深度合并 JavaScript 对象。</p><h1 id="12ad" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">递归合并</h1><p id="80fc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了深度合并 JavaScript 对象，我们必须自己递归地合并每一层。</p><p id="696d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们必须编写自己的函数。</p><p id="a318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b8b4" class="mq lg iq le b gy mr ms l mt mu">const isObject = (item) =&gt; {<br/>  return (item &amp;&amp; typeof item === 'object' &amp;&amp; !Array.isArray(item));<br/>}</span><span id="9a0d" class="mq lg iq le b gy mv ms l mt mu">const mergeDeep = (target, ...sources) =&gt; {<br/>  if (!sources.length) return target;<br/>  const source = sources.shift();</span><span id="0e6c" class="mq lg iq le b gy mv ms l mt mu">if (isObject(target) &amp;&amp; isObject(source)) {<br/>    for (const key in source) {<br/>      if (isObject(source[key])) {<br/>        if (!target[key]) Object.assign(target, {<br/>          [key]: {}<br/>        });<br/>        mergeDeep(target[key], source[key]);<br/>      } else {<br/>        Object.assign(target, {<br/>          [key]: source[key]<br/>        });<br/>      }<br/>    }<br/>  }</span><span id="3599" class="mq lg iq le b gy mv ms l mt mu">  return mergeDeep(target, ...sources);<br/>}</span><span id="3606" class="mq lg iq le b gy mv ms l mt mu">const merged = mergeDeep({<br/>  a: 1<br/>}, {<br/>  b: {<br/>    c: 123<br/>  }<br/>});<br/>console.log(merged)</span></pre><p id="4c57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们通过检查<code class="fe lb lc ld le b">item</code>参数是否真实以及它是否是一个不是数组的对象来创建<code class="fe lb lc ld le b">isObject</code>辅助函数。</p><p id="fd0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe lb lc ld le b">typeof</code>操作符来检查对象是否是对象。</p><p id="a398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是真的并且它的类型是一个对象，那么它一定是一个对象。</p><p id="a9dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过使用<code class="fe lb lc ld le b">Array.isArray</code>方法检查这个对象不是一个数组。</p><p id="733c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建<code class="fe lb lc ld le b">mergeDeep</code>方法将多个对象合并到<code class="fe lb lc ld le b">target</code>对象中。</p><p id="419e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们首先检查是否有任何东西存储在<code class="fe lb lc ld le b">sources</code>中。</p><p id="e95b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有，那么我们返回<code class="fe lb lc ld le b">target</code>对象，因为没有第二个和随后的参数。</p><p id="20c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们检查<code class="fe lb lc ld le b">target</code>和<code class="fe lb lc ld le b">source</code>是否是对象。</p><p id="8623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过用<code class="fe lb lc ld le b">shift</code>从<code class="fe lb lc ld le b">source</code>数组中获取第一项来获取<code class="fe lb lc ld le b">source</code>。</p><p id="e3ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用 for-in 循环遍历<code class="fe lb lc ld le b">source</code>的键。</p><p id="a0f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果属性是一个对象，那么我们用<code class="fe lb lc ld le b">Object.assign</code>将一个空对象合并到<code class="fe lb lc ld le b">target</code>对象中。</p><p id="7b89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe lb lc ld le b">mergeDeep</code>将<code class="fe lb lc ld le b">source</code>的对象属性内的键递归合并到对象中。</p><p id="a2d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则我们有一个原语属性值，我们调用<code class="fe lb lc ld le b">Object.assign</code>直接合并到对象中。</p><p id="80ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们在最后返回合并的对象。</p><p id="94cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们用两个对象调用<code class="fe lb lc ld le b">mergeDeep</code>来试试。</p><p id="70b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而我们应该看到，<code class="fe lb lc ld le b">merged</code>是:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fa43" class="mq lg iq le b gy mr ms l mt mu">{<br/>  "a": 1,<br/>  "b": {<br/>    "c": 123<br/>  }<br/>}</span></pre><h1 id="069b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">洛达什合并法</h1><p id="27e7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们不想写自己的函数，那么我们可以使用 Lodash <code class="fe lb lc ld le b">merge</code>方法来合并对象。</p><p id="2027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c137" class="mq lg iq le b gy mr ms l mt mu">const merged = _.merge({<br/>  a: 1<br/>}, {<br/>  b: {<br/>    c: 123<br/>  }<br/>});</span></pre><p id="b4d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">merged</code>，我们得到相同的值。</p><h1 id="ba2b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="6d3c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用自己的 JavaScript 函数或 Lodash <code class="fe lb lc ld le b">merge</code>方法深度合并 JavaScript 对象。</p></div></div>    
</body>
</html>