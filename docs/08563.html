<html>
<head>
<title>Write Better Tests For Django With PyCharm’s Interactive Debugger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 PyCharm 的交互式调试器为 Django 编写更好的测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/write-better-tests-for-django-with-pycharms-interactive-debugger-1e55b49993f2?source=collection_archive---------5-----------------------#2022-06-24">https://blog.devgenius.io/write-better-tests-for-django-with-pycharms-interactive-debugger-1e55b49993f2?source=collection_archive---------5-----------------------#2022-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a774" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">PyCharm 的交互式调试器是如何成为我开发过程中的一个宝贵部分的，它也应该成为你的一部分。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/35c01c9020e29947367667290da00a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuqTAkNF7CgWpCXXGWVF1g.jpeg"/></div></div></figure><p id="bb80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">PyCharm 的交互式调试器将帮助您更快地编写更健壮的代码，帮助您理解工作流，并更容易地找到和调试代码中的错误。</p><p id="f9a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将在 PyCharm 上完成一个基本的 Django 项目的设置。我们将安装<code class="fe lk ll lm ln b">pytest</code>并向您展示如何将其启用为默认的测试运行程序。最后，我们将向您展示如何使用调试器来查找和修复一些错误，以及如何在您的日常开发工作流程中使用它。最后还有奖金，所以不要走。</p><p id="d00e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果阅读不适合你，这里还有一个短视频<a class="ae lo" href="https://youtu.be/pQNZoEopBq0" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="3912" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">项目设置</h1><p id="1d08" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">这篇文章中的所有内容都可以用 PyCharm 的社区版来完成，所以请直接从他们的网站上为您的系统下载的免费版本。如果您遵循默认的安装说明，几分钟后您就可以开始使用了。我们显然需要一个项目来合作，我已经有了一个，你可以从<a class="ae lo" href="https://github.com/the-nonlinearity/your-first-django-app/tree/start" rel="noopener ugc nofollow" target="_blank"> Github </a>拉。该项目基于<a class="ae lo" href="https://docs.djangoproject.com/en/3.2/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank">编写你的第一个 Django 应用</a>教程，你可以在他们的网站上找到。如果你是一个初学者或者想温习一些基础知识，我强烈推荐你跟随教程。我还将上传另一篇关于编写和发布你自己的可重用 Django 包的文章。</p><p id="a24d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从克隆来自<a class="ae lo" href="https://github.com/the-nonlinearity/your-first-django-app/tree/start" rel="noopener ugc nofollow" target="_blank">库</a>的代码开始。现在我们已经准备好了编辑器和代码，让我们开始在 PyCharm 上设置我们的项目。</p><h2 id="cbc2" class="mm lq in bd lr mn mo dn lv mp mq dp lz kx mr ms mb lb mt mu md lf mv mw mf mx bi translated">1.打开您的项目</h2><p id="6835" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">使用顶部导航在 PyCharm 中打开您的项目。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/25d5d35930fbb440a68aebcaf2732ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*evFJSpg21t_aColQ9H0uxg.png"/></div></figure><p id="b8b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">导航到克隆项目的位置，并在新窗口中打开基础项目文件夹。您应该看到以下内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/3a2b5e378ac1b5eeed59f3de519dee93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yFIVd0P-VnL7-yD3LhdEqA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">你第一次打开 Django 应用的时候。</figcaption></figure><p id="4019" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">随着项目的打开，我们可以开始为我们的项目配置设置。</p><h2 id="8c2e" class="mm lq in bd lr mn mo dn lv mp mq dp lz kx mr ms mb lb mt mu md lf mv mw mf mx bi translated">2.创建或使用虚拟环境</h2><p id="4408" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">默认情况下，PyCharm 将使用您默认拥有的任何 python 解释器，但是您很可能总是希望至少在虚拟环境中运行您的项目。您可以从设置(首选项)窗口直接创建一个或添加一个现有的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/be89d944298bca3ee31146878923dd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g592_iOSGB1GrgAkUUN47w.png"/></div></div></figure><p id="ab0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我使用<code class="fe lk ll lm ln b">pyenv</code>，因此我将添加我在项目设置期间创建的现有环境，但您可以点击右上角的齿轮，创建一个新环境或添加您自己的环境。请注意，您希望将您的 python 解释器更改为<code class="fe lk ll lm ln b">python3</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/24b2f1d422d074369e274cb424a9e65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EX6ljSyLnMTbCIOoOdTBXw.png"/></div></div></figure><p id="b34a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建了新的虚拟环境后，您现在应该会看到如下内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/52293673f431def125d0a7a1a509d61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Q61WcyLp1LNGtOTFkZmeg.png"/></div></div></figure><p id="5c21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，您将看到默认情况下安装在虚拟环境中的软件包。您会注意到 Django 还没有安装。我们现在会解决这个问题。</p><p id="a19c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">用户可以直接从这里安装软件包，也可以从命令行直接在虚拟环境中安装软件包。我们将使用命令行，因为我们还想将我们的包添加到项目的<code class="fe lk ll lm ln b">requirements.txt</code>文件中，以便跟踪我们将使用的内容。</p><p id="f724" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将下面的<code class="fe lk ll lm ln b">requirements.txt</code>文件添加到项目的基本目录中。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="7f89" class="mm lq in ln b gy nk nl l nm nn">Django==4.0.4<br/>pytest==7.1.2<br/>pytest-django==4.5.2</span></pre><p id="addf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以用<code class="fe lk ll lm ln b">pip install -r requirements.txt</code>来安装需求，它会安装你所有的需求。</p><h2 id="6b70" class="mm lq in bd lr mn mo dn lv mp mq dp lz kx mr ms mb lb mt mu md lf mv mw mf mx bi translated">3.设置测试跑步者</h2><p id="93a6" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">为了使用<code class="fe lk ll lm ln b">pytest</code>包来运行我们的测试，我们需要再改变一个配置设置。导航到<code class="fe lk ll lm ln b">Tools&gt;Python Integrated Tools</code>并将默认测试运行器设置为<code class="fe lk ll lm ln b">pytest</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/a7eebe6bafa12cbbf939522231578ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HomkBtPTkLbsxeoIhe0-A.png"/></div></div></figure><p id="d548" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还需要告诉<code class="fe lk ll lm ln b">pytest</code>在哪里可以找到我们的项目设置文件。所以我们将下面的<code class="fe lk ll lm ln b">pytest.ini</code>文件添加到我们的项目中。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="cfdb" class="mm lq in ln b gy nk nl l nm nn">[pytest]<br/>DJANGO_SETTINGS_MODULE=mysite.settings<br/>python_files = tests.py test_*.py *_tests.py</span></pre><p id="7a20" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很好，现在我们已经设置好了项目，我们现在可以开始编写一些代码并使用交互式调试器了。</p><h1 id="bfa7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">编写我们的第一个测试</h1><p id="6cdb" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在我们做任何进一步的事情之前，我们将以纯 TDD 的方式编写我们的第一个测试用例。将以下代码添加到<code class="fe lk ll lm ln b">polls/tests.py</code>文件中。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="1d8e" class="mm lq in ln b gy nk nl l nm nn">from django.test import TestCase<br/>from django.urls import reverse<br/><br/><br/>class IndexViewTests(TestCase):<br/>    def test_index(self):<br/>        <em class="no">"""<br/>        Test the index page.<br/>        """<br/>        </em>response = self.client.get(reverse('polls:index'))<br/>        assert response.status_code == 200</span></pre><p id="e121" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在您将能够在 PyCharm UI 中导航到您的测试，右键单击<code class="fe lk ll lm ln b">test_index</code>并选择<code class="fe lk ll lm ln b">Run 'pytest for tests.IndexViewTests.test_index'</code>。这将运行您的单一测试。您可以对测试类或整个<code class="fe lk ll lm ln b">tests.py</code>文件进行同样的操作。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/a9209fea21c7811fbe5f6c8b77cb5fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d5rklufPWTNpt-gjcY62w.png"/></div></div></figure><p id="4d6f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，您将看到测试失败，并且在下面的控制台中会有一些输出。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/49d7f6a2212e44a16098817f65856538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsJ1Kitg0izbfHRDWwRJ6g.png"/></div></div></figure><p id="c85f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以使用我们的错误输出来修复我们的测试。由于我们没有在 Django 中定义视图或 url，我们应该知道这就是为什么我们的测试失败并出现<code class="fe lk ll lm ln b">NoReverseMatch</code>异常。幸运的是，我们可以通过添加索引页面视图和 url 映射来快速修复这个问题。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="e761" class="mm lq in ln b gy nk nl l nm nn"># polls/views.py<strong class="ln io"><br/>from</strong> <strong class="ln io">django.http</strong> <strong class="ln io">import</strong> HttpResponse<br/><br/><br/><strong class="ln io">def</strong> index(request):<br/>    response_text = "Hello, world. You're at the polls index."<br/>    <strong class="ln io">return</strong> HttpResponse(response_text)</span></pre><p id="77a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">和投票应用程序 url</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="ffe8" class="mm lq in ln b gy nk nl l nm nn"># polls/urls.py<br/><strong class="ln io">from</strong> <strong class="ln io">django.urls</strong> <strong class="ln io">import</strong> path<br/><br/><strong class="ln io">from</strong> <strong class="ln io">.</strong> <strong class="ln io">import</strong> views<br/><br/>app_name = 'polls'<br/>urlpatterns = [<br/>    path('', views.index, name='index'),<br/>]</span></pre><p id="d5cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后将投票应用程序 URL 添加到<code class="fe lk ll lm ln b">mysite/urls.py</code>中的站点 URL。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="cb1a" class="mm lq in ln b gy nk nl l nm nn">urlpatterns = [<br/>    path('polls/', include('polls.urls')),<br/>    path('admin/', admin.site.urls),<br/>]</span></pre><p id="be01" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以使用 PyCharm 中的<code class="fe lk ll lm ln b">alt+return</code>快捷方式添加 include 导入。将鼠标悬停在缺少的导入上，然后按下<code class="fe lk ll lm ln b">alt+return</code>，它会提示您是否要添加导入。只要确保选择正确的导入即可。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/523be8101400856b61a525a09f4aadca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOlJnq603iVMtrTkWywTkw.png"/></div></div></figure><p id="d820" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再次运行我们的测试，现在应该通过了。既然我们已经建立了项目并运行了测试，我们可以开始使用 PyCharm 中的交互式调试器了。</p><h1 id="bda9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">交互式调试器</h1><p id="3602" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">我们现在可以使用调试器来检查我们编写的代码。为了使用调试器，我们需要在 PyCharm 的调试模式下运行测试，并且我们希望在代码中添加一个断点。您可以在视图代码中添加断点，方法是单击行号旁边的装订线。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/96cd36da5bd5b1324a5652380f2097db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrDzQGuZWQW8pm8-9635fg.png"/></div></div></figure><p id="3753" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在使用调试模式运行测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/707436fc90d3994a4dcdddcd59b2d718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEnK0Dp35ykY3oVsFUZl0Q.png"/></div></div></figure><p id="bedf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">测试现在将在断点处暂停执行。您将看到函数中变量的预览将显示在指向断点的行中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/c9a4a8c463bd07f73e023bc24699e575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7wv8JJfqoKK3ckKEbQJwQ.png"/></div></div></figure><p id="f9f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，最有价值的是在下面的交互窗口中，您可以在这里进一步检查变量，并使用其他各种可用的执行选项继续执行。在此视图中还可以设置其他配置和视图。我们将在下面讨论这些。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/f9e9b02b447c792a7bca6a4e898908af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCgRaiOm6nMejX9icO-Zag.png"/></div></div></figure><p id="8e54" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">PyCharm 的文档包含了调试时可用的各种功能的大量示例，我将只详细说明我最常用的功能。</p><ol class=""><li id="e653" class="nv nw in kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated"><strong class="kq io">跨过</strong></li><li id="b2fd" class="nv nw in kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><strong class="kq io">进入我的代码</strong></li><li id="6f8e" class="nv nw in kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><strong class="kq io">评估表达式</strong></li></ol><p id="caec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们深入研究这些之前，让我们跳到 Django 教程，这样我们就有一个更好的测试来调试。从存储库中签出第 5 部分标签。</p><p id="72ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用我们之前使用的右键单击并运行来运行<code class="fe lk ll lm ln b">test_was_published_recently_with_future_question</code>测试，我们看到测试如预期的那样失败了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/9da6a9ffc8dccd064d63f754beb6ece6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioSxOTVX_1iSt0gkcoPDKw.png"/></div></div></figure><p id="811c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看看测试中会发生什么。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="78b3" class="mm lq in ln b gy nk nl l nm nn"><strong class="ln io">def</strong> test_was_published_recently_with_future_question(self):<br/>    <em class="no">"""<br/>    was_published_recently() returns False for questions whose pub_date<br/>    is in the future.<br/>    """<br/>    </em>time = timezone.now() + datetime.timedelta(days=30)<br/>    future_question = Question(pub_date=time)<br/>    self.<strong class="ln io">assertIs</strong>(future_question.was_published_recently(), <strong class="ln io">False</strong>)</span></pre><p id="3880" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">test_was_published_recently_with_future_question</code>创建了一个<code class="fe lk ll lm ln b">Question</code>实例，它的<code class="fe lk ll lm ln b">pub_date</code>字段是未来 30 天，使用<code class="fe lk ll lm ln b">assertIs()</code>方法，它发现它的<code class="fe lk ll lm ln b">was_published_recently()</code>返回<code class="fe lk ll lm ln b">True</code>，尽管我们希望它返回<code class="fe lk ll lm ln b">False</code>。我们现在可以利用我们的交互式调试器来找出到底哪里出错了。</p><p id="f5e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">向测试中的第一行添加断点。我们将使用<strong class="kq io">单步跳过</strong>和<strong class="kq io">单步进入</strong>动作来查找故障点，并且我们将使用<strong class="kq io">求值表达式</strong>功能来查看哪里出错了。继续在调试模式下运行测试。你应该在这里结束。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/e4601ebbeaae6ee45de5366cdb66010a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIsG79NqSBLj2UA6KeQvvg.png"/></div></div></figure><p id="1920" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<strong class="kq io">跨过</strong>动作向下移动到 assertIs 语句。你会看到你可以检查你所创建的时间确实是你所期望的，甚至它被正确地设置在你的<code class="fe lk ll lm ln b">future_question</code>对象上。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/1aabf5e5d1ae82ecb1e165d0b5e689d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9sdQ2CDWKzvWmjP9ZwTsw.png"/></div></div></figure><p id="6b88" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们知道这些都是正确的，我们可以<strong class="kq io">跳到我的代码</strong>中，看看<code class="fe lk ll lm ln b">was_published_recently()</code>函数内部发生了什么。你应该发现自己在这里:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ol"><img src="../Images/ed80adbc1ed9871b78b4848b4d2eca44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFWyyMxSp9qz2Agq8yaW2g.png"/></div></div></figure><p id="957f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以使用求值表达式函数来查找并修复 bug。如果我们在 return 语句上运行 Evaluate 表达式，我们会看到它返回 True，尽管我们预期它是 False。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/b3d5d43d90d2b0882f827b460f2dbcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCWdrh9AEqiclQ0UoB7MYA.png"/></div></div></figure><p id="8045" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">进一步检查我们正在比较的日期，我们看到<code class="fe lk ll lm ln b">pub_date</code>确实是在未来，但是我们没有从表达式中排除未来日期的帖子。我们需要检查一下<code class="fe lk ll lm ln b">pub_date</code>是否也小于<code class="fe lk ll lm ln b">now()</code>。在将它放入代码之前，我们可以在表达式求值中测试它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi on"><img src="../Images/48eb057340957d0cbf34252ef6e97946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pMVCFc70zu0gcz701CyUg.png"/></div></div></figure><p id="e22c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太好了，现在它似乎工作了，我们可以纠正我们的代码并重新运行我们的测试。这一次它正确地通过了。请记住，在调试模式下执行测试期间，您可以随时使用<strong class="kq io">恢复</strong>、<strong class="kq io">暂停</strong>和<strong class="kq io">停止</strong>按钮。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/01b1d4895e6d9f1721b6b20f2d254720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TcpLcgsOfGFcvXzqJKkoQ.png"/></div></div></figure><h1 id="189d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="b17a" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">希望通过这个简单的例子可以帮助您理解这个过程，并将其应用到您的具体案例中。它确实帮助我更快地发现问题，尤其是在处理我自己没有写或者很久以前写的代码时。使用<strong class="kq io"> Step into my code </strong>函数也有助于找到信号中有时会发生事情的地方。</p><h1 id="3613" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">奖励无迁移🎉</h1><p id="49d1" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">当您在测试开始之前有许多迁移要运行时，或者当您想要测试一个模型变化而不经历整个迁移过程时，这个<code class="fe lk ll lm ln b">--nomigrations</code>标志是一个救命稻草。您可以在测试配置中设置此标志:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi op"><img src="../Images/2dd5ddc7dbe186a279d3c6aed44af386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WKXsgKn6imNAozsVXAhUg.png"/></div></div></figure><p id="6de1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后在<strong class="kq io">附加参数</strong>选项中添加<code class="fe lk ll lm ln b">--nomigrations</code>参数</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oq"><img src="../Images/28e62db3156c7567b5e19c7c5dd24eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZ2cScjJ60jj3cF0dY4iuQ.png"/></div></div></figure><p id="5460" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者您可以将它全局添加到您的<code class="fe lk ll lm ln b">pytest.ini</code>文件中，但是不要提交这个选项，因为您不希望您的 CI 在不需要进行任何迁移的情况下运行您的测试，然后如果您需要额外的更改，需要回滚或更改它们。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="28aa" class="mm lq in ln b gy nk nl l nm nn">[pytest]<br/>DJANGO_SETTINGS_MODULE=mysite.settings<br/>python_files = tests.py test_*.py *_tests.py<br/>addopts = --nomigrations</span></pre><p id="3ade" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">继续向您的问题模型添加一个不可为空的字段，看看您的测试如何运行。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="e8c8" class="mm lq in ln b gy nk nl l nm nn"><strong class="ln io">class</strong> Question(models.Model):<br/>    question_text = models.CharField(max_length=200)<br/>    pub_date = models.DateTimeField('date published')</span><span id="da33" class="mm lq in ln b gy or nl l nm nn">    published_by = models.ForeignKey(User, on_delete=models.CASCADE)<br/><br/>    <strong class="ln io">def</strong> __str__(self):<br/>        <strong class="ln io">return</strong> self.question_text</span></pre><p id="23e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还要更新测试。</p><pre class="kd ke kf kg gt ng ln nh ni aw nj bi"><span id="7520" class="mm lq in ln b gy nk nl l nm nn"><strong class="ln io">def</strong> test_was_published_recently_with_future_question(self):<br/>    <em class="no">"""<br/>    was_published_recently() returns False for questions whose pub_date<br/>    is in the future.<br/>    """<br/>    </em>user = User.objects.create_user('john', 'lennon@thebeatles.com', 'johnpassword')<br/>    time = timezone.now() + datetime.timedelta(days=30)<br/>    future_question = Question(pub_date=time, published_by=user)<br/>    future_question.save()<br/>    self.<strong class="ln io">assertIs</strong>(future_question.was_published_recently(), <strong class="ln io">False</strong>)<br/>    self.<strong class="ln io">assertEqual</strong>(future_question.published_by, user)</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/6994a4470b5a4d2b9234ff2fea9e79f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFuWcawASEWqxO-dTNXShw.png"/></div></div></figure><p id="e828" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这能帮助你提高效率和代码质量！</p></div></div>    
</body>
</html>