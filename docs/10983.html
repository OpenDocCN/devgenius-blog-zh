<html>
<head>
<title>K8s — Container Memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s —容器内存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-container-memory-87c6a2a98bef?source=collection_archive---------1-----------------------#2022-12-12">https://blog.devgenius.io/k8s-container-memory-87c6a2a98bef?source=collection_archive---------1-----------------------#2022-12-12</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="63e5" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">容器内存使用情况深度调查</h2></div><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/c25c7843907745d564abf8e4d43659e4.png" data-original-src="https://miro.medium.com/v2/format:webp/0*kElNJxeOHApCzL8b.png"/></div></figure><h1 id="a6d8" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">运行容器神奇地消失了？</h1><p id="0ae2" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">你在使用容器时遇到过这种情况吗？一个容器在系统中运行一段时间后，突然消失了。即使你看了日志文件但里面什么也没有。集装箱就这么消失了。</p><p id="c5b1" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">很多时候，当一个正在运行的容器被系统杀死，原因只有一个:“<strong class="li is">容器中的进程使用了太多的内存</strong>”。具体来说，容器中所有进程使用的内存量超过了容器所在的<code class="fe mh mi mj mk b">Memory Cgroup</code>中的内存限制。这时候 Linux 系统会主动杀死容器中的一个进程，往往会导致整个容器的退出。</p><p id="b391" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">让我们做一个实验。为了模拟 OOM(内存不足)杀戮，我为您准备了这个 docker 映像——Docker hub link:<a class="ae ml" href="https://hub.docker.com/repository/docker/tonylixu/oom" rel="noopener ugc nofollow" target="_blank">tonylixu:OOM</a></p><p id="7968" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">刚刚拉下的图像:</p><pre class="kg kh ki kj gu mm mk mn bn mo mp bi"><span id="79c3" class="mq kp ir mk b be mr ms l mt mu">$ docker pull tonylixu/oom:v1<br/>v1: Pulling from tonylixu/oom<br/>8a29a15cefae: Already exists<br/>3e9f54602a54: Pull complete<br/>Digest: sha256:632fdf51af051c336f21a9722327716ee984809a8592ab1ae51b2bdfccdb2a29<br/>Status: Downloaded newer image for tonylixu/oom:v1<br/>docker.io/tonylixu/oom:v1</span></pre><p id="d25c" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">使用以下 shell 脚本运行:</p><pre class="kg kh ki kj gu mm mk mn bn mo mp bi"><span id="68a7" class="mq kp ir mk b be mr ms l mt mu">#!/bin/bash<br/># Stop existing oom_test, if any<br/>$ docker stop oom_test;docker rm oom_test# Start container as daemon<br/>$ docker run -d --name oom_test tonylixu/oom:v1# Sleep for two seconds<br/>sleep 2<br/>CONTAINER_ID=$(sudo docker ps --format "{{.ID}}\t{{.Names}}" | grep -i oom_test | awk '{print $1}')<br/>echo $CONTAINER_ID# Get Container memory Cgroup path<br/>CGROUP_CONTAINER_PATH=$(find /sys/fs/cgroup/memory/ -name "*$CONTAINER_ID*")<br/>echo $CGROUP_CONTAINER_PATH# Set memory limit to 1GB<br/>echo 1073741824 &gt; $CGROUP_CONTAINER_PATH/memory.limit_in_bytes<br/>cat $CGROUP_CONTAINER_PATH/memory.limit_in_bytes</span></pre><p id="3c7c" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">当容器运行时，使用另一个终端并使用<code class="fe mh mi mj mk b">top</code>命令来监控进程:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/e22fffad799edc1e052ffe824ca89681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C2KGQvNFw9-5Nv1-.png"/></div></figure><p id="3ad0" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">你会发现一个叫做<code class="fe mh mi mj mk b">mem_alloc</code>的进程一直在请求内存。当请求的内存超过<code class="fe mh mi mj mk b">1GB</code>时，就会消失。</p><p id="7a8e" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">如果您使用<code class="fe mh mi mj mk b">docker inspect &lt;container_id&gt;</code>进行检查，您会看到集装箱状态为<code class="fe mh mi mj mk b">exited</code>和<code class="fe mh mi mj mk b">OOMKilled</code>为<code class="fe mh mi mj mk b">true</code>:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj mw"><img src="../Images/5677ed17f01b1fb3c67757413e73a454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*68HV2IJdDDS0K8sH.png"/></div></figure><h1 id="7177" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">什么是 OOM 黑仔？</h1><p id="e081" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">OOM 代表“内存不足”，顾名思义，就是内存不足的意思，黑仔在这里的意思是需要杀死一个进程。那么 OOM 黑仔就意味着如果 Linux 系统内存不足，就需要杀死一个正在运行的进程来释放一些内存。</p><p id="aec8" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">所以你可能会问，既然 Linux 系统中的进程是用<code class="fe mh mi mj mk b">malloc()</code>来申请新内存的，那么如果内存不足，我们为什么不简单的为<code class="fe mh mi mj mk b">malloc()</code>返回一个失败，而不是杀死一个正在运行的进程呢？</p><p id="87aa" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">其实这和 Linux 进程的内存应用策略有关。Linux 允许一个进程在申请内存时<strong class="li is">过量使用</strong>。</p><p id="0b4a" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">这是什么意思？也就是说，允许进程申请超过实际物理内存上限的内存。例如，如果一个服务器只有 1GB 内存，但是如果一个进程使用<code class="fe mh mi mj mk b">malloc()</code>请求 1.5GB 内存，该请求仍然会通过(因为<code class="fe mh mi mj mk b">malloc()</code>实际上是请求虚拟内存)。在物理内存确实不足的某个时候，Linux 内核就会开始查杀。</p><h1 id="3434" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">OOM 黑仔如何选择杀死哪个进程？</h1><p id="f96c" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">Linux 内核有一个函数叫做<code class="fe mh mi mj mk b">oom_badness()</code>，这个函数选择杀死哪个进程。基于以下内容:</p><ol class=""><li id="a846" class="mx my ir li b lj mc lm md lp mz lt na lx nb mb nc nd ne nf bi translated">进程使用的物理内存页数。</li><li id="7c30" class="mx my ir li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">OOM 校准值<code class="fe mh mi mj mk b">oom_score_adj</code>。在<code class="fe mh mi mj mk b">/proc</code>目录下，每个进程都有一个<code class="fe mh mi mj mk b">/proc/&lt;pid&gt;oom_score_adj</code>文件。该文件中的值在<code class="fe mh mi mj mk b">-1000 to 1000</code>之间</li></ol><p id="07e4" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">当<code class="fe mh mi mj mk b">oom_badness</code>进行计算时:<strong class="li is">它将系统中可用页面的总数乘以 OOM 校准值 oom_score_adj，再加上进程已使用的物理页面数。计算值越大，进程被 OOM 杀死的概率就越大。</strong></p><h1 id="18ef" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">容器内存组</h1><p id="3fba" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">所以现在我们明白了，容器 OOM 击杀是由容器<code class="fe mh mi mj mk b">Memory Cgroup</code>控制/限制的。<code class="fe mh mi mj mk b">Memory Cgroup</code>是如何工作的？</p><p id="be76" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated"><code class="fe mh mi mj mk b">Memory Cgroup</code>也是 Linux Cgroups 子系统之一，它的作用是限制一组进程的内存使用量。<code class="fe mh mi mj mk b">Memory Cgroup</code>虚拟文件系统的挂载点一般在目录“<strong class="li is"> /sys/fs/cgroup/memory </strong>”下，与<code class="fe mh mi mj mk b">CPU Cgroup</code>类似。我们可以在<code class="fe mh mi mj mk b">Memory Cgroup</code>的挂载点目录下创建一个子目录作为控制组。像下面这样:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/c628c0252c87e06fce786fc01c9fd7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P4xfOkULN1gvaJzt.png"/></div></figure><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/aa659121645a7c262194c93a2a24a5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-WEfEMemfd4vUmET.png"/></div></figure><p id="2bd0" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">每个控制组下有许多参数。这里，我们将只讨论与 OOM 最相关的 3 个参数:</p><ul class=""><li id="96cc" class="mx my ir li b lj mc lm md lp mz lt na lx nb mb nl nd ne nf bi translated"><strong class="li is">memory . limit _ in _ bytes:</strong><em class="nm">每个控制组中最重要的参数。这是因为控制组中所有进程可以使用的最大内存直接受到该参数值的限制。</em></li><li id="b69d" class="mx my ir li b lj ng lm nh lp ni lt nj lx nk mb nl nd ne nf bi translated"><strong class="li is">memory . oom _ control:</strong><em class="nm">决定当控制组中进程的内存使用达到极限时，是否触发 OOM 黑仔。</em></li><li id="e2b3" class="mx my ir li b lj ng lm nh lp ni lt nj lx nk mb nl nd ne nf bi translated"><strong class="li is">memory . usage _ in _ bytes:</strong><em class="nm">存储当前控制组中所有进程实际使用的内存总和。</em></li></ul><p id="d149" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated"><strong class="li is">注意:</strong>如果设置<code class="fe mh mi mj mk b">memory.oom_control</code>为 1，则不会触发 OOM 黑仔。</p><p id="0452" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">所以总结一下:</p><ol class=""><li id="54b6" class="mx my ir li b lj mc lm md lp mz lt na lx nb mb nc nd ne nf bi translated"><code class="fe mh mi mj mk b">Memory Cgroup</code>中的每个控制组可以限制一组进程的内存使用。一旦所有进程使用的内存总量达到限制，将默认触发 OOM 黑仔。这样，对照组中的“某个进程”就会被杀死。</li><li id="f8da" class="mx my ir li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">“某个进程”定义为控制组中可用页面总数乘以该进程的<code class="fe mh mi mj mk b">oom_score_adj</code>，加上该进程已经使用的物理内存页面，值最大的进程将被系统选择并杀死。</li></ol><p id="9f85" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">我希望现在您能理解为什么有时您的运行容器会突然消失。大多数容器云平台，比如 Kubernetes，都会对容器的内存使用量设置上限。该内存的上限将被写入 Cgroup，具体是容器对应的<code class="fe mh mi mj mk b">Memory Cgroup</code>控制组中的参数<code class="fe mh mi mj mk b">memory.limit_in_bytes</code>。</p><h1 id="1328" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">如何确认集装箱被 OOM 杀死？</h1><p id="c504" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">你可以使用系统命令<code class="fe mh mi mj mk b">journalctl -k</code>来验证一个容器是否被 OOM 杀死</p><pre class="kg kh ki kj gu mm mk mn bn mo mp bi"><span id="55ed" class="mq kp ir mk b be mr ms l mt mu">$ journalctl -kSep 13 20:05:55 devops101 kernel: Memory cgroup stats for /docker/9aa53161a9f95c6be87e448980332a151b0aeeb840ea4ca92dc96a64a03e3d33: cache:0KB rss:1045824KB rss_huge:0KB shmem:0KB mapped_file:0KB dirty:0KBSep 13 20:05:55 devops101 kernel: [ pid ]   uid  tgid total_vm      rss nr_ptes nr_pmds swapents oom_score_adj nameSep 13 20:05:55 devops101 kernel: [11002]     0 11002   262708   261750     519       4        0             0 mem_allocSep 13 20:05:55 devops101 kernel: Memory cgroup out of memory: Kill process 11002 (mem_alloc) score 1000 or sacrifice childSep 13 20:05:55 devops101 kernel: Killed process 11002 (mem_alloc) total-vm:1050832kB, anon-rss:1045716kB, file-rss:1284kB, shmem-rss:0kB</span></pre><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/3b340509004c124167a9c2757ad12d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pT8aJjiB4qPzZbmJ.png"/></div></figure><p id="443d" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">从上面的截图我们可以看到<code class="fe mh mi mj mk b">mem_alloc</code>有 261750 个<code class="fe mh mi mj mk b">rss</code>，每个<code class="fe mh mi mj mk b">rss</code>页面大约 4KB，所以<code class="fe mh mi mj mk b">261750 x 4KB</code> = <code class="fe mh mi mj mk b">1GB</code>。这是我们为此容器内存设置的确切限制。</p></div></div>    
</body>
</html>