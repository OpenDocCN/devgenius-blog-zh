<html>
<head>
<title>Inline Assembly in F#! How does it work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F#中的内联程序集！它是如何工作的？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/inline-assembly-in-f-net-language-6d70ab9f58c1?source=collection_archive---------1-----------------------#2022-02-05">https://blog.devgenius.io/inline-assembly-in-f-net-language-6d70ab9f58c1?source=collection_archive---------1-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/268bd9e4b128115ec94d012158ad7e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cd7oSXw7sSTHeFIlzo1Llg.png"/></div></div></figure><p id="5a60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 F#中的汇编语言。不，这不是模仿。它不是 IL。它是 x86 汇编语言。在你的 CPU 上运行的那个。…在 F#中。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">这一切是如何开始的(看看我的推特，呵呵)</figcaption></figure><p id="2a25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们看看它是如何工作的引擎盖下！</p><h1 id="157a" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">让我们用 C#编码几条指令！</h1><p id="b6a5" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">所以，我来给你讲讲<a class="ae mg" href="https://github.com/icedland/iced" rel="noopener ugc nofollow" target="_blank">冰镇</a>。这是一个非常棒的库，它允许你为 x86(基本上，大多数桌面 CPU)编码和解码汇编。</p><p id="3d0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以像这样创建一个装配生成器，并添加一些指令:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/63f2da5fd6bae6d03de947305d10fe2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyyLF8GuEufEcp6iOB-mlQ.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">创建一个汇编程序并实现两个数相加的函数</figcaption></figure><p id="dc69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这没有任何作用。它只是把它们保存在某个地方，是为了方便我们使用它们。它不会使任何东西可执行。</p><h1 id="c4af" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">现在，我们将汇编保存到可执行内存中</h1><p id="1fd4" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">什么是可执行内存？它就像常规内存，但操作系统“允许”从那里运行字节作为 CPU 指令。</p><p id="533a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用 Windows API 来分配内存。一旦分配，我们将改变其保护为可执行。我们正在做的是:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/4f0eb4c092d2d358fc3d6513f2fa9c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mEagk5d2pvvNNgkpKaRTA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">分配内存并使其可执行</figcaption></figure><p id="e86a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，那么…现在我们做到了，这意味着什么？这意味着，如果我们写入那个内存，我们可以制作一个<a class="ae mg" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers" rel="noopener ugc nofollow" target="_blank"> <em class="mj">函数指针</em> </a>指向第一个字节，并本地运行它！</p><h1 id="0f9a" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">将我们的程序集复制到内存中</h1><p id="446e" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">基本上，使用 Iced API 我们只是将字节保存到一个流中，然后我们为它们分配内存并复制到其中。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/523d91d0a284cf8e5070464cb4b8aa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28jTPDB0NwH5sjxvo2G4Kw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将汇编字节复制到可执行内存</figcaption></figure><h1 id="6ce8" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">编译以委托</h1><p id="23ce" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">正如你所注意到的，到目前为止我们一直使用 C#。原因是 F#还不喜欢函数指针。我们得做出能被 F#执行的东西。</p><p id="6074" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住——我们得到了一个指向汇编内存块第一个字节的指针。所以我们所需要的就是以某种方式调用它作为一个函数。为此，我做了一个扩展方法，将指针转换成函数指针:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/07e5ed9cd64c823872bc4e752d0cb811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxqoiEgcYUm_f2BIxfrB8Q.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">“编译”后将指针强制转换为函数指针</figcaption></figure><p id="62e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我需要为它做 Func <tout>。这部分我就省略了，因为太邪恶了。但是如果你很好奇，这里有它的来源。它从函数指针中获取 Func &lt; TOut &gt;。</tout></p><h1 id="7206" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">F#的简洁语法</h1><p id="5dba" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">为了获得我在截图中展示的语法，我们将使用<a class="ae mg" href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions" rel="noopener ugc nofollow" target="_blank">计算表达式</a>(CE)——非常丰富的特性，是 F#所独有的。</p><p id="35b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能已经见过 CEs 在使用中，例如 task { }，async { }，seq {}，如下所示:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/819c20819531d5c2a2629e48079c1f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*XYwAjZtrqTj_jNbWK4KPfw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">内置 CE 的示例</figcaption></figure><p id="cdef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要宣布我们自己的。此外，我们将对它使用自定义操作。</p><p id="5417" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们定义 Yield，在定制操作符的情况下，它可以用作“初始化器”:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/d0ec961061073394fc1578fa967aeb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6IZ_1W-LFGMeWUlLGYQ0w.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">首先创建汇编程序的实例</figcaption></figure><p id="e28f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们创建一些方法。Iced 的汇编器有成百上千个方法，实际上可以使用反射为它们生成一个包装器，但是为了简单起见，我将在这里展示我在示例中使用的方法:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/a9995b54c2a1dce989776b3663ea518b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fb9v28yegrU1ozocWNk-MQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">定义 rdtsc、shl、add 和 ret</figcaption></figure><p id="ced8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过属性的第一个参数给它们命名。</p><p id="52b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们声明方法 Run，它“终结”表达式:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/37616485352671fda77f7ffa818e91b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ4S_kuau7Qmb-cu4etQWw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">定义运行方法</figcaption></figure><p id="8c18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以最后它返回一个函数，这个函数不接受任何参数，但返回一个 int64。</p><p id="98f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">搞定了。我们声明了 AsmBuilder。我们现在可以实例化它的一个实例(我们实际上只需要创建它一次，因为我们从不改变它):</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/511cd0e4969c2c8eb9b235871401fd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*RNfxzH67zws6dOozsKY0DA.png"/></div></figure><h1 id="1b48" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用</h1><p id="039f" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">现在，我们可以使用我们的 asm 计算表达式，通过使用我们定义的自定义操作，并从 ice 传递常量或寄存器。</p><p id="d1d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是用这种内联 asm 语法创建的两个函数示例:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/f323b178d8bb3b27d2be19d98b3537d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ui1NW_6sOqXsnmz4KFPEOA.png"/></div></div></figure><h1 id="f491" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="74b8" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">所以，这就是它，我没有进入任何主题的细节，我认为这只是一个有趣的 ice/F #的 CE 和东西的用例。</p><p id="d6ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于“真正的”使用，有很多限制。</p><p id="3322" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，F#不支持函数指针，<a class="ae mg" href="https://github.com/dotnet/runtime/issues/9136" rel="noopener ugc nofollow" target="_blank">不可能</a>从泛型函数指针创建委托。这意味着我们需要为不同大小和 ABI 的参数创建大量重载(例如，Windows x86 上的浮点在 xmm 寄存器中传递)。在这篇文章中，我只考虑一个返回的函数，但不接受任何参数。</p><p id="a5cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二，我没有做任何事情来支持调用和标签(显然，这对于任何非基本的东西都是必不可少的)。所以这是一个概念的证明，而不是真实的东西。</p><p id="eed4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但无论如何，我希望它是有趣的！来源是这里的<a class="ae mg" href="https://github.com/WhiteBlackGoose/AsmToDelegate" rel="noopener ugc nofollow" target="_blank"/>。感谢您的关注！</p><p id="2312" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的<a class="ae mg" href="https://twitter.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> twitter </a>，<a class="ae mg" href="https://github.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> github </a>。</p></div></div>    
</body>
</html>