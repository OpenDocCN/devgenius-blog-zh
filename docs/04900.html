<html>
<head>
<title>How to Build a Serverless S3 Object Lowercaser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个无服务器的S3对象小写器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-a-serverless-s3-object-lowercaser-31e00d68e41c?source=collection_archive---------3-----------------------#2021-05-18">https://blog.devgenius.io/how-to-build-a-serverless-s3-object-lowercaser-31e00d68e41c?source=collection_archive---------3-----------------------#2021-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d24fc6a2b2aebd3c7b25b97d182df031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIKJ8ew6XI9sJJxKBx5fgg.jpeg"/></div></div></figure><p id="ed93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AWS Lambda和其他无服务器计算选项为技术人员提供了一个很好的选择，使他们不必考虑服务器的供应、扩展以及运行复杂系统的许多运营开销。最近，当遇到棘手的问题时，我有机会利用这种力量。我们的解决方案最终是构建一个无服务器的S3对象密钥小写器。</p><h1 id="9fce" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么要构建这个工具？</h1><p id="6a65" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们面临的问题是将产品存储从Amazon EBS卷上托管的SMB共享迁移到S3对象存储。这种转变非常复杂，但与此讨论相关的挑战是，SMB公开了不区分大小写的文件系统，而S3是区分大小写的对象存储；因此，如果大小写不一致，简单地将文件转换成对象是行不通的。考虑到使用这些文件的应用程序已经有大约20年的历史，有超过一百万行的代码，所以对于这些文件是否都处于一致状态的信心很低。因此，决定在存储前将所有文件名转换成小写。这实际上允许我们忽略这个问题。然而，要解决的问题是如何有效地将数百万个文件名转换成小写字母。</p><h1 id="53dd" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最初的失败</h1><p id="a2ce" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们最初编写了许多工具，试图使这变得更容易。这个工具是一个多步骤的过程，我们在本地小写所有文件，然后使用AWS CLI运行一个S3同步任务，将数据放到必要的桶中。这一过程确实有效，但速度慢且容易出错，因为在转换发生时，我们必须在最后的停机时间内，用另一个最终同步来跟踪拷贝。在一些测试环境中运行这个过程几次后，我们确定这个过程不会起作用。</p><h1 id="ec89" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">方向的改变</h1><p id="40ed" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们最初的失败后，我们决定回到绘图板，看看是否将过程分成单独的部分可以改进我们的过程。知道我们过程的第一部分，即把数据复制到S3存储桶，并不是唯一的需要，我们确信必须有一个构建良好的工具来促进这一过程。我们发现AWS的<a class="ae lz" href="https://aws.amazon.com/datasync" rel="noopener ugc nofollow" target="_blank"> DataSync </a>工具“简化、自动化并加速了内部存储系统和AWS存储服务之间的数据移动”,根据它的文档。我们发现这与其描述相符。安装DataSync代理后，我们运行了一些测试拷贝，对镜像速度以及拷贝过程中的可见性非常满意。这比我们自己开发的工具在各方面都要好。</p><p id="4c6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们已经解决了数据迁移问题，但仍然没有解决小写问题的方法。当我们试图找出我们最初的解决方案时，我们考虑过在对象到达S3后将其小写。这个想法被抛弃了，因为在S3没有重命名对象键功能，取而代之的是你必须复制对象然后删除原始对象。这似乎非常慢，并且需要大量的API调用。把这个想法从垃圾桶里拿出来，我们决定再看一看它，但运行方式稍有不同。</p><h1 id="a3f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Lambda低功率激光器</h1><p id="999f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们决定迁移到的架构如下所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/7795857daa86eb37042df4d7182a301e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqzr9H_0VGla9qI-a_G1OA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">基本小写图</figcaption></figure><p id="faaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">高层架构将在目标桶上设置<a class="ae lz" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/NotificationHowTo.html" rel="noopener ugc nofollow" target="_blank"> S3事件通知</a>来触发Lambda函数。Lambda函数将确定对象的键是否已经是小写的，如果是，函数将在这里结束，如果不是，它将小写对象。最后，如果在此过程中出现错误，失败信息将被放到一个长保留SQS队列中。</p><p id="7747" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更深入地研究一下代码。让我们从基础设施即代码开始。当使用基于Lambda的架构时，我喜欢使用<a class="ae lz" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>,因为我认为它使事情变得相当简单，并且很大程度上不碍事。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此配置中值得注意的信息。</p><ul class=""><li id="97a4" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">在<code class="fe mu mv mw mx b">resources</code>部分，我们为要记录的失败的小写尝试创建SQS队列。可能最有趣的部分是1209600秒(14天)的<code class="fe mu mv mw mx b">MessageRetentionPeriod</code>,这是该字段的最大可用值。因为人们将审查这个队列的结果，我们希望给他们尽可能多的时间。</li><li id="a5bb" class="ml mm iq ka b kb my kf mz kj na kn nb kr nc kv mq mr ms mt bi translated">使用<code class="fe mu mv mw mx b">iamRoleStatements</code>部分，我们能够为Lambda创建一个最小特权策略，只允许完成工作所必需的访问。</li><li id="842d" class="ml mm iq ka b kb my kf mz kj na kn nb kr nc kv mq mr ms mt bi translated">第29行列出了该函数允许操作的资源，这当然需要针对每个用例进行更改。</li></ul><p id="65c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候看一些代码了。这个函数没有很多代码，但是有一些问题需要注意。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="af4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">S3事件通知以已更改的对象数组的形式出现，所以在第2行，我们简单地遍历所有提供的对象。然后，我们从提供的JSON对象中提取必要的信息。</p><p id="183e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第10行，我们遇到了第一个问题，出于某种原因，事件通知HTML对对象名进行了编码。潜在地，如果你的对象名不包含任何特殊字符，这可能不会起作用，但安全总比后悔好。</p><p id="99c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们检查对象名的小写版本是否与当前对象名相同，也就是说，我们确定对象是否需要小写。这一部分非常重要，因为如果你不这样做，你将会陷入Lambda调用的无限循环。一个对象将进入，文件将被小写并写入桶中，这将触发对lambda的另一个调用，从而开始恶性循环。当设置S3事件通知时，会有一个警告提示不要这样做。</p><p id="2d43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第16行进入下一个潜在的陷阱。当处理超过5gb的文件时，您必须使用的复制功能是不同的，效率较低(因此您不想总是使用它)，如果您试图使用原始方法，它<a class="ae lz" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.copy_object" rel="noopener ugc nofollow" target="_blank">将失败</a>。</p><p id="18b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，代码非常简单。我们复制文件，然后删除原始文件，如果在整个过程中出现任何错误，我们会将堆栈跟踪发送给SQS。</p><h1 id="f51e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">它是如何工作的？</h1><p id="f529" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">它最终运行得相当好。基于Lambda的可伸缩性，我们能够处理尽可能多的对象。我们也不必等到所有对象都被复制到bucket中之后才开始这个过程(我们实际上必须做相反的事情，它必须在上传发生之前设置好)。S3事件通知的保证是至少一次交付，这个保证对于我们的用例来说是完美的。事实证明，随着实时重命名的发生，我们并没有因为低效的副本而受到太多的影响，这当然会导致更多的API调用，这意味着成本的增加，但这些增加是微不足道的，也是值得的。</p><h1 id="2ce1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">经验教训</h1><ul class=""><li id="1557" class="ml mm iq ka b kb lu kf lv kj nd kn ne kr nf kv mq mr ms mt bi translated">在构建自己的解决方案之前，先寻找现有的解决方案。</li><li id="3bb7" class="ml mm iq ka b kb my kf mz kj na kn nb kr nc kv mq mr ms mt bi translated">在现有可扩展解决方案的基础上构建可以极大地简化您的生活。</li><li id="c9d5" class="ml mm iq ka b kb my kf mz kj na kn nb kr nc kv mq mr ms mt bi translated">熟悉许多不同的技术，你永远不知道什么时候你能使用这些技术来解决问题。</li></ul><h1 id="3dcc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源</h1><div class="ng nh gp gr ni nj"><a href="https://github.com/kylec32/s3lowercaser" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">kylec 32/S3小写字母</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">在GitHub上创建一个帐户，为kylec 32/S3 lower case开发做贡献。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/NotificationHowTo.html" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">亚马逊S3活动通知</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">您可以使用亚马逊S3事件通知功能，在S3发生特定事件时接收通知…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://aws.amazon.com/datasync" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">AWS数据同步|轻松地在AWS | Amazon Web Services之间传输数据</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">简化、自动化和加速AWS存储之间的数据移动，以及AWS存储服务AWS之间的数据移动…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">aws.amazon.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jw nj"/></div></div></a></div></div></div>    
</body>
</html>