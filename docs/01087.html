<html>
<head>
<title>Basic Node Apps Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本节点应用最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/basic-node-apps-best-practices-d4ed4ddb04bd?source=collection_archive---------32-----------------------#2020-06-23">https://blog.devgenius.io/basic-node-apps-best-practices-d4ed4ddb04bd?source=collection_archive---------32-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ebfef05c489b57215bcad6f73710edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyg2NmQBrlMQPJZE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@henry_be?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Henry Be </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cbbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，节点应用程序也必须编写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些节点最佳实践。</p><h1 id="3f01" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理回调中的错误</h1><p id="7c1a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在回调中处理错误。</p><p id="0abe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步代码通常有带<code class="fe me mf mg mh b">err</code>参数的回调。</p><p id="5bac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的回访中，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56bd" class="mq lc iq mh b gy mr ms l mt mu">const loadData = (error, data) =&gt; {<br/>  if (error) {<br/>     console.log(error.stack);<br/>  }<br/>  doSomething();<br/>}</span></pre><p id="c39d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是像这样忽视它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="957b" class="mq lc iq mh b gy mr ms l mt mu">const loadData = (error, data) =&gt; {<br/>  doSomething();<br/>}</span></pre><p id="234b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们记录下来，也比什么都不做好。</p><h1 id="b2c9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回调文字</h1><p id="990c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当一个函数被命名为<code class="fe me mf mg mh b">cb</code>或<code class="fe me mf mg mh b">callback</code>时，那么它应该用<code class="fe me mf mg mh b">undefined</code>、<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">Error</code>实例来调用，这样如果有错误就传入一个错误。</p><p id="8377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a18c" class="mq lc iq mh b gy mr ms l mt mu">cb(undefined);</span></pre><p id="560e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9d83" class="mq lc iq mh b gy mr ms l mt mu">callback(new Error('error'));</span></pre><p id="db32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是传入一个字符串或其他东西。</p><h1 id="2f2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">出口中没有分配</h1><p id="491b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在一个<code class="fe me mf mg mh b">exports </code>对象中分配任何东西。</p><p id="b508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们这样做，它就不会像预期的那样工作。</p><p id="d669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d6f6" class="mq lc iq mh b gy mr ms l mt mu">exports = {<br/>  foo: 'bar'<br/>}</span></pre><p id="27af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="835d" class="mq lc iq mh b gy mr ms l mt mu">exports.bar = 1;</span></pre><p id="636d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="072f" class="mq lc iq mh b gy mr ms l mt mu">module.exports.foo = 1</span></pre><p id="150d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4673" class="mq lc iq mh b gy mr ms l mt mu">module.exports = {}</span></pre><p id="2846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，成员实际上是导出的。</p><h1 id="73e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有外来的进口</h1><p id="adce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该进口任何我们不需要的东西。</p><p id="f0c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该清除它们。</p><h1 id="4028" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有额外要求</h1><p id="d9c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果不需要 require 调用，那么我们应该删除它们，就像导入一样。</p><h1 id="de1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有遗漏导入</h1><p id="e1a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们忘记导入一个模块，那么我们应该修复它。</p><p id="a6b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="85b2" class="mq lc iq mh b gy mr ms l mt mu">import typoFile from "./typo-file";<br/>import typoModule from "typo-module"; </span></pre><p id="5ea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们修复了错别字:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2ad" class="mq lc iq mh b gy mr ms l mt mu">import existingFile from "./existing-file";<br/>import existingModule from "existing-module";</span></pre><h1 id="e33b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有遗漏要求</h1><p id="da3d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像导入一样，我们应该修复指向不存在的模块的 require 调用。</p><p id="b7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1543" class="mq lc iq mh b gy mr ms l mt mu">const foo = require("./foo");</span></pre><p id="f717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">foo</code>不存在，那么我们会得到一个错误。</p><p id="eeee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07bf" class="mq lc iq mh b gy mr ms l mt mu">const existingFile = require("./existing-file");<br/>const existingModule = require("existing-module");</span></pre><h1 id="c0f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有新要求</h1><p id="01c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该用<code class="fe me mf mg mh b">require</code>来形容<code class="fe me mf mg mh b">new</code>。把它们结合在一起会让人感到困惑</p><p id="d5c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能会混淆:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ea87" class="mq lc iq mh b gy mr ms l mt mu">const bar = new require('foo');</span></pre><p id="8a80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d42a" class="mq lc iq mh b gy mr ms l mt mu">const bar = new (require('foo'));</span></pre><p id="9328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该将它赋给一个变量，然后在需要时使用<code class="fe me mf mg mh b">new</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="71c3" class="mq lc iq mh b gy mr ms l mt mu">const Foo = new require('foo');<br/>const foo = new Foo();</span></pre><h1 id="23b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有路径串联</h1><p id="5cb4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该把路径连接在一起。</p><p id="2d81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为不同平台之间的路径分隔符可能不同。</p><p id="d767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该<code class="fe me mf mg mh b">path.join</code>来组合路径。</p><p id="9edb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以在所有支持的操作系统中正常工作</p><p id="4450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6fe4" class="mq lc iq mh b gy mr ms l mt mu">const fullPath = __dirname + "/foo.js";</span></pre><p id="3ff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5b5a" class="mq lc iq mh b gy mr ms l mt mu">const fullPath = `${__dirname}/foo.js`;</span></pre><p id="52f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1e88" class="mq lc iq mh b gy mr ms l mt mu">const fullPath = path.join(__dirname, "foo.js");</span></pre><h1 id="d9f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有进程退出</h1><p id="5f11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">process.exit()</code>是一个危险的调用方法，因为它可以在任何时候停止程序。</p><p id="e4d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着程序在退出前可能没有时间处理错误。</p><p id="c723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以抛出一个错误。</p><p id="3aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写作；</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be4f" class="mq lc iq mh b gy mr ms l mt mu">if (errorHappened) {<br/>  process.exit(1);<br/>}</span></pre><p id="bc4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e1c1" class="mq lc iq mh b gy mr ms l mt mu">if (errorHappened) {<br/>  throw new Error("error!");<br/>}</span></pre><h1 id="95c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有未发布的框</h1><p id="5139" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们没有为我们的项目发布一个包，我们应该在我们的<code class="fe me mf mg mh b">package.json</code>中有<code class="fe me mf mg mh b">bin</code>属性。</p><h1 id="c621" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不支持的 ES 功能</h1><p id="7307" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用不受支持的 ES 特性，因为没有 transpilation 它们就不能运行。</p><p id="82e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然 JavaScript 的改进已经被整合到 Node.js 中，在没有官方支持的情况下，我们就没有那么多需要使用的新特性了。</p><p id="e0dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该只使用受支持的那些。</p><p id="db05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这包括语法和方法。</p><p id="6a55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些方法可能有库或 polyfill。</p><p id="983c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法相当成熟，所以我们不需要使用新的不支持的语法。</p><h1 id="3598" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事情</h1><p id="6575" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们添加了一个 shebang，这样我们就可以运行我们的节点程序，而不需要显式地输入<code class="fe me mf mg mh b">node</code>。</p><p id="18e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5267" class="mq lc iq mh b gy mr ms l mt mu">#!/usr/bin/env node</span></pre><p id="a852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命令行将选择 shebang 并处理 Node。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/7a19f29996ad9312029f58e8c6c0da6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XNjYOEWnRx8rCttV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@meric?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅里达勒</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="76b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不推荐使用的 API</h1><p id="d3cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有许多我们应该避免使用的不推荐使用的 API。</p><p id="ace7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe me mf mg mh b">assert</code>模块有一些方法，如<code class="fe me mf mg mh b">deepEqual</code>、<code class="fe me mf mg mh b">equal</code>等。不推荐使用的。</p><p id="8880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">crypto</code>也有一些弃用的模块。</p><p id="ee10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该避免使用它们，因为它们将来会被删除。</p><h1 id="8c39" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="02dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在编写节点应用程序时，我们应该考虑一些最佳实践。</p><p id="c94c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们非常简单，我们可以快速修复。</p><p id="f34e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像连接路径这样的事情是 Node 的内置特性，我们可以用它来解决这个问题。</p></div></div>    
</body>
</html>