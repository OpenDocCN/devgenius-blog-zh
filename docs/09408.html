<html>
<head>
<title>A way to ensure auditability in data processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种确保数据处理中可审计性的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-way-to-ensure-auditability-in-data-processing-f7664b70ec2b?source=collection_archive---------3-----------------------#2022-08-19">https://blog.devgenius.io/a-way-to-ensure-auditability-in-data-processing-f7664b70ec2b?source=collection_archive---------3-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="da97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我称之为数据管理的三位一体:可追溯性、可审计性和可再现性。本文关注的是数据的可审计性；它是什么，如何设置，以及如何在您的数据管道中确保它。我将使用 dbt 进行实践练习。</p><h1 id="8346" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">数据可审计性</h1><p id="95ad" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我的大部分数据职业生涯都是在银行或电信的数据仓库中度过的。在这两种情况下，数据可审计性都是必须的，这是法律要求的，尤其是当我们谈到金融和发票时。除此之外，在欧洲，我们有 GDPR，建立一个使数据审计更容易的流程是遵守法律的一种方式。</p><p id="b294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据可审计性有两个主要组成部分:</p><ul class=""><li id="138f" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">能够概述您如何处理数据——数据质量、数据处理标准和数据用户管理</li><li id="bbb9" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">能够评估您处理数据的方式的性能或效率</li></ul><p id="e04a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我不会关注数据质量或数据用户管理，而是关注数据处理标准。每当我们处理数据时，我们都希望能够回答以下问题:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/c3f4674da1846a2c38b75d581e692913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fPA1GLWwVRChTrsl.png"/></div></div></figure><p id="b821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些问题可以通过始终使用一组标准的审计列来回答。这些列不仅提供如上所述的基本信息，还可以用于在数据处理中生成更深入的见解，并最终帮助您了解数据谱系和可追溯性。我们来详细看看吧！</p><h1 id="fc39" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">后端(web)应用程序</h1><p id="b21d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当我们谈到典型的用户界面时，有一组标准列被添加到数据中(注意，这里的命名是一个示例，最好遵循您的命名约定):</p><ul class=""><li id="4b36" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">创建者</li><li id="928a" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">更新者</li><li id="4d14" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">CreatedTimestamp</li><li id="e1e4" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">UpdatedTimestamp</li></ul><p id="8f06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我注册成为用户时，会为我生成一条记录。信息看起来像:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="b0d4" class="mt km iq mp b gy mu mv l mw mx">{<br/>    "username": "username",<br/>    "email_address": "email_address",<br/>    "first_name": "first_name",<br/>    "last_name": "last_name"<br/>}</span></pre><p id="1889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在一个网站注册的时候，有一个重要的时间属性:注册的瞬间。这是 CreatedTimestamp，它是一个在用户的生命周期中永远不会改变的值。</p><p id="2b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是谁在为我创造记录呢？CreatedBy 可以是 API 进程名称、允许以我的名义生成数据的一般技术用户、API 版本等。虽然听起来可能有些多余，但 CreatedBy 为审计记录是由哪个流程创建的提供了可能性，以确保在注册步骤中没有欺诈行为。</p><p id="e42a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我正在更新我的姓氏。该操作将发出一个带有新时间戳的新记录，称为 UpdatedTimestamp。有了它，我们可以跟踪一个人的注册表的变化和行动。UpdatedBy 遵循 CreatedBy 逻辑。</p><p id="98e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我的用户可以更改另一个用户的日历条目，该怎么办？在这种情况下，日历记录更改可以在 UpdatedBy 字段中使用 my user。通过这种方式，我们可以跟踪谁对某个业务流程进行了更改。</p><p id="8621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我完全处理流数据会怎么样？然后，事件时间戳可以用来计算注册的时间，但是请注意，如果您不存储计算结果，则每次都需要重新计算。</p><h1 id="e1fd" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">(大)数据处理</h1><p id="8c0a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果在用户应用程序端，一次处理一个记录，当我们谈到(大)数据处理时，数据通常是大量处理的(当然是在流平台之外！).这意味着我们会收到多个记录，我们会检查它们的质量，我们可能会清理它们，最后我们可能会存储它们以备将来使用。</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="cc7a" class="mt km iq mp b gy mu mv l mw mx">username   email_address   first_name  last_name   created_by created_timestamp          updated_by   updated_timestamp<br/>0   username   email_address   first_name  last_name    api_v22   2022-03-15 20:29:57.000    api_v22      2022-04-15 20:29:57.000<br/>1   username_  email_address_  first_name  last_name    api_v23   2022-06-15 20:29:57.000    api_v24      2022-08-15 20:29:57.000</span></pre><p id="5ea0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经有了用户数据注册表单的审计信息，但是当我们执行数据处理步骤时，我们有了新的时间戳，CreatedBy/UpdatedBy 不再与注册流程相关，而是与创建/更新信息的<em class="my">进程</em>相关。在我们了解如何用 dbt 实现审计列之前，让我们先了解一下数据管道设计。</p><h1 id="5a92" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">数据处理设计</h1><p id="27b7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">下图描述了(大)数据处理的通用架构。它的重点是数据处理部分，因此没有添加数据可视化工具。我们从将数据加载到原始层(或阶段)开始，并从那里将其转换和处理到集成层。在集成层之上，可能会创建其他数据集市或层:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/cf5fd2c140e681711ef8d81b452c5904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jmMnvc_XcgRjd-cM.png"/></div></div></figure><p id="c9e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">源可以是生成数据的任何其他应用程序。在这种情况下，我们的源将是负责注册表单的应用程序。该应用程序中的数据可以通过多种方式交付:</p><ul class=""><li id="571d" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">文件交付，通常包含所有用户或所有新的/修改的用户(这被称为完全/增量批处理方法)</li><li id="18f6" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">事件交付，通常包含由注册表单生成的事件(这称为流方法)</li><li id="336b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">数据同步，通常基于数据库中的变更事件(这称为变更数据捕获方法)</li></ul><p id="a126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，源系统不会保存历史。根据多种因素，应用程序会在更改时覆盖记录。这就是为什么数据被发送到数据平台，在那里建立历史和分析应用程序可以开发。</p><p id="d548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一层是原始/暂存层，其中的数据是作为从源接收的数据的精确副本加载的。根据使用情况，这一层可以是持久的，也可以是临时的。我在同一个框中使用 raw/stage，因为如果我们看云数据仓库，它们在意义上可能会重叠。</p><p id="9d7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集成层是数据建模活动发生的层。集成可能是:</p><ul class=""><li id="3f6a" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">技术:创建代理键，添加技术有效性间隔，创建外键或</li><li id="bc37" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">功能性:添加从业务角度看有意义的属性(用户类型、登录次数等)。</li></ul><p id="bd46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据用例的不同，可能会有技术层和业务层。</p><p id="e03a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据集市层不是强制性的。如果集成层包含所需的信息，就没有必要拥有数据集市。但是它可能有助于实现数据最小化和其他关于数据使用的规则。</p><h1 id="6fa5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">dbt 实践</h1><p id="0f58" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">从这一章开始，我将带您从数据源开始处理数据，确保我们添加了审计信息。该代码可在<a class="ae mz" href="https://github.com/acirtep/data-management-exercises-dbt" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。请记住，这是一个游乐场仓库。在专业环境中，事情完全是以不同的方式完成的！查看您有兴趣在生产环境中使用的每个部件的文档链接。</p><p id="065d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，dbt 推荐的最佳实践是拥有阶段-中间-集市层，其中阶段是原始层之上的 1:1 视图。从性能和架构的角度来看，我并不 100%同意这种方法，所以我不会遵循它。这些练习的设置是一个<em class="my">持久化的</em>原始层，数据从该层转换到集成层。</p><h1 id="8e52" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置</h1><p id="1f64" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在 docker-compose 的帮助下，我们开发了两个服务:一个 postgres 数据库和一个 python 应用程序。python 应用程序包含对原始层的加载和 dbt 设置。当执行 docker-compose up 时，python 服务将作为入口点执行多个命令:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="659d" class="mt km iq mp b gy mu mv l mw mx">command: <br/>      - bash<br/>      - -c<br/>      - |<br/>        python /app/data_management_exercises/load_raw/create_raw_layer.py<br/>        python /app/data_management_exercises/load_raw/initial_load_user_data.py<br/>        dbt deps<br/>        dbt run --full-refresh --model fact_user_registration<br/>        python /app/data_management_exercises/load_raw/load_updated_user_data.py<br/>        dbt run --model fact_user_registration<br/>        dbt docs generate<br/>        dbt docs serve</span></pre><ol class=""><li id="4bf0" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk na lu lv lw bi translated">创建原始图层模式</li><li id="ef4c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">执行对 raw 的初始加载</li><li id="835e" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">安装了 dbt 依赖项</li><li id="2222" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">完全刷新</li><li id="b8f4" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">在 raw_layer 中加载增量数据</li><li id="577a" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">将增量数据添加到 integration _ layes</li><li id="96ff" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">生成文档</li><li id="c721" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated">服务文档</li></ol><p id="c41e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的终端中看到此消息意味着它正在成功运行:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="eb28" class="mt km iq mp b gy mu mv l mw mx">dbt_dm_app     | 13:09:14  Catalog written to /app/data_management_exercises/target/catalog.json<br/>dbt_dm_app     | 13:09:34  Running with dbt=1.2.0<br/>dbt_dm_app     | 13:09:34  Serving docs at 0.0.0.0:8080<br/>dbt_dm_app     | 13:09:34  To access from your browser, navigate to:  http://localhost:8080<br/>dbt_dm_app     | 13:09:34  <br/>dbt_dm_app     | 13:09:34</span></pre><p id="b1d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dbt 不提供从源数据加载到原始数据的功能。所以我创建了一个 Python 脚本，将一些虚拟数据加载到 Postgres 表中。我使用 faker 生成假数据，使用 sqlalchemy 和 pandas 将数据加载到一个名为 raw_user_registration_events 的表中。我选择了一个描述性的名称，即使这个表可以很容易地命名为 only users。通过添加后缀“registration_events ”,我清楚地表明该表包含了与注册表单相关的事件:它捕获了注册以及与之相关的属性的任何变化。</p><p id="4b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有两种方法加载数据:</p><ul class=""><li id="e177" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">full，这将从头开始重新创建表(类似于 dbt 中的表具体化)</li><li id="386d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">增量，将数据追加到现有的表中</li></ul><p id="0b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这些数据是为游乐场准备的，所以我简单地使用了 sqlalchemy 和 pandas。我本可以使用 dbt 的种子，但使用它们可能会发出错误的信号。不要将它们用于加载步骤！</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="4119" class="mt km iq mp b gy mu mv l mw mx">if __name__ == "__main__":<br/>    initial_user_data = get_initial_user_data()<br/>    initial_user_data_df = pandas.DataFrame(initial_user_data)<br/>    initial_user_data_df['load_timestamp'] = datetime.now() - timedelta(1)<br/>    pg_conn = get_pg_conn()<br/>    initial_user_data_df.to_sql(<br/>        name='raw_user_registration_events',<br/>        schema='raw_layer',<br/>        con=pg_conn,<br/>        if_exists='replace',<br/>        index=False<br/>    )<br/>    pg_conn.close()</span><span id="2890" class="mt km iq mp b gy nb mv l mw mx">if __name__ == "__main__":<br/>    pg_conn = get_pg_conn()<br/>    user_data_df = pandas.read_sql(<br/>        'select username, email_address, first_name, created_by, created_timestamp \<br/>        from raw_layer.raw_user_registration_events limit 5;', pg_conn)<br/>    user_data_df = add_updated_attributes(user_data_df)<br/>    user_data_df['load_timestamp'] = datetime.now()<br/>    <br/>    user_data_df.to_sql(<br/>        name='raw_user_registration_events',<br/>        schema='raw_layer',<br/>        con=pg_conn,<br/>        if_exists='append',<br/>        index=False<br/>    )<br/>    pg_conn.close()</span></pre><p id="ee25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始载荷和增量载荷之间的区别是:</p><ul class=""><li id="b367" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">在初始加载中，该表被删除并重新创建</li><li id="836e" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">在初始加载中，时间戳设置为昨天，在增量加载中设置为现在</li><li id="b52d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">增量加载由初始加载中加载的 5 条记录组成，包含对姓氏和审计列的更新</li></ul><p id="7902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原始层中的数据示例:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="0483" class="mt km iq mp b gy mu mv l mw mx">dbt_db=# select * from raw_layer.raw_user_registration_events limit 5;<br/>    username    |    email_address     | first_name | last_name | created_by |  created_timestamp  | updated_by |  updated_timestamp  |       load_timestamp       <br/>----------------+----------------------+------------+-----------+------------+---------------------+------------+---------------------+----------------------------<br/> ryanbrown      | tjackson@example.com | Elizabeth  | Mccall    | api_v22    | 2022-08-16 16:30:46 | api_v22    | 2022-08-16 16:30:46 | 2022-08-18 12:13:03.920983<br/> angelajohnson  | steven74@example.org | Victoria   | Brown     | api_v22    | 2022-08-16 04:03:36 | api_v22    | 2022-08-16 04:03:36 | 2022-08-18 12:13:03.920983<br/> twilliams      | lisa12@example.com   | Jeremy     | Salinas   | api_v22    | 2022-08-12 01:47:42 | api_v22    | 2022-08-12 01:47:42 | 2022-08-18 12:13:03.920983<br/> ralphschultz   | adam41@example.com   | Gregory    | Dean      | api_v22    | 2022-08-17 15:13:17 | api_v22    | 2022-08-17 15:13:17 | 2022-08-18 12:13:03.920983<br/> katherineprice | tking@example.org    | Ashley     | Roberts   | api_v22    | 2022-08-10 08:41:13 | api_v22    | 2022-08-10 08:41:13 | 2022-08-18 12:13:03.920983<br/>(5 rows)</span></pre><p id="df2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，即使在这一层，我也添加了一个审计列:<em class="my"> load_timestamp </em>。这对于存储非常重要，因为基于它，您可以:</p><ul class=""><li id="d262" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">确定数据加载的时间</li><li id="bfc5" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">如果您希望进行增量读取，可以对其进行筛选/分区，这与大数据处理相关</li><li id="2145" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">用它进行<em class="my">技术</em>时间旅行</li></ul><h1 id="9c39" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">dbt 模型</h1><p id="d2d7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">考虑到我接收的数据类型，我决定使用<em class="my">事实</em>作为表名前缀。作为事实但没有任何度量的表被称为无事实事实。</p><p id="bc90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从原始层到集成层的加载步骤有一些重要的变化:</p><ul class=""><li id="db76" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">我利用源代码来维护我的 dbt 项目中的血统(为什么？惊喜！)</li></ul><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="f205" class="mt km iq mp b gy mu mv l mw mx">version: 2</span><span id="5e69" class="mt km iq mp b gy nb mv l mw mx">sources:<br/>  - name: raw_layer<br/>    database: dbt_db<br/>    schema: raw_layer<br/>    tables:<br/>      - name: raw_user_registration_events<br/>        columns:<br/>          - name: username<br/>            description: "Username"<br/>          - name: email_address<br/>            description: "Email address used in the registration form"<br/>          - name: first_name<br/>            description: "The first name of the user"<br/>          - name: last_name<br/>            description: "The last name of the user"<br/>          - name: created_by<br/>            description: "User, process or version which created the record"<br/>          - name: created_timestamp<br/>            description: "User first registration time"<br/>          - name: updated_by<br/>            description: "User, process or version which updated the record"<br/>          - name: updated_timestamp<br/>            description: "Update time of the record in the source system"<br/>          - name: load_timestamp<br/>            description: "Time of load from source into the raw_layer"</span></pre><ul class=""><li id="6d1b" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">我转换了列以确保正确的数据类型</li></ul><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="02ef" class="mt km iq mp b gy mu mv l mw mx">{{ <br/>    config(<br/>        materialized = 'incremental'<br/>        ) <br/>}} </span><span id="1e1a" class="mt km iq mp b gy nb mv l mw mx">select<br/>    cast({{ dbt_utils.surrogate_key(['username', 'updated_timestamp']) }} as varchar(128)) as event_sk,<br/>    cast(username as varchar(30)) username,<br/>    cast(email_address as varchar(320)) email_address,<br/>    cast(first_name as varchar(100)) first_name,<br/>    cast(last_name as varchar(100)) last_name,<br/>    cast(created_by as varchar(10)) created_by,<br/>    cast(created_timestamp as timestamp) created_timestamp,<br/>    cast(updated_by as varchar(10)) updated_by,<br/>    cast(updated_timestamp as timestamp) updated_timestamp,<br/>    {{ get_audit_columns() }}<br/>from {{ source ('raw_layer', 'raw_user_registration_events') }}</span><span id="fcbe" class="mt km iq mp b gy nb mv l mw mx">{% if is_incremental() %}</span><span id="6092" class="mt km iq mp b gy nb mv l mw mx">  where cast(load_timestamp as date) = cast(current_date as date)</span><span id="8166" class="mt km iq mp b gy nb mv l mw mx">{% endif %}</span></pre><p id="3fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完全刷新后，只需预览一下数据:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="f94d" class="mt km iq mp b gy mu mv l mw mx">dbt_db=# select * from  integration_layer.fact_user_registration limit 5;<br/>             event_sk             |    username    |    email_address     | first_name | last_name | created_by |  created_timestamp  | updated_by |  updated_timestamp  |    dbt_inserted_timestamp     |           dbt_execution_id           <br/>----------------------------------+----------------+----------------------+------------+-----------+------------+---------------------+------------+---------------------+-------------------------------+--------------------------------------<br/> 9bd7b86d7193954910ef1d1349b05735 | ryanbrown      | tjackson@example.com | Elizabeth  | Mccall    | api_v22    | 2022-08-16 16:30:46 | api_v22    | 2022-08-16 16:30:46 | 2022-08-19 12:20:45.964459+00 | 52f445a2-66f2-4947-abfd-e54a7a3cbfb4<br/> 0767c505fe7deb060e14d84ac98b0c1e | angelajohnson  | steven74@example.org | Victoria   | Brown     | api_v22    | 2022-08-16 04:03:36 | api_v22    | 2022-08-16 04:03:36 | 2022-08-19 12:20:45.964459+00 | 52f445a2-66f2-4947-abfd-e54a7a3cbfb4<br/> a5cc0ed6ada714e7ff29894322ae2a90 | twilliams      | lisa12@example.com   | Jeremy     | Salinas   | api_v22    | 2022-08-12 01:47:42 | api_v22    | 2022-08-12 01:47:42 | 2022-08-19 12:20:45.964459+00 | 52f445a2-66f2-4947-abfd-e54a7a3cbfb4<br/> 5ac5a072f29ac8429f0ef7ada12a0080 | ralphschultz   | adam41@example.com   | Gregory    | Dean      | api_v22    | 2022-08-17 15:13:17 | api_v22    | 2022-08-17 15:13:17 | 2022-08-19 12:20:45.964459+00 | 52f445a2-66f2-4947-abfd-e54a7a3cbfb4<br/> 83998db3f6bc8155eec3ed2fe7eac421 | katherineprice | tking@example.org    | Ashley     | Roberts   | api_v22    | 2022-08-10 08:41:13 | api_v22    | 2022-08-10 08:41:13 | 2022-08-19 12:20:45.964459+00 | 52f445a2-66f2-4947-abfd-e54a7a3cbfb4<br/>(5 rows)</span></pre><p id="c746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该层的数据与原始层的数据相比如何？</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/925f79e4c9f150e26f338a84c6402493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QrjY5Y0PHHhhHgoN.png"/></div></div></figure><p id="b9b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在这一层，我们已经应用了造型，并相应地定义了我们的数据。通过这样做，我们启用了“写错误”模式:如果列不符合其数据类型，加载将失败。其他变化包括:</p><ul class=""><li id="27f1" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">添加代理键，以唯一地标识事件</li><li id="db13" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">添加 dbt_inserted_timestamp 以反映插入的时间</li><li id="e139" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">我们不传播 load_timestamp，因为这会产生数据冗余，并且它不会在集成层中产生值(想象一下数据的重新交付)</li></ul><p id="0c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在源系统中我们有 2 个时间组件，这里我们有 3 个:</p><ul class=""><li id="2f7a" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">报名的那一刻</li><li id="a6ff" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">更新姓氏的时刻</li><li id="d946" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">将数据加载到集成层的时刻</li></ul><p id="5ad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些组件帮助我们回答数据审计中需要回答的问题。它们还帮助我们进行时间旅行，是再现性的关键。你在表定义中还看到了什么额外的东西？</p><h1 id="1b23" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">dbt 元数据</h1><p id="32b3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">每当执行 dbt 命令时，都会生成一个日志文件。默认情况下，日志将放在日志目录下，但这可以更改。从 dbt 1.2.0 开始，也可以在 CLI 中配置日志路径。</p><p id="b28b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看增量执行后的日志文件:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/449517f6d98ac6251812111774b2f9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PZXSUAWcLWK7Vnhx.png"/></div></div></figure><p id="d18a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，时间戳旁边的字符串是什么？不是别的，就是 invocation_id，也就是我们的“由审计列创建”。我们可以通过使用 invocation_id jinja 函数将它与我们的数据存储在一起。现在我们可以分析数据处理是如何发生的:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="0e25" class="mt km iq mp b gy mu mv l mw mx">dbt_db=# select dbt_execution_id, dbt_inserted_timestamp, count(*) from integration_layer.fact_user_registration group by 1,2 order by 2;<br/>           dbt_execution_id           |    dbt_inserted_timestamp     | count <br/>--------------------------------------+-------------------------------+-------<br/> 52f445a2-66f2-4947-abfd-e54a7a3cbfb4 | 2022-08-19 12:20:45.964459+00 |    25<br/> 19bd3ff6-6179-408a-8a45-4ae751b10598 | 2022-08-19 12:33:00.227058+00 |     5</span></pre><p id="a75d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们想知道 execution_id 是什么？因为它是某个 dbt 调用的唯一标识符，并且基于它，dbt(在 dbt cloud 版本中)将为您提供类似用于该运行的 SQL 查询的信息，这有助于数据管理的可追溯性部分。有了这些信息，它还可以帮助您在生产环境中进行影响分析或调试。</p><p id="0f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SQL 也可以在</p><ul class=""><li id="0989" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">在调试日志中</li><li id="fd6b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">在执行 dbt 编译后的编译目录中。</li></ul><p id="f4ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用宏，我可以轻松地在我的模型中标准化审计列:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="5bb1" class="mt km iq mp b gy mu mv l mw mx">{% macro get_audit_columns() %}<br/>current_timestamp as dbt_inserted_timestamp,<br/>cast('{{ invocation_id }}' as varchar(128)) as dbt_execution_id<br/>{% endmacro %}</span></pre><h1 id="7792" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">dbt 文档</h1><p id="3a07" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们都喜欢自动化文档，所以我们选择用 dbt 生成文档也就不足为奇了。</p><p id="f6a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过执行<em class="my"> dbt docs generate </em>，dbt 将解析来自您的存储库和数据库元数据的信息，将其保存在目标目录下，并创建 html 页面，将信息呈现在网页上。</p><p id="50ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过执行<em class="my">dbt docs serves</em>，dbt 将在 localhost:8080 上运行一个 docs 网页，该网页将显示在生成步骤中收集的信息。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/6c26197aaa18d79693b511c96ca3efef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dQPQmTHdfvtoh1FJ.png"/></div></div></figure><p id="7b37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你还记得我在项目中也配置了我的资源吗？因此，我可以在谱系图中看到它们:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/2c400757cb64d3d098599f0e019758da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dRXbYK4aDwdjlT_h.png"/></div></div></figure><p id="3291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你认为在 docs 应用程序中提供元数据怎么样？这将极大地有助于进行审计和数据发现。</p><h1 id="0f25" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="67a2" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">无论使用何种数据处理工具，都必须确保数据的可审计性。小小的第一步是准备好审计列，这样我们可以直接回答简单的问题，或者通过分析所用工具的元数据来回答。</p><p id="92b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了您的数据，您还发现了哪些其他相关信息？编排流程的执行 id、代码的版本、允许运行代码的技术用户是什么？它们都是有效的选项，我承认我通常会添加它们。</p><h1 id="7bcf" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">观察</h1><p id="d26f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在写这篇文章的时候，我在 dbt 中钻研了很久。我浏览了 github 库，分析了日志，尝试了不同的配置。</p><p id="bcd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我非常惊讶地看到每次运行时有多少查询被发送到数据库，如何进行增量装载，如何使用临时表，以及在执行 1:1 插入后。我没有在生产中见过 dbt(事实上我曾用 AWS Glue 替换它)，但我很想知道这种方法是否有效。</p><p id="8177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从 postgres 日志中，每当我运行 dbt 时，我还会看到一条警告消息:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="3f91" class="mt km iq mp b gy mu mv l mw mx">root@e34ae017ecb9:/app/data_management_exercises# dbt run<br/>13:39:21  Running with dbt=1.2.0<br/>13:39:22  Found 1 model, 11 tests, 0 snapshots, 0 analyses, 476 macros, 0 operations, 0 seed files, 1 source, 0 exposures, 0 metrics<br/>13:39:22  <br/>13:39:23  Concurrency: 1 threads (target='dev')<br/>13:39:23  <br/>13:39:23  1 of 1 START incremental model integration_layer.fact_user_registration ........ [RUN]<br/>13:39:24  1 of 1 OK created incremental model integration_layer.fact_user_registration ... [INSERT 0 5 in 1.30s]<br/>13:39:24  <br/>13:39:24  Finished running 1 incremental model in 0 hours 0 minutes and 2.04 seconds (2.04s).<br/>13:39:24  <br/>13:39:24  Completed successfully<br/>13:39:24  <br/>13:39:24  Done. PASS=1 WARN=0 ERROR=0 SKIP=0 TOTAL=1<br/>root@e34ae017ecb9:/app/data_management_exercises#</span><span id="e8b4" class="mt km iq mp b gy nb mv l mw mx">dbt_dm_pg      | 2022-08-19 13:39:23.013 UTC [120] WARNING:  there is already a transaction in progress<br/>dbt_dm_pg      | 2022-08-19 13:39:23.162 UTC [121] WARNING:  there is already a transaction in progress<br/>dbt_dm_pg      | 2022-08-19 13:39:23.204 UTC [121] WARNING:  there is already a transaction in progress<br/>dbt_dm_pg      | 2022-08-19 13:39:24.014 UTC [122] WARNING:  there is already a transaction in progress<br/>dbt_dm_pg      | 2022-08-19 13:39:24.659 UTC [123] WARNING:  there is already a transaction in progress</span></pre><p id="48f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我检查 dbt.log 时，我看到了与 dbt 触发的 SQL 相对应的警告。从表面上看，连接完成得很好，但是缺少事务的结束。我认为这可能是 dbt 如何处理 Postgres 事务的一个问题，即使在运行期间 Postgres 连接似乎没有增加，并且它们被正确关闭。</p><p id="0211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于 docs，有一个关于描述的小问题:当使用 dbt 创建一个表时，schema.yml 中的描述不会作为注释添加到数据库目录中的表中。为了持久化该描述，您需要在 dbt_project.yml 文件中配置 persist_docs。但是通过这样做，每次 dbt 运行都将在表/列级别执行注释的添加。</p><h1 id="1ab0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">证明文件</h1><ol class=""><li id="98b4" class="lo lp iq jp b jq lj ju lk jy nc kc nd kg ne kk na lu lv lw bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Data_auditing" rel="noopener ugc nofollow" target="_blank">数据审计维基</a></li><li id="3fbe" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://faker.readthedocs.io/en/master/#" rel="noopener ugc nofollow" target="_blank">造假单据</a></li><li id="1d68" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://pandas.pydata.org/docs/reference/api/pandas.read_sql.html" rel="noopener ugc nofollow" target="_blank">熊猫读取 sql API </a></li><li id="f81c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/reference/events-logging" rel="noopener ugc nofollow" target="_blank"> dbt 日志</a></li><li id="6f2d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/reference/commands/compile" rel="noopener ugc nofollow" target="_blank"> dbt 编译</a></li><li id="4286" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/docs/dbt-cloud/dbt-cloud-api/metadata/metadata-overview" rel="noopener ugc nofollow" target="_blank"> dbt 元数据 API </a></li><li id="d264" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/docs/building-a-dbt-project/using-sources" rel="noopener ugc nofollow" target="_blank"> dbt 源参考</a></li><li id="6c88" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/guides/legacy/best-practices" rel="noopener ugc nofollow" target="_blank"> dbt 最佳实践</a></li><li id="67c0" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/guides/best-practices" rel="noopener ugc nofollow" target="_blank"> dbt 云最佳实践</a></li><li id="ecc1" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros" rel="noopener ugc nofollow" target="_blank"> dbt 宏</a></li><li id="1f06" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk na lu lv lw bi translated"><a class="ae mz" href="https://docs.getdbt.com/docs/building-a-dbt-project/documentation" rel="noopener ugc nofollow" target="_blank"> dbt 文档</a></li></ol><p id="a16d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首发@ <a class="ae mz" href="https://ownyourdata.ai/wp/a-way-to-ensure-auditability-in-data-processing/" rel="noopener ugc nofollow" target="_blank"> ownyourdata.ai </a>。</p></div></div>    
</body>
</html>