<html>
<head>
<title>Working with Hooks in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 中使用钩子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-hooks-in-react-c1974693241c?source=collection_archive---------16-----------------------#2022-03-03">https://blog.devgenius.io/working-with-hooks-in-react-c1974693241c?source=collection_archive---------16-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="2e89" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="c20e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">钩子是 React 中的一个新特性，它让你不用写类就可以使用状态和其他 React 特性。挂钩是让您从功能组件“挂钩”React 状态和生命周期特性的功能。</p><p id="81a4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在 React 发布钩子之前，您只能使用类组件中的生命周期方法来操作或更新<code class="fe ll lm ln lo b">state</code>,但是使用钩子允许您在不编写类的情况下利用 React 的强大功能。钩子提供了一种在组件之间重用功能的强大而富有表现力的新方法。</p><p id="a7c8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">本文将涵盖从基础到高级的钩子概念，在本文结束时，您将理解何时以及如何在您的应用程序中使用不同类型的 React 钩子。</p><h1 id="7d15" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">钩子的规则</h1><p id="1fe1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">有指导钩子使用的规则，为了避免你的代码抛出错误，这些规则必须被遵守。</p><ul class=""><li id="bc69" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">钩子必须在函数或组件体内部被调用。</li><li id="d050" class="lp lq in kk b kl ly kp lz kt ma kx mb lb mc lf lu lv lw lx bi translated">不要有条件地、在循环内部或嵌套函数中调用钩子。</li><li id="e201" class="lp lq in kk b kl ly kp lz kt ma kx mb lb mc lf lu lv lw lx bi translated">命名钩子时，应该以前缀“use”开头。这适用于自定义挂钩和 React 提供的挂钩。</li><li id="d96c" class="lp lq in kk b kl ly kp lz kt ma kx mb lb mc lf lu lv lw lx bi translated">当使用钩子时，组件必须是大写的。</li></ul><h1 id="dc0b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用挂钩</h1><p id="58d1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">React 提供了在应用程序中使用钩子的不同方式。这意味着我们可以在应用程序中使用不同的钩子，这取决于我们想要达到的目标。React 也给了我们创建定制钩子的能力，这允许我们重用有状态逻辑。是不是很牛逼！！！</p><p id="b742" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们从看一看 React 中的不同挂钩开始</p><ul class=""><li id="1d31" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">使用状态挂钩</li></ul><p id="b525" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useState 挂钩用于管理和更新 React 应用程序中的<code class="fe ll lm ln lo b">state</code>。它给了我们一个数组，这个数组由两个值组成:T2 和 T3，这个 setter 函数是我们用来更新状态的。useState 钩子也接受默认状态的值。</p><p id="2943" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">示例:</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="a594" class="ml jl in lo b gy mm mn l mo mp">import React, { useState } from "react";<br/><br/>const App = () =&gt; {<br/><br/>  const [text, setText] = useState(false);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;{text === true ? "Sign In" : "Sign Up"}&lt;/h2&gt;<br/>      &lt;button onClick={()=&gt;setText(!text)}&gt;Change Text.&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="15cc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的例子中，每当我们点击<code class="fe ll lm ln lo b">h2 </code>元素时，<code class="fe ll lm ln lo b">button </code>就会更新它的内容，因为有了 useState 钩子，这才有可能。</p><p id="25cb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，我们初始化一个名为<code class="fe ll lm ln lo b">text</code>的新状态变量和一个名为<code class="fe ll lm ln lo b">setText</code>的 setter 函数，然后将这两个变量赋给 useState。</p><p id="c0ee" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后我们返回两个元素，<code class="fe ll lm ln lo b">h2 </code>元素保存状态本身的值，我们声明一个条件语句来检查状态<code class="fe ll lm ln lo b">text</code>是否等于 true。如果是，我们希望显示<code class="fe ll lm ln lo b">Sign In</code>或<code class="fe ll lm ln lo b">Sign Up</code></p><p id="6a81" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">button 元素接受一个 onClick 属性，该属性的值是我们用来更新状态的 setter 函数。每次我们点击这个按钮，React 都会重新渲染组件，从而将正确的值传递给<code class="fe ll lm ln lo b">h2</code>元素。</p><ul class=""><li id="2a09" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">使用效果挂钩</li></ul><p id="7a42" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useEffect 挂钩允许您在函数中执行副作用。副作用包括:从 API 获取数据、改变 DOM 元素、将内容推入数组等。</p><p id="0dd8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useEffect 执行 componentDidMount、componentDidUpdate 和 componentWillUnmount 组合的功能。</p><p id="40ec" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">默认情况下，useEffect 在组件中每次重新渲染后运行，大多数时候我们只希望 useEffect 在挂载时运行。为了解决这个问题，我们必须在 useEffect 中包含一个依赖数组，这在我们想要从 API 获取数据的情况下非常方便。我们不希望每次组件重新渲染时都调用 API，我们只想在 useEffect 安装后立即调用它。</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="a5f6" class="ml jl in lo b gy mm mn l mo mp">useEffect ( () =&gt; {<br/>  //do something here<br/>}, [])</span></pre><p id="a23e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们通过一个例子来看看 useEffect 是如何工作的:</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="0562" class="ml jl in lo b gy mm mn l mo mp">import React, { useState, useEffect } from "react";<br/><br/>const App = () =&gt; {<br/>  const [products, setProducts] = useState({});<br/><br/>  const fetchData = async () =&gt; {<br/>    const response = await fetch("https://fakestoreapi.com/products?limit=5");<br/>    const data = await response.json();<br/>    setProducts(data)<br/>  };<br/><br/>  useEffect(() =&gt; {<br/>    fetchData();<br/>  }, []);<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      {products.map(({image, title, price,id})=&gt;(<br/>        &lt;div key={id} className="container"&gt;<br/>        &lt;img src={image} alt="store" /&gt;<br/>        &lt;p&gt;{title}&lt;/p&gt;<br/>        &lt;p&gt;{price}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      ))}<br/>     <br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default App;</span></pre><p id="a734" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的例子中，我们从一个假的 API 获取数据，映射从 API 得到的结果，最后返回结果。</p><ul class=""><li id="1df0" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">useReducer 挂钩</li></ul><p id="3e0f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useReducer 挂钩是一个用于状态管理的挂钩。您可能想知道为什么 useReducer 钩子执行与 useState 钩子相同的功能。</p><p id="3fb2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useReducer 挂钩和 useState 挂钩都用于状态管理，但它们的使用取决于应用程序的大小。当您有涉及多个子值的复杂状态逻辑时，useReducer 通常比 useState 更可取。它还允许您优化触发深度更新的组件的性能，因为您可以向下传递分派而不是回调。</p><p id="1f61" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useReducer 钩子语法与 useState 非常相似，只是它接受两个参数，即<code class="fe ll lm ln lo b">reducer function</code>和<code class="fe ll lm ln lo b">initial state</code>。初始状态的值可以是任何值，这取决于我们试图初始化什么。它可以是数字、函数、数组、对象等。</p><p id="a629" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们来看看如何通过构建一个简单的计数器在我们的代码中实现 useReducer 挂钩的演示。</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="5af6" class="ml jl in lo b gy mm mn l mo mp">import React, { useReducer } from "react";<br/><br/>function reducer(state, action) {<br/>  switch (action.type) {<br/>    case "increment":<br/>      return state + 1;<br/>    case "decrement":<br/>      return state - 1;<br/>    default:<br/>      return state;<br/>  }<br/>}<br/><br/>const App = () =&gt; {<br/>  const [count, dispatch] = useReducer(reducer, 0);<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;Count: {count} &lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type:"decrement"})}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type:"increment"})}&gt;+&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="25b8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，我们声明一个保存当前状态和<code class="fe ll lm ln lo b">dispatch</code>函数的数组，然后将它分配给 useReducer 钩子。useReducer 钩子接受两个值，它们是 Reducer 函数和初始状态。在这种情况下，初始状态为 0。</p><p id="8797" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，我们返回从函数返回值的 JSX 元素。<code class="fe ll lm ln lo b">h1</code>元素保存了<code class="fe ll lm ln lo b">count</code>的值，以及增加和减少<code class="fe ll lm ln lo b">count</code>值的两个按钮。每个按钮都有一个<code class="fe ll lm ln lo b">onClick</code>属性，我们将传递<code class="fe ll lm ln lo b">dispatch</code>函数给它。<code class="fe ll lm ln lo b"> The dispatch</code>函数还包含一个参数，表示我们想要执行的动作类型，在本例中，我们想要递增和递减。</p><p id="7e50" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最后，我们在 main 函数之外声明我们的 reducer 函数。该减速器函数接受两个参数<code class="fe ll lm ln lo b">state</code>和<code class="fe ll lm ln lo b">action</code>。现在我们想使用一个 switch 语句来检查已经在<code class="fe ll lm ln lo b">dispatch</code>函数中声明的动作类型。因此，如果动作的类型是递增，我们希望状态增加 1，如果是递减，我们希望状态减少 1，否则什么都不会发生。</p><ul class=""><li id="4f4e" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">使用上下文挂钩</li></ul><p id="0beb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useContext 挂钩允许我们使用 React 的上下文 API，它本身是一种机制，允许我们在它的组件树内共享数据，而无需通过 props。它基本上消除了道具钻井！</p><p id="9e1d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useContext 挂钩接受 Context 对象，该对象是从 React.createContext 返回的值，并返回当前上下文值，该值由给定上下文的最近上下文提供程序提供。</p><p id="48e8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们通过构建一个随机密码生成器来看看它是如何工作的</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="ac71" class="ml jl in lo b gy mm mn l mo mp">import React,{useContext, createContext, useState} from "react";<br/><br/>const RandomPasswordContext = createContext();<br/>const SetRandomPasswordContext = createContext();<br/><br/>function RandomPassword() {<br/>  const randomPassword = useContext(RandomPasswordContext);<br/>  return &lt;div&gt;Password: {randomPassword}&lt;/div&gt;;<br/>}<br/><br/>function PasswordGenerator() {<br/>  let text =""<br/>  let characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";<br/>  const setRandomNumber = useContext(SetRandomPasswordContext);<br/>  const generateRandomNumber = () =&gt; {<br/>      for (let i = 1; i &lt; 7; i++){<br/>    setRandomNumber (text+=characters.charAt(Math.floor(Math.random() * characters.length)));<br/>  }<br/>};<br/>  return &lt;button onClick={generateRandomNumber}&gt;Generate Random Password&lt;/button&gt;;<br/>}<br/><br/>const App = () =&gt; {<br/>  const [randomNumber, setRandomNumber] = useState(0);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;RandomPasswordContext.Provider value={randomNumber}&gt;<br/>        &lt;SetRandomPasswordContext.Provider value={setRandomNumber}&gt;<br/>          &lt;RandomPassword /&gt;<br/>          &lt;PasswordGenerator /&gt;<br/>        &lt;/SetRandomPasswordContext.Provider&gt;<br/>      &lt;/RandomPasswordContext.Provider&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App</span></pre><ul class=""><li id="c35c" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">useRef 挂钩</li></ul><p id="4302" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useRef 钩子返回一个可变的 Ref 对象，其中<code class="fe ll lm ln lo b">.current</code>属性被初始化为传递的参数(初始值)。这个钩子使得访问功能组件中的 DOM 节点成为可能。我们可以如下使用它:</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="0827" class="ml jl in lo b gy mm mn l mo mp">import React, {useRef} from "react";<br/><br/>const refContainer = useRef(initialValue)</span></pre><p id="5ae0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个钩子用于处理 react 中对元素和组件的引用。我们可以通过向元素传递 ref 属性来设置引用。</p><p id="31d7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们看看如何使用 useRef 钩子的最常见的例子</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="42b8" class="ml jl in lo b gy mm mn l mo mp">import React, { useEffect, useRef } from "react"<br/><br/>const App = () =&gt; {<br/>  const inputEl = useRef(null);<br/>  useEffect(() =&gt; {<br/>    inputEl.current.focus();<br/>  }, []);<br/>  return &lt;input ref={inputEl} type="text" /&gt;;<br/>}<br/><br/>export default App;</span></pre><p id="1afc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的例子中，我们正在访问 input 元素，我们希望在组件安装后立即关注 input 元素。</p><ul class=""><li id="3764" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">使用回调挂钩</li></ul><p id="1b4f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个钩子允许我们传递一个内联回调函数和一组依赖项，并将返回回调函数的记忆版本。当我们想防止在每次渲染时都创建一个函数时，这是很有用的。</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="d9e0" class="ml jl in lo b gy mm mn l mo mp">import React, {useState} from "react";<br/><br/>const Counter = ({increment}) =&gt; {<br/>  return &lt;button onClick={increment}&gt;increase&lt;/button&gt;;<br/>};<br/>const App = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Count : {count}&lt;/p&gt;<br/>      &lt;Counter increment={()=&gt;setCount(count + 1)} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default App;</span></pre><p id="236d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的例子中，每次 App 组件刷新时，都会呈现<code class="fe ll lm ln lo b">setCount</code>函数。我们可以使用<code class="fe ll lm ln lo b">useCallback</code>挂钩来防止这种情况发生。</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="0eb3" class="ml jl in lo b gy mm mn l mo mp">import React, { useState, useCallback } from "react";<br/><br/>const Counter = ({increment}) =&gt; {<br/>  return &lt;button onClick={increment}&gt;increase&lt;/button&gt;;<br/>};<br/>const App = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  const increment = useCallback(()=&gt;{<br/>    setCount(c =&gt; c + 1)<br/>  },[setCount])<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Count : {count}&lt;/p&gt;<br/>      &lt;Counter increment={increment} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default App;</span></pre><p id="29f0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当向优化的子组件传递回调时，useCallback 钩子很有用。它的工作方式类似于 useMemo 钩子，但是用于回调函数。</p><ul class=""><li id="2b42" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">使用备忘录挂钩</li></ul><p id="f20e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">记忆化是一种优化技术，其中函数调用的结果被缓存，然后在相同的输入再次出现时被返回。useMemo 钩子允许我们计算一个值并记忆它。我们可以如下使用它:</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="3099" class="ml jl in lo b gy mm mn l mo mp">import { useMemo } from 'react'<br/><br/>  const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</span></pre><p id="e10a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当我们想要避免重复执行昂贵的操作时，useMemo 钩子对于优化是有用的。</p><ul class=""><li id="cf67" class="lp lq in kk b kl lg kp lh kt lr kx ls lb lt lf lu lv lw lx bi translated">useLayoutEffect</li></ul><p id="3392" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个钩子与 useEffect 相同，但是它只在所有文档对象模型(DOM)突变后触发。我们可以如下使用它:</p><pre class="md me mf mg gt mh lo mi mj aw mk bi"><span id="206a" class="ml jl in lo b gy mm mn l mo mp">import { useLayoutEffect } from 'react'<br/><br/>  useLayoutEffect(didUpdate)</span></pre><p id="7383" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">useLayoutEffect 钩子可以用来从 DOM 中读取信息。</p><p id="d095" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">尽可能使用 useEffect 挂钩，因为 useLayoutEffect 会阻止可视化更新并降低应用程序的速度。</p><p id="1126" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以这些都在“在 React 中使用钩子”中，以后我会有更多这样的文章。</p><p id="ac04" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在那之前，请继续关注我！</p></div></div>    
</body>
</html>