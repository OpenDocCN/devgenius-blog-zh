<html>
<head>
<title>Part Three: Security in React and WebApi in ASP.NET Core C# with authentication and authorization by KeyCloak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第三部分:React 和 WebApi 在 ASP.NET Core C #中的安全性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/security-in-react-and-webapi-in-asp-net-core-c-with-authentification-and-authorization-by-keycloak-f890d340d093?source=collection_archive---------0-----------------------#2022-06-12">https://blog.devgenius.io/security-in-react-and-webapi-in-asp-net-core-c-with-authentification-and-authorization-by-keycloak-f890d340d093?source=collection_archive---------0-----------------------#2022-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bb1f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第三部分:用 JWT 认证保护 ASP.NET 核心 C # REST Web API<br/>版本 1.0 <br/>日期 2022/06/12 <br/>作者 Nicolas Barlatier</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/46c0b1213fb8e3dd08e987d284fe544f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a31Xm3U3vm3fy3qGnySsdA.png"/></div></div></figure><p id="c68d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你错过了第一部分:<br/> <a class="ae lk" href="https://medium.com/p/1d076777a979" rel="noopener">第一部分:用 Docker 和 Administration 安装 key cloak</a></p><p id="2d81" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您错过了第二部分:<br/> <a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/security-in-react-and-webapi-in-asp-net-core-c-with-authentification-and-authorization-by-keycloak-89ba14be7e5a">第二部分:保护前端 React 应用程序</a></p><p id="ca03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后第四部分:<br/> <a class="ae lk" href="https://medium.com/@barlatiernicolas/part-four-security-in-react-and-webapi-in-asp-net-b6dffd3b7624" rel="noopener">第四部分:从 React SPA 调用受保护的 Web API，使用访问 JWT 令牌载体授权</a></p><p id="6669" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你需要了解更多关于 RS256 JWT 验证的知识:<br/> <a class="ae lk" href="https://systemweakness.com/part-1-cryptography-in-net-c0f78cfa9326" rel="noopener ugc nofollow" target="_blank">第 1 部分:密码学。NET Core 5.0:关于 RSA 和 RS256 签名和验证您需要知道的一切。</a></p><p id="d399" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要在 Docker 中使用<strong class="kq io">前端 React 应用程序，您可以阅读:</strong></p><p id="5da6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://medium.com/@barlatiernicolas/dockerizing-the-typescript-react-app-with-nodejs-vs-nginx-with-wsl2-alpine-linux-on-windows-10-8dddd447f43a" rel="noopener">第一部分在 Windows 10 上用 NodeJS 和 NGINX 对 TypeScript React App 和 WSL2 Alpine Linux 进行 dockering</a></p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="20fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">包含 React 和 Web API 项目的 GitHub 存储库</p><ul class=""><li id="6a91" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated"><strong class="kq io">用类型脚本对 18.1.0 版做出反应</strong></li><li id="ad8d" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">【ASP.NET 核心 5.0 的 T21 网络应用编程接口</li></ul><div class="mg mh gp gr mi mj"><a href="https://github.com/nicoclau/reactwebapiaspnetcorekeycloak" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">GitHub—nicoclau/reactwebapiaspnetcorekeycloak:React 和 REST 受 keycloak 保护的 Web API 与…</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">React 和 REST Web API 由带有授权代码流和 JWT 令牌的 Keycloak 保护— GitHub …</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx km mj"/></div></div></a></div><p id="d744" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您有两个提交:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/38a6e19aea67aef3f2d66e21b54cde1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*j7erUTzcaMTRKGUaGI49-Q.png"/></div></figure><p id="25eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一次提交包含:</p><ul class=""><li id="a74a" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">由 keycloak 服务器保护的 React SPA</li><li id="2d3b" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">Web API 由访问令牌保护，使用来自 keycloak 服务器的公钥进行验证</li></ul><p id="3578" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两个应用程序还没有通信，它们只是受到保护。</p><p id="4b0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二次提交包含:</p><ul class=""><li id="991a" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">React SPA 使用 JWT 令牌与 Web API 通信，并处理 CORS 策略</li></ul></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="0700" class="mz na in bd nb nc nd ne nf ng nh ni nj jt nk ju nl jw nm jx nn jz no ka np nq bi translated">介绍</h1><p id="7034" class="pw-post-body-paragraph ko kp in kq b kr nr jo kt ku ns jr kw kx nt kz la lb nu ld le lf nv lh li lj ig bi translated">到目前为止，我们已经看到了如何使用 Keycloak 来保护我们的<strong class="kq io"> SPA 应用程序</strong>。</p><p id="a7ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果没有任何<strong class="kq io">服务</strong>反馈<strong class="kq io">信息和</strong>数据<strong class="kq io">数据</strong>，那么<strong class="kq io"> SPA 应用</strong>将会变得毫无用处。这里我们将关注一种类型的服务:Rest Web API。我们需要保护它。</p><blockquote class="nw nx ny"><p id="9256" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">用户与 SPA/移动应用/桌面应用/Web 应用/CLI/…进行交互，并将使用<strong class="kq io"> OpenID Connect(授权码授予)</strong>进行身份验证。授权服务器将发出一个<code class="fe od oe of og b">id_token</code>(由应用程序用来<strong class="kq io">认证用户</strong>)和一个<code class="fe od oe of og b">access_token</code>(由应用程序用来代表用户调用 API <strong class="kq io">。)</strong></p></blockquote><p id="b63b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以 SPA 收到了两个带有 OpendConnectID 协议的令牌:ID 令牌和访问令牌。我们将看到,<strong class="kq io">访问令牌</strong>将用于访问我们的受保护资源:REST API。因为这个令牌将包含关于授权的声明。</p><p id="c810" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，我们将使用服务是外部服务的架构；它将作为外部 REST API 托管。</p><p id="f236" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是什么意思？这意味着 REST API 将托管在不同的机器/虚拟机/网络上，并且可以通过与用于访问 SPA 的域不同的域中的 URI 进行访问。</p><p id="0410" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是 SPA、外部 REST API 和 Keycloak 之间的完整工作流:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/fc7aaa921b1cd7924ee13bbe669de8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBVptK6c5L7a0I-d-YTB5A.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">SPA Keycloak 和外部 REST API 之间的流程</figcaption></figure><p id="ed89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经详细了解了步骤 1、2 和 3</p><p id="1a41" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我们将详细说明步骤:4 和 5。</p><p id="fcfc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">SPA 将在步骤 4 中访问外部 REST API。<br/>REST API 将受到<strong class="kq io">承载认证方法</strong>的保护。</p><p id="1b4e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 9 月 5 日，响应将返回 CORS 头，因为 REST API 托管在不同于 React SPA 使用的域中。</p><p id="1cab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么使用这种方法进行载体认证？</p><p id="f033" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">承载认证</strong>(也称<strong class="kq io">令牌认证</strong>)是一种<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication" rel="noopener ugc nofollow" target="_blank"> HTTP 认证方案</a>，涉及<strong class="kq io">安全令牌</strong>称为<strong class="kq io">承载令牌</strong>。名称“载体认证”可以理解为“给予该令牌的载体访问权”承载令牌是一个加密字符串，通常由服务器生成以响应登录请求。当向受保护的资源发出请求时，客户端必须在<code class="fe od oe of og b">Authorization</code>报头中发送该令牌:</p><ul class=""><li id="d0ee" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated"><code class="fe od oe of og b">Authorization: Bearer &lt;token&gt;</code></li></ul><p id="dedd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">承载认证方案最初是作为<a class="ae lk" href="https://tools.ietf.org/html/rfc6750" rel="noopener ugc nofollow" target="_blank"> RFC 6750 </a>中<a class="ae lk" href="https://swagger.io/docs/specification/authentication/oauth2/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 </a>的一部分创建的，但有时也单独使用。承载身份验证应仅用于 HTTPS (SSL)。</p><p id="560e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，将使用什么令牌？<strong class="kq io">访问令牌</strong>确实！为什么？因为它是在<strong class="kq io"> OAuth 2.0 </strong>中使用的令牌！令牌还包含所有<strong class="kq io">需要的声明</strong>，以确保请求被授权或不到达我们的<strong class="kq io">受保护资源</strong>:这里是 REST API。SPA 应用程序使用访问令牌代表用户调用 API。</p><p id="fa1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇博客中，我们将让我们的 REST API 得到完全的保护。对任何方法的任何访问都需要授权。</p><p id="db16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">创建我们的 REST Web Api </strong></p><p id="b0e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们创建我们的项目。这里用的是<strong class="kq io"> Visual Studio 2019 </strong>。我倾向于为前端 React SPA 使用<strong class="kq io">可视代码</strong>，为所有后端解决方案使用<strong class="kq io"> Visual Studio 2019 </strong>。</p><p id="b80d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击“ASP。NET Core Web API”然后接下来</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/c0f0da5b6937621bd760b8f74d31f711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POalxpOLPYSD-PHpsszqKA.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">创建 ASP.NET 核心 Web API 项目</figcaption></figure><p id="06bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们提供“项目名称”和“位置”</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/c326952c8259a83b7b7e0260c2768ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcsDiPd47ZcqkypcYYnGhQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">项目名称和位置</figcaption></figure><p id="9e1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们单击“下一步”，我们将看到构建项目前最重要的步骤:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/d161c4d0a215e64862b46d7f41f26fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8liR91jAVgx6pr3G5VpsdQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">目标框架和 HTTPS</figcaption></figure><p id="b994" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们先用 Visual Studio 2019 选择最近的一个来设置目标框架:。NET 5.0</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/aeae98aac9164f25c8eebbe7f80e9476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TutXCQtfMzJvAZ_wKEPUZw.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">。NET 5.0</figcaption></figure><p id="51d6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们单击“为 HTTPS 配置”,这样我们就可以确保将发送到 Web API 的“访问令牌”将受到 TLS 的保护。</p><p id="199a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们选中“启用 OpenAPI 支持”,以便启用 Swagger。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/8832ad8a257e5f5a0b05a783f623968d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njgQ4_NSvmRPs1m06CAQuw.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">HTTPS 和斯瓦格</figcaption></figure><p id="fa1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击“创建”</p><p id="5d72" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们得到以下解决方案:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi on"><img src="../Images/af8f368debe3f69aac823fdeff5a02bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*bwJDfFJYDYtPv2oKfqOCZA.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">MyWebApi 解决方案</figcaption></figure><p id="5e0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Visual Studio 2019 默认创建了一个 REST Web API，它有一个控制器，可以返回随机的天气预报。</p><p id="4f1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将足以满足我们的需要。</p><p id="f5b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在调试模式下运行 REST API，方法是单击 F5:</p><p id="4872" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将运行 IIS Express</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6cd979cad7f32b1f1e530bb17caead5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*ABgT40zXGxarD0WMkNp0Zg.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">IIS 快速通知</figcaption></figure><p id="714d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以看到我们的应用程序 MyWebApi 的 URL:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi op"><img src="../Images/72369f16c000f025e42d667a360eac85.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*GqS0ZgP-ddrOGwEqpzXlZg.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">MyWebApi Urls</figcaption></figure><p id="91ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而且 Visual Studio 会用一个随机端口自动打开我们的 Chrome 浏览器:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oq"><img src="../Images/6e330317f772a73fded79c03cf9ddd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjQpZcMUv-692THWtF2mAw.png"/></div></div></figure><p id="c665" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它将公开招摇，非常方便地发现服务。</p><p id="8b05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们点击“获取”</p><p id="9a77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将详细了解如何调用该方法</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi or"><img src="../Images/e6b75ae65e7a58430dcacd6319e6552b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SPree7DXKMJGx70yZwdHZw.png"/></div></div></figure><p id="294d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击“试用”，然后点击“执行”</p><p id="2c64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们得到了回应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/cb961a8b28e3d62d9fa4957ebd2c6668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uJ42vJba5DyAj0V0ytbEw.png"/></div></div></figure><p id="a98d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Swagger 是发现我们的 REST Web API 的一个非常方便的标准。</p><p id="ad7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我将通过使用 HTTP GET 方法和发送带有值 text/plain 的头:accept 来再次使用失眠症</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ot"><img src="../Images/bf0decc598687e4aa2bc665560b60a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDiXq3zzMR5UAWe3ZcIw2g.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">失眠:天气预报控制器 HTTP GET 请求和响应</figcaption></figure><p id="a6ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，现在我们确保我们有一个 REST Web API，它运行平稳，但它完全不受保护！</p><p id="c4f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们继续下一部分:</p><p id="7654" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">保护我们的 REST Web Api </strong></p><p id="56e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在更新我们的代码库之前，我们需要了解:我们的 web api 将如何通过使用 JWT 访问令牌进行授权而得到<strong class="kq io">保护？它<strong class="kq io">将如何验证</strong>我们的<strong class="kq io"> JWT 访问令牌</strong>，该令牌将由我们的 SPA React 应用程序在名为<strong class="kq io">授权</strong>的标头中发送，其值为<br/> <strong class="kq io">无记名</strong> &lt;令牌&gt;</strong></p><p id="e710" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一开始真的很混乱，但最后确实很简单。</p><p id="17f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们需要了解 JWT 访问令牌的结构、格式和数据。</p><p id="a016" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还记得我们从失眠中直接得到的表征吗:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/5c35f793a79004c51167ee71b26a372f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INQ8PL0B_XAJ07v-j3fwaw.png"/></div></div></figure><p id="63c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们获取访问令牌:</p><blockquote class="nw nx ny"><p id="b9fe" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">eyjhbgcioijsuzi 1 niis INR 5 ccigoiaislduiiwia 2 KIA 6 icjfmuk 0 rhpmwhuzutrqmm 80 zhdsrfbsovbguzd 6 be w2 mdoagtisu l5 wkq 0 in 0 . eyjlheioje 2 ntq 1 ntexmzusimlhdci 6 mt y1 NDU 1 MDG znswianrpijoidgyotcymgyttu 0 ms 0n TQ 3 ltgytzt TN zu 4 yjewymiy g3ii wiaxnzijoia HR 0 CDO v2 vy 2 fsag 90</p></blockquote><p id="6d31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们用 JWT 网站来解码。我们把<strong class="kq io"> <em class="nz"> 3 部分用“.”隔开</em> </strong></p><p id="34ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/e0150b0b349e1a43a87868778741cb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ck-RmU-HMAaWyebStLI8AQ.png"/></div></div></figure><p id="0988" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要了解 JWT，最好的文章是:</p><div class="mg mh gp gr mi mj"><a href="https://arielweinberger.medium.com/json-web-token-jwt-the-only-explanation-youll-ever-need-cf53f0822f50" rel="noopener follow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">JSON Web Token (JWT) —您需要的唯一解释</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">JSON Web 令牌正在改变世界。一劳永逸，</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">arielweinberger.medium.com</p></div></div><div class="ms l"><div class="ow l mu mv mw ms mx km mj"/></div></div></a></div></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="22ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的令牌中，我们得到:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/c79bc019bfcbe8e5b7c0385516a3f709.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*0QcmzjyS5vHHwO0aR10baQ.png"/></div></figure><p id="1873" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nz">第一部分</em> </strong> <br/>中的红色表头我们有:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7162b0cbb735efd951d5bbee65859840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*EQHgyJoKL0q8SfpTp2zbnA.png"/></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="5405" class="pd na in og b gy pe pf l pg ph">{<br/> “alg”: “RS256”,<br/> “typ”: “JWT”,<br/> “kid”: “E1I4DzLXu3Q4j2o4dwRDPR9PFS7zlL627NhkbIIyZD4”<br/>}</span></pre><p id="3d8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们有:</p><ul class=""><li id="a9b8" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">算法:RS256</li><li id="39e2" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated"><strong class="kq io">键 ID(kid)</strong>:E1 i4 dzlxu 3 q 4j 2 o 4 dwrdpr 9 PFS 7 zll 627 nhkbiiyzd 4</li></ul><p id="0d92" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个<strong class="kq io"> kid </strong>信息将引导我们获得正确的<strong class="kq io">公钥</strong>来验证 REST Web API 中的访问令牌。</p><p id="3323" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 Keycloak 中找到<strong class="kq io">公钥</strong>转到“领域设置”,然后在“密钥”选项卡上，确保你在“活动”子选项卡上，然后你看适当的算法:我们寻找 RS256，你可能有两行，然后你看孩子，你看到它是最后一行。现在点击“公钥”按钮</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pi"><img src="../Images/57d153040f35fcfbdfab5914a2c40c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIU1YVfuOM1dsuDG3sD37w.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">如何用好的算法和孩子找到合适的线</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pj"><img src="../Images/e658d9c3bb0ca13839dc7769e33587d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5kYr2XgACA3OxZhsFt9Qw.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">如何获得公钥</figcaption></figure><p id="bf16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们知道哪个<strong class="kq io">公钥</strong>将用于验证客户端(比如我们的 SPA)发送给任何受保护资源的<strong class="kq io"> JWT 访问令牌</strong>:这里是我们的 REST API。</p><p id="f7ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nz">第二部分</em> </strong></p><p id="03f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它是主要的有效载荷:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="74ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经看到了这一点，我们在这里将重点关注声明:</p><p id="2ccf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.rfc-editor.org/rfc/rfc7519#section-4" rel="noopener ugc nofollow" target="_blank">https://www.rfc-editor.org/rfc/rfc7519#section-4</a></p><ul class=""><li id="be7d" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated"><strong class="kq io">ISS</strong>:“ISS”(发行人)索赔确定了发行<br/> JWT 的委托人。这是我们 Keycloak 服务器的 URI</li><li id="deee" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated"><strong class="kq io">aud</strong>:“aud”(受众)声明标识了 JWT 的目标接收者。</li><li id="d7ea" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated"><strong class="kq io">sub</strong>:“sub”(subject)索赔标识了作为 JWT 的<br/>主体的委托人。必须是独一无二的。</li><li id="c6d9" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated"><strong class="kq io"> typ: </strong>由[ <a class="ae lk" href="https://www.rfc-editor.org/rfc/rfc7519#ref-JWS" rel="noopener ugc nofollow" target="_blank"> JWS </a> ]和[ <a class="ae lk" href="https://www.rfc-editor.org/rfc/rfc7519#ref-JWE" rel="noopener ugc nofollow" target="_blank"> JWE </a> ]定义的“typ”(类型)头参数被 JWT 应用程序使用<br/>来声明媒体类型[ <a class="ae lk" href="https://www.rfc-editor.org/rfc/rfc7519#ref-IANA.MediaTypes" rel="noopener ugc nofollow" target="_blank"> IANA。这是一个完整的 JWT。这里是“不记名”，所以我们可以使用它</a></li></ul><p id="5f11" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Keycloak 添加了与用户和 ClientId 相关联的角色</p><ul class=""><li id="7b8c" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">resource _ Access/<strong class="kq io">MyApp</strong>/Roles[Admin]</li></ul><p id="ba24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们只有一个管理员。但是我们可以有几个。</p><p id="42fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，我们可以看到<strong class="kq io">clientId</strong>:<strong class="kq io">MyApp</strong>。</p><p id="d5b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们在 REST API 中需要的是我们的客户端 id MyApp 的角色声明</p><p id="bb0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nz">第三部分</em> </strong></p><p id="27ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这只是为了确保主要有效载荷(第二部分)没有被篡改。</p><p id="c39f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">jwt 可以使用秘密(使用<strong class="kq io"> HMAC </strong>算法)或使用<strong class="kq io"> RSA </strong>的公钥/私钥对进行签名</p><p id="7911" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为 keycloak 使用的是 RSA。</p><blockquote class="nw nx ny"><p id="cb98" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">签名= <strong class="kq io"> RSA </strong>(</p><p id="d5b7" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated"><strong class="kq io"><em class="in">SHA-256</em></strong>(<br/>base 64 urlencode(header)+“.”+ base64UrlEncode(有效负载))</p><p id="6d6e" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">，<strong class="kq io">私钥</strong></p></blockquote><p id="32b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们有两个步骤:</p><p id="83ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1)用 SHA-256 散列报头和有效载荷</p><p id="5c96" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们用 SHA-256 散列:“base64 header.base64 payload”(注意。作为分隔符)</p><p id="a3a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2)签名:使用私钥通过 RSA 算法对散列进行编码</p><p id="0d34" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们通过使用 RSA 算法用私钥对散列进行编码来制作签名。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="30a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后当我们的受保护资源:REST API 将使用<strong class="kq io">公钥</strong>验证令牌。</p><p id="ffd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们将看到如何使用授权方案:Bearer 来保护我们的 REST API。</p><p id="f914" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如何在我们的 ASP.NET 核心 Web API 中添加 JWT 熊授权?<strong class="kq io">?</strong></p><p id="b60d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在是时候了解如何在我们的 ASP.NET 核心 Web Api 应用程序中使用授权了。<br/>我们将看到如何保护我们的 API 端点。</p><p id="b456" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，为了帮助我们添加适当的服务和中间件，以便在我们的应用程序中使用 JWT 载体认证，让我们安装:</p><blockquote class="nw nx ny"><p id="33c4" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">微软。AspNetCore . authentic ation . jwtbearer</p></blockquote><p id="12d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 nuget 的帮助下:</p><div class="mg mh gp gr mi mj"><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">微软。AspNetCore . authentic ation . jwtbearer 6 . 0 . 5</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">ASP。NET 核心中间件，使应用程序能够接收 OpenID 连接承载令牌。这个包是建立在…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.nuget.org</p></div></div><div class="ms l"><div class="pm l mu mv mw ms mx km mj"/></div></div></a></div><p id="3d5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要安装与兼容的 nuget。net 5.0。</p><p id="af8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面我们找到了所有的版本和统计数据</p><div class="mg mh gp gr mi mj"><a href="https://www.nuget.org/stats/packages/Microsoft.AspNetCore.Authentication.JwtBearer?groupby=Version" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">Microsoft 的软件包下载。AspNetCore . authentic ation . jwtbearer</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">编辑描述</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.nuget.org</p></div></div></div></a></div><p id="d784" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将使用这个链接<a class="ae lk" href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer/5.0.17" rel="noopener ugc nofollow" target="_blank">https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer/5.0.17</a></p><p id="1fc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用命令在我们的项目中安装</p><p id="8f31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装包微软。AspNetCore . authentic ation . jwtbearer-版本 5.0.17</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="8559" class="pd na in og b gy pe pf l pg ph">Install-Package Microsoft.AspNetCore.Authentication.JwtBearer -Version 5.0.17</span></pre><p id="8d94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者，如果您喜欢使用 Visual Studio 界面，请转到解决方案，右键单击并选择管理解决方案的 Nuget 包…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/d098ae49b3183395b2a8274d5a9b38e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*IRV4E5MCI7ldQa8XLfOvmA.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">管理解决方案的 NuGet 包</figcaption></figure><p id="0ba3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">确保您启用了 Nuget 源<a class="ae lk" href="https://api.nuger.org/v3/index.json" rel="noopener ugc nofollow" target="_blank">https://api.nuger.org/v3/index.json</a>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi po"><img src="../Images/6ac0c819f340b6c1384b3d423ed44452.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*y63QdglCTITxajQd6ugYKg.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/d6b793f43eae7b9b3902c9769e239af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*Qf2bc9OfvcYmt9kOvjEfQw.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated"><a class="ae lk" href="https://api.nuger.org/v3/index.json" rel="noopener ugc nofollow" target="_blank">https://api.nuger.org/v3/index.json</a></figcaption></figure><p id="b084" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">键入 JwtBearer 并选择 Microsoft。AspNetCore . authentic ation . jwtbearer</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pq"><img src="../Images/8294e9c12a4cba26b236c7cc22069a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-lsmGAsgqGhv2wd8qsJrA.png"/></div></div></figure><p id="0fbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选择好的版本 5.0.17 和我们的项目 MyWebApi</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/29cf0f8debf9a75fa23769e0ccbc6710.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*ae_hriVe_iGf1zigf5Do8Q.png"/></div></figure><p id="3ff5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击安装</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/3cbc1d863989e39502b011f228edbb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*FDiMI2uT_XXX-eL5wkNNMQ.png"/></div></figure><p id="8539" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击我接受</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/f5a60159a343de0a5edab822bee14481.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*uYFLp4IUko5IjVsCFBgt3Q.png"/></div></figure><p id="ba78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它更新了 csproj 文件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pu"><img src="../Images/864f8f2489638e72cff34984d702f91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXxD9bPpv6p0bmEsJOUcDg.png"/></div></div></figure><p id="bf87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们准备用 JwtBearer 来保护我们的应用程序。</p><p id="bf2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是关于如何从微软源代码中添加 JWT 载体认证的示例代码。</p><div class="mg mh gp gr mi mj"><a href="https://github.com/dotnet/aspnetcore/blob/02c6de4ba6022025fcda7581415f310f8c73cdc3/src/Security/Authentication/JwtBearer/samples/JwtBearerSample/Startup.cs#L46" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">aspnetcore/startup . cs at 02 c 6 de 4 ba 6022025 fcda 7581415 f 310 F8 c 73 CDC 3 dot net/aspnetcore</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="pv l mu mv mw ms mx km mj"/></div></div></a></div><p id="63c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们将用简单的步骤展示如何做到这一点:</p><p id="12e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">如何添加 JWT 认证和授权？</strong></p><p id="0c35" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有两个步骤:</p><ul class=""><li id="d100" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated"><strong class="kq io">注册所有必要的认证服务</strong>以便认证可以正常工作。这些服务将被添加到 DI 容器中<strong class="kq io"/></li><li id="97fd" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated"><strong class="kq io">调用 UseAuthorization 在我们的管道</strong>中添加授权中间件，这个中间件将使用来自 DI 容器的<strong class="kq io">认证服务</strong>。</li></ul><blockquote class="nw nx ny"><p id="5c46" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">认证中间件将在请求到达控制器之前被调用，这个中间件将设置请求安全上下文。如果安全上下文与我们的控制器方法的安全需求不匹配，请求将被拒绝，并带有<strong class="kq io"><em class="in">HTTP 401 unauthorized</em></strong>状态响应。</p></blockquote><p id="43d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还记得 ASP.NET 核心 Web Api 管道中的中间件，请求通过所有中间件，直到到达负责返回响应的最后一个中间件。<br/>响应将以相反的顺序通过中间件链返回。</p><blockquote class="nw nx ny"><p id="283e" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">我们将在中间件<strong class="kq io">微软之间的适当管道位置添加认证中间件。AspNetCore . routing . endpointroutingmiddleware</strong>负责路由，最后一个中间件叫做<strong class="kq io">微软。AspNetCore . routing . endpoint middleware</strong>负责处理带有控制器的端点。</p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/fdcc58a9e98ab35dff0742c2cf600d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*1fL8awDMPOcClF5j"/></div></figure><p id="23fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们先创建一个名为“<strong class="kq io">认证</strong>”的专用文件夹。实际上，通过检查声明，它实际上是一种授权，但是 nuget 使用了术语身份验证。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi px"><img src="../Images/0ab560a5a934b737858a69a825912655.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*OaPFZ3SbFk_I46ahe03CaA.png"/></div></figure><p id="50c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们创建一个名为<strong class="kq io">configureserviceauthenticationextension</strong>的静态助手类。这个类将包含一个名为<strong class="kq io"> ConfigureJWT </strong>的扩展方法</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="b6c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该扩展方法将在启动类的 ConfigureServices 方法中使用，该方法用于将我们的服务添加到 ASP.NET 核心应用程序的内置 DI(依赖注入)容器中。</p><p id="34b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此服务将设置身份验证。</p><p id="9900" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的服务将在启动时添加。使用 IServiceCollection 集合配置服务。</p><p id="fb53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里启动类<strong class="kq io">先于</strong>我们的修改:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="2068" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将调用我们的扩展方法 ConfigureJWT，它将通过注入将必要的身份验证服务添加到具有 IWebHostEnvironment 的 DI 容器中，并将 RSA JWT 令牌的公钥直接插入到代码中(以避免分心)。然后我们将看到如何把公钥放在配置文件中，以及如何使用它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="1563" class="pd na in og b gy pe pf l pg ph">services.ConfigureJTWT(_currentEnvironment.IsDevelopment(), "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp3CVbF+TZDrO6IjeFIsbWhi4vjxkLrPy2ygWBbXse7ycd2daJrFXzKmlWECrSw7wbBcv4KO0PFVtb9s5PCJGmDZOZR02xY8DgUauU+S1EWEjmEdjeC8puEOPoM/YauNWWqAtJt8146WNTN07/UsvH7YZogKcmrl7PgmEMQtHhHYCWuoe+/27Mm4UffaIWIWrdVw970SFQ2PPAYns8j9NxWHMXUQZFewEKn1mw7RrByiP99PIOMoS7GtvnkWSls9VEXrsYelVjTEaXKiaKHYX6trzP4Zg9odOTMlULmeRLYs4lVCBC/lAg/BzM+3h/3I/1xLWy9S0sfwj3YCTboBL5wIDAQAB");</span></pre><p id="4f25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们称我们的 ConfigureJWT 方法为 passing:</p><ul class=""><li id="8136" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">用于检查我们是否在开发环境中的布尔值</li><li id="6ab0" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">公钥，因此我们可以验证或不验证在 RSA 算法中由私钥签名的 JWT 令牌。</li></ul><p id="5dfb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在将了解如何配置服务以使用 JWT 载体身份验证。</p><p id="09c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为此，我们为<strong class="kq io"> IServiceCollection </strong>服务使用静态类<strong class="kq io">AuthenticationServiceCollectionExtensions</strong>的标准扩展方法<strong class="kq io"> AddAuthentication </strong>。</p><p id="35a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> AddAuthentication </strong>注册认证服务所需的服务，并且<strong class="kq io">配置</strong>Microsoft . aspnetcore . authentic ation .<strong class="kq io">认证选项</strong>，我们将使用这些选项来告诉。NET 核心使用 JWT 承载认证模式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">AuthenticationServiceCollectionExtensions</figcaption></figure><p id="d615" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在这里看到 ASP.NET 核心 5.0.17 的这个扩展方法的源代码</p><div class="mg mh gp gr mi mj"><a href="https://github.com/dotnet/aspnetcore/blob/v5.0.17/src/Security/Authentication/Core/src/AuthenticationServiceCollectionExtensions.cs" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">5.0.17 版的 aspnetcore/authenticationservicecollectionextensions . cs</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="py l mu mv mw ms mx km mj"/></div></div></a></div><p id="752a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将使用以下扩展方法 add authentic ation with Action<authenticationoptions>configure options:</authenticationoptions></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="4284" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它将调用扩展方法 AddAuthentication，然后用我们的配置选项配置它。</p><p id="4481" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 AddAuthentication 扩展方法的源代码下面</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="adce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以看到它调用了<strong class="kq io"> AddAuthenticationCore </strong>方法，在这里我们可以看到添加的服务:</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="fb7b" class="pd na in og b gy pe pf l pg ph">services.TryAddScoped&lt;IAuthenticationService, AuthenticationService&gt;();</span><span id="7a42" class="pd na in og b gy pz pf l pg ph">services.TryAddSingleton&lt;IClaimsTransformation, NoopClaimsTransformation&gt;(); // Can be replaced with scoped ones that use DbContext            </span><span id="634c" class="pd na in og b gy pz pf l pg ph">services.TryAddScoped&lt;IAuthenticationHandlerProvider, AuthenticationHandlerProvider&gt;();            </span><span id="9a27" class="pd na in og b gy pz pf l pg ph">services.TryAddSingleton&lt;IAuthenticationSchemeProvider, AuthenticationSchemeProvider&gt;();</span></pre><p id="f7c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">稍后我们将看到<strong class="kq io"> IClaimsTransformation </strong>对于获取由 Keycloak 生成的 JWT 令牌中为客户端添加的用户角色非常有用。</p><p id="4767" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们配置选项，以便身份验证中间件将使用 JWT 载体身份验证。</p><p id="de1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">配置 JWT 承载认证的选项</strong></p><p id="a324" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将设置以下选项来使用<strong class="kq io"> <em class="nz"> JWT 承载认证方案</em> </strong>:</p><ul class=""><li id="72b0" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">认证选项。<strong class="kq io">DefaultAuthenticateScheme</strong>:微软默认使用的方案。AspNetCore . authentic ation . iauthenticationservice . authenticateasync(微软。AspNetCore.Http.HttpContext，System。字符串)。</li><li id="1e55" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">认证选项。<strong class="kq io"> DefaultChallengeScheme </strong>:微软默认使用的方案。AspNetCore . authentic ation . iauthenticationservice . challenge easync(微软。AspNetCore.Http.HttpContext，System。字符串，微软。AspNetCore . authentic ation . authenticationproperties)。</li><li id="7ac8" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">认证选项。<strong class="kq io">默认方案</strong></li></ul><p id="aa4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面的链接解释了不同之处</p><div class="mg mh gp gr mi mj"><a href="https://github.com/aspnet/announcements/issues/262" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">Auth 2.0 更改/迁移问题#262 aspnet/Announcements</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">摘要:旧的 1.0 身份验证堆栈不再有效，在 2.0 中已经过时。所有与认证相关的…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="qa l mu mv mw ms mx km mj"/></div></div></a></div><p id="ee94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将把它们都设置为 JwtBearerDefaults。身份验证方案</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="63f6" class="pd na in og b gy pe pf l pg ph">public const string AuthenticationScheme = "Bearer";</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="abca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">AddAuthentication 添加了必要的服务，并将身份验证方案的选项更改为 JWT 载体。我们得到一个 AuthenticationBuilder。</p><p id="f1ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用此 AuthenticationBuilder，我们现在可以设置 JWT 令牌验证。</p><p id="b08c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将使用微软的 Nuget M。AspnetCore . authentic ation . jwtbearer 并调用静态类<strong class="kq io"> JwtBearerExtensions </strong>的<strong class="kq io"> AddJwtBearer </strong>扩展方法来扩展<strong class="kq io"> AuthenticationBuilder </strong></p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="95ac" class="pd na in og b gy pe pf l pg ph"><strong class="og io">AuthenticationBuilder.AddJwtBearer(...)</strong></span></pre><p id="2cd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> AddJwtBearer </strong>将参数</p><p id="0276" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">动作<jwtbeareroptions>配置选项</jwtbeareroptions></p><p id="98f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在此操作中，我们将设置 JwtBearerOptions 的以下属性:</p><ul class=""><li id="45d6" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated"><strong class="kq io">TokenValidationParameters</strong>:包含一组微软使用的参数。identity model . tokens . securitytokenhandler。identity model . tokens . security Token(这里是一个 JWT 令牌)。在这里，我们设置<strong class="kq io">公钥</strong>来验证令牌签名、我们可以接受的<strong class="kq io">有效颁发者</strong>以及其他参数。</li><li id="0e90" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">JwtBearerEvents :指定微软。AspNetCore . authentic ation . jwtbearer . jwtbearerhandler 调用以使开发人员能够控制身份验证过程。它是我们决定当令牌被验证时、当身份验证得到一个异常被抛出时、当身份验证失败时等等做什么的地方</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/5c769a45cc43cca634e1b50903610afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*nJDclPceA4BjrNXkfr3JYw.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">我们可以使用的事件列表</figcaption></figure><p id="98cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们需要一个 helper 方法来从我们的 JWT 公钥构建 RSA 安全密钥，它是一个字符串:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="0040" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以找到一篇关于这个加密部分的好文章</p><div class="mg mh gp gr mi mj"><a href="https://vcsjones.dev/key-formats-dotnet-3/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">在中导入和导出 RSA 密钥格式。网络核心 3</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">NET Core 3.0 引入了十几个新的 API 来导入和导出不同格式的 RSA 密钥。他们中的许多人…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">vcsjones.dev</p></div></div></div></a></div><p id="2b8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您需要了解 RS256 JWT 验证的更多信息，我还写了一篇非常详细的文章:</p><div class="mg mh gp gr mi mj"><a href="https://systemweakness.com/part-1-cryptography-in-net-c0f78cfa9326" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">第 1 部分中的密码学。网</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">第 1 部分:RSA 和 RS256 签名和验证</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">systemweakness.com</p></div></div><div class="ms l"><div class="qc l mu mv mw ms mx km mj"/></div></div></a></div><blockquote class="nw nx ny"><p id="3caa" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">公钥有一种自我描述密钥算法的格式，称为主题公钥信息(Subject Public Key Info，SPKI ),在 X509 和许多其他标准中大量使用。PEM 头是“BEGIN PUBLIC KEY ”,而<code class="fe od oe of og b">ImportSubjectPublicKeyInfo</code>是导入它们的正确方式。</p><p id="b080" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">总结每个 PEM 标签和 API 配对:</p><p id="2984" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">"开始 RSA 私钥" =&gt; <code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsaprivatekey?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank">RSA.ImportRSAPrivateKey</a></code></p><p id="b775" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">【开始私钥】=&gt; <code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importpkcs8privatekey?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank">RSA.ImportPkcs8PrivateKey</a></code></p><p id="e54c" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">"开始加密私钥" =&gt; <code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importencryptedpkcs8privatekey?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank">RSA.ImportEncryptedPkcs8PrivateKey</a></code></p><p id="50ae" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">"开始 RSA 公钥" =&gt; <code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsapublickey?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank">RSA.ImportRSAPublicKey</a></code></p><p id="ffc5" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated"><strong class="kq io"> <em class="in">【开始公钥】= &gt; </em> </strong> <code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importsubjectpublickeyinfo?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="in">RSA.ImportSubjectPublicKeyInfo</em></strong></a></code></p></blockquote><p id="71e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要我们的公钥中 Keycloak 使用的最后一个“BEGIN PUBLIC KEY”。我认为首先我们需要<code class="fe od oe of og b"><a class="ae lk" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsapublickey?view=netcore-3.0" rel="noopener ugc nofollow" target="_blank"><em class="nz">RSA.ImportRSAPublicKey</em></a><em class="nz"> </em></code>，但是它失败了，出现了一个异常。</p><p id="aaef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我发誓这是代码库中不太清楚的部分，我花了一段时间才弄清楚。所以有困惑也不要为难自己:-)吧</p><p id="f951" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们在动作<jwtbeareroptions>中设置 JwtBearerOptions 的选项，该动作将被<strong class="kq io">service collection:IServiceCollection</strong>的方法<strong class="kq io"> Configure </strong>调用</jwtbeareroptions></p><p id="5b56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 ServiceCollection 的源代码下面</p><div class="mg mh gp gr mi mj"><a href="https://github.com/dotnet/runtime/blob/v5.0.17/src/libraries/Microsoft.Extensions.DependencyInjection/src/ServiceCollection.cs" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">5.0.17 版的 runtime/ServiceCollection.cs</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="qd l mu mv mw ms mx km mj"/></div></div></a></div><p id="94ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">甚至在我们接受服务之前。ConfigureJWT 调用，我们可以看到 DI 已经包含了认证的所有服务，但是它们是默认设置。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qe"><img src="../Images/6053e6b2c3230b815284e2ebe5c97315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFXNqM5rQzaozDpaA2ZKpA.png"/></div></div></figure><p id="e088" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，他们没有任何认证方案</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/09d5799ebb1081a9e9ee38b6a11be83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*N515xceqYy2SQAaV1nWC1w.png"/></div></figure><p id="c398" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们将在静态 JwtBearerExtensions 类的<strong class="kq io"> AuthenticationBuilder 中添加带有扩展方法 AddJwtBearer 的 JWT 承载方案</strong></p><div class="mg mh gp gr mi mj"><a href="https://github.com/dotnet/aspnetcore/blob/v5.0.17/src/Security/Authentication/JwtBearer/src/JwtBearerExtensions.cs" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">5.0.17 版的 aspnetcore/jwtbearerextensions . cs</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="qg l mu mv mw ms mx km mj"/></div></div></a></div><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="aefe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以看到，使用 call AddScheme 将 JWT 承载方案添加到了服务 AuthenticationService 中。</p><p id="b50c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看如何使用<strong class="kq io"> AddJwtBearer </strong></p><p id="74c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还可以看到:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qh"><img src="../Images/6ab958f606ec21ed432527a43fcc6d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruqvwa57OMrrXRn1mgpBag.png"/></div></div></figure><p id="4fc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="bcfe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以在 AddJwtBearer 中看到两个部分:</p><ul class=""><li id="f21f" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">TokenValidationParameters:用于告诉如何验证我们的 JWT 令牌</li><li id="0db9" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">Events:用于告诉在令牌被验证时(我们只是将它记录到控制台)，在身份验证获得异常时(我们返回 HTTP 500 并仅在 dev 模式下添加细节)，如何对特定事件做出反应</li></ul><p id="6119" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 TokenValidationParameters 中，我们验证这里硬编码的 JWT 令牌<strong class="kq io">颁发者</strong>(该值在 JWT 令牌的“<strong class="kq io"> iss </strong>”声明中，并且是 Keycloak 服务器中我们领域的 URI)，我们用 RsaSecurityKey 验证令牌的签名，最后我们验证令牌的生存期。</p><p id="a9ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们已经准备好保护我们的端点，请记住，在启动时，我们已经在应用程序的配置方法中。UseAuthorization()。此方法将 Microsoft . aspnetcore . authorization .<strong class="kq io">授权中间件中间件</strong>添加到指定的 Microsoft . aspnetcore . builder .<strong class="kq io">IApplicationBuilder</strong>中，从而启用授权功能。</p><blockquote class="nw nx ny"><p id="716a" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">当授权使用端点路由选择路由的资源时，这个调用<br/>必须出现在对 app 的调用之间。UseRouting()和 app。使用端点(…)使中间件正常工作。</p></blockquote><p id="4281" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">见下文:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="1673" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们现在要做的就是添加 AuthorizeAttribute 属性，将 AuthenticationSchemes 设置为“Bearer ”,如下所示:</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="f73e" class="pd na in og b gy pe pf l pg ph">[Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]</span></pre><p id="2bcf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以向控制器添加 AuthorizeAttribute 属性，这样所有方法都受到授权的保护。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="c465" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们在没有授权的情况下测试我们受保护的 Web API。我们发送没有 JWT 令牌的请求:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qi"><img src="../Images/90e3293d2bdc666afb0c4ae99881f24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWepeLwBUm3fl9CmHHCyaQ.png"/></div></div></figure><p id="84be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们得到预期的 HTTP 401 未授权代码作为响应。我们再也够不到我们的 Web API 了。</p><p id="7568" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们更新我们的 swagger 代码，以便我们可以轻松使用我们的 JWT 令牌:</p><p id="5214" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文有助于:</p><div class="mg mh gp gr mi mj"><a href="https://dev.to/eduardstefanescu/aspnet-core-swagger-documentation-with-bearer-authentication-40l6" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">ASP。NET Core Swagger 文档，带有载体认证</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">原载于 https://eduardtefenescu . dev 2022 年 1 月 15 日。在上一篇文章中，我们添加了 Swagger…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">开发到</p></div></div><div class="ms l"><div class="qj l mu mv mw ms mx km mj"/></div></div></a></div><p id="b0a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们得到以下代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="5d58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以大摇大摆地使用我们的 JWT 代币了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qk"><img src="../Images/c65d1206fb57540d69af541425d0e773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to0TmM_Wd0BC-Acm3_Lv7g.png"/></div></div></figure><p id="da8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们点击授权链接</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qk"><img src="../Images/4faa9887d43f76610021b208dcf58f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkkgQGYHZOMs-Sp9lDNUog.png"/></div></div></figure><p id="7893" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们复制 JWT 代币的价值，然后点击授权。</p><p id="e5ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们可以使用我们的 web api:)</p><p id="767d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们试试:</p><p id="d5af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从失眠中复制我们的访问令牌，它将在 300 秒后过期:5 分钟。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ql"><img src="../Images/c595cdb67b59d28a1408832b1cb9b606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7Itz8-ykhzskGlAoj3KpA.png"/></div></div></figure><p id="7eb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以招摇的形式粘贴它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/9e9c9d0f6dffbab71d6bb8e691c74029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*YzI75SKXTcVglXsZAvqVDQ.png"/></div></figure><p id="48c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击授权。我们得到以下确认。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/32595f7de8401584675c61ceceb55a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*p_3RaVfaa2VTK5wPGSbk-w.png"/></div></figure><p id="3dd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以稍后随时注销。单击关闭以保留令牌。</p><p id="2a23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们得到以下窗口</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qk"><img src="../Images/9b721b729051965970683eff5ee4a325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiogjBEX4mvAtC5qr_bD4Q.png"/></div></div></figure><p id="c267" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们再试一次天气预报和成功！我们的 Web API 验证了 JWT 令牌，我们得到了 HTTP 200 代码和预期的响应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qo"><img src="../Images/365eb8a650155dda253590c7ad77b4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3TgMBF3PIJ27x5h2-6TPg.png"/></div></div></figure><p id="b75d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们注销，首先再次点击授权</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qp"><img src="../Images/134fdd7f4789b464c417f949b73f9b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZmqIQn7aSasbDQ4VBnhIQ.png"/></div></div></figure><p id="fd23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后注销</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/554bc56c5677582abc7d47199e26a326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*1VTfZ6vNWLq_MC0Hryp61w.png"/></div></figure><p id="0048" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们拿回表格</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/5a5d17c197852a518581677692694945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*dlDEbpRDNf7CG0f6cScjww.png"/></div></figure><p id="ae79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">单击关闭，然后重试 Web API:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/bde2f99b904f05e6fa1a450ab07856d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*lXWb03daNF1G9P8h6WYEtg.png"/></div></figure><p id="2c1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们再次得到 HTTP 401 代码。</p><p id="8676" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一篇很好的文章，可以更详细地了解 JWT 载体认证中间件是如何工作的</p><div class="mg mh gp gr mi mj"><a href="https://andrewlock.net/a-look-behind-the-jwt-bearer-authentication-middleware-in-asp-net-core/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">ASP.NET 核心中 JWT 承载认证中间件的背后</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">这是关于 ASP.NET 核心认证和授权系列文章的下一篇。在我们收到的第一封邮件中…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">andrewlock.net</p></div></div><div class="ms l"><div class="qt l mu mv mw ms mx km mj"/></div></div></a></div><p id="42b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">JWT 授权和角色</strong></p><p id="de46" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们差不多完成了，我们需要通过角色来限制访问。</p><p id="1f9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">目前，任何拥有有效 JWT 令牌的用户都可以访问我们的 Web API。<br/>Keycloak 为我们的客户端 MyApp 在 JWT 令牌中添加了用户角色，但是还没有被我们的 Web API 利用。</p><p id="7236" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们现在就做吧！</p><p id="44ba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">告诉我们的身份验证中间件检查 JWT 令牌中的角色实际上非常简单，我们只需要通过添加如下角色来更新我们的 Authorize 属性:</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="8e88" class="pd na in og b gy pe pf l pg ph">[Authorize(AuthenticationSchemes = "Bearer", Roles = "Admin")]</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="1cf6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们再次启动我们的 web api。</p><p id="5e50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后让我们用 Swagger 再试一次，记住我们的用户是管理员角色。<br/>我们再次添加新生成的 JWT 令牌，并尝试会发生什么:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qu"><img src="../Images/14b0abb338d248ca7d8b3dd17d80f6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xAKgB7U96vJvcrWdZ-qyg.png"/></div></div></figure><p id="b294" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们没有得到任何回应，但是得到了<strong class="kq io"> HTTP 403:禁止代码</strong>的回应。</p><p id="45d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，Web API 似乎禁止我们使用 JWT 令牌，因为角色不匹配。但是我们确信我们的 JWT 令牌具有管理员角色…</p><p id="76cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/6c97a5d970d65e131110056490b62634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*skCa3wZYOjMcamHiQzZVhw.png"/></div></figure><p id="943f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">是的，我们可以在主有效负载中看到 JWT 令牌，我们为客户端 MyApp 设置了角色:Admin。</p><blockquote class="nw nx ny"><p id="7582" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated">问题是 Keycloak 在一个位置添加了客户端角色。net 核心框架不找。我们需要简化 resource_access，因为 Microsoft 身份模型不支持嵌套声明</p></blockquote><p id="3eef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要添加一个 ClaimsTransformer，它将查看嵌套的声明，并将缺少的<strong class="kq io">声明</strong>添加到当前经过身份验证的用户的<strong class="kq io">声明中。</strong></p><p id="53a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要两个名称空间:</p><ul class=""><li id="0d27" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">系统。证券.标准<strong class="kq io">债权本金</strong>债权</li><li id="a553" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">微软。AspNetCore .接口的身份验证<strong class="kq io"> IClaimsTransformation </strong></li></ul><p id="e838" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要 nuget newtonsoft.json 来解析 json 对象，该对象包含 JSON 格式的角色声明。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qw"><img src="../Images/11914375d8b4964fbfed6f0671ff5927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0mkOSWEr4IE8dJO2Hh9Qg.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qx"><img src="../Images/8055fa3db372cc0e261d368d3796f913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDiduXO5Zknl65Ol66f8qg.png"/></div></div></figure><p id="08de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们最后只安装了 3 个 nu get。</p><p id="eacf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们创建一个声明转换器，它将获取角色并将它们添加到用户 ClaimsPrincipal 中。</p><p id="6808" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们确保通过将声明转换器作为 IClaimsTransformation 实例添加到服务 DI 容器中来使用它:</p><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="8fe9" class="pd na in og b gy pe pf l pg ph">services.AddTransient&lt;IClaimsTransformation, ClaimsTransformer&gt;()</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pk pl l"/></div></figure><blockquote class="nw nx ny"><p id="a34d" class="ko kp nz kq b kr ks jo kt ku kv jr kw oa ky kz la ob lc ld le oc lg lh li lj ig bi translated"><strong class="kq io">请注意</strong>我在零件中硬编码了客户 id“MyApp”。应该在 appsettings.json 中使用它。同样，我想让源代码尽可能简单。这根本不是一个生产就绪的代码库！</p></blockquote><pre class="kd ke kf kg gt oz og pa pb aw pc bi"><span id="b983" class="pd na in og b gy pe pf l pg ph">content["MyApp"]["roles"]</span></pre><p id="1924" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请在此处找到有关如何映射、自定义或转换声明的 microsoft 官方文档:</p><div class="mg mh gp gr mi mj"><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-6.0#extend-or-add-custom-claims-using-iclaimstransformation" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">在 ASP.NET 核心中映射、定制和转换索赔</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">由 Damien Bowden 声明可以从任何用户或身份数据中创建，这些数据可以使用可信身份发布…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">docs.microsoft.com</p></div></div><div class="ms l"><div class="qy l mu mv mw ms mx km mj"/></div></div></a></div><p id="4414" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们再次启动 Web Api 并进行测试！</p><p id="fcbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而且效果很好:)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qz"><img src="../Images/79d66eda6b28888aa2aa13193670431d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrrucvrtYgK0qlsfJxFwyQ.png"/></div></div></figure><p id="5ac8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，我们可以等待 5 分钟，再试一次，一旦 JWT 到期，你会看到一个新的错误将被返回。我们需要:</p><ul class=""><li id="3ef0" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">刷新我们的 JWT 令牌并使用它</li><li id="1c5e" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">从头开始重建一个新的 JWT 令牌</li></ul><p id="df7e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">结论</strong></p><p id="495a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们看到了如何使用 JWT 令牌通过身份验证和载体授权来保护我们非常基本的 WebApi。</p><p id="48d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第四部分的最后，我们将看到如何从 React SPA 应用程序中使用我们的访问 JWT 令牌来调用我们的 Web API。我们将通过 React SPA、受保护资源 Web API 和我们的 JWT 令牌发行者 Keycloak 转换完整的授权代码流！</p><p id="8224" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，它不是一个生产就绪的代码库！它是一个代码库，可以帮助您在非常庞大的安全主题中找到自己的方向。</p><p id="4fcb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请给我一些意见，反馈。</p><p id="6f9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">干杯！</p><p id="4f1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后第四部分:<br/> <a class="ae lk" href="https://medium.com/@barlatiernicolas/part-four-security-in-react-and-webapi-in-asp-net-b6dffd3b7624" rel="noopener">第四部分:用访问 JWT 令牌持有者授权从 React SPA 调用受保护的 Web API</a></p><p id="a1cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">推荐人:</strong></p><div class="mg mh gp gr mi mj"><a href="https://sandrino.dev/blog/aspnet-core-5-jwt-authorization" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">ASP.NET 核心 5 的 JWT 承载认证和授权</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">2020 年 11 月 10 日微软发布。NET 5 和更新的 ASP.NET 核心平台，其中包括一长串…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">sandrino.dev</p></div></div><div class="ms l"><div class="ra l mu mv mw ms mx km mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a href="https://andrewlock.net/a-look-behind-the-jwt-bearer-authentication-middleware-in-asp-net-core/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">ASP.NET 核心中 JWT 承载认证中间件的背后</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">这是关于 ASP.NET 核心认证和授权系列文章的下一篇。在我们收到的第一封邮件中…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">andrewlock.net</p></div></div><div class="ms l"><div class="qt l mu mv mw ms mx km mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-6.0#extend-or-add-custom-claims-using-iclaimstransformation" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">在 ASP.NET 核心中映射、定制和转换索赔</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">由 Damien Bowden 声明可以从任何用户或身份数据中创建，这些数据可以使用可信身份发布…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">docs.microsoft.com</p></div></div><div class="ms l"><div class="qy l mu mv mw ms mx km mj"/></div></div></a></div></div></div>    
</body>
</html>