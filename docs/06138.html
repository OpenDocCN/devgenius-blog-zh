<html>
<head>
<title>An epic tale: comparing JDBC and R2DBC in a real-world scenario (Part 1/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">史诗般的故事:现实世界中 JDBC 和 R2DBC 的比较(第 1/2 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-a536db512834?source=collection_archive---------1-----------------------#2021-12-16">https://blog.devgenius.io/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-a536db512834?source=collection_archive---------1-----------------------#2021-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a37" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">整个探索围绕着一个简单但难以回答的问题:“使用 R2DBC 有意义吗？”</h2></div><p id="d6c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在谷歌上搜索一下，可以找到几个精确说明 R2DBC 具有高并发性的基准。然而，这些基准是建立在一个远离真正的数据库密集型应用的场景之上的。他们通常在数据库表上测试一个简单的“get ”:这太简单了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/032b30783f792889180dcb34f1cddca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z46hlfZ4sWq7BpgoxH6ZCQ.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">由<a class="ae lr" href="https://unsplash.com/@linussandvide" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@linussandvide</a>在 Unsplash 上拍摄的照片</figcaption></figure><ul class=""><li id="bb78" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">所以我用 SPRING-BOOT 以阻塞(JDBC)和反应(R2DBC)的方式编写了自己的用例</li><li id="6df7" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">在容器化的环境中使用 docker-compose 部署一切</li><li id="c5f8" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">测试了几次，改变了一些有见地的参数</li></ul><p id="c626" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我得出的结论是，<strong class="kh ir">“R2DBC 高并发更快”这句话，<em class="mg"/>基本上是错误的。</strong></p><h1 id="4003" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">介绍</h1><p id="6e91" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我的测试环境部署包含以下容器:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ne"><img src="../Images/039cb588d6a7c4b1f75f55188e47d687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4FgCTYyJn4BpzyGUaWv-Q.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">应用程序使用的容器。</figcaption></figure><p id="6579" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用了<strong class="kh ir"> GRAFANA </strong>和<strong class="kh ir"> INFLUXDB </strong>来帮助我用一个非常漂亮的配置来绘制结果，可以绘制如下图:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nf"><img src="../Images/386ed76fab8121e2cbc9180d659d59ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxWtExD5xCs2pcFRWxYSgg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">Grafana k6 负载测试</figcaption></figure><p id="518e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署的<strong class="kh ir"> POSTGRES </strong>数据库服务包含一个足够简单的模式，它是在容器开始时自动创建的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ea3a49f1c6d54dc27bd941d9fbff43cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*RMBaRz7LWOuq2MXzJ7SW0A.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">数据库库模式</figcaption></figure><p id="3e7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NGINX 被放在那里仅仅是为了相同种类的多个容器之间的负载平衡——如果有的话。只有 JDBC 和 R2DBC 容器才是真正的测试对象。<strong class="kh ir">(并且已经配置为在高压下完全执行)</strong></p><p id="0dfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负载测试已经在运行<strong class="kh ir">临时 K6 容器</strong>的情况下执行，通过指定不同的 ENV 参数从不同的执行中改变。</p><h1 id="83ea" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">经典的 GET 测试</h1><p id="c0ee" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们从直接在 book 表上测试一个简单的 HTTP GET 开始，就像在网上找到的各种场景中一样。但是…我还参数化了从单个 GET 中检索到的数据库条目的数量，这就是问题所在！</p><p id="1c67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从具有以下配置的单个容器开始:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="96ee" class="nm mi iq ni b gy nn no l np nq">spring-jdbc:<br/>  build:<br/>    context: ../spring-jdbc<br/>  depends_on:<br/>    - db-service<br/>  restart: always<br/>  environment:<br/>    <strong class="ni ir">- POOL_SIZE=20</strong><br/>  ports:<br/>    - "8080:8080"<br/>  deploy:<br/>    replicas: 1<br/>  <strong class="ni ir">  resources:<br/>      limits:<br/>        cpus: 2<br/>        memory: 2G<br/>      reservations:<br/>        memory: 2G</strong><br/><br/>spring-r2dbc:<br/>  build:<br/>    context: ../spring-r2dbc<br/>  depends_on:<br/>    - db-service<br/>  restart: always<br/>  environment:<br/>   <strong class="ni ir"> - POOL_SIZE=20</strong><br/>  ports:<br/>    - "8081:8080"<br/>  deploy:<br/>    replicas: 1<br/>   <strong class="ni ir"> resources:<br/>      limits:<br/>        cpus: 2<br/>        memory: 2G<br/>      reservations:<br/>        memory: 2G</strong></span></pre><p id="49dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过改变这些参数来运行一些测试:<strong class="kh ir">访问端点的同时期用户和从数据库中检索的条目数量。</strong></p><p id="b9e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个分析，我们将只考虑 k6 执行的成功和完整迭代的次数，它给出了给定时间内的总吞吐量(HTTP 请求持续时间和每秒请求数等其他参数将在后续测试中进行评估)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/565d98fb4af31dfc17f48684f9103490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovCQgmf49sr4FVhk46PMOg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">k6 测试截图。</figcaption></figure><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="de9b" class="nm mi iq ni b gy nn no l np nq">Database Items retrieved: <br/>         <br/>       6000 / 3000 / 1500</span><span id="ad2d" class="nm mi iq ni b gy ns no l np nq">Troughput:</span><span id="bdf4" class="nm mi iq ni b gy ns no l np nq">  Case 1: 500 users</span><span id="538b" class="nm mi iq ni b gy ns no l np nq">  - R2DBC: <strong class="ni ir">4083 </strong>/ 5373 / 10689<br/>  - JDBC:  3321 / 5447 / <strong class="ni ir">22765</strong></span><span id="98a5" class="nm mi iq ni b gy ns no l np nq">  Case 2: 250 users<br/><br/>  - R2DBC: <strong class="ni ir">4385 </strong>/ 7364 / 15152<br/>  - JDBC: 3520 / 6944 / <strong class="ni ir">20255</strong><br/><br/>  Case 3: 100 users<br/><br/>  - R2DBC: <strong class="ni ir">4057 </strong>/ 7636 / 15341<br/>  - JDBC: 3247 / 8835 / <strong class="ni ir">22079</strong><br/><br/>  Case 4: 10 users<br/><br/>  - R2DBC: 4541 / 8823 / 16111<br/>  - JDBC: <strong class="ni ir">6841 / 12031 / 26349</strong></span></pre><p id="2809" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述结果意味着阻塞堆栈在行数较少的情况下性能更好。还要记住，在呼叫实际结束之前可以处理反应输出(这是反应驱动程序的全部目的)<br/>结果是一个足够清楚的陈述:</p><blockquote class="nt nu nv"><p id="608a" class="kf kg mg kh b ki kj jr kk kl km ju kn nw kp kq kr nx kt ku kv ny kx ky kz la ij bi translated"><strong class="kh ir">只有在处理数据流而不是涓涓细流有意义时，才使用反应式堆栈:】T2</strong></p></blockquote><p id="0940" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">R2DBC 似乎只有在检索超过 100 个并发用户的 3000 个项目时才明显更好。这是一个非常有限的场景。是否有很多应用程序需要一次超过 3000 个数据库行，并且有超过 100 个并发用户？考虑到查询分页也是一个选项，答案是显而易见的。在我看来，对于绝大多数数据库密集型 web 应用程序来说，完全反应式堆栈并不是一个好的选择。</p><p id="0e0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应式堆栈所做的优化(使用额外的队列来最大限度地减少 CPU 和 CPU 上下文切换的使用)在从数据库中检索很少行的情况下不够好。请始终记住，反应式项目增加了大量的处理开销，这可能是 R2DBC 在某些情况下看起来更慢的原因。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nz"><img src="../Images/7e8253e59f87ac7df4e50196de6df31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57M2o6IQODTKr5IDkpGDPw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">来自一个很棒的视频<a class="ae lr" href="https://www.youtube.com/watch?v=0rnMIueRKNU" rel="noopener ugc nofollow" target="_blank">该做的和不该做的:避免初次反应式程序员地雷</a></figcaption></figure><h1 id="618a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="61b9" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">现在，让我们继续。如果我们使用 Spring-JDBC 阻塞堆栈和 Spring-R2DBC 电抗堆栈来实现两个不同的应用，会怎么样？</p><p id="59cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的第二部分，我们将看到这个测试环境的完整代码和应用程序！敬请关注。</p><h2 id="7a93" class="nm mi iq bd mj oa ob dn mn oc od dp mr ko oe of mt ks og oh mv kw oi oj mx ok bi translated">更新:下面是第二部分。</h2><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-part-2-2-d908df49651c"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">史诗般的故事:现实世界中 JDBC 和 R2DBC 的比较(下)</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">整个探索围绕着一个简单但难以回答的问题:“使用 R2DBC 有意义吗？”</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">blog.devgenius.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ll oo"/></div></div></a></div><p id="77f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，非常感谢您的阅读。</p></div></div>    
</body>
</html>