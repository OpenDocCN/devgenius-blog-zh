# 围棋中的筹码

> 原文：<https://blog.devgenius.io/stacks-in-go-f57f4cb87b5f?source=collection_archive---------6----------------------->

欢迎回到*Go 中的数据结构介绍*！今天，我们将讨论堆栈。栈很容易理解，并且有许多不同的用途。它还会在编码面试中出现很多，因为它的属性可以带来很多很酷的应用。

# 什么是堆栈？

栈是遵循后进先出原则的数据结构。也就是说，任何最后进去的东西都会先出来。想象一堆盘子。我们将从下到上堆叠盘子，然后首先使用最上面的盘子。

# 用 Go 写

实现非常简单。我们将使用切片来实现堆栈。

```
type Stack struct {
    items []int
}
```

我们将首先定义一个属性为`items`的`Stack`类型。我们的堆栈负责保存整数，但是您可以将数据类型更改为您想要的任何类型。

最重要的两种叠法是`push`和`pop`。将项目推入堆栈会将项目添加到最顶端的位置，从堆栈中弹出会移除最顶端的项目。

```
func (s *Stack) Push(data int) {
    s.items = append(s.items, data)
}func (s *Stack) Pop() {
    if s.IsEmpty() {
        return
    }
    s.items = s.items[:len(s.items)-1]
}
```

这些方法作用于指向我们的`Stack`类型的指针，因为我们需要主动地对它进行修改。

`Push`很简单——我们只需要将数据追加到`s.items`中。

`Pop`简单为好。我们首先关注堆栈为空的情况，在这种情况下方法不会做任何事情。在其他情况下，我们可以从包含除最后一个元素之外的所有元素的`s.items`中提取一个片段。

我们将定义三个更有用的实用方法。

```
func (s *Stack) Top() (int, error) {
    if s.IsEmpty() {
        return 0, fmt.Errorf("stack is empty")
    }
    return s.items[len(s.items)-1], nil
}func (s *Stack) IsEmpty() bool {
    if len(s.items) == 0 {
        return true
    }
    return false
}func (s *Stack) Print() {
    for _, item := range s.items {
        fmt.Print(item, " ")
    }
    fmt.Println()
}
```

返回堆栈中最顶端的项目。当堆栈为空时，它将返回一个零值和一个错误，指出堆栈为空。

`IsEmpty`如果堆栈为空，返回 true，否则返回 false。

`Print`遍历堆栈并打印项目。

# 这很好，但是我在哪里使用它呢？

到目前为止，这只是看起来像额外步骤的切片。这到底用在哪里？

堆栈用于以下目的:

*   实现撤消操作。
*   反转字符串或数组。
*   调用内存中的堆栈。
*   在浏览器和文件浏览器中向前和向后导航。
*   在中缀、前缀和后缀表示法之间转换表达式。
*   检查括号是否正确关闭。

这些都是有趣的用法，我们可以详细讨论更有趣的用法。

## 撤消操作

我们只需要在一个堆栈中存储上一次操作的细节。当我们想要撤销它时，我们只需要弹出堆栈来恢复到上次保存的状态。

## 反转字符串或数组

我们迭代字符串中的字符或数组中的元素，并将它们存储在堆栈中。完成后，我们只需要读取栈顶元素，并弹出它，直到栈为空。

## 调用栈

名字*stackoverflow.com*中的栈指的是一个程序的调用栈。当您运行一个程序时，会分配一定数量的内存用作程序的调用堆栈。这是一个存储被调用函数的堆栈。存储在堆栈中的每个函数调用还将保存在函数范围内生成的局部变量的值。

仅供参考，堆栈溢出是当您调用的函数超过调用堆栈所能容纳的数量时出现的错误。这通常发生在你无法对递归函数进行转义的时候。这也可能导致潜在的攻击，如缓冲区溢出攻击，在这种攻击中，拥有高级权限的恶意用户可以故意使堆栈溢出，导致其中的任何重要数据泄漏。

## 中缀、前缀和后缀符号

这有点复杂。所以通常情况下，我们会这样写表达式:

```
a + b
```

这就是所谓的*中缀*符号。这是因为运算符位于操作数之间。根据这个你大概能猜到另外两个是什么样的。

```
Infix: <operand><operator><operand>
Prefix: <operator><operand><operand>
Postfix: <operand><operand><operator>
```

例如，上面显示的表达式也可以写成这样:

```
Infix: a+b
Prefix: +ab
Postfix: ab+
```

我们究竟为什么要写这样的东西？好吧，虽然中缀符号对人的眼睛来说是令人愉快的，但它对计算机的眼睛来说却没有带来多少快乐。就像高级语言对人类友好，低级语言对机器友好一样，前缀和后缀符号更容易被计算机处理。

使用中缀符号可以很容易地解析简单表达式，但是这是不可伸缩的。例如，看看这个表达式。

```
{(a*b) + (c*d)} - e
```

当有很多括号和运算符时，你可以看到难度增加得有多快。我们不仅需要处理操作，还需要跟踪操作的顺序。

```
Infix: {(a*b) + (c*d)} - e
Postfix: ab*cd*+e-
```

后缀符号更容易理解，因为我们只需要从左到右扫描表达式就可以得到结果。我们可以使用堆栈将中缀符号转换成后缀符号。我们是怎么做到的？细节将在下一篇文章中涉及，因为它有点冗长。

## 检查括号是否正确结束

当括号正确闭合时，我们称之为*平衡*。

```
Balanced: (a+b), {(a*b) + (c*d)}
Unbalanced: (a+b, []int{0, 1, 2), [)](
```

手动检查每个括号会很繁琐。相反，我们可以使用堆栈来轻松检查平衡。

```
type StringStack struct {
    items []string
}func checkBalance(exp string) bool {
    s := StringStack{} for _, char := range exp {
        switch char {
        case '(':
            s.Push(string(char))
        case '{':
            s.Push(string(char))
        case '[':
            s.Push(string(char))
        case ')':
            top, _ := s.Top()
            if top == "(" {
                s.Pop()
            } else {
                return false
            }
        case '}':
            top, _ := s.Top()
            if top == "{" {
                s.Pop()
            } else {
                return false
            }
        case ']':
            top, _ := s.Top()
            if top == "[" {
                s.Pop()
            } else {
                return false
            }
        }
    } if s.IsEmpty() {
        return true
    }
    return false
}
```

这段代码看起来很难看，但它完成了工作。代码很长，因为我们要处理三种不同类型的括号`()`、`{}`和`[]`。让我们看看逻辑是如何工作的。

*   我们创建了一个名为`s`的`StringStack`实例。
*   遍历输入字符串。每个字符将被表示为一个符文，这是描述 Unicode 字符代码点的一种特殊方式。符文很容易转换成字符串。
*   如果一个字符是一个左括号，我们把它添加到堆栈中。
*   如果一个字符是右括号，我们检查堆栈中最上面的元素，看它是否匹配。对于`)`，`s.Top()`应该返回`(`相互抵消。如果括号匹配，我们从堆栈中弹出。如果不是，括号就不平衡，因此我们应该返回`false`。
*   继续下去，直到我们完成了字符串的迭代。如果堆栈中还有任何元素，这意味着一些括号没有正确结束，从而使括号不平衡。然而，如果堆栈是空的，我们返回`true`，因为它是平衡的。

# 结论

我们讨论了一个堆栈的基本实现及其在 Go 中的方法。我们还讨论了栈在现实世界中一些最常见的用法。对于新手来说，我希望这篇文章能帮助你理解什么是栈。对于经验丰富的老兵来说，我希望这篇文章能起到复习的作用。不管怎样，我希望你读这篇文章的时候开心。谢谢大家！

你也可以在 [Dev.to](https://dev.to/jpoly1219/stacks-in-go-54k) 和[我的个人网站](https://jpoly1219.github.io)上阅读这个帖子。