<html>
<head>
<title>Javascript Pro Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript专业技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-pro-tips-159029088776?source=collection_archive---------2-----------------------#2020-09-27">https://blog.devgenius.io/javascript-pro-tips-159029088776?source=collection_archive---------2-----------------------#2020-09-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ed2d07767b9370c906bda2ed8e463dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FT29kFS90c_arTUmGEMoGQ.png"/></div></div></figure><p id="7713" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将讨论Javascript Pro技巧。请学习如何编写可靠的现代Javascript，避免过去的糟糕代码。</p><h1 id="02b0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">排除故障</h1><p id="a4a0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">实际上，它是关于控制台日志的东西。</p><p id="b7ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你如何使用控制台日志？控制台日志有好方法和坏方法。想象你有三个不同的物体。每个都像这样分配给自己的变量。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e9ba" class="mf ku in mb b gy mg mh l mi mj">const foo = { name: 'tom', age: 30, nervous: false } <br/>const bar = { name: 'dick', age: 40, nervous: false }<br/>const baz = { name: 'harry', age:50, nervous: false }</span></pre><p id="16b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记录这些的最明显的方法就是一个接一个地记录。</p><p id="d777" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4a09" class="mf ku in mb b gy mg mh l mi mj">console.log(foo);<br/>console.log(bar);<br/>console.log(baz);</span></pre><p id="3fd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是主要的问题是我们不知道变量的名字，当它被记录的时候，但是有一个技巧我们可以在这里使用，叫做计算属性名，我们把变量添加到一个对象中。</p><p id="c25f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以你可以这样做:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e42f" class="mf ku in mb b gy mg mh l mi mj">console.log({ foo, bar, baz });</span></pre><p id="0cb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不仅减少了代码的使用量，还准确地告诉我们哪个变量定义了这个数据。一行代码，一个控制台日志和我们需要的所有信息。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/e7d81722e27f9f726066e6ab3dcf6e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjvItLYRTGAxgMuPkNKt3w.png"/></div></div></figure><p id="b01b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是也许这个数据是额外重要的，所以我们想用一些定制的CSS样式来突出它。您可以使用<code class="fe ml mm mn mb b">%</code>符号替换数据和CSS样式。所以我们将添加<code class="fe ml mm mn mb b">%c</code>，然后让第二个参数成为我们实际的CSS样式。</p><p id="a967" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4967" class="mf ku in mb b gy mg mh l mi mj">console.log('%c My Friends', 'color: orange;')<br/>console.log({ foo, bar, baz });</span></pre><p id="2457" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开始了。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/6721064ef3e1cf7f800a0b0a52884fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSUF-n5diXSrnUexgU79FA.png"/></div></div></figure><p id="4ef2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能已经注意到的一件事是，这些对象都有共同的属性，所以也许我们应该把它们显示为一个表格。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4bce" class="mf ku in mb b gy mg mh l mi mj">console.table([foo, bar, baz]);</span></pre><p id="1f9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你有一个对象数组时，这真的很有用。你只要用阵列做控制台表。</p><p id="34e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在基准测试性能，你实际上可以跟踪时间。控制台。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b93c" class="mf ku in mb b gy mg mh l mi mj">console.time('looper');</span><span id="c8eb" class="mf ku in mb b gy mp mh l mi mj">let i = 0;<br/>while (i &lt; 1000000) { i ++ }</span><span id="19bb" class="mf ku in mb b gy mp mh l mi mj">console.timeEnd('looper')</span></pre><p id="10ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记录时间很棒，但是如果你需要知道一个<code class="fe ml mm mn mb b">console.log</code>从哪里来呢？</p><p id="8311" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们想象一下，我们有一个非常重要的函数，它从我们的数据库中删除项目，我们希望确保我们不会意外地调用这个方法两次。在这种情况下，您可以将控制台跟踪添加到您的函数中，它会为您提供调用它的位置和定义它的内容的堆栈跟踪。如果我们运行这段代码，我们会得到一个控制台日志，告诉我们该函数是在第几行定义的。</p><p id="64d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ba08" class="mf ku in mb b gy mg mh l mi mj">const deleteMe = () =&gt; console.trace('bye bye database')</span></pre><p id="9940" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以获得:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/214d4ddf96acd3c7770761ea1d4f5c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dX4dKG0dla4QCDu_q9rPA.png"/></div></div></figure><h1 id="df8e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">解构</h1><p id="8b36" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在这里，我将向您展示几种不同的方法，让您的代码尽可能简洁高效。假设我们有一个包含动物数据的对象，我们需要一个告诉我们如何喂养动物的函数。</p><p id="2558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a163" class="mf ku in mb b gy mg mh l mi mj">function feed(animal) {<br/>    return `Feed ${animal.name} ${animal.meal} kilos of ${animal.diet}`<br/>}</span></pre><p id="f52a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来不太糟，但是你会注意到我们一遍又一遍地重复动物这个词。有一种叫做对象析构的技术，我们可以用它来消除这里的大部分重复。</p><p id="5fc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们有一个接受一个对象的函数，但是我们只需要使用它的一些属性。我们可以在论点中分解它们。我们只是把它放在括号中，然后传入我们想要使用的对象属性的名称。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d8ab" class="mf ku in mb b gy mg mh l mi mj">function feed({ name, meal, diet }) {<br/>    return `Feed ${name} ${meal} kilos of ${diet}`<br/>}</span></pre><p id="da4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在我们可以格式化同样的字符串，但是我们实际上从来不需要直接使用动物这个词。对于这个简单的函数来说，这似乎是一个不大的收获，但是当你有一个具有很多属性的大对象时，这可能会产生很大的不同。</p><p id="ae07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不喜欢object参数中的这种括号语法，实际上还有另一种同样好的方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cdcc" class="mf ku in mb b gy mg mh l mi mj">function feed(animal) {<br/>    const { name, meal, diet } = animal;<br/>    return `Feed ${name} ${meal} kilos of ${diet}`<br/>}</span></pre><p id="9353" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以在整个函数中使用像变量这样的属性，如果你有多个对象2d结构和一个函数，这可能是更好的方法。</p><h1 id="f25c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模板文字</h1><p id="d078" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在这一部分，我将讨论我们已经在代码中使用的模板文字。但实际上这里还有更多要谈的。</p><p id="a2b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们有:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2fad" class="mf ku in mb b gy mg mh l mi mj">const horse = {<br/>   name: 'Topher',<br/>   size: 'large',<br/>   skills: ['jousting', 'racing'],<br/>   age: 7<br/>}</span><span id="2e83" class="mf ku in mb b gy mp mh l mi mj">let bio = horse.name + ' is a ' + horse.size + ' horse skilled in ' + horse.skills.join(' &amp; ')</span></pre><p id="19ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你会看到很多字符串连接，就像上面一样，你有一个变量加一个字符串，你必须管理中间的空格加一个表达式加一大堆其他的东西。这种类型的代码很难处理，但是现代Javascript中的模板文字完全解决了这个问题。</p><p id="5e22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，我们可以将它们直接插入到字符串中，而不是将值连接在一起。你可以这样做，用反斜杠定义你的字符串，然后用美元符号括号，然后在里面放上你想要的任何变量或表达式。像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6966" class="mf ku in mb b gy mg mh l mi mj">const horse = {<br/>   name: 'Topher',<br/>   size: 'large',<br/>   skills: ['jousting', 'racing'],<br/>   age: 7<br/>}</span><span id="b7f6" class="mf ku in mb b gy mp mh l mi mj">bio = `${name} is a ${size} skilled in ${skills.join(' &amp; ')}`</span></pre><p id="b995" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来可读性更强，维护起来也更容易。</p><p id="2683" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是实际上你可以更进一步，用纯函数的方式构建字符串。所以我们在这里写一个名为马龄的函数，它接受一个字符串数组作为第一个参数，然后它可以接受任何其他想要的参数。想象我们有这个函数:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="361c" class="mf ku in mb b gy mg mh l mi mj">function horseAge(str, age) {<br/>   const ageStr = age &gt; 5 ? 'old' : 'young';<br/>   return `${str[0]}${ageStr} at ${age} years`;<br/>}</span></pre><p id="3ed9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但有趣的是，我们可以将它附加到一个模板文字上，它会解析其中的参数，而不是将一个常规参数传递给这个函数。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="421f" class="mf ku in mb b gy mg mh l mi mj">const bio2 = horseAge`This horse is ${horse.age}`;</span></pre><p id="43fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，它将按照出现在美元符号括号中的顺序处理所有其他参数。换句话说，你可以用一个参数在返回的字符串中组成多个值。这对于模板来说是一个非常强大的概念。</p><h1 id="2c76" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">扩展语法</h1><p id="f2a2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">假设我们有一个口袋妖怪的对象，另一个是定义其各种属性的统计数据。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="96f8" class="mf ku in mb b gy mg mh l mi mj">const pikachu = { name: 'Pikachu' }<br/>const stats = { hp: 40, attack: 60, defense: 45 }</span></pre><p id="8eea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们想将stats对象的属性分配给Pikach对象。一种方法是在原始皮卡丘对象上逐个重新定义它们。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e6f2" class="mf ku in mb b gy mg mh l mi mj">pikachu['hp] = stats.hp<br/>pikachu['attack'] = stats.attack<br/>pikachu['defense'] = stats.defense</span></pre><p id="dbf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，这真的很难看而且冗长，但是当我们很可能想要创建一个新的不可变对象时，我们也在改变原始对象，因为假设我们的口袋妖怪随着时间的推移而升级，我们希望将每个级别都表示为它自己的对象。</p><p id="f997" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在这里使用<code class="fe ml mm mn mb b">Object.assign()</code>,将原始对象与统计数据合并，这样会从左到右将它们合并在一起。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f448" class="mf ku in mb b gy mg mh l mi mj">const lv10 = Object.assign(pikachu, stats)<br/>const lvl1 = Object.assign(pikachu, { hp: 45 })</span></pre><p id="744e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这并不太坏，但是有一种更简洁的方法可以用spread语法来实现。通过创建一个新的对象，并把我们现有的对象放在前面有三个点。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cfde" class="mf ku in mb b gy mg mh l mi mj">const lvl0 = { ...pikachu, ...stats }<br/>const lvl1 = { ...pikachu, hp: 45 }</span></pre><p id="0f62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将从左到右组成一个新的对象。所以最右边的财产有优先权。同样，这主要是语法上的好处，它只是让你的代码可读性更好，更容易维护。</p><p id="3168" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以在数组上使用spread语法。让我们假设我们有一个字符串数组，我们需要将额外的项推到这个数组中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d714" class="mf ku in mb b gy mg mh l mi mj">let pokemon = ['Arbok', 'Raichu', 'Sandshrew']</span></pre><p id="82c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传统的方法是把新的项目一个接一个地放入数组。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bee6" class="mf ku in mb b gy mg mh l mi mj">pokemon.push('Bulbasaur')<br/>pokemon.push('Metapod')<br/>pokemon.push('Weedle')</span></pre><p id="e01e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在今天的世界中，我们可以通过用新的项和原始数组的spread语法定义一个数组，将这三行代码减少到一行。像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0818" class="mf ku in mb b gy mg mh l mi mj">pokemon = [...pokemon, 'Bulbasaur', 'Metapod', 'Weedle']</span><span id="8427" class="mf ku in mb b gy mp mh l mi mj">pokemon = ['Bulbasaur', ...pokemon, 'Metapod', 'Weedle']</span></pre><h1 id="b49f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">环</h1><p id="4678" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们想象一下，我们这里有一个表示其他总数的数字数组。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3632" class="mf ku in mb b gy mg mh l mi mj">const orders = [500, 30, 99, 15, 223]</span></pre><p id="fb3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要基于这个数组计算一些值，比如订单总数。也许我们需要给每个订单加一些税，并过滤掉高价值的订单，由经理审核。一种选择是只使用一个经典的for循环，就像你在几乎每种编程语言中都可以找到的那样。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3170" class="mf ku in mb b gy mg mh l mi mj">const total = 0;<br/>const withTax = [];<br/>const highValue = [];<br/>for(i = 0; i &lt; orders.length; i ++) {</span><span id="7a6f" class="mf ku in mb b gy mp mh l mi mj">  // Reduce<br/>  total += orders[i];</span><span id="b3ba" class="mf ku in mb b gy mp mh l mi mj">  // Map<br/>  withTax.push(orders[i] * 1.1);</span><span id="1fc0" class="mf ku in mb b gy mp mh l mi mj">  // Filter<br/>  if (orders[i] &gt; 100) {<br/>    highValue.push(orders[i])<br/>  }</span><span id="49b4" class="mf ku in mb b gy mp mh l mi mj">}</span></pre><p id="e8b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码非常难看，它的变异值可能会让我们的代码变得更加不可预测。幸运的是，通过使用现代的Javascript数组方法，我们可以将它减少到只有三行代码。像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e6ec" class="mf ku in mb b gy mg mh l mi mj">// Reduce<br/>const total = orders.reduce((acc, cur) =&gt; acc + cur)</span><span id="e994" class="mf ku in mb b gy mp mh l mi mj">// Map<br/>const withTax = orders.map(v =&gt; v * 1.1)</span><span id="a58d" class="mf ku in mb b gy mp mh l mi mj">// Filter<br/>const highValue = orders.filter(v =&gt; v &gt; 100)</span></pre><h1 id="a35c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异步/等待</h1><p id="ba79" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们创建一个名为random的方法，该方法返回一个异步解析为随机数的承诺。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4608" class="mf ku in mb b gy mg mh l mi mj">const random = () =&gt; {<br/>  return Promise.resolve(Math.random())<br/>}</span></pre><p id="8ea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们想一个接一个地检索三个不同的异步数字，然后在最后把它们加在一起。这可能看起来像一个愚蠢的例子，但这实际上是现实世界中很多时候的工作方式，当你必须从数据库中检索一个项目，从API中获取一些数据检索另一个项目，等等。</p><p id="86ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于承诺，你等待一个异步值被解析，然后用then中的回调函数处理它。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d1d2" class="mf ku in mb b gy mg mh l mi mj">const sumRandomAsyncNums = () =&gt; {<br/>  let first;<br/>  let second;<br/>  let third;</span><span id="f4f0" class="mf ku in mb b gy mp mh l mi mj">return random()<br/>       .then(v =&gt; {<br/>           first = v;<br/>           return random();<br/>       })<br/>       .then(v =&gt; {<br/>           second = v;<br/>           return random();<br/>       })<br/>       .then(v =&gt; {<br/>           third = v;<br/>           return first + second + third;<br/>       })<br/>}</span></pre><p id="f08e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以重写承诺链。唯一的区别是在函数前面添加了async，这将迫使它返回一个承诺。像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7102" class="mf ku in mb b gy mg mh l mi mj">const sumRandomAsyncNums = async () =&gt; {<br/>  <br/>    const first = await random();<br/>    const second = await random();<br/>    const third = await random();</span><span id="2db0" class="mf ku in mb b gy mp mh l mi mj">    return first + second + third;<br/>}</span></pre><p id="8a4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里真正的好处是，我们可以在承诺前使用await，并让它们解析为实际的变量值。因此，我们可以只说<code class="fe ml mm mn mb b">const first = await random();</code>,对第二个和第三个数字做同样的事情，而不是使用那些then回调。现在阅读和理解这段代码要容易得多，因为我们可以一行一行地看，看到我们在等待一个数，等待另一个数，等等。</p><p id="394e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个async/await概念是Javascript有史以来最棒的事情之一！</p><p id="07f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天到此为止。</p><p id="45cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>