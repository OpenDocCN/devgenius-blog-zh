<html>
<head>
<title>Why Are INDEXES Important In SQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么索引在 SQL 中很重要？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-are-indexes-important-in-sql-8c00c5aef16f?source=collection_archive---------13-----------------------#2022-12-05">https://blog.devgenius.io/why-are-indexes-important-in-sql-8c00c5aef16f?source=collection_archive---------13-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f40a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="bd65" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">索引及其对 SQL Server 性能的影响</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/1bc952f46e833016ba756d9c45b13d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*lr2Orav_sMBgI91Y"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">图片来自<a class="ae la" href="http://www.specialacademy.org/gallery/creative-writing-gallery-2/gallery-by-olivia-trieu-my-first-book/" rel="noopener ugc nofollow" target="_blank">specialacademy.org</a></figcaption></figure><h1 id="7a5d" class="lb lc iq bd ld le lf lg lh li lj lk ll kf lm kg ln ki lo kj lp kl lq km lr ls bi translated">概观</h1><p id="20c4" class="pw-post-body-paragraph lt lu iq lv b lw lx ka ly lz ma kd mb mc md me mf mg mh mi mj mk ml mm mn mo ij bi translated">SQL 中的索引就像一本书中的索引或目录。索引是 SQL 中的<strong class="lv ja">单个查找表</strong>。它们是在表和视图上创建的。</p><h1 id="a2f0" class="lb lc iq bd ld le lf lg lh li lj lk ll kf lm kg ln ki lo kj lp kl lq km lr ls bi translated">为什么要使用索引？</h1><p id="2262" class="pw-post-body-paragraph lt lu iq lv b lw lx ka ly lz ma kd mb mc md me mf mg mh mi mj mk ml mm mn mo ij bi translated">索引用于通过查询表来加快数据检索过程。如果一本书没有索引，而我们被告知要找到某个特定的章节，我们需要从头到尾寻找这本书的每一页。但是，如果这本书包含索引，我们可以查找该章的页码，并根据索引中给出的页码找到该章。因此，书中的索引大大减少了查找书中章节的时间。同样，SQL 中的索引用于增强查询的性能。如果索引不存在，那么数据库查询引擎需要从第一条记录到最后一条记录在整个表中查找所需的数据，这意味着它需要执行<strong class="lv ja">表扫描</strong>。从性能角度来看，表扫描是不好的。</p><p id="65e1" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated"><strong class="lv ja">例如:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/f5c732ae09d5941b404e46d1a5b06e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*BHyorDc5DU6UxXBF"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">员工表</figcaption></figure><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="acca" class="ne lc iq na b be nf ng l nh ni">SELECT Emp_name, Emp_salary<br/>from Employee<br/>Where Emp_salary&gt;8000 AND Emp_salary&lt;15000</span></pre><p id="8b53" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">上面的雇员表现在没有任何索引。为了获取薪水大于 8000 且小于 15000 的所有雇员姓名，查询引擎需要从第一行到最后一行搜索整个雇员表。这将导致表扫描，进而降低性能，尤其是当表包含太多记录时。为了避免这些性能问题，我们现在将学习如何在表上创建索引，以及它将如何显著提高性能。</p><h1 id="6e32" class="lb lc iq bd ld le lf lg lh li lj lk ll kf lm kg ln ki lo kj lp kl lq km lr ls bi translated">如何在表上创建索引？</h1><p id="f32b" class="pw-post-body-paragraph lt lu iq lv b lw lx ka ly lz ma kd mb mc md me mf mg mh mi mj mk ml mm mn mo ij bi translated">使用 CREATE INDEX 命令在表上创建索引。语法如下所示:</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="96cd" class="ne lc iq na b be nf ng l nh ni">CREATE INDEX index_name ON table_name column_name</span></pre><p id="f9e7" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">因此，我们使用相同的语法在带有 Emp_salary 列的 Employee 表上创建一个名为 INDEX_Employee 的索引，如下所示:</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="26a1" class="ne lc iq na b be nf ng l nh ni">CREATE INDEX INDEX_Employee<br/>ON Employee (Emp_salary ASC)</span></pre><p id="608d" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">创建的索引将存储每个雇员的工资，按升序排列，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/c6b75afbea5c73faf19ee34c0f6459ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*7ePVmUoF0SeQDRfW"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">员工表</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/fcbbdb9b056b134de86584949fca0c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/0*SDl8_HdsB2gxHGEn"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">创建指数后按升序排列的员工薪资</figcaption></figure><p id="dfe9" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">(实际索引外观可能不同)</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="a9b6" class="ne lc iq na b be nf ng l nh ni">SELECT Emp_name, Emp_salary<br/>from Employee<br/>Where Emp_salary&gt;8000 AND Emp_salary&lt;15000</span></pre><p id="dd9e" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">在使用 Emp_salary 列对 Employee 表创建索引 INDEX_Employee 之后，当我们再次使用上面的查询来查找薪金大于 8000 且小于 15000 的雇员时，该索引将帮助查询引擎获取所需的记录，因为这些记录是按升序排列的。它将快速占用所需的记录，并提高检索数据的速度。它被称为<strong class="lv ja">索引查找。</strong></p><h1 id="ba00" class="lb lc iq bd ld le lf lg lh li lj lk ll kf lm kg ln ki lo kj lp kl lq km lr ls bi translated">SQL Server 中索引对查询性能的影响</h1><p id="ed2f" class="pw-post-body-paragraph lt lu iq lv b lw lx ka ly lz ma kd mb mc md me mf mg mh mi mj mk ml mm mn mo ij bi translated">SQL Server 索引格式在顶部有一个根节点，在底部有一个叶节点，中间有中间节点。这被称为<strong class="lv ja"> B 树格式</strong>。为了找到所需的记录，它从中间有中间节点的根节点遍历到末端的叶节点。叶级节点是 SQL Server 中的索引节点，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/667cf3e510f2371dcba1702066d3394b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*0d0Gu7YdCLtvvjh4"/></div></figure><p id="6b70" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">下面是通过 BTree 索引查找所需行的步骤:</p><ol class=""><li id="1cd6" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nq nr ns nt bi translated">它从根节点开始。</li><li id="e0e7" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nq nr ns nt bi translated">然后，它转到与所需值范围相匹配的叶节点。</li><li id="c0da" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nq nr ns nt bi translated">从这个节点到第二层。</li><li id="943b" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nq nr ns nt bi translated">查找所需的记录。</li></ol><p id="8a9a" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">这个过程将重复进行，直到找到正确的行。</p><p id="10ff" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">在 SQL server 中，主要有两种类型的索引:</p><ul class=""><li id="b52d" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nz nr ns nt bi translated"><strong class="lv ja">聚簇索引:</strong>在数据表中，表示数据的物理顺序。一个表只能有一个聚集索引，但是一个聚集索引可以有多个列，这被称为<strong class="lv ja">复合聚集索引。</strong></li><li id="873a" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nz nr ns nt bi translated"><strong class="lv ja">非聚集索引:</strong>在数据表中，它表示指向数据存储位置的指针。一个表可以有多个非聚集索引。</li></ul><p id="23f9" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">聚集索引比非聚集索引快。与非聚集索引相比，聚集索引占用较少的磁盘空间。</p><p id="45a3" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">为了了解索引对 SQL Server 查询性能的影响，我们以一个名为 Techdata 的数据库为例，该数据库包含两个表 tblAuthors 和 tblBooks。tblAuthors 表包含 Id、Author_name 和 country 列，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/44fb92c15f91dbf41f0a44e83261f9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/0*_-3lHW3ypNAYAgi2"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">tblAuthors</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3bfc6cfbe9a333fb8f4dbb6f5783d753.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/0*Hk8f6QPzHufgIUBa"/></div></figure><p id="7931" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">tblAuthors 表包含 90 万条记录(为了举例说明，这是一个巨大的虚拟数据)。tblBooks 表包含 Id、Author_Id、Price 和 Edition 列，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fff507ae77fe21337be59eb661238b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/0*tklx7ev7yEkpmPLB"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">TBL 书籍</figcaption></figure><p id="8461" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">tblBooks 表还包含 90 万条记录(巨大的哑数据)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6bc8242d6ec6e9d75526d19533ec34c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/0*rfZ8RZi7-nr2H6Rw"/></div></figure><p id="4238" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">目前，tblBooks 上没有任何索引。为了检索 SQL Server 中应用于某个表的所有索引，我们可以使用以下命令执行存储过程<strong class="lv ja"> sp_helpIndex </strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oe"><img src="../Images/ba78644f40608495045cb9e3992d2952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5NXgUxJKR9rhju4V"/></div></div></figure><p id="797c" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">如消息所示，“tblBooks”没有任何索引。在 SQL server 中，当一个表没有任何索引时，它被称为<strong class="lv ja">堆表</strong>。假设，我们想获取所有书籍价格高于 70 美元低于 90 美元的记录。我们可以在 SQL Server 中执行以下 SQL 语句来查找查询的统计时间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi of"><img src="../Images/a552281aa2abeefdad2224d5d83e83ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TtsdZb5bNqzk61TP"/></div></div></figure><p id="ba62" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">如图所示，该查询从 900，000 条记录中返回 341457 条记录。从上述查询的<strong class="lv ja">执行计划</strong>可以看出，它运行了一个<strong class="lv ja">表扫描。</strong>因此，为了检索特定的记录，它已经读取了表中的所有行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c62e8fe0c52f5cb8770af8a2695bdbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*w_5tVwaMMS7kBZg3"/></div></figure><p id="50c7" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">当我们将光标悬停在表扫描上时，它将向我们显示表扫描的全部细节。在这里，我们可以看到我们的结果关系包含 341457 条记录，但是它已经读取了所有 900K 条记录。</p><ul class=""><li id="2026" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nz nr ns nt bi translated"><strong class="lv ja">读取的行数为 900000 </strong></li><li id="34fe" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nz nr ns nt bi translated"><strong class="lv ja">实际行数为 341457 </strong></li></ul><p id="642b" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">现在，我们可以想象包含数百万行的海量数据。在这里，我们的查询性能将会大大降低，因为要遍历所有数百万条记录来查找一些特定的记录。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7ff2fd65bde6bcb6fd08f1d347e30722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*8te5Pl37CjQ8f8WK"/></div></figure><p id="fa12" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">让我们在使用<strong class="lv ja">价格</strong>列在<strong class="lv ja"> tblBooks </strong>表上创建一个索引后，检查一下我们的查询性能，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oi"><img src="../Images/507f1fe4d11d66ff4e5904b1c3f869ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*jFM6lfOxIPmdWOGE"/></div></div></figure><p id="ade7" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">创建索引后，我们可以在表上调用<strong class="lv ja"> sp_helpIndex </strong>存储过程来验证<strong class="lv ja">结果</strong>窗格是否包含我们刚刚创建的索引，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oj"><img src="../Images/9f14768a085a89bd477443abb7d4ba87.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/0*PjDA3RIJKG4b5fNh"/></div></div></figure><p id="33f0" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">让我们执行相同的查询来查找图书价格高于 70 和低于 90 的记录。但是，记住这次我们的表在<strong class="lv ja">价格</strong>列上有一个索引。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ok"><img src="../Images/16d8e33355ac899009b782961bbc9ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CV7Ky3O91d1ISrRs"/></div></div></figure><p id="c907" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">我们可以看到，检索到了<strong class="lv ja"> 341457 </strong>条记录，这与我们之前在没有任何索引的表上应用的查询相同。但是，从下面的<strong class="lv ja">执行计划</strong>可以看出，这次它已经运行了<strong class="lv ja">聚集索引寻道</strong>，而不是之前<strong class="lv ja">的<strong class="lv ja">表扫描</strong>。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c09886a3bff642e61e611d46ca1c09a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*tUFZinM3Q1FdYw2g"/></div></figure><p id="f58e" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">当我们将鼠标悬停在<strong class="lv ja">聚集索引 Seek、</strong>上时，我们将进入其详细信息<strong class="lv ja"> </strong>，这表明这次读取的记录总数是<strong class="lv ja"> 341457 </strong>，但实际读取的行数也是<strong class="lv ja"> 341457，而不是之前的 900K </strong>。这一次，SQL Server 查询优化器精确地读取了这些行，因为在<strong class="lv ja"> Price </strong>列上创建了索引。</p><ul class=""><li id="3484" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nz nr ns nt bi translated"><strong class="lv ja">读取的行数是 341457 </strong></li><li id="7529" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nz nr ns nt bi translated"><strong class="lv ja">实际行数为 341457 </strong></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi om"><img src="../Images/c4af3fafe799e10e3929a21fe416dcca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rb7SbgfixJx6vKn2"/></div></div></figure><p id="630f" class="pw-post-body-paragraph lt lu iq lv b lw mp ka ly lz mq kd mb mc mr me mf mg ms mi mj mk mt mm mn mo ij bi translated">现在，我们将在 SQL Server 中进行<strong class="lv ja">显示计划分析，这是对两个执行计划的比较分析。看看下面突出显示的表扫描(无索引)和聚集索引查找(有索引)的参数和值。</strong></p><ul class=""><li id="7b75" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nz nr ns nt bi translated"><strong class="lv ja">表扫描的估计 CPU 成本为 0.990079，而聚集索引查找的估计 CPU 成本降至 0.37576。</strong></li><li id="49db" class="nl nm iq lv b lw nu lz nv mc nw mg nx mk ny mo nz nr ns nt bi translated"><strong class="lv ja">表扫描的估计 I/O 成本为 2.72394，而聚集索引查找的估计 I/O 成本为 1.03498。</strong></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi on"><img src="../Images/879aafcba2ee25d5d26b34bf71677a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qc5hW-A5hQg8ogFg"/></div></div></figure><ul class=""><li id="8938" class="nl nm iq lv b lw mp lz mq mc nn mg no mk np mo nz nr ns nt bi translated"><strong class="lv ja">表扫描的实际逻辑读取计数为 3674，而聚集索引寻道的实际逻辑读取计数为 1402。</strong></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oo"><img src="../Images/5c1dd012342be49d948bc7757d13c2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LbZlLzBapwejVn2l"/></div></div></figure><h2 id="c97a" class="op lc iq bd ld oq or dn lh os ot dp ll mc ou ov ln mg ow ox lp mk oy oz lr iw bi translated"><strong class="ak">结论</strong></h2><p id="b997" class="pw-post-body-paragraph lt lu iq lv b lw lx ka ly lz ma kd mb mc md me mf mg mh mi mj mk ml mm mn mo ij bi translated">我希望通过本教程，您已经清楚地了解了索引对我们的数据库查询引擎的影响。我们需要在表上创建索引，以优化查询性能并加快数据检索过程。我们将在下一个教程中学习 SQL Server 中的<strong class="lv ja">性能调优。</strong></p></div></div>    
</body>
</html>