<html>
<head>
<title>A Gentle Introduction to Delegation in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林代表团简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-gentle-introduction-to-delegation-in-kotlin-a1c4f19ec589?source=collection_archive---------2-----------------------#2022-07-24">https://blog.devgenius.io/a-gentle-introduction-to-delegation-in-kotlin-a1c4f19ec589?source=collection_archive---------2-----------------------#2022-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/078bbe3ac2649784a226c3934ba05956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZG5_3kbpEPoh7Mc-eYzmQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@saj_shafique?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Saj Shafique </a>在<a class="ae jz" href="https://unsplash.com/s/photos/forward?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="70a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在面向对象编程中，委托是一种面向对象的设计模式，是继承的替代方案。在委托中，一个对象通过将请求委托给另一个对象来处理请求。另一个做实际工作的对象叫做委托。</p><p id="fa57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于委托是一种设计模式，这意味着我们可以用任何面向对象的语言来实现它。一些面向对象的语言如 Kotlin 本身就支持它，这意味着没有样板代码。</p><h1 id="c9e1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一个例子</h1><p id="a37e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们通过一个简单的例子来了解委托的基本概念。首先，我们定义了<code class="fe mb mc md me b">Software</code>接口。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="eb56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们为刚刚定义的接口定义两个实现。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="debe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们定义一个名为<code class="fe mb mc md me b">WordProcessor</code>的类，它实现了<code class="fe mb mc md me b">Software</code>接口。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cdad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">WordProcessor</code>接收一个<code class="fe mb mc md me b">Software</code>的实例，当它的<code class="fe mb mc md me b">getLicense</code>被调用时，它简单地将调用委托/转发给<code class="fe mb mc md me b">software</code>。</p><p id="0cc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！现在你知道什么是委托了，但是还有更多。</p><h1 id="1580" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">班级委派</h1><p id="36c0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">你刚才看到的例子是一个类委托的例子。在类委托中，类<code class="fe mb mc md me b">A</code>将其部分或全部职责委托给类<code class="fe mb mc md me b">B</code>。</p><p id="849d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为 Kotlin 本身支持类委托，所以让我们以一种更优雅的方式实现前面的例子。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="44e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的<code class="fe mb mc md me b">WordProcessor</code>类具有与我们之前定义的完全相同的功能，但是没有任何样板代码。Kotlin 编译器将为我们生成样板文件！</p><p id="5514" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<code class="fe mb mc md me b">by</code>关键字让 Kotlin 编译器做两件事:</p><ol class=""><li id="0eb6" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">为<code class="fe mb mc md me b">WordProcessor</code>生成<code class="fe mb mc md me b">Software</code>接口的所有方法。</li><li id="d6df" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">将生成的方法的调用委托给<code class="fe mb mc md me b">software</code>对应的方法。</li></ol><p id="fef6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<code class="fe mb mc md me b">WordProcessor</code>的字节码反编译成 Java，给出如下代码。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c357" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Kotlin 编译器已经完成了它的工作！</p><p id="9c09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在该谈谈另一种类型的委托了，这种委托被称为财产委托。</p><h1 id="df56" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">财产委托</h1><p id="fe52" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在讨论财产委托之前，让我们看看为什么我们需要它。</p><h2 id="7cc9" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">一个例子</h2><p id="8a5e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">考虑下面的类。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="eb10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想要为<code class="fe mb mc md me b">User</code>的每个属性实现以下逻辑:</p><ul class=""><li id="1a29" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx nl mr ms mt bi translated">打印"<property name="">是读取"属性的值时，</property></li><li id="2c5c" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx nl mr ms mt bi translated">打印<property name="">是在给属性赋值时写的。</property></li></ul><p id="aa22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以当运行下面的代码时:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8ef4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望得到下面的输出:</p><pre class="mf mg mh mi gt nm me nn no aw np bi"><span id="8644" class="mz kz in me b gy nq nr l ns nt">firstName is written<br/>secondName is written<br/>firstName is read<br/>secondName is read</span></pre><p id="bacc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种简单的方法是在读/写<code class="fe mb mc md me b">User</code>的任何属性时手动添加<code class="fe mb mc md me b">println</code>语句。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2f0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码可以工作，但是你猜怎么着。它根本不可扩展，我们在重复同样的逻辑。如果我们可以一次定义逻辑并使用它，而不是一遍又一遍地重复相同的逻辑，那将是理想的。这就是财产代表可以帮忙的地方。</p><h2 id="afcc" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">定义属性委托</h2><p id="b9c4" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">属性委托只不过是一个具有非常特殊的<code class="fe mb mc md me b">getValue</code>和<code class="fe mb mc md me b">setValue</code>方法的类。</p><p id="e34e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们定义一个委托，它实现了我们前面手动实现的相同逻辑。</p><p id="052a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，为了让下面的代码工作，我们需要将下面的依赖项添加到我们的<code class="fe mb mc md me b">build.gradle</code>文件中(当然，假设我们使用的是 Gradle！)</p><pre class="mf mg mh mi gt nm me nn no aw np bi"><span id="2d23" class="mz kz in me b gy nq nr l ns nt"><em class="nu">implementation</em>("org.jetbrains.kotlin:kotlin-reflect:&lt;insert version here&gt;")</span></pre><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2c9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们读取属性的值时，就会执行<code class="fe mb mc md me b">getValue</code>方法。它是一个运算符方法，必须有以下确切的参数:</p><ul class=""><li id="73eb" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx nl mr ms mt bi translated"><code class="fe mb mc md me b">thisRef</code>必须是<code class="fe mb mc md me b">Any?</code>类型。它是包含委托属性的类的实例。如果委托属性没有在类中定义(如在<code class="fe mb mc md me b">main</code>函数中定义)<code class="fe mb mc md me b">thisRef</code>将为空。</li><li id="e210" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx nl mr ms mt bi translated"><code class="fe mb mc md me b">property</code>必须是类型<code class="fe mb mc md me b">KProperty&lt;*&gt;</code>或其子类型。是房产本身。</li></ul><p id="77ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">getValue</code>的返回类型必须与属性(或其子类型)的类型相同。</p><p id="0bf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">setValue</code>是我们给属性赋值时执行的方法。它是一个运算符方法，必须有以下参数。</p><ul class=""><li id="8161" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx nl mr ms mt bi translated"><code class="fe mb mc md me b">thisRef</code>与上述目的完全相同。</li><li id="9083" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx nl mr ms mt bi translated"><code class="fe mb mc md me b">property</code>与上述用途完全相同。</li><li id="4ebe" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx nl mr ms mt bi translated"><code class="fe mb mc md me b">value</code>是分配给属性的值。</li></ul><p id="3dae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以使用刚刚定义的委托了。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2c11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行上述代码会生成以下输出。</p><pre class="mf mg mh mi gt nm me nn no aw np bi"><span id="505a" class="mz kz in me b gy nq nr l ns nt">firstName is written<br/>secondName is written<br/>firstName is read<br/>secondName is read</span></pre><p id="2442" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们再次使用关键字<code class="fe mb mc md me b">by</code>进行属性委托。<code class="fe mb mc md me b">by</code>关键字告诉 Kotlin 编译器两件事:</p><ol class=""><li id="efca" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">当访问比方说<code class="fe mb mc md me b">firstName</code>的值时，不调用默认的<code class="fe mb mc md me b">firstName</code>的 getter，而是调用<code class="fe mb mc md me b">Delegate.getValue</code>。</li><li id="2b9b" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">赋值给 say <code class="fe mb mc md me b">firstName</code>时，不调用<code class="fe mb mc md me b">firstName</code>的默认 setter，而是调用<code class="fe mb mc md me b">Delegate.setValue</code>。</li></ol><p id="6340" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们将<code class="fe mb mc md me b">User</code>的字节码反编译成 Java，我们将得到下面的代码，它证实了这样一个事实，即当设置/获取<code class="fe mb mc md me b">firstName</code> / <code class="fe mb mc md me b">lastName</code>的值时，是<code class="fe mb mc md me b">Delegate</code>处理这项工作。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4c2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们刚刚实现的委托是一个非常简单且不太有用的委托。发挥你的想象力，想想我们可以通过财产委托实现的事情。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="f2bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这个！现在你对 Kotlin 的委托有了基本的了解。</p><h1 id="e128" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><p id="df08" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://kotlinlang.org/docs/delegation.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/delegation.html</a></p><p id="4c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://kotlinlang.org/docs/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/delegated-properties.html</a></p><p id="36d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.baeldung.com/kotlin/delegation-pattern" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/kotlin/delegation-pattern</a></p></div></div>    
</body>
</html>