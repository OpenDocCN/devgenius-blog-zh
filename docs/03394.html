<html>
<head>
<title>Dependency Injection, The Big Picture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入，大图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-injection-the-big-picture-e4ae1e13c87d?source=collection_archive---------2-----------------------#2020-10-29">https://blog.devgenius.io/dependency-injection-the-big-picture-e4ae1e13c87d?source=collection_archive---------2-----------------------#2020-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9746e1a3880d80d8f399db5d56f9e505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuHIN8vIbz3pINIg0qq7FA.png"/></div></div></figure><h1 id="bc23" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">什么是依赖注入？</strong></h1><p id="4f24" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">关于依赖注入(DI)及其用例有很多定义。依赖注入是软件工程中的另一个难题，在许多 web 框架和应用程序中被广泛用作一种设计模式。</p><p id="5d04" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我喜欢将<strong class="kv io">依赖注入</strong>定义为<strong class="kv io"> <em class="lw">设计模式</em> </strong>，以及实现<strong class="kv io"> <em class="lw">控制反转</em> </strong> <em class="lw"> </em> (IOC)的技术，借此一个对象接收它所依赖的其他对象。</p><p id="db9d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这么多流行语，对吧？让我们得到一个更清晰的画面。😅</p><p id="7665" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先，将<strong class="kv io"> <em class="lw">设计模式</em> </strong>视为软件开发人员在软件开发过程中面临的一般问题的解决方案。</p><p id="f308" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">另一方面，控制反转(IOC)在软件工程中是一个非常宽泛的术语。简单来说，<em class="lw">就是控制组件和类的行为，因此，顾名思义，它是用来在面向对象设计中颠倒不同种类的控件来实现松耦合</em>。</p><p id="3d5d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">反转控制有点棘手，你可以按照这篇<a class="ae lx" href="https://martinfowler.com/articles/injection.html#InversionOfControl" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">的文章</strong> </a> <strong class="kv io"> </strong>从马丁·福勒那里得到一个更清楚的例子。</p><p id="cc55" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，让我们回到我前面提到的定义中，它说<strong class="kv io"> <em class="lw">依赖注入</em> </strong>是一种实现<strong class="kv io">反转控制</strong>的技术。使用依赖注入，<strong class="kv io"> <em class="lw">实现通过构造器、服务查找、设置器等传递到对象</em> </strong>中，对象将“依赖”这些实现以正确地运行。</p><h1 id="78d2" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">依赖注入的类型</h1><p id="c67e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">依赖注入有三种类型，我们将会看到它是如何使用的。</p><p id="8d08" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">构造器注入:</strong>这在依赖注入的实现中被广泛使用。在构造函数注入中，当创建类的实例时，注入器通过类的构造函数提供服务(依赖)。</p><p id="58a0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">属性注入(Setter 注入):</strong>在属性注入中，注入器通过类的一个公共属性来提供依赖。</p><p id="4d2e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">方法注入(接口注入):</strong>在方法注入中，通过方法提供依赖关系。这个方法可以是类方法，也可以是接口方法。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="7a19" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">构造函数注入</h2><p id="d24e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如前所述，依赖关系是通过客户端的类构造函数提供的。尽管这里的大部分例子都是用 C#编写的，但它是一种通用语言，并且根据<strong class="kv io">面向对象(OO) </strong>原则很容易理解。</p><p id="17c9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们用一个真实世界的场景来更好地理解，让我们想象一个学校，基本上，学校是我们去获取知识的地方，通过学习涉及我们想要获取或获得更多理解的“那个”的东西。我们可以通过上课等方式来实现。</p><p id="3cf5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">创建一个接口<strong class="kv io"> ISchool。</strong></p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d784" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> <em class="lw"> ISchool </em> </strong>接口有一个方法定义叫做<strong class="kv io"> <em class="lw"> Learn。</em> </strong>创建一个类<strong class="kv io"> <em class="lw"> School </em> </strong>，该类在其构造函数中将<strong class="kv io"><em class="lw">is School</em></strong>接口作为参数。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b5ff" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在让我们添加两所热门大学(哈佛大学和牛津大学)，这两所大学显然都属于学校类别，并且必须从<strong class="kv io"> <em class="lw"> ISchool </em> </strong>接口继承。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0752" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有了上面的类，让我们看看依赖注入的实际应用。😋</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="70a7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意，对于<strong class="kv io"> <em class="lw"> School </em> </strong>类的每个实例，我们也可以称之为容器类，我们正在传递我们需要的类的一个新实例，在本例中是<em class="lw">哈佛大学</em>和<em class="lw">牛津大学</em>。从而使<strong class="kv io">和<em class="lw">松耦合。</em> </strong></p><blockquote class="mx my mz"><p id="4169" class="kt ku lw kv b kw lr ky kz la ls lc ld na lt lg lh nb lu lk ll nc lv lo lp lq ig bi translated">这里需要注意的重要一点是，<strong class="kv io">学校类</strong>接受<strong class="kv io">is School</strong>接口作为其<strong class="kv io"> <em class="in">构造函数</em> </strong>中<strong class="kv io"> <em class="in">依赖关系的参数。</em>T47】</strong></p></blockquote><pre class="mr ms mt mu gt nd ne nf ng aw nh bi"><span id="9305" class="mf jw in ne b gy ni nj l nk nl">private readonly ISchool _school;        <br/>public School(ISchool school)    <br/>{        <br/>   this._school = school;    <br/>}</span></pre><h2 id="27c4" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">资产注入</h2><p id="58ac" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如前所述，注入器通过类的公共属性提供依赖关系。让我们看一个很好的例子，来自我们之前的代码样本。</p><p id="f2f7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> <em class="lw">属性注入</em> </strong>可以和<strong class="kv io"> <em class="lw">构造函数注入一起实现，</em> </strong>通过设置默认为<strong class="kv io"> <em class="lw">构造函数注入</em> </strong>。回想一下在<strong class="kv io"> <em class="lw"> School 类</em> </strong>中我们声明了一个属性<strong class="kv io"> <em class="lw"> _school </em> </strong>，它的类型是<strong class="kv io"> ISchool 接口。</strong></p><pre class="mr ms mt mu gt nd ne nf ng aw nh bi"><span id="93ef" class="mf jw in ne b gy ni nj l nk nl">private readonly ISchool _school;</span></pre><p id="f614" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，要完全实现<strong class="kv io"> <em class="lw">属性注入</em> </strong>这里，我们需要修改这个属性，我们可以把它改成一个公共方法，而且，它不应该是一个<strong class="kv io"> <em class="lw">只读的</em> </strong>类型。请参见下面的示例。</p><pre class="mr ms mt mu gt nd ne nf ng aw nh bi"><span id="b60d" class="mf jw in ne b gy ni nj l nk nl">public ISchool _school { get; set; }</span></pre><p id="3dc9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意<strong class="kv io"> <em class="lw"> get-set </em> </strong>方法。以前，<strong class="kv io"> <em class="lw"> _school </em> </strong>属性是一个<strong class="kv io"> <em class="lw">只读</em> </strong>类型，它只使用<strong class="kv io"> <em class="lw"> get。</em>T15】</strong></p><p id="b009" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">另一种实现<strong class="kv io"> <em class="lw">属性注入的方式，</em> </strong>这是正常的方式，而在这种情况下，构造函数注入实际上并没有被设置为默认的注入模式。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="14dc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，通过属性注入依赖项将如下所示</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a0f3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您可以看到<strong class="kv io"> School </strong>类的属性<strong class="kv io"> school </strong>现在可以分配给哈佛大学或牛津大学的不同实例，这正是注入发生的地方。</p><h2 id="5c04" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">方法注入</h2><p id="404d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">依赖关系是通过方法提供的，方法是将依赖关系作为方法参数传递。这个方法可以是类方法，也可以是接口方法。</p><p id="68e2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们看一个上面定义的简单例子。同样，使用我们之前的例子，让我们修改代码来进一步展示方法注入是如何发生的。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e0f3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意我们正在将<strong class="kv io"> ISchool </strong>接口作为参数传递给<strong class="kv io"><em class="lw">attend class()</em></strong>方法。</p><p id="c89c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> <em class="lw">方法注入</em> </strong>不同于其他类型的 DI 模式，注入不会发生在<em class="lw">组合根</em>中，而是在调用时动态进行。</p><p id="f826" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">组合根</strong>是应用程序中一个(最好是)唯一的位置，模块在这里组合在一起。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><blockquote class="mx my mz"><p id="8fe3" class="kt ku lw kv b kw lr ky kz la ls lc ld na lt lg lh nb lu lk ll nc lv lo lp lq ig bi translated">总结一下<strong class="kv io">依赖注入</strong>的类型，我们可以说，一个学生需要一所学校，<strong class="kv io"> <em class="in">构造函数注入</em> </strong>为学生提供了一所大学的前期，他们无法改变。<strong class="kv io"> <em class="in">属性注入</em> </strong>让某人不挑大学就成为学生，可以换大学，但大概不会经常换。<strong class="kv io"> <em class="in">方法注入</em> </strong>让学生每次上课的时候选择自己要去的大学！。</p></blockquote><p id="970a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在 C#中，使用现代 web 框架，如<a class="ae lx" href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">ASP.NET 核心</strong> </a>，依赖注入是一个内置特性，它的支持不仅限于中间件，还包括框架的其他部分，如控制器、视图、模型等。</p><p id="4b0e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">关于<strong class="kv io"> <em class="lw">依赖注入</em> </strong>如何在<strong class="kv io">Asp.Net 核心</strong>中工作的更多细节需要注意的是，这可以通过使用<strong class="kv io"> <em class="lw">容器(IOC 容器)来实现。</em> </strong></p><h2 id="3d91" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">那么什么是 IoC 容器呢？</h2><p id="db4e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">请记住，<strong class="kv io"> IoC </strong>的要点是我们不应该需要手动连接我们的依赖，因此依赖注入实现了<strong class="kv io"> IoC。</strong></p><p id="1a59" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> IoC 容器</strong>创建指定类的对象，并在运行时通过构造函数、属性或方法注入所有依赖对象，并在适当的时候释放它。这样做是为了让我们不必手动创建和管理对象。</p><p id="2b8e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">所以在像<strong class="kv io"><em class="lw">Asp.Net 核心</em> </strong>这样的框架中，我们注册我们称之为<strong class="kv io"> <em class="lw">的提供者</em> </strong>和<strong class="kv io"> <em class="lw">容器(Ioc 容器)</em> </strong>为我们做依赖注入。</p><h1 id="059b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">依赖注入的优势</strong></h1><p id="96d9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">依赖注入有很多优点，也有很多用例，但是让我们来看几个。</p><h2 id="aa15" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated"><strong class="ak">松散耦合架构</strong></h2><p id="d0be" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">松散耦合意味着对象应该只拥有完成其工作所需的依赖关系——并且依赖关系应该很少。此外，如果可能的话，对象的依赖应该在接口上，而不是在“具体的”对象上。</p><h2 id="2bb9" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">具有不同模拟实现的易测试代码</h2><p id="bb19" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">依赖注入增加了组件的可测试性。当依赖关系可以注入到组件中时，就有可能注入这些依赖关系的模拟实现。模拟对象用于测试，作为真实实现的替代。</p><h2 id="ef26" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated"><strong class="ak">更可读的代码</strong></h2><p id="6b2d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">更容易看出一个对象有什么依赖关系，或者你的用例是什么。使代码更具可读性。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="b394" class="jv jw in bd jx jy nm ka kb kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks bi translated">参考</h1><p id="4d5b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae lx" href="https://martinfowler.com/articles/injection.html#InversionOfControl" rel="noopener ugc nofollow" target="_blank"> <em class="lw">反转控制:马丁福勒</em> </a> <em class="lw">、</em> <a class="ae lx" href="https://www.tutorialsteacher.com/ioc/dependency-injection" rel="noopener ugc nofollow" target="_blank"> <em class="lw">迪讲解:教程老师</em> </a></p><h2 id="9633" class="mf jw in bd jx mg mh dn kb mi mj dp kf le mk ml kj li mm mn kn lm mo mp kr mq bi translated">摘要</h2><p id="70be" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这是我能想到的关于依赖注入的一些基本解释，我希望这能有所帮助。我尽可能用简单明了的步骤来解释，但是如果有任何问题，请让我知道。</p><p id="c777" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">另外，如果你觉得这有帮助，请留下掌声。😃</p><p id="70c7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">感谢 Lionell Park 彻底检查了代码示例。</p><p id="a0db" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><a class="ae lx" href="http://chibuikekenneth.github.io/" rel="noopener ugc nofollow" target="_blank"><em class="lw">(chibuikekenneth . github . io)</em></a>，<a class="ae lx" href="https://github.com/Chibuikekenneth" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> (github) </em> </a>，<a class="ae lx" href="https://twitter.com/chibuikekenn" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> (twitter) </em> </a> <em class="lw">💂</em></p></div></div>    
</body>
</html>