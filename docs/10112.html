<html>
<head>
<title>Resilience4j Circuit Breaker with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带 Spring Boot 的 Resilience4j 断路器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/resilience4j-circuit-breaker-with-spring-boot-5fb19a748323?source=collection_archive---------2-----------------------#2022-10-08">https://blog.devgenius.io/resilience4j-circuit-breaker-with-spring-boot-5fb19a748323?source=collection_archive---------2-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/495e6749f1eccfd476baa0b3c2d2221f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6hvCsBqW0jv5ZekLCytJg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd jz">resilience 4j Spring Boot 断路器</strong></figcaption></figure><p id="d701" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">覆盖主题:<br/> 1。什么是断路器和电阻电路 4j。<br/> 2 .如何实现 Resilience4j。<br/> 3 .使用执行器进行监控。</p><p id="9d16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">什么是断路器:</strong> <br/>调用远程服务的服务，其功能类似于断路器。<br/>当连续故障的次数超过定义的阈值时，断路器关闭(<em class="ky">断开状态</em>)，并且在一段超时时间内，所有调用远程服务的尝试将立即失败。超时后，断路器允许有限数量的测试请求通过(<em class="ky">半断开状态</em>)。如果这些请求成功，断路器恢复正常操作(<em class="ky">闭合状态</em>)。否则，如果出现故障，超时时间将再次开始。</p><p id="4e81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">Resilience4j:</strong><br/>Resilience4j 是一个可选的轻量级容错库，灵感来自网飞·海斯特里克斯，是为 Java 8 和函数式编程设计的。它建立在 Java 8 的功能语言扩展之上，没有任何其他外部库依赖。下图解释了 Resilience4j 断路器的工作原理。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/35ecff76876ed6bc9a8a1b38efffa06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*2H4m5Cz0Q6SC2PVDrWOS7g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">断路器流程图</figcaption></figure><p id="de9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> H </span> <strong class="kc io">如何实施 Resilience4j: </strong></p><p id="1f30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要在我们的代码库中进行依赖性设置、断路器配置和使用。</p><p id="5c9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">添加依赖项:</strong>在 pom.xml 中添加以下依赖项。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="c0cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">配置:</strong>我们将通过应用程序 yml 使用以下配置来配置断路器。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2450" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看上面的配置</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="4e6a" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">registerHealthIndicator:</strong> By default the CircuitBreaker or RateLimiter health indicators are disabled, but we can enable them via the configuration by setting it true.</span><span id="b381" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">slidingWindowType:</strong> COUNT_BASED/TIME_BASED. Configures the type of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed<br/>Default value is COUNT_BASED.</span><span id="bb03" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">slidingWindowSize:</strong>Configures the size of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed. <br/>Its value will be in count based if slidingWindowType is COUNT_BASED.<br/>Its value will be in seconds based if slidingWindowType is TIME_BASED.<br/>Default value is 100.</span><span id="b9f5" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">permittedNumberOfCallsInHalfOpenState:</strong> Configures the number of permitted calls when the CircuitBreaker is half open.<br/>Default value is 10.</span><span id="1b46" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">minimumNumberOfCalls:</strong>Configures the minimum number of calls which are required (per sliding window  period) before the CircuitBreaker can calculate the error rate.<br/>Default value is 100</span><span id="8a03" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">waitDurationInOpenState:</strong> Configures the wait duration (in seconds) which specifies how long the  CircuitBreaker should stay open, before it switches to half open.<br/>Default value is 60 seconds.</span><span id="9761" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">slowCallRateThreshold:</strong> Configures a threshold in percentage. The CircuitBreaker considers a  call as slow when the call duration is greater than  slowCallDurationThreshold<br/>Default value is 100.</span><span id="49c4" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">slowCallDurationThreshold:</strong> Configures the duration threshold (seconds) above which calls are considered as slow and increase the slow calls percentage.<br/>Default value is 60.</span><span id="ff26" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">failureRateThreshold: </strong>Configures the failure rate threshold in percentage. If the failure rate  is equal or greater than the threshold the CircuitBreaker transitions  to open and starts short-circuiting calls.<br/>Default value is 50.</span></pre><p id="4db4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">执行器配置:</strong>我们将使用以下配置通过 application.yml 启用断路器执行器端点。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="28d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">配置好断路器后，我们可以通过浏览器进入 url <host> /actuator/health 进行健康检查。在 up 状态下，我们将得到 state <strong class="kc io"> <em class="ky"> CLOSED </em> </strong>。请查看下面的 Api 响应。</host></p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/24cf5b2fb0978eb8b6cc4f00f3e27553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*uKpLtKzpCacBUvrW5o4a4A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">断路器运行状况</figcaption></figure><p id="9b1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在半开启状态<retry>下，状态将是<strong class="kc io"> <em class="ky">半开启</em> </strong></retry></p><p id="d76e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在打开状态<remote api="" down="">下，状态会是<strong class="kc io"> <em class="ky">打开</em> </strong></remote></p><p id="08b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">代码实现:</strong>现在我们将在微服务 API 调用中实现断路器。<br/>我们将使用<strong class="kc io"> <em class="ky"> @CircuitBreaker </em> </strong>标注后跟断路器的<strong class="kc io"> <em class="ky">名称</em> </strong>和<strong class="kc io"><em class="ky">fallback method</em></strong>。<br/> fallbackMethod:当状态为 HALF_OPEN 或 OPEN 时，我们将从 fallbackMethod 返回默认响应。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="b8a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:确保用<strong class="kc io"><em class="ky">@ circuit breaker</em></strong>标注的方法不应该在同一个调用者类中。</p><p id="e699" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仅此而已！！</p><p id="f9ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以在微维修应用中使用 Resilience4j 断路器了。</p></div></div>    
</body>
</html>