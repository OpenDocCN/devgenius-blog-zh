<html>
<head>
<title>What is data versioning and 3 ways to implement it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是数据版本化以及实现它的 3 种方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-data-versioning-and-3-ways-to-implement-it-4b6377bbdf93?source=collection_archive---------1-----------------------#2021-10-23">https://blog.devgenius.io/what-is-data-versioning-and-3-ways-to-implement-it-4b6377bbdf93?source=collection_archive---------1-----------------------#2021-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="df88" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">数据的可再现性是任何数据平台的关键要素。称为数据历史化，现在的数据版本化，这是实现它的技术。这篇文章说明了一切。</h2></div><p id="e676" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了举例说明数据版本控制，我想象自己在一家电子商务公司担任数据工程师。为了简单起见，电子商务应用程序将其数据保存到 Postgres 数据库中，模型简化为两个表:用户和订单。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/b8f68fd144f8d3a60b060499838636ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QW6CLVA8rDNo2KUmKg6sqg.png"/></div></div></figure><p id="527b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了购买产品，用户需要创建一个帐户并提供个人信息:姓名、地址等。由于其描述性和可变性，这类信息保存在一个<strong class="ke io">维度</strong>实体(<strong class="ke io"> <em class="lk">用户</em> </strong>)中。当用户下订单时，这被称为事件，并且由于其不变性，它被存储在<strong class="ke io">事件/事实</strong>实体(<strong class="ke io"> <em class="lk">订单</em> </strong>)中。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ll"><img src="../Images/0bb79b6e684172b806c2c6fba7096e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcYQv6Z73zEkSJKXqpL4Jw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">切勿将整个地址存储在一个字段中:)</figcaption></figure><p id="447b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据以上数据，我们知道用户<code class="fe lq lr ls lt b">demo-user-1</code>订购了 2 件产品，应该在<code class="fe lq lr ls lt b">Street Unknown, no 10</code>地址收到。从今天起一个月内<code class="fe lq lr ls lt b">demo-user-1</code>将改变地址。首先想到的是，我们可以覆盖现有的信息，忘记以前的地址。通过这样做，重要信息被删除。由于法律要求(审计、合规、法律诉讼)，这类信息需要可检索，这就是数据版本控制的主要作用。这个要求被称为可再现性，它意味着某个时间点的查询结果不会随时间而改变，即使数据在变化。</p><blockquote class="lu lv lw"><p id="635f" class="kc kd lk ke b kf kg jo kh ki kj jr kk lx km kn ko ly kq kr ks lz ku kv kw kx ig bi translated">什么是变更数据捕获？</p></blockquote><p id="1db7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的用户在我们的应用程序中更新了地址，我们的数据如下所示:</p><pre class="kz la lb lc gt ma lt mb mc aw md bi"><span id="496a" class="me mf in lt b gy mg mh l mi mj">ecommerce=# select * from ecommerce_user_table;<br/>-[ RECORD 1 ]---+---------------------------<br/>user_id         | 1<br/>user_name       | demo-user-1<br/>user_address    | Street Unknown, No 20<br/>creation_date   | 2021-10-23<br/>insert_datetime | 2021-10-23 13:54:02.815599<br/>update_datetime | 2021-11-23 14:24:20.560314</span></pre><p id="23c5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的示例中，电子商务应用程序本身对用户的当前地址感兴趣，以便将产品发送到正确的地址。这就是用户表中的记录被覆盖的原因。更新地址的事件会导致数据发生变化，通过变化数据捕获，我们能够在电子商务公司的数据平台中记录这些变化:</p><ul class=""><li id="8459" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">要么我们在不同的表中存储用户的所有先前版本(历史方法)</li></ul><pre class="kz la lb lc gt ma lt mb mc aw md bi"><span id="b168" class="me mf in lt b gy mg mh l mi mj">ecommerce=# select * from ecommerce_user_table_hist ;<br/>-[ RECORD 1 ]---+---------------------------<br/>user_id         | 1<br/>user_name       | demo-user-1<br/>user_address    | Street Unknown, No 10<br/>creation_date   | 2021-10-23<br/>insert_datetime | 2021-10-23 13:54:02.815599<br/>update_datetime | 2021-10-23 13:54:02.815599</span></pre><ul class=""><li id="0c78" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">任一事件都记录了更改的内容(事件方法*)</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mv"><img src="../Images/1b23860bb6a35b171952a59b71c7b0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrF_7dJIRr1o02eUjSMnvg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">有了疾病控制中心，我们能够记录随时间的变化</figcaption></figure></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="7976" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道了什么是变更数据捕获，什么是数据版本控制？它只不过是以一种可以方便查询的方式存储数据版本的技术。</p><blockquote class="lu lv lw"><p id="3d71" class="kc kd lk ke b kf kg jo kh ki kj jr kk lx km kn ko ly kq kr ks lz ku kv kw kx ig bi translated">数据版本化，金博尔方法</p></blockquote><p id="c7ed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最常见的数据版本化方法是渐变维度(SCD)方法，由 Kimball 在他的<code class="fe lq lr ls lt b">The DataWarehouse Toolkit</code>中实现。大约有 7 种 SCD，但是我将展示 SCD 类型 6 的方法。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nd"><img src="../Images/9e0e09dcadf4b2fadf39f5be6c5bf8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5-0ftZigw9RLwP7iGnMyQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">有效截止日期可以默认为很久以后的日期</figcaption></figure><p id="927c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于每一个新的<em class="lk">不同的</em>记录，一个有效性区间是基于唯一的自然关键字建立的——在这个例子中是<code class="fe lq lr ls lt b">user_id</code>。每条记录都有一个<strong class="ke io"> user_key </strong>，这是一个从自然键和变更日期生成的代理键。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ne"><img src="../Images/a4b55f7d33626c7d5ab6c370a99bad98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APC8DNLlRQJrPtnEqmaT0A.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用 user_key 检索 order_date 的版本，使用 user_id 检索任何版本。</figcaption></figure><blockquote class="lu lv lw"><p id="57c7" class="kc kd lk ke b kf kg jo kh ki kj jr kk lx km kn ko ly kq kr ks lz ku kv kw kx ig bi translated">数据版本化，功能方法</p></blockquote><p id="762a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">存储是廉价的，并且由于 Hive metastore 被引入到数据环境中，围绕数据工程创建了一个功能范例。考虑到这一点，我们不需要投资创建复杂的 ETL 来复制某个版本。我们可以简单地创建用户的日常版本:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nf"><img src="../Images/2ff308f0219ba80cadda392984998bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMElI3joaZT4zpepBw_bdA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">举个例子。</figcaption></figure><p id="e9e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我确实认为这种方法不够有效，如果我想到:</p><ul class=""><li id="a204" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">需要回答是否有变化(需要复杂的查询)；</li><li id="b1b3" class="mk ml in ke b kf ng ki nh kl ni kp nj kt nk kx mp mq mr ms bi translated">非每日频率负载:较高的频率会复制更多的数据，较低的频率会创建虚假数据</li><li id="6f93" class="mk ml in ke b kf ng ki nh kl ni kp nj kt nk kx mp mq mr ms bi translated">增量负载:如果数据在输入时是增量的，则需要创建人工数据，以便为某个时刻创建快照。</li></ul><blockquote class="lu lv lw"><p id="2089" class="kc kd lk ke b kf kg jo kh ki kj jr kk lx km kn ko ly kq kr ks lz ku kv kw kx ig bi translated">数据版本化，事件方法</p></blockquote><p id="a8b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从 CDC 这一章，我们知道可以用事件做 CDC。事件可以存储在数据库或文件中，并且可以使用窗口函数进行查询:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nl"><img src="../Images/c50afafed4553482fc9c883bf871ad94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6Ev2RfPwArN5uzcsks09A.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用窗口函数，我们可以及时检索某一时刻的某个版本。</figcaption></figure><p id="7fb8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们仔细观察数据，我们会发现使用窗口函数可以生成 SCD 时间间隔:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nm"><img src="../Images/38953f1ef43c1a99a2c834ec8e20a4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBy1ATuAlpHxKQkMgnX8Qg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">事实表将只包含 user_id，并且附加的过滤器将应用于有效性间隔。</figcaption></figure><p id="72c2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然事件方法减少了实现 SCD 复杂 ETL 的需要，但是有两个相关点需要考虑:</p><ul class=""><li id="3e74" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">如果事件是在不感兴趣的属性上生成的，则可能会创建与前一个事件相似的版本；</li><li id="f628" class="mk ml in ke b kf ng ki nh kl ni kp nj kt nk kx mp mq mr ms bi translated">窗口函数计算量很大，仍然建议在 ETL 作业中处理它们。</li></ul></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="1fe1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我总结了什么是数据版本化，变更数据捕获在其中如何发挥作用，以及如何实现它。根据数据量和数据平台的底层技术，这三种方法中的任何一种都可能是最佳选择。</p><p id="8881" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lk">注意事项</em>:</p><ul class=""><li id="15e7" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">CDC，事件方法:卡夫卡使之成为可能。您可以在列级别对变更事件进行流式处理，并创建您独特的数据视图。</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mt mu l"/></div></figure><ul class=""><li id="513c" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">虽然在某些情况下，改变行为可能是分析产品中的一个关键因素，但我还没有遇到一个项目比您的系统产生和集成这种事件的压力(和成本)更重要。</li><li id="66b4" class="mk ml in ke b kf ng ki nh kl ni kp nj kt nk kx mp mq mr ms bi translated">现在，你可能知道我是 docker 的超级粉丝。这就是你如何用 docker-compose 运行 postgres:</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mt mu l"/></div></figure><pre class="kz la lb lc gt ma lt mb mc aw md bi"><span id="6883" class="me mf in lt b gy mg mh l mi mj"><strong class="lt io">petra1$ docker-compose up </strong><br/>demo-postgres-python_postgres_db_1 is up-to-date<br/>Attaching to demo-postgres-python_postgres_db_1<br/>postgres_db_1  | The files belonging to this database system will be owned by user "postgres".<br/>postgres_db_1  | This user must also own the server process.<br/>postgres_db_1  | <br/>postgres_db_1  | The database cluster will be initialized with locale "en_US.utf8".<br/>postgres_db_1  | The default database encoding has accordingly been set to "UTF8".</span><span id="25a2" class="me mf in lt b gy nn mh l mi mj"><strong class="lt io">petra1$ docker ps</strong><br/>CONTAINER ID        IMAGE                             COMMAND                  <br/>....<br/><strong class="lt io">10009cb5e923</strong>        postgres:14.0                     "docker-entrypoint.s…"   </span><span id="b670" class="me mf in lt b gy nn mh l mi mj"><strong class="lt io">petra1$ docker exec</strong> -it <strong class="lt io">10009cb5e923</strong> psql ecommerce -U ecommerce_user<br/>psql (14.0 (Debian 14.0-1.pgdg110+1))<br/>Type "help" for help.<br/><br/>ecommerce=# </span></pre></div></div>    
</body>
</html>