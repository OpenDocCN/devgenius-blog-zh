<html>
<head>
<title>Flask Blog tutorial with Hexagonal Architecture(part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">六边形架构的 Flask 博客教程(第二部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-2-8930ca009c27?source=collection_archive---------4-----------------------#2022-10-12">https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-2-8930ca009c27?source=collection_archive---------4-----------------------#2022-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5688fb3df07e18fc85641b31358a5003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebUHgG6JwawEifXlARgfzg.png"/></div></div></figure><p id="c49e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图片来自:<br/><a class="ae kt" href="http://thinkmicroservices.com/blog/2019/hexagonal-architecture.html" rel="noopener ugc nofollow" target="_blank">http://thinkmicroservices . com/blog/2019/hexagon-architecture . html</a></p><p id="4788" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ShahriyarR/hexagonal-flask-blog-tutorial" rel="noopener ugc nofollow" target="_blank">该项目的 GitHub 回购</a></p><p id="62ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa" rel="noopener">第一部分</a>中，我们已经推出了使用六角形架构重写原始<a class="ae kt" href="https://flask.palletsprojects.com/en/2.2.x/tutorial/" rel="noopener ugc nofollow" target="_blank"> Flask 博客教程</a>的想法和初始代码库。</p><p id="621c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个版本的教程充满了依赖倒置和依赖注入的主题，所以请继续关注，直到你学到新的东西。</p><p id="3443" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经总结了端口和适配器模式的端口部分(即六边形架构)，现在是实现适配器端的时候了。请参考项目文件夹结构的<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa" rel="noopener">第一部分</a>。</p><p id="d8d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在本系列的最后<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-3-9a265f0c4b95" rel="noopener">第三部分</a>中深入讨论了依赖注入。</p><h1 id="210c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">存储库模式实现</h1><p id="8b7c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们将有两个独立的存储库，<code class="fe lx ly lz ma b">PostRepository</code>和<code class="fe lx ly lz ma b">UserRepository</code>，它们都实现了来自端口部分的<code class="fe lx ly lz ma b">RepositoryInterface</code>。</p><p id="5c6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">路径:<code class="fe lx ly lz ma b">src/adapters/db/post_repository.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="93ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有<code class="fe lx ly lz ma b">src/adapters/db/user_repository.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ee8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，这两个存储库都接受数据库连接作为一个依赖项，这将在稍后通过依赖项注入来注入。</p><p id="96ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再回忆一下<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa" rel="noopener">第一部分</a>我们的<code class="fe lx ly lz ma b">PostService</code>和<code class="fe lx ly lz ma b">UserService</code>端口有一个<code class="fe lx ly lz ma b">RepositoryInterface</code>的依赖，在依赖注入过程中会注入具体的实现<code class="fe lx ly lz ma b">PostRepository</code>和<code class="fe lx ly lz ma b">UserRepository</code>。</p><p id="8b20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是 SOLID in action 所谓的依赖反转原理。</p><p id="0ea2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际的高层代码(<code class="fe lx ly lz ma b">PostService</code>和<code class="fe lx ly lz ma b">UserService</code>)并不依赖于低层代码(<code class="fe lx ly lz ma b">PostRepository</code>和<code class="fe lx ly lz ma b">UserRepository</code>)，都依赖于抽象(接口)。</p><h1 id="cf59" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">烧瓶应用</h1><p id="8b84" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">到目前为止，我们已经有了端口部分和适配器部分，现在是时候初始化我们的 Web 应用程序了。</p><p id="ae70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑一下 Flask 应用程序，想象一下 Flask 是我们项目的触发器或发起者。它在六边形的左外侧，它触发了一些动作。</p><p id="703a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特别是，端点将通过服务— <code class="fe lx ly lz ma b">UserService</code>和<code class="fe lx ly lz ma b">PostService</code>与我们的系统交互。</p><p id="9bbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，<code class="fe lx ly lz ma b">/auth/register</code>应该使用用户服务来创建功能等。</p><p id="7878" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，服务依赖于我们的端点，因此它们将被依赖注入器注入。</p><h1 id="1829" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">烧瓶 app 结构</h1><p id="cf4c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们的整体 web 应用程序结构是:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5fc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的静态和模板都是从<a class="ae kt" href="https://github.com/pallets/flask/tree/main/examples/tutorial/flaskr" rel="noopener ugc nofollow" target="_blank"> Flask 博客教程代码库</a>中抓取的。</p><p id="05c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一起探索<code class="fe lx ly lz ma b">application.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="537d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，只需忽略<code class="fe lx ly lz ma b">Container()</code>部分，这将在最后一部分解释。</p><p id="798a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个注册蓝图也应该是大家熟悉的，但是这个<code class="fe lx ly lz ma b">init_app()</code>是什么呢？基本上就是初始化数据库的 flask CLI 命令，位于<code class="fe lx ly lz ma b">main.config</code>。</p><p id="dd2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将我们引向项目的主要配置部分。</p><h1 id="e0e6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">配置</h1><p id="4c56" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在<code class="fe lx ly lz ma b">src/main/config.py</code>中，我们放置了所有的配置，这是集中我们设置的一种非常天真和恰当的方式。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="655f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">init_app()</code>将<code class="fe lx ly lz ma b">init-db</code>命令(见<code class="fe lx ly lz ma b">@click.command</code>装饰器)注册为 Flask CLI 命令。</p><p id="5653" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe lx ly lz ma b">src/adapters/app/schema.sql</code>中有一个<code class="fe lx ly lz ma b">schema.sql</code>文件，将在<code class="fe lx ly lz ma b">init_db()</code>中使用，用于创建数据库表。由于<code class="fe lx ly lz ma b">init-db</code>命令是 flask app 命令的一部分，因此<code class="fe lx ly lz ma b">schema.sql</code>也位于附近。</p><blockquote class="mh mi mj"><p id="7119" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">我们在这里没有使用 ORM，因为最初的 Flask 博客教程忽略了这个主题。</p></blockquote><p id="a2ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个有趣的部分是<code class="fe lx ly lz ma b">get_db()</code>函数，如果你注意到我们从这个函数返回可调用的，调用者应该调用返回值来获得实际的数据库连接。</p><p id="a8c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是<a class="ae kt" href="https://github.com/ets-labs/python-dependency-injector" rel="noopener ugc nofollow" target="_blank">依赖注入器</a>的一个变通方法，因为连接对象本身不能被酸洗。</p><h1 id="0ed1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">烧瓶设计图</h1><p id="acf8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在我们越来越接近实际的 web 应用程序。</p><p id="c440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在<code class="fe lx ly lz ma b">src/adapters/app/blueprints</code>中定义我们的蓝图。基本上，我们有两个文件<code class="fe lx ly lz ma b">auth.py</code>用于认证端点，还有<code class="fe lx ly lz ma b">blog.py</code>用于博客:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cb66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">auth.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f61b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">logout 函数和 login_required 装饰器很简单，不需要注意。</p><p id="1c9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的还挺有意思的。这个<code class="fe lx ly lz ma b">register</code>的签名是:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="aa87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，<code class="fe lx ly lz ma b">user_service</code>是这个函数的依赖项，而实际的<code class="fe lx ly lz ma b">user_service</code>对象是由依赖注入器容器(<code class="fe lx ly lz ma b">Provide[Container.user_package.user_service]</code>)提供的。</p><p id="0bf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">@inject</code>装饰器表明<code class="fe lx ly lz ma b">user_service</code>将被注入，只要。</p><blockquote class="mh mi mj"><p id="bbfb" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">我们将在第三部分探讨依赖注入主题，所以请不要惊慌。</p></blockquote><p id="63d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们解释一下下面的代码部分:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="beba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">register_user_factory</code>接受用户名和密码并返回<code class="fe lx ly lz ma b">RegisterUserInputDto</code>,正如我们在本系列文章的第一部分中所解释的。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6105" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，密码散列和所有其他验证工作都将在工厂内部进行。我们已经将这一职责从端点和服务委托给 Dto 端。</p><p id="85e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在取回<code class="fe lx ly lz ma b">RegisterUserInputDto</code>对象后，我们将它直接发送给<code class="fe lx ly lz ma b">user_service.create()</code>方法，该方法具有以下签名:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="438e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它接受<code class="fe lx ly lz ma b">RegisterUserInputDto</code>，然后使用 user_factory 创建一个实际的用户模型。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5eef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意<code class="fe lx ly lz ma b">uuid4</code>代也隐藏在用户工厂中，因为它不是所创建的服务的责任。</p><p id="7b3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的很简单，将用户插入用户数据库表并返回。</p><p id="49cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的原则和思想也适用于博客蓝图。</p><p id="e515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面我们来详细探究一下，<code class="fe lx ly lz ma b">blog.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="375a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建、更新和删除端点接受<code class="fe lx ly lz ma b">PostService</code>作为来自依赖注入容器的依赖。再次值得注意的是，我们已经将<code class="fe lx ly lz ma b">create_post_factory</code>、<code class="fe lx ly lz ma b">update_post_factory</code>和<code class="fe lx ly lz ma b">delete_post_factory</code>分开，用于创建 dto:<code class="fe lx ly lz ma b">CreatePostInputDto</code>、<code class="fe lx ly lz ma b">UpdatePostInputDto</code>和<code class="fe lx ly lz ma b">DeletePostInputDto</code>。</p><p id="c586" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些 d to 然后被传递给实际的相应服务动作。</p><p id="3abc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第二部分中，我们探索了:</p><ul class=""><li id="75d8" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">存储库模式实现</li><li id="3ac3" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">Flask app 启动代码，数据库初始化</li><li id="144b" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">简要介绍了依赖注入容器的思想</li><li id="0363" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">使用 Flask 蓝图实施 web 端点</li></ul></div></div>    
</body>
</html>