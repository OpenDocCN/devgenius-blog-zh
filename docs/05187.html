<html>
<head>
<title>Guide to Multithreading in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 多线程指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multithreading-in-swift-how-gcd-works-why-do-we-need-operation-queues-high-performing-ios-ddf6ca09583e?source=collection_archive---------0-----------------------#2021-06-29">https://blog.devgenius.io/multithreading-in-swift-how-gcd-works-why-do-we-need-operation-queues-high-performing-ios-ddf6ca09583e?source=collection_archive---------0-----------------------#2021-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="9c69" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">技术</h2><div class=""/><div class=""><h2 id="dc4d" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">使用 GCD 和操作队列介绍 Swift 中的多线程</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/5364234630260f0a1809d3503f2ab121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*RqwErhdFudaIiIztnbJqRw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">iOS | GCD |调度队列中的多线程</figcaption></figure><p id="c4c9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">你有没有收到公关评论说“这不属于主队列”或类似的话，却不知道为什么？好了，这篇文章送给你！</p><p id="cfd2" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我相信我们所有人都花了相当多的时间查看调试导航器和查看堆栈跟踪。嗯，堆栈跟踪只不过是在运行程序的过程中执行的<em class="lt">线程</em>的回溯。线程仅仅是<em class="lt">一组可以独立执行的命令。</em></p><p id="b491" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">每个应用程序至少有一个线程，即主线程。这是线程层次结构中最顶层的线程，它可以将其任务委托给其他线程。主线程将任务委托给其他几个<em class="lt">后台线程</em>就是我们所说的<strong class="kz ix">多线程</strong>。多线程只不过是同时执行任务<strong class="kz ix">和</strong>，通过在多个线程上调度它们来提高应用程序的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/2bf15d57d70618117b9ec9a559f0d508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EJRbt5ZX-jX2B7X81ZNeA.jpeg"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">单核处理器与多核处理器中的并发性(作者)</figcaption></figure><p id="2c71" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">虽然通过<em class="lt">时间分片</em>可以在单核处理器中实现并发性，但是<em class="lt">多线程</em>和<em class="lt">并发性</em>在 20 世纪 50 年代随着多核处理器的引入而变得流行起来。与单核处理器不同，多核处理器允许我们并行运行多个线程，而无需<em class="lt">时间分片</em>中涉及的<em class="lt">上下文切换</em>。不使用这种运行多线程的能力，本质上意味着我们没有以最佳方式利用资源，导致性能低下。这就是<strong class="kz ix">大中央调度</strong>，通常被称为<strong class="kz ix"> GCD </strong>的用武之地。</p><h1 id="e920" class="lz ma in bd mb mc md me mf mg mh mi mj kc mk kd ml kf mm kg mn ki mo kj mp mq bi translated">什么是中央车站？</h1><p id="5377" class="pw-post-body-paragraph kx ky in kz b la mr jx lc ld ms ka lf lg mt li lj lk mu lm ln lo mv lq lr ls ig bi translated">如果你开发过 iOS 应用程序，你一定意识到即使我们使用多线程(我们的堆栈跟踪就是证明！)，我们其实和线程的交互不多。这是因为 GCD 在后台处理它。管理哪个线程将要运行哪个任务是 GCD 的责任，我们只需要指定需要运行的任务。这也是一件好事，因为 GCD 在系统层面上工作，更了解系统的资源，如何利用它们，以及如何安排我们的任务最有效地执行。</p><p id="5fc6" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">GCD 管理一组<strong class="kz ix">分派队列</strong>，或者简称为队列，我们的任务在队列中被装载、调度，然后在线程池中进一步分发以供执行。这些调度队列可以是"<em class="lt">串行"</em>，即顺序运行任务，也可以是<em class="lt">"并发"</em>，并行运行任务。正如我们已经讨论过的，并发性会带来更好的性能，所以我们被鼓励更多地使用并发队列。</p><h1 id="f998" class="lz ma in bd mb mc md me mf mg mh mi mj kc mk kd ml kf mm kg mn ki mo kj mp mq bi translated">DispatchQueue.main.what…？</h1><p id="03a4" class="pw-post-body-paragraph kx ky in kz b la mr jx lc ld ms ka lf lg mt li lj lk mu lm ln lo mv lq lr ls ig bi translated"><em class="lt">主队列</em>是一个全局可用的<em class="lt">串行队列</em>，由在应用主线程上执行任务的 GCD 提供。</p><blockquote class="mw mx my"><p id="d65f" class="kx ky lt kz b la lb jx lc ld le ka lf mz lh li lj na ll lm ln nb lp lq lr ls ig bi translated">由于主线程用于更新 UI，我们在这个队列上执行任务时应该小心，因为我们不想阻塞主线程。</p></blockquote><p id="9785" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">但是阻塞主线程是什么意思呢？而且真的会影响用户体验吗？我们已经知道主线程用于更新 UI。这是一项非常耗费资源的行动。由于大多数设备每秒都要执行多次这种操作，所以即使是几分之一秒的延迟也会对我们的用户界面的流畅程度产生影响。为了让我们的应用程序能够每秒绘制多次 UI，它需要有足够的资源，如果我们在主线程上执行不必要的任务，这是不可能的。</p><p id="529c" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为了避免这种情况，除了主队列之外，GCD 还为我们提供了一堆<strong class="kz ix">全局队列</strong>，也称为后台队列，用于执行不属于主线程的任务，即任何不属于 UI 更新的任务！</p><p id="6bd3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">例如，您需要基于某种状态显示一个动画，并且您有一个返回要显示哪个动画的函数。与其获取动画并将其显示在主队列上，不如在全局后台线程上获取动画并在主线程上显示动画。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">在全局线程和主线程之间拆分 UI 更新和 CPU 密集型代码</figcaption></figure><p id="cd75" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，我们所说的<code class="fe ne nf ng nh b">DispatchQueue.main.async</code>中的<code class="fe ne nf ng nh b">async</code>是什么意思？嗯，GCD 允许我们以<em class="lt">同步</em>或<em class="lt">异步</em>的方式分派任务。使用<code class="fe ne nf ng nh b">sync</code>只会在完成任务执行后将控制返回给调用函数。而使用<code class="fe ne nf ng nh b">async</code>会立即开始执行并将控制返回给调用者，而不会阻塞线程。通常，我们在进行 API 调用或执行 CPU 密集型任务时使用异步。同样，正如我们对主线程使用 async 一样，我们可以根据自己的需求使用<code class="fe ne nf ng nh b">DispathQueue.global().async</code>或<code class="fe ne nf ng nh b">sync</code>。</p><h1 id="92e2" class="lz ma in bd mb mc md me mf mg mh mi mj kc mk kd ml kf mm kg mn ki mo kj mp mq bi translated">那我们为什么需要操作队列？</h1><p id="4539" class="pw-post-body-paragraph kx ky in kz b la mr jx lc ld ms ka lf lg mt li lj lk mu lm ln lo mv lq lr ls ig bi translated">所以我们知道 GCD 是一个支持多线程的低级 API。<em class="lt">另一方面，操作队列</em>是建立在 GCD 之上的抽象。它们允许我们给任务添加优先级，并在它们之间添加依赖关系。因此，调度队列是纯粹的 FIFO，而操作队列不是。此外，还记得<em class="lt">调度队列</em>是串行的还是并发的吗？操作队列总是并发的。我们可以通过定义依赖关系来设置某些序列，但它们永远不会是纯顺序的。</p><p id="c2ea" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为了实现操作队列，我们可以使用<code class="fe ne nf ng nh b">OperationQueue</code>或<code class="fe ne nf ng nh b">NSOperatioQueue</code>类，对于添加到这些队列中的任务，或者说<em class="lt">操作</em>，我们使用<code class="fe ne nf ng nh b">Operation</code>或<code class="fe ne nf ng nh b">NSOperation</code>类。这些操作就像调度队列任务一样，是可以独立执行的命令单元。</p><p id="6486" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">操作队列的真正优势是什么？难道我们不能用 GCD 来实现这些任务吗？</strong></p><ul class=""><li id="9983" class="ni nj in kz b la lb ld le lg nk lk nl lo nm ls nn no np nq bi translated">当您需要根据另一个任务的结果执行一个任务时，您可能希望使用操作队列来克服分派队列的 FIFO 行为。</li><li id="6af1" class="ni nj in kz b la nr ld ns lg nt lk nu lo nv ls nn no np nq bi translated">调度队列不允许您设置<strong class="kz ix">优先级</strong>。如果您的任务需要区分优先级，您需要使用操作队列。</li><li id="2678" class="ni nj in kz b la nr ld ns lg nt lk nu lo nv ls nn no np nq bi translated">操作队列允许您取消已经计划的任务。由于 GCD 的透明性并不为人所知，这对于调度队列来说并不容易实现。有一些变通方法，但是没有好的方法可以用 GCD 做到这一点。即便如此，一旦任务开始在调度队列中运行，就无法停止。即使操作队列不会强制停止正在执行的操作，它们也会将其 canceled 属性设置为 true。每个操作都有<em class="lt">就绪</em>、<em class="lt">执行</em>和<em class="lt">完成</em>状态。当执行成功完成时，Finished 设置为 true。如果存在与该操作相关联的完成块，则在设置了完成标志时执行该操作。但是，在取消操作的情况下，取消标志在完成标志之前设置。因此，您可以相应地修改完成块，并在需要时处理取消的场景。这在 GCD 中是不可能的。</li></ul><p id="dcbb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这里有一个操作队列的例子。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Swift 中操作队列的示例代码</figcaption></figure></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="ae1f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">就这样结束了。这是 swift 中多线程的简短介绍，带有<em class="lt"> GCD </em>和<em class="lt">操作队列</em>。感谢阅读。欢迎提出任何问题，非常感谢您的反馈，所以请留下您的评论！</p></div></div>    
</body>
</html>