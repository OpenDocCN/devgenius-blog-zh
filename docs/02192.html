<html>
<head>
<title>Node.js Tips — Body Parser Errors, Static Files, and Update Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—主体解析器错误、静态文件和更新集合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-body-parser-errors-static-files-and-update-collections-ab510c4dce14?source=collection_archive---------14-----------------------#2020-07-22">https://blog.devgenius.io/node-js-tips-body-parser-errors-static-files-and-update-collections-ab510c4dce14?source=collection_archive---------14-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/67579a47a2fca05989cc3eeea552db66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L9uoH90mtRhKl-GS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@hirmin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克斯·克莱恩</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="293f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="f936" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">注册猫鼬模型</h1><p id="5219" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过导出它们来注册Mongoose模型，然后在我们的Express应用程序的入口点中要求它们。</p><p id="569e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以在<code class="fe me mf mg mh b">models/User.js</code>中编写以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="31c7" class="mq lc iq mh b gy mr ms l mt mu">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;</span><span id="432b" class="mq lc iq mh b gy mv ms l mt mu">const userSchema = new Schema({<br/>  name: String<br/>});<br/><br/>mongoose.model('User', userSchema);</span></pre><p id="06e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的<code class="fe me mf mg mh b">app.js</code>文件中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d966" class="mq lc iq mh b gy mr ms l mt mu">mongoose.connect("mongodb://localhost/news");<br/>require("./models/User");</span><span id="3710" class="mq lc iq mh b gy mv ms l mt mu">const users = require('./routes/users');</span><span id="aa20" class="mq lc iq mh b gy mv ms l mt mu">const app = express();</span></pre><p id="544b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要求<code class="fe me mf mg mh b">./models/User.js</code>将使它运行代码来注册模型。</p><h1 id="9618" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Catch Express主体解析器错误</h1><p id="7fdc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自己的中间件捕捉明显的<code class="fe me mf mg mh b">body-parser</code>错误。</p><p id="891e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="86e0" class="mq lc iq mh b gy mr ms l mt mu">app.use( (error, req, res, next) =&gt; {<br/>  if (error instanceof SyntaxError) {<br/>    sendError(res, 'syntax error');<br/>  } else {<br/>    next();<br/>  }<br/>});</span></pre><p id="de38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查<code class="fe me mf mg mh b">error</code>是否是<code class="fe me mf mg mh b">SyntaxError</code>的实例，并对其进行处理。</p><p id="6fb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则我们调用<code class="fe me mf mg mh b">next</code>继续下一个中间件。</p><h1 id="a535" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过快速应用程序将所有请求发送至index.html</h1><p id="994a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在一个路由处理器中使用rth<code class="fe me mf mg mh b">sendFile</code>方法将所有请求路由到Express应用程序中的<code class="fe me mf mg mh b">index.html</code>。</p><p id="1cde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="81a7" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express')<br/>const server = express();<br/>const path = require('path');</span><span id="a0f4" class="mq lc iq mh b gy mv ms l mt mu">server.use('/public', express.static(path.join(__dirname, '/assets')));</span><span id="ed55" class="mq lc iq mh b gy mv ms l mt mu">server.get('/foo', (req, res) =&gt; {<br/>  res.send('ok')<br/>})</span><span id="b5f1" class="mq lc iq mh b gy mv ms l mt mu">server.get('/*', (req, res) =&gt; {<br/>  res.sendFile(path.join(__dirname, '/index.html'));<br/>})</span><span id="9fb1" class="mq lc iq mh b gy mv ms l mt mu">const port = 8000;<br/>server.listen(port)</span></pre><p id="4aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将所有请求重定向到<code class="fe me mf mg mh b">index.html</code>,最后是一个无所不包的路由。</p><p id="48a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们仍然可以有一些路线做别的事情。</p><p id="9a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">foo</code>路线响应<code class="fe me mf mg mh b">ok</code>。</p><p id="fa20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">express.static</code>提供静态内容。</p><h1 id="e4f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有Node.js和Express的基本Web服务器，用于提供HTML文件和资源</h1><p id="13be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">express.static</code>中间件来服务静态资产。</p><p id="3c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0de8" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const app = express();<br/>const http = require('http');<br/>const path= require('path');<br/>const httpServer = http.Server(app);</span><span id="2d70" class="mq lc iq mh b gy mv ms l mt mu">app.use(express.static(path.join(__dirname, '/assets'));</span><span id="59a1" class="mq lc iq mh b gy mv ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.sendfile(path.join(__dirname, '/index.html'));<br/>});<br/>app.listen(3000);</span></pre><p id="16b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个带有<code class="fe me mf mg mh b">express.static</code>中间件的服务器来服务来自<code class="fe me mf mg mh b">assets</code>文件夹的静态文件。</p><p id="00b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个GET route来渲染<code class="fe me mf mg mh b">index.html</code>。</p><p id="7dda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">connect</code>来做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb8e" class="mq lc iq mh b gy mr ms l mt mu">const util = require('util');<br/>const connect = require('connect');<br/>const port = 1234;</span><span id="a46d" class="mq lc iq mh b gy mv ms l mt mu">connect.createServer(connect.static(__dirname)).listen(port);</span></pre><p id="5ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">createServer</code>来创建一个web服务器。</p><p id="f3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">connect.static</code>将当前app文件夹作为静态文件夹服务。</p><h1 id="bb47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Gzip快速静态内容</h1><p id="fac6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用中间件<code class="fe me mf mg mh b">compression</code>通过Gzip提供静态内容。</p><p id="24d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8abb" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const compress = require('compression');<br/>const app = express();<br/>app.use(compress());</span></pre><h1 id="232a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中查找文件的大小</h1><p id="c6e0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">statSync</code>方法来获取文件的大小。</p><p id="110c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d30f" class="mq lc iq mh b gy mr ms l mt mu">const fs = require("fs");<br/>const stats = fs.statSync("foo.txt");<br/>const fileSizeInBytes = stats.size</span></pre><p id="d001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">statSync</code>来返回一个包含文件相关数据的对象。</p><p id="f42e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以字节为单位的大小在<code class="fe me mf mg mh b">size</code>属性中。</p><h1 id="c1ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动为每个“呈现”响应添加标题</h1><p id="8dd4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">res.header</code>方法为每个响应返回一个头。</p><p id="dace" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f244" class="mq lc iq mh b gy mr ms l mt mu">app.get('/*', (req, res, next) =&gt; {<br/>  res.header('X-XSS-Protection', 0);<br/>  next(); <br/>});</span></pre><p id="8966" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个中间件来设置<code class="fe me mf mg mh b">X-XSS-Protection</code>头为0。</p><h1 id="0ef5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Mongoose更新子集合</h1><p id="fe5f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在回调中更新之后，我们获得更新的集合。</p><p id="d132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="123d" class="mq lc iq mh b gy mr ms l mt mu">Lists.findById(listId, (err, list) =&gt; {<br/>  if (err) {<br/>    ...<br/>  } else {<br/>    list.items.push(task)<br/>    list.save((err, list) =&gt; {<br/>      ...<br/>    });<br/>  }<br/>});</span></pre><p id="5377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">findById</code>来获取集合。</p><p id="92c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe me mf mg mh b">items</code>子集合上调用<code class="fe me mf mg mh b">push</code>。</p><p id="25b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们调用<code class="fe me mf mg mh b">list.save</code>保存数据，并在<code class="fe me mf mg mh b">save</code>回调的<code class="fe me mf mg mh b">list</code>数组中获取最新的列表。</p><p id="8594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用<code class="fe me mf mg mh b">$push</code>操作符在回调之外进行推送:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="30f2" class="mq lc iq mh b gy mr ms l mt mu">Lists.findByIdAndUpdate(listId, {$push: { items: task }}, (err, list) =&gt; {<br/>  //...<br/>});</span></pre><p id="8d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">listId</code>调用<code class="fe me mf mg mh b">findByIdAndUpdate</code>来获取列表。</p><p id="9444" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用我们的<code class="fe me mf mg mh b">task</code>对象设置<code class="fe me mf mg mh b">items</code>，并使用<code class="fe me mf mg mh b">$push</code>来推动它。</p><p id="0d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从回调中的<code class="fe me mf mg mh b">list</code>参数获取最新的数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4701152c39c3d904958fc1ce3a12c2f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4aKafqRRiQ-DOaTY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@williamdaigneault?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·戴格诺特</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="0d67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0c85" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过运行注册模式的代码来注册Mongoose模型。</p><p id="2c3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向子集合添加项的方法不止一种。</p><p id="d91e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Express或Connect提供静态文件。</p><p id="652a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以捕捉主体解析器错误。</p></div></div>    
</body>
</html>