<html>
<head>
<title>Let’s Build a WebSockets Project With Rust and Yew 0.19 🦀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用 Rust 和 Yew 0.19 构建一个 WebSockets 项目🦀</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-build-a-websockets-project-with-rust-and-yew-0-19-60720367399f?source=collection_archive---------0-----------------------#2022-02-14">https://blog.devgenius.io/lets-build-a-websockets-project-with-rust-and-yew-0-19-60720367399f?source=collection_archive---------0-----------------------#2022-02-14</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><figure class="gm go jm jn jo jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj jl"><img src="../Images/946e68e73d0efc5e4a5ffaf8bb2d3632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEtmkR0Qg6Y2j_Duy3uZIA.jpeg"/></div></div><figcaption class="jw jx gk gi gj jy jz bd b be z dk translated">照片由<a class="ae ka" href="https://unsplash.com/@ahmeyer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克·温克勒</a>在<a class="ae ka" href="https://unsplash.com/s/photos/socket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8f08" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">让我先说我是红豆杉的超级粉丝。使用 Rust 的能力和灵活性来构建前端组件，我觉得随着 WebAssembly 的适应能力的增长，这只会变得越来越大。最近，我的一个副业项目需要一些 WebSockets love。我认为这将是深入了解 Yew 最近发布的 0.19 版本的最佳时机，该版本引入了对框架的几项重大更改(移除了<code class="fe kz la lb lc b">web-sys</code>及其支持的服务(即<code class="fe kz la lb lc b">ConsoleService</code>)并引入了<em class="ld">、</em>等功能组件)。</p><p id="ed46" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">正如你可能已经从标题中猜到的那样，我们将使用 Yew、yew-router、yew-agent 和其他几个箱子来构建一个聊天应用程序(这是一个陈词滥调，我知道，我将展示我自己)。</p><figure class="lf lg lh li gu jp gi gj paragraph-image"><div class="gi gj le"><img src="../Images/67e02f0f7c516b115b35149643f6a0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*OZlexFCroqrP80FF.jpg"/></div><figcaption class="jw jx gk gi gj jy jz bd b be z dk translated">至少它有 GIF 支持！</figcaption></figure><p id="5f15" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">为了让你对我们将要建造的东西有所了解，请看这张可爱的图片:</p><figure class="lf lg lh li gu jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj lj"><img src="../Images/c7e04141aa4c61effccb030a3c7978a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RbbAFl7MeYex63eTb9s0dQ.gif"/></div></div></figure><blockquote class="lk ll lm"><p id="f0b1" class="kb kc ld kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky ih bi translated"><em class="io"> 🛑 </em>在前进之前，确保你已经安装了 Rust 和 NodeJS。</p></blockquote><h1 id="e528" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">🗿WebSocket 服务器</h1><p id="d74a" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">要在客户端使用 WebSockets，您需要一台能够使用 WebSockets 的服务器(我知道这很令人震惊)。为了保持这篇文章的合理长度，也为了专注于一个主题，我们不会过多地讨论 WebSockets 服务器。简而言之:除了处理传入和传出连接，服务器还将传入连接保存在一个名为<code class="fe kz la lb lc b">users</code>的数组中。每隔几秒钟，服务器就会将<code class="fe kz la lb lc b">users</code>数组与服务器当前的活动连接列表进行比较，以验证列表中的所有用户实际上都仍然处于连接状态。</p><p id="1d9c" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">虽然你可以为我们可爱的聊天应用程序构建/使用自己的 WebSockets 服务器，但这里更简单的解决方案是克隆我在 https://github.com/jtordgeman/SimpleWebsocketServer 使用的 NodeJS WebSocket 服务器。克隆完成后，运行<code class="fe kz la lb lc b">npm i</code>，然后运行<code class="fe kz la lb lc b">npm start</code>，如果一切顺利，您现在应该有一个可爱的 WebSockets 服务器在端口 8080 上本地运行。</p><h1 id="28b1" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">该走了🚀</h1><ol class=""><li id="d73e" class="mt mu io kd b ke mo ki mp km mv kq mw ku mx ky my mz na nb bi translated">在<a class="ae ka" href="https://github.com/jtordgeman/YewChat" rel="noopener ugc nofollow" target="_blank">https://github.com/jtordgeman/YewChat</a>克隆启动项目</li><li id="bee7" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">安装工具链依赖项</li></ol><pre class="lf lg lh li gu nh lc ni nj aw nk bi"><span id="fa1d" class="nl lr io lc b gz nm nn l no np">npm i</span></pre><blockquote class="lk ll lm"><p id="5ba1" class="kb kc ld kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky ih bi translated">starter 项目只是一个已经设置了 wasm-pack 和 webpack 的空项目，因此我们可以将注意力集中到 Yew 上</p></blockquote><h1 id="11a1" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak"> 🛤 ️Routing </strong></h1><p id="2604" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">我们的应用程序有三种可能的路线:</p><ol class=""><li id="9a68" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">登录——一个简单的页面，带有一个文本框和一个按钮，供用户输入昵称</li><li id="1160" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">聊天——主页面——有一个用户列表、聊天显示和一个用于向聊天中输入内容的文本框</li><li id="d8c3" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">404——如果任何人试图去一个不存在的页面——这个包罗万象的页面将显示其所有的荣耀</li></ol><p id="c828" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">如果你来自 React，你可能知道(并使用)<code class="fe kz la lb lc b">react-router-dom</code>。好消息。<code class="fe kz la lb lc b">yew-router</code>几乎是完全相同的想法！<code class="fe kz la lb lc b">yew-router</code>根据 URL 处理不同页面(组件)的显示。</p><p id="6db4" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">理论讲够了，让我们开始吧:</p><ol class=""><li id="cec7" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">在<strong class="kd ip"> src </strong>文件夹下新建一个名为<strong class="kd ip"> components </strong>的文件夹。我们将在这里托管所有组件。</li><li id="ed9f" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">在新创建的组件文件夹下创建三个文件:<strong class="kd ip"> chat.rs </strong>、<strong class="kd ip"> login.rs </strong>、<strong class="kd ip"> mod.rs. </strong>我们暂时将 chat 和 login 留空，在 mod.rs 中添加以下内容:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="991d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.在<strong class="kd ip"> lib.rs </strong>的顶部，添加以下使用语句:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="6c66" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">注意<strong class="kd ip">登录</strong>和<strong class="kd ip">聊天</strong>将显示为未解决。当我们以后开始处理组件时，我们会解决这个问题。</p><p id="539d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">4.多亏了<code class="fe kz la lb lc b">yew-router</code>，我们可以使用 enum 来定义我们的路线。我们将把它添加到我们的<strong class="kd ip">库</strong>中，如下所示:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="f902" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">非常好的东西！我们用它处理的 URL 注释每个条目。注意，404 路由使用了一个额外的注释:<code class="fe kz la lb lc b">#[not_found]</code>——这个宏来自<code class="fe kz la lb lc b">yew-router</code>包，基本上是它使得这个路由成为一个无所不包的路由。</p><p id="d7d2" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">5.接下来，我们需要一种方法来将路由的 enum 值转换为实际的组件。在 Route enum 的正下方添加以下<code class="fe kz la lb lc b">switch</code>函数:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="2818" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">6.为了渲染我们的路由器(以及它路由到的组件)，我们将使用<strong class="kd ip">一个功能组件。你可能会问，什么是功能组件？<br/>功能组件是常规 Yew 组件的简化版本，它可以接收属性并通过返回 HTML 来确定呈现的内容。简而言之——功能组件基本上是被简化为只有<code class="fe kz la lb lc b">view</code>方法的组件。</strong></p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="9657" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">7.最后但同样重要的是，我们需要一个应用程序的入口点 JavaScript 可以调用这个函数来启动我们的 Yew 应用程序。将<code class="fe kz la lb lc b">run_app</code>函数添加到 lib.rs，如下所示:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="18be" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">🔬那么我们这里有什么？</p><ul class=""><li id="75fb" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><strong class="kd ip">第 1 行</strong>:使用<code class="fe kz la lb lc b">wasm_bindgen</code>宏，我们将<code class="fe kz la lb lc b">run_app</code>函数暴露给 JavaScript。</li><li id="1a9f" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 3 行</strong>:我们初始化<code class="fe kz la lb lc b">wasm_logger</code>板条箱。使用<code class="fe kz la lb lc b">wasm_logger</code>和<code class="fe kz la lb lc b">log</code>机箱，我们可以将调试日志写到浏览器的控制台。</li><li id="9839" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 4 行</strong>:我们将主组件(在上一步中定义)传递给<code class="fe kz la lb lc b">yew</code>的<code class="fe kz la lb lc b">start_app</code>方法，正如你可能已经猜到的那样，启动应用程序。</li></ul><p id="e629" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">有了合适的路由，让我们继续创建组件。</p><h1 id="1d9a" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">🪅 <strong class="ak"> ️Components —第一阶段</strong></h1><p id="e3a8" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">为了简单起见，我们的应用程序将由两个组件组成:</p><ul class=""><li id="e7c8" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><strong class="kd ip">登录</strong> —一个简单的功能组件，用于获取用户名并连接到 WebSockets 服务器。</li><li id="e392" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">聊天</strong>——该应用的主要组件——显示聊天窗口，以及一个向聊天内容写入内容的文本区域。</li></ul><p id="6c50" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">当用户浏览到<strong class="kd ip">登录</strong>组件时，他们将输入一个用户名并点击连接——然后该用户名需要传递到<strong class="kd ip">聊天</strong>组件并在那里用于连接到 WebSocket 服务器。为了实现这一点，我们将使用一个<strong class="kd ip">上下文</strong>(将其视为应用程序的全局状态)，它将保存任何组件要使用的用户名。我们定义上下文的方式如下:</p><ol class=""><li id="c6ad" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">为上下文定义一个<code class="fe kz la lb lc b">struct</code>并为其定义一个<code class="fe kz la lb lc b">type</code>别名:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="b04a" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">2.在<code class="fe kz la lb lc b">main</code>组件中，使用<code class="fe kz la lb lc b">use_state</code>钩子定义一个上下文:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="ea93" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.最后，让我们通过用一个<code class="fe kz la lb lc b">ContextProvider</code>元素包装主组件 HTML 来使用上下文，这使得子元素能够实际使用这个上下文。</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="dc77" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">一个<code class="fe kz la lb lc b">ContextProvider</code>元素需要一个上下文结构(<code class="fe kz la lb lc b">User</code>)和一个上下文对象(<code class="fe kz la lb lc b">ctx</code>)，这是使用元素的<code class="fe kz la lb lc b">context</code>属性设置的。</p><blockquote class="lk ll lm"><p id="4011" class="kb kc ld kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky ih bi translated"><em class="io">👁️ </em>注意:每当上下文改变时，ContextProvider 的子元素将重新呈现。</p></blockquote><p id="7598" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">有了上下文，让我们构建<strong class="kd ip">登录</strong>组件！</p><ol class=""><li id="d3f8" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">在<strong class="kd ip">组件/登录. rs </strong>中添加<strong class="kd ip">登录</strong>功能组件:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="bdab" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">2.声明一个<code class="fe kz la lb lc b">use_state</code>钩子来管理用户输入的用户名的状态。当声明一个<code class="fe kz la lb lc b">use_state</code>钩子时，我们提供默认值(在我们的例子中是一个空的<code class="fe kz la lb lc b">String</code>)，类似于 React 的<code class="fe kz la lb lc b">use_state</code>钩子:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="10ce" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.要获得对上下文的引用(您可能还记得，它将保存用户名的全局状态)，请使用<code class="fe kz la lb lc b">use_context</code>钩子:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="f285" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">4.登录组件 UI 将包含一个输入元素和一个按钮。每当输入改变时，我们需要更新本地<code class="fe kz la lb lc b">username</code>变量。为了连接 UI 元素和<code class="fe kz la lb lc b">username</code>，我们使用了一个<code class="fe kz la lb lc b">callback</code>:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="723b" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">🔬那么我们这里有什么？</p><ul class=""><li id="3778" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><strong class="kd ip">第 7 行</strong>:我们克隆了用户名状态处理程序，这样我们以后可以使用它的<code class="fe kz la lb lc b">set</code>方法更新它。</li><li id="1d69" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">第 9 行:我们从 input 元素的<code class="fe kz la lb lc b">onchange</code>事件中创建一个回调。</li><li id="3b30" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 10 行</strong>:我们使用<code class="fe kz la lb lc b">InputEvent</code>的<code class="fe kz la lb lc b">target_unchecked_into</code>方法获取目标元素(触发事件的元素)。</li><li id="5df3" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 11 行</strong>:我们使用元素的<code class="fe kz la lb lc b">value</code>方法，用<code class="fe kz la lb lc b">input</code>元素当前保存的新值更新<code class="fe kz la lb lc b">username</code>状态。</li></ul><blockquote class="lk ll lm"><p id="409a" class="kb kc ld kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky ih bi translated"><em class="io">🎉如果你曾经做过 HTML 元素的 JavaScript 工作，那么所有这些应该看起来非常相似。</em></p></blockquote><p id="ebc0" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">5.我们需要创建的下一个回调是针对提交按钮的。一旦输入了用户名，并且用户单击了提交按钮，我们需要将用户名保存到全局上下文中，以便其他组件在需要时可以使用它。如下创建<code class="fe kz la lb lc b">onclick</code>回调:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="5ce2" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">6.最后，让我们使用<code class="fe kz la lb lc b">html!</code>宏为这个组件添加实际的 UI:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="03fc" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">👀一些标注:</p><ul class=""><li id="e6ac" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><code class="fe kz la lb lc b">input</code>元素注册到<code class="fe kz la lb lc b">oninput</code>回调中。每次输入改变时，我们调用<code class="fe kz la lb lc b">oninput</code>并更新<code class="fe kz la lb lc b">username</code>状态。</li><li id="8681" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">我们使用<code class="fe kz la lb lc b">yew_router</code>箱中的<code class="fe kz la lb lc b">Link</code>元素，通过<code class="fe kz la lb lc b">to</code>属性将浏览器路由到<code class="fe kz la lb lc b">Chat</code>路径。</li><li id="054e" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><code class="fe kz la lb lc b">Link</code>元素包含一个<code class="fe kz la lb lc b">button</code>元素，它注册到<code class="fe kz la lb lc b">onclick</code>回调函数，后者用<code class="fe kz la lb lc b">username</code>的值更新全局上下文。除此之外，该按钮还设置了<code class="fe kz la lb lc b">disabled</code>属性以防止用户点击它，除非<code class="fe kz la lb lc b">username</code>的长度为 2 个字符或更多。</li></ul><p id="717b" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这就是登录组件的包装🎊。我们现在有了一个使用上下文的组件，以便与其他组件共享其数据(在我们的例子中是用户名)。</p><p id="6ead" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在我们可能很想跑过去创建聊天组件，但是让我们停下来想一想聊天组件是如何工作的…</p><h1 id="13a8" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">👋你好网络插座！</h1><p id="4a04" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">我们聊天应用程序的核心是 WebSockets。WebSockets 使我们能够在服务器和客户端之间异步发送和接收消息，而不需要客户端不断轮询。这个特性使得 Websockets 成为我们聊天应用的完美核心。让我们继续创建一个 WebSocket 服务，它将处理我们的应用程序中使用 WebSockets 的所有方面！</p><ol class=""><li id="555f" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">在<strong class="kd ip"> src </strong>文件夹下创建一个名为<strong class="kd ip"> services </strong>的新文件夹。</li><li id="227d" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">在<strong class="kd ip">服务</strong>中添加一个名为<strong class="kd ip"> mod.rs </strong>的新文件，内容如下:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="d059" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.我们的 Websocket 服务将处理以下内容:</p><ul class=""><li id="d8b8" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated">侦听来自 WebSocket 服务器的传入消息。</li><li id="d218" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">将消息写入 WebSocket 服务器。</li><li id="5e37" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">使用 MPSC(多生产商单消费者)通道与其他组件通信(稍后将有更多内容🤔)</li></ul><p id="b685" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">在<strong class="kd ip">服务</strong>文件夹中添加一个名为<strong class="kd ip"> websocket.rs </strong>的新文件，内容如下:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="2df2" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">😱OMG 这里发生了很多事情，让我们来看看整个事情:</p><ul class=""><li id="647a" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><strong class="kd ip">第 6–8 行:</strong>创建保存类型<code class="fe kz la lb lc b">Sender</code>的单个属性的<code class="fe kz la lb lc b">WebsocketService</code>结构。<code class="fe kz la lb lc b">Sender</code>允许我们按照消息发送的顺序，在接收方稍后将接收的通道上异步发送消息。<code class="fe kz la lb lc b">Sender</code>是可克隆的，这意味着每个使用该服务的组件都可以克隆它，并用它将消息发送回接收方，顾名思义——只能有一个。</li><li id="ac00" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 11–46 行</strong>:<code class="fe kz la lb lc b">new</code>函数初始化服务，类似于其他语言中的构造函数。该函数执行以下操作:<br/> -连接到 WebSocket 服务器(第 12 行)<br/> -创建 MPSC 通道(第 16 行)<br/> -在当前线程上生成一个新的 future(异步任务)，该线程将侦听 MPSC 通道的接收端，并将收到的消息写入 WebSocket 服务器。这就是组件与我们的服务通信的方式——通过通道发送消息(第 18–23 行)。<br/>——在当前线程上产生另一个新的 future 来监听来自 WebSocket 服务器的传入消息并将其注销(第 25–43 行)。<br/> -最后，该函数返回一个保存通道发送器(<code class="fe kz la lb lc b">in_tx</code>)的<code class="fe kz la lb lc b">WebSocketService</code> ( <code class="fe kz la lb lc b">Self</code>)实例。</li></ul><p id="15e1" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这里有一个方便的图表，直观地展示了所有事物之间的联系:</p><figure class="lf lg lh li gu jp gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/a5b5bf8117286e88566c75ef00253b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*NrZlkCpS7Wj8Oiehxur4ig.png"/></div></figure><p id="2b06" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">太棒了，有了 WebSocket 服务，让我们继续创建实际的聊天组件吧！</p><h1 id="a725" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">🪅 ️Components —第二阶段</h1><p id="880b" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">对于我们的聊天组件，我们将使用一个常规的(不是 T4)组件，因为我们将充分利用它不同的生命周期方法。</p><ol class=""><li id="a2c8" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">打开<strong class="kd ip"> chat.rs </strong>并添加以下内容:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="aac4" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">👀一些标注:</p><ul class=""><li id="60df" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><code class="fe kz la lb lc b">Msg</code> enum 保存我们的组件可以接收的可能消息(读取动作)。Chat 有两个基本功能:要么它处理从 WebSocket 服务器收到的消息(<code class="fe kz la lb lc b">HandleMsg</code>)，要么它向服务器提交消息(<code class="fe kz la lb lc b">SubmitMessage</code> ) —例如当用户在聊天中键入一些内容时。</li><li id="18dd" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><code class="fe kz la lb lc b">MessageData</code>表示聊天消息，包含消息来自谁以及实际消息是什么。</li><li id="4250" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">enum 保存了组件可以发送或接收的不同类型的消息。</li><li id="fb99" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">最后，<code class="fe kz la lb lc b">WebSocketMessage</code>表示发送给 WebSocket 服务器的消息的样子:它有一个类型(<code class="fe kz la lb lc b">message_type</code>)，然后是一个字符串数组(比如在聊天用户列表的情况下)或单个字符串(比如向服务器发送聊天消息的情况下)。</li></ul><p id="5b51" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">2.接下来，让我们添加聊天组件本身:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="be3e" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">聊天组件包含用户列表(<code class="fe kz la lb lc b">users</code>)、键入到文本框中的输入(<code class="fe kz la lb lc b">chat_input</code>)、对 Websocket 服务的引用(<code class="fe kz la lb lc b">wss</code>)，最后是键入到聊天中的所有消息的数组(<code class="fe kz la lb lc b">messages</code>)。</p><p id="0e4c" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.我们添加的第一个组件生命周期方法是<code class="fe kz la lb lc b">create</code>方法。<code class="fe kz la lb lc b">create</code>初始化组件状态，它的<code class="fe kz la lb lc b">ComponentLink</code>:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="393d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">👀这里发生了相当多的事情，让我们来分解一下:</p><ul class=""><li id="122f" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated">我们获取保存在<code class="fe kz la lb lc b">Context</code>(第 4-7 行)中的<code class="fe kz la lb lc b">user</code>(属于<code class="fe kz la lb lc b">type Rc&lt;UserInner&gt;</code>)对象，然后克隆它的<code class="fe kz la lb lc b">username</code>字段(第 9 行)，这是用户用来登录的实际用户名。</li><li id="6f10" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">我们创建一个新的 WebSocket 消息，向 WebSocket 服务器注册当前客户端(第 11–15 行)。接下来，我们使用<code class="fe kz la lb lc b">WebSocketService</code>的通道发送器(<code class="fe kz la lb lc b">tx</code>)将它发送到 WebSocket 服务器(第 17–23 行)。如果一切顺利，我们将向控制台记录一条消息(第 22 行)。</li><li id="4a05" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">我们通过发送一个新的<code class="fe kz la lb lc b">Chat</code>实例来结束这个方法(第 25–30 行)。</li></ul><p id="aefc" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">4.接下来，我们添加 view 方法，它负责呈现组件:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="564f" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这是一个很长的方法😅这里的大部分内容只是 HTML 和样式，所以我们不会深究，但这里有一些有趣的提示:</p><ul class=""><li id="50cf" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated">在第 4 行，我们创建了一个类型为<code class="fe kz la lb lc b">MouseEvent</code>的<code class="fe kz la lb lc b">callback</code>，在点击提交按钮时使用。每当点击按钮时，<code class="fe kz la lb lc b">callback</code>将发送类型为<code class="fe kz la lb lc b">SubmitMessage</code> <em class="ld"> </em>的消息。该消息将由<code class="fe kz la lb lc b">update</code>生命周期方法处理。</li><li id="cb20" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">在第 10 行，我们通过使用<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">collect</code>来迭代<code class="fe kz la lb lc b">users</code>字段，以呈现当前连接的用户列表(每个用户都呈现在其自己的<code class="fe kz la lb lc b">div</code>元素中)。</li><li id="76e0" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">在第 33 行，我们迭代了<code class="fe kz la lb lc b">messages</code>字段，类似于我们之前对<code class="fe kz la lb lc b">users</code>所做的。</li><li id="9039" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">我们在<code class="fe kz la lb lc b">input</code>元素(第 57 行)上使用了<code class="fe kz la lb lc b">ref</code>属性，这样我们就可以在<code class="fe kz la lb lc b">view</code>生命周期方法之外引用它(即读取它的值)。</li><li id="408a" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">我们设置提交按钮的<code class="fe kz la lb lc b">onclick</code>属性(第 58 行)来提交第 4 行定义的回调。</li></ul><p id="815e" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">5.我们终于准备好第一次运行这个项目，看看我们到目前为止取得了什么成果！在项目根文件夹中运行<code class="fe kz la lb lc b">npm start</code>。这将启动将我们的应用程序编译成 WASM、优化它、构建 HTML(使用 Webpack)以及最终运行开发服务器的过程。</p><p id="59f8" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">如果一切顺利，您应该会看到一个登录页面，您可以在其中输入用户名。完成后，主聊天屏幕出现，让我们检查开发工具控制台:</p><figure class="lf lg lh li gu jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj nx"><img src="../Images/66b6ed4d26fdb8da19762cc032515f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoF7BoLa-6R4DMX1Mm6VJg.png"/></div></div></figure><p id="20b5" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">几乎立即出现了三行字:</p><ul class=""><li id="b9a7" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated">我们成功地从聊天组件向 WebSocket 服务器发送了一条 WebSocket 消息(第一个调试行)</li><li id="0ce4" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">WebSocket 服务将用户名发送到 WebSocket 服务器</li><li id="8143" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">WebSocket 服务器返回了一个类型为<code class="fe kz la lb lc b">users</code>的消息，其中包含一个包含已连接用户名称的数组。</li></ul><p id="b9ec" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这就引出了一个问题:如果我们的 WebSocket 服务收到了所有连接用户的消息——为什么我们在 UI 上看不到呢？我们的聊天组件到底收到消息了吗？</p><p id="9fe4" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">眼尖的读者可能会注意到，当我们之前讨论 WebSocket 服务时。我们只讨论了组件如何向服务发送消息，但是没有提到服务如何向组件发回消息。让我们再深入一下我们的 WebSocket 服务……</p><h1 id="44e3" class="lq lr io bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">🔌WebSockets —第二阶段</h1><p id="68d6" class="pw-post-body-paragraph kb kc io kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky ih bi translated">我们目前使用 MPSC 通道在组件和 WebSocket 服务之间进行通信，但是顾名思义，我们不能使用相同的方法来更新组件，因为我们需要相反的方向，即多消费者(组件)单生产者(服务)，这是不存在的。</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="ny nu l"/></div></figure><p id="5d08" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">我们用紫杉药剂！代理可以用来“独立于组件层次结构中的位置在组件之间路由消息”(摘自 Yew 的官方文档)。这意味着我们可以使用代理的调度程序将消息从 WebSocket 服务发送到任何监听组件。让我们创建一个事件总线服务，我们将使用它来发送这些消息。</p><p id="49eb" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">在 services 下创建一个名为<strong class="kd ip"> event_bus.rs </strong>的新文件，并将以下内容粘贴到其中:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="d366" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">🔬那么我们这里有什么？</p><ul class=""><li id="cc38" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky nv mz na nb bi translated"><strong class="kd ip">第 10–13 行</strong>:我们创建了<code class="fe kz la lb lc b">EventBus</code>结构，它保存了一个链接和一个订户列表。</li><li id="4d85" class="mt mu io kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated"><strong class="kd ip">第 15–47 行</strong>:我们为<code class="fe kz la lb lc b">EventBus.</code>实现了<code class="fe kz la lb lc b">Agent</code>特征。我们需要实现很多方法(<code class="fe kz la lb lc b">connected</code>、<code class="fe kz la lb lc b">disconnected</code>等)，但我们最关心的是<code class="fe kz la lb lc b">handle_input</code>，它遍历所有订阅者，并使用<code class="fe kz la lb lc b">link</code>向他们发送消息内容。</li></ul><p id="9c90" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在让我们回到 WebSocket 服务，使用新的事件总线:</p><ol class=""><li id="6114" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">打开服务文件夹下的<strong class="kd ip"> websocket.rs </strong>。添加所需的<code class="fe kz la lb lc b">use</code>语句和<code class="fe kz la lb lc b">event_bus</code>初始化。我们正在创建一个<code class="fe kz la lb lc b">dispatcher</code>,因为我们需要服务和组件之间的单向通信通道:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="013d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">2.要在信道上发送消息，我们只需使用<code class="fe kz la lb lc b">send</code>:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="6d57" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">你可以看到我们正在利用我们在<strong class="kd ip"> event_bus.rs </strong>中定义的<code class="fe kz la lb lc b">EventBusMsg</code>结构来沿着通道发送一条<code class="fe kz la lb lc b">String</code>消息(第 9 行和第 15 行)。</p><p id="e75f" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">最后，我们需要将事件总线添加到聊天组件中。</p><ol class=""><li id="89c4" class="mt mu io kd b ke kf ki kj km nq kq nr ku ns ky my mz na nb bi translated">打开<strong class="kd ip">组件</strong>文件夹下的<strong class="kd ip"> chat.rs </strong>，将<code class="fe kz la lb lc b">_producer</code>添加到聊天结构中:</li></ol><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="ad06" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">2.转到<code class="fe kz la lb lc b">Chat</code>的<code class="fe kz la lb lc b">create</code>生命周期方法，将<code class="fe kz la lb lc b">_producer</code>的默认值添加到返回的<code class="fe kz la lb lc b">Self</code>语句中:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="28b7" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">如果你现在再次运行应用程序，你会发现没有什么真正的变化。原因是我们从未实现过<code class="fe kz la lb lc b">update</code>生命周期方法，该方法负责处理组件获得的不同消息(如<code class="fe kz la lb lc b">HandleMsg</code>或<code class="fe kz la lb lc b">SubmitMessage</code>)。该方法返回一个布尔值，指示是否应重新呈现组件。</p><p id="ab66" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">3.在<code class="fe kz la lb lc b">create</code>方法下，添加以下<code class="fe kz la lb lc b">update</code>的实现:</p><figure class="lf lg lh li gu jp"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="dd57" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">🔬那么我们这里有什么？</p><p id="95c0" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">该方法将<code class="fe kz la lb lc b">msg</code>匹配到组件可能获得的两个消息之一:<code class="fe kz la lb lc b">HandleMsg</code>或<code class="fe kz la lb lc b">SubmitMessage</code>。如果消息是类型<code class="fe kz la lb lc b">HandleMsg</code>的，我们执行另一个匹配并检查它是类型<code class="fe kz la lb lc b">Users</code>还是类型<code class="fe kz la lb lc b">Message</code>的消息。每当连接的用户列表发生变化(用户连接/断开连接)时，就会发送类型为<code class="fe kz la lb lc b">Users</code>的消息，在收到该消息时，我们会用每个连接的用户的姓名和头像填充<code class="fe kz la lb lc b">users</code>数组。当用户在聊天中发布消息时，类型为<code class="fe kz la lb lc b">Message</code>的消息被发送，与我们处理<code class="fe kz la lb lc b">users</code>的方式非常相似，我们将新消息添加到<code class="fe kz la lb lc b">messages</code>数组中。在这两种情况下，我们都返回<code class="fe kz la lb lc b">true</code>,因为我们需要组件用新数据重新呈现自己。</p><p id="914c" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">在消息类型为<code class="fe kz la lb lc b">SubmitMessage</code>的情况下，我们从<code class="fe kz la lb lc b">input</code> HTML 元素中获取消息文本(还记得我们之前设置的<code class="fe kz la lb lc b">ref</code>属性吗？)并使用 WebSocket 服务通道发送器(tx)将消息发送到 WebSocket 服务器。在<code class="fe kz la lb lc b">SubmitMessage</code>的情况下，我们返回<code class="fe kz la lb lc b">false</code>，因为我们不需要组件自己重新呈现。</p><p id="d201" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">随着这一变化，我们的应用程序现在已经准备好黄金时间！</p><figure class="lf lg lh li gu jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj nz"><img src="../Images/7d0ff207dcc9a58e08aa280af998d915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTmruZMoiZUJw43JH9I4GA.png"/></div></div></figure></div><div class="ab cl oa ob hs oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ih ii ij ik il"><p id="236d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这篇文章肯定比较长，但我希望你能体验到在构建 web 应用程序时与 Yew 一起工作的感觉。你可以在 https://github.com/jtordgeman/YewChat 找到完整的源代码。欢迎在 Twitter 上给我打电话或者在这里留言——我保证我会很好地回答；p</p><p id="4fdb" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">最后但同样重要的是，非常感谢<a class="oh oi ep" href="https://medium.com/u/9caa2c6ac2a4?source=post_page-----60720367399f--------------------------------" rel="noopener" target="_blank">萨拉·卢梅尔斯基</a>校对并纠正了我愚蠢的拼写错误！:)</p></div></div>    
</body>
</html>