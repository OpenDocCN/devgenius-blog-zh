<html>
<head>
<title>Effective Windows Forms Development Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的Windows窗体开发技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/effective-windows-forms-development-tips-ed0a27d887c2?source=collection_archive---------14-----------------------#2021-05-07">https://blog.devgenius.io/effective-windows-forms-development-tips-ed0a27d887c2?source=collection_archive---------14-----------------------#2021-05-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1267" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对于图形和多线程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b6e3897cfe1f8715e01937f30928c49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkaIjyBD1Q6uE8V2-l1rFA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://www.pexels.com/photo/mosaic-alien-on-wall-1670977/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/mosaic-alien-on-wall-1670977/</a></figcaption></figure><p id="68ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">W</span>indows Forms【WF】卷土重来。NET Core显著的性能提升，在本文中，我们将介绍一些在开发WF应用程序时需要牢记的技巧和技术。首先，我们将介绍实例检测，然后使用内置的<em class="ly">背景工作器</em>，最后我们将学习如何在我们的WF中绘制、无效和模拟一个游戏循环，而没有烦人的闪烁。</p><p id="f7a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated">过去，许多开发人员更喜欢与WF合作的原因之一是，他们可以轻而易举地原型化和构建一套良好的功能。这是通过可重写事件、控件和编辑器的组合来实现的。</p><p id="f2e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated">让我们从一个小小的误称开始:检测一个应用程序运行的多个实例，而不是检测单个应用程序中打开的一个表单的多个实例。后者可以通过查询<em class="ly">应用来实现。例如，当试图判断应用程序实例是否已经在运行时，一个简单的解决方案是查询当前进程并与活动进程进行比较。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c0ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> R </span>使用内置<a class="ae ks" href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.backgroundworker?view=net-5.0" rel="noopener ugc nofollow" target="_blank">后台工作器</a>运行长时间操作。该类提供了一个用于执行长时间运行操作的专用线程和一组事件，以便对操作的不同阶段进行粒度控制。下面几行说明了如何设置一个<a class="ae ks" href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.backgroundworker?view=net-5.0" rel="noopener ugc nofollow" target="_blank"> BackgroundWorker </a>的实例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c278" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> W </span>当使用<em class="ly"> BackgroundWorker </em>或多线程时，对于某些控件更新，正在运行的线程很可能不会与UI线程同步(RunWorkerCompleted确实会同步，但DoWork内的UI更新会导致InvokeRequired标志被设置为true)。框架处理这种情况的方式是在从控件基类派生的任何东西上翻转InvokeRequired标志。有了这些知识，我们可以编写一个简单的扩展来简化UI更新的执行，而不必担心线程的同步。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2c40" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">任何UI控件都可以使用下面的语法调用这个扩展。thread safe update(()=&gt;textbox 1。Text =日期时间。utc now . ToLongTimeString())；</p><p id="4bb8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> W </span> F并不特别适合制作视频游戏，因为绘制操作使用较慢的GDI+API，并且框架提供的开箱即用定时器不是高分辨率定时器。借鉴WF仍然是一个有趣的活动，有一些技巧(很容易快速完成)，甚至创造一些事件驱动的游戏，如扫雷或棋盘游戏，如国际象棋。在定时器上渲染或调用Invalidate()进行即时重绘时，需要注意的一点是，必须使用VSync或帧速率与显示器刷新率同步，以避免闪烁或屏幕撕裂。将DoubleBuffered属性设置为true可以避免闪烁。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d16a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着我们的闪烁问题的解决，让我们使用系统创建一个小的游戏循环。计时器。计时器代替了表格计时器，以获得更好的准确性和控制。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f5e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里需要注意的一点是，在整个窗体区域的不同位置将绘制一个矩形，但是为了维护所有以前的矩形，需要将这些矩形添加到一个集合中，并在一个循环中绘制。</p></div></div>    
</body>
</html>