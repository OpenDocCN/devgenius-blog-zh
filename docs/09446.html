<html>
<head>
<title>Enums in PostgreSQL &amp; When to use them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 中的枚举&amp;何时使用它们</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/enums-in-postgresql-when-to-use-them-abb7559156ee?source=collection_archive---------7-----------------------#2022-08-21">https://blog.devgenius.io/enums-in-postgresql-when-to-use-them-abb7559156ee?source=collection_archive---------7-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/52c2c28a9ac61835ec6f6ba8b0957eda.png" data-original-src="https://miro.medium.com/v2/format:webp/0*cQ2UpOz7IqRRihWM.png"/></div></figure><p id="1de4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有没有遇到过这样的情况，您需要在表的某一列中有有限的特定值？我也遇到过类似的情况。我需要跟踪一些进程的状态。以下是可能的解决方案:</p><h1 id="1cc4" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">解决方案</h1><ol class=""><li id="e1f5" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko lu lv lw lx bi translated">如果您真的不在乎或者真的很急，您可以创建一个文本列，并确保每个人都用固定的、预先指定的值插入/更新该列。</li><li id="78ee" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">如果您真的关心一致性，您可以创建一个外键表来存储所有这些数据，并使用外键来引用它。这是一个更好的解决方案。但是对于不经常更新的静态值来说，还有更好的方法。</li><li id="b209" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">您可以使用自定义枚举类型。这就像创建一个包含常量的外来表，但是没有这些麻烦要好得多。</li></ol><h1 id="a20c" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">那么什么是枚举呢？</h1><blockquote class="md"><p id="2523" class="me mf in bd mg mh mi mj mk ml mm ko dk translated">枚举(enum)类型是包含一组静态有序值的数据类型。它们相当于许多编程语言中支持的枚举类型。枚举类型的一个例子可能是一周中的几天，或者一段数据的一组状态值。</p></blockquote><p id="6089" class="pw-post-body-paragraph jr js in jt b ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko ig bi translated">在这篇博客中，我们将讨论如何在 PostgreSQL 中创建和使用枚举</p><h1 id="98db" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.创建自定义枚举类型</h1><p id="8584" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">在这个特定的例子中，我们将创建一个 enum 来跟踪任何进程的状态。</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mw"><img src="../Images/68f812ded6a323eb9450f76817423169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4XICpzgPdwo5pF8F044fQ.png"/></div></div></figure><p id="fa6e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将在公共模式中创建一个名为 status 的新类型，现在您可以在创建列时使用它作为您的数据类型。</p><h1 id="68cc" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.创建使用该枚举的表</h1><p id="9658" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">接下来，让我们创建一个表，通过使用 enum 作为其中一个列的类型来跟踪不同流程的状态。</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nf"><img src="../Images/18fffd6b12b09a31bfcb7ffbdf95915b.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*BpbZjZyMi1VW3hmO82i3YA.png"/></div></div></figure><h1 id="9fc2" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.将数据插入 process_tracker</h1><figure class="mx my mz na gt jn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e405935700943aba2399056f6b0eb397.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*Rf_fomQoa70KwtQLUsQnRA.png"/></div></figure><p id="3003" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">表格:</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3c0f66b93be740a54369b4c66f1ab9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*njEGWJfVTmKIW3L6hSnkZA.png"/></div></figure><h1 id="92a1" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.使用错误的值插入/更新 process_status？</h1><p id="33f6" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">现在，如果您尝试用不正确的值更新/插入 process_status 列，您将会得到一个错误。</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6abbbbe12c3025a91ba646579aef38b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*2u3nLpO0OoK6F0IbPTtSZw.png"/></div></figure><blockquote class="md"><p id="c364" class="me mf in bd mg mh nj nk nl nm nn ko dk translated"><em class="mn">永远不要选择犯错，而只是努力避免犯错，这总是好的。使用 enums 可以做到这一点，而不必创建不同的表和外键约束。</em></p></blockquote><h1 id="b20e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la no lc ld le np lg lh li nq lk ll lm bi translated">5.改变枚举类型值</h1><p id="4178" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">使用枚举的另一个好处是，如果您想要更改枚举值，您可以更改名称，它们将自动反映在使用该值的所有记录中。</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2ceba5648088bde002b9cc21c592a5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*kANCQkX-2SraWTJAHL5rcw.png"/></div></figure><p id="0b38" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，该表将看起来像这样</p><figure class="mx my mz na gt jn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d4cedb7b6f3ff4c1b849faa1f367d7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*VTx1VoO28_n5TtacwNkSlQ.png"/></div></figure><h1 id="e15c" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论:</h1><p id="95ea" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">因此，不要对具有选项/选择值的列使用文本字段。如果它们是动态的，并且不断变化，或者您只有一个很长的选择列表，那么一个外国表就是一条路要走。但是如果表中某一列的值是有限的，并且不会改变，那么就使用枚举。</p><h1 id="5501" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><ul class=""><li id="60b4" class="ln lo in jt b ju lp jy lq kc lr kg ls kk lt ko nt lv lw lx bi translated"><a class="ae nu" href="https://www.postgresql.org/docs/current/datatype-enum.html" rel="noopener ugc nofollow" target="_blank"> Postgresql 枚举文档</a></li><li id="654d" class="ln lo in jt b ju ly jy lz kc ma kg mb kk mc ko nt lv lw lx bi translated"><a class="ae nu" href="https://www.postgresql.org/docs/current/sql-altertype.html" rel="noopener ugc nofollow" target="_blank">关于变更类型的更多信息</a></li></ul></div></div>    
</body>
</html>