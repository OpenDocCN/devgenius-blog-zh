<html>
<head>
<title>Buffer overflow tutorial (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出教程(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/buffer-overflow-tutorial-part1-efc6b9f3e4ee?source=collection_archive---------1-----------------------#2020-07-07">https://blog.devgenius.io/buffer-overflow-tutorial-part1-efc6b9f3e4ee?source=collection_archive---------1-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ecf2131d8ac4251c66c30c182e90282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ehi3odcfj8oWTXpR9fPmg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安加德·辛格·www.officialhacker.com</figcaption></figure><p id="fdc8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缓冲区是存储信息的临时区域。当程序或框架进程放入更多的信息时，额外的信息就会泛滥。它使一部分信息泄漏到不同的缓冲区，这些缓冲区可能会退化或覆盖它们保存的任何信息。在缓冲区溢出攻击中，附加信息有时包含黑客或恶意用户提议的活动的明确准则；例如，数据可能引发损害文档、更改信息或泄露私人数据的反应。</p><p id="ac3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缓冲区溢出很可能是最常见的软件安全漏洞。大多数编程设计者都意识到缓冲区溢出漏洞是什么，但是针对继承和最近创建的应用程序的缓冲区溢出攻击仍然无处不在。这个问题的一部分是因为缓冲区溢出可能发生的方式多种多样，另一部分是因为经常用来防止缓冲区溢出的容易出错的技术。很难发现缓冲区溢出，尽管如此，当您检测到一个缓冲区溢出时，通常很难利用它。尽管如此，攻击者已经找到了如何在数量惊人的产品和组件中识别缓冲区溢出的方法。</p><h1 id="9c72" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1 — <strong class="ak">理解记忆</strong></h1><p id="4c6a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">为了完全理解缓冲区溢出攻击是如何工作的，我们必须理解信息内存在一个进程中是如何组织的。当程序运行时，它需要内存空间来存储信息。假设主机框架利用虚拟存储器组件，进程虚拟地址空间分成至少三个存储器部分。</p><p id="5aa9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.<em class="md">【文本】</em>段，是内存的只读部分，用于在运行时保持程序的代码。</p><p id="a9ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.<em class="md">“数据”</em>段，这是一个进程可以额外写入信息的不同内存位置。如果信息访问这个区域，数据段将被放在一个比文本段交替的内存页上。</p><p id="2d35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.最后是<em class="md"> "Stack" </em>部分，它是赋予操作框架的内存的一部分。它用于存储函数内部定义的局部变量或与系统调用相关的信息。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/701dad3030bac3da477196bed39f30c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7tzDCjg_zE2RiRKGD0RGA.jpeg"/></div></div></figure><p id="b41e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将最初的两个内存部分分开，我们将讨论堆栈，因为它是发生缓冲区溢出的地方。</p><p id="9823" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如前所述，名为<em class="md">“Stack”</em>的内存是程序存储其参数、局部变量和一些控制程序执行流的信息的地方。在 PC 体系结构中，存储在堆栈中的每个数据都调整为 4 字节长的倍数。在 Intel 32 位架构上，四字节长的信息被称为<em class="md">【双字】</em>或<em class="md">【dword】</em>Linux 操作框架上的栈从高内存地址开始，发展到低内存地址。此外，英特尔 x86 上的内存遵循 little-endian 惯例，因此最低有效字节值存储在低内存地址，其他字节按照重要性递增的顺序存储。我们可以说，内存是由低内存地址到高内存地址组成的。</p><p id="fce5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="md">“堆栈”</em>据称是其名为后进先出(L.I.F.O)的库存策略的结果。这意味着最后一个存放在内存中的<em class="md">【dword】</em>将首先被检索。堆栈中允许的活动是 PUSH 和 POP。利用 PUSH 将一个<em class="md">【dword】</em>信息嵌入到<em class="md">【Stack】</em>中，POP 通过<em class="md">【Stack】检索最后一个<em class="md">【dword】</em>。</em>调用函数使用<em class="md">“堆栈”</em>为被调用函数传递参数。对于每个函数调用，制定一个<em class="md">【堆栈】</em>框架，以包含以下内容:</p><p id="b4e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.函数参数。</p><p id="bb42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.返回地址—用于存储函数返回后调用的下一条指令的内存地址。</p><p id="5348" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.帧指针——用于获取对当前<em class="md">“堆栈”</em>帧的引用，并授予它们进入局部变量和函数参数的权限。</p><p id="e557" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.和函数的局部变量。</p><p id="c416" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在 x86 位架构中，至少有三个进程注册表可能成为最关键的因素，其中包括<em class="md">“堆栈”</em>；那些是“EIP”、“EBP”、“T27”和“超感官知觉”“EIP”代表扩展指令指针，它是一个只读寄存器，它包含程序上要读取的后续指令的位置。它始终指向<em class="md">“程序代码”</em>内存部分。<em class="md">【EBP】</em>代表扩展基栈指针，其动机是指向<em class="md">栈的基位置</em>和<em class="md">“ESP”</em>代表扩展堆栈指针；该寄存器旨在告诉您在<em class="md">【堆栈】</em>中的位置。这意味着<em class="md">“ESP”</em>始终标记着<em class="md">堆栈的最高点</em></p><p id="87b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="md"/>《EBP》意义重大，因为它在记忆中给了一个停留点，我们可以有很多东西参照那个价值。当函数在程序内部被调用时，我们有几个参数发送给它，内存中的位置被<em class="md">【EBP】</em>连续引用，就像局部变量一样，如下图所示。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/934574cbbd7ac734ab0cbfcbdbc140c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnYFHqMrVxWExGC7LrOkxw.jpeg"/></div></div></figure><p id="d490" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们知道，内存是由低内存地址到高内存地址组成的。假设我们发送一个由 12 个<em class="md">“A”</em>字符组成的字符串。内存将如下图所示:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/f61c791aea811b90367633f48bb40356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SLeRQHYThU5lh0fTlJ5mQ.jpeg"/></div></div></figure><p id="155f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当分析此图像时，我们看到<em class="md"> "PARAM1" </em>指向保存在<em class="md">" Stack "</em>中的信息的位置，正如我们可能知道的那样<em class="md"> "ESP" </em>聚焦到堆栈的顶部，因此字符串从<em class="md"> "ADDR1" </em> 4 字节一个接一个地复制到更高的内存中，这是因为这是留在<em class="md"> "Stack 中的最佳方式。</em>万一该函数在将信息组合到<em class="md">【堆栈】</em>上之前没有控制缓冲区的长度，并且我们发送了大量的<em class="md">【A】</em>字符，我们可能会以如下图所示的情况结束。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/5c58688c98747c631fdcac94978cabd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hH7SjFzPv3-lnnOut9RhKw.jpeg"/></div></div></figure><p id="e8e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">万一<em class="md">“EIP”</em>寄存器被<em class="md">“A”</em>字符覆盖，此时，您修改地址以返回执行以下指令。当<em class="md">【EIP】</em>被<em class="md">【噪音】</em>覆盖时，你会得到一个豁免，程序会停止。</p><p id="cd3a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在接下来的部分中，我们将向您展示并解释如何执行缓冲区溢出攻击并危害目标计算机。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="9dcd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae mr" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part1-efc6b9f3e4ee" rel="noopener">缓冲区溢出教程(第一部分)</a></p><p id="b53e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae mr" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part2-c21c6de5c11c" rel="noopener">缓冲区溢出教程(第二部分)</a></p><p id="e9d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae mr" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part3-98ab394073e3" rel="noopener">缓冲区溢出教程(第三部分)</a></p><p id="941a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae mr" href="https://medium.com/dev-genius/buffer-overflow-tutorial-part4-1e80e90a2f03" rel="noopener">缓冲区溢出教程(第四部分)</a></p></div></div>    
</body>
</html>