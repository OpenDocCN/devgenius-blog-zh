<html>
<head>
<title>To Unmarshal() or To Decode()? JSON Processing in Go Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解组()还是解码()？解释了 Go 中的 JSON 处理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/to-unmarshal-or-to-decode-json-processing-in-go-explained-e92fab5b648f?source=collection_archive---------1-----------------------#2022-04-04">https://blog.devgenius.io/to-unmarshal-or-to-decode-json-processing-in-go-explained-e92fab5b648f?source=collection_archive---------1-----------------------#2022-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="27fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你像我一样，想学习后端开发，你可能曾经遇到过 JSON 处理。JSON 是一种非常流行的在前端和后端之间传输数据的格式。因为它是现代 web 开发中如此重要的特性，Go 在其<code class="fe ki kj kk kl b">encoding/json</code>包中添加了对 JSON 的支持。</p><p id="92e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是做事的方式并不只有一种。如果您过去看过一些教程，您可能已经注意到人们使用不同的函数来处理 JSON。有人用<code class="fe ki kj kk kl b">Marshal</code>和<code class="fe ki kj kk kl b">Unmarshal</code>，有人用<code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code>。你应该用什么？哪个更好？在这篇博文中，我将尝试解释这两种方法之间的区别，以及何时应该使用其中一种。尽情享受吧！</p><h1 id="5a22" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">但是首先，让我向您展示这两种方法。</h1><p id="d11d" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">有两种方法可以读写 JSON。这段代码片段将帮助您理解如何使用这两种方法。第一，<code class="fe ki kj kk kl b">Marshal</code>和<code class="fe ki kj kk kl b">Unmarshal</code>:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="4773" class="lx kn in kl b gy ly lz l ma mb">func PrettyPrint(v interface{}) (err error) {<br/>    b, err := json.MarshalIndent(v, "", "\t")<br/>    if err == nil {<br/>        fmt.Println(string(b))<br/>    }<br/>    return err<br/>}</span><span id="d12a" class="lx kn in kl b gy mc lz l ma mb">func TryMarshal() error {<br/>    data := map[string]interface{}{<br/>        "1": "one",<br/>        "2": "two",<br/>        "3": "three",<br/>    }<br/>    result, err := json.Marshal(&amp;data)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="7da9" class="lx kn in kl b gy mc lz l ma mb">    err = PrettyPrint(result)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="f63c" class="lx kn in kl b gy mc lz l ma mb">    return nil<br/>}</span><span id="7c87" class="lx kn in kl b gy mc lz l ma mb">func TryUnmarshal() error {<br/>    myFile, err := os.Open("test.csv")<br/>    if err != nil {<br/>        return err<br/>    }<br/>    defer myFile.Close()</span><span id="2e4c" class="lx kn in kl b gy mc lz l ma mb">    data, err := io.ReadAll(myFile)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="f9f2" class="lx kn in kl b gy mc lz l ma mb">    var result map[string]interface{}<br/>    json.Unmarshal([]byte(data), &amp;result)</span><span id="46db" class="lx kn in kl b gy mc lz l ma mb">    err = PrettyPrint(result)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="140c" class="lx kn in kl b gy mc lz l ma mb">    return nil<br/>}</span></pre><p id="5a8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">TryMarshal</code>中，我创建了一个<code class="fe ki kj kk kl b">map[string]interface{}</code>来保存一些数据。然后我传给了<code class="fe ki kj kk kl b">Marshal</code>。</p><p id="5a01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">TryUnmarshal</code>中，我读取了一个文件，并将其转换成字节片<code class="fe ki kj kk kl b">data</code>。该<code class="fe ki kj kk kl b">data</code>被传入<code class="fe ki kj kk kl b">Unmarshal</code>，后者将结果存储在一个<code class="fe ki kj kk kl b">map[string]interface{}</code>中。</p><p id="f30e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">PrettyPrint</code>只是格式化输出使其看起来更好。</p><p id="e000" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来看看<code class="fe ki kj kk kl b">Encoder.Encode</code>和<code class="fe ki kj kk kl b">Decoder.Decode</code>。</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="6ae7" class="lx kn in kl b gy ly lz l ma mb">func TryEncode() error {<br/>    data := map[string]interface{}{<br/>        "1": "one",<br/>        "2": "two",<br/>        "3": "three",<br/>    }<br/>    err := json.NewEncoder(os.Stdout).Encode(&amp;data)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="3711" class="lx kn in kl b gy mc lz l ma mb">    return nil<br/>}</span><span id="8019" class="lx kn in kl b gy mc lz l ma mb">func TryDecode(path string) error {<br/>    myFile, err := os.Open(path)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    defer myFile.Close()</span><span id="907e" class="lx kn in kl b gy mc lz l ma mb">    var result map[string]interface{}<br/>    json.NewDecoder(myFile).Decode(&amp;result)</span><span id="a3ba" class="lx kn in kl b gy mc lz l ma mb">    return nil<br/>}</span></pre><p id="ccac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码看起来与前面的例子非常相似。<code class="fe ki kj kk kl b">TryEncode</code>类似于<code class="fe ki kj kk kl b">TryMarhsal</code>,<code class="fe ki kj kk kl b">TryDecode</code>类似于<code class="fe ki kj kk kl b">TryUnmarshal</code>。这里唯一的区别是<code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code>是<code class="fe ki kj kk kl b">Encoder</code>和<code class="fe ki kj kk kl b">Decoder</code>类型的方法。</p><p id="1ce0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">NewEncoder</code>接受<code class="fe ki kj kk kl b">io.Writer</code>接口并返回一个新的<code class="fe ki kj kk kl b">Encoder</code>类型。<code class="fe ki kj kk kl b">NewDecoder</code>接受<code class="fe ki kj kk kl b">io.Reader</code>接口并返回一个新的<code class="fe ki kj kk kl b">Decoder</code>类型。对于这个例子，我为<code class="fe ki kj kk kl b">NewEncoder</code>传入了<code class="fe ki kj kk kl b">os.Stdout</code>，为<code class="fe ki kj kk kl b">NewDecoder</code>传入了<code class="fe ki kj kk kl b">myFile</code>(属于<code class="fe ki kj kk kl b">os.File</code>类型)。</p><p id="b12b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们知道了如何使用这些函数，我们就可以深入了解这两种方法的不同之处。</p><h1 id="bd10" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">封送()和解封送()</h1><p id="b3d8" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">让我们来看看它们的实现:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="063a" class="lx kn in kl b gy ly lz l ma mb">func Marshal(v any) ([]byte, error) {<br/>    e := newEncodeState()</span><span id="d47c" class="lx kn in kl b gy mc lz l ma mb">    err := e.marshal(v, encOpts{escapeHTML: true})<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    buf := append([]byte(nil), e.Bytes()...)</span><span id="ddb0" class="lx kn in kl b gy mc lz l ma mb">    encodeStatePool.Put(e)</span><span id="84d4" class="lx kn in kl b gy mc lz l ma mb">    return buf, nil<br/>}</span><span id="bddb" class="lx kn in kl b gy mc lz l ma mb">func Unmarshal(data []byte, v any) error {<br/>    var d decodeState<br/>    err := checkValid(data, &amp;d.scan)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="d8d8" class="lx kn in kl b gy mc lz l ma mb">    d.init(data)<br/>    return d.unmarshal(v)<br/>}</span></pre><p id="0209" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要知道的是:</p><ul class=""><li id="206e" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><code class="fe ki kj kk kl b">Marshal</code>接受任意值(<code class="fe ki kj kk kl b">any</code>是<code class="fe ki kj kk kl b">interface{}</code>的包装器)并将其转换成字节片。</li><li id="6a0f" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><code class="fe ki kj kk kl b">Unmarshal</code>获取一个字节片，对其进行解析，并将结果存储到<code class="fe ki kj kk kl b">v</code>。</li></ul><p id="1c2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，看看<code class="fe ki kj kk kl b">Marshal</code> <strong class="jm io">如何将所有的字节</strong>存储到一个字节片<code class="fe ki kj kk kl b">buf</code>中。这意味着<code class="fe ki kj kk kl b">Marshal</code> <strong class="jm io">需要在内存</strong>中保存所有数据才能工作。这可能会占用大量内存。<code class="fe ki kj kk kl b">Unmarshal</code>有类似的问题，因为它接受一个完整的字节片作为输入。</p><h1 id="65e9" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">NewEncoder()。Encode()和 NewDecoder()。解码()</h1><p id="ba27" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">下面是 Encode()和 Decode()的代码:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="e4b9" class="lx kn in kl b gy ly lz l ma mb">func (enc *Encoder) Encode(v any) error {<br/>    if enc.err != nil {<br/>        return enc.err<br/>    }<br/>    e := newEncodeState()<br/>    err := e.marshal(v, encOpts{escapeHTML: enc.escapeHTML})<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="d2ca" class="lx kn in kl b gy mc lz l ma mb">    e.WriteByte('\n')</span><span id="7bdc" class="lx kn in kl b gy mc lz l ma mb">    b := e.Bytes()<br/>    if enc.indentPrefix != "" || enc.indentValue != "" {<br/>        if enc.indentBuf == nil {<br/>            enc.indentBuf = new(bytes.Buffer)<br/>        }<br/>        enc.indentBuf.Reset()<br/>        err = Indent(enc.indentBuf, b, enc.indentPrefix, enc.indentValue)<br/>        if err != nil {<br/>            return err<br/>        }<br/>        b = enc.indentBuf.Bytes()<br/>    }<br/>    if _, err = enc.w.Write(b); err != nil {<br/>        enc.err = err<br/>    }<br/>    encodeStatePool.Put(e)<br/>    return err<br/>}</span><span id="9a34" class="lx kn in kl b gy mc lz l ma mb">func (dec *Decoder) Decode(v any) error {<br/>    if dec.err != nil {<br/>        return dec.err<br/>    }</span><span id="55f4" class="lx kn in kl b gy mc lz l ma mb">    if err := dec.tokenPrepareForDecode(); err != nil {<br/>        return err<br/>    }</span><span id="c342" class="lx kn in kl b gy mc lz l ma mb">    if !dec.tokenValueAllowed() {<br/>        return &amp;SyntaxError{msg: "not at beginning of value", Offset: dec.InputOffset()}<br/>    }</span><span id="9405" class="lx kn in kl b gy mc lz l ma mb">    n, err := dec.readValue()<br/>    if err != nil {<br/>        return err<br/>    }<br/>    dec.d.init(dec.buf[dec.scanp : dec.scanp+n])<br/>    dec.scanp += n</span><span id="1146" class="lx kn in kl b gy mc lz l ma mb">    err = dec.d.unmarshal(v)</span><span id="8b8d" class="lx kn in kl b gy mc lz l ma mb">    dec.tokenValueEnd()</span><span id="db64" class="lx kn in kl b gy mc lz l ma mb">    return err<br/>}</span></pre><p id="c94d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的代码比较长，但请记住以下几点:</p><ul class=""><li id="57cc" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code>是<code class="fe ki kj kk kl b">Encoder</code>和<code class="fe ki kj kk kl b">Decoder</code>类型的方法，它们是通用接口<code class="fe ki kj kk kl b">io.Writer</code>和<code class="fe ki kj kk kl b">io.Reader</code>的包装器。</li><li id="eeaf" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code> <strong class="jm io">流式传输数据，而不是一次存储所有数据</strong>。有一个缓冲区供<code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code>读写，直到所有数据处理完毕。</li></ul><h1 id="3775" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">好吧…那我应该用哪一个呢？</h1><p id="0208" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">好问题！我很想知道这两种方法之间的性能差异，所以我写了一个测试并对它们进行了基准测试。请注意，测试的任何打印都已被禁用。</p><p id="a203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个测试是为<code class="fe ki kj kk kl b">Unmarshal</code>和<code class="fe ki kj kk kl b">Decode</code>设计的，因为通常你不会自己写大量的 JSON 数据，但是从服务器接收大量的 JSON 数据是可能的。你仍然可以期待<code class="fe ki kj kk kl b">Marshal</code>和<code class="fe ki kj kk kl b">Encode</code>的类似结果，因为它们基本上是它们的伙伴函数的反序。</p><p id="f434" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是测试代码:</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="048b" class="lx kn in kl b gy ly lz l ma mb">func BenchmarkTryUnmarshal(b *testing.B) {<br/>    for i := 0; i &lt; b.N; i++ {<br/>        err := TryUnmarshal("file.json")<br/>        if err != nil {<br/>            b.Fatalf("error: %v", err)<br/>        }<br/>    }<br/>}</span><span id="97ee" class="lx kn in kl b gy mc lz l ma mb">func BenchmarkTryDecode(b *testing.B) {<br/>    for i := 0; i &lt; b.N; i++ {<br/>        err := TryDecode("file.json")<br/>        if err != nil {<br/>            b.Fatalf("error: %v", err)<br/>        }<br/>    }<br/>}</span></pre><p id="6ddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">"file.json"</code>是我们的实验变量。这些将是每次运行的不同大小的 JSON 文件。前五个 JSON 文件来源于<a class="ae mr" href="https://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder - Free 伪 REST API </a>。最后一个 JSON 文件(最大的一个)来源于主 JSON-iterator/test-data GitHub 中的<a class="ae mr" href="https://github.com/json-iterator/test-data/blob/master/large-file.json" rel="noopener ugc nofollow" target="_blank"> test-data/large-file.json。</a></p><p id="edc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是用于测试的架构。</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="268a" class="lx kn in kl b gy ly lz l ma mb">goos: linux<br/>goarch: amd64<br/>pkg: example.com/jsonExperiment<br/>cpu: Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz</span></pre><p id="524b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是基准数据。</p><h2 id="b104" class="lx kn in bd ko ms mt dn ks mu mv dp kw jv mw mx la jz my mz le kd na nb li nc bi translated">解组</h2><figure class="lp lq lr ls gt nd"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="f207" class="lx kn in bd ko ms mt dn ks mu mv dp kw jv mw mx la jz my mz le kd na nb li nc bi translated">译</h2><figure class="lp lq lr ls gt nd"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5c28e882a2687c4479aa37e74343a3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*muNB1Con9ZKXOJP_0gTYhA.png"/></div></figure><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0f1fc4efaff504ca27e83545586af2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*-i3FsoUS__iNRKk8omeP1g.png"/></div></figure><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f5ecc622905891327ec6e2756d567528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*i-xTkTDux7mWiFa4ETNUJQ.png"/></div></figure><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4d6de05358ded5dbd45e9fe8eff0dde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*zdkwY4foiKfftQJzB_zMDA.png"/></div></figure><p id="ed4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在这里看到一些模式:</p><ul class=""><li id="9fc1" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><code class="fe ki kj kk kl b">Decode</code>始终比<code class="fe ki kj kk kl b">Unmarshal</code>使用更少的内存。然而，这并没有太大的区别。</li><li id="492b" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">其他的都没那么大区别。</li><li id="3649" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">当您处理大型 JSON 文件时，内存使用似乎成了一个问题，但是一个服务器不太可能会收到这么大的 JSON 数据。我用最后一个例子来推动它。</li></ul><h1 id="affe" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="e16d" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">性能上的差异相当小，所以我认为在决定采用哪种方法时，性能不应该成为成败的因素。更合理的考虑方式是看你使用的是什么数据格式。例如，看看这个片段。</p><pre class="lp lq lr ls gt lt kl lu lv aw lw bi"><span id="00d1" class="lx kn in kl b gy ly lz l ma mb">func Homepage(w http.ResponseWriter, r *http.Request){<br/>    type pageData struct {<br/>        visited time.Time<br/>        message string<br/>    }<br/>    homepageData := pageData{time.Now(), "Welcome!"}<br/>    json.NewEncoder(w).Encode(&amp;homepageData)<br/>}</span><span id="b597" class="lx kn in kl b gy mc lz l ma mb">func main() {<br/>    http.HandleFunc("/", Homepage)<br/>    log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="a763" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个简单的例子，展示了一个 API 在 Go 中的样子。对<code class="fe ki kj kk kl b">/</code>端点的任何请求都将触发该代码运行<code class="fe ki kj kk kl b">Homepage</code>控制器，该控制器创建一个<code class="fe ki kj kk kl b">pageData</code>的实例，并使用<code class="fe ki kj kk kl b">NewEncoder(w).Encode(&amp;homepageData)</code>对其进行编码。<code class="fe ki kj kk kl b">w</code>实现了<code class="fe ki kj kk kl b">io.Writer</code>，所以使用<code class="fe ki kj kk kl b">Encode</code>更方便，预计在<code class="fe ki kj kk kl b">io.Writer</code>上使用。你可以从技术上把这个结构转换成字节片，然后使用<code class="fe ki kj kk kl b">Marshal</code>。但是当你不需要的时候为什么要多走一步呢？</p><p id="ed63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要点是，你不应该太担心性能，直到它成为一个问题。相反，你应该选择一个在给定时间内最容易使用的解决方案。如果有一个字节片要处理，使用<code class="fe ki kj kk kl b">Marshal</code>和<code class="fe ki kj kk kl b">Unmarshal</code>。如果有<code class="fe ki kj kk kl b">io.Writer</code>或<code class="fe ki kj kk kl b">io.Reader</code>，使用<code class="fe ki kj kk kl b">Encode</code>和<code class="fe ki kj kk kl b">Decode</code>。</p><p id="0316" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读！这对我来说是一个有趣的话题，我想进行一些实验。如果你喜欢这些类型的帖子，请在评论中告诉我！你可以在<a class="ae mr" href="https://dev.to/jpoly1219/to-unmarshal-or-to-decode-json-processing-in-go-explained-5870" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae mr" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>