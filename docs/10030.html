<html>
<head>
<title>Soft Introduction to SQL Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 事务软介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-transactions-150b99fafc14?source=collection_archive---------5-----------------------#2022-10-01">https://blog.devgenius.io/sql-transactions-150b99fafc14?source=collection_archive---------5-----------------------#2022-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/168864b81fbe5bc48cf4e52b7fe635cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MipipDMYJO-KKBxtdUS8Qw.png"/></div></div></figure><p id="ec90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将探讨 SQL 事务的基础知识。</p><h2 id="ef88" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">🤔首先，什么是事务处理？</h2><p id="7982" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">通过确保批量 SQL 操作完全运行或根本不运行，事务处理用于保持数据库的完整性。</p><p id="2c44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在继续之前，让我们假设我们有一个电子商务系统，其中有两个订单表(orders、OrderItems)和一个客户表。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/4e9af4016408a8bd4f9f4f445ce61f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-Dgw6nnljPCPtkvsRe5Gg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">客户表</figcaption></figure><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/7e4a20ed0fd247a4cee85af5b3089cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8pgP0gMlbdbMsbTvAzD0Q.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">订单表</figcaption></figure><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/65d9f7e078b9a6d5d2a6195d0f127111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjsNmDXWpVnoaJDzDs2OVg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">订单项目表</figcaption></figure><p id="7e46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">订单表就是一个很好的例子。订单保存在两个表中:Orders 跟踪实际订单，而 OrderItems 跟踪订购的特定项目。使用称为主键的唯一 id，这两个表相互连接。这些表链接到包含客户和产品数据的其他表。</p><p id="a11b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">向系统添加订单涉及以下步骤:</p><ol class=""><li id="823d" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">验证数据库，查看客户是否已经在那里。如果没有，请添加该人。</li><li id="f95e" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">获取客户的 ID。</li><li id="7751" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">应该在 Orders 表中添加一行，将其链接到客户 ID。</li><li id="23c3" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">从 Orders 表中获取新分配的订单 ID。</li><li id="f137" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">对于订购的每项商品，向 OrderItems 表添加一行，并使用检索到的 ID 将其链接到 Orders 表(通过产品 ID 链接到 Products 表)。</li></ol></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="dfb0" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">🥸什么是<strong class="ak">交易处理</strong></h2><p id="18cb" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><em class="mx">事务处理</em>是一种管理必须成组执行的 SQL 操作集的方法，确保数据库不会存储不完整操作的结果。使用事务处理，您可以确保操作集不会在过程中间停止处理；相反，它们要么完全完成处理，要么根本不完成处理(除非另有明确指示)。如果没有错误，整个语句集将被提交(写入)到数据库表中。如果确实发生了错误，可以执行回滚(撤消)来将数据库返回到已知的安全状态。</p><p id="66a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以基本上:</p><ol class=""><li id="fcfa" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated"><strong class="jx io">事务</strong>:一段 SQL 语句。</li><li id="d8fb" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated"><strong class="jx io">回滚</strong>:撤销指定 SQL 语句的过程。</li><li id="901c" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated"><strong class="jx io">提交</strong>:将未保存的 SQL 语句写入数据库表。</li><li id="19e7" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated"><strong class="jx io">保存点</strong>:事务集中的临时占位符，可以向其发出回滚命令(与回滚整个事务相反)。</li></ol><p id="d72f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以<strong class="jx io">回滚哪些语句？</strong></p><p id="0a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">INSERT、UPDATE 和 DELETE 语句的管理使用事务处理。使用 SELECT 所做的语句是不可逆的。(无论如何，这样做没有什么意义。)创建和删除等操作无法撤消。这些语句可以在事务块中使用，但是如果您执行回滚，它们将不会被撤销。</p><p id="f942" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，使用相同的示例，过程如下:</p><ol class=""><li id="1cbf" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">验证客户是否已经在数据库中，如果没有，则添加他们。</li><li id="9d68" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">传递客户数据。</li><li id="031b" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">获取客户的 ID。</li><li id="0352" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">向 Orders 表中添加一行。</li><li id="5c00" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">如果将行添加到订单时出现问题，请回滚。</li><li id="cd0e" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">从 Orders 表中获取新分配的订单 ID。</li><li id="677c" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">对于每个订购的项目，在 OrderItems 表中添加一行。</li><li id="64f7" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">如果向 OrderItems 添加行时出现故障，则回滚所有已添加的 OrderItems 行和 Orders 行。</li></ol></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="ba36" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">交易的🥳属性</h2><p id="18fe" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">事务的以下四个常见属性被称为 ACID，如下所示:</p><ul class=""><li id="5598" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks my mi mj mk bi translated"><strong class="jx io">原子性</strong>——确保工作单元内的每个操作都是成功的；否则，事务将在故障点暂停，先前的操作将被撤消。</li><li id="598e" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks my mi mj mk bi translated"><strong class="jx io">一致性</strong>—确保在成功提交事务后，数据库会相应地改变状态。</li><li id="20ca" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks my mi mj mk bi translated"><strong class="jx io">隔离</strong>—允许独立和透明的交易操作。</li><li id="da90" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks my mi mj mk bi translated"><strong class="jx io">持久性</strong>确保在系统出现故障时，已提交交易的结果或影响仍然存在。</li></ul></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="0bd7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak"> ⚠️控制交易</strong></h2><p id="a9b0" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><strong class="jx io"> <em class="mx">注</em> </strong> <em class="mx">:管理事务的关键在于将 SQL 语句分解成逻辑块，并明确说明数据何时应该回滚，何时不应该回滚。</em></p><p id="16a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mx">注意</em> </strong> <em class="mx">:有些 DBMSs 要求你显式标记事务块的开始和结束。</em></p><h2 id="1acb" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">SQL Server</h2><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2af6aba9d45313b2c8277ae701f62ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*SsIMQFdDctG7Rqs2in3E-g.png"/></div></figure><h2 id="f64e" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">Postgres</h2><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/750525a3cf1425eecfcbe109eac71999.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*78OdadKD9HKi8NU8N4yxww.png"/></div></figure><p id="b028" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，在 BEGIN TRANSACTION 和 COMMIT TRANSACTION 语句之间执行的所有 SQL 都必须完成，否则无法使用。其他数据库管理系统使用上述内容的变体。您会发现大多数实现都没有明确的事务结束。相反，事务会继续进行，直到某个事件结束它，通常是回滚以撤销更改或提交以保存更改。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="66b7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">👾使用</strong> <code class="fe nb nc nd ne b"><strong class="ak">ROLLBACK</strong></code></h2><p id="6ceb" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">SQL <code class="fe nb nc nd ne b">ROLLBACK</code>命令用于回滚(撤销)SQL 语句，如下一条语句所示:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/65184b10d7ce2338e93c7a6b3bffee63.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*yhY6QioByeWt-hhsK2pmNA.png"/></div></figure><p id="1595" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此图中，执行了一个删除操作，然后使用 ROLLBACK 语句将其反转。尽管这不是最好的说明，但它确实表明删除操作——不同于插入和更新操作——在一个事务块中永远不是最终的。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="6f01" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak"> 🫡利用</strong>T2】</h2><p id="561f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">通常，SQL 语句被直接执行并写入数据库表。这被称为<em class="mx">隐式提交</em> —提交(写或保存)操作自动发生。</p><p id="d93c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，在事务块中，提交可能不会隐式发生。这也是 DBMS 特有的。一些 DBMSs 将事务结束视为隐式提交；其他人没有。</p><p id="309c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要强制显式提交，可以使用<code class="fe nb nc nd ne b">COMMIT</code>语句。下面是一个 SQL Server 示例:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/a5d0d79ea9f645b0b09eed8b53ae2d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfSPR_RPwYzGkauqbM-0IQ.png"/></div></div></figure><p id="0e12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 SQL Server 示例中，订单编号 12345 已从数据库中完全删除。事务块用于确保订单不会被部分删除，因为这涉及到更新两个数据库表 Orders 和 OrderItems。如果没有错误，最终的 COMMIT 语句只写入更改。如果第一次删除成功，但第二次删除失败，则不会提交删除。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="be0b" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak"> ✅使用拯救点数</strong></h2><p id="824f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">简单的<code class="fe nb nc nd ne b">ROLLBACK</code>和<code class="fe nb nc nd ne b">COMMIT</code>语句使您能够编写或撤销整个事务。尽管这种方法适用于简单的事务，但更复杂的事务可能需要部分提交或回滚。</p><p id="40fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，前面描述的添加订单的过程是一个单一的事务。如果出现错误，您只想回滚到添加<code class="fe nb nc nd ne b">Orders</code>行之前的点。您不希望回滚到<code class="fe nb nc nd ne b">Customers</code>表的添加(如果有的话)。</p><p id="c737" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了支持部分事务的回滚，您必须能够在事务块中的关键位置放置占位符。然后，如果需要回滚，您可以回滚到其中一个占位符。</p><p id="b933" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 SQL 中，这些占位符被称为<em class="mx">保存点</em>。要在 MariaDB、MySQL 和 Oracle 中创建一个，可以使用<code class="fe nb nc nd ne b">SAVEPOINT</code>语句，如下所示:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6137fdeb0783a0b62ab215d3f1251449.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*hKGe3GT2Dgla77toCKEDug.png"/></div></figure><p id="9ff1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个保存点都有一个唯一的名称来标识它，这样当您回滚时，DBMS 就知道您回滚到了哪里。要回滚到该保存点，请执行以下操作</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e02b883dcd6a9ed4986b18205e7a2996.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*48lmQUu9mVtRVm9xxhnJ6A.png"/></div></figure><h2 id="293e" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">🚧完整示例:</h2><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/3a930df94f61650876dd5edc11bd8f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cd2jPUn7HxyePjNvtuqKvg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">SQL Server 事务</figcaption></figure><p id="06fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，一个事务块包含四个 INSERT 语句。在第一次插入后，会建立一个保存点，这样，如果任何后续的插入操作失败，事务只会回滚到该点。如果操作失败，可以通过查看 SQL Server 中的@@ERROR 变量来检查。(其他 DBMSs 使用各种函数或变量返回此数据。)发生错误，如果@@ERROR 返回 0 以外的值，事务将回滚到保存点。如果整个事务成功，将发送一个提交来保存数据。</p><blockquote class="nj"><p id="c8e9" class="nk nl in bd nm nn no np nq nr ns ks dk translated"><em class="nt">你可以在这里找到一个很棒的 Postgres 的例子</em><a class="ae nu" href="https://www.tutorialspoint.com/postgresql/postgresql_transactions.htm" rel="noopener ugc nofollow" target="_blank"><em class="nt">https://www . tutorialspoint . com/PostgreSQL/PostgreSQL _ transactions . htm</em></a></p></blockquote></div></div>    
</body>
</html>