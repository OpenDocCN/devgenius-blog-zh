<html>
<head>
<title>Leetcode 4: Median of Two Sorted Arrays in O(log-n) time complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">leet code 4:O(log-n)时间复杂度的两个排序数组的中值</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-4-hard-median-of-two-sorted-arrays-cce292b4f4e?source=collection_archive---------5-----------------------#2022-09-04">https://blog.devgenius.io/leetcode-4-hard-median-of-two-sorted-arrays-cce292b4f4e?source=collection_archive---------5-----------------------#2022-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="90fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定两个大小分别为 m 和 n 的排序数组 nums1 和 nums2，返回两个排序数组的中间值。</p><p id="3490" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的运行时间复杂度应该是 O(log (m+n))。</p><p id="8705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><p id="8dd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入:nums1 = [1，3]，nums2 = [2] <br/>输出:2.00000 <br/>说明:合并数组= [1，2，3]，中位数为 2。</p><p id="fed9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例二:</strong></p><p id="ea88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入:nums1 = [1，2]，nums2 = [3，4] <br/>输出:2.50000 <br/>说明:合并数组= [1，2，3，4]，中位数为(2 + 3) / 2 = 2.5。</p><p id="557f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">约束:</strong></p><p id="cbde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">nums 1 . length = = m<br/>nums 2 . length = = n<br/>0&lt;= m&lt;= 1000<br/>0&lt;= n&lt;= 1000<br/>1&lt;= m+n&lt;= 2000<br/>-106&lt;= nums 1[I]，nums2[i] &lt; = 106</p><h2 id="b85e" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">方法</h2><p id="c905" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">整个逻辑都是围绕分区展开的。我们将对这两个数组进行分区，直到我们得到一个条件</p><p id="eeb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分区 1 左半部分的所有元素&lt;= right half of partition 2 and<br/>分区 2 左半部分的所有元素&lt; =分区 1 右半部分</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b59f" class="ki kj in ll b gy lp lq l lr ls">def check_condition(LH1,LH2,RH1,RH2):<br/>    return (LH1 &lt;= RH2)&amp;(LH2&lt;=RH1)</span></pre><p id="6eb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果不满足上述条件，我们将移动分区。</p><p id="e39a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果 1 的左半部分大于 2 的右半部分。我们将把分区 1 向左移动，分区 2 向右移动。否则，我们将把分区 1 移到右边，分区 1 移到左边。</p><p id="927c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这个例子</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/c542c1e6b43aef771631b579434c82ac.png" data-original-src="https://miro.medium.com/v2/format:webp/1*uFDwBSWvRQ3G37eOwJk0yw.png"/></div></figure><p id="4319" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个结果是</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/4a4c6c36595f5d246c83a6d29814f712.png" data-original-src="https://miro.medium.com/v2/format:webp/1*odpciTj1RwqQMyzHiG9wkQ.png"/></div></figure><p id="23a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中位数变成了(3+5)/2 = 4</p><p id="0180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们看另一个例子:</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/036291fdc61e904d73b3de08a6047f08.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pMOkGicQRCrnH4ioGs3yUg.png"/></div></figure><p id="4862" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，中位数将变成(2+3)/2 = 2.5</p><h2 id="7428" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">如何移动分区</h2><p id="cc9c" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">最初，如果你看到当我们合并两个分区时，它等于合并数组的一半长度。<br/>因此，<br/>partition 1+partition 2 =(len(num S1)+len(num S2))/2</p><p id="a03a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，如果我们知道其中一个分区，我们可以很容易地找到第二个分区。此外，当我们做更新时，我们把 LH 放在分区和更新。因此，这方面的代码将是</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="9794" class="ki kj in ll b gy lp lq l lr ls">def obtain_partition(mid):<br/>    LH1 = mid<br/>    <br/>    LH2 = int(len(nums1+nums2)*0.5) - LH1 -1<br/>    <br/>    if len(nums1+nums2)%2==0:<br/>        LH2 -= 1<br/>    RH1 = LH1+1<br/>    RH2 = LH2+1<br/>    <br/>    print("Partition",LH1, LH2, RH1, RH2)<br/>    return LH1, LH2, RH1, RH2</span></pre><p id="4999" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它会看起来像这样，然后我们做移动</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/cc4139c853792f964e385657b438905f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*c8E9XTDGdghz6gfyt_jHug.png"/></div></figure><h2 id="71c7" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">让我们结合这两种情况进行模拟</h2><p id="2a7e" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">nums1 = [1，3，4，6，8] <br/> nums2 = [2，4，5]</p><p id="7547" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将进行一次交换。因为在较小长度的阵列上应用二分搜索法成本较低</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/07dfe62092d7edbc5aa1ef780e85c5e4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*K6-iSMHxKkt9oONednZqXw.png"/></div></figure><p id="1c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此后，进行初始分区</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/b5db2239fd14b2ea0e926fe9ec3d5ac9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lBz0KrQLKT1W7NdxqUB_jA.png"/></div></figure><p id="21bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此后，根据条件，我们改变指针，这样我们得到</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/4ae24802dece36f937f9cb4fdc4ce177.png" data-original-src="https://miro.medium.com/v2/format:webp/1*89nVGHLOIDCBJ2Jx2GP-rQ.png"/></div></figure><p id="556e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中位数将被计算为两个分区的左半部分的最大值和两个分区的右半部分的最小值</p><p id="3555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中位数= (9+1)/2 = 5</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f5f4" class="ki kj in ll b gy lp lq l lr ls">if len(nums1)&gt;len(nums2):<br/>    nums1,nums2 = nums2,nums1<br/><br/>start = 0<br/>end = min(len(nums1),len(nums2))-1</span><span id="0abf" class="ki kj in ll b gy lx lq l lr ls">mid = start - int((start-end)*0.5)<br/>LH1, LH2, RH1, RH2 = obtain_partition(mid)</span><span id="59f9" class="ki kj in ll b gy lx lq l lr ls">while LH1 &gt;= 0 and RH1&lt;=len(nums1)-1:<br/>    if (nums1[LH1]&lt;=nums2[RH2])&amp;(nums2[LH2]&lt;=nums1[RH1]):<br/>        if len(nums1+nums2)%2 != 0:<br/>            return(max(nums1[LH1], nums2[LH2]))<br/>        else:<br/>            return((max(nums1[LH1],nums2[LH2])+min(nums1[RH1],nums2[RH2]))*0.5)<br/>        break<br/>    elif nums1[LH1]&gt;=nums2[RH2]:<br/>        end = mid-1<br/>    else:<br/>        start = mid+1<br/>    mid = (start+end)//2<br/>    LH1, LH2, RH1, RH2 = obtain_partition(mid)</span></pre><p id="d0b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，有一种情况，我们的 nums1 长度小于等于 1。<br/>如果是 0 那么直接 we。计算 nums2 的中值。<br/>当它。是 1 那么我们需要。看到三个条件</p><ol class=""><li id="1964" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">如果 nums1 中的元素值等于 nums2 的中值，则没有问题</li><li id="8518" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">如果元素值。小于 nums2 的中值，那么我们需要找到前一个。元素和下一个元素</li><li id="8ab0" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">如果元素值大于 num2 的中值。那我们需要。求下一个元素和它的下一个元素的中间值</li></ol><p id="7f0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果。长度是奇数，那么我们就简单地做 n-1 次。元素等于第 n 个元素并执行运算。</p><p id="2506" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">的。这方面的例子。是。作为。遵照</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/fa5491adbfad8a98c8b395239d24ff46.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ThH9waJOj4GU8enYqnK16Q.png"/></div></figure><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="ffcc" class="ki kj in ll b gy lp lq l lr ls">if len(nums1)&lt;=1:<br/>    median_index = (len(nums2)-1)//2<br/>    median_ = (nums2[median_index]+nums2[median_index+1])*0.5 if len(nums2)%2==0 else nums2[median_index]<br/>    x = 0 if len(nums1)==0 else nums1[0]<br/>    if x==median_ or len(nums1)==0:<br/>        print(median_)<br/>    elif x&lt;=median_:<br/>        if len(nums2)==1:<br/>            print((nums2[0]+nums1[0])*0.5)<br/>        elif len(nums2)%2==0:<br/>            nums2[median_index-1]=nums2[median_index]<br/>        return((max(nums2[median_index-1],nums1[0])+nums2[median_index])*0.5)<br/>    else:<br/>        if len(nums2)%2=0:<br/>            nums2[median_index]=nums2[median_index+1]<br/>        return((nums2[median_index]+nums2[median_index+1])*0.5)</span></pre><p id="f81d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是最后一个例外。处理需要执行的是，当分区退出时。边界见示例</p><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/efba5b41a08c74c084efef38d4d5c54b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wQK3cI62Eje74XMPpzougg.png"/></div></figure><p id="f4e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况下。我们将 max(left)+min(right)/2 中的值更改为 sys.max 和-sys.min。其代码如下</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="ff67" class="ki kj in ll b gy lp lq l lr ls">if len(nums1+nums2)%2==0:<br/>    x1 = -sys.maxsize if LH1==-1 else nums1[LH1]<br/>    x2 = -sys.maxsize if LH2==-1 else nums2[LH2]<br/>    y1 = sys.maxsize if RH1==len(nums1) else nums1[RH1]<br/>    y2 = sys.maxsize if RH2==len(nums2) else nums2[RH2]<br/><br/>    print((max(x1,x2)+min(y1,y2))*0.5)<br/>    <br/>    <br/>else:<br/>    if len(nums1)==RH1:<br/>        print(max(nums2[LH2],nums1[LH1]))<br/>    else:<br/>        print(nums2[LH2])</span></pre><p id="7c17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，获得两个排序数组的中间值的整个程序将如下所示:</p><div class="mm mn gp gr mo mp"><a href="https://leetcode.com/submissions/detail/791189946/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">帐户登录- LeetCode</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">leetcode.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd lv mp"/></div></div></a></div><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4753" class="ki kj in ll b gy lp lq l lr ls">import sys<br/>class Solution(object):<br/>    def findMedianSortedArrays(self, nums1, nums2):<br/>        """<br/>        :type nums1: List[int]<br/>        :type nums2: List[int]<br/>        :rtype: float<br/>        """<br/>        if len(nums1)&gt;len(nums2):<br/>            nums1,nums2 = nums2,nums1<br/>        <br/>        start = 0<br/>        end = min(len(nums1),len(nums2))-1<br/>        <br/><br/>        def obtain_partition(mid):<br/>            LH1 = mid<br/><br/>            LH2 = int(len(nums1+nums2)*0.5) - LH1 -1<br/><br/>            if len(nums1+nums2)%2==0:<br/>                LH2 -= 1<br/>            RH1 = LH1+1<br/>            RH2 = LH2+1<br/>            return LH1, LH2, RH1, RH2<br/><br/>        mid = start - int((start-end)*0.5)<br/>        LH1, LH2, RH1, RH2 = obtain_partition(mid)<br/>        <br/>        while LH1 &gt;= 0 and RH1&lt;=len(nums1)-1:<br/>            if (nums1[LH1]&lt;=nums2[RH2])&amp;(nums2[LH2]&lt;=nums1[RH1]):<br/>                if len(nums1+nums2)%2 != 0:<br/>                    return(max(nums1[LH1], nums2[LH2]))<br/>                else:<br/>                    return((max(nums1[LH1],nums2[LH2])+min(nums1[RH1],nums2[RH2]))*0.5)<br/>                break<br/>            elif nums1[LH1]&gt;=nums2[RH2]:<br/>                end = mid-1<br/>            else:<br/>                start = mid+1<br/>            mid = (start+end)//2<br/>            LH1, LH2, RH1, RH2 = obtain_partition(mid)<br/>            <br/>            <br/>        if len(nums1)&lt;=1:<br/>            median_index = (len(nums2)-1)//2<br/>            median_ = (nums2[median_index]+nums2[median_index+1])*0.5 if len(nums2)%2==0 else nums2[median_index]<br/>            x = 0 if len(nums1)==0 else nums1[0]<br/>            if len(nums2)==1 and len(nums1)==1:<br/>                    return((nums2[0]+nums1[0])*0.5)<br/>            if x==median_ or len(nums1)==0:<br/>                return(median_)<br/>            elif x&lt;=median_:<br/>                if len(nums2)%2==0:<br/>                    nums2[median_index-1]=nums2[median_index]<br/>                return((max(nums2[median_index-1],nums1[0])+nums2[median_index])*0.5)<br/>            else:<br/>                if len(nums2)%2==0:<br/>                    nums2[median_index]=nums2[median_index+1]<br/>                return((nums2[median_index]+min(nums2[median_index+1],nums1[0]))*0.5)   <br/>             <br/>        elif len(nums1+nums2)%2==0:<br/>            x1 = sys.maxsize*-1 if LH1==-1 else nums1[LH1]<br/>            x2 = sys.maxsize*-1 if LH2==-1 else nums2[LH2]<br/>            y1 = sys.maxsize if RH1==len(nums1) else nums1[RH1]<br/>            y2 = sys.maxsize if RH2==len(nums2) else nums2[RH2]<br/>            return((max(x1,x2)+min(y1,y2))*0.5)<br/>        else:<br/>            if len(nums1)==RH1:<br/>                return(max(nums2[LH2],nums1[LH1]))<br/>            else:<br/>                return(nums2[LH2])</span></pre><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/19df414c8e589ce536e103c6adeaa52b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*uEySND8oaaeT27l_a3marQ.png"/></div></figure><figure class="lg lh li lj gt lt gh gi paragraph-image"><div class="ab gu cl lu"><img src="../Images/a3e3a52559f28076c583ac816c6ae542.png" data-original-src="https://miro.medium.com/v2/format:webp/1*DTQof-EpD-jJMzsHI6Hpxg.png"/></div></figure></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="8c0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读我的文章。DMs 于<a class="ae nl" href="https://linktr.ee/prituldave" rel="noopener ugc nofollow" target="_blank">https://linktr.ee/prituldave</a>开放，欢迎任何查询！！！</p></div></div>    
</body>
</html>