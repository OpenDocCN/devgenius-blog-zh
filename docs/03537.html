<html>
<head>
<title>Functional JavaScript — Useful Higher-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式 JavaScript——有用的高阶函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-javascript-useful-higher-order-functions-346a1a919275?source=collection_archive---------9-----------------------#2020-11-15">https://blog.devgenius.io/functional-javascript-useful-higher-order-functions-346a1a919275?source=collection_archive---------9-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/81c85782b4708fb416600f9c6522db6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0tDbLmYHiAvOC8Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@laurarain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳拉·克劳</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">un plash</a>上拍摄</figcaption></figure><p id="6f16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 在一定程度上是一种功能性语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用闭包来创建我们自己的高阶函数。</p><h1 id="1007" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一元函数</h1><p id="d60f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建自己的<code class="fe me mf mg mh b">unary</code>函数，该函数返回一个只调用一个参数的函数。</p><p id="7238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f1bc" class="mq lc iq mh b gy mr ms l mt mu">const unary = (fn) =&gt;<br/>  fn.length === 1 ?<br/>  fn :<br/>  (arg) =&gt; fn(arg)</span></pre><p id="75b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">fn</code>这是一个函数。</p><p id="185b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe me mf mg mh b">fn</code>的<code class="fe me mf mg mh b">length</code>属性，返回它有多少参数。</p><p id="34cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果只有一个参数，则返回<code class="fe me mf mg mh b">fn</code>函数。</p><p id="ea52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们返回一个只有一个参数调用<code class="fe me mf mg mh b">fn</code>的函数。</p><p id="9bc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就可以通过<code class="fe me mf mg mh b">map</code>方法安全地使用类似<code class="fe me mf mg mh b">parseInt</code>的功能。</p><p id="84c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3583" class="mq lc iq mh b gy mr ms l mt mu">const nums = ['1', '2', '3'].map(unary(parseInt));</span></pre><p id="2048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">parseInt</code>调用<code class="fe me mf mg mh b">unary</code>函数，这样我们就可以用带有 n 个参数的回调函数将字符串解析成一个整数。</p><p id="0523" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">parseInt</code>取要解析的值，基数作为第二个参数，所以我们不能直接通过<code class="fe me mf mg mh b">parseInt</code>来映射，因为基数是数组条目的索引，这不是我们想要的。</p><p id="cc6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的<code class="fe me mf mg mh b">unary</code>函数，我们总是只通过传入的值来调用<code class="fe me mf mg mh b">parseInt</code>。</p><p id="88da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">故<code class="fe me mf mg mh b">nums</code>为<code class="fe me mf mg mh b">[1, 2, 3]</code>。</p><h1 id="2834" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能一次</h1><p id="9008" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个<code class="fe me mf mg mh b">once</code>函数，只调用一次。</p><p id="f7fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bc3c" class="mq lc iq mh b gy mr ms l mt mu">const once = (fn) =&gt; {<br/>  let done = false;<br/>  return function(...args) {<br/>    if (!done) {<br/>      done = true;<br/>      fn.apply(this, args);<br/>    }<br/>  }<br/>}</span></pre><p id="706a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">once</code>函数，它只运行<code class="fe me mf mg mh b">done</code>为<code class="fe me mf mg mh b">false</code>时传入的<code class="fe me mf mg mh b">fn</code>函数。</p><p id="0168" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是这样的话，那么我们将<code class="fe me mf mg mh b">done</code>设置为<code class="fe me mf mg mh b">true</code>并用<code class="fe me mf mg mh b">apply</code>调用<code class="fe me mf mg mh b">fn</code>。</p><p id="5cbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">apply</code>将<code class="fe me mf mg mh b">this</code>值作为第一个参数，将参数数组作为第二个参数。</p><p id="cda1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来调用一个函数，只需写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="83fd" class="mq lc iq mh b gy mr ms l mt mu">const foo = once(() =&gt; {<br/>  console.log("foo")<br/>})</span><span id="5657" class="mq lc iq mh b gy mv ms l mt mu">foo();<br/>foo();</span></pre><p id="de38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个我们只想调用一次的函数来调用<code class="fe me mf mg mh b">once</code>函数。</p><p id="da56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用它两次，看到<code class="fe me mf mg mh b">'foo'</code>只被记录了一次。</p><h1 id="17a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">记忆</h1><p id="35aa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建自己的<code class="fe me mf mg mh b">memoize</code>函数来缓存函数调用的返回值。</p><p id="2d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d556" class="mq lc iq mh b gy mr ms l mt mu">const memoize = (fn) =&gt; {<br/>  const cache = {};<br/>  return (arg) =&gt; {<br/>    if (!cache[arg]) {<br/>      cache[arg] = fn(arg);<br/>    }<br/>    return cache[arg]<br/>  }<br/>}</span></pre><p id="994f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个接受<code class="fe me mf mg mh b">fn</code>函数的<code class="fe me mf mg mh b">memoize</code>函数。</p><p id="671b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数中，我们定义了<code class="fe me mf mg mh b">cache</code>对象。</p><p id="1323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回一个带<code class="fe me mf mg mh b">arg</code>参数的函数。</p><p id="9b05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe me mf mg mh b">cache[arg]</code>是否在缓存中。</p><p id="0b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是，那么我们在<code class="fe me mf mg mh b">cache</code>对象中设置值。</p><p id="219c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们返回缓存的值。</p><p id="1659" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="da3c" class="mq lc iq mh b gy mr ms l mt mu">let fastFib = memoize((n) =&gt; {<br/>  if (n === 0 || n === 1) {<br/>    return 1;<br/>  }<br/>  return n + fastFib(n - 1);<br/>});</span></pre><p id="2291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定<code class="fe me mf mg mh b">n</code>的值，我们传递我们的 Fibonacci 函数来返回 Fibonacci 数。</p><p id="0f2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这要快得多，因为我们可以从<code class="fe me mf mg mh b">cache</code>对象中查找过去计算的值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8da719c25a6c5b40cc975a6e3cd2df7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VwU9MPQNT8_7X7Tp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@justusmenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Justus Menke </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d656" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="25e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建自己的高阶函数来用它做各种事情。</p></div></div>    
</body>
</html>