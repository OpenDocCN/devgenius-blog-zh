<html>
<head>
<title>Async Image Loading —It’s Combine Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步图像加载——这是一种组合方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-image-loading-its-combine-way-be203eae12f7?source=collection_archive---------1-----------------------#2020-06-26">https://blog.devgenius.io/async-image-loading-its-combine-way-be203eae12f7?source=collection_archive---------1-----------------------#2020-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c63b0fc871086edc6d2a851e784be082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7aGijN5HTrkdp8wyJ_24g.jpeg"/></div></div></figure><p id="cf3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">苹果在2019年WWDC发布了SwiftUI和Combine框架。从那以后，它改变了编码的方式。我们知道如何从远程URL下载并显示图像。我相信我们已经这样做了一千次了。有些开发人员使用内置框架来完成这项任务，有些开发人员则自行实现。</p><p id="c6ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从远程URL下载一个图像，并在SwiftUI Image中显示该图像。但是，我们将借助Combine framework来处理从URLSession dataTask接收的数据，并在SwiftUI中呈现该图像。我希望你对SwiftUI和Combine框架有所了解。让我们开始吧…</p><h1 id="92ad" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">入门指南</h1><p id="b094" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将创建一个SwiftUI文件，并将其命名为AsyncWebImageView。这里我们将渲染下载的图像。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="899d" class="mf ku in mb b gy mg mh l mi mj">import SwiftUI</span><span id="27ef" class="mf ku in mb b gy mk mh l mi mj"><br/>struct AsyncWebImageView: View {<br/>    private var url: URL<br/>    private var placeHolder: Image</span><span id="cfdd" class="mf ku in mb b gy mk mh l mi mj">    init(url: URL, placeHolder: Image) {<br/>        self.url = url<br/>        self.placeHolder = placeHolder<br/>    }</span><span id="26d0" class="mf ku in mb b gy mk mh l mi mj">    var body: some View {<br/>        placeHolder<br/>            .resizable()<br/>            .onAppear { }<br/>            .onDisappear { }<br/>    }</span><span id="bb5c" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><p id="2800" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候设计<em class="ml"> AsyncImageBinder </em>类了。这个调用将负责下载和缓存图像。这里我将使用Combine框架。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0769" class="mf ku in mb b gy mg mh l mi mj">import Foundation<br/>import Combine<br/>import UIKit</span><span id="b732" class="mf ku in mb b gy mk mh l mi mj">// 1<br/>class AsyncImageBinder: ObservableObject {       <br/>    private var subscription: AnyCancellable?</span><span id="17cb" class="mf ku in mb b gy mk mh l mi mj">    // 2<br/>    @Published private(set) var image: UIImage?<br/></span><span id="a938" class="mf ku in mb b gy mk mh l mi mj">    // 3    <br/>    func load(url: URL) {<br/>        //do something<br/>    }</span><span id="f36b" class="mf ku in mb b gy mk mh l mi mj">    // 4<br/>    func cancel() {<br/>        // do something<br/>    }</span><span id="127e" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><p id="5fd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们知道联合收割机有两个组成部分。即<em class="ml">发布者</em>和<em class="ml">订阅者。<br/> </em>发布者发布值，订阅者接收值。</p><ol class=""><li id="3785" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">这里我们使用了<em class="ml"> ObservableObject </em>协议。这是使模型可观察的综合方法。</li><li id="5641" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">我们使用了带有图像属性的已发布属性包装。每当我们更新图像的值时，它都会通知订阅者。</li><li id="c23b" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated"><em class="ml"> load(url:) </em>方法将从远程url获取图像。</li><li id="cb1e" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated"><em class="ml">取消</em>方法会在我们不想在UI中渲染图像的时候取消订阅。</li></ol><h2 id="1444" class="mf ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">从远程URL获取图像</h2><p id="5bb0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们在load(url:)方法中实现图像下载代码。</p><p id="4b01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">引入Combine之后，URLSession又增加了两个实例方法。他们是</p><ol class=""><li id="1193" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">dataTaskPublisher(对于url: URL) -&gt; URLSession。DataTaskPublisher</li><li id="bf03" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">dataTaskPublisher(for request:URL request)-&gt; URL session。DataTaskPublisher</li></ol><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ea80" class="mf ku in mb b gy mg mh l mi mj">func load(url: URL) {<br/>    subscription = URLSession.shared<br/>                       .dataTaskPublisher(for: url)      // 1<br/>                       .map { UIImage(data: $0.data) }   // 2<br/>                       .replaceError(with: nil)          // 3<br/>                       .receive(on: DispatchQueue.main)  // 4<br/>                       .assign(to: \.image, on: self)    // 5</span><span id="49f3" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="ec58" class="mf ku in mb b gy mk mh l mi mj">func cancel() {<br/>    subscription?.cancel()<br/>}</span></pre><p id="0703" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是不是很酷！！！</p><p id="f337" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只需要写这么多代码来从远程URL获取图像。让我们明白我们在做什么。</p><ol class=""><li id="0e64" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">dataTaskPublisher(对于url: URL)会给我们URLSession.DataTaskPublisher .我们知道，每个Publisher都有两个关联的类型。它们是输出和失败(错误)。所以URLSession的输出。DataTaskPublisher有数据和响应。我们需要处理数据。所以我们在这个发布器上推出了一系列的操作。</li><li id="db58" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">map将尝试从数据中获取UIImage。</li><li id="529f" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">如果我们无法获取图像数据并以错误结束，replaceError(with:)将用nil替换错误。</li><li id="4a53" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">根据多线程规则，我们应该只在主线程上更新UI。这里我们将在主线程上接收。</li><li id="c4db" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">这里我们将把接收到的值赋给图像属性。</li></ol><h2 id="7e1d" class="mf ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">在用户界面中渲染图像</h2><p id="87e9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在是时候更新AsyncWebImageView来在这里呈现下载的图像了。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fe94" class="mf ku in mb b gy mg mh l mi mj">struct AsyncWebImageView: View {<br/>    // ...</span><span id="9d2b" class="mf ku in mb b gy mk mh l mi mj">    // 1<br/>    @ObservedObject var binder = AsyncImageBinder() </span><span id="dae0" class="mf ku in mb b gy mk mh l mi mj"><br/>    init(url: URL, placeHolder: Image) {<br/>        // ...</span><span id="4e7a" class="mf ku in mb b gy mk mh l mi mj">        // 2<br/>        self.binder.load(url: self.url)<br/>    }</span><span id="4b3b" class="mf ku in mb b gy mk mh l mi mj">    var body: some View {<br/>        VStack {<br/>            // 3<br/>            if binder.image != nil {<br/>                Image(uiImage: binder.image!)<br/>                    .renderingMode(.original)<br/>                    .resizable()<br/>            } else {<br/>                placeHolder<br/>            }<br/>        }<br/>        .onAppear {  }<br/>        .onDisappear { self.binder.cancel() }<br/>    <br/>    }</span><span id="67eb" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><p id="afb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们了解一下这是怎么回事…</p><ol class=""><li id="c09d" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">ObservedObject属性包装类型订阅可观察类型对象。所以，每当我们要改变<em class="ml"> AsyncImageBinder类</em>的image属性的值时，<em class="ml"> AsyncWebImageView </em>就会被通知这个改变。</li><li id="5d2d" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">我们正在调用<em class="ml"> AsyncImageBinder的load(url:)方法。</em></li><li id="2990" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">这里我们将使用一个条件操作。如果image属性的值为零，我们将显示占位符图像。</li></ol><h2 id="508e" class="mf ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">让我们看看结果</h2><p id="af83" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在是时候看看我们到目前为止都做了些什么。我们将在预览中看到这些变化。让我们在<em class="ml"> AsyncWebImageView </em>中添加以下代码</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bbcd" class="mf ku in mb b gy mg mh l mi mj">struct AsyncWebImageView_Previews: PreviewProvider {<br/>    static let url = URL(string: "https://image.tmdb.org/t/p/original/cDbOrc2RtIA37nLm0CzVpFLrdaG.jpg")!</span><span id="fafc" class="mf ku in mb b gy mk mh l mi mj"><br/>    static var previews: some View {<br/>        AsyncWebImageView(url: url)<br/>    }</span><span id="7387" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><p id="946a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们将在预览中看到的。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d07cae0be86d80b287e0524ecc147e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*rG7SaeLW9jHoE8IboaMrbg.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">这是从预览中捕获的图像</figcaption></figure><h2 id="7bc7" class="mf ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">缓存图像</h2><p id="1185" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们创建一个AsyncImageCache类。在这里，我们将NSCache来存储图像。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2a47" class="mf ku in mb b gy mg mh l mi mj">class AsyncImageCache {<br/>    <br/>    // 1<br/>    static let shared = AsyncImageCache()</span><span id="9128" class="mf ku in mb b gy mk mh l mi mj">    // 2<br/>    private var cache: NSCache = NSCache&lt;NSString, UIImage&gt;()</span><span id="02f7" class="mf ku in mb b gy mk mh l mi mj">    // 3<br/>    subscript(key: String) -&gt; UIImage? {<br/>        get { cache.object(forKey: key as NSString) }<br/>        set(image) { image == nil ? self.cache.removeObject(forKey: (key as NSString)) : self.cache.setObject(image!, forKey: (key as NSString)) }</span><span id="9626" class="mf ku in mb b gy mk mh l mi mj">    }</span><span id="7426" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><p id="a955" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们明白我们在做什么。</p><ol class=""><li id="feff" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">我们将创建单例。Singleton将确保AsyncImageCache只有一个入口点。当我们在一个列表中使用多个<em class="ml"> AsyncWebImageView </em>时，这将对我们很有帮助。</li><li id="9d96" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">我们将有一个NSCache实例。</li><li id="b9fb" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">NSCache是一个可变的集合，我们将数据临时存储在一个键值对中。我们知道下标为我们提供了一种从集合中访问数据的快捷方式。因此，我们将使用下标。</li></ol><p id="5928" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候更新AsyncImageBinder 类了。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8481" class="mf ku in mb b gy mg mh l mi mj">//...</span><span id="31d7" class="mf ku in mb b gy mk mh l mi mj">private var cache = AsyncImageCache.shared</span><span id="98af" class="mf ku in mb b gy mk mh l mi mj">//...</span><span id="33ad" class="mf ku in mb b gy mk mh l mi mj">func load(url: URL) {<br/>    // 1<br/>if let image: UIImage = cache[url.absoluteString] {<br/>        self.image = image<br/>        return<br/>    }<br/>    </span><span id="7b47" class="mf ku in mb b gy mk mh l mi mj">    subscription = URLSession.shared.dataTaskPublisher(for: url)<br/>                       .map { UIImage(data: $0.data) }<br/>                       .replaceError(with: nil)<br/>                       .handleEvents(receiveOutput: { self.cache[url.absoluteString] = $0 })                 // 2<br/>                       .receive(on: DispatchQueue.main)<br/>                       .assign(to: \.image, on: self)</span><span id="8cdf" class="mf ku in mb b gy mk mh l mi mj">}</span></pre><ol class=""><li id="7f45" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">在从远程URL获取图像之前，我们将检查是否已将图像存储在特定URL的NSCache中。如果有，我们将从NSCache获取图像并更新图像属性。</li><li id="f8a0" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">发布者的handleEvents操作帮助我们跟踪发布者的事件。在receiveOutput事件中，我们将图像存储在NSCache中。</li></ol><p id="1918" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">酷…</p><h1 id="ede6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="bc42" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">组合框架非常强大。它提供了一种更简单的方法来完成异步任务。</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="bebe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。希望你喜欢它。随意评论。</p><p id="275b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章有帮助，请鼓掌，你知道每个人可以鼓掌50次😉，并鼓励我进一步写更多的文章。</p></div></div>    
</body>
</html>