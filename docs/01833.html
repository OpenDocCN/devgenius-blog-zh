<html>
<head>
<title>Kubernetes Secrets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特的秘密</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kubernetes-secrets-c951ad81ad0a?source=collection_archive---------40-----------------------#2020-07-12">https://blog.devgenius.io/kubernetes-secrets-c951ad81ad0a?source=collection_archive---------40-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2824f4410ef3c7d98f8ecb97e677dc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*l92kLf2nNZSPiEMiawDvsw.png"/></div></figure><p id="ac9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们为什么需要秘密？</p><p id="28f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嗯，我们不希望我们的敏感信息，如密码、api令牌和ssh密钥以纯文本形式存储在任何源代码中，也不希望硬编码在docker映像中。K8s提供了一种在集群中存储这些变量的方法，这样只有具有访问权限的管理员才能管理它们。</p><p id="3319" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">要点:</strong></p><ol class=""><li id="c8a5" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">默认情况下，机密不加密，但可以进行base64编码。你可以按照<a class="ae lb" href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/" rel="noopener ugc nofollow" target="_blank">这个</a>来加密你的秘密。</li><li id="507c" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">存储在etcd中</li><li id="866f" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">机密是有名称空间的，这意味着只有在同一个名称空间中运行的pod才能使用它们</li></ol><p id="96ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">创建秘密:</strong></p><p id="0b3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes支持三种类型的秘密</p><ol class=""><li id="9c21" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">Generic (Opaque):这允许从本地文件或命令行或目录提供的文字值创建一个秘密。</li></ol><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="4a02" class="lq lr iq lm b gy ls lt l lu lv">kubectl create secret generic &lt;name&gt; --from-literal=USERNAME=&lt;user&gt; --from-literal=PASSWORD=&lt;password&gt;</span></pre><p id="f77c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.Docker-Registry(kubernetes . io/docker config JSON):我们经常使用私有的docker存储库来存储我们创建的专有图像，当我们处理这些图像时，kubelet需要docker registry凭证来获取这些图像。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="2dc3" class="lq lr iq lm b gy ls lt l lu lv">kubectl create secret docker-registry my-private-docker-registry --docker-server=&lt;server&gt; --docker-username=&lt;user&gt; --docker-password=&lt;password&gt; --docker-email=&lt;email&gt;</span></pre><p id="7ec7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.TLS(kubernetes.io/tls):任何应用程序都可能需要TLS秘密来安全地传输数据。我们可以使用tls密钥生成一个，并使用这个TLS secret类型生成tls crt。</p><p id="4f1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lw lx ly lm b">kubectl create secret tls app-tls --key="key" --cert="cert"</code></p><p id="1a04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">在pod中使用机密:</strong></p><p id="00b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们知道了如何创建秘密，让我们看看如何将它们共享给容器。它们可以通过以下方式共享:</p><p id="75a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">I)作为环境变量</p><p id="41eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ii)作为卷安装的文件</p><p id="71e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">iii)docker-registry secrets到kubelet以提取图像</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="15ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们进入演示部分，通过示例更好地理解</p><p id="b284" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 1。</strong> <strong class="jw ir">将用户名和密码作为环境变量传递</strong></p><p id="7c26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">I)用用户名和密码创建一个密码</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="8921" class="lq lr iq lm b gy ls lt l lu lv">kubectl create secret generic db-creds --from-literal=USERNAME=admin --from-literal=PASSWORD=admin</span></pre><p id="d274" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用<code class="fe lw lx ly lm b">kubectl get secrets db-creds</code>验证。输出应该如下所示，所有使用泛型创建的秘密将显示为不透明类型。基本上，这种类型包含键值对</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/3ad872b678395ed95cc9f228f3ec902d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzQj61_A6B8ClTu2D5Gjew.png"/></div></div></figure><p id="c891" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ii)创建一个部署，在pod.spec中，我们要求api服务器通过读取指定的机密来创建env变量。<code class="fe lw lx ly lm b">envFrom</code>会将secret <code class="fe lw lx ly lm b">db-creds</code>中的所有密钥对值设置为env变量。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="acbb" class="lq lr iq lm b gy ls lt l lu lv">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>   name: hello-world-deployment-v1<br/>spec:<br/>   selector:<br/>      matchLabels:<br/>         app: hello-world<br/>   replicas: 1<br/>   template:<br/>      metadata:<br/>         name: hello-world-pod<br/>         labels:<br/>            app: hello-world<br/>      spec:<br/>         containers:<br/>            - name: hello-world<br/>              image: gcr.io/google-samples/hello-app:1.0<br/>              <strong class="lm ir">envFrom:<br/>              - secretRef:<br/>                    name: db-creds</strong></span></pre><p id="913a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以用<code class="fe lw lx ly lm b">kubectl exec -it &lt;pod-name&gt; -- /bin/sh -c 'env'</code>来验证这一点</p><p id="229f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2 </strong>。<strong class="jw ir">挂载一个秘密文件作为卷</strong></p><p id="6ed8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">I)创建样本文件secret-file.txt</p><p id="9434" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ii)创建一个kubernetes秘密对象。秘密的类型应该是不透明的，如上面的例子所示。</p><p id="90dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lw lx ly lm b">kubectl create secret generic <strong class="jw ir">mysecretfile</strong> --from-file=secret-file.txt</code></p><p id="b432" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">iii)创建一个部署，并将这个秘密文件作为一个卷安装到所需的容器中</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="5a7b" class="lq lr iq lm b gy ls lt l lu lv">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>   name: hello-world-deployment-v2<br/>spec:<br/>    selector:<br/>       matchLabels:<br/>           app: hello-world<br/>    replicas: 1<br/>    template:<br/>       metadata:<br/>           name: hello-world-pod<br/>           labels:<br/>              app: hello-world<br/>       spec:<br/>           containers:<br/>               - name: hello-world<br/>                 image: gcr.io/google-samples/hello-app:1.0<br/>                 volumeMounts:<br/>                     - mountPath: <strong class="lm ir">/etc/secrets/</strong><br/>                       name: secret-volume</span><span id="5220" class="lq lr iq lm b gy ml lt l lu lv">           volumes:<br/>               - name: secret-volume<br/>                 secret:<br/>                    secretName: <strong class="lm ir">mysecretfile</strong></span></pre><p id="eeca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果我们执行到容器中，我们应该在/etc/secrets目录中看到该文件。</p><p id="80c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还要注意，如果我们挂载在第一个场景中创建的secret <code class="fe lw lx ly lm b">db-creds</code>,我们应该会看到两个文件/etc/secrets/USERNAME和/etc/secrets/PASSWORD及其相应的值。这意味着对于所有的键-值对，都会创建一个名称等于key的文件。请通过更新上述部署中的<code class="fe lw lx ly lm b">secretName</code>进行尝试。</p></div></div>    
</body>
</html>