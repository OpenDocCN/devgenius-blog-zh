<html>
<head>
<title>Drupal 8 — only save a node when it has changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Drupal 8——仅在节点发生变化时保存节点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/drupal-8-only-save-a-node-when-it-has-changes-babffc6b0dd1?source=collection_archive---------9-----------------------#2020-06-26">https://blog.devgenius.io/drupal-8-only-save-a-node-when-it-has-changes-babffc6b0dd1?source=collection_archive---------9-----------------------#2020-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7a75ee682bc14ae31f832bc491e38279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YfosZymj84KJLDYZ"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d5e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您有一个外部服务(或导入)，它在Drupal中为您处理节点创建/更新。无论您使用队列还是批处理，都没有关系…</p><p id="db5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在很多情况下，您可能会在导入过程中循环遍历所有数据，而不管数据是否已经更改。如果您正在使用的API只提供更改的数据(以任何可能的方式)，那么您很幸运。你可能不需要看这篇文章:)</p><p id="352e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">遍历所有数据和更新现有节点并不重要，因为这些都是在后台进程中完成的，对吗？没错，但是你想过<strong class="kc io">缓存失效吗？</strong></p><p id="7db7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，如果您要使用视图或任何其他(自定义)方式构建概视图来构建任何实体列表，您会希望使用{entity_type}_list <em class="ky"> </em> <a class="ae jz" href="https://www.drupal.org/docs/drupal-apis/cache-api/cache-tags" rel="noopener ugc nofollow" target="_blank">缓存标记</a>。但是每次保存该类型的任何实体时，您的缓存都会失效。有意义，因为，如果你不这样做，概述就会过时。但是，这意味着，如果您的导入机制保存所有节点，没有一个被改变，你是无效的缓存没有任何理由。</p><p id="2d3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">幸运的是，在导入循环中保存节点之前，有一种简单的方法可以检查节点是否发生了变化。我在这里添加了一个示例类向您展示:<a class="ae jz" href="https://github.com/NickDaelemans/drupal-cheat-sheet/blob/master/drupal8/check-if-node-has-changed/check-if-node-changed.php" rel="noopener ugc nofollow" target="_blank">https://github . com/NickDaelemans/Drupal-cheat-sheet/blob/master/Drupal 8/check-if-node-has-changed/check-if-node-changed . PHP</a></p><p id="b65c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们来分解一下。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="0e29" class="li lj in le b gy lk ll l lm ln">public function getFields() {<br/>  return [<br/>    'field_example_body',<br/>    'field_example_title',<br/>  ];<br/>}</span></pre><p id="184f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很容易返回您想要检查节点的字段。通常，这是您在导入逻辑中更新的字段。我们稍后会用到它。</p><p id="448a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看另一个函数</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="da70" class="li lj in le b gy lk ll l lm ln">public function isNodeChanged(NodeInterface $node) {<br/>  $original_node = $this-&gt;entityTypeManager-&gt;getStorage('node')<br/>    -&gt;loadUnchanged($node-&gt;id());<br/><br/>  $fields = $this-&gt;getFields();<br/>  $node_fields = array_intersect_key($node-&gt;toArray(), array_flip($fields));<br/>  $original_node_fields = array_intersect_key($original_node-&gt;toArray(), array_flip($fields));<br/>  return $node_fields !== $original_node_fields;<br/>}</span></pre><p id="e3dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好的理解，我们来分解一下。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="defa" class="li lj in le b gy lk ll l lm ln">$original_node = $this-&gt;entityTypeManager-&gt;getStorage('node')<br/>  -&gt;loadUnchanged($node-&gt;id());</span></pre><p id="ccef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们通过节点ID获得未改变的节点。我们要用这个来检查。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d033" class="li lj in le b gy lk ll l lm ln">$fields = $this-&gt;getFields();</span></pre><p id="5da5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从我们之前创建的函数中获取字段。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="146e" class="li lj in le b gy lk ll l lm ln">$node_fields = array_intersect_key($node-&gt;toArray(), array_flip($fields));</span></pre><p id="5a95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过使用<a class="ae jz" href="https://www.php.net/manual/en/function.array-intersect-key.php" rel="noopener ugc nofollow" target="_blank"> array_intersect_key </a>我们创建了一个数组，其中包含了我们需要的字段的节点更改值(来自getFields()函数)。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="7213" class="li lj in le b gy lk ll l lm ln">$original_node_fields = array_intersect_key($original_node-&gt;toArray(), array_flip($fields));</span></pre><p id="155f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们对未更改的节点进行同样的操作。</p><p id="2375" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后比较它们:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="667e" class="li lj in le b gy lk ll l lm ln">return $node_fields !== $original_node_fields;</span></pre><p id="65e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，您会希望将这些函数放在一个单独类中，并将其定义为一个服务，这样您就可以在需要时包含它。</p><p id="c15d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个用法示例:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="fbb9" class="li lj in le b gy lk ll l lm ln">if ($this-&gt;nodeUtils-&gt;isNodeChanged($node)) {<br/>  $node-&gt;save();<br/>}</span></pre><p id="b34b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！</p></div></div>    
</body>
</html>