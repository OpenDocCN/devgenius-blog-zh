<html>
<head>
<title>Interface Changes in Java 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 8 中的接口变化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/interface-changes-in-java-8-feae3ab6970d?source=collection_archive---------7-----------------------#2022-05-30">https://blog.devgenius.io/interface-changes-in-java-8-feae3ab6970d?source=collection_archive---------7-----------------------#2022-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4c8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们了解一下 java 8 之后的变化</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17c4752fc016ca247b181802ba254f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHPZdN9r9ZnIXTsWFChc9Q.png"/></div></div></figure><p id="5fa3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ku translated">嗨，伙计们！这是下一篇基于<strong class="jm io"> Java 8 特性</strong>的文章。对你来说这是一篇很短的文章。都是 Java 8 以后的接口。</p><p id="1da3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能已经知道了接口..对吗？</p><p id="c44b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常引入接口是为了实现 2️⃣的主要目标。</p><ol class=""><li id="6a1d" class="ld le in jm b jn jo jr js jv lf jz lg kd lh kh li lj lk ll bi translated">实现松耦合实现的完全抽象。</li><li id="5bbb" class="ld le in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">用不同的方式实现多重继承，因为 Java 不支持使用类的多重继承。</li></ol><h1 id="83dc" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">接口方法</h1><ul class=""><li id="6287" class="ld le in jm b jn mp jr mq jv mr jz ms kd mt kh mu lj lk ll bi translated">它们是含蓄的<strong class="jm io">公共抽象</strong></li><li id="22ac" class="ld le in jm b jn lm jr ln jv lo jz lp kd lq kh mu lj lk ll bi translated">没有任何实现(Java 8 之前)</li><li id="081d" class="ld le in jm b jn lm jr ln jv lo jz lp kd lq kh mu lj lk ll bi translated">当任何类实现接口时，它们<strong class="jm io">必须被覆盖</strong></li><li id="6f06" class="ld le in jm b jn lm jr ln jv lo jz lp kd lq kh mu lj lk ll bi translated">发生重写时，访问修饰符必须是公共的(逻辑是重写时访问修饰符需要比抽象方法高一级。因为接口方法在默认情况下是公共的，所以我们必须使用 public)</li></ul></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="7d06" class="lr ls in bd lt lu nc lw lx ly nd ma mb mc ne me mf mg nf mi mj mk ng mm mn mo bi translated">Java 8 有什么新特性？</h1><p id="7eb9" class="pw-post-body-paragraph jk jl in jm b jn mp jp jq jr mq jt ju jv nh jx jy jz ni kb kc kd nj kf kg kh ig bi translated">现在我们有了另一个 2️⃣类型的接口方法…</p><ol class=""><li id="d17b" class="ld le in jm b jn jo jr js jv lf jz lg kd lh kh li lj lk ll bi translated">静态方法</li><li id="e0e8" class="ld le in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">默认方法</li></ol><p id="3459" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一个一个地了解它们。</p><h1 id="3e99" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">静态方法</h1><p id="a96a" class="pw-post-body-paragraph jk jl in jm b jn mp jp jq jr mq jt ju jv nh jx jy jz ni kb kc kd nj kf kg kh ig bi translated">如果我们希望在我们的接口中有一个方法，它不能在派生类中被重写，那么我们可以使用一个接口。按照惯例，在 Java 中我们不能覆盖静态方法。这几乎就像一个<strong class="jm io"> <em class="nk">实用方法</em> </strong>。并且您可以在没有对象 实例的情况下<strong class="jm io"> <em class="nk">使用该方法，因为它是静态的。我们可以使用静态方法根据类的属性执行一些逻辑。</em></strong></p><p id="728a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我举个例子…</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e44e" class="nq ls in nm b gy nr ns l nt nu">public class java8Interfaces {<br/>    public static void main(String[] args) {<br/>        Car car = new Lamborghini("Lambo", "2010");<br/>        car.drive();<br/>        String condition = Car.<em class="nk">getCondition</em>(car.getCarType());<br/>        System.out.println(condition);<br/>    }<br/>}<br/><br/>class Lamborghini extends BaseCar implements Car {<br/>    Lamborghini(String name, String year) {<br/>        super(name, year);<br/>    }<br/>    @Override<br/>    public void drive() {<br/>        System.out.println("Lamborghini::drive()");<br/>    }<br/>    @Override<br/>    public String getCarType() {<br/>        return "Lamborghini";<br/>    }<br/>}<br/><br/>class Corolla extends BaseCar implements Car {<br/>    Corolla(String name, String year) {<br/>        super(name, year);<br/>    }<br/>    @Override<br/>    public void drive() {<br/>        System.out.println("Ferrari::drive()");<br/>    }<br/>    @Override<br/>    public String getCarType() {<br/>        return "Ferrari";<br/>    }<br/>}<br/><br/>class BaseCar {<br/>    private final String name;<br/>    private final String year;<br/>    BaseCar(String name, String year) {<br/>        this.name = name;<br/>        this.year = year;<br/>    }<br/>    public String getName() {<br/>        return name;<br/>    }<br/>    public String getYear() {<br/>        return year;<br/>    }<br/>}<br/><br/>interface Car {<br/>    void drive();<br/>    String getCarType();<br/>    static String getCondition(String name) {<br/>        String condition;<br/>        if (name.equals("Lamborghini")) {<br/>            condition = "Sports Car";<br/>        } else {<br/>            condition = "Normal Car";<br/>        }<br/>        return condition;<br/>    }<br/>}</span></pre><p id="033c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在这里看到的，<strong class="jm io"> getCondition </strong>方法是根据定义的汽车类型执行通用逻辑的方法。这更像是一种实用的方法！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4e91f129ca079d3f5fac8881d4e402fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzdlGhLj12eKAoDEj5xP3g.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">静态方法的结果</figcaption></figure></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="3553" class="lr ls in bd lt lu nc lw lx ly nd ma mb mc ne me mf mg nf mi mj mk ng mm mn mo bi translated">默认方法</h1><p id="f4a4" class="pw-post-body-paragraph jk jl in jm b jn mp jp jq jr mq jt ju jv nh jx jy jz ni kb kc kd nj kf kg kh ig bi translated">因此，在 Java 8 之前，当我们用一个接口实现一个类时，我们必须实现所有的方法。</p><blockquote class="oa ob oc"><p id="f358" class="jk jl nk jm b jn jo jp jq jr js jt ju od jw jx jy oe ka kb kc of ke kf kg kh ig bi translated">当我们通过继承为接口中所有派生类提供一个公共方法时，会发生什么？</p></blockquote><p id="3a1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，我们必须重写公共方法，即使实现总是公共的！这导致了派生类中的代码重复！！！</p><p id="e9b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我举个例子…</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="15e2" class="nq ls in nm b gy nr ns l nt nu">public class java8Interfaces {<br/>    public static void main(String[] args) {<br/>        Car car1 = new Lamborghini("Lambo", "2010");<br/>        car1.drive();<br/>        car1.showInfo();<br/>        Car car2 = new Corolla("Corolla", "2015");<br/>        car2.drive();<br/>        car1.showInfo();<br/>    }<br/>}<br/><br/>class Lamborghini extends BaseCar implements Car {<br/>    Lamborghini(String name, String year) {<br/>        super(name, year);<br/>    }<br/>    @Override<br/>    public void drive() {<br/>        System.out.println("Lamborghini::drive()");<br/>    }<br/>    @Override<br/>    public String getCarType() {<br/>        return "Lamborghini";<br/>    }<br/>}<br/><br/>class Corolla extends BaseCar implements Car {<br/>    Corolla(String name, String year) {<br/>        super(name, year);<br/>    }<br/>    @Override<br/>    public void drive() {<br/>        System.out.println("Ferrari::drive()");<br/>    }<br/>    @Override<br/>    public String getCarType() {<br/>        return "Ferrari";<br/>    }<br/>}<br/><br/>class BaseCar {<br/>    private final String name;<br/>    private final String year;<br/>    BaseCar(String name, String year) {<br/>        this.name = name;<br/>        this.year = year;<br/>    }<br/>    public String getName() {<br/>        return name;<br/>    }<br/>    public String getYear() {<br/>        return year;<br/>    }<br/>}<br/><br/>interface Car {<br/>    void drive();<br/>    String getCarType();<br/>    default void showInfo() {<br/>        System.out.println("Car has 4 wheels!");<br/>    }<br/>}</span></pre><p id="4360" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以看到<strong class="jm io"> showInfo() </strong>方法可以使用任何派生类类型来调用。这里，car1 是一辆兰博基尼，car2 是一辆卡罗拉……但是，使用对象引用，我们可以访问默认的方法实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/180739eb6c8db709988bfa06989138dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oX0m-h2z6j2cLQ8b6kZolQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">默认方法的结果</figcaption></figure></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="b4c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这都是 Java 8 中的接口变化！希望你明白了…这不是一个很大的变化。但它会根据我们的要求以某种方式帮助我们。</p><p id="f564" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阅读和分享家伙！！！</p></div></div>    
</body>
</html>