<html>
<head>
<title>7 Advanced C++ Concepts You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的 7 个高级 C++概念</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-advanced-c-concepts-you-should-know-78a5f9134be5?source=collection_archive---------0-----------------------#2019-12-09">https://blog.devgenius.io/7-advanced-c-concepts-you-should-know-78a5f9134be5?source=collection_archive---------0-----------------------#2019-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bda92d922629bf961efd7c69f9bbb892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DCIDUl7g_QxTZcNk-MSQw.png"/></div></div></figure><p id="612f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我不久前开始用现代 C++更新自己&amp;自从我的帖子<a class="ae kt" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank"> 21 个现代 C++的新特性用于你的项目</a> &amp; <a class="ae kt" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">所有关于 C++中的 lambda 函数</a>很受欢迎以来，我决定写一些关于高级 C++概念&amp;的习惯用法，这是我从这个<a class="ae kt" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" rel="noopener ugc nofollow" target="_blank"> wikibook </a> &amp; <a class="ae kt" href="https://www.udemy.com/course/cpp-in-detail-common-idioms/" rel="noopener ugc nofollow" target="_blank">课程</a>中学到的。</p><blockquote class="ku kv kw"><p id="8720" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kt" href="http://www.vishalchovatiya.com/" rel="noopener ugc nofollow" target="_blank"><em class="in">www.vishalchovatiya.com</em></a><em class="in">。</em></p></blockquote><p id="ec18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有许多其他高级 C++概念和习惯用法，但我认为这 7 个是“应该知道的”。为了解释它们，我采取了一种比复杂更务实的方法。并且更注重可读性、简单性而不是其他花哨的功能、语法糖和复杂性。</p><p id="7562" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">注:</em> </strong>使用这些技术也有一些缺点，我在这里没有讨论，或者也许我不够资格。</p><h1 id="301e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.拉伊</h1><p id="eec0" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>保证在一个作用域结束时释放资源。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>将资源包装成一个类；在分配后立即在构造函数中获取的资源；在析构函数中自动释放；通过类的接口使用的资源；<br/> <strong class="jx io"> <em class="kx">也称为:</em> </strong>执行-环绕对象，资源释放是终结化，范围限制的资源管理</p><h2 id="2e13" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">问题</h2><ul class=""><li id="7c48" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated"><strong class="jx io">R</strong>esource<strong class="jx io">A</strong>acquisition<strong class="jx io">I</strong>s<strong class="jx io">I</strong>initialization 习语是最强大的&amp;广泛使用的习语虽然这个名字真的很可怕，因为习语更多的是关于资源释放而不是获取。</li><li id="f341" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">RAII 保证在范围/销毁结束时释放资源。从而确保没有资源泄漏，并提供基本的<a class="ae kt" href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">异常安全保证</a>。</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c495" class="me lc in nj b gy nn no l np nq">struct resource<br/>{<br/>    resource(int x, int y) { cout &lt;&lt; "resource acquired\n"; }<br/>    ~resource() { cout &lt;&lt; "resource destroyed\n"; }<br/>};</span><span id="d867" class="me lc in nj b gy nr no l np nq">void func()<br/>{<br/>    resource *ptr = new resource(1, 2);<br/>    int x;<br/>    std::cout &lt;&lt; "Enter an integer: ";<br/>    std::cin &gt;&gt; x;<br/>    if (x == 0)<br/>        throw 0; // the function returns early, and ptr won't be deleted!<br/>    if (x &lt; 0)<br/>        return; // the function returns early, and ptr won't be deleted!<br/>    // do stuff with ptr here<br/>    delete ptr;<br/>}</span></pre><ul class=""><li id="42d7" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">在上面的代码中，早期的<code class="fe nv nw nx nj b">return</code>或<code class="fe nv nw nx nj b">throw</code>语句，导致函数在<code class="fe nv nw nx nj b">ptr</code>没有被删除的情况下终止。</li><li id="4fc0" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">因此，为变量<code class="fe nv nw nx nj b">ptr</code>分配的内存现在被泄漏了(并且每次调用该函数并提前返回时都会再次泄漏)。</li></ul><h2 id="9ff2" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f92c" class="me lc in nj b gy nn no l np nq">template&lt;class T&gt;<br/>class smart_ptr<br/>{<br/>    T* m_ptr;<br/>public:<br/>    template&lt;typename... Args&gt;<br/>    smart_ptr(Args&amp;&amp;... args) : m_ptr(new T(std::forward&lt;Args&gt;(args)...)){}<br/>    ~smart_ptr() { delete m_ptr; }</span><span id="2e4e" class="me lc in nj b gy nr no l np nq">    smart_ptr(const smart_ptr&amp; rhs) = delete;<br/>    smart_ptr&amp; operator=(const smart_ptr&amp; rhs) = delete;</span><span id="f3b3" class="me lc in nj b gy nr no l np nq">    smart_ptr(smart_ptr&amp;&amp; rhs) : m_ptr(exchange(rhs.m_ptr, nullptr)){}<br/>    smart_ptr&amp; operator=(smart_ptr&amp;&amp; rhs){        <br/>        if (&amp;rhs == this) return *this;<br/>        delete m_ptr;<br/>        m_ptr = exchange(rhs.m_ptr,nullptr);<br/>        return *this;<br/>    }<br/>    T&amp; operator*() const { return *m_ptr; }<br/>    T* operator-&gt;() const { return m_ptr; }<br/>};</span><span id="d0a2" class="me lc in nj b gy nr no l np nq">void func()<br/>{<br/>    auto ptr = smart_ptr&lt;resource&gt;(1, 2); // now ptr guarantee the release of resource<br/>    // ...<br/>}</span></pre><ul class=""><li id="37ba" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">注意，无论<code class="fe nv nw nx nj b">ptr</code>声明后发生什么，<code class="fe nv nw nx nj b">ptr</code>都会在函数终止时被销毁(不管它是如何终止的)。</li><li id="8951" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">由于<code class="fe nv nw nx nj b">ptr</code>是一个局部<a class="ae kt" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">对象</a>，当<a class="ae kt" href="http://www.vishalchovatiya.com/how-c-program-convert-into-assembly/" rel="noopener ugc nofollow" target="_blank">函数堆栈帧</a>回退时，将调用析构函数。因此，我们确信<code class="fe nv nw nx nj b">resource</code>将被妥善清理。</li></ul><h2 id="54d7" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="d2b9" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">使用 RAII，像<code class="fe nv nw nx nj b">new</code> / <code class="fe nv nw nx nj b">delete</code>、<code class="fe nv nw nx nj b">malloc</code> / <code class="fe nv nw nx nj b">free</code>这样的资源、获取/释放、互斥锁/解锁、文件打开/关闭、计数<code class="fe nv nw nx nj b">++</code> / <code class="fe nv nw nx nj b">--</code>、数据库连接/断开或其他任何存在于有限供应中的资源都可以很容易地被管理。</li><li id="92e8" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">来自 C++标准库的例子有<code class="fe nv nw nx nj b"><a class="ae kt" href="http://www.vishalchovatiya.com/understanding-unique-ptr-with-example-in-cpp11/" rel="noopener ugc nofollow" target="_blank">std::unique_ptr</a></code>、<code class="fe nv nw nx nj b">std::ofstream</code>、<code class="fe nv nw nx nj b">std::lock_guard</code>等。</li></ul><h1 id="cb58" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.返回类型解析器</h1><p id="af36" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>推断被初始化或赋值的对象的类型。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>使用模板化的转换运算符。<br/> <strong class="jx io"> <em class="kx">又称:</em> </strong>返回式重载</p><h2 id="8e68" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">问题</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3e95" class="me lc in nj b gy nn no l np nq">int from_string(const char *str) { return std::stoi(str); }<br/>float from_string(const char *str) { return std::stof(str); } // error</span></pre><ul class=""><li id="ab9d" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">一个函数不能只通过它的返回类型来重载。</li></ul><h2 id="7c5c" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f4ec" class="me lc in nj b gy nn no l np nq">class from_string<br/>{<br/>    const string m_str;<br/>public:<br/>    from_string(const char *str) : m_str(str) {}<br/>    template &lt;typename type&gt;<br/>    operator type(){<br/>        if constexpr(is_same_v&lt;type, float&gt;)        return stof(m_str);<br/>        else if (is_same_v&lt;type, int&gt;)              return stoi(m_str);<br/>    }<br/>};</span><span id="d075" class="me lc in nj b gy nr no l np nq">int n_int = from_string("123");<br/>float n_float = from_string("123.111");<br/>// Will only work with C++17 due to `is_same_v`</span></pre><p id="79d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不知道 constexpr，我已经在<a class="ae kt" href="http://www.vishalchovatiya.com/when-to-use-const-vs-constexpr-in-cpp/" rel="noopener ugc nofollow" target="_blank">上写了一篇关于 c++中什么时候使用 const vs constexpr 的短文</a>。</p><h2 id="f34f" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="2809" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">当您使用<code class="fe nv nw nx nj b"><a class="ae kt" href="http://www.vishalchovatiya.com/what-exactly-nullptr-is-in-cpp/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">nullptr</strong></a></code>(在 C++11 中引入)时，这是一种在幕后运行的技术，根据它所赋给的指针变量来推断正确的类型。</li><li id="8797" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">正如我们在上面看到的，你也可以在返回类型的基础上克服函数重载的限制。</li><li id="6c2d" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">返回类型解析器也可以用来为<a class="ae kt" href="http://www.vishalchovatiya.com/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">赋值</a>提供一个通用接口，独立于被赋值的对象。</li></ul><h1 id="68ab" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.类型擦除</h1><p id="262a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>创建可以处理各种具体类型的通用容器。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>可以通过<code class="fe nv nw nx nj b">void*</code>、模板、多态、联合、代理类等实现。<br/> <strong class="jx io"> <em class="kx">又名:鸭式打字</em> </strong></p><h2 id="3087" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">问题</h2><ul class=""><li id="e5f5" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">C++是一种<a class="ae kt" href="http://www.vishalchovatiya.com/cpp-type-casting-with-example-for-c-developers/" rel="noopener ugc nofollow" target="_blank">静态类型的</a>语言，具有强类型。在静态类型语言中，已知的对象类型&amp;在编译时设置。而在动态类型语言中，类型与运行时值相关联。</li><li id="ebe8" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">在强类型语言中，对象的类型在编译后不会改变。</li><li id="8ac9" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">为了克服这个限制&amp;提供一个类似动态类型语言的特性，库设计者想出了各种通用容器类的东西，比如<code class="fe nv nw nx nj b"><a class="ae kt" href="https://en.cppreference.com/w/cpp/utility/any" rel="noopener ugc nofollow" target="_blank">std::any</a></code> (C++17)、<code class="fe nv nw nx nj b"><a class="ae kt" href="https://en.cppreference.com/w/cpp/utility/variant" rel="noopener ugc nofollow" target="_blank">std::variant</a></code> (C++17)、<code class="fe nv nw nx nj b"><a class="ae kt" href="https://en.cppreference.com/w/cpp/utility/functional/function" rel="noopener ugc nofollow" target="_blank">std::function</a></code> (C++11)，等等。</li></ul><h2 id="5b00" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">不同类型的擦除技术</h2><ul class=""><li id="e7e4" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">对于如何实现这种习语，没有一个严格的规则，它可以有各种各样的形式，但都有以下缺点:</li></ul><p id="410e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> = &gt;使用 void*(类似于 C 中的)类型擦除</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="96fc" class="me lc in nj b gy nn no l np nq">void qsort (void* base, size_t num, size_t size,<br/>            int (*compare)(const void*,const void*));</span></pre><p id="fe1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx">缺点:</em>不安全&amp;每种类型需要单独的比较功能</p><p id="925a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> = &gt;使用模板类型擦除</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2619" class="me lc in nj b gy nn no l np nq">template &lt;class RandomAccessIterator&gt;<br/>  void sort(RandomAccessIterator first, RandomAccessIterator last);</span></pre><p id="9654" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx">缺点:</em>可能导致许多函数模板实例化&amp;编译时间变长</p><p id="65ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> = &gt;使用多态性类型擦除</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e858" class="me lc in nj b gy nn no l np nq">struct base { virtual void method() = 0; };<br/>struct derived_1 : base { void method() { cout &lt;&lt; "derived_1\n"; } };<br/>struct derived_2 : base { void method() { cout &lt;&lt; "derived_2\n"; } };<br/>// We don't see a concrete type (it's erased) though can dynamic_cast<br/>void call(base* ptr) { ptr-&gt;method(); };</span></pre><p id="01ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx">缺点:</em>运行时开销(动态分派、间接、vtable 等。)</p><p id="f23d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> = &gt;使用 union 类型擦除</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="cd06" class="me lc in nj b gy nn no l np nq">struct Data {};<br/>union U {<br/>    Data d;         // occupies 1 byte<br/>    std::int32_t n; // occupies 4 bytes<br/>    char c;         // occupies 1 byte<br/>    ~U() {}         // need to know currently active type<br/>}; // an instance of U in total occupies 4 bytes.</span></pre><p id="9108" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx">缺点:</em>不是<a class="ae kt" href="http://www.vishalchovatiya.com/cpp-type-casting-with-example-for-c-developers/" rel="noopener ugc nofollow" target="_blank">类型安全</a></p><h2 id="bdfd" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><ul class=""><li id="9fab" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">正如我前面提到的，标准库已经有了这样的通用容器。</li><li id="f373" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">为了更好地理解类型擦除，让我们实现一个类似<code class="fe nv nw nx nj b">std::any</code>的例子:</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="001e" class="me lc in nj b gy nn no l np nq">struct any <br/>{<br/>    struct base {};</span><span id="d1ea" class="me lc in nj b gy nr no l np nq">    template&lt;typename T&gt;<br/>    struct inner: base{<br/>        inner(T t): m_t{std::move(t)} {}<br/>        T m_t;<br/>        static void type() {}<br/>    };</span><span id="fd3c" class="me lc in nj b gy nr no l np nq">    any(): m_ptr{nullptr}, typePtr{nullptr} {}<br/>    template&lt;typename T&gt;<br/>    any(T &amp;&amp; t): m_ptr{std::make_unique&lt;inner&lt;T&gt;&gt;(t)}, typePtr{&amp;inner&lt;T&gt;::type} {}<br/>    template&lt;typename T&gt;<br/>    any&amp; operator=(T&amp;&amp; t){<br/>        m_ptr = std::make_unique&lt;inner&lt;T&gt;&gt;(t); <br/>        typePtr = &amp;inner&lt;T&gt;::type;<br/>        return *this;<br/>    }<br/>private:<br/>    template&lt;typename T&gt;<br/>    friend T&amp; any_cast(const any&amp; var);</span><span id="d487" class="me lc in nj b gy nr no l np nq">    std::unique_ptr&lt;base&gt; m_ptr = nullptr;<br/>    void (*typePtr)() = nullptr;<br/>};<br/>template&lt;typename T&gt;<br/>T&amp; any_cast(const any&amp; var)<br/>{<br/>    if(var.typePtr == any::inner&lt;T&gt;::type)<br/>        return static_cast&lt;any::inner&lt;T&gt;*&gt;(var.m_ptr.get())-&gt;m_t;<br/>    throw std::logic_error{"Bad cast!"};<br/>}<br/>int main()<br/>{<br/>    any var(10);<br/>    std::cout &lt;&lt; any_cast&lt;int&gt;(var) &lt;&lt; std::endl;<br/>    var = std::string{"some text"};<br/>    std::cout &lt;&lt; any_cast&lt;std::string&gt;(var) &lt;&lt; std::endl;<br/>    return 0;<br/>}</span></pre><p id="5f7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特别是，这里要注意的是我们如何利用空静态方法，即<code class="fe nv nw nx nj b">inner&lt;T&gt;::type()</code>来确定<code class="fe nv nw nx nj b">any_cast&lt;T&gt;</code>中的模板实例类型。</p><h2 id="1156" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="4abb" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">采用处理来自函数/方法的多种类型的返回值(尽管这不是推荐的建议)。</li></ul><h1 id="aceb" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.CRTP</h1><p id="3eb6" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>实现静态多态性。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>利用基类模板专门化。<br/> <strong class="jx io"> <em class="kx">又称:</em> </strong>颠倒遗传，静态多态</p><h2 id="abf7" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">问题</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="7f18" class="me lc in nj b gy nn no l np nq">struct obj_type_1<br/>{<br/>    bool operator&lt;(const value &amp;rhs) const {return m_x &lt; rhs.m_x;}<br/>    // bool operator==(const value &amp;rhs) const;<br/>    // bool operator!=(const value &amp;rhs) const;    <br/>    // List goes on. . . . . . . . . . . . . . . . . . . .<br/>private:<br/>    // data members to compare<br/>};</span><span id="697e" class="me lc in nj b gy nr no l np nq">struct obj_type_2<br/>{<br/>    bool operator&lt;(const value &amp;rhs) const {return m_x &lt; rhs.m_x;}<br/>    // bool operator==(const value &amp;rhs) const;<br/>    // bool operator!=(const value &amp;rhs) const;    <br/>    // List goes on. . . . . . . . . . . . . . . . . . . .<br/>private:<br/>    // data members to compare<br/>};</span><span id="3523" class="me lc in nj b gy nr no l np nq">struct obj_type_3 { ...<br/>struct obj_type_4 { ...<br/>// List goes on. . . . . . . . . . . . . . . . . . . .</span></pre><ul class=""><li id="4b6e" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">对于每个可比较的对象，您需要定义各自的比较运算符。这是多余的，因为如果我们有一个<code class="fe nv nw nx nj b">operator &lt;</code>，我们可以在它的基础上重载其他操作符。</li><li id="eb53" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">因此，<code class="fe nv nw nx nj b">operator &lt;</code>是唯一一个具有类型信息的操作符，出于可重用性的目的，其他操作符可以是类型独立的。</li></ul><h2 id="453b" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><ul class=""><li id="4c75" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated"><strong class="jx io"> C </strong>精心<strong class="jx io"> R </strong>确保<strong class="jx io"> T </strong> emplate <strong class="jx io"> P </strong>模式实现规则简单，<strong class="jx io"> <em class="kx">分离出依赖类型的&amp;独立功能，并使用模板专门化</em> </strong>将类型 <em class="kx">独立功能与基类绑定。</em></li><li id="61ad" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">第一行可能看起来很神秘。因此，为了更清楚起见，考虑上述问题的以下解决方案:</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="574c" class="me lc in nj b gy nn no l np nq">template&lt;class derived&gt;<br/>struct compare {};<br/>struct value : public compare&lt;value&gt; <br/>{<br/>    value(const int x): m_x(x) {}<br/>    bool operator&lt;(const value &amp;rhs) const { return m_x &lt; rhs.m_x; }<br/>private:<br/>    int m_x;<br/>};</span><span id="b77a" class="me lc in nj b gy nr no l np nq">template &lt;class derived&gt;<br/>bool operator&gt;(const compare&lt;derived&gt; &amp;lhs, const compare&lt;derived&gt; &amp;rhs) {<br/>    // static_assert(std::is_base_of_v&lt;compare&lt;derived&gt;, derived&gt;); // Compile time safety measures<br/>    return (static_cast&lt;const derived&amp;&gt;(rhs) &lt; static_cast&lt;const derived&amp;&gt;(lhs));<br/>}</span><span id="3dbb" class="me lc in nj b gy nr no l np nq">/*  Same goes with other operators<br/> == :: returns !(lhs &lt; rhs) and !(rhs &lt; lhs)<br/> != :: returns !(lhs == rhs)<br/> &gt;= :: returns (rhs &lt; lhs) or (rhs == lhs)<br/> &lt;= :: returns (lhs &lt; rhs) or (rhs == lhs) <br/>*/</span><span id="0f2d" class="me lc in nj b gy nr no l np nq">int main()<br/>{   <br/>    value v1{5}, v2{10};<br/>    cout &lt;&lt;boolalpha&lt;&lt; "v1 == v2: " &lt;&lt; (v1 &gt; v2) &lt;&lt; '\n';<br/>    return 0;<br/>}<br/>// Now no need to write comparator operators for all the classes, <br/>// Write only type dependent `operator &lt;` &amp;  use CRTP</span></pre><h2 id="f7ce" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="558a" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">CRTP 广泛应用于静态多态，无需承担虚拟调度机制的成本。考虑下面的代码，我们没有使用虚拟关键字，但仍然实现了多态性的功能(特别是静态多态性)。</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f148" class="me lc in nj b gy nn no l np nq">template&lt;typename specific_animal&gt;<br/>struct animal {<br/>    void who() { implementation().who(); }<br/>private:<br/>    specific_animal&amp; implementation() {return *static_cast&lt;specific_animal*&gt;(this);}<br/>};</span><span id="c895" class="me lc in nj b gy nr no l np nq">struct dog : public animal&lt;dog&gt; {<br/>    void who() { cout &lt;&lt; "dog" &lt;&lt; endl; }<br/>};</span><span id="cc93" class="me lc in nj b gy nr no l np nq">struct cat : public animal&lt;cat&gt; {<br/>    void who() { cout &lt;&lt; "cat" &lt;&lt; endl; }<br/>};</span><span id="5bf6" class="me lc in nj b gy nr no l np nq">template&lt;typename specific_animal&gt;<br/>void who_am_i(animal&lt;specific_animal&gt; &amp; animal) {<br/>    animal.who();<br/>}</span></pre><ul class=""><li id="73f5" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">正如我们在上面看到的，CRTP 也可以用于优化，它还支持代码重用。</li></ul><p id="34b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新:通过使用<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/default_comparisons" rel="noopener ugc nofollow" target="_blank">飞船</a>(<code class="fe nv nw nx nj b">&lt;=&gt;</code>/<a class="ae kt" href="https://en.wikipedia.org/wiki/Three-way_comparison" rel="noopener ugc nofollow" target="_blank">三向比较运算符</a>，上述声明多重比较运算符的问题将从 C++20 中永久排序。</p><h1 id="e196" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5.虚拟构造函数</h1><p id="ed01" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>在不知道其具体类型的情况下，创建一个副本或新对象。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>利用多态赋值利用重载方法。<br/> <strong class="jx io"> <em class="kx">又称:</em> </strong>工厂方法/设计模式。</p><h2 id="aa60" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">问题</h2><ul class=""><li id="9ade" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">C++使用基类的<a class="ae kt" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>支持多态对象析构。缺少对创建和复制对象的等效支持，因为с++不支持虚拟构造函数、<a class="ae kt" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a>。</li><li id="2b26" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">此外，除非知道对象的静态类型，否则无法创建对象，因为编译器必须知道它需要分配的空间量。出于同样的原因，复制一个对象也需要在编译时知道它的类型。</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="762c" class="me lc in nj b gy nn no l np nq">struct animal {<br/>    virtual ~animal(){ cout&lt;&lt;"~animal\n"; }<br/>};</span><span id="c1ad" class="me lc in nj b gy nr no l np nq">struct dog : animal {<br/>    ~dog(){ cout&lt;&lt;"~dog\n"; }<br/>};</span><span id="be68" class="me lc in nj b gy nr no l np nq">struct cat : animal {<br/>    ~cat(){ cout&lt;&lt;"~cat\n"; }<br/>};</span><span id="e5f1" class="me lc in nj b gy nr no l np nq">void who_am_i(animal *who) { // not sure whether dog would be passed here or cat<br/>    // How to `create` the object of same type i.e. pointed by who ?<br/>    // How to `copy` object of same type i.e. pointed by who ?<br/>    delete who; // you can delete object pointed by who<br/>}</span></pre><h2 id="26bd" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><ul class=""><li id="0206" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">虚拟构造函数技术通过使用虚拟方法将创建和复制对象的动作委托给派生类，从而允许在 C++中多态地创建和复制对象。</li><li id="b328" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">下面的代码不仅实现了虚拟构造函数(即<code class="fe nv nw nx nj b">create()</code>)，还实现了虚拟<a class="ae kt" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a>(即<code class="fe nv nw nx nj b">clone()</code>)。</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d370" class="me lc in nj b gy nn no l np nq">struct animal {<br/>    virtual ~animal() = default;<br/>    virtual std::unique_ptr&lt;animal&gt; create() = 0;<br/>    virtual std::unique_ptr&lt;animal&gt; clone() = 0;<br/>};</span><span id="4c45" class="me lc in nj b gy nr no l np nq">struct dog : animal {<br/>    std::unique_ptr&lt;animal&gt; create() { return std::make_unique&lt;dog&gt;(); }<br/>    std::unique_ptr&lt;animal&gt; clone() { return std::make_unique&lt;dog&gt;(*this); }<br/>};</span><span id="49b7" class="me lc in nj b gy nr no l np nq">struct cat : animal {<br/>    std::unique_ptr&lt;animal&gt; create() { return std::make_unique&lt;cat&gt;(); }<br/>    std::unique_ptr&lt;animal&gt; clone() { return std::make_unique&lt;cat&gt;(*this); }<br/>};</span><span id="2b66" class="me lc in nj b gy nr no l np nq">void who_am_i(animal *who) {<br/>    auto new_who = who-&gt;create();// `create` the object of same type i.e. pointed by who ?<br/>    auto duplicate_who = who-&gt;clone(); // `copy` object of same type i.e. pointed by who ?    <br/>    delete who; // you can delete object pointed by who<br/>}</span></pre><h2 id="b789" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="ace4" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">提供一个通用接口，只使用一个类来生成/复制各种类。</li></ul><h1 id="b03f" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">6.SFINAE 和 std::enable_if</h1><p id="6a5a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>从一组重载函数中过滤出不能产生有效模板实例化的函数。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>由编译器自动实现或使用 std::enable_if 利用。<br/> <strong class="jx io"> <em class="kx">又名:</em> </strong></p><h2 id="6965" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">动机</h2><ul class=""><li id="43fc" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated"><strong class="jx io">S</strong>substitution<strong class="jx io">F</strong>failure<strong class="jx io">I</strong>S<strong class="jx io">N</strong>ot<strong class="jx io">A</strong>N<strong class="jx io">E</strong>error 是 C++编译器在重载解析过程中用来过滤掉一些模板化函数重载的语言特性(不是习语)。</li><li id="dbe7" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">在函数模板的重载解析过程中，当用显式指定或推导的类型替换模板参数失败时，专用化将从重载集中丢弃，而不是导致编译错误。</li><li id="2823" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">当类型或表达式格式不良时，会发生替换失败。</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="bcca" class="me lc in nj b gy nn no l np nq">template&lt;class T&gt;<br/>void func(T* t){ // Single overload set<br/>    if constexpr(std::is_class_v&lt;T&gt;){ cout &lt;&lt; "T is user-defined type\n"; }<br/>    else { cout &lt;&lt; "T is primitive type\n"; }<br/>}</span><span id="a8a9" class="me lc in nj b gy nr no l np nq">int primitive_t = 6;<br/>struct {char var = '4';} class_t;<br/></span><span id="d08f" class="me lc in nj b gy nr no l np nq">func(&amp;class_t);<br/>func(&amp;primitive_t);</span></pre><ul class=""><li id="2c95" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">我们如何创建两组(分别基于原始类型和用户定义类型)具有相同签名的函数？</li></ul><h2 id="4468" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">解决办法</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1323" class="me lc in nj b gy nn no l np nq">template&lt;class T, typename = std::enable_if_t&lt;std::is_class_v&lt;T&gt;&gt;&gt;<br/>void func(T* t){<br/>    cout &lt;&lt; "T is user-defined type\n";<br/>}</span><span id="8d7b" class="me lc in nj b gy nr no l np nq">template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt; = 0&gt;<br/>void func(T* t){ // NOTE: function signature is NOT-MODIFIED<br/>    cout &lt;&lt; "T is primitive type\n";<br/>}</span></pre><ul class=""><li id="d697" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">上面的代码片段是一个使用<code class="fe nv nw nx nj b">std::enable_if</code>利用 SFINAE 的简短示例，其中第一个模板实例化将等同于<code class="fe nv nw nx nj b">void func&lt;(anonymous), void&gt;((anonymous) * t)</code>，第二个等同于<code class="fe nv nw nx nj b">void func(int * t)</code>。</li><li id="47d0" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">以上<code class="fe nv nw nx nj b">std::enable_if</code> <a class="ae kt" href="https://en.cppreference.com/w/cpp/types/enable_if" rel="noopener ugc nofollow" target="_blank">你可以在这里</a>阅读更多。</li></ul><h2 id="a72b" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="3dc2" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">SFINAE 和<code class="fe nv nw nx nj b">std::enable_if</code>一起被大量用于模板元编程。</li><li id="b652" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">标准库也在大多数<a class="ae kt" href="https://en.cppreference.com/w/cpp/header/type_traits" rel="noopener ugc nofollow" target="_blank"> type_traits </a>实用程序中利用了 SFINAE。请考虑以下情况:</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="59be" class="me lc in nj b gy nn no l np nq">// Stolen &amp; trimmed from https://stackoverflow.com/questions/982808/c-sfinae-examples.<br/>template&lt;typename T&gt;<br/>class is_class_type {<br/>    template&lt;typename C&gt; static char test(int C::*);    <br/>    template&lt;typename C&gt; static double test(...);<br/>public:<br/>    enum { value = sizeof(is_class_type&lt;T&gt;::test&lt;T&gt;(0)) == sizeof(char) };<br/>};</span><span id="7071" class="me lc in nj b gy nr no l np nq">struct class_t{};</span><span id="9589" class="me lc in nj b gy nr no l np nq">int main()<br/>{<br/>    cout&lt;&lt;is_class_type&lt;class_t&gt;::value&lt;&lt;endl;    // 1<br/>    cout&lt;&lt;is_class_type&lt;int&gt;::value&lt;&lt;endl;        // 0<br/>    return 0;<br/>}</span></pre><ul class=""><li id="5fd3" class="mq mr in jx b jy jz kc kd kg ns kk nt ko nu ks mv mw mx my bi translated">如果没有 SFINAE，你会得到一个编译器错误，比如“<code class="fe nv nw nx nj b">0</code>不能被转换为非类类型<code class="fe nv nw nx nj b">int</code>的成员指针，因为<code class="fe nv nw nx nj b">test</code>的重载仅仅在返回类型上有所不同。</li><li id="3e41" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">因为<code class="fe nv nw nx nj b">int</code>不是一个类，所以它不能有<code class="fe nv nw nx nj b">int int::*</code>类型的成员指针。</li></ul><h1 id="24a0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">7.代理人</h1><p id="3d89" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">意图:</em> </strong>利用中间件类实现直观的功能。<br/> <strong class="jx io"> <em class="kx">实现:</em> </strong>通过使用临时/代理类。<br/> <strong class="jx io"> <em class="kx">又称:</em> </strong> <code class="fe nv nw nx nj b">operator []</code>(即下标)代理，双/两次运算符重载</p><h2 id="7877" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">动机</h2><ul class=""><li id="3da4" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">大多数开发人员认为这仅仅是关于下标操作符(即<code class="fe nv nw nx nj b">operator[ ]</code>)，但我认为交换数据之间的类型是代理。</li><li id="5b23" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">我们已经在上面的<a class="ae kt" href="https://dev.to/visheshpatel/7-advanced-c-concepts-you-should-know-112e-temp-slug-4165128?preview=2b7d6aff272f3802f6f81519c40d6dbab56dcb9fbdaba14b0b4f6df9297afebf5cc662a1dfdedd09d6680942d22043cb9b9c549f84958887c605ab9e#Type-Eraser" rel="noopener ugc nofollow" target="_blank">类型擦除</a>(即类<code class="fe nv nw nx nj b">any::inner&lt;&gt;</code>)中间接看到了这个习语的一个很好的例子。但是，我仍然认为再举一个例子会增加我们理解的具体性。</li></ul><h2 id="3459" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">运算符[ ]解决方案</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ad1e" class="me lc in nj b gy nn no l np nq">template &lt;typename T = int&gt;<br/>struct arr2D{<br/>private:<br/>    struct proxy_class{<br/>        proxy_class(T *arr) : m_arr_ptr(arr) {}<br/>        T &amp;operator[](uint32_t idx) { return m_arr_ptr[idx]; }<br/>    private:<br/>        T *m_arr_ptr;<br/>    };<br/>    T m_arr[10][10];<br/>public:<br/>    arr2D::proxy_class operator[](uint32_t idx) { return arr2D::proxy_class(m_arr[idx]); }<br/>};</span><span id="ed1f" class="me lc in nj b gy nr no l np nq">int main()<br/>{<br/>    arr2D&lt;&gt; arr;<br/>    arr[0][0] = 1;<br/>    cout &lt;&lt; arr[0][0];<br/>    return 0;<br/>}</span></pre><h2 id="8bb9" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">用例</h2><ul class=""><li id="d2a9" class="mq mr in jx b jy lz kc ma kg ms kk mt ko mu ks mv mw mx my bi translated">创建像双操作符重载、<code class="fe nv nw nx nj b">std::any</code>等直观特性。</li></ul><h1 id="040d" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常见问题汇总</h1><p id="9032" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io">什么时候实际使用 RAII？</strong></p><p id="9296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你有一套步骤来执行一项任务时&amp;两步是理想的，即设置和清理，那么这就是你可以使用 RAII 的地方。</p><p id="39c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么函数不能通过返回类型重载？</strong></p><p id="01d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您不能重载返回类型，因为在函数调用表达式中使用函数的返回值不是强制性的。例如，我可以说</p><p id="bbe3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nj b">get_val();</code></p><p id="fb7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器现在做什么？</p><p id="ba15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">何时使用返回式解析器习语？</strong></p><p id="21d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当输入类型固定但输出类型可能变化时，可以应用返回类型解析器习语。</p><p id="e9ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">c++中什么是类型擦除？</strong></p><p id="765b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">- Type erasure 技术用于设计依赖于<a class="ae kt" href="http://www.vishalchovatiya.com/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">赋值</a>类型的泛型类型(就像我们在 python 中做的一样)。<br/> -对了，你知道<code class="fe nv nw nx nj b">auto</code>或者你现在能设计一个吗？</p><p id="2377" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">应用类型擦除习语的最佳场景？</strong></p><p id="0e01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">-在泛型编程中很有用。<br/> -也可以用于处理来自函数/方法的多种类型的返回值(尽管这不是推荐的建议)。</p><p id="c06e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是奇怪地重复出现的模板模式(CRTP)？</p><p id="af29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CRTP 是当一个类<code class="fe nv nw nx nj b">A</code>有一个基类的时候。这个基类是类<code class="fe nv nw nx nj b">A</code>本身的模板特化。例如<br/> <code class="fe nv nw nx nj b">template &lt;class T&gt;</code> <br/> <code class="fe nv nw nx nj b">class X{...};</code> <br/> <code class="fe nv nw nx nj b">class A : public X&lt;A&gt; {...};</code> <br/>它<em class="kx">是</em>奇怪地重复出现，不是吗？</p><p id="d674" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么奇怪地重复出现模板模式(CRTP 模式)的作品？</strong></p><p id="e46c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我觉得<a class="ae kt" href="https://stackoverflow.com/questions/49708984/why-curiously-recurring-template-pattern-crtp-works" rel="noopener ugc nofollow" target="_blank">这个</a>回答很贴切。</p><p id="a267" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是 SFINAE？</strong></p><p id="7b7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">S</strong>substitution<strong class="jx io">F</strong>failure<strong class="jx io">I</strong>S<strong class="jx io">N</strong>ot<strong class="jx io">A</strong>N<strong class="jx io">E</strong>error 是 C++编译器在重载解析过程中用来过滤掉一些模板化函数重载的语言特性(不是习语)。</p><p id="df03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是 C++中的代理类？</strong></p><p id="ce94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代理是向另一个类提供修改接口的类。</p><p id="43b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么我们在 C++中没有虚拟构造函数？</strong></p><p id="0503" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">-为每个具有一个或多个“虚函数”的类创建一个虚拟表(vtable)。每当创建这样一个类的对象时，它都包含一个指向相应 vtable 基址的“虚拟指针”。每当有虚函数调用时，vtable 就被用来解析函数地址。<br/> -构造函数不能是虚拟的，因为当执行类的构造函数时，内存中没有 vtable，这意味着还没有定义虚拟指针。因此，构造函数应该总是非虚拟的。</p><p id="83b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">能否在 C++中将类复制构造函数虚化？</strong></p><p id="4035" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似于“为什么我们在 C++中没有虚构造函数？”上面已经回答了。</p><p id="4f4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">虚拟构造函数需要哪些用例&amp;？</strong></p><p id="056a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用基类多态方法创建和复制对象(不知道其具体类型)。</p></div></div>    
</body>
</html>