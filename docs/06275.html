<html>
<head>
<title>The Guide to Docker ARG, ENV and .env</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker ARG，ENV 和。包封/包围（动词 envelop 的简写）</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-guide-to-docker-arg-env-and-env-4a7b3ddd5543?source=collection_archive---------3-----------------------#2021-12-27">https://blog.devgenius.io/the-guide-to-docker-arg-env-and-env-4a7b3ddd5543?source=collection_archive---------3-----------------------#2021-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c04" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">揭开 Docker 参数、环境和。包封/包围（动词 envelop 的简写）</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/289af24eca812d5fb424510abe03d299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAWPC80TBhKaeYm5GVWnvA.png"/></div></div></figure><p id="735c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于那些赶时间的人，这里有一个总结这篇文章内容的表格。你可以在这里找到更高分辨率的<a class="ae ln" href="https://docs.google.com/presentation/d/1QqCYdF67zEpRg724BlFceDhg_ntPmiZ5rgmSq_vlssk/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/75652cab2157d8d8e6dba2e84a6446ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doiix3m0cqFlq8k3cG2l3A.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">TL；DR 表</figcaption></figure><h2 id="f960" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">为什么是这个指南？</h2><p id="6cb0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">很多时候，开发人员在开发和部署的不同阶段都在绞尽脑汁地寻找传递变量的最佳方式。我自己对此感到内疚。为了一劳永逸地解决这个问题，我决定进行实验，并在本文中记录下我的观察结果。<a class="ae ln" href="https://emojipedia.org/hugging-face/" rel="noopener ugc nofollow" target="_blank">🤗</a></p><h1 id="6944" class="mr lu iq bd lv ms mt mu ly mv mw mx mb jw my jx me jz mz ka mh kc na kd mk nb bi translated">在 Docker 中设置环境变量</h1><p id="58e2" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在这一节中，我将向您介绍四种不同的方式，您可以在构建期间使用 docker-compose 向 docker 映像的环境变量提供值。</p><h2 id="50b4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">1.Docker Dot-Env 文件(环境)</h2><p id="8b8c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated"><code class="fe nc nd ne nf b">.env</code>文件可能是设置环境变量最常见的方式。通过将变量存储在文件中，您可以使用 Git 跟踪它们的变化。通常，<code class="fe nc nd ne nf b">.env</code>的内容用以下符号表示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用当前目录中的<code class="fe nc nd ne nf b">.env</code>文件和下面的<code class="fe nc nd ne nf b">docker-compose.yml</code>文件，您可以运行命令<code class="fe nc nd ne nf b">docker-compose up -d</code>来启动容器。在后台，它将读取<code class="fe nc nd ne nf b">.env</code>文件中的变量，并按照<code class="fe nc nd ne nf b">command</code>的指示将值打印到控制台。为了验证，运行<code class="fe nc nd ne nf b">docker logs ubuntu</code>，您将看到变量<code class="fe nc nd ne nf b">ONE</code>被记录。</p><p id="9ff7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有趣的事实:如果你在 docker-compose 文件中需要一个字面上的美元符号，可以使用双<code class="fe nc nd ne nf b">$$</code>。这也阻止了 Compose 插入一个值，因此<code class="fe nc nd ne nf b">$$</code>允许您引用不希望 Compose 处理的环境变量。这就是这里记载的<a class="ae ln" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#variable-substitution" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="3112" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">2.使用主机的环境变量</h2><p id="34e0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">或者，如果您不希望创建一个<code class="fe nc nd ne nf b">.env</code>文件，而是希望在您的主机中使用一个现有的环境变量，您也可以使用下面的<code class="fe nc nd ne nf b">docker-compose.yml</code>文件。这样，Docker 将读入您的主机的环境变量，并将其传递给容器。但是，我不建议使用这种方法，因为它可能会使您难以调试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="41a8" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">3.码头环境</h2><p id="aa04" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">另一种设置环境变量的方法是使用<code class="fe nc nd ne nf b">environment:</code>语法在<code class="fe nc nd ne nf b">docker-compose.yml</code>文件中直接定义它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="1c4c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">4.使用壳参数展开</h2><p id="35b0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">最后一种方法是在参数本身中设置环境变量。使用 Shell 参数扩展特性，<code class="fe nc nd ne nf b">${VARIABLE_ONE:-ONE}</code>将默认为值<code class="fe nc nd ne nf b">ONE</code>，如果它在运行时没有被覆盖的话。有关这种行为的更多信息，请参见<a class="ae ln" href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameter-Expansion" rel="noopener ugc nofollow" target="_blank"> bash 参考</a>和 Docker <a class="ae ln" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#variable-substitution" rel="noopener ugc nofollow" target="_blank">的文档。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="83fa" class="mr lu iq bd lv ms np mu ly mv nq mx mb jw nr jx me jz ns ka mh kc nt kd mk nb bi translated">Docker 中有两种类型的变量——ARG 和 ENV</h1><p id="10bb" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Docker 中有两种类型的环境变量。在 docker 文件中，它们以<code class="fe nc nd ne nf b">ARG</code>和<code class="fe nc nd ne nf b">ENV</code>的语法出现。在 Docker 编写文件中，它们是<code class="fe nc nd ne nf b">args:</code>和<code class="fe nc nd ne nf b">environment:</code>。为了便于参考，我以要点的形式总结了下面的差异。</p><p id="3576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> ENV </strong></p><ul class=""><li id="f64b" class="nu nv iq kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated"><code class="fe nc nd ne nf b">ENV</code>在构建和运行期间<strong class="kt ir">是否可用</strong></li><li id="72ec" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">使用它在运行时传递秘密，避免在构建时硬编码它们</li><li id="4cb5" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated"><code class="fe nc nd ne nf b">ENV</code>不能在<code class="fe nc nd ne nf b">FROM</code>语法之前声明</li><li id="c107" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">在多阶段构建中，<code class="fe nc nd ne nf b">ENV</code>贯穿所有阶段</li><li id="81d2" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">优先于相同变量名的<code class="fe nc nd ne nf b">ARG</code>。例如，在 docker 文件中，相同的变量名由<code class="fe nc nd ne nf b">ENV</code>和<code class="fe nc nd ne nf b">ARG</code>定义，将使用<code class="fe nc nd ne nf b">ENV</code>的值而不是<code class="fe nc nd ne nf b">ARG</code></li></ul><p id="ff1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> ARG </strong></p><ul class=""><li id="ca0a" class="nu nv iq kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated"><code class="fe nc nd ne nf b">ARG</code>也称为构建时环境变量，因为它们<strong class="kt ir">仅在构建时可用，而在运行时不可用</strong></li><li id="96ec" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">不要用它来设置秘密，因为任何使用<code class="fe nc nd ne nf b">docker history</code>命令的映像用户都可以看到构建时的值</li><li id="5aae" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated"><code class="fe nc nd ne nf b">ARG</code>可以在<code class="fe nc nd ne nf b">FROM</code>语法之前声明</li><li id="451a" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">在多阶段构建中，<code class="fe nc nd ne nf b">ARG</code>不会持续到第一阶段之后</li><li id="a4ee" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">在构建期间，您可以用标志<code class="fe nc nd ne nf b">--build-arg &lt;varname&gt;=&lt;value&gt;</code>覆盖<code class="fe nc nd ne nf b">ARG</code>变量，用不同的变量构建映像。注意:如果存在用相同变量名配置的<code class="fe nc nd ne nf b">ENV</code>，这不起作用，参见下面关于优先级的部分</li></ul><h2 id="992a" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">ENV 优先于 ARG</h2><p id="c3dd" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在下面的例子中，同一个变量<code class="fe nc nd ne nf b">SOME_VAR</code>由<code class="fe nc nd ne nf b">ARG</code>和<code class="fe nc nd ne nf b">ENV</code>定义。由于来自<code class="fe nc nd ne nf b">ENV</code>的值优先于<code class="fe nc nd ne nf b">ARG</code>，使用命令<code class="fe nc nd ne nf b">docker build --no-cache -t demo .</code>构建图像将在一个层中打印<code class="fe nc nd ne nf b">Build-time: SOME_VAR is set to env-value</code>，因为它打印来自<code class="fe nc nd ne nf b">ENV</code>的值。这意味着来自<code class="fe nc nd ne nf b">ARG</code>的值被忽略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="961c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，用标志<code class="fe nc nd ne nf b">--build-arg SOME_VAR=new-value</code>构建图像也没有效果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="e678" class="mr lu iq bd lv ms mt mu ly mv mw mx mb jw my jx me jz mz ka mh kc na kd mk nb bi translated">使用 ONBUILD 语法的多阶段映像构建</h1><p id="0ceb" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated"><code class="fe nc nd ne nf b">ONBUILD</code>的概念允许您在一个阶段中声明<code class="fe nc nd ne nf b">ARG</code>和<code class="fe nc nd ne nf b">ENV</code>，并让这些值仅在后续阶段中可用。</p><p id="d6c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的 Dockerfile 示例中，我在第一阶段声明了四个环境变量，即<code class="fe nc nd ne nf b">VAR_ENV</code>、<code class="fe nc nd ne nf b">VAR_ARG</code>、<code class="fe nc nd ne nf b">VAR_ENV_ONBUILD</code>和<code class="fe nc nd ne nf b">VAR_ARG_ONBUILD</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="79cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在构建期间，注意在第 6 步(第一阶段)，只有<code class="fe nc nd ne nf b">VAR_ARG</code>和<code class="fe nc nd ne nf b">VAR_ENV</code>被打印。然而，在步骤 8(第二阶段)中，除了<code class="fe nc nd ne nf b">VAR_ARG</code>之外，打印<code class="fe nc nd ne nf b">VAR_ARG_ONBUILD</code>、<code class="fe nc nd ne nf b">VAR_ENV_ONBUILD</code>和<code class="fe nc nd ne nf b">VAR_ENV</code>。这证明<code class="fe nc nd ne nf b">VAR_ARG</code>不会持续超过其自身的第一阶段，并且<code class="fe nc nd ne nf b">VAR_*_ONBUILD</code>仅在随后的第二和第三阶段可用(参见第三阶段的步骤 10)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="2d81" class="mr lu iq bd lv ms np mu ly mv nq mx mb jw nr jx me jz ns ka mh kc nt kd mk nb bi translated">可选阅读:环境变量与外壳变量的背景</h1><p id="d8a5" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">如果您想知道，一个<strong class="kt ir"> shell 变量</strong>对于 Shell 的一个特定实例是本地的，而<strong class="kt ir">环境变量</strong>被任何程序继承，包括从另一个 Shell 会话继承。这也意味着 shell 变量是环境变量的子集，在某种意义上对 Shell 会话是“临时”可用的。</p><p id="d39c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，变量存储在键值对结构中。Shell 变量使用命令<code class="fe nc nd ne nf b">SOME_SHELL_VAR=shell-var</code>设置，环境变量使用<code class="fe nc nd ne nf b">export SOME_ENV_VAR=env-var</code>设置，并带有额外的<code class="fe nc nd ne nf b">export</code>关键字。有几种方法可以列出所有当前定义的环境变量，那就是运行命令<code class="fe nc nd ne nf b">set</code>、<code class="fe nc nd ne nf b">printenv</code>或<code class="fe nc nd ne nf b">env</code>。然而，外壳变量(非导出)只能使用<code class="fe nc nd ne nf b">set</code>命令找到。</p><p id="72ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用</strong> <code class="fe nc nd ne nf b"><strong class="kt ir">set</strong></code>查看所有 Shell 和环境变量</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e371" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">设置和查看外壳变量</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1613" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用</strong> <code class="fe nc nd ne nf b"><strong class="kt ir">printenv</strong></code>查看所有环境变量</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">设置和查看环境变量</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更多详细信息，请参见 Ubuntu 的指南<a class="ae ln" href="https://help.ubuntu.com/community/EnvironmentVariables" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="2731" class="mr lu iq bd lv ms np mu ly mv nq mx mb jw nr jx me jz ns ka mh kc nt kd mk nb bi translated">结论</h1><p id="4926" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">到目前为止，您应该已经很好地理解了环境变量在 Docker 中是如何工作的——包括 ENV 和 ARG 两种形式。我希望这能成为你学习和使用 Docker 的一个很好的参考。<a class="ae ln" href="https://emojipedia.org/hugging-face/" rel="noopener ugc nofollow" target="_blank">🤗</a></p></div></div>    
</body>
</html>