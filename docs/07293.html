<html>
<head>
<title>DSA | Cycle detection using Floyd’s algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用弗洛伊德算法的循环检测</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/beginners-guide-to-cycle-detection-in-linked-list-ca610f8a7980?source=collection_archive---------8-----------------------#2022-03-12">https://blog.devgenius.io/beginners-guide-to-cycle-detection-in-linked-list-ca610f8a7980?source=collection_archive---------8-----------------------#2022-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="34e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文是数据结构与算法系列的一部分。在这个系列中，我将尝试详细解释重要而棘手的数据结构和算法主题。</p><p id="91f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将讨论三个臭名昭著的链表问题</p><ol class=""><li id="340d" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">循环检测</li><li id="b6f1" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">如果循环存在，则寻找循环的起点</li><li id="89bc" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">如果循环存在，求循环的长度</li></ol><p id="e256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用<a class="ae kw" href="https://en.wikipedia.org/wiki/Cycle_detection" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">弗洛伊德的周期寻找算法</strong> </a> <strong class="jm io"> </strong>通俗易懂。</p><p id="0eca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在浪费我们的时间之前，让我们直接开始吧。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/f624e005b65e878a3faaeb5704c49eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w10_zuxm-PTNOoMsE46gVw.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">链表循环表示法。(图片由作者提供)</figcaption></figure><p id="5262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了便于理解，在本文的其余部分，我们将参考这张图片。</p><h1 id="0b93" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">问题 1:周期检测</h1><p id="cc82" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">第一个问题很简单。假设我们有一只兔子和一只乌龟，兔子的速度是乌龟的两倍。现在两人都从<strong class="jm io">起点</strong>开始比赛。</p><blockquote class="mu mv mw"><p id="2815" class="jk jl mx jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">考虑到这一点。如果赛道上有一个循环，那么没有人会完成比赛，他们会继续跑下去，对吗？如果他们继续以不同的速度奔跑，他们一定会相遇，我们会发现有一个以可怜的兔子和野兔为代价的循环😅</p></blockquote><p id="8d46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们为上述情况编写算法。</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="8ad5" class="nf lo in mt b gy ng nh l ni nj">public class Solution {<br/>    public boolean detectCycle(ListNode head) {<br/>        // If the track is of 0 length or,<br/>        // if the track is of length 1,<br/>        // it obviously means there is no cycle<br/>        if (null == head ||  null == head.next) return false;<br/>        <br/>        // Slow pointer is our tortoise<br/>        ListNode slow = head;<br/>  <br/>        // Fast pointer is our rabbit<br/>        ListNode fast = head;<br/>        <br/>        // Rabbit and tortoise will keep running<br/>        // until they meet or rabbit finishes the race.<br/>        // We are only checking for rabbit as it is twice faster<br/>        while (fast != null &amp;&amp; fast.next != null) {<br/>            slow = slow.next;<br/>            fast = fast.next.next;<br/>            if (slow == fast) break;<br/>        }<br/>        <br/>        // If rabbit and tortoise are at the same position<br/>        // that means the cycle exist, otherwise it doesn't<br/>        if (slow != fast) return false;<br/>    }<br/>}</span></pre><h1 id="0a61" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">问题 2:寻找循环的起点</h1><p id="cdd2" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">从上一个问题中，我们知道了如何用兔子来求循环。我们知道，如果有一个循环，那么他们会在循环中的某处相遇，在位置<strong class="jm io"> M </strong>。</p><p id="8868" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们把我们所知道的一切都用方程式来表示。(为便于理解，请参考图片)</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="a8b2" class="nf lo in mt b gy ng nh l ni nj">Length of the cycle = N</span><span id="a812" class="nf lo in mt b gy nk nh l ni nj">Tortoise distance covered = X + Y</span><span id="47e8" class="nf lo in mt b gy nk nh l ni nj">Rabbit distance covered = X + k x N + Y (Where k is the number of repetition)</span><span id="a5a4" class="nf lo in mt b gy nk nh l ni nj">Rabbit distance covered = 2 x Tortoise distance covered (As Rabbit is twice faster than Tortoise)</span><span id="ba4a" class="nf lo in mt b gy nk nh l ni nj">X + k x N + Y = 2 x (X + Y)</span><span id="a1f4" class="nf lo in mt b gy nk nh l ni nj">=&gt; X = k x N - Y</span><span id="5e4b" class="nf lo in mt b gy nk nh l ni nj">=&gt; X = (k - 1) x N + N - Y</span><span id="c6e5" class="nf lo in mt b gy nk nh l ni nj">=&gt; X = (k - 1) x N + Z  (Since N = Y + Z)</span><span id="c529" class="nf lo in mt b gy nk nh l ni nj">=&gt; Z = X % N  (% is modulo operator)</span></pre><p id="7e41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的等式中，我们得到了<code class="fe mq mr ms mt b">X = (k — 1)N + Z</code>或<code class="fe mq mr ms mt b">Z = X modulo N </code>，其中<code class="fe mq mr ms mt b">k</code>是兔子在遇到乌龟之前重复跑的次数。因此，如果我们将第一只乌龟保持在<strong class="jm io"> M </strong>处，并将第二只乌龟带到<strong class="jm io">起始位置</strong>处，然后让第一只乌龟和第二只乌龟都跑，它们肯定会在循环的起始位置<strong class="jm io">s</strong>处相遇</p><p id="c205" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们为上述情况编写算法。</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="f10b" class="nf lo in mt b gy ng nh l ni nj">public class Solution {<br/>    public ListNode detectCycle(ListNode head) {<br/>        // If the track is of 0 length or<br/>        // if the track is of length 1,<br/>        // it obviously means there is no cycle<br/>        if (null == head ||  null == head.next) return null;<br/>        <br/>        // Slow pointer is our tortoise<br/>        ListNode slow = head;<br/>  <br/>        // Fast pointer is our rabbit<br/>        ListNode fast = head;<br/>        <br/>        // Rabbit and tortoise will keep running<br/>        // until they meet or rabbit finishes the race.<br/>        // We are only checking for rabbit as it twice faster<br/>        while (fast != null &amp;&amp; fast.next != null) {<br/>            slow = slow.next;<br/>            fast = fast.next.next;<br/>            if (slow == fast) break;<br/>        }<br/>        <br/>        // If rabbit and tortoise are at the same position<br/>        // that means the cycle exist, otherwise it doesn't<br/>        if (slow != fast) return null;<br/>  <br/>        // This is the second tortoise pointer,<br/>        // and we put it to the starting position<br/>        Listnode slow2 = head;<br/>  <br/>        // Both tortoise will keep running until they meet<br/>        while (slow != slow2) {<br/>            slow = slow.next;<br/>            slow2 = slow2.next;<br/>        }<br/>        <br/>        // Then we can return the first or second tortoise pointer<br/>        return slow;<br/>    }<br/>}</span></pre><h1 id="8a19" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">问题 3:寻找周期的长度</h1><p id="2177" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">从前面两个问题我们知道如何检测一个循环，也知道如何找到循环的起点。</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="9533" class="nf lo in mt b gy ng nh l ni nj">N = Y + Z </span></pre><p id="cfaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们记得兔子在 M，两只乌龟在 s。</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="bc76" class="nf lo in mt b gy ng nh l ni nj">Y = distance between S -&gt; M<br/>Z = distance between M -&gt; S</span></pre><p id="d144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，在这种情况下，第二只乌龟可以计算两个距离。</p><ol class=""><li id="6f22" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">首先，它将从现在的位置(S)出发，与(M)处的兔子相遇，从而找到 y。</li><li id="ad0c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">然后它会从(M)回到第一只乌龟的位置(S ),在这个过程中它会找到 z。</li></ol><p id="f394" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们为上述情况编写算法。</p><pre class="ky kz la lb gt nb mt nc nd aw ne bi"><span id="43f4" class="nf lo in mt b gy ng nh l ni nj">public class Solution {<br/>    public int detectCycle(ListNode head) {<br/>        // If the track is of 0 length or<br/>        // if the track is of length 1,<br/>        // it obviously means there is no cycle<br/>        if (null == head ||  null == head.next) return 0;<br/>        <br/>        // Slow pointer is our tortoise<br/>        ListNode slow = head;<br/>  <br/>        // Fast pointer is our rabbit<br/>        ListNode fast = head;<br/>        <br/>        // Rabbit and tortoise will keep running<br/>        // until they meet or rabbit finishes the race.<br/>        // We are only checking for rabbit as it twice faster<br/>        while (fast != null &amp;&amp; fast.next != null) {<br/>            slow = slow.next;<br/>            fast = fast.next.next;<br/>            if (slow == fast) break;<br/>        }<br/>        <br/>        // If rabbit and tortoise are at the same position<br/>        // that means the cycle exist, otherwise it doesn't<br/>        if (slow != fast) return 0;<br/>  <br/>        // This is the second tortoise pointer,<br/>        // and we put it to the starting position<br/>        Listnode slow2 = head;<br/>  <br/>        // Both tortoise will keep running until they meet<br/>        while (slow != slow2) {<br/>            slow = slow.next;<br/>            slow2 = slow2.next;<br/>        }<br/>  <br/>        // y and z is represeting distance Y and Z respectively<br/>        int y = 0, z = 0;<br/>  <br/>        // Second tortoise is running from point S to M<br/>        // and in that process it will find Y<br/>        while (slow2 != rabbit) {<br/>            slow2 = slow2.next;<br/>            y++;<br/>        }<br/>  <br/>        // After that seconnd tortoise will run from M to S<br/>        // and in that process it will find Z<br/>        while (slow2 != slow) {<br/>            slow2 = slow2.next;<br/>            z++;<br/>        }<br/>        <br/>        // Then we can return sum of Y + Z which will be N<br/>        return y+z;<br/>    }<br/>}</span></pre><p id="70b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道如何检测一个循环，找到循环的起点，找到循环的长度。</p></div></div>    
</body>
</html>