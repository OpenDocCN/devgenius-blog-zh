<html>
<head>
<title>How to write a game in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 JavaScript 写一个游戏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-a-game-in-javascript-4d1d3ba0828c?source=collection_archive---------18-----------------------#2022-09-05">https://blog.devgenius.io/how-to-write-a-game-in-javascript-4d1d3ba0828c?source=collection_archive---------18-----------------------#2022-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fa6b23fb4594c0b2523171d589331100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_GDn6RXZSZC66kvrMHh5Q.png"/></div></div></figure><p id="2fc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天的浏览器允许你创建全图形的游戏。以下是如何使用 JavaScript 和 HTML5 编写简单的赛车游戏。</p><p id="a9b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览器现在为 JavaScript 开发人员创建有趣的站点提供了很多选择。Flash 曾被用于此——它很受欢迎，无数的游戏、玩家、花哨的界面等等都是在它上面创建的。然而，它们不再在任何现代浏览器中运行。</p><p id="794d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，Flash 技术是重量级的，并且充满了漏洞，所以它开始放弃。尤其是因为有 HTML5 形式的替代品。</p><p id="4b82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Canvas 是可以用 JS 命令在上面绘图的画布。它可以用来创建动画背景，各种构造函数，最重要的是，游戏。</p><p id="17db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，你将学习如何用 JavaScript 和 HTML5 创建一个浏览器游戏。但首先，我们建议您熟悉 JS 中的面向对象编程(只需了解什么是类、方法和对象)。这是创建游戏的最佳方式，因为它允许你处理实体而不是抽象数据。但是，有一个缺点:任何版本的 Internet Explorer 都不支持 OOP。</p><p id="a5ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">游戏页面布局</strong></p><p id="fdff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，您需要创建一个显示画布的页面。这需要很少的 HTML:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6d68" class="lc ld in ky b gy le lf l lg lh">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;JS Game&lt;/title&gt;<br/>        &lt;link rel="stylesheet" href="style.css"&gt;<br/>        &lt;meta charset="utf-8"&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;div class="wrapper"&gt;<br/>            &lt;canvas width="0" height="0" class="canvas" id="canvas"&gt;Your browser does not support JavaScript и HTML5 &lt;/canvas&gt;<br/>        &lt;/div&gt;<br/>        &lt;script src="game.js"&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="35ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要添加样式:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="9da8" class="lc ld in ky b gy le lf l lg lh">body, html<br/>{<br/>    width: 100%;<br/>    height: 100%;<br/>    padding: 0px;<br/>    margin: 0px;<br/>    overflow: hidden;<br/>}<br/> <br/>.wrapper<br/>{<br/>    width: 100%;<br/>    height: 100%;<br/>}<br/> <br/>.canvas<br/>{<br/>    width: 100%;<br/>    height: 100%;<br/>    background: #000;<br/>}</span></pre><p id="8ecd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，在 HTML 中，canvas 元素的宽度和高度都是零，而 CSS 指定的是 100%。在这方面，画布表现得像一幅图像。它有实际分辨率和可见分辨率。</p><p id="5ef2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用样式更改可见分辨率。然而，图片的尺寸将保持不变:它只是被拉伸或压缩。这就是为什么实际的宽度和高度将在以后通过脚本来指定。</p><p id="c977" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">游戏脚本</strong></p><p id="df4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们为游戏添加一个脚本蓝图:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="eecf" class="lc ld in ky b gy le lf l lg lh">var canvas = document.getElementById("canvas"); //Retrieving a canvas from the DOM<br/>var ctx = canvas.getContext("2d"); //Obtaining a context - through it you can work with the canvas<br/> <br/>var scale = 0.1; //Machine scale<br/> <br/>Resize(); //When the page loads, the canvas size is set<br/> <br/>window.addEventListener("resize", Resize); //Changing the size of the window will change the size of the canvas<br/> <br/>window.addEventListener("keydown", function (e) { KeyDown(e); }); //Receiving keystrokes from the keyboard<br/> <br/>var objects = []; //An array of game objects<br/>var roads = []; //An array with backgrounds<br/> <br/>var player = null; //The object controlled by the player - here will be the number of the object in the objects array<br/> <br/>function Start()<br/>{<br/>    timer = setInterval(Update, 1000 / 60); //The game state will update 60 times per second - at this rate, the update of what is happening will seem very smooth<br/>}<br/> <br/>function Stop()<br/>{<br/>    clearInterval(timer); //Stopping the update<br/>}<br/> <br/>function Update() //Game update<br/>{<br/>    Draw();<br/>}<br/> <br/>function Draw() //Working with graphics<br/>{<br/>    ctx.clearRect(0, 0, canvas.width, canvas.height); //Clearing the canvas from the previous frame<br/>}<br/> <br/>function KeyDown(e)<br/>{<br/>    switch(e.keyCode)<br/>    {<br/>        case 37: //Left<br/>            break;<br/> <br/>        case 39: //Right<br/>            break;<br/> <br/>        case 38: //Up<br/>            break;<br/> <br/>        case 40: //Down<br/>            break;<br/> <br/>        case 27: //Esc<br/>            break;<br/>    }<br/>}<br/> <br/>function Resize()<br/>{<br/>    canvas.width = window.innerWidth;<br/>    canvas.height = window.innerHeight;<br/>}</span></pre><p id="fce6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个脚本拥有创建游戏所需的一切:数据(数组)、更新、绘图和控制功能。只剩下用基本逻辑来补充它了。也就是说，确切地指定对象的行为方式以及它们在画布上的显示方式。</p><p id="3196" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">游戏逻辑</strong></p><p id="9766" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Update()函数调用期间，游戏对象的状态将会改变。之后，将使用 Draw()函数在画布上绘制它们。所以我们实际上并不移动画布上的对象，我们只画一次，然后改变它们的坐标，删除旧图像，用新坐标显示对象。这一切发生得如此之快，以至于给人以运动的错觉。</p><p id="f162" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个道路的例子。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/e4bdf46904b9b91593441abbac0ff00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBqmk0yR-gTRKZndHptmdg.jpeg"/></div></div></figure><p id="0029" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个图像显示在画布上，并逐渐向下移动。紧接着，会显示另一个像这样的图像，使它感觉像一条没有尽头的路。</p><p id="956f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，让我们创建一个 Road 类:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="eb95" class="lc ld in ky b gy le lf l lg lh">class Road<br/>{<br/>    constructor(image, y)<br/>    {<br/>        this.x = 0;<br/>        this.y = y;<br/> <br/>        this.image = new Image();<br/>        <br/>        this.image.src = image;<br/>    }<br/> <br/>    Update(road) <br/>    {<br/>        this.y += speed; //The image shifts down when you refresh<br/> <br/>        if(this.y &gt; window.innerHeight) //If the image has gone over the edge of the canvas, change the position<br/>        {<br/>            this.y = road.y - this.image.height + speed; //The new position is indicated with the second background<br/>        }<br/>    }<br/>}</span></pre><p id="f79b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Road 类的两个对象被添加到背景数组中:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1693" class="lc ld in ky b gy le lf l lg lh">var roads = <br/>[<br/>    new Road("images/road.jpg", 0),<br/>    new Road("images/road.jpg", 626)<br/>]; //background array</span></pre><p id="3432" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您现在可以更改<em class="lj"> Update() </em>函数，以便图像的位置随着每一帧而变化。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="23b2" class="lc ld in ky b gy le lf l lg lh">function Update() //Game Update<br/>{<br/>    roads[0].Update(roads[1]);<br/>    roads[1].Update(roads[0]);<br/> <br/>    Draw();<br/>}</span></pre><p id="a65e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只剩下添加这些图像的输出:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="13cc" class="lc ld in ky b gy le lf l lg lh">function Draw() //Working with graphics<br/>{<br/>    ctx.clearRect(0, 0, canvas.width, canvas.height); //Clearing the canvas from the previous frame<br/> <br/>    for(var i = 0; i &lt; roads.length; i++)<br/>    {<br/>        ctx.drawImage<br/>        (<br/>            roads[i].image, //Render image<br/>            0, //Initial X position in the image<br/>            0, //Initial Y-axis position in the image<br/>            roads[i].image.width, //Image width<br/>            roads[i].image.height, //Image height<br/>            roads[i].x, //X-axis position on the canvas<br/>            roads[i].y, //Y-axis position on the canvas<br/>            canvas.width, //The width of the image on the canvas<br/>            canvas.width //Since the width and height of the background are the same, the width is specified as the height<br/>        );<br/>    }<br/>}</span></pre><p id="fc02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以看到它在游戏中是如何工作的:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/65070cce6603e82e0bcdbe783bbb7c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MPPq4zMtytCIh26coI3iBA.gif"/></div></div></figure><p id="27eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是时候增加一个球员和一个 NPC 了。为此，您需要编写一个汽车类。它将有一个 Move()方法，玩家用它来控制他的汽车。NPC 的移动将通过 Update()完成，它只是改变了 Y 坐标。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="62be" class="lc ld in ky b gy le lf l lg lh">class Car<br/>{<br/>    constructor(image, x, y)<br/>    {<br/>        this.x = x;<br/>        this.y = y;<br/> <br/>        this.image = new Image();<br/> <br/>        this.image.src = image;<br/>    }<br/> <br/>    Update()<br/>    {<br/>        this.y += speed;<br/>    }<br/> <br/>    Move(v, d) <br/>    {<br/>        if(v == "x") //X-axis movement<br/>        {<br/>            this.x += d; //Offset<br/> <br/>            //<br/>            if(this.x + this.image.width * scale &gt; canvas.width)<br/>            {<br/>                this.x -= d; <br/>            }<br/>    <br/>            if(this.x &lt; 0)<br/>            {<br/>                this.x = 0;<br/>            }<br/>        }<br/>        else //Y-axis movement<br/>        {<br/>            this.y += d;<br/> <br/>            if(this.y + this.image.height * scale &gt; canvas.height)<br/>            {<br/>                this.y -= d;<br/>            }<br/> <br/>            if(this.y &lt; 0)<br/>            {<br/>                this.y = 0;<br/>            }<br/>        }<br/>        <br/>    }<br/>}</span></pre><p id="4061" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建第一个要检查的对象。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="cb11" class="lc ld in ky b gy le lf l lg lh">var objects = <br/>[<br/>    new Car("images/car.png", 15, 10)<br/>]; //An array of game objects<br/>var player = 0; //the number of the object controlled by the player</span></pre><p id="4fb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您需要向 draw()函数添加一个绘制汽车的命令。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4990" class="lc ld in ky b gy le lf l lg lh">for(var i = 0; i &lt; objects.length; i++)<br/>{<br/>    ctx.drawImage<br/>    (<br/>        objects[i].image, //Render image<br/>        0, //Initial X position in the image<br/>        0, //Initial Y-axis position in the image<br/>        objects[i].image.width, //Image width<br/>        objects[i].image.height, //Image height<br/>        objects[i].x, //X-axis position on the canvas<br/>        objects[i].y, //Y-axis position on the canvas<br/>        objects[i].image.width * scale, //The width of the image on the canvas multiplied by the scale<br/>        objects[i].image.height * scale //The height of the image on the canvas multiplied by the scale<br/>    );<br/>}</span></pre><p id="c57d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 KeyDown()函数中，当您按下键盘时会调用该函数，您需要添加对 Move()方法的调用。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="24d3" class="lc ld in ky b gy le lf l lg lh">function KeyDown(e)<br/>{<br/>    switch(e.keyCode)<br/>    {<br/>        case 37: //Left<br/>            objects[player].Move("x", -speed);<br/>            break;<br/><br/>        case 39: //Right<br/>            objects[player].Move("x", speed);<br/>            break;<br/> <br/>        case 38: //Up<br/>            objects[player].Move("y", -speed);<br/>            break;<br/> <br/>        case 40: //Down<br/>            objects[player].Move("y", speed);<br/>            break;<br/> <br/>        case 27: //Esc<br/>            if(timer == null)<br/>            {<br/>                Start();<br/>            }<br/>            else<br/>            {<br/>                Stop();<br/>            }<br/>            break;<br/>    }<br/>}</span></pre><p id="2006" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以检查渲染和控制。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/68f5dd0b62f1a917c6d04ab07e0e07ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*maHaV7PyU-y-lhrSSmivNA.gif"/></div></div></figure><p id="36d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">碰撞时不会发生任何事情，但稍后会修复。首先，您需要确保从视图中丢失的对象被删除。这是为了避免堵塞闸板。</p><p id="65d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Car 类中，我们添加值为 false 的 dead 字段，然后在 Update()方法中更改它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d6d3" class="lc ld in ky b gy le lf l lg lh">if(this.y &gt; canvas.height + 50)<br/>{<br/>    this.dead = true;<br/>}</span></pre><p id="890f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您需要更改游戏的更新功能，替换与对象相关的代码:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f59f" class="lc ld in ky b gy le lf l lg lh">var hasDead = false;<br/> <br/>for(var i = 0; i &lt; objects.length; i++)<br/>{<br/>    if(i != player)<br/>    {<br/>        objects[i].Update();<br/> <br/>        if(objects[i].dead)<br/>        {<br/>            hasDead = true;<br/>        }<br/>    }<br/>}<br/> <br/>if(hasDead)<br/>{<br/>    objects.shift();<br/>}</span></pre><p id="214d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不移除物体，当产生太多的汽车时，游戏将开始减慢计算机的速度。</p><p id="18c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">游戏物体的碰撞</strong></p><p id="eb32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以开始实现碰撞了。为此，为 Car 类编写 Collide()方法，该方法将检查汽车的坐标:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="917f" class="lc ld in ky b gy le lf l lg lh">Collide(car)<br/>{<br/>    var hit = false;<br/> <br/>    if(this.y &lt; car.y + car.image.height * scale &amp;&amp; this.y + this.image.height * scale &gt; car.y) //If the objects are on the same line horizontally<br/>    {<br/>        if(this.x + this.image.width * scale &gt; car.x &amp;&amp; this.x &lt; car.x + car.image.width * scale) //If the objects are on the same line vertically<br/>        {<br/>            hit = true;<br/>        }<br/>    }<br/> <br/>    return hit;<br/>}</span></pre><p id="172f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要给 Update()函数添加一个冲突检查:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="515e" class="lc ld in ky b gy le lf l lg lh">var hit = false;<br/> <br/>for(var i = 0; i &lt; objects.length; i++)<br/>{<br/>    if(i != player)<br/>    {<br/>        hit = objects[player].Collide(objects[i]);<br/> <br/>        if(hit)<br/>        {<br/>            alert("You crashed!");<br/>            Stop();<br/>            break;<br/>        }<br/>    }<br/>}</span></pre><p id="6c64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是游戏中的内容</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/1c4921abf915960e76cda9ccb2d5c315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*b3GXRqh43ZSSAuAP16nCuA.gif"/></div></figure><p id="fb07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">发生冲突时，可以添加任何逻辑:</p><p id="5ff1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开动画；</p><p id="a6a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">添加一种效果；；</p><p id="8026" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">删除一个对象；</p><p id="5a81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">健康状况的改变，等等。</p><p id="2239" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些都留给开发者自己决定。</p><p id="9cb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">结论</strong></p><p id="4da5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常简单的游戏，但它足以理解 JS 如何处理图形以及游戏是如何创建的。您可以在 GitHub 资源库中找到图片和完整的游戏代码。</p><p id="0ea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 canvas 有利于处理图形:它提供了很好的特性，并且不会给浏览器带来太多的负载。我们现在也有一个 WebGL 库(示例和用法)，它可以为您提供大量的性能和 3D 工作(canvas 无法做到这一点)。</p><p id="4d62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理解 WebGL 可能很难——也许相反，许多人对尝试 Unity 引擎更感兴趣，该引擎知道如何编译项目以在浏览器中运行它们。</p></div></div>    
</body>
</html>