<html>
<head>
<title>var, let and const in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的 var、let 和 const</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/difference-between-var-let-and-const-in-javascript-7be7d83f63aa?source=collection_archive---------17-----------------------#2020-06-09">https://blog.devgenius.io/difference-between-var-let-and-const-in-javascript-7be7d83f63aa?source=collection_archive---------17-----------------------#2020-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="37ac" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript 变量声明及其范围快速指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4758f0d0cc91aea861236b719015d137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDVzMZVPxmTr1Kce"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·罗宾·艾宾浩斯</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="1e82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将讨论<em class="lp"> var，let，</em>和<em class="lp"> const </em>的区别，它们的适用范围，以及根据具体情况，它们之间的优劣。</p><p id="08e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们使用编程语言构建应用程序时，我们必须清楚地了解变量声明。变量是存储数据值的容器。范围定义了变量的可见性。有了 ES6 的新特性，JavaScript 增加了新的变量声明，其中<strong class="kv io"> <em class="lp"> let </em> </strong>和<strong class="kv io"> <em class="lp"> const </em> </strong>另外还有<strong class="kv io"> <em class="lp"> var </em> </strong>。</p><h2 id="3e06" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated"><strong class="ak"> <em class="mj"> 1。var </em> </strong></h2><blockquote class="mk ml mm"><p id="e58c" class="kt ku lp kv b kw kx jo ky kz la jr lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">var 语句声明了一个<strong class="kv io">函数作用域的</strong>或<strong class="kv io">全局作用域的</strong>变量，<strong class="kv io">可选地将其初始化为一个值。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank"> <em class="in">来源</em> </a></strong></p></blockquote><p id="b6f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据定义，<strong class="kv io"> <em class="lp"> var </em> </strong>是函数作用域或全局作用域的变量。</p><p id="05f2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数作用域？<br/>JavaScript 的每个函数都会创建一个新的作用域。当变量在函数内部定义时，它只在函数内部可见。它在我们的视线之外是无法接近的。</p><p id="2107" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">全局作用域？</strong> <br/>当一个变量被声明在一个函数之外时，它就变成了全局变量，可以被网页上的所有脚本和函数访问。</p><p id="bda6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一个是<em class="lp">var</em>T46】初始化是可选的。默认值为<strong class="kv io"> <em class="lp">未定义</em> </strong>。同样<strong class="kv io">重复变量</strong>由<em class="lp">变量</em>声明<strong class="kv io">未发生错误</strong>。现在我们举例讨论。变量声明在任何代码执行之前被处理。这叫吊装。因此，总是在变量作用域的顶部声明变量。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 1(示例 1.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="8025" class="lq lr in mt b gy mx my l mz na">undefined<br/>inside function x: 1<br/>inside function y: 2<br/>outside function x: 1</span></pre><p id="fe87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<em class="lp"> Example1.js </em> <em class="lp"> var </em>声明中，变量<em class="lp"> x </em>被初始化为 1。这里 x 是全局变量。<br/>变量<em class="lp"> y </em>使用<em class="lp">变量</em>声明初始化为 2。它的作用范围是函数<em class="lp">打印</em>。如果试图在函数之外访问 y，则生成错误<strong class="kv io"> ReferenceError: y 未定义。</strong></p><p id="c8eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当在全局上下文中使用 var 声明变量时，属性描述符<strong class="kv io">不能</strong> <strong class="kv io">改变</strong>或<strong class="kv io">删除</strong>。</p><blockquote class="mk ml mm"><p id="3199" class="kt ku lp kv b kw kx jo ky kz la jr lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">JavaScript 有自动内存管理，在全局变量上使用 delete 操作符是没有意义的。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 2(示例 2.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="c1bd" class="lq lr in mt b gy mx my l mz na">inside the function x: 2<br/>inside the function y: undefined<br/>outside the function x: 1</span></pre><h2 id="2243" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">2.让</h2><blockquote class="mk ml mm"><p id="d23c" class="kt ku lp kv b kw kx jo ky kz la jr lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">let 语句声明了一个<strong class="kv io">块范围的局部变量</strong>，可选地将其初始化为一个值。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="5751" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> var </em>关键字是将变量定义为作用域为全局或局部的一个整函数，在<em class="lp">中让</em> <strong class="kv io"> <em class="lp"> </em>变量的作用域限于一个 block 语句</strong>(图 3) block 可以是{}，for 循环，if -else 等。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 3(示例 3.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="9d82" class="lq lr in mt b gy mx my l mz na">inside the code block of printVar: 2<br/>inside the printVar: 2<br/>inside the code block of printLet: 2<br/>inside the printLet: 1</span></pre><p id="27c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，讨论第二个，<em class="lp">让</em>是<strong class="kv io">错误发生</strong>，当它在变量被声明 d 之前被访问<strong class="kv io">时。该变量从块的开始直到初始化被处理都处于“时间死区”中。但是<em class="lp">变量</em>由于吊装原因在相同情况下被赋予<strong class="kv io">未定义</strong>。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 4(示例 4.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="c22b" class="lq lr in mt b gy mx my l mz na">inside printVar before declared: undefined<br/>inside printVar after declared: 1<br/> console.log(“inside printLet before declared: “+ y);<br/>ReferenceError: Cannot access 'y' before initialization</span></pre><p id="6348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第三个是，使用 let 在<strong class="kv io">同一个块或函数</strong>中声明重复变量出现<strong class="kv io">语法错误。</strong>但是<em class="lp">变量</em>允许<strong class="kv io">在同一块中重复变量</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 5(示例 5.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="4e46" class="lq lr in mt b gy mx my l mz na">let y = 1;<br/> ^<br/>SyntaxError: Identifier ‘y’ has already been declared</span></pre><p id="e34c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们要用一个单独的块编写 switch 语句，并在每种情况下都使用<em class="lp"> let </em>声明变量时，会产生一个语法错误。解决方案是在每个 case 子句中添加一个块(图 6)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 6(示例 6.js)</figcaption></figure><h2 id="0dad" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated"><strong class="ak"> 3。常量</strong></h2><blockquote class="mk ml mm"><p id="8500" class="kt ku lp kv b kw kx jo ky kz la jr lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">常量是<strong class="kv io">块范围的</strong>，很像使用 let 关键字定义的变量。一个<strong class="kv io">常量</strong>的值不能通过重新赋值来改变，它<strong class="kv io">也不能被</strong> <strong class="kv io">重新声明</strong>。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="dcaa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">常量</em>由<em class="lp">更改为</em>不可重新分配。<em class="lp">常量</em>必须初始化。正常情况下，<em class="lp">常量</em>变量用大写字母声明。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 7(示例 7.js)</figcaption></figure><p id="a084" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> const </em>块范围可以是全局的，也可以是局部的。与<em class="lp">变量</em>不同，<em class="lp">常量</em>变量不是窗口对象的属性。在同一个块中重新声明一个<em class="lp"> const </em>变量会抛出一个错误。</p><p id="1efd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在 example8.js 中，PI 被声明为常量，并全局赋值为 3.14。在<em class="lp"> if </em>条件下，使用 let 创建了一个 PI 变量。它是一个非常量变量，如果阻塞，其范围为<em class="lp">。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 8(示例 8.js)</figcaption></figure><pre class="kd ke kf kg gt ms mt mu mv aw mw bi"><span id="f4e9" class="lq lr in mt b gy mx my l mz na">3.14<br/>3.142857142857143<br/>3.14</span></pre><p id="7d4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">结论</strong></p><p id="3275" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们总结<em class="lp"> var </em>、<em class="lp"> let </em>和<em class="lp"> const </em>的区别时，</p><p id="81cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp"> var </em> </strong> <br/>函数作用域或全局作用域。</p><p id="8b66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可选初始化。默认值是未定义的。</p><p id="ebbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">重复变量未出现错误</p><p id="b8bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在声明变量之前访问变量时未定义。</p><p id="1d01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">变量是在全局上下文中使用 var 声明的，因此不能更改或删除属性描述符。</p><p id="ed02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">让</em> </strong></p><p id="8bd5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">锁定范围的局部变量。</p><p id="81e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可选地将其初始化为一个值。</p><p id="f1f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在声明变量之前访问，出现错误。</p><p id="4b4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不允许在同一个块或函数中有重复的变量。</p><p id="baa7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">常量</em> </strong></p><p id="7de3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">块范围的。</p><p id="38e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">常量不能通过重新分配来更改。</p><p id="a0ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不能重新申报</p><p id="40df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">常量变量不是窗口对象的属性。</p><p id="71e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">参考文献</strong></p><div class="nb nc gp gr nd ne"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">声明和宣言</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">JavaScript 应用程序由具有适当语法的语句组成。一条语句可能跨越多行…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">developer.mozilla.org</p></div></div><div class="nn l"><div class="no l np nq nr nn ns km ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://tylermcginnis.com/var-let-const/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">JavaScript 中的 var vs let vs const</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在这篇文章中，你将学习两种在 JavaScript (ES6)中创建变量的新方法，let 和 const。一路上我们会寻找…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">tylermcginnis.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns km ne"/></div></div></a></div></div></div>    
</body>
</html>