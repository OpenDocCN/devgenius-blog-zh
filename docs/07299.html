<html>
<head>
<title>7 Good Code Review Practices Seasoned Java Developers Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的 Java 开发人员使用的 7 个良好的代码审查实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-good-code-review-practices-seasoned-java-developers-use-6cf83d3deb68?source=collection_archive---------2-----------------------#2022-03-13">https://blog.devgenius.io/7-good-code-review-practices-seasoned-java-developers-use-6cf83d3deb68?source=collection_archive---------2-----------------------#2022-03-13</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9869" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何执行高质量的 Java 代码评审</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/774cdf1f270ae230fe2ac08cb14d22ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vm5SRp6AfxnfQ45F.png"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">来自<a class="ae ks" href="https://www.pexels.com/photo/photo-of-man-sitting-in-front-of-people-3184299/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>的<a class="ae ks" href="https://www.pexels.com/@fauxels?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>的照片</figcaption></figure><p id="0f10" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">代码评审对于分散知识至关重要。</em></p><p id="bc39" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">一些开发人员不知道在代码审查中要寻找什么。他们会抱怨风格问题，而代码质量会受到影响。</p><p id="23fa" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您应该知道如何执行高质量的 Java 代码评审。这将使你与众不同，并教会你更多。</p><p id="5bdb" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里有 7 个好的 Java 代码审查实践。</p></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><h1 id="08aa" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">使用方法引用</h1><p id="70ec" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">尽可能使用方法引用。比起绑定的方法引用，更喜欢未绑定的。</em>T13】</strong></p><p id="ca5a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我会建议使用未绑定的(<code class="fe mu mv mw mx b">Class::method</code>)，因为它们不会有很大的捕获成本。绑定的<code class="fe mu mv mw mx b">this::method</code>会有额外的捕获开销。他们需要捕获比未绑定方法引用更大的词法范围。</p><p id="9bf3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">方法引用是一种 lambda 表达式。</em> </strong>正因如此，它们的编译方式不同。这里有一个例子。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="7080" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp"> Lambda 运行时不失败，方法引用失败。</em> </strong></p><p id="5f2c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">答案就在这个<a class="ae ks" href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13.3" rel="noopener ugc nofollow" target="_blank">规格</a>中:</p><p id="b2c0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">首先，如果方法引用表达式以 ExpressionName 或 Primary 开头，则评估该子表达式。</em> <strong class="kv is"> <em class="lp">如果子表达式的计算结果为</em> </strong> <code class="fe mu mv mw mx b"><strong class="kv is"><em class="lp">null</em></strong></code> <strong class="kv is"> <em class="lp">，则抛出一个</em> </strong> <code class="fe mu mv mw mx b"><strong class="kv is"><em class="lp">NullPointerException</em></strong></code> <strong class="kv is"> <em class="lp">，方法引用表达式突然完成。</em> </strong> <em class="lp">如果子表达式突然完成，方法引用表达式也会因为同样的原因突然完成。</em></p><p id="614d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">并且<a class="ae ks" href="https://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html" rel="noopener ugc nofollow" target="_blank"> lambda 在编译阶段</a>早期失败。</p><p id="51d9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">当编译器遇到 lambda 表达式时，它首先将 lambda 主体降级(反糖)到一个方法中，该方法的参数列表和返回类型与 lambda 表达式的匹配，可能带有一些附加参数(如果有的话，用于从词法范围捕获的值)。)</em></p><p id="c1dd" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">同时使用 lambdas 和方法引用，但要注意有副作用的方法(线程，或者异步函数)。</em> </strong></p></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><h1 id="56b0" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">首选功能<code class="fe mu mv mw mx b">for</code>循环</h1><p id="69d8" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">比起传统的 for 循环，更喜欢</em> </strong> <code class="fe mu mv mw mx b"><strong class="kv is"><em class="lp">IntStream</em></strong></code> <strong class="kv is"> <em class="lp">。</em>T25】</strong></p><p id="92ea" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mu mv mw mx b">IntStream</code>降低复杂性，隐藏样板文件，产生更好的代码。这里有一个来自文卡特的例子。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="b5b0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mu mv mw mx b">IntStream</code>解决的另一个问题是突变。索引变量的突变，如果使用<code class="fe mu mv mw mx b">IntStream</code>就不会发生。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="51aa" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有了<code class="fe mu mv mw mx b">IntStream</code>，我们不再需要临时变量。传统的 for 循环需要它来确保索引变量实际上是最终的。默认情况下，这实际上是最终版本。</p><p id="fcc8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">使用非传统的<code class="fe mu mv mw mx b">for</code>方法，你确实会损失一些性能。即便如此，您也可以通过并行执行来解决这个问题。使用流更容易实现并行化。</p><div class="na nb gq gs nc nd"><a href="https://jmh.morethan.io/?gist=0dac70e0966679e160fdfbbf44ade61e" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fp"><div class="nf ab ng cl cj nh"><h2 class="bd is gz z fq ni fs ft nj fv fx iq bi translated">JMH 观察仪</h2><div class="nk l"><h3 class="bd b gz z fq ni fs ft nj fv fx dk translated">JMH 可视化工具可以帮助你可视化你的 JMH 基准测试结果。只要上传你的 JSON 报告，你就会得到它…</h3></div><div class="nl l"><p class="bd b dl z fq ni fs ft nj fv fx dk translated">jmh.morethan.io</p></div></div></div></a></div></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><h1 id="7555" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">首选功能界面</h1><p id="b26c" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">函数接口是具有单一方法的接口。</em> </strong>这些也被称为 SAMs 或者单一抽象方法。</p><p id="3c34" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">功能接口与流混合得很好。您也可以创建自己的，或重用现有的。现有的 Sam 有<code class="fe mu mv mw mx b">Function&lt;T,R&gt;</code>、<code class="fe mu mv mw mx b">Predicate&lt;T&gt;</code>、<code class="fe mu mv mw mx b">Consumer&lt;T&gt;</code>等。您也可以创建带有<code class="fe mu mv mw mx b">@FunctionalInterface</code>注释的自定义模板。所有这些都比创造传统方法更有效。</p><p id="a327" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有时使用现有的 SAM 更好。它们通过设计具有描述性的名称。此外，您不必创建新的接口，这将增加代码的可读性。</p><p id="db03" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里有一个例子。当我们使用 SAM 时，我们可以传入匿名类或 lambda 表达式。后者当然更好。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div></figure><h1 id="4096" class="lx ly ir bd lz ma nm mc md me nn mg mh jx no jy mj ka np kb ml kd nq ke mn mo bi translated">测试预期异常</h1><p id="8475" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated">大多数钻杆排放系统没有这些测试。 </p><p id="ef8d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">开发人员也应该测试模糊案例。这就是为什么您应该检查预期的异常。您可以在 JUnit 中使用<code class="fe mu mv mw mx b">@Test</code>中的<code class="fe mu mv mw mx b">expected</code>值来这样做。</p><p id="b8a3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有了更新的 JUnit，JUnit 5，<a class="ae ks" href="https://github.com/junit-team/junit5/blob/main/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L41" rel="noopener ugc nofollow" target="_blank">可以用</a> <code class="fe mu mv mw mx b"><a class="ae ks" href="https://github.com/junit-team/junit5/blob/main/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L41" rel="noopener ugc nofollow" target="_blank">assertThrows</a></code> <a class="ae ks" href="https://github.com/junit-team/junit5/blob/main/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L41" rel="noopener ugc nofollow" target="_blank">代替</a>。这是比<code class="fe mu mv mw mx b">expected</code>更好的选择。为什么？因为您可以检查异常。使用<code class="fe mu mv mw mx b">expected</code>可以验证类型，使用<code class="fe mu mv mw mx b">assertThrows</code>也可以验证状态。</p><h1 id="9c3d" class="lx ly ir bd lz ma nm mc md me nn mg mh jx no jy mj ka np kb ml kd nq ke mn mo bi translated">如何使用断言？</h1><p id="fb55" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated">这里有一个很好的关于异常和断言区别的备忘单。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://github.com/google/guava/wiki/ConditionalFailuresExplained#summary" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="7cf8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">断言错误表示程序中的错误。例外显示例外情况。这两个不一样，你应该知道什么时候用。</p><p id="45bc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">断言错误可能位于静态类的私有构造函数中。这是一个编程错误的例子。那是不应该发生的事情。</p><h1 id="3327" class="lx ly ir bd lz ma nm mc md me nn mg mh jx no jy mj ka np kb ml kd nq ke mn mo bi translated">使用静态实例初始值设定项</h1><p id="44a0" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated">您可能会看到填充单例成员<code class="fe mu mv mw mx b">HashMap</code>的方法。</p><p id="e975" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以把它移到一个静态初始化器中。 这防止了每次调用该方法时的地图填充。还有，这样读更清楚。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="5bca" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您只能从静态初始化器中引用类的静态成员。这是初始化实例的好方法，不需要通过构造函数。</p><p id="9092" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您可以将它与多个构造函数一起使用，以防止重复初始化。<strong class="kv is"> <em class="lp">一次静态初始化器胜过多次初始化。</em> </strong></p><h1 id="4de8" class="lx ly ir bd lz ma nm mc md me nn mg mh jx no jy mj ka np kb ml kd nq ke mn mo bi translated">强制枚举</h1><p id="6f7d" class="pw-post-body-paragraph kt ku ir kv b kw mp js ky kz mq jv lb lc mr le lf lg ms li lj lk mt lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">比起字符串常量，更喜欢枚举唯一接口，或者一般的常量。</em>T25】</strong></p><p id="f21f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">在以前的企业项目中，我们会有这些。即便如此，这个接口也是一个反模式。本质上不是反模式，<a class="ae ks" href="https://stackoverflow.com/a/2659740/5999670" rel="noopener ugc nofollow" target="_blank">而是对接口的糟糕使用</a>。</p><p id="514b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">现在使用<code class="fe mu mv mw mx b">EnumSet</code>来代替只有常量的接口。</p><p id="4242" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">为什么要用</em> <code class="fe mu mv mw mx b"><em class="lp">EnumSet</em></code> <em class="lp">而不是常量专用接口？</em> <code class="fe mu mv mw mx b">EnumSet</code>最多可以定义 64 个常量，在大多数场合足够了。由于枚举集后面的位集，您还可以获得更快的访问速度。<code class="fe mu mv mw mx b">EnumSet</code>实现了<code class="fe mu mv mw mx b">Set</code>接口，所以你也将得到<code class="fe mu mv mw mx b">Set</code>操作。</p><p id="e744" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">枚举节拍字符串常量。</em> </strong></p><p id="db78" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mu mv mw mx b">Enum</code>会给你比<code class="fe mu mv mw mx b">String</code>更大的灵活性。你可以用<code class="fe mu mv mw mx b">Enum#values</code>得到所有的枚举并和它们一起工作。如果您想将枚举映射到其他结构，可以将枚举放在<code class="fe mu mv mw mx b">EnumMap</code>中。或者放在<code class="fe mu mv mw mx b">EnumSet</code>里，在测试或者其他地方使用。</p></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><p id="6914" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">代码评审是一个重要的过程。</em> </strong></p><p id="db56" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">尽管如此，大多数开发人员不知道如何去做。我为你准备了一个不同的代码审查视角。 <a class="ae ks" href="https://zivce.gumroad.com/l/become-high-quality-code-reviewer" rel="noopener ugc nofollow" target="_blank">查看这里。</a></p></div></div>    
</body>
</html>