<html>
<head>
<title>What are Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是 Web 组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-are-web-components-cbfdf08c35a9?source=collection_archive---------0-----------------------#2021-09-05">https://blog.devgenius.io/what-are-web-components-cbfdf08c35a9?source=collection_archive---------0-----------------------#2021-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/81705a761d38086629514b7ae280147f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h744Voyjvy5s5JnmYRqpSw.png"/></div></div></figure><p id="392a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近有很多关于 Web 组件的讨论。但这些是什么，我们会努力弄清楚。</p><p id="6fa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据 MDN <a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">的说法，Web 组件</a>是一组帮助我们创建定制的可重用组件的技术。这些组件可以很容易地封装，不会与应用程序的其他部分发生任何冲突。</p><p id="18b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最棒的是，它们不依赖于任何框架，是浏览器自带的。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="8f17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从一个 web 组件的基本示例开始。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="ee6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个 HTML 文件，我们可以看到一个定制标签<code class="fe lh li lj lk b">basic-component</code>正在被定义<em class="ll">(第 17 行)</em>。</p><p id="274d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它在下面的<code class="fe lh li lj lk b">basic-component.js</code>中被定义</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="0849" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，扩展了<code class="fe lh li lj lk b">HTMLElement</code>的类<code class="fe lh li lj lk b">Basic</code>创建了一个定制元素。</p><p id="0c2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lh li lj lk b"><em class="ll">super()</em></code> <em class="ll">(第 3 行)</em>只是调用 HTMLElement 类的构造函数。</p><p id="5477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lh li lj lk b">this</code>关键字表示我们正在更新其<code class="fe lh li lj lk b">innerHTML</code>属性的定制元素。</p><p id="e35b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lh li lj lk b">this.getAttribute("name")</code>获取从 HTML 中传递的属性名。</p><p id="b143" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是仅仅定义它是不行的，我们还必须将它连接到一个 HTML 标签，当被调用时需要呈现它，这就是在<em class="ll">第 10 行，</em>将类<code class="fe lh li lj lk b">Basic</code>连接到<code class="fe lh li lj lk b">basic-component</code>标签并定义它。</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/ba42e642866cdace2ce4a8256fce061c.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*DSqm4dZjxzSGAws2t-Uh5g.png"/></div></figure><p id="78d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是浏览器为上述代码呈现的内容。</p><p id="3640" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么“我应该是紫色的”是红色的你会问，我们一会儿会谈到这一点。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="41c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将浏览一下 Web 组件所包含的规范:</p><h2 id="b0f9" class="ln lo in bd lp lq lr dn ls lt lu dp lv kg lw lx ly kk lz ma mb ko mc md me mf bi translated"><strong class="ak">定制元素</strong></h2><p id="4f64" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这些允许我们定义可重用的定制元素。在上面的例子中，我们可以看到<code class="fe lh li lj lk b">Basic </code>是一个自定义元素。</p><p id="ee0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们捆绑了<code class="fe lh li lj lk b">Basic</code>提供的所有功能，并将其映射到一个标签<code class="fe lh li lj lk b">basic-component</code></p><h2 id="8b92" class="ln lo in bd lp lq lr dn ls lt lu dp lv kg lw lx ly kk lz ma mb ko mc md me mf bi translated"><strong class="ak">暗影 DOM </strong></h2><p id="d2b2" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">帮助封装 web 组件，避免样式泄漏。</p><p id="cca2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有没有想过，尽管 HTML 视频标签有很多控件，比如播放/暂停，声音控件等等，为什么我们从来没有看到它们。</p><p id="383d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们看到的只是</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/46bb7c7d86b9a8f942f13f09d7b99db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZ00WaTbtDmRi5U5bnHKGQ.png"/></div></div></figure><p id="5dba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为视频标签的所有内容都在影子 DOM 中。</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/29c230a81b47592746047d26a7b13896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7Ys7vJD5apsiuAq8i1KtQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">阴影 DOM —来自<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"> MDN </a>的图像</figcaption></figure><p id="8e53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Shadow DOM 是一组 Javascript APIs，帮助将 DOM 树附加和封装到元素中。这有助于保持元素特性的抽象，可以独立地设计样式和编写脚本，而不用担心冲突。</p><p id="93be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">影子 DOM 允许将隐藏的 DOM 树附加到常规 DOM 树中的元素上。</p><p id="a699" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">影子主机将自己附加到 DOM 节点，该节点指向影子树，影子根是这个影子树的根。</p><p id="4d13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是怎么才能看到视频标签的阴影 DOM 呢？</p><p id="24e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单，进入开发工具-&gt;设置-&gt;检查选项<em class="ll">显示用户代理阴影 DOM </em>并重新加载页面，你现在应该可以看到它了</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c4d8c34f07cff66c681ca0ab583cb9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*BaFl8uhKs4ELoIH0mI2kEg.gif"/></div></figure><p id="59b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您可以看到视频标签由什么组成。</p><p id="843d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到为什么“我应该是紫色的”是红色的</p><p id="8c3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为样式已经从具有相同类<code class="fe lh li lj lk b">color</code>但不同实现的 web 组件中泄漏出来。</p><p id="0ee9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可以通过阴影 DOM 来解决，如下所示。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2cdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们创建一个 HTML 模板，并将其附加到一个影子根。</p><p id="7ca6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lh li lj lk b">this.attachShadow({mode:"open"})</code>附加一个阴影 DOM 树。</p><p id="73e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ll">第 17 行</em>将模板附加到阴影根。</p><p id="800e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">影子 DOM 实现的前<a class="ae kt" href="https://codesandbox.io/s/need-for-shadow-dom-c8897?file=/need-for-shadow-dom.js" rel="noopener ugc nofollow" target="_blank">和</a>后<a class="ae kt" href="https://codesandbox.io/s/component-with-shadow-56ijj?file=/component-with-shadow.js" rel="noopener ugc nofollow" target="_blank">代码见这些链接。</a></p><h2 id="e462" class="ln lo in bd lp lq lr dn ls lt lu dp lv kg lw lx ly kk lz ma mb ko mc md me mf bi translated">ES 模块</h2><p id="635d" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">ES 模块规范以基于标准、模块化和高性能的方式定义了 JS 文档的包含和重用。</p><p id="1e6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们看到我们能够通过简单地导入如下的<code class="fe lh li lj lk b">js</code>文件来消费 HTML 中的<code class="fe lh li lj lk b">basic-component</code></p><pre class="lb lc ld le gt ms lk mt mu aw mv bi"><span id="a5bd" class="ln lo in lk b gy mw mx l my mz">&lt;script src="./basic-component.js" type="module"&gt;&lt;/script&gt;</span></pre><p id="4486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是 ES 模块所提供的。</p><h2 id="9917" class="ln lo in bd lp lq lr dn ls lt lu dp lv kg lw lx ly kk lz ma mb ko mc md me mf bi translated"><strong class="ak"> HTML 模板</strong></h2><p id="9472" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这些模板只有在被请求时才会被呈现。这些帮助我们编写可以多次使用的标记模板。<code class="fe lh li lj lk b">&lt;template&gt;</code>和<code class="fe lh li lj lk b">&lt;slot&gt;</code>是这些 API 的一部分。</p><p id="bd7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们使用了一个 HTML 模板，我们创建了它并将其附加到一个影子根。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="2f3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，所有这些 API 都是低级的，处理它们变得非常乏味。</p><p id="60d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，随着组件变得越来越复杂，它们也变得难以维护和构建。</p><p id="c7bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">StencilJS 通过创建一个工具链来构建可重用的组件，为我们解决了这些问题</p><p id="21e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将在下一篇文章中看到如何使用 StencilJS。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><div class="lb lc ld le gt na"><a href="https://medium.com/@kkakroo/working-with-stenciljs-a4d75f7b1131" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">使用模板 JS</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">StencilJS 如何简化 Web 组件的使用</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jt na"/></div></div></a></div></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="74a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你喜欢这篇文章。如果您有任何建议或问题，可以通过 <a class="ae kt" href="https://www.linkedin.com/in/kkakroo/" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> LinkedIn </em> </a> <em class="ll">与我联系或在下面评论。</em></p></div></div>    
</body>
</html>