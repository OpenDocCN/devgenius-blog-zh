<html>
<head>
<title>What is JavaScript all about: this keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript到底是什么:这个关键字</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-javascript-all-about-this-keyword-332494a899c7?source=collection_archive---------37-----------------------#2020-07-14">https://blog.devgenius.io/what-is-javascript-all-about-this-keyword-332494a899c7?source=collection_archive---------37-----------------------#2020-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8294ef8ad8f8c85c91b5780aee3b7f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C1J5UtN6fXM-TsFT"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@artemisfaul?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artemis Faul </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f2d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中，<code class="fe ky kz la lb b">this </code>关键字的行为与其他语言如C++、Java等稍有不同。<br/>在这些语言中，<code class="fe ky kz la lb b">this </code>关键字代表类的方法中当前对象的实例，而在<strong class="kc io"> JavaScript </strong>中，这个关键字指的是正在执行当前代码并且可以被改变的对象。</p><p id="c39d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，<code class="fe ky kz la lb b">this</code>关键字指的是正在执行当前javascript代码的对象。因为JavaScript中的一切都是关于<a class="ae jz" href="https://medium.com/dev-genius/what-is-scope-all-about-1764642a2c4c" rel="noopener">作用域</a>的，所以可以在全局和局部作用域中使用<code class="fe ky kz la lb b">this</code>关键字，其值等于该作用域中的当前对象。</p><blockquote class="lc"><p id="9a40" class="ld le in bd lf lg lh li lj lk ll kx dk translated"><code class="fe ky kz la lb b">'this’</code>引用当前调用函数的对象</p></blockquote><p id="02e4" class="pw-post-body-paragraph ka kb in kc b kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx ig bi translated">让我们从一个例子开始</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7a28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码块超级简单。我已经声明了一个名为<code class="fe ky kz la lb b">getName</code>的函数、一个名为<code class="fe ky kz la lb b">name</code>的变量和两个对象。然后，我调用函数——首先作为一个全局函数，其次作为<code class="fe ky kz la lb b">obj1</code>的一部分，然后作为<code class="fe ky kz la lb b">obj2.</code>的一部分</p><p id="240c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数<code class="fe ky kz la lb b">getName</code>只是打印当前执行上下文的<code class="fe ky kz la lb b">name</code>属性的值(即<code class="fe ky kz la lb b"><em class="lx">this</em></code> <em class="lx"> </em>对象)<em class="lx">。</em></p><h1 id="4f6e" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><code class="fe ky kz la lb b"><strong class="ak">Global Execution</strong></code></h1><p id="be01" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在全局执行上下文中(任何函数之外)，<code class="fe ky kz la lb b">this</code>是指全局对象。<br/>在web浏览器中，全局对象是<code class="fe ky kz la lb b">window</code>对象，而Node.js下运行的<br/>脚本有一个名为<code class="fe ky kz la lb b">global</code>的对象作为它们的全局对象。<br/>回到我们上面的代码，一旦我们调用<code class="fe ky kz la lb b">getName </code>函数作为全局上下文的一部分，<code class="fe ky kz la lb b">this </code>关键字引用的是全局对象，也就是<code class="fe ky kz la lb b">window</code>对象，因为我们声明了一个名为<code class="fe ky kz la lb b">name</code>的变量作为全局上下文的一部分，<code class="fe ky kz la lb b">this.name</code>将打印<code class="fe ky kz la lb b">Global Name</code>。</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="1e2d" class="nf lz in lb b gy ng nh l ni nj">getName(); // print Global Name</span></pre><blockquote class="lc"><p id="6fad" class="ld le in bd lf lg nk nl nm nn no kx dk translated">每次我们将变量声明为全局上下文的一部分时，它都会在全局对象(<code class="fe ky kz la lb b">window </code> object)中创建一个新的属性。</p></blockquote><pre class="np nq nr ns nt nb lb nc nd aw ne bi"><span id="d977" class="nf lz in lb b gy ng nh l ni nj">var name = "Global Name";<br/><br/>console.log(window.name) // prints "Global Name"</span></pre><h1 id="a9db" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">本地执行</h1><p id="bfff" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在我们的代码示例中，在调用全局函数之后，我们调用<code class="fe ky kz la lb b">getName</code>函数作为对象执行上下文的一部分。<br/>这一次，一旦我们执行了函数，<code class="fe ky kz la lb b">this</code>将等于对象执行上下文。因此，该函数将打印分配给当前对象的<code class="fe ky kz la lb b">name</code>属性的值。</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="a196" class="nf lz in lb b gy ng nh l ni nj">obj1.getName() // print "Maya"<br/>obj2.getName() // print "Savir"</span></pre><h2 id="204a" class="nf lz in bd ma nu nv dn me nw nx dp mi kl ny nz mm kp oa ob mq kt oc od mu oe bi translated">让我们看看另一个例子</h2><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b903" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次，我创建了一个名为<code class="fe ky kz la lb b">getName </code>的变量，并给它分配了<code class="fe ky kz la lb b">object.getName</code>属性。<code class="fe ky kz la lb b">getName</code>作为全局上下文的一部分被调用，因此，它将打印全局<code class="fe ky kz la lb b">name</code>变量。T21:这可能会让人困惑，所以我们先讨论一下。<br/> 当我们声明<code class="fe ky kz la lb b">var getName = object.getName</code>时，我们简单地将<code class="fe ky kz la lb b">getName</code>变量赋给<code class="fe ky kz la lb b">object.getName</code>值，在我们的例子中，这只是一个将<code class="fe ky kz la lb b">this.name</code>打印到控制台的函数。所以我们也可以这样看待它，就像我们刚刚声明了一个新变量，并给它赋了一个函数，就像这样</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="829a" class="nf lz in lb b gy ng nh l ni nj">var name = "Global Name";</span><span id="a128" class="nf lz in lb b gy of nh l ni nj">var getName = function(){<br/> console.log(this.name);<br/>}</span><span id="e5c5" class="nf lz in lb b gy of nh l ni nj">getName();</span></pre><p id="782e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于前面的解释，由于我们是从全局上下文中调用<code class="fe ky kz la lb b">getName</code>函数，函数内部的<code class="fe ky kz la lb b">this</code>等于全局对象，<code class="fe ky kz la lb b"><strong class="kc io">getName()</strong></code> <strong class="kc io">将打印</strong> <code class="fe ky kz la lb b"><strong class="kc io">Global Name</strong></code> <strong class="kc io">。</strong></p><blockquote class="lc"><p id="a52b" class="ld le in bd lf lg lh li lj lk ll kx dk translated"><code class="fe ky kz la lb b"><strong class="ak">It’s important to know how, when and from where the function is called. It does not matter where the function has been declared.</strong></code></p></blockquote><h1 id="e11e" class="ly lz in bd ma mb mc md me mf mg mh mi mj og ml mm mn oh mp mq mr oi mt mu mv bi translated">隐式和显式绑定</h1><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5f47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">隐式绑定</strong>是当<code class="fe ky kz la lb b">this</code>关键字指向函数被调用的对象时(函数被调用时句点左边是什么)。</p><p id="7632" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">显式绑定</strong>是我们显式告诉JavaScript引擎设置<code class="fe ky kz la lb b">this</code>指向某个值。让我们在上面的代码片段中添加两行代码。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次，我创建了一个变量并赋予它<code class="fe ky kz la lb b">object.getName</code>属性，然后调用这个函数值。<br/>问题是，现在我<strong class="kc io">没有将全局变量<code class="fe ky kz la lb b">name</code>分配给全局对象<code class="fe ky kz la lb b">window</code>，因此<code class="fe ky kz la lb b">object2()</code>执行将打印<code class="fe ky kz la lb b">undefined</code>。</strong></p><p id="78c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这个场景，我们可以使用<code class="fe ky kz la lb b">call()</code>、<code class="fe ky kz la lb b">apply()</code>或<code class="fe ky kz la lb b">bind()</code>显式地告诉JavaScript将<code class="fe ky kz la lb b">this</code>关键字设置为一个特定的对象。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="dc20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> call()和apply() </strong> <br/>两者<code class="fe ky kz la lb b">call</code>和<code class="fe ky kz la lb b">apply</code>完成的任务是一样的，两者的第一个参数应该是<code class="fe ky kz la lb b">this</code>指向的东西。只有在需要将额外的参数传递给被调用的函数时，这种差异才显而易见。<strong class="kc io">如果你不知道将要传递的参数的数量，或者如果它们已经在一个数组或类似数组的对象中(比如arguments对象来转发你自己的参数)，使用apply </strong>。<strong class="kc io">否则使用call </strong>，因为不需要将参数包装在数组中。</p><p id="9bd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> bind() </strong> <code class="fe ky kz la lb b"><br/>bind</code>用于创建一个永久绑定到<code class="fe ky kz la lb b">this</code>值的新函数。在下面的例子中，我们创建了一个新的函数，它的<code class="fe ky kz la lb b">this</code>永久绑定到了<code class="fe ky kz la lb b">getName </code>，并将<code class="fe ky kz la lb b">getName </code>重新分配给这个新的永久绑定的函数。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><blockquote class="lc"><p id="c706" class="ld le in bd lf lg nk nl nm nn no kx dk translated">每次我们执行<code class="fe ky kz la lb b">getName()</code>函数时，我们会将它绑定到<code class="fe ky kz la lb b">person</code>对象，因此，‘<code class="fe ky kz la lb b">this’</code>将指向<code class="fe ky kz la lb b">person</code>对象。</p></blockquote><h1 id="d206" class="ly lz in bd ma mb mc md me mf mg mh mi mj og ml mm mn oh mp mq mr oi mt mu mv bi translated">新绑定</h1><p id="95c0" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">当使用<code class="fe ky kz la lb b">new</code>关键字创建一个函数对象的实例时，我们将函数用作构造函数。<br/>当一个函数作为构造函数被调用时，<code class="fe ky kz la lb b">this</code>指向创建的新对象。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a1b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当使用<code class="fe ky kz la lb b">new</code>关键字时，<br/> *一个全新的空对象被创建。<br/> *新的空对象链接到那个函数的原型属性<br/> * <strong class="kc io"> <em class="lx">这个</em> </strong>关键字绑定到同一个新的空对象，用于那个函数调用的执行上下文</p><p id="fcee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，<code class="fe ky kz la lb b">Person</code>函数被调用时前面带有<code class="fe ky kz la lb b"><em class="lx">new</em></code>关键字。它创建一个新对象，然后这个新对象被链接到函数<code class="fe ky kz la lb b">Person</code>的原型链，之后创建的新对象被绑定到<code class="fe ky kz la lb b">Person</code>函数的<code class="fe ky kz la lb b"><em class="lx">this</em></code>对象。</p><p id="12b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想知道为什么第10行显示“未定义”吗？<br/> 在第10行，已经创建了一个类型为<code class="fe ky kz la lb b">Person</code>的新对象，并且已经执行了<code class="fe ky kz la lb b">Person</code>功能。此时，<code class="fe ky kz la lb b">Person</code>函数被调用，当它到达第4行时，它打印到控制台<code class="fe ky kz la lb b">name</code>和<code class="fe ky kz la lb b">this.lastName</code>。<br/>问题是，在<code class="fe ky kz la lb b">Person</code>函数中并没有真正的<code class="fe ky kz la lb b">this.lastName</code>，但是它有一个名为<code class="fe ky kz la lb b">lastName</code>的变量——这不是一回事！<br/><code class="fe ky kz la lb b">name</code>变量来自全局声明(第7行)。</p><p id="8a9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当<code class="fe ky kz la lb b">maya.name</code>被打印到控制台(第11行)时，js引擎知道<code class="fe ky kz la lb b">maya</code>是一个类型为<code class="fe ky kz la lb b">Person</code>的对象，并且<code class="fe ky kz la lb b">Person</code>有一个<code class="fe ky kz la lb b">this.name</code>属性。由于<code class="fe ky kz la lb b">this</code>指向<code class="fe ky kz la lb b">Person</code>，我们在控制台上看到<code class="fe ky kz la lb b">Maya</code>。<br/> *如果我尝试控制<code class="fe ky kz la lb b">maya.lastName</code>，我将再次看到<code class="fe ky kz la lb b">undefined</code>，因为这个. lastName(或maya.lastName)与<code class="fe ky kz la lb b">Person</code>函数中的变量<code class="fe ky kz la lb b">lastName</code>不同。</p><h1 id="06ed" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">箭头函数绑定</h1><p id="e161" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">箭头函数不绑定它们自己的<code class="fe ky kz la lb b">this</code>，相反，它们从父作用域继承一个。</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="2f85" class="nf lz in lb b gy ng nh l ni nj"><strong class="lb io">const</strong> getName = () =&gt; {   <br/> console.log(<strong class="lb io">this</strong>); // <em class="lx">this</em> refers to the global object<br/>};  </span><span id="b0ef" class="nf lz in lb b gy of nh l ni nj">getName();</span></pre><p id="4a73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">预期结果将与正常函数相同，<code class="fe ky kz la lb b">window or global</code>对象。结果一样，原因不一样。对于普通函数，作用域默认绑定到全局作用域，<strong class="kc io"> arrows函数</strong>没有自己的<code class="fe ky kz la lb b">this</code>，但是它们从父作用域继承，在本例中是全局作用域。</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="0a3b" class="nf lz in lb b gy ng nh l ni nj"><strong class="lb io">const</strong> person = {   <br/> myName: null,   <br/> getName: <strong class="lb io">function</strong> () {     <br/>  <strong class="lb io">this</strong>.myName = () =&gt; { console.log(<strong class="lb io">this</strong>) };   <br/> } <br/>};</span><span id="beb3" class="nf lz in lb b gy of nh l ni nj">person.getName();<br/>person.myName();<br/><strong class="lb io">const</strong> myName = person.myName; <br/>myName();</span></pre><p id="b15d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们调用<code class="fe ky kz la lb b">person.getName()</code>时，我们用方法<code class="fe ky kz la lb b">getName</code>内部的箭头函数初始化<code class="fe ky kz la lb b">person.myName()</code>，因此它将继承它的作用域。<strong class="kc io">是</strong> <a class="ae jz" href="https://medium.com/dev-genius/what-is-closure-all-about-bc530dafc205" rel="noopener"> <strong class="kc io">闭包</strong> </a>的完美案例。</p><h2 id="9cdc" class="nf lz in bd ma nu nv dn me nw nx dp mi kl ny nz mm kp oa ob mq kt oc od mu oe bi translated">严格模式与非严格模式</h2><p id="3e18" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在<strong class="kc io">严格模式的情况下，</strong>全局<strong class="kc io"> </strong>这将默认为<code class="fe ky kz la lb b">undefined</code> <strong class="kc io"> <br/> </strong>而在<strong class="kc io">非严格模式的情况下</strong> <code class="fe ky kz la lb b">this</code>将默认为全局对象。</p><pre class="lr ls lt lu gt nb lb nc nd aw ne bi"><span id="7ea5" class="nf lz in lb b gy ng nh l ni nj">function getName(){<br/> 'use strict';<br/> console.log(this);<br/>}</span><span id="ac59" class="nf lz in lb b gy of nh l ni nj">getName() // prints <em class="lx">undefined</em> (instead of the global object)</span></pre><p id="1fce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">“this”关键字绑定的优先级<br/> </strong> *首先检查该函数是否用<strong class="kc io"> <em class="lx">新</em> </strong>关键字调用。<br/> *其次检查函数是否用<em class="lx"> call() </em>或<em class="lx"> apply() </em>方法调用，即显式绑定。<br/> *第三，检查函数是否通过上下文对象调用(隐式绑定)。<br/> *默认全局对象(在严格模式下未定义)。</p></div></div>    
</body>
</html>