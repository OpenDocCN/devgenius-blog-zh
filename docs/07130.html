<html>
<head>
<title>Illustrations of Design Patterns Implementations: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式实现示例:第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/illustrations-of-design-patterns-implementations-part-1-a0094426504a?source=collection_archive---------11-----------------------#2022-02-28">https://blog.devgenius.io/illustrations-of-design-patterns-implementations-part-1-a0094426504a?source=collection_archive---------11-----------------------#2022-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5192a4c17da3402258f53fbbc6213770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nZEPN8PeiOfCx2umfw5CA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">感谢 Ricardo Gomes 的这张照片:<a class="ae jz" href="https://unsplash.com/@rgaleria" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@rgaleria</a></figcaption></figure><p id="48a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我还是一名初级软件工程师时，我被告知要学习设计模式。我学会了它们。在某种程度上，我意识到我知道并理解了其中的很多，但是当我被要求举出一些应用设计模式的真实案例时——我一个也说不出来。</p><p id="6a2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将给出设计模式的实际实现的例子，我们可以在使用 React 和常见的第三方服务时找到，如 MobX、Redux 等。对于一些模式，我将分享现实生活场景的想法，在那里可以使用这些模式。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="68ed" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">示例 1:观察者</h1><p id="9f03" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">观察者设计模式是我的最爱之一(因为它是最容易理解的模式之一)。让我们回顾一下这种模式的定义:</p><blockquote class="mi mj mk"><p id="c1c2" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">Observer 是一个行为设计模式，它允许你通知几个对象关于他们订阅监听的对象正在发生的某些事件。最新的被称为可观测的。</p></blockquote><p id="02de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于那些不知道的人来说，行为模式是允许对象之间有效交互的模式。</p><p id="c970" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我现在要举的例子很可怕，但我不想想出什么复杂的东西来给你添堵。简单说一下这个模式，假设你有某个网站，它可以根据时间把它的 UI 从亮模式换成暗模式。有趣的是，我们不想把所有的 UI 都改成黑暗模式，我们只想改变 UI 的某些部分。如果是晚上 8 点到早上 6 点，我们希望我们的组件是深色的。否则——光。因此，我们的组件(观察者)需要倾听(观察)时间(可观察的)并相应地改变它的颜色。这基本上可以通过观察者模式来实现。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="35dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我看来，这种模式实现的最好例子是 MobX。MobX 的核心理念是我们创建一个商店，在那里我们有我们的<strong class="kc io">观察点</strong>。然后，我们用一个<strong class="kc io">观察者</strong> HOC 包装我们的 React 组件，该观察者为我们的组件订阅可观察对象。</p><blockquote class="mi mj mk"><p id="c349" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">重要提示:我们的组件将只监听那些在渲染过程中使用的可观察到的变化。不是所有可观察到的。</p></blockquote><p id="46e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将展示一个稍加修改的示例，摘自 MobX 官方文档:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a93c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将不讨论 MobX 库的细节，因为这不是本文的主题。我们创建了一个商店，在那里我们希望有我们可观察的<strong class="kc io">秒</strong>，我们也用<strong class="kc io"> increaseTimer </strong>函数修改它。这个例子中你需要知道的就是<strong class="kc io">make auto observable(this)</strong>会把<strong class="kc io">秒</strong>变量变成可观测的。</p><p id="3789" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们将向该商店订阅组件。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b23d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，我们用特设的<strong class="kc io">观察者</strong>包装了<strong class="kc io">应用</strong>组件，然后我们开始渲染<strong class="kc io">秒</strong>，这是我们从<strong class="kc io">定时器商店</strong>中获取的。</p><blockquote class="mi mj mk"><p id="bd36" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">重要提示:在<strong class="kc io"> useEffect </strong>钩子中，我正在设置一个间隔来调用<strong class="kc io"> increaseTimer </strong>方法并改变存储中的<strong class="kc io"> seconds </strong>变量，并且我也在卸载时清除这个间隔。记得在卸载时清除间隔和侦听器。</p></blockquote><p id="1d07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们启动 React 应用程序，看起来会是这样:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/244de463bfd5dbd0d554fee01a7002dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*rnsMVjGzJdeTQkRjUGRD-A.gif"/></div></figure><p id="cfcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">就这样。</strong>这是现实生活中观察者模式实现的一个简单例子。</p><p id="3b3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个很好的例子是 Redux 的<strong class="kc io"> useSelector </strong>。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a404" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个特定的例子中,<strong class="kc io">使用选择器</strong>做什么——它基本上将我们的<strong class="kc io">应用</strong>组件订阅到 Redux 商店，具体来说是订阅到<strong class="kc io">用户</strong>数组。每当<strong class="kc io">用户</strong>数组发生变化，它会通知<strong class="kc io"> App </strong>组件，并导致重新渲染。所以，<strong class="kc io">用户</strong>——是可观察对象，<strong class="kc io">App</strong>——是观察者。</p><h1 id="4803" class="lf lg in bd lh li mw lk ll lm mx lo lp lq my ls lt lu mz lw lx ly na ma mb mc bi translated">示例 2:工厂</h1><p id="9b17" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">工厂是最受欢迎的模式之一。定义:</p><blockquote class="mi mj mk"><p id="d943" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">工厂——是一种创造性的设计模式，它为您提供了一个接口，允许您创建其他类的实例，而无需指定确切的类。</p></blockquote><p id="2a65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创造性设计模式——是一种让您轻松安全地创建新对象的模式。</p><p id="0156" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单地说，工厂只是一个对象，它允许你创建其他对象。当然你可以自己创建其他对象，不需要工厂。但是工厂的想法是隐藏其他对象的创建逻辑，因为这个创建逻辑可能很复杂。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="51f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我能想到的最好的使用案例之一是这样的——假设你为一家公司工作，这家公司轻视第三方库，想要为几乎任何任务从头创建自己的库。这家公司创建不同的项目，其中一些使用相同的 API。</p><p id="d00b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，问题是:我们有几个项目使用相同的 API。而且这些项目有 100%的 API 重复代码。</p><p id="d1a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决方案:让我们创建一个 NPM 包。这个包将为您提供调用我们的 API 的方法。</p><p id="9265" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是工厂模式在哪里？怎么用？</p><p id="e2c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们必须创建一个 NPM 包，它允许我们调用这些路由:<br/>GET<em class="ml">/users</em>to<em class="ml"/>GET 一组用户<em class="ml"/><br/>GET<em class="ml">/users/:id</em>to<em class="ml"/>GET 一个特定用户<br/>GET<em class="ml">/activities</em>to<em class="ml"/>GET 一组活动<br/>GET<em class="ml">/activities/:id【id</em></p><p id="fdbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将以这种方式完成这项任务(没有工厂模式的示例):</p><ol class=""><li id="591b" class="nb nc in kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated">创建网络客户端。</li></ol><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="674e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个网络客户端基本上用默认配置设置了 Axios，<strong class="kc io"> networkClient </strong>变量公开了一些方法，我可以用它们来调用 API。在这个特殊的例子中，我们只能发出 GET 请求。</p><p id="48db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.为用户创造服务。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f393" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是一个具有两个方法的类，这两个方法非常简单——这两个方法使用<strong class="kc io">网络客户端</strong>向用户 API 发出 GET 请求。然后我导出这个类的一个实例。</p><p id="686a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.为活动创建服务。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b29f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.我们如何使用这些服务的例子。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="485a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下导入，我正在导入用户服务 API，然后导入活动服务 API。这就是问题所在，用户服务和活动服务在我们公司的许多应用程序中重复，我们必须进行两次导入，而我们只能进行一次导入。带有工厂模式。</p><p id="8d39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在到工厂模式。让我们稍微修改一下我们的用户服务和活动服务:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="41ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，我们不再导入这些类的实例，而是导入类本身。</p><p id="4740" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的 API 工厂将如下所示:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f859" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用可用的 API 服务创建了一个对象<strong class="kc io">API</strong>。然后，我查看这个 API 服务是否存在—我返回这个服务的一个新实例，如果不存在—我抛出一个错误。</p><blockquote class="mi mj mk"><p id="bd46" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">提示:我没有使用 if-else/switch，因为通过键访问对象的值更快。在这个特殊的例子中，if-else/switch 就可以了(因为只有 2 个 API)，但是在我们想象的情况下，我们可能有 10 个以上的 API 要调用，所以 object 会更好。</p></blockquote><p id="e7bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我会像这样使用这个工厂:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6665" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您看，现在我们只导入一个工厂，并从这个工厂获取我们服务的实例。关键是，如果我真的用这个工厂创建了一个库，我们的导入会是这样的:</p><pre class="mp mq mr ms gt nk nl nm nn aw no bi"><span id="e712" class="np lg in nl b gy nq nr l ns nt">import apiFactory from '@companyName/apiFactory';</span></pre><p id="d12a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">就是这个</strong>，我已经隐藏了服务实例的创建细节。现在，您不需要自己创建服务，不需要向您的项目添加更多代码，您只需使用这个<strong class="kc io">@ company name/API factory</strong>NPM 包，并访问您需要进行 API 调用的任何实例。</p><p id="eba1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，您可以在<strong class="kc io"> node_modules </strong>中看到源代码，但是您需要这样做吗？如果事情不顺利，也许你会。我有时也会检查<strong class="kc io"> node_modules </strong>并在需要时创建补丁。但是现在——你有一个工厂，工厂返回你需要的实例，你不需要其他任何东西。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e547" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您阅读这篇文章。如果您有任何意见、问题，认为有些地方解释错误或可以解释得更好，请通过电子邮件<strong class="kc io"><em class="ml">islamrustamov @ rambler . ru</em></strong>或下面的评论与我联系。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="acb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">资源:</em></p><p id="0ea8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">百科—</em><a class="ae jz" href="https://www.wikipedia.org/" rel="noopener ugc nofollow" target="_blank"><em class="ml"/></a></p><p id="fe6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml"> Redux 官方文档—</em><a class="ae jz" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://react-redux.js.org/api/hooks</em></a></p><p id="8cdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml"> MobX 官方文档—</em><a class="ae jz" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://mobx.js.org/README.html</em></a></p><p id="41e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">我的头</em></p></div></div>    
</body>
</html>