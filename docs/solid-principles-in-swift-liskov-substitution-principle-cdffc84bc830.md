# 斯威夫特的坚实原则——利斯科夫替代原则

> 原文：<https://blog.devgenius.io/solid-principles-in-swift-liskov-substitution-principle-cdffc84bc830?source=collection_archive---------3----------------------->

![](img/32ea14b7ee7b59404572820ba218521c.png)

[火星](https://unsplash.com/@heylagostechie?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 背景

在这一系列的帖子中，我们将涉及软件开发的坚实原则。这些是一组原则/指导方针，当开发软件系统时遵循这些原则/指导方针，使得系统随着时间的推移更容易扩展和维护。让我们来看看他们寻求解决的问题:

*   脆弱性:一个变化可能会破坏意想不到的部分，如果你没有一个好的测试覆盖率，这是很难检测到的
*   不可移动性:一个组件很难在另一个项目或同一个项目的多个地方重用，因为它有太多耦合的依赖关系
*   刚性:变更需要大量的努力，因为它影响到项目的几个部分

那么坚实的原则是什么呢？

*   单一责任原则——一个类应该只有一个责任/只有一个改变的理由
*   开闭原则——软件应该对扩展开放，但对修改关闭
*   Liskov 替换原则——程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性
*   接口分离原则——许多特定于客户端的接口比一个通用接口要好
*   依赖倒置原则——高级模块不应该依赖低级模块。两者都应该依赖于抽象

在本文中，我们将集中讨论利斯科夫替代原理。

# 这是什么意思？

所以里斯科夫替代原理说:

> *派生类必须可以替换它们的基类*

这到底是什么意思？从基本意义上来说，例如，如果你有一个函数，它接受一个类的类型，这个类是其他类的父类，那么任何一个子类化这个父类的类都应该能够被传入，而不会破坏程序。

参见以下原则要点的总结:

1.  子类型中方法参数类型的抵销差异。
2.  子类型中方法返回类型的协方差。
3.  新异常不能由子类型中的方法引发，除非它们是由超类型的方法引发的异常的子类型。
4.  不要在输入参数上实现比父类实现的更严格的验证规则。
5.  将至少与父类相同的规则应用于所有输出参数。

让我们看看这些不同的规则对子类意味着什么。

# 父类

首先，让我们定义包含一些功能的父类或基类。让我们用一个车辆类别作为例子，这个车辆有一个节流阀，可以设置在 0 到 100 之间的任何值。

让我们一步一步来:

1.  首先，我们定义了一个自定义错误，如果油门不在界限内，将抛出该错误
2.  这里我们定义了我们的 vehicle 类，它有一个 throttle 变量来存储设置的值
3.  我们有一个函数来设置节流值，有一个 guard 语句来检查设置的值是否在适当的范围内。如果不是，我们抛出一个错误，如果是，我们设置值

# 输入参数的验证规则

现在让我们创建一个打破这个原则的子类。我们将创建一个从超类继承而来的卡车类，但是将自己的限制添加到 throttle 函数中，例如，只允许 throttle 设置在 0 到 60 之间。

这里发生了什么？我们创建了 Vehicle 类的子类，并覆盖了 setThrottle 方法。现在，我们在这里所做的是，我们添加了一个 guard 语句来检查 throttle 是否在 0 到 60 之间。如果超出界限，我们抛出一个错误，如果在界限内，我们调用超类方法。

为什么这是一个问题？假设我们正在构建一个与 Vehicle 类交互的系统/类。现在，根据车辆类别，您可以将油门设置为 0 到 100 之间的任意值。然而现在，如果有人选择将一个卡车子类传递到你的系统/类中，你将不能将油门设置在 60 以上。根据其他类或系统的构建方式，这可能会产生意想不到的副作用，因为您无法在不出错的情况下设置预期的值。

这个例子打破了规则:

> 不要在输入参数上实现比父类实现的更严格的验证规则。

# 利斯科夫原理中的错误

让我们修改一下我们的例子，看看如何通过抛出不同的错误来打破这个原则。让我们修改卡车子类:

这里发生了什么:

*   我们添加了一个新的错误类型，称为 LorryError
*   当我们有 bounds 异常时，我们抛出这个新的错误类型，而不是由超类提供的错误类型

为什么这会引起问题呢？为了找到答案，让我们看一下错误处理代码:

让我们浏览一下这段代码:

1.  我们正在创建一个车辆超类对象。
2.  我们用一个被认为越界的值调用我们的函数
3.  我们捕获 outOfBounds 异常并输出系统关闭消息
4.  我们对其他错误有一个通用的捕捉机制，在这里我们显示一个通用的错误消息

现在，如果我们运行这段代码，我们会在控制台中看到预期的以下消息:

> *系统关闭*

那么，如果我们用新的 error 替换我们的卡车子类，并把它放在 Vehicle 超类的位置，会发生什么呢？如果我们将第一行改为:

如果我们运行上面的代码，我们现在会看到一个不同的错误:

> *显示一般性错误*

错误处理代码不知道特定于子类的错误，因此不再能够相应地处理它们。想象一个任务关键型系统，如果发生越界，它需要关闭，在这种情况下，错误将被遗漏，因为它需要错误处理类知道所有可能的子类型，以便适当地处理所有错误。击败了使用超类的点，从而打破了原则:

> 子类型中的方法不能抛出新的异常，除非它们是由超类型的方法抛出的异常的子类型。

# 参数和返回类型的反方差和协方差

在规则列表中，您可能记得看到过两项关于参数和返回类型的相对方差和协方差的内容。这到底是什么意思？

1.  子类型中方法参数类型的抵销差异。
2.  子类型中方法返回类型的协方差。

# 子类型中方法参数类型的抵销差异

反向方差意味着我们可以将方法参数的类型更改为该类型的超类，而不是子类。该规则基本上与以下规则结合使用:

> 不要在输入参数上实现比父类实现的更严格的验证规则。

这意味着，我们可以使用一个参数的超类，从而“削弱”方法的限制，但不能使用该类型的子类来加强方法的限制。

# 子类型中方法返回类型的协方差

协方差意味着正在使用的类型可以是超类函数返回类型提供的类的子类型。同样，这与第五条规则的工作方式相同:

> 将至少与父类相同的规则应用于所有输出参数。

现在，作为 Swift 的一部分，这两条规则都不可能被打破。不可能重载提供替代类型规范的函数，至少在引用超类类型时是这样。我们可以覆盖方法并提供不同的参数类型和返回类型，但这需要调用类知道子类的类型。当引用超类时，无论子类函数的参数不同，都会调用超类实现。

*原载于 2022 年 4 月 18 日*[*https://pyartez . github . io*](https://pyartez.github.io/architecture/solid-principles-in-swift-liskov-substitution-principle.html)*。*