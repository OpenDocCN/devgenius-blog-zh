<html>
<head>
<title>Insertion Sort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">插入排序算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/insertion-sort-algorithm-c8c6aee65c8c?source=collection_archive---------11-----------------------#2020-06-08">https://blog.devgenius.io/insertion-sort-algorithm-c8c6aee65c8c?source=collection_archive---------11-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a8b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Swift 中插入排序的逐步说明</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e0ecb76c8753fe23a04425a53513d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOI0XyrWS_3tchwotnMF8Q@2x.jpeg"/></div></div></figure><h1 id="f2bb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">插入排序:</strong></h1><blockquote class="ls lt lu"><p id="a9f4" class="jk jl lv jm b jn jo jp jq jr js jt ju lw jw jx jy lx ka kb kc ly ke kf kg kh ig bi translated"><strong class="jm io">插入排序是一种简单的排序算法，一次构建一个最终排序的数组。</strong> <em class="in">🤔🤔🤔</em></p></blockquote><h1 id="7548" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">让我们看看这个概念，然后我们将逐行理解🤏代码🤩</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/02200ad0c6bafa114876b507f383de9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8ll1v0O42L9pEM3i6Gcp7Q.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">数组样本</figcaption></figure><p id="e9b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 1 : </strong>将该数组分成两部分:-排序数组和未排序数组👍(GIF -1)</p><p id="44b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:数组的第一个元素总是排序的🤪</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/068d1b434fcb7dc58bf41b1c7184a906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JqkBMfT2oypsq4bfmtLtmA.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">GIF-1</figcaption></figure><p id="6b97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 2 : </strong>将未排序数组的第一个元素存储在一个常量中(常量名:key)</p><p id="d1c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例(GIF-2)中，值 6 存储在常量名称键中。</p><p id="708f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 3 : </strong>将关键字与排序后的数组进行比较，如果关键字小于值，则将值从左向右移动，如果排序后的数组中没有更多可比较的元素，则插入关键字。</p><p id="1849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子(GIF-2)中，我比较了 6 和 8，6 小于 8，所以我们将 8 向右移动，之后没有元素可用，所以我们不能再比较 key。</p><h2 id="94b3" class="me kv in bd kw mf mg dn la mh mi dp le jv mj mk li jz ml mm lm kd mn mo lq mp bi translated">所以最后两个元素在这个数组中排序，三个元素未排序。现在我们必须重复同样的步骤👏👏👏</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/734469992d436ddab145ae20a17a5e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SCCyYQmRtDgA2yKHqFuopw.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">GIF-2</figcaption></figure><p id="fa22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 5 : </strong>将未排序数组的第一个元素存储在 key 中，并将 key 与排序后的数组进行比较。如果键小于值，则将值从左向右移动</p><p id="04f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 6 (A): </strong>将关键字与排序数组的剩余元素进行比较。如果键小于值，将值从左向右移动，如果没有更多的元素要比较，则插入键。</p><p id="7f4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 6 (B) : </strong>如果 key 大于 value，则在 value 之前插入 key。</p><p id="9317" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以很容易地注意到，我们在排序后的数组中从后向前移动，找到插入键的正确位置(键只是未排序数组的第一个元素)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/8f18f9e3cdf26aeeb47e520fee14dec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kLyD2b3yaKCl6NmSHp1mTA.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">GIF-3</figcaption></figure><p id="f05e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见(GIF-4 ),该数组的三个元素是排序的，两个元素是未排序的。我们将继续同样的过程，所有的元素将被排序🤝</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/bdbc4cfc3811d96dcbb6834fb08f10f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dYeD_rpaTjOn6k47MQ3Ymg.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">GIF-4</figcaption></figure><h1 id="9abb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">🤓现在让我们为这个算法编码🤓</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/65750f39f424601ea57a514d4205e91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*_KxBUaIyD6V0siIfyfceNw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图 10</figcaption></figure><p id="ac9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 12 行:</strong>宣告本阵。</p><p id="c43e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 14 行:</strong>从未排序数组的第一个元素开始循环。</p><p id="30de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 16 行:</strong>将未排序数组的第一个元素存储在 constant-key 中。</p><p id="e2fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 18 行:</strong>存储排序数组的最后一个索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/65750f39f424601ea57a514d4205e91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*_KxBUaIyD6V0siIfyfceNw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图 10</figcaption></figure><p id="de1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 19 行:</strong>通过将未排序数组的第一个元素与已存储数组的所有元素进行比较，在已排序数组中查找合适的插入位置。</p><p id="72e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 20 行:</strong>如果键小于值，则从左向右移动值。</p><p id="ca3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 21 行:</strong>减小‘j’的值，这样我们可以在排序后的数组中从最后一个到第一个反向移动。</p><p id="16c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 23 行:</strong>在右边位置插入键(未排序数组的第一个元素)。</p></div></div>    
</body>
</html>