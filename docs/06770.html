<html>
<head>
<title>Callback function to suspend function and Flow (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">暂停函数和流的回调函数(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/callback-function-to-suspend-function-and-flow-part-1-c17e2e523a18?source=collection_archive---------3-----------------------#2022-02-02">https://blog.devgenius.io/callback-function-to-suspend-function-and-flow-part-1-c17e2e523a18?source=collection_archive---------3-----------------------#2022-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/86c38e00d4ee229279dfd52c09c2fd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DB7-Ul3NKRP5pwRHh7c4g.jpeg"/></div></figure><p id="2ac7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">大多数库都实现了协程，它让我们开发更容易、更安全、更符合语法的代码。然而，一些 SDK 或项目功能还没有实现协程。在本文中，我们将把它们迁移到挂起功能和流。</p><p id="7f5d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我敢打赌，每个开发人员都遇到过要么片段 AbcFragment 没有附加到活动，要么 NullPointerException 基于上下文的东西。如果你在处理回调的话，在比赛条件下思考和发展是非常困难的。此外，如果你试图并行处理更多的回调，它会变成火箭科学，但我们不是在建造火箭，所以让我们摆脱样板，难以理解的回调。</p><p id="e958" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将这篇文章分成两部分，但是我们将不得不在这一部分讨论何时使用<strong class="jt io">暂停函数</strong>或<strong class="jt io">流</strong>。</p><p id="31d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">事实上，很容易理解如果回调只返回一次数据，你应该选择暂停函数，否则你的回调会多次发出数据。</p><p id="160f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面是<strong class="jt io">暂停功能</strong>和<strong class="jt io">流程</strong>使用示例；</p><p id="d3fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">暂停功能</strong></p><p id="c3df" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">从 Restful api 获取数据</em></p><p id="c00b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">从 LocationApi 获取一个时间位置</em></p><p id="cb09" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">获取繁重任务的输出，如查看位图、数学计算等。</em></p><p id="3c54" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">从 Firebase Auth 获取用户令牌</em></p><p id="75dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">将数据保存到文件或从文件中读取</em></p><p id="fa9d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">流</strong></p><p id="0dc9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">持续获取用户位置</em></p><p id="a288" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">从 Socket 获取货币或每次从 Restful API 获取货币</em></p><p id="4aca" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">从硬件获取传感器数据</em></p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><p id="f3d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如你所看到的，很明显，当你想获得数据并继续时，你应该选择暂停功能，不像暂停功能，你想让数据作为一个流，你应该选择流。</p><h1 id="61b7" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">理解为什么我们应该使用协程</h1><p id="de46" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">在直接进入最佳解决方案之前，我们必须看到并理解为什么其他解决方案没有效率。我认为这是理解我们为什么应该使用协程的最好方式。</p><p id="0183" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了理解和解决这个问题，让我们创建我们的超级简单的 SDK。</p><p id="9ea4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如您所见，在给定的假持续时间(3 秒)后发出值。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/16a64c9c40c637fb7a8224b5b320253e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhZzINhv2nz-vfkX1_Pl_g.png"/></div></div></figure><p id="33e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是视图端的实现。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/fb0f2711e8594d7bacfb08c874010d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29dl20JPYk-2c91DrgZ3SA.png"/></div></div></figure><p id="c28a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们试试吧</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/57978170b850b9b84f4ba8fa3eff0ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*vXj-4dcvMm0BBzgNG_64ag.gif"/></div></figure><p id="33b1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">很好用吧？但是，如果用户不等待结果就关闭第二个片段，会发生什么呢？</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/4e5e64d9048b8a4f51e2ac7cdd609cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*f0xHSNdHC1RbnzanVQWXjw.gif"/></div></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mk"><img src="../Images/86ad5e30e1a85f8759072bfd3fceff15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cbku2yUpPhHHQUlg"/></div></div></figure><p id="6526" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">呃，有一个问题是在 FragmentTwo 被销毁后回调会发送结果，那么我们该如何解决这个问题呢？</p><p id="2b7a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有解决办法；</p><p id="ff31" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">解决方案 1 向 SDK 的回调结果添加 isAdded 条件</strong></p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/15b53ac941b38414621c19398e72efec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAtfgdOYvM6UH2KS9bkajA.png"/></div></div></figure><p id="e377" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是修复这类崩溃的一种简单快捷的方法。但是这个解决方案有两个缺点。</p><ol class=""><li id="a0e8" class="ml mm in jt b ju jv jy jz kc mn kg mo kk mp ko mq mr ms mt bi translated">开发人员和代码审查人员每次使用 SDK 时都必须记住。</li><li id="bccf" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated"><em class="kp">我们解决了崩溃问题，但 SDK 仍然继续工作，并返回未使用的值，浪费设备资源。</em></li></ol><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mz"><img src="../Images/42de818644481d50e0a903b8d8a06ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxIPhSPPNAgoUVt7zfgRsA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">Logcat 输出显示 SDK 的方法继续工作</figcaption></figure><p id="41aa" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">解决方案 2 在视图上管理 SDK</strong></p><p id="0b6c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好吧，第一个问题看起来不那么重要，但是第二个问题很烦人，让我们试着解决它。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/7ec0406cc288dcf62cc1d9b058cc52d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9voFBPTusjCmXdPjWAvjg.png"/></div></div></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/4aad84b4628941d55d70fbf103134f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGQkgX4LCPm43_PtmvOb4Q.png"/></div></div></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/927dd8f158a663cfe6d0bbdfe804a34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lj8FWmLbxtwX-GMjaq_C_Q.png"/></div></div></figure><p id="70ef" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">是的，明白了！我们解决了用户设备上的资源浪费问题。然而，这种方法以如此多的样板代码而告终，第一个问题现在看起来如此令人烦恼。</p><p id="064f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们试图用传统的方法找到解决办法。我们已经给了 SDK 的管理能力一个视角，但是记住本大叔对蜘蛛侠说的话；</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c8a5a5c64c10fb33b4289a13d6e7f43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*SpG67ekUc0RiUueB"/></div></figure><p id="43e6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这两种解决方案都在实现 SDK 的视图端承担了很大的责任。但是视图已经有了这么大的责任，那就是绘制和监听视图事件。因此，让我们来减轻这一负担。</p><p id="9263" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们不让蜘蛛侠忙碌起来，他可以用他最好的方式创造更多的英雄事迹..如果我们用图画来观察事物，它可以使工作更加清晰，没有任何问题，对吗？</p><p id="6472" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我说有另一种解决方案如此渴望从应用程序的角度或部分角度承担责任，那会怎么样？</p><p id="342e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">是的，我猜你和我想的一样，让我们用协程来实现它。</p><h1 id="144e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用协程包装回调函数</h1></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="797d" class="kx ky in bd kz la nf lc ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu bi translated"><strong class="ak">解决方案 3 </strong>挂起协同例程</h1><p id="f173" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">实现你的回调函数是如此简单，你只需要像下面这样包装它。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/8240ff0514933e094a5f9a311736fd52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rm7HtPhzailqUAzhKI603Q.png"/></div></div></figure><p id="58a2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是我们在视图端的新实现。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/8ec10b6f95184eed78b273f05a8f7503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSfTD0T55PIC7HU2yT7SbQ.png"/></div></div></figure><p id="1764" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不再有异常和回调。最后，我们修复了它，打算使用它的开发人员不必再注意这些缺陷了。</p><p id="e0eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们的问题是什么？</p><ol class=""><li id="9065" class="ml mm in jt b ju jv jy jz kc mn kg mo kk mp ko mq mr ms mt bi translated"><em class="kp">开发人员和代码审查人员每次使用 SDK 时都必须记住。</em></li><li id="4dc1" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated"><em class="kp">我们解决了崩溃问题，但 SDK 仍然继续工作并返回一个未使用的值，浪费了设备资源。</em></li></ol><p id="ceaf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">是的，我们完全解决了第一个问题。让我们试着看看第二个问题。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mz"><img src="../Images/42de818644481d50e0a903b8d8a06ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxIPhSPPNAgoUVt7zfgRsA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">Logcat 输出显示 SDK 的方法一直在工作</figcaption></figure><p id="755e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">呃，它还能工作。怎么可能呢？我们如何解决第二个问题？</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="6f53" class="kx ky in bd kz la nf lc ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu bi translated">解决方案 4<strong class="ak">suspendecancellablecoroutine</strong></h1><p id="fa19" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">乍一看，Coroutine 的最大优势似乎是使代码更具可读性和安全性。是的，它们当然是强大的优势，但是结构化并发比它们更有优势。</p><p id="fbdb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">挂起功能必须是协作性的。所有内置的挂起功能都关注并承担开发人员的责任。</p><p id="6eea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">举个例子，</p><p id="d102" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你查看延迟函数文档，你会发现它并没有阻塞当前线程，并且知道这个取消。</p><p id="fc29" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae nk" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" rel="noopener ugc nofollow" target="_blank">https://kot Lin . github . io/kot linx . coroutines/kot linx-coroutines-core/kot linx . coroutines/delay . html</a></p><p id="a8a5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">用一个可取消的协程来实现。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/e92bd2bd6f538b98d2feb12eb00e1035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2d8CeaCfZo6tgrOv2PQIQ.png"/></div></div></figure><p id="a4d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当<strong class="jt io">一个父作业</strong>被<strong class="jt io">取消</strong>时，它将取消传播到<strong class="jt io">子挂起函数</strong>捕捉到<strong class="jt io">调用取消</strong>并停止 SDK 的任务。并且在视图端与<strong class="jt io"> suspendCoroutine </strong>的实现没有区别。</p><p id="a62d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望对理解协程为什么会发挥作用有所帮助。这是我的教学方法，因为我相信这是理解和记住的最好方法。了解问题所在，然后我们如何以可持续和可靠的方式解决这些问题。</p><p id="f90e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在文章的下一部分，我们将实现<strong class="jt io">流程</strong>，但是你已经明白了主要的意思。下一篇文章将会尽可能的简短。如果你在评论中遇到困难，请告诉我。</p></div></div>    
</body>
</html>