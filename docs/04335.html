<html>
<head>
<title>Rate Limiting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">限速</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rate-limiting-a0a02f98ebb3?source=collection_archive---------3-----------------------#2021-03-02">https://blog.devgenius.io/rate-limiting-a0a02f98ebb3?source=collection_archive---------3-----------------------#2021-03-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/fb4c93462715828c1694405950876310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-htvtgU_w3oFgoJp-g2VUg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/photos/dBI_My696Rk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">影像学分</a></figcaption></figure><div class=""/><div class=""><h2 id="de09" class="pw-subtitle-paragraph ka jc jd bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">设计一个API速率限制器来限制超过给定阈值的用户</h2></div><h1 id="692b" class="ks kt jd bd ku kv kw kx ky kz la lb lc kj ld kk le km lf kn lg kp lh kq li lj bi translated">漏桶算法</h1><p id="22bd" class="pw-post-body-paragraph lk ll jd lm b ln lo ke lp lq lr kh ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我喜欢把漏桶想象成沙漏里的沙子。不管你放多少沙子，它都会以恒定的速度滴下。</p><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/767e34e406a061911d2d64f0427a9b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kETGZlVJVzjKZuTnYC-xMQ.jpeg"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/photos/5Hl5reICevY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">图像学分</a></figcaption></figure><p id="a5a2" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">这个算法就是这样。每个用户都有一个独立的沙漏，当他们被大量并发请求淹没，填满玻璃桌面时，新的请求将被拒绝。恒定的滴沙速度平滑了<em class="mg">突发</em>请求，并以近似平均的速率处理它们。</p><p id="1d06" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">您需要一个计数器来知道正在进行的<em class="mg">请求的数量，并需要一个队列来将传入的请求推入。队列(桶)的容量是您准备接受的“突发”流量。</em></p><p id="ee6c" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">当请求进来时，计数器(每用户)需要增加，并且在请求处理后减少。我们可以将这些数据保存在Memcahed/Redis中。虽然这种算法提供了流量平滑和内存占用较小的优点，但它有几个限制。</p><ul class=""><li id="9f78" class="mr ms jd lm b ln mm lq mn lt mt lx mu mb mv mf mw mx my mz bi translated">它有两个参数(平均速率和脉冲串),这两个参数并不总是容易调整。</li><li id="a4c8" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated">无论您选择什么(Memcached/Redis)，您都只能支持有限的原子操作，比如<code class="fe nf ng nh ni b">GET</code>、<code class="fe nf ng nh ni b">SET</code>和<code class="fe nf ng nh ni b">INCR</code>。并且该算法需要多个不同的操作，这些操作不能自动完成。此外，建立一个锁定机制来执行这些操作会降低整个处理过程的速度，并且可能无法伸缩。</li><li id="5ab9" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated">填满队列的旧请求会使最近的请求变得饥饿，并且不均匀的延迟会带来麻烦。</li></ul><h1 id="ed8e" class="ks kt jd bd ku kv kw kx ky kz la lb lc kj ld kk le km lf kn lg kp lh kq li lj bi translated">固定窗口算法</h1><p id="790b" class="pw-post-body-paragraph lk ll jd lm b ln lo ke lp lq lr kh ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在这个算法中，系统使用一个固定的<code class="fe nf ng nh ni b">n</code>秒的窗口。在给定的窗口中，如果请求在给定的阈值内，则在该给定的阈值之后，它们被允许和拒绝。这是一个简单的方法，解决了漏桶算法的两个局限性。首先，你不需要多重操作，只有<code class="fe nf ng nh ni b">INCR</code>就够了。第二，它会丢弃旧的请求来服务新的请求。</p><p id="257d" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">然而，这提出了一个不同的问题。假设，我们有一个固定的窗口大小<code class="fe nf ng nh ni b">1</code>秒，阈值是<code class="fe nf ng nh ni b">5</code>。<code class="fe nf ng nh ni b">5</code>请求在<code class="fe nf ng nh ni b">0.59th</code>秒到达，<code class="fe nf ng nh ni b">5</code>请求在<code class="fe nf ng nh ni b">1.01th</code>秒到达。这种算法将允许这样的情况，这将导致处理两倍的请求率。</p><h1 id="1707" class="ks kt jd bd ku kv kw kx ky kz la lb lc kj ld kk le km lf kn lg kp lh kq li lj bi translated">滑动窗口算法</h1><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a68f2c8605ad4a73aa350f5e66cc17ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Dgif0OKAPztL1hbs7AMHCA.jpeg"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/photos/qbP_kUO8tyY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">图像演职员表</a></figcaption></figure><p id="72ba" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">这是对<em class="mg">固定窗口算法</em>的稍微修改。在这种方法中，假设当前请求来自于<code class="fe nf ng nh ni b">1.2</code>秒。这意味着，当前窗口只完成了<code class="fe nf ng nh ni b">20%</code>(考虑同样的<code class="fe nf ng nh ni b">1</code>第二个窗口大小)。因此，我们将检查前一个窗口的最后一个<code class="fe nf ng nh ni b">80%</code>。如果结合这两个部分的请求数量超过阈值，则该请求将被拒绝。该算法的这一关键差异使“突发”流量受到控制。</p><h1 id="bd82" class="ks kt jd bd ku kv kw kx ky kz la lb lc kj ld kk le km lf kn lg kp lh kq li lj bi translated">结论</h1><p id="596e" class="pw-post-body-paragraph lk ll jd lm b ln lo ke lp lq lr kh ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">滑动窗口算法可以证明比其他算法执行得更好，同时保持较小的内存占用。仅使用原子操作就可以使用Redis/Memcached来维护计数器。</p><p id="52f1" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">但是，对于每个请求，我们都需要查询Redis服务器，这可能会阻塞服务器。更重要的是，它会降低合法查询的速度。为了缓解这个问题，一旦需要使用时间戳阻止客户端信息，每个服务器可以在本地维护客户端信息。在此之前，只查询本地存储的数据来拒绝请求，这肯定有助于减轻大规模攻击。</p><p id="994b" class="pw-post-body-paragraph lk ll jd lm b ln mm ke lp lq mn kh ls lt mo lv lw lx mp lz ma mb mq md me mf ig bi translated">可以有更复杂的方法来进一步提高性能，但最终这都取决于您可以投入的时间和精力以及它为您的系统增加的价值。</p><h1 id="ac43" class="ks kt jd bd ku kv kw kx ky kz la lb lc kj ld kk le km lf kn lg kp lh kq li lj bi translated">参考</h1><ul class=""><li id="59fb" class="mr ms jd lm b ln lo lq lr lt nj lx nk mb nl mf mw mx my mz bi translated"><a class="ae ja" href="https://en.wikipedia.org/wiki/Leaky_bucket" rel="noopener ugc nofollow" target="_blank">漏桶—维基百科</a></li><li id="d00f" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated"><a class="ae ja" href="https://blog.cloudflare.com/counting-things-a-lot-of-different-things/" rel="noopener ugc nofollow" target="_blank">我们如何构建能够扩展到数百万个域的速率限制</a></li><li id="6794" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated"><a class="ae ja" href="https://www.figma.com/blog/an-alternative-approach-to-rate-limiting/" rel="noopener ugc nofollow" target="_blank">速率限制的替代方法</a></li><li id="4929" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated"><a class="ae ja" href="https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm/" rel="noopener ugc nofollow" target="_blank">如何设计一个可扩展的速率限制算法</a></li><li id="f0c8" class="mr ms jd lm b ln na lq nb lt nc lx nd mb ne mf mw mx my mz bi translated"><a class="ae ja" href="https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/" rel="noopener ugc nofollow" target="_blank">利用Redis排序集合实现更好的速率限制</a></li></ul></div></div>    
</body>
</html>