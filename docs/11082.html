<html>
<head>
<title>[OS] How mutex is implemented — concurrency part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[OS]互斥是如何实现的——并发性第 4 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/os-how-mutex-is-implemented-concurrency-part-4-addd9f8eabbe?source=collection_archive---------8-----------------------#2022-12-17">https://blog.devgenius.io/os-how-mutex-is-implemented-concurrency-part-4-addd9f8eabbe?source=collection_archive---------8-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/f493caf8d466d9799da6b9e1496ee913.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*CKiEtaB9ZN-E_eTB.jpg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">互斥是什么？</figcaption></figure><p id="2438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们讨论了什么是互斥体，以及我们应该如何使用它。今天，我们要讨论互斥体是如何实现的。这看起来很神奇，它只是提供了一个“原子”锁定和解锁…对不对？</p><h2 id="177c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">定时器中断</h2><p id="cd5f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">上次我们简要地讨论了中断，但现在让我们深入探讨一下。定时器中断是操作系统用来切换到另一个线程的机制。如果在运行线程“A”时从硬件触发了中断，则 CPU 调用相应的“中断处理程序”，该程序保存线程 A 的进程并切换到下一个线程。操作系统有权启用或禁用中断。但是，禁用中断时，我们应该非常小心。为什么？定时器中断是让所有线程都有机会运行的好方法。如果我们没有“中断”会发生什么？CPU 很可能会卡在一个线程上，直到用户的代码主动放弃 CPU。</p><h2 id="f8fe" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">如果一个线程永远在 CPU 上运行…</h2><p id="c31f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这是一个巨大的问题！假设用户正在运行一个计算圆周率最后一位数的线程。如果这个线程占用了 CPU，还不放弃 CPU，那么你的电脑就永远做不了别的事情了。因此，就暂停问题和资源分配而言，我们总是必须确保在运行用户程序时启用“中断”。</p><h2 id="7283" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">线程的同步</strong></h2><p id="ecbf" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">如果一个中断一直被启用，那么我们应该如何在线程之间强制排序呢？我们不知道中断是何时触发的，这将打乱我们试图强制执行的任何线程序列。</p><p id="97d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们通过简单地使用 while 循环来实现一个互斥体。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="2951" class="ma ku in lw b be mb mc l md me">class Mutex{<br/>  ...<br/>  bool locked;<br/>  void lock(){<br/>    while(locked){<br/>      // wait until lock is free... <br/>    }<br/>    // Line A<br/>    locked = true;<br/>  } <br/>  void unlock(){<br/>    locked = false; <br/>  }<br/>  ...<br/>};</span></pre><p id="420c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设 locked == false，线程 A 调用 lock()，中断在行 A 处被激发，然后，线程 B 也调用 lock()，检查 locked 变量，因为它是 false，所以它设置 locked = true。然后，中断再次被触发，并返回到线程 A。由于我们在 A 行被阻塞，它从 A 行恢复，并设置 locked = true。这是一个问题。由于线程 B 持有锁，线程 A 应该等待。现在，我们有两个线程持有一个锁！</p><p id="6595" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，另一个问题是 while 循环的繁忙等待。正如我们上次讨论线程的生命周期一样，当线程等待锁被释放时，我们应该将它放在等待队列中，以避免繁忙的等待。</p><h2 id="3a87" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">中断启用/禁用和等待队列</h2><p id="5c65" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了控制这一点，我们在线程库中使用中断启用和禁用。线程库被认为是一个 OS 代码，所以它有使用中断禁用和启用的特权。现在，我们可以使用这个很酷的工具来实现互斥。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="f1b6" class="ma ku in lw b be mb mc l md me">class Mutex{<br/>...<br/>  void lock(){<br/>    interrupt_disable();<br/>    if(locked){<br/>      // put current thread to wait queue. <br/>    }else{<br/>      locked = true;<br/>    }<br/>    interrupt_enable();<br/>  }<br/>  void unlock(){<br/>    interrupt_disable();<br/>    if(/* the owner of the lock is current thread*/){<br/>      locked = free;<br/>    }<br/>    // pull some threads from wait queue and put it into ready queue<br/>    // so that that thread which was waiting for this mutex can start working<br/>    interrupt_enable();<br/>  }<br/>}</span></pre><p id="26f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 lock()中，我们应该首先禁用中断，这样任何线程都不能修改“锁定”状态。如果互斥体已经被锁定，我们应该将当前线程放入等待队列，如果锁是空闲的，我们将 locked 设置为 true，启用中断并返回。这有点类似于使用锁定和解锁来保护用户代码中的共享状态。我们可以把中断看作是阻止共享状态“锁定”的低级机制当我们解锁()它时，我们应该根据调度器的优先级从等待队列中取出一些东西，并将该线程放入就绪队列，以便等待互斥体的线程可以获得锁并执行工作。</p><h2 id="bd18" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">不变量</strong></h2><p id="55a7" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们应该小心的一件事是，我们应该在返回用户代码之前启用中断。一个基本原则是“我们不能相信用户的代码。”正如我上面提到的，用户的线程可能会计算圆周率的最后一位数，这是不可能的。<strong class="jx io">因此，我们应该确保在返回之前启用中断。</strong>这是一个<strong class="jx io">不变量</strong>我们应该继续写线程库。当我们实际切换线程时，情况变得复杂，因为我们不能在切换到另一个线程之前启用中断，因为我们应该确保我们存储了正确的线程 TCB。然而，如果我们在切换后启用中断，这就变得很奇怪，因为我们不知道这个线程什么时候会再次恢复，我们也不知道我们会在刚刚切换到的线程中做什么。答案是，我们只需在切换到另一个线程后启用中断。简而言之，所有线程总是从切换部分恢复，所以只要我们确保在切换后启用中断，我们就可以推断我们的不变量是全局保持的。这被称为<strong class="jx io">开关不变</strong>。我会写一个关于这个转换过程的单独的帖子，因为它相当复杂。</p><p id="b733" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，我们可以应用上次学习的 RAII 模式来保持这种不变量不受早期返回和错误的影响。</p><h2 id="d839" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">多核？</h2><p id="f173" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">可悲的是，中断是一个<strong class="jx io">每核心操作</strong>。它只能强制单个内核不要切换到另一个线程。因此，如果我们有多个内核，那么另一个内核可能会运行另一个触及互斥体的线程，我们为强制执行一个序列所做的所有努力都将付诸东流。</p><h2 id="d5e7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">我们如何防止另一个<strong class="ak">内核</strong>访问我们的互斥体？</h2><p id="1403" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们应该使用原子的读-修改-写。存储值(将值写入内存)是原子性的。利用这一点，我们可以实现一个守卫。</p><p id="3007" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有一个像这样的交换函数。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="c28b" class="ma ku in lw b be mb mc l md me">int exchange(int *guard, int value){<br/>  int result = *guard; // read the current value of that memory address<br/>  *guard = value; // store the value to that memory address<br/>  return result; // return the old value<br/>}</span></pre><p id="1069" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只需获取守卫的旧值，并为守卫分配一个新值。现在，当我们调用 lock()时，我们可以做的是，</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="329d" class="ma ku in lw b be mb mc l md me">void lock(){<br/>  interrupt_disable();<br/>  while(exchange(&amp;guard, 1)) {<br/>    // wait until guard gives 0.<br/>  }<br/>  ...<br/>  locked = true;<br/>  guard = 0;<br/>  ... <br/>}</span></pre><p id="9576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不断调用 exchange 来获取警卫的旧值。如果 guard“was”1，这意味着另一个内核正在处理它。如果 guard“是”0，那么我们将它设置为 1，以防止另一个内核处理同一个互斥体。最后，在我们完成对它的处理后，我们将它设置为 0。</p><p id="5e6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能会有一个关于我们在哪里忙着等待的问题。防止其他内核访问互斥体是不可避免的。</p><p id="6ebb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现一个线程库要比这复杂得多，但是我们至少了解了它是如何工作的基本结构！下一次，我们将看看线程库的另一个功能，即 CV(条件变量)。</p></div></div>    
</body>
</html>