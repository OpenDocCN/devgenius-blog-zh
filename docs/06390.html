<html>
<head>
<title>Getting started with Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-microservices-architecture-203172390928?source=collection_archive---------8-----------------------#2022-01-04">https://blog.devgenius.io/getting-started-with-microservices-architecture-203172390928?source=collection_archive---------8-----------------------#2022-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3c3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">微服务实现和微服务测试的基础</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d4b16413970dffbb55d78a2767ba26c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvPlEuyPwIux9_WX-eGf9Q.png"/></div></div></figure><p id="3edf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将讨论微服务架构和微服务架构的测试策略。微服务架构是一种架构风格，它将应用程序构建为围绕业务领域建模的小型自治服务的集合。下面你可以看到一个微服务架构设计的例子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/8a96adbb7855ac5abdafa0093454d9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Pbn9Y4uDvRZzzUv7t3UKA.png"/></div></div></figure><h2 id="1b52" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务设计原则</h2><p id="3ac8" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">在设计微服务时，没有一套预定义的标准规则可以遵循。然而，微服务被设计成小型的、无状态的、独立的和全栈的应用程序，以便它们可以被单独实现和运行。</p><ol class=""><li id="4858" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">高内聚低耦合</li><li id="2a01" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">独立/自主</li><li id="6898" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">故障设计</li><li id="55c5" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">可部署性</li></ol><h2 id="3700" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务的核心概念</h2><ol class=""><li id="f80a" class="mj mk in kq b kr me ku mf kx mx lb my lf mz lj mo mp mq mr bi translated">服务</li><li id="ee58" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">通信</li><li id="6ef7" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">分配</li><li id="f186" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">数据库和交易</li><li id="52d0" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">API 层</li></ol><h2 id="8518" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务应用启动</h2><p id="2bc3" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">让我们创建一个基本的微服务来了解一下微服务架构。在这里，我启动一个 java spring boot 应用程序来阐明微服务。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/f2a298f7e1dec70b867d45af73dc72e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqAKqGb5WjHtt_tftNgiKw.png"/></div></div></figure><p id="d08d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">之后，将生成 Zip 文件。然后解压，用 IntelliJ idea 打开。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b5beace128b26913839e5f617dfdc8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*gznS6hf9fQG4cLtg973cwA.png"/></div></figure><p id="38ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">yml 文件是配置应用程序配置(如自定义端口和数据源等)的地方。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/10ce5b9c7ed2839ad6c863fda91d7661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*gM6Td-4GgMXQnNmszaWxyQ.png"/></div></figure><p id="3ceb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">文件夹结构:</p><ol class=""><li id="f41e" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">所有的。类文件驻留在— src -&gt; main -&gt; java 中</li><li id="0cbf" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">所有的。js 和。css 文件保存在—src -&gt; main -&gt; resources -&gt; static 中</li><li id="e200" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">所有的。html 文件位于—src-&gt; main-&gt; resource-&gt; templates 中</li></ol><h2 id="529b" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务之间的相互通信</h2><p id="fe5a" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">在整体方法中，所有进程都在同一个应用程序中。因此，组件通过函数或方法调用相互调用。但是当使用微服务方法时，几个小的应用程序一起工作形成最终的应用程序。那么微服务之间就需要互通。</p><p id="a23e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相互通信的类型:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/00b1a07d5342905be466b3469b2de0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXYlGhRViM8xvue5RhO49w.png"/></div></div></figure><p id="8925" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同步——客户端发送请求并等待服务的响应。</p><p id="b937" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">异步——客户端代码或消息发送方通常不等待响应。</p><p id="6154" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">互通实现方法:</p><ol class=""><li id="6647" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">RestTemplate 是 Spring 框架中的核心类，用于在客户端执行同步 HTTP 请求。</li><li id="cbdd" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">是一个声明性的 web 服务客户端。它使得编写 web 服务客户端更加容易。使用 Feign 创建一个接口并对其进行注释。</li><li id="255d" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">RabbitMQ-RabbitMQ 是一个消息队列实现，它在通信过程中的两个应用程序之间以低级 AMQP 协议执行。</li><li id="4884" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">Apache Kafka-Apache Kafka 是一个社区分布式事件流平台，每天能够处理数万亿个事件。</li></ol><p id="4de8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">编码示例:</p><p id="b9c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我发起了两个微服务；用户服务和订单服务。在下面的示例中，用户和订单服务分别管理与用户和订单相关的所有数据。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f4e04607743b75e226a7f43f293d9b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Vns9hi5Rg7K5McFMgpSJSQ.png"/></div></figure><p id="ba67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后使用 postman 你可以测试 API 调用。</p><h2 id="e5e9" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务部署流程</h2><p id="62d5" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">微服务可以手动或自动部署。但是，手动部署过程在生产环境中并不实用。因此，自动化过程可通过 CI/CD 管道与远程源代码管理系统一起应用。</p><p id="d55c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为微服务是复杂的，所以应该有一种机制来识别微服务在运行时的潜在问题。启用日志记录是解决这一问题的有效方法之一。</p><p id="f178" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="b9ac" class="ll lm in ng b gy nk nl l nm nn">public boolean saveUser(UserDTO user) {<br/>    try {<br/>        if (Validations.<em class="no">validateUser</em>(user)) {<br/>            UserEntity userEntity = new UserEntity(user.getName(), user.getAge());<br/>            repository.save(userEntity);<br/>            return true;<br/>        } else {<br/>            LOGGER.info("--ERROR in Validation ---");<br/>            return false;<br/>        }<br/>    } catch (Exception e) {<br/>        LOGGER.info("--ERROR in User Save--" + e.getMessage());<br/>        return false;<br/>    }<br/>}</span></pre><p id="1f9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">维护多个 application.yml 文件有助于为每个部署环境指定自定义配置。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/e58b2b6b82d05039fd73947b50d94bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7R7nRU2FQ5lOJVNUe9fYw.png"/></div></div></figure><h2 id="4796" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">创建本地部署的生成</h2><p id="cdf8" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">有一个 maven 命令可以在运行或不运行测试用例的情况下构建应用程序。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="32c6" class="ll lm in ng b gy nk nl l nm nn">mvn clean install</span><span id="dcc5" class="ll lm in ng b gy nq nl l nm nn">mvn clean install -Dmaven.test.skip=true</span></pre><p id="1a7e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后可以在目标文件夹中找到 output.jar 文件。然后，您可以使用以下命令在本地运行它。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="44be" class="ll lm in ng b gy nk nl l nm nn">java -jar {jar_file_name}.jar</span></pre><h2 id="429c" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">微服务的测试策略</h2><p id="859f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">通常，微服务会显示由部分或全部显示图层组成的类似内部结构。</p><p id="e87b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所采用的任何测试策略都应该旨在覆盖服务的每一层和层间，同时保持轻量级。</p><h2 id="26d7" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">单元测试</h2><p id="747f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">单元测试是一种测试类型，其中对软件的单个单元或功能进行测试。它的主要目的是测试每个单元或功能。我们可以使用单元测试来测试微服务的以下部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/7d5dfb44ba553c38e353e262971f0523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*74-VxZzJ6MeAkoKR2W_zog.png"/></div></figure><ol class=""><li id="9af5" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">资源和服务层:<br/>资源和服务层分为两部分，协作者和网关。对于驻留在另一个服务器上的网关(几乎总是这样)，使用测试替身作为模拟对象应该更好。你可以为合作者做单独的测试，这样会减慢过程。</li><li id="019f" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">域:<br/>域逻辑包含计算和状态转换，所以对象是基于状态的，因此不能被隔离，但是最好的选择是进行社交单元测试。</li><li id="717d" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">存储库:<br/>存储库代表查询的执行，并且像执行一样与数据库相关。在这种情况下，如果集成测试不值得执行，那么使用单独测试将会有效。</li><li id="fbc6" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">网关:<br/>网关碰巧与外部服务连接，建议进行单独的单元测试，以避免影响网络。</li></ol><p id="7dfc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是单元测试本身并不能保证系统的行为。</p><h2 id="a593" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">集成测试</h2><p id="210b" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">通过单元和集成测试，我们可以对组成微服务的各个模块中包含的逻辑的正确性有信心。下图描述了如何对微服务进行集成测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3b4d245e4c29fc476cc658e778b6cf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*iZSR-SRJqnpdwr7SosWzhg.png"/></div></figure><ol class=""><li id="33bc" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">网关集成测试:这种类型的测试允许以尽可能精细的测试粒度清除任何协议级错误，比如丢失 HTTP 头、不正确的 SSL 处理或请求/响应体不匹配。</li><li id="544d" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">持久性集成测试:这保证了代码假设的模式与数据存储中可用的模式相匹配。对象关系映射(ORM)是一种编程技术，其中元数据描述符用于将对象代码连接到关系数据库。在微服务中，我们使用 ORM 来映射对象代码和关系数据库。由于大多数数据存储存在于一个网络分区中，因此它们也会受到超时和网络故障的影响。集成测试应该尝试验证集成模块能够处理这些故障。</li></ol><h2 id="86c5" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">端到端测试</h2><p id="8ddf" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">因为目标是测试整个系统的行为，所以端到端测试以尽可能粗的粒度进行交互。我们可以使用 selenium web 驱动程序或任何其他 UI 自动化工具在微服务中进行端到端测试。使用端到端测试，我们可以一次测试整个微服务。但是片状剥落、过长的测试运行时间和维护测试套件的额外成本是端到端测试的缺点。</p><p id="d8bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是当你开始给微服务架构写自动化测试的时候。如果能坚持测试金字塔就更好了。除了这三种主要测试策略，我们还可以使用组件测试和契约测试来进行微服务测试。</p><p id="8d42" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下图简要描述了微服务测试流程。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/63461c7999a9bb8d1419eb77d306943f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93WekUFysgNvY0iRv44kKw.png"/></div></div></figure><p id="7fdd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更多详情:<a class="ae nu" href="https://martinfowler.com/articles/microservice-testing/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/microservice-testing/</a></p><p id="0b0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">特别感谢:Iroshan Abeyrathne 先生</p></div></div>    
</body>
</html>