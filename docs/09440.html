<html>
<head>
<title>React Lazy Load Images using Intersection Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器对延迟加载图像做出反应</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-lazy-load-images-using-intersection-observer-60b6cc8790ff?source=collection_archive---------1-----------------------#2022-08-21">https://blog.devgenius.io/react-lazy-load-images-using-intersection-observer-60b6cc8790ff?source=collection_archive---------1-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/bb853dbdd364cc62c094f7b88f0a1257.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*Ahdc9ddvNJrSIk1UU2Kv6w.png"/></div></figure><h1 id="00f8" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">举例。</h1><ol class=""><li id="88a8" class="kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">你有 4 个大的高清图像。</li><li id="f94c" class="kp kq in kr b ks lh ku li kw lj ky lk la ll lc ld le lf lg bi translated">你想优化它们。</li></ol><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lm"><img src="../Images/19310f9c4a5f544ca771d814bf73ffee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsLaDh3NcBNFg_YxhRC0bg.png"/></div></div></figure><h2 id="066f" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">阅读前:</h2><ol class=""><li id="cc82" class="kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">我使用 Next.js 和 React</li><li id="06fd" class="kp kq in kr b ks lh ku li kw lj ky lk la ll lc ld le lf lg bi translated">默认情况下，分数比你看到的要低。<br/> <strong class="kr io">为什么？<br/> </strong>因为 Next.js 默认优化图片。</li></ol><h1 id="201f" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">1.制作基本布局</h1><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mh"><img src="../Images/9f0d86765b10c5ffa555710c8aa85711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcRgaYg-Bzl9eotjkpLhFQ.png"/></div></div></figure><blockquote class="mi mj mk"><p id="4c1a" class="ml mm mn kr b ks mo mp mq ku mr ms mt mu mv mw mx my mz na nb nc nd ne nf lc ig bi translated">只是简单的布局，没有什么不同，但 Chrome 给了我很差的评级。</p></blockquote><h2 id="954f" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">我们如何更新这个？</h2><p id="7328" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">使用<strong class="kr io"> WEBP/AVIF </strong>代替<strong class="kr io"> JPEG/JPG </strong>或者使用<strong class="kr io"> <em class="mn">次世代格式</em> </strong>。那就让我们转变吧，但是你必须明白:</p><ol class=""><li id="b593" class="kp kq in kr b ks mo ku mr kw nj ky nk la nl lc ld le lf lg bi translated">压缩的<strong class="kr io"> WEBP </strong>算法比<strong class="kr io"> JPEG/JPG </strong>更好。</li><li id="4294" class="kp kq in kr b ks lh ku li kw lj ky lk la ll lc ld le lf lg bi translated"><strong class="kr io"> AVIF </strong>不是进步图像不是那个<strong class="kr io"> JPEG/JPG </strong></li></ol><h2 id="17f2" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">总之。</h2><p id="7606" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">让我们开始吧。</p><h1 id="2af5" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">2.准备 JPEG 到 WEBP</h1><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/54df0e1f80baec9b4aaf9260586169c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*8gw1MORK3EaeEf1pF8RlpQ.png"/></div></figure><p id="8f16" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">正如你所看到的，我们更新了最大内容绘制时间，但这还不是全部。</p><h1 id="1975" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">3.关于图像大小</h1><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/64f2e454bf2c3f50372bde1478ef54a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*-_ffNpi13BiPzRQ_4Uhq-A.png"/></div></figure><blockquote class="mi mj mk"><p id="8d14" class="ml mm mn kr b ks mo mp mq ku mr ms mt mu mv mw mx my mz na nb nc nd ne nf lc ig bi translated">我们应该用图片标签来拯救 7.0784 KiB 吗？ <strong class="kr io"> <em class="in">是的</em> </strong> <em class="in">。</em></p></blockquote><h2 id="fc27" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">为什么？</h2><p id="db6a" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">该算法试图将原始图像转换为 CSS 图像。</p><p id="3ca8" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated"><strong class="kr io">例如</strong>:</p><p id="a78a" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">你的图像是<strong class="kr io"> 4000px/6000px。你的 CSS 样式是 452px/435px。</strong>浏览器获得完整图像。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi no"><img src="../Images/073b951905dbd35af95d9c38dd06df5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohK8N1D_5j7skRknvNbmEQ.png"/></div></div></figure><p id="5291" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">原图大小为<strong class="kr io"> 3.45 MB </strong>。浏览器获取<strong class="kr io"> 3.6 MB。</strong></p><p id="be9e" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated"><strong class="kr io">还有我们应该更新什么？</strong>浏览器建议将原始图像大小更改为 CSS 样式，<strong class="kr io">但是例如</strong>我们不能更改移动设备的徽标大小，因为我们必须在一个桌面上使用它<strong class="kr io"> <em class="mn">并且一个图像的大小是不好的</em> </strong>。</p><h2 id="fafa" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">我们如何更新这个？</h2><p id="6976" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">使用响应图像。对于这一个，我们必须使用一个<strong class="kr io">图片</strong>标签。</p><h1 id="d1c3" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">4.制作响应图像并添加图片标签</h1><p id="7ac7" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">响应图像是一种用于为当前帧/设备加载正确图像的技术。现在我要添加<strong class="kr io"> <em class="mn">图片/img/来源</em> </strong>标签。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi np"><img src="../Images/63c60895d0cbd69908aa3c87f63bbea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rnj_W28gTPVaZ9FL1l7xAQ.png"/></div></div></figure><p id="4664" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">正如你所看到的，我改变了每张图片的宽度和高度。我知道我降低了图像的质量，但无论如何，在生产中- <strong class="kr io">你必须问设计师的图像。</strong></p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/32f55f2239efc64ad2c8703e92c7812f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*WIsxvDTk7SgqMpotsLDa3g.png"/></div></figure><h1 id="133a" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">5.为图像添加延迟加载</h1><p id="667e" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">在我们添加<em class="mn">惰性加载/交集观察器</em>之前——我们必须明白，使用惰性加载不会减少<strong class="kr io">最大内容绘制</strong>时间，因为<strong class="kr io"> LCP </strong>是关于应用程序在性能通过加载阶段运行时的样子。</p><p id="cf6d" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">首先，我想展示我正在谈论的东西:</p><blockquote class="mi mj mk"><p id="73fe" class="ml mm mn kr b ks mo mp mq ku mr ms mt mu mv mw mx my mz na nb nc nd ne nf lc ig bi translated">我为这个例子下载了<a class="ae nr" href="https://www.npmjs.com/package/react-lazy-load-image-component" rel="noopener ugc nofollow" target="_blank"><strong class="kr io">react-lazy-load-image-component NPM</strong></a>。</p></blockquote><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ed22202e4b292a527a7ba5264488983a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*NNq02a53MiDRy72rQ-4CMw.png"/></div></figure><p id="84ae" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">我们在项目中添加了一个 npm，但是我们不能说我们<strong class="kr io">真的更新了</strong>我们的应用程序。<em class="mn">然而</em>，当我们有超过 3 张图片的时候<strong class="kr io">我们就能看出区别，例如</strong>一百张，一千张在我们的应用中。</p><blockquote class="mi mj mk"><p id="43a6" class="ml mm mn kr b ks mo mp mq ku mr ms mt mu mv mw mx my mz na nb nc nd ne nf lc ig bi translated">L <!-- -->让我们试着只为图像延迟加载重写这个 npm。</p></blockquote><h1 id="d06c" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">6.交叉观察者</h1><p id="dfe1" class="pw-post-body-paragraph ml mm in kr b ks kt mp mq ku kv ms mt kw ng mw mx ky nh na nb la ni ne nf lc ig bi translated">我不会把一个<em class="mn"> IntersectionObserver </em>作为对象来讨论，因为已经存在这个对象的 API <a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nt"><img src="../Images/c7317dc870683333057b70fa703c75e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YC4wMGzd2bv4_vIHqHFTdQ.png"/></div></div></figure><p id="7b41" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">来说说我写的:</p><ol class=""><li id="a1bb" class="kp kq in kr b ks mo ku mr kw nj ky nk la nl lc ld le lf lg bi translated"><strong class="kr io">当前图像</strong> <em class="mn">状态</em>是当前图像的 id。</li><li id="39c2" class="kp kq in kr b ks lh ku li kw lj ky lk la ll lc ld le lf lg bi translated"><strong class="kr io">all registerimages</strong><em class="mn">state</em>是我们要与<em class="mn"> IntersectionObserver 绑定的所有项目的数组，</em>换句话说，就是当这个项目出现在用户的视口中时，我们需要隐藏和显示的所有项目。<br/> <strong class="kr io">我为什么要用 any？<br/> </strong> <em class="mn">因为在这种情况下，我们确实不知道当前内容项是什么类型。</em></li><li id="7572" class="kp kq in kr b ks lh ku li kw lj ky lk la ll lc ld le lf lg bi translated">当我们更新<strong class="kr io"><em class="mn">setCurrentImage</em></strong>时，我们使用三元运算:<br/><strong class="kr io"><em class="mn">a)</em></strong><strong class="kr io">is interest</strong>布尔标志，用于定义是否是用户视口中的项目。<br/> <strong class="kr io"> <em class="mn"> b) </em> </strong>如果<strong class="kr io">感兴趣</strong>为<strong class="kr io"> </strong>真-我们使用从<em class="mn">数据-订单</em>属性获得的当前<strong class="kr io"> id </strong>更新一个<strong class="kr io">当前图像</strong>。<br/> <strong class="kr io"> <em class="mn"> c) </em> </strong>如果<strong class="kr io">is interest</strong>为 false——这意味着我们从<strong class="kr io">可见项</strong>和<a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry" rel="noopener ugc nofollow" target="_blank"> <em class="mn">相交项</em> </a>看不到任何要显示的项，当这种情况发生时——我们定义下一个要显示的项。<br/> <strong class="kr io"> <em class="mn">工作原理如下:</em> </strong> <br/>如果用户向上滚动- <strong class="kr io"> y </strong>为正数，这意味着用户希望看到以前的项目并显示以前的项目:</li></ol><pre class="ln lo lp lq gt nu nv nw nx aw ny bi"><span id="90f3" class="lv js in nv b gy nz oa l ob oc">const <strong class="nv io">PreviosSlide </strong>= currentSlide — 1;<br/>const <strong class="nv io">NextSlide </strong>= currentSlide + 1;</span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi od"><img src="../Images/9e24625301cedbb13c31ca30a4da2be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*f_FfrLNM2rmytVY0YyXeFg.png"/></div></figure><p id="482e" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">在这之后，我们创建相同的行为，就像拥有 npm 库一样。</p><blockquote class="mi mj mk"><p id="dc9f" class="ml mm mn kr b ks mo mp mq ku mr ms mt mu mv mw mx my mz na nb nc nd ne nf lc ig bi translated">不更新 ut LCP 和 TBT。</p></blockquote><h1 id="fad1" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">陷阱。</h1><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oe"><img src="../Images/2cbd1c91e0dcb7095c15847a6f06707e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oCQ81L7_-XDYkXpQsPiWQ.png"/></div></div></figure><p id="228f" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">如果我们将测试我们的应用程序的性能，我们将得到一个警告:<strong class="kr io"> <em class="mn">长任务占用了… ms. </em> </strong></p><h2 id="6b3a" class="lv js in bd jt lw lx dn jx ly lz dp kb kw ma mb kf ky mc md kj la me mf kn mg bi translated">让我们深入这个案例，定义发生了什么。</h2><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/18ed546ab09acf30914944cab3e8766a.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*CF0jmjt6YWYR5rm6bxdYpg.png"/></div></figure><p id="6c0d" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated"><strong class="kr io">什么是长任务？<em class="mn"> </em> </strong> <br/> <em class="mn">长任务</em>——是耗时大于 50ms 的任务。在这种情况下，我们为此采用<strong class="kr io"> 394ms </strong>。</p><p id="671e" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">如何才能更新<strong class="kr io">脚本</strong>时间？</p><p id="01da" class="pw-post-body-paragraph ml mm in kr b ks mo mp mq ku mr ms mt kw mv mw mx ky mz na nb la nd ne nf lc ig bi translated">在前端- <strong class="kr io">没办法</strong>。加载脚本时间的最大文件是我们的 WEBP 图像，但我们不能编码图像或为此更改 webpack 配置，因为 Next.js 已经这样做了。只有一个解决方案来解决这个问题- <strong class="kr io">从后端获取图像。</strong></p></div></div>    
</body>
</html>