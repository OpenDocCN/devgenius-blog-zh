<html>
<head>
<title>Go sync 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去同步 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-sync-101-39777f75a434?source=collection_archive---------0-----------------------#2022-05-10">https://blog.devgenius.io/go-sync-101-39777f75a434?source=collection_archive---------0-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">遍历互斥和其他同步工具</h2></div><p id="d605" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Go 1.18 中，最吸引眼球的<code class="fe lb lc ld le b">generics</code>，被认为是 Go 问世以来最大的语法“进化”。但是，不应该忽视 API 的其他变化，例如<code class="fe lb lc ld le b">sync</code>包的<code class="fe lb lc ld le b">Mutex</code>和<code class="fe lb lc ld le b">RWMutex</code>API 中添加了<a class="ae lf" href="https://pkg.go.dev/sync#Mutex.TryLock" rel="noopener ugc nofollow" target="_blank"> TryLock </a>。</p><p id="9ec7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在阅读<a class="ae lf" href="https://pkg.go.dev/sync" rel="noopener ugc nofollow" target="_blank">同步文档</a>时，我发现自己对它很陌生，甚至对<code class="fe lb lc ld le b">Mutex</code>或<code class="fe lb lc ld le b">WaitGroup</code>也是如此，这促使我仔细研究 Go sync，并回顾其不同类型的定义及其包含的功能。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/df7829228fbc4bba5ba8d251ebd9c713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSy8rVdwR6JoGZOV"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">来自 unsplash，<a class="ae lf" href="https://unsplash.com/photos/tn85IH-sbhw" rel="noopener ugc nofollow" target="_blank"> @picsbyjameslee </a></figcaption></figure><h1 id="97c4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">通常</h1><p id="37fb" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">sync 包是 Golang 并发实现不可或缺的一部分，与其他语言相比，Go 使用简单的锁。更好的解释:Java 同步可以通过<code class="fe lb lc ld le b">synchronized</code>关键字、<code class="fe lb lc ld le b">ReentrantLock</code>和<code class="fe lb lc ld le b">volatile</code>来实现；而 Go 摆脱了复杂性，只支持两种类型，<code class="fe lb lc ld le b">Mutex</code>和<code class="fe lb lc ld le b">RWMutex</code>。在 1.18 之前，其实只有一套方法，<code class="fe lb lc ld le b">Lock</code>和<code class="fe lb lc ld le b">UnLock</code>，如果你把<code class="fe lb lc ld le b">RLock</code>和<code class="fe lb lc ld le b">RUnlock</code>看成核心相同，只是形式不同的话。</p><p id="f23e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以 sync 包里总共只有 7 种。除了<code class="fe lb lc ld le b">Locker</code>接口和<code class="fe lb lc ld le b">Mutex</code>外，其余<code class="fe lb lc ld le b">RWMutex</code>、<code class="fe lb lc ld le b">Cond</code>、<code class="fe lb lc ld le b">WaitGroup</code>、<code class="fe lb lc ld le b">Pool</code>和<code class="fe lb lc ld le b">Once</code>都是构建在<code class="fe lb lc ld le b">Mutex</code>之上的 sync 类型，以支持特殊场景。</p><h1 id="b897" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">互斥（体）…</h1><p id="59c5" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">毫无疑问，sync 包的核心是<a class="ae lf" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/sync/mutex.go#L25" rel="noopener ugc nofollow" target="_blank">互斥</a>，一个排他锁的实现，几乎所有的 sync 逻辑都是基于它构建的。它有 3 个来自 API 端的函数。</p><ul class=""><li id="3bc8" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/mutex.go#L74" rel="noopener ugc nofollow" target="_blank">锁</a>。获取锁，或者在锁被占用时排队等待，并且线程变成阻塞状态。现在，我们让处理器逻辑来决定线程是否以及何时可以获得锁。而互斥体源中的<em class="nc">正常</em>和<em class="nc">饥饿</em>两种模式，在一定程度上可以决定队列中线程的优先级，涉及到将哪个线程放入队列，是否允许新加入的线程自旋等。简而言之，<strong class="kh ir">互斥对于各种“竞争者”是公平的。</strong></li><li id="a9cd" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/mutex.go#L205" rel="noopener ugc nofollow" target="_blank">解锁</a>。根据当前锁的不同情况释放锁，并尽可能“公平”地转移锁的所有权，像锁一样提供两种路径，快速和慢速。</li><li id="0a25" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/mutex.go" rel="noopener ugc nofollow" target="_blank">试锁</a>。以轻量级的方式获得锁，避免阻塞线程。这种方法在其他语言中也很常见，比如 Java 中的<code class="fe lb lc ld le b">ReentrantLock</code>，Python 中的<code class="fe lb lc ld le b">Lock.acquire(False)</code>。但在 Go 中，经过 2013 年以来 9 年的鏖战却依然在 API 上打上了提醒的标记，终于被带入现实(<a class="ae lf" href="https://github.com/golang/go/issues/45435" rel="noopener ugc nofollow" target="_blank">提议</a>)。</li></ul><blockquote class="ni nj nk"><p id="344d" class="kf kg nc kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">请注意，虽然 TryLock 的正确用法确实存在，但这种用法很少见，而且 TryLock 的使用通常是在互斥体的特定使用中出现更深层次问题的迹象。</p></blockquote><p id="711a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我非常同意提案中提出的一些案例。TryLock 很有用！想象一个需要同步更新的缓存:你希望后续更新的请求可以尽快退出，以缩短“愚蠢”的等待，因为这个缓存可以通过接受过时的数据来加快进程。这是一个非常常见的权衡。</p><pre class="lh li lj lk gt no le np nq aw nr bi"><span id="3beb" class="ns lx iq le b gy nt nu l nv nw">lock sync.Mutex</span><span id="c373" class="ns lx iq le b gy nx nu l nv nw">func(c *cache) Get(key string) interface{}{<br/>  if ( needUpdate &amp;&amp; lock.TryLock) {<br/>    c.update() // update takes 5 seconds<br/>    lock.Unlock()<br/>}<br/>  return c.map.Get(key)<br/>}</span></pre><p id="53e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，<code class="fe lb lc ld le b">channel</code>也可以达到同样的效果，或者在 Golang 设计师看来更“Go”。然而，没有人能否认 TryLock 在这种情况下更简单、更优雅。</p><p id="d694" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住这一点，你会很容易陷入 bug。</p><blockquote class="ni nj nk"><p id="dde2" class="kf kg nc kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">互斥体在第一次使用后不得复制。</p></blockquote><p id="7c73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要试图复制互斥变量，甚至是包装互斥变量的结构实例，这将导致错误<code class="fe lb lc ld le b"><em class="nc">written by concurrent Map</em></code>。参考此<a class="ae lf" href="https://eli.thegreenplace.net/2018/beware-of-copying-mutexes-in-go/" rel="noopener ugc nofollow" target="_blank">示例</a>了解更多信息。</p><h1 id="8ccf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">RWMutex</h1><p id="49b7" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">RWMutex 基于 Mutex，适用于读多写少的同步场景。本质上，它通过给互斥体增加一个额外的<code class="fe lb lc ld le b">semaphore</code>来配备更多的读锁。</p><ul class=""><li id="7449" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L133" rel="noopener ugc nofollow" target="_blank">锁</a>，一次阻塞操作，读写都需要等待一次被占用。</li><li id="8fc0" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L190" rel="noopener ugc nofollow" target="_blank">解锁</a>，解锁阅读器，解锁内部互斥锁。</li><li id="576b" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L56" rel="noopener ugc nofollow" target="_blank"> RLock </a>，get <code class="fe lb lc ld le b">readerSem</code>，不影响任何并发的<code class="fe lb lc ld le b">read</code>操作，同时阻塞<code class="fe lb lc ld le b">write</code>操作(Lock)直到<code class="fe lb lc ld le b">read</code>结束。<code class="fe lb lc ld le b">RWMutex</code>支持<code class="fe lb lc ld le b">1&lt;&lt;30</code> <code class="fe lb lc ld le b">read</code> goroutines 的同时访问，降低了等待读锁的可能性。</li><li id="197d" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L103" rel="noopener ugc nofollow" target="_blank"> RUnlock </a>，从<code class="fe lb lc ld le b">readerCount</code>中减去一。并且当它是最后一个读取器时，如果存在的话，解除阻塞<code class="fe lb lc ld le b">write</code> goroutine。</li><li id="6633" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L76" rel="noopener ugc nofollow" target="_blank">尝试锁定</a>，尝试获取<code class="fe lb lc ld le b">readerSem</code>。</li><li id="ad40" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/rwmutex.go#L158" rel="noopener ugc nofollow" target="_blank"> TryLock </a>，调用互斥体的<code class="fe lb lc ld le b">TryLock</code>。如果<code class="fe lb lc ld le b">readerCount</code>当前不为 0，则失败且<code class="fe lb lc ld le b">Unlock</code>；否则，锁定<code class="fe lb lc ld le b">readersem</code>和<code class="fe lb lc ld le b">writersem</code>。</li></ul><p id="dc39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">RWMutex</code>在 Go 中的应用甚至比<code class="fe lb lc ld le b">Mutex</code>更广泛，尤其是在实现与地图相关的简单缓存时，比如在 Kubernetes APIServer 代码中使用一个<code class="fe lb lc ld le b">RWMutex</code>来确保同步访问<a class="ae lf" href="https://github.com/kubernetes/apiserver/blob/92392ef22153d75b3645b0ae339f89c12767fb52/pkg/quota/v1/generic/registry.go#L27" rel="noopener ugc nofollow" target="_blank">注册表</a>中的一个<code class="fe lb lc ld le b">Evaluator</code>地图。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5c29b3f5e94b635fc22a768c4b82f2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*QCPsKH0bneSTBm7E"/></div></figure><p id="1190" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后像<code class="fe lb lc ld le b">Add</code>和<code class="fe lb lc ld le b">Get</code>这样的操作分别调用相应的 Lock 和 RLock 方法。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nz"><img src="../Images/b175d4bdb9a624a0cf6fb76ce0e05f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ce-yBxrG7B4gwDz7"/></div></div></figure><p id="42e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和<code class="fe lb lc ld le b">Mutex</code>一样，<code class="fe lb lc ld le b">RWMutex</code>用完后不要复制。</p><p id="c1a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">警惕👇</p><p id="9484" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实践中找到最合适的<code class="fe lb lc ld le b">Mutex</code>。<code class="fe lb lc ld le b">RWMutex</code>增加了几种信号量同步的操作，提供了比互斥更多的功能。但是互斥锁在性能上胜出。更多详情见本<a class="ae lf" href="https://github.com/golang/go/issues/38813" rel="noopener ugc nofollow" target="_blank">发行单</a>。</p><h1 id="c569" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">锁柜</h1><p id="3084" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/mutex.go#L33" rel="noopener ugc nofollow" target="_blank"> Locker </a>接口在<code class="fe lb lc ld le b">mutex.go</code>中定义，其值由两个方法<code class="fe lb lc ld le b">Lock</code>和<code class="fe lb lc ld le b">Unlock</code>组成。同时，<code class="fe lb lc ld le b">RWMutex</code>实现了自己的<code class="fe lb lc ld le b">RLocker</code>。</p><p id="789f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个灵活的锁，这个接口可以作为一个字段封装到其他结构中，使得开发者可以在<code class="fe lb lc ld le b">Mutex</code>、<code class="fe lb lc ld le b">RWMutex</code>中传递它，甚至可以自定义它。比如在 Kubernetes 中，Locker 保证了<a class="ae lf" href="https://github.com/kubernetes/apiserver/blob/15bcfedb6be8749a8d1e9340af8d95705892e9b9/pkg/storage/cacher/watch_cache_interval.go#L97" rel="noopener ugc nofollow" target="_blank"> watchCacheInterval </a>的同步，而<code class="fe lb lc ld le b">watchCache’s</code> <a class="ae lf" href="https://github.com/kubernetes/apiserver/blob/09e974dbce4a2dbbac618210414fdf0d1054aab9/pkg/storage/cacher/watch_cache.go#L635" rel="noopener ugc nofollow" target="_blank"> RWMutex </a>实际上是传入的。</p><h1 id="1618" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Cond</h1><p id="d67d" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><code class="fe lb lc ld le b">Cond</code>是一个同步条件变量，通常与<code class="fe lb lc ld le b">Mutex</code>结合使用。它本质上是等待某个特定条件的线程的同步机制，内部包含一个<code class="fe lb lc ld le b">Locker</code>。</p><pre class="lh li lj lk gt no le np nq aw nr bi"><span id="d23a" class="ns lx iq le b gy nt nu l nv nw">cond := sync.NewCond(&amp;sync.Mutex{})</span></pre><ul class=""><li id="9b8e" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Cond.Wait" rel="noopener ugc nofollow" target="_blank">等待</a>，暂停当前 goroutine。</li><li id="4315" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Cond.Signal" rel="noopener ugc nofollow" target="_blank">信号</a>，唤醒正在等待的 goroutine。</li><li id="231d" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Cond.Broadcast" rel="noopener ugc nofollow" target="_blank">广播</a>，唤醒所有等待的 goroutines。</li></ul><p id="d48a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe lb lc ld le b">Cond</code>在围棋中很少使用，因为<code class="fe lb lc ld le b">channel</code>。<a class="ae lf" href="https://github.com/golang/build/blob/master/livelog/livelog.go" rel="noopener ugc nofollow" target="_blank">这里的</a>是我从这张<a class="ae lf" href="https://github.com/golang/go/issues/20491" rel="noopener ugc nofollow" target="_blank">发行票</a>中找到的一个例子，讨论为<code class="fe lb lc ld le b">Cond</code>增加文件和例子。读起来挺有意思的。</p><p id="2ee5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对 Java 的<code class="fe lb lc ld le b">wait</code>或者<code class="fe lb lc ld le b">notify</code>的理解可以帮助你更好的把握<code class="fe lb lc ld le b">Cond’s</code>本质。Golang 使用运行时<a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/cond.go#L27" rel="noopener ugc nofollow" target="_blank"> notifyList </a>实现等待队列。</p><h1 id="b657" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">等待组</h1><p id="0729" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#WaitGroup" rel="noopener ugc nofollow" target="_blank"> WaitGroup </a>，与<code class="fe lb lc ld le b">Cond</code>相反，在 Go 中非常流行，允许一个或多个 goroutines 被一组执行<code class="fe lb lc ld le b">groutinues</code>阻塞。</p><p id="5dfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的内部实现与互斥无关，而是由一些原子操作一个<a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/waitgroup.go#L29" rel="noopener ugc nofollow" target="_blank">计数器</a>和信号量。</p><ul class=""><li id="2093" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#WaitGroup.Add%5C" rel="noopener ugc nofollow" target="_blank">添加</a>，添加增量同步等待程序。</li><li id="0adc" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#WaitGroup.Done" rel="noopener ugc nofollow" target="_blank"> Done </a>，一个 goroutine 执行完毕后，计数器减 1，由<code class="fe lb lc ld le b">Add</code>方法实现。</li><li id="8e98" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#WaitGroup.Wait" rel="noopener ugc nofollow" target="_blank"> Wait </a>，内部通过无限 for 循环实现，当计数器返回 0 时退出，使被阻塞的 goroutine 继续执行。</li></ul><p id="45f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">常见的 WaitGroup 代码模板如下。</p><pre class="lh li lj lk gt no le np nq aw nr bi"><span id="f3fb" class="ns lx iq le b gy nt nu l nv nw">wg := &amp;sync.WaitGroup{}<br/>for i := 0; i &lt; n; i++ {  // n number of executing goroutines<br/>wg.Add(1)<br/>go func() {<br/>  // execute logics<br/>  wg.Done()  // declare finished<br/>}()<br/>}<br/>wg.Wait()  // main goroutine is blocked and wait for all goroutines to finish</span></pre><p id="70b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">waitGroup</code>用于 APIServer 中的<code class="fe lb lc ld le b">bufferedBackend</code>来并发处理<a class="ae lf" href="https://github.com/kubernetes/apiserver/blob/92392ef22153d75b3645b0ae339f89c12767fb52/plugin/pkg/audit/buffered/buffered.go#L234" rel="noopener ugc nofollow" target="_blank">事件。</a></p><p id="a930" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要提醒的是，如果你将太多的 go routine 加入 waitGroup，那么一小部分 go routine 不能正确调用<code class="fe lb lc ld le b">Done</code>将导致整个程序被阻塞。</p><h1 id="6861" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">一次</h1><p id="db5b" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Once" rel="noopener ugc nofollow" target="_blank">一次</a>顾名思义，是针对并发编程中某些事情只需要做一次的场景，比如初始化配置，或者读取输入信息。</p><p id="9e52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Once 只有一个<a class="ae lf" href="https://pkg.go.dev/sync#Once.Do" rel="noopener ugc nofollow" target="_blank"> Do </a>方法，并且只接受一个<code class="fe lb lc ld le b">func</code>参数。</p><p id="97d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行中，a <code class="fe lb lc ld le b">Mutex</code>和<code class="fe lb lc ld le b">uint</code>保证<a class="ae lf" href="https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/sync/once.go#L14" rel="noopener ugc nofollow" target="_blank">一次</a>只执行一次，执行后单元从 0 变为 1。</p><p id="ac29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go doc 最后提供了一个完美的例子。</p><pre class="lh li lj lk gt no le np nq aw nr bi"><span id="b808" class="ns lx iq le b gy nt nu l nv nw">func main() {<br/>  var once sync.Once<br/>  onceBody := func() {<br/>  // some heavy operations<br/>  }<br/>  done := make(chan bool)<br/>  for i := 0; i &lt; 10; i++ {<br/>    go func() {<br/>    once.Do(onceBody) // onceBody will only be called once.<br/>    done &lt;- true<br/>    }()<br/>  }</span><span id="bc76" class="ns lx iq le b gy nx nu l nv nw">  for i := 0; i &lt; 10; i++ {<br/>    &lt;-done<br/>  }<br/>}</span></pre><h1 id="069e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">泳池</h1><p id="392f" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Pool" rel="noopener ugc nofollow" target="_blank">池</a>，临时对象池，用于存放暂时不用但以后会用到的对象，可以被多个 goroutines 共享。</p><blockquote class="ni nj nk"><p id="b60a" class="kf kg nc kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">Pool 的目的是缓存已分配但未使用的项，以便以后重用，减轻垃圾收集器的压力。也就是说，它使得构建高效、线程安全的自由列表变得容易。但是，它并不适用于所有的自由列表。</p></blockquote><p id="b600" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某些情况下，它可以节省内存开销并减少 GC 压力。</p><ul class=""><li id="87db" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe lb lc ld le b">Get</code>，用钥匙从池中获取一个对象。</li><li id="dd12" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><code class="fe lb lc ld le b">Put</code>，将一个密钥和一个对象放入池中。</li></ul><p id="14c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很好的官方插图。</p><pre class="lh li lj lk gt no le np nq aw nr bi"><span id="eb37" class="ns lx iq le b gy nt nu l nv nw">var bufPool = sync.Pool{<br/>  New: func() any {<br/>  return new(bytes.Buffer)<br/>  },<br/>}</span><span id="d2e0" class="ns lx iq le b gy nx nu l nv nw">func Log(w io.Writer, key, val string) {<br/>  b := bufPool.Get().(*bytes.Buffer)<br/>  b.Reset()<br/>  // Replace this with time.Now() in a real logger.<br/>  b.WriteString(timeNow().UTC().Format(time.RFC3339))<br/>  b.WriteByte(' ')<br/>  b.WriteString(key)<br/>  b.WriteByte('=')<br/>  b.WriteString(val)<br/>  w.Write(b.Bytes())<br/>  bufPool.Put(b)<br/>}</span></pre><p id="9c16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大量调用<code class="fe lb lc ld le b">Log</code>方法的场景，我们从 Pool 中获取一个<code class="fe lb lc ld le b">Buffer</code>，然后将它放回以减少<code class="fe lb lc ld le b">Buffer</code>的创建，例如，Kubernetes 中令牌验证过程中的散列操作。将临时散列键存储在<a class="ae lf" href="https://github.com/kubernetes/apiserver/blob/706a6d89cf35950281e095bb1eeed5e3211d6272/pkg/authentication/token/cache/cached_token_authenticator.go#L222" rel="noopener ugc nofollow" target="_blank">池</a>中是一个好主意，可以节省散列操作的内存开销。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oa"><img src="../Images/d0d55b4cfb3cd8dfa9c61be90ae4c5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*47GvZPRpgpO8JVEl"/></div></div></figure><h1 id="9ad6" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">地图</h1><p id="da54" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map" rel="noopener ugc nofollow" target="_blank"> Map </a>是一个并发 Map 实现。两种最常见的适用场景是:</p><blockquote class="ni nj nk"><p id="49e4" class="kf kg nc kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">当给定关键字的条目只被写入一次，但被读取多次时，如在只增长的缓存中。</p><p id="b6e9" class="kf kg nc kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">当多个 goroutines 读取、写入和覆盖不相交的键集的条目时。</p></blockquote><p id="38c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包括以下 API。</p><ul class=""><li id="9b83" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map.Load" rel="noopener ugc nofollow" target="_blank">加载</a>，找到按键对应的值。</li><li id="aa50" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map.LoadAndDelete" rel="noopener ugc nofollow" target="_blank">加载并删除</a>，找到<code class="fe lb lc ld le b">Key</code>对应的值，删除<code class="fe lb lc ld le b">Key</code>。</li><li id="6d3f" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map.LoadOrStore" rel="noopener ugc nofollow" target="_blank"> LoadAndStore </a>，找到<code class="fe lb lc ld le b">Key</code>，如果有则返回<code class="fe lb lc ld le b">Value</code>；否则将<code class="fe lb lc ld le b">Key</code>和<code class="fe lb lc ld le b">default</code>包含在地图中。</li><li id="b456" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map.Range" rel="noopener ugc nofollow" target="_blank">范围</a>，遍历地图执行一次<code class="fe lb lc ld le b">func</code>。它是无序的，不阻塞映射，可以执行<code class="fe lb lc ld le b">Load</code>和<code class="fe lb lc ld le b">Store</code>这样的方法。</li><li id="ffec" class="mt mu iq kh b ki nd kl ne ko nf ks ng kw nh la my mz na nb bi translated"><a class="ae lf" href="https://pkg.go.dev/sync#Map.Store" rel="noopener ugc nofollow" target="_blank">存储</a>，在地图中保存<code class="fe lb lc ld le b">Key</code>和<code class="fe lb lc ld le b">Value</code>。</li></ul><p id="42cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，<code class="fe lb lc ld le b">sync.Map</code>比<code class="fe lb lc ld le b">map + RWMutex</code>实现的同步映射更高效，尤其是在读操作较多而并发写操作较少的情况下。然而，在有许多并发写入和锁竞争的情况下，这些开源缓存存储算法胜过了<code class="fe lb lc ld le b">sync.Map</code>。</p><p id="56e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最新的<code class="fe lb lc ld le b">sync.Map</code>可能会像这个<a class="ae lf" href="https://github.com/golang/go/issues/51972" rel="noopener ugc nofollow" target="_blank">提案</a>建议的那样改变，融入类似<code class="fe lb lc ld le b">Swap</code>的方法。</p><h1 id="a577" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结束了</h1><p id="185b" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">反映了 Go 的哲学，“要简单”，<code class="fe lb lc ld le b">sync</code>包使用有限的代码，提供基于互斥和原子操作的有用工具。</p><p id="2ef8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住这个概念，你就能更好地掌握 Go sync 包。无论你是在阅读源代码还是在一些同步场景下自己开发，都要简化代码或问题，从同步包中寻求工具最终解决。</p><p id="d1ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>