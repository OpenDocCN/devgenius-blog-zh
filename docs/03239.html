<html>
<head>
<title>Best of Modern JavaScript — New Object Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—新的对象方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-new-object-methods-1a427aa9b3aa?source=collection_archive---------7-----------------------#2020-10-15">https://blog.devgenius.io/best-of-modern-javascript-new-object-methods-1a427aa9b3aa?source=collection_archive---------7-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a5236834b01ea5d94c727c222aa3ba98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wV1f7JAXLH4BsZcP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">生殖健康用品联盟在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中新的OOP特性。</p><h1 id="3f39" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复制所有自己的属性</h1><p id="d714" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用<code class="fe me mf mg mh b">Reflect.ownKeys</code>方法获取所有自己的键来从对象中复制所有自己的属性。</p><p id="a332" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a470" class="mq lc iq mh b gy mr ms l mt mu">function copyAll(target, ...sources) {<br/>  for (const source of sources) {<br/>    for (const key of Reflect.ownKeys(source)) {<br/>      const desc = Object.getOwnPropertyDescriptor(source, key);<br/>      Object.defineProperty(target, key, desc);<br/>    }<br/>  }<br/>  return target;<br/>}</span></pre><p id="9c08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个包含对象数组的<code class="fe me mf mg mh b">sources</code>数组，我们希望将这些对象的属性复制到<code class="fe me mf mg mh b">target</code>中。</p><p id="2860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们循环遍历它们，然后用<code class="fe me mf mg mh b">Reflect.ownKeys</code>得到密钥。</p><p id="f311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到属性描述符，它包括带有<code class="fe me mf mg mh b">Object.getOwnPropertyDescriptor</code>的名称和值。</p><p id="aa45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">Object.defineProperty</code>来定义属性。</p><p id="5932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是要将属性复制到的<code class="fe me mf mg mh b">target</code>对象。</p><p id="bcb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是属性的<code class="fe me mf mg mh b">key</code>。</p><p id="0277" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数是属性描述符。</p><h1 id="5a46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Object.assign()</code>不适用于移动方法</h1><p id="827a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.assign</code>对于移动方法不太管用。</p><p id="5c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不能移动任何继承的方法。</p><p id="92f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为原型有很多不可枚举的方法，不能用<code class="fe me mf mg mh b">Object.assign</code>移动。</p><h1 id="2428" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">例子</h1><p id="3cac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Object.assign</code>方法将新属性复制到<code class="fe me mf mg mh b">this</code>。</p><p id="71b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7aba" class="mq lc iq mh b gy mr ms l mt mu">class Point {<br/>  constructor(x, y) {<br/>    Object.assign(this, {<br/>      x,<br/>      y<br/>    });<br/>  }<br/>}</span></pre><p id="f85d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比以下内容重复性更低:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="95f7" class="mq lc iq mh b gy mr ms l mt mu">class Point {<br/>  constructor(x, y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span></pre><p id="7fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以用它来提供对象属性的默认值。</p><p id="f4d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e587" class="mq lc iq mh b gy mr ms l mt mu">const DEFAULTS = {<br/>  logLevel: 0,<br/>  outputFormat: 'html'<br/>};</span><span id="b84c" class="mq lc iq mh b gy mv ms l mt mu">let options = {<br/>  frequency: 100<br/>}</span><span id="abf2" class="mq lc iq mh b gy mv ms l mt mu">options = Object.assign({}, DEFAULTS, options);</span></pre><p id="85b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">DEFAULTS</code>和<code class="fe me mf mg mh b">options</code>作为参数传入，将属性放入空对象。</p><p id="5a6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象作为两个对象的所有属性返回。</p><p id="64fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">Object.assign</code>方法向对象添加方法。</p><p id="e3ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="54c2" class="mq lc iq mh b gy mr ms l mt mu">function SomeClass() {}</span><span id="db34" class="mq lc iq mh b gy mv ms l mt mu">Object.assign(SomeClass.prototype, {<br/>  foo(arg1, arg2) {<br/>    //...<br/>  },<br/>  bar() {<br/>    //...<br/>  }<br/>});</span></pre><p id="499f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了<code class="fe me mf mg mh b">SomeClass</code>构造函数，并用<code class="fe me mf mg mh b">Object.assign</code>方法向其原型添加了更多属性。</p><p id="9d8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.assign</code>也非常适合克隆对象。</p><p id="4e3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4dee" class="mq lc iq mh b gy mr ms l mt mu">const clone = Object.assign({}, orig);</span></pre><p id="5521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将属性从对象复制到一个空对象并返回来创建一个<code class="fe me mf mg mh b">orig</code>对象的克隆。</p><h1 id="509c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Object.getOwnPropertySymbols(obj)</code></h1><p id="dcac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.getOwnPropertySymbols</code>方法让我们获得对象的非继承符号键。</p><p id="e56a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是对<code class="fe me mf mg mh b">Object.getOwnPropertyNames()</code>的补充，后者获取一个对象的所有非继承的字符串键。</p><p id="d09f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1dc8" class="mq lc iq mh b gy mr ms l mt mu">const foo = Symbol('foo');<br/>const obj = {<br/>  [foo]: 'bar'<br/>}</span><span id="f1e9" class="mq lc iq mh b gy mv ms l mt mu">const keys = Object.getOwnPropertySymbols(obj)</span></pre><p id="ee7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe me mf mg mh b">keys</code>就是<code class="fe me mf mg mh b">[Symbol(foo)]</code>。</p><h1 id="56f5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Object.is(值1，值2)</h1><p id="e75b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.is</code>是一种让我们比较两个值以确定它们是否相同的方法。</p><p id="7e7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和<code class="fe me mf mg mh b">===</code>操作符差不多。</p><p id="56d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同之处在于<code class="fe me mf mg mh b">NaN</code>等于自身。</p><p id="01bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe me mf mg mh b">-0</code>不被认为与<code class="fe me mf mg mh b">+0</code>相同。</p><p id="53a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4678" class="mq lc iq mh b gy mr ms l mt mu">Object.is(NaN, NaN)</span></pre><p id="f110" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">true</code>。</p><p id="5841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a065" class="mq lc iq mh b gy mr ms l mt mu">Object.is(-0, +0)</span></pre><p id="0b48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">false</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/fb4d6f631bd2a302a107f39b51c7b5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IYyfbPeosV7h5KqP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@epicantus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daria Nepriakhina </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="ab23" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2a43" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Reflect.ownKeys</code>得到所有非继承的键。</p><p id="6e7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe me mf mg mh b">Object</code>在ES6中增加了各种新方法。</p></div></div>    
</body>
</html>