<html>
<head>
<title>Dynamic Programming — Strategy to approach a DP question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划——解决动态规划问题的策略</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dynamic-programming-strategy-to-approach-a-dp-question-f0f27f5e6b22?source=collection_archive---------7-----------------------#2022-06-27">https://blog.devgenius.io/dynamic-programming-strategy-to-approach-a-dp-question-f0f27f5e6b22?source=collection_archive---------7-----------------------#2022-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/a0c801273c6e70215cc01831ab76ee8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syw2kfAv4QTHaEk097eu3g.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@hadijasaidi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈迪贾·赛义迪</a>在<a class="ae ja" href="https://unsplash.com/s/photos/past?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="487b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">动态编程是对递归的增强！！！</p><blockquote class="ky"><p id="dcad" class="kz la jd bd lb lc ld le lf lg lh kx dk translated">DP ==递归+记忆(自上而下)或列表(自下而上)</p></blockquote><h2 id="645d" class="li lj jd bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">识别 DP</h2><p id="200e" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">寻找像最大、最小、路数或最优这样的关键词。另一个暗示是，我们在每一步都有不同的选择。然后寻找这个问题的答案，给定的问题是优化问题吗？</p><p id="5470" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">最优子结构— </strong>给定问题具有最优子结构性质，如果利用其子问题的最优解可以得到给定问题的最优解。假设我们要寻找从<strong class="kc je"> <em class="mg">源</em> </strong>到<strong class="kc je"> <em class="mg">目的</em> </strong>的最短路径。让<strong class="kc je">通过</strong>成为<strong class="kc je"><em class="mg"/></strong>和<strong class="kc je"> <em class="mg">源</em> </strong>之间的中间点，用<strong class="kc je">单边</strong>连接到<strong class="kc je">源</strong>。但是我们有从<strong class="kc je">经过</strong>到<strong class="kc je">目的地的多条路径。</strong>在这种情况下<code class="fe mh mi mj mk b">shortest(source, destination) = min(Source → Via + min(Via → Destination))</code>。</p><p id="5ff4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">重叠子问题— </strong>动态规划将反复需要的子问题的解组合起来。DP 存储子问题的结果以避免重复计算。</p><p id="92cc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦发现问题，请采取以下步骤:</p><ol class=""><li id="9287" class="ml mm jd kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">想象这个问题</li><li id="0c13" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">查找子问题(后缀、前缀、子串)</li><li id="ab1e" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">找出子问题之间的关系</li><li id="f6b7" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">概括关系</li><li id="9cdf" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">实现子问题的顺序</li></ol><p id="9bba" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦你收集了观察结果，使用下面的框架来解决问题。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mz"><img src="../Images/3d055429c96f185de12fe888c065621f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SLd0NP0Go1UuVq5D04Bcw.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">解决动态规划问题的框架</figcaption></figure><p id="a092" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们带着一个问题去理解上面讨论的整个过程。</p><h2 id="e56c" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">爬楼梯</h2><p id="077f" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">你正在爬楼梯。需要 n 步才能到达顶端。每次你可以爬 1 或 2 级台阶。你有多少种不同的方式可以爬到顶端？</p><h2 id="bd4f" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">解决动态规划问题的框架</h2><p id="437e" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">1.定义目标函数</p><ul class=""><li id="3ed7" class="ml mm jd kc b kd ke kh ki kl mn kp mo kt mp kx nj mr ms mt bi translated">f(n)是到达第 n 级楼梯的不同方式的数量。</li></ul><p id="ee3e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.确定最小有效输入的基本情况</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="ff2b" class="li lj jd mk b gy no np l nq nr">f(0) = 1<br/>f(1) = 1<br/>f(2) = 2 # f(2) can be caluculated from f(0) and f(1) as well. I have taken this just for more clarity. </span></pre><p id="e3a8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.写下目标函数的递归关系。</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="1aee" class="li lj jd mk b gy no np l nq nr">f(n) = f(n-1) + f(n-2)</span></pre><p id="fed2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">注意:在递归中，我们一般会在每次后续的函数调用中减少输入空间。这里我们减少 n，如果我们有一个数组，我们可以通过增加索引(从左到右)或减少索引(从右到左)来减少数组的大小。</em></p><p id="067a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.执行的顺序是什么？</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="8f00" class="li lj jd mk b gy no np l nq nr">n → n-1 → n-2 … 1 → 0</span></pre><p id="1805" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.去哪里寻找答案？</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="880c" class="li lj jd mk b gy no np l nq nr">f(n)</span></pre><h2 id="99b5" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">递归解</h2><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="d38c" class="li lj jd mk b gy no np l nq nr">class Solution:<br/>    def climbStairs(self, n):<br/>        return self.cs_helper(n)<br/>    <br/>    def cs_helper(self, n): <br/>        if n == 0: <br/>           return 0<br/>        if n == 1:<br/>           return  1<br/>        if n == 2:<br/>           return 2<br/>        <br/>        return self.cs_helper(n - 1) + self.cs_helper(n - 2)</span></pre><h2 id="0009" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">递归+记忆</h2><blockquote class="ns nt nu"><p id="0951" class="ka kb mg kc b kd ke kf kg kh ki kj kk nv km kn ko nw kq kr ks nx ku kv kw kx ig bi translated">那些记不起过去的人，注定会重复过去。</p></blockquote><p id="0124" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用一个数组来存储计算参数的结果，而不是用同一个参数反复调用函数。</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="9ebe" class="li lj jd mk b gy no np l nq nr">class Solution:<br/>    def climbStairs(self, n):<br/>        memo = [None for i in range(n + 1)]<br/>        return self.cs_helper(n, memo)<br/>    <br/>    def cs_helper(self,n,memo):<br/>        if memo[n] is not None:<br/>            return memo[n] <br/>        if n == 0: <br/>           return 0<br/>        if n == 1:<br/>            result =  1<br/>        if n == 2:<br/>            result = 2<br/>        else:<br/>            result = self.cs_helper(n - 1, memo) + self.cs_helper(n - 2, memo)<br/>            memo[n] = result<br/>        return result</span></pre><p id="958a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">注意:你不需要实现递归函数，你可以简单地提出一个递归数学函数，找到它的状态，然后继续创建状态度量/数组。</em></p><p id="e6e5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们有了自上而下的解决方案，我们就可以把它转换成列表解决方案。</p><h2 id="6409" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">自下而上/制表</h2><p id="a4f8" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">现在我们按照这个框架，把递归解转换成线性解。由于基本情况我们使用 0，1 和 2 秒步骤，我们用值 0，1，2 初始化 dp[0]，dp[1]和 dp[2]。函数调用改为 dp[n]赋值，使用最后两个位置(dp[n-1] &amp; dp[n-2])作为查找得到答案。</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="ee70" class="li lj jd mk b gy no np l nq nr">class Solution:<br/>    def climbStairs(self, n):<br/>        dp = [0] * (n+1)<br/>        dp[0], dp[1], dp[2] = 0, 1, 2<br/>        for i in range(3, n+1):<br/>            dp[i] = dp[i-1] + dp[i-2]<br/>        return dp[n]</span></pre><p id="5072" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的解决方案中，我们使用的顺序是 0 → 1 →2 →3… →n-1 →n。</p><h2 id="278e" class="li lj jd bd lk ll ne dn ln lo nf dp lq kl ng ls lt kp nh lv lw kt ni ly lz ma bi translated">动态规划中的空间优化</h2><p id="ef27" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">因为在每个索引中，我们只寻找最后两个值，所以我们可以删除 DP 数组，只使用两个变量来得到结果。</p><pre class="na nb nc nd gt nk mk nl nm aw nn bi"><span id="c819" class="li lj jd mk b gy no np l nq nr">class Solution:<br/>    def climbStairs(self, n):<br/>        first = 1<br/>        second = 1<br/>        for i in range(2, n+1):<br/>            res = first+second<br/>            first, second = second, res<br/>        return second</span></pre><p id="3778" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">自顶向下&amp;自底向上</strong>方法的主要区别在于后一种方法计算所有的解，而前一种方法只计算那些需要的解。在自下而上的方法(制表)中，我们可以优化空间复杂度，这在递归解决方案中是不可能的。</p><blockquote class="ky"><p id="462d" class="kz la jd bd lb lc ld le lf lg lh kx dk translated"><strong class="ak"> <em class="ny">时间复杂度= O(状态数∫计算一个状态所需时间)</em> </strong></p></blockquote><ul class=""><li id="3c8d" class="ml mm jd kc b kd nz kh oa kl ob kp oc kt od kx nj mr ms mt bi translated">自底向上通常更快，因为递归有相当大的计算成本。</li><li id="d0f3" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx nj mr ms mt bi translated">在有许多从未计算过的表状态的情况下，自顶向下更快。</li></ul><p id="10eb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！！！</p></div></div>    
</body>
</html>