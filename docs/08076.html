<html>
<head>
<title>Promise in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无中生有</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/promise-in-nodejs-d8db90fcdd48?source=collection_archive---------9-----------------------#2022-05-15">https://blog.devgenius.io/promise-in-nodejs-d8db90fcdd48?source=collection_archive---------9-----------------------#2022-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/353b1640ab932a2440e7bc15f35703c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TWf5N6hIMHmOMbaB.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Pic Credit <a class="jz ka ep" href="https://medium.com/u/8b318225c16a?source=post_page-----d8db90fcdd48--------------------------------" rel="noopener" target="_blank"> freeCodeCamp </a></figcaption></figure><p id="4426" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Promise 允许您处理最终值或错误，或者换句话说，它允许您处理未来(异步)值(IO 阻塞任务值)。例如网络呼叫、读取文件等。这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<em class="kz">承诺</em>在未来的某个时间提供该值。</p><p id="50a3" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">承诺具有以下一组状态</p><ol class=""><li id="0db9" class="la lb in kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">待定—初始状态，既未完成也未拒绝。</li></ol><p id="6233" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz"> 2。完成</em>:表示操作成功完成。</p><p id="59f6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz"> 3。拒绝</em>:表示操作失败。</p><p id="62ec" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">承诺的语法</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="42a7" class="ls lt in lo b gy lu lv l lw lx">const promise = new <strong class="lo io"><em class="kz">Promise</em></strong>((resolve, reject) =&gt; {}).then(out =&gt; {}).catch(err =&gt; {})</span></pre><p id="f9ac" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Promise 有两个参数，一个是 resolve，另一个是 reject。<strong class="kd io"> resolve </strong>在未来(IO 阻塞任务)没有任何错误的情况下被调用，然后您可以使用 IO 任务值的输出调用 resolve。</p><p id="879c" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">而<strong class="kd io"> reject </strong>则是在执行一些阻塞任务时出现错误时调用。</p><p id="4cec" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">连锁承诺&amp;拒绝旁路</strong></p><p id="3ea6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们可以创造承诺链。然后功能。在 then 函数中，我们可以将值传递给下一个 then 函数。我们还可以<strong class="kd io">在<strong class="kd io"> then 函数</strong>中抛出错误</strong>，这将绕过当前 then 函数的所有 then，并在缓存函数中捕捉错误。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0442" class="ls lt in lo b gy lu lv l lw lx">const promise = new <strong class="lo io"><em class="kz">Promise</em></strong>((resolve, reject) =&gt; {<br/>    // Both asynchronous or synchronous code can be present here<br/>    resolve('good')<br/>    //reject('bad') // this will directly call catch method<br/>})<br/>    .then(data =&gt; {<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data);<br/>        return 1;<br/>    })<br/>    .then(data =&gt; {<br/>        throw 'really bad'; // this exception will get caught in the catch method and next then function will get bypass<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data);<br/>        return 2;<br/>    })<br/>    .then(data =&gt; {<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data);<br/>        return 3;<br/>    })<br/>    .then(data =&gt; {<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data);<br/>        return 4;<br/>    })<br/>    .catch(err =&gt; {<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(err);<br/>    })</span></pre><p id="9102" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">承诺的好处</strong></p><ol class=""><li id="c898" class="la lb in kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">为了克服回调地狱，我们可以使用承诺</li></ol><p id="609d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">为了克服回调地狱，我们可以使用承诺。然后-&gt;。然后-&gt;。然后，当我们需要方法使它像同步代码一样运行时</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="4806" class="ls lt in lo b gy lu lv l lw lx">const fs = require('fs');</span><span id="ca1f" class="ls lt in lo b gy ly lv l lw lx">new <strong class="lo io"><em class="kz">Promise</em></strong>((resolve, reject) =&gt; {<br/>    fs.readFile('../dir/file1.txt', (err, data) =&gt; {<br/>        if (err) {<br/>            reject(err);<br/>        } else{<br/>            resolve(data.toString());<br/>        }<br/>    })<br/>}).then(data =&gt; {<br/>    <strong class="lo io"><em class="kz">console</em></strong>.log(data);<br/>}).catch(err =&gt; {<br/>    <strong class="lo io"><em class="kz">console</em></strong>.log(err);<br/>})</span></pre><p id="46ae" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">2.一次调用多个同步方法</p><p id="3d52" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们可以使用 promise.all 函数一次调用多个同步函数。我举了一个从磁盘读取文件的例子</p><p id="e077" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">为了克服以回调地狱方式读取文件，我们可以使用 promise.all 方法，所有文件的输出将以最近的数组格式提供。然后方法。</p><p id="1e8f" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Promise.all 方法将一个参数作为我们从 util.promisify 方法中提取的承诺数组</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="78bc" class="ls lt in lo b gy lu lv l lw lx">const fs = require('fs');<br/>const utils = require('util');</span><span id="b3a1" class="ls lt in lo b gy ly lv l lw lx">const read = utils.promisify(fs.readFile);<br/><strong class="lo io"><em class="kz">Promise</em></strong>.all([<br/>    read('../dir/file1.txt'),<br/>    read('../dir/file2.txt'),<br/>    read('../dir/file3.txt')<br/>]).then(<br/>    data =&gt; {<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data[0].toString());<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data[1].toString());<br/>        <strong class="lo io"><em class="kz">console</em></strong>.log(data[2].toString());<br/>    })</span></pre><p id="b43d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这就是我所要分享的一切。如果你有更多的观点要分享，请在下面评论。这将帮助我和其他人获得更多关于承诺的知识。感谢阅读。请关注支持和更多这样的内容。</p><p id="0094" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae lz" href="https://www.youtube.com/channel/UCvEB7wXUEXGFE9lCx0USR3Q" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io">订阅获取更多类似内容解码，我们的 YouTube 频道</strong> </a> <strong class="kd io">！</strong></p><p id="79ba" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">注:更多精彩内容还可登陆<a class="ae lz" href="https://ajaykrp.me" rel="noopener ugc nofollow" target="_blank"> https://ajaykrp.me </a>。请检查一下。</p></div></div>    
</body>
</html>