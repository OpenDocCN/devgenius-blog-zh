<html>
<head>
<title>Quick Sort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速排序算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/quick-sort-algorithm-7bcf2ff1e79c?source=collection_archive---------0-----------------------#2020-05-12">https://blog.devgenius.io/quick-sort-algorithm-7bcf2ff1e79c?source=collection_archive---------0-----------------------#2020-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bc7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">逐行解释 C++中的快速排序算法</strong></p><p id="15c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di">一位</span>作者在这里用图表和代码截图简要解释了快速排序，还推荐了一些链接。此外，逐行解释该算法在 C++中的程序执行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/867a183dcfc1dfd930bf98e737e9b765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JS8P0ikspFNQdJa23iiSqw.png"/></div></div></figure><blockquote class="ld le lf"><p id="69e8" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">快速排序基于分而治之的方法，这种方法基于选择一个元素作为 pivot 元素并对其周围的数组进行分区的思想，这样:pivot 的左侧包含小于 pivot 元素的所有元素，右侧包含大于 pivot 元素的所有元素。</p></blockquote><h1 id="1b2e" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">图解说明快速排序算法的工作</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mi"><img src="../Images/167db3eb90a6fc8179f952bf863fb48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crDfWFaUmqbPjwp8yAIOVQ.jpeg"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ea738a8537e89f57ff096ed8b70e1f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*4pdM7bQUufuzQAJCfqfJyw.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e6ad73cecbc74f3f0547f712015bdff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*QORA_FMtqYA3iJhbNtFVBw.png"/></div></figure><h1 id="e336" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">现在让我们为这个算法编码</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/6499debeb49db1bc338d332f1d158460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nPRhqUm6WzPtAk1aX9pZg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd lm">节目第一部分(图 1) </strong></figcaption></figure><p id="171e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 37 行(图 1) :- </strong>这里从主函数启动程序，因为我们向用户询问数组的大小，由用户获取数组的元素，并在排序前打印元素。</p><p id="5b82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 57 行(图 1) :- </strong>这里我们调用排序算法对数组进行排序，现在是时候研究这个函数了，我们也将参数作为数组的第 0 个索引和数组的最后一个索引进行传递。</p><h1 id="89c4" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">现在让我们编写快速排序函数的代码</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mq"><img src="../Images/f251baec49cf2bdfedd7361a8b9b3af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQF3btfq6js7kbtOT8NNcw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd lm">程序的第二部分(图 2) </strong></figcaption></figure><p id="6177" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 27 行(图 2) :- </strong>这里我们应用主排序函数，将参数作为数组，将“s”作为起始索引，“e”作为结束索引。</p><p id="6b44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 29 行(图 2) :- </strong>这里我们检查的是起始索引是否小于结束索引，很明显起始索引(0)总是小于最后一个数组，写这个的目的是为了确定是否有更多的元素。</p><p id="d3b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 31 行(图 2) :- </strong>这里我们调用的是分区函数，将返回值存储在 p integer 中。也以参数为<em class="lg"> arr </em>和起始索引和结束索引。</p><p id="5dfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 32、33 行(图 2) :- </strong>这里我们递归调用函数本身，希望你对递归函数有所了解。</p><blockquote class="ld le lf"><p id="e064" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">在继续下一步之前，你至少应该听说过递归函数，如果你不知道的话，那就谷歌一下。</p></blockquote><h1 id="5d64" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">现在让我们编写我们的分区函数</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7984c730b157ba1227e446a2b06a8f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*CJ849qF2nhuCjt6Bk5AXHg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd lm">程序的第三部分(图 3) </strong></figcaption></figure><p id="d648" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">首先让我们了解分区的目的，因为该算法说选择一个枢轴，然后将所有较小的值放在左边，较大的值放在右边，这意味着与枢轴相比较小的值将在左边，而与枢轴相比较大的值将在右边。</strong></p><p id="d65d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 5 行(图 3) :- </strong>这里我们以参数为数组，起始索引，最后索引来应用分区。现在，在第 7 行中，我们将数组的最后一个元素作为支点，在下一行中，我们将一个整数作为第一个索引的值，我们将在下一个程序中使用<em class="lg"> iIndex </em>。</p><p id="f57e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 10 行(图 3) :- </strong>现在我们正在迭代一个 for 循环，将较小的值放在左边，将较大的值放在右边。所以从起始索引 0 开始循环，直到最后一个索引。现在，我们将第一个元素与 pivot 进行比较，并交换它们(将较小的值放在左边)。</p><p id="9983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第 21 行(图 3) :- </strong>这里我们正在执行交换，但是与 pivot 相比，它的值更大。并返回<em class="lg"> pIndex </em>的值。</p><h1 id="4b7f" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">下面视频中的快速排序算法讲解</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="ak">快速排序的算法说明</strong></figcaption></figure></div></div>    
</body>
</html>