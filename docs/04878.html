<html>
<head>
<title>Issues with Spring, how Micronaut solves it, and latter’s support for GraalVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring 的问题，Micronaut 如何解决它，以及后者对 GraalVM 的支持</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/micronaut-application-comparison-with-spring-boot-and-support-for-graalvm-d0fb0d933d55?source=collection_archive---------0-----------------------#2021-05-15">https://blog.devgenius.io/micronaut-application-comparison-with-spring-boot-and-support-for-graalvm-d0fb0d933d55?source=collection_archive---------0-----------------------#2021-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8a4908818f672c5ec19862370f1bbe81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhuJOJKTBsIM3AU72djYPg.png"/></div></div></figure><p id="f79d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java 有一个非常健壮和成熟的生态系统，但是大多数 JAVA 开发人员有时会被关于 JAVA 内存消耗和启动时间的问题所困扰。</p><p id="7c7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经在本文的第一部分<em class="kt"> — </em>的<strong class="jx io"> <em class="kt">中讨论了<strong class="jx io"> Spring Boot </strong>应用程序的这一方面，以及<strong class="jx io"> GraalVM </strong>如何在这方面提供惊人的突破性改进</em></strong></p><div class="ku kv gp gr kw kx"><a rel="noopener  ugc nofollow" target="_blank" href="/spring-boot-application-with-graalvm-native-image-8074034ba35f"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">具有 GraalVM 本机映像的 Spring Boot 应用程序</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">GraalVM 本机映像极大地改善了启动和内存消耗</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">blog.devgenius.io</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jt kx"/></div></div></a></div><p id="3546" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但问题仍然挥之不去…</p><p id="0680" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">我们能表现得更好吗？<br/>Spring 框架本身是否有某些方面导致了这个问题？<br/>有没有已经把事情做得更好的框架？</em></p><p id="cf27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，我们会试着通过深入研究找到这些问题的答案-</p><ul class=""><li id="f018" class="lm ln in jx b jy jz kc kd kg lo kk lp ko lq ks lr ls lt lu bi translated"><strong class="jx io"> Micronaut 框架与 Spring Boot 有什么不同</strong></li><li id="955f" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated"><strong class="jx io">创建一个类似于我们在第 1 部分中所做的 REST 应用程序</strong></li><li id="77f0" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated"><strong class="jx io">使用 GraalVM </strong>将应用程序转换为本机映像</li></ul><p id="6812" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，系好安全带，我们开始吧😉</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="1655" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">弹簧的缺点</h1><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/cccf2fc1ef67e8d1b96c07ab908a4f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wQGu0ca9RRrSHD7rkCwIw.png"/></div></div></figure><p id="ac32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，我们都知道 Spring 是开发微服务的一个很棒的框架。在<strong class="jx io"> DI </strong>(依赖注入)和<strong class="jx io"> AOP </strong>(面向方面编程)方面都是极其强大的。</p><p id="952e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是…… <strong class="jx io">它在运行时做这些！！！！</strong></p><ul class=""><li id="eca5" class="lm ln in jx b jy jz kc kd kg lo kk lp ko lq ks lr ls lt lu bi translated"><a class="ae nk" href="https://github.com/spring-projects/spring-framework/tree/main/spring-core/src/main/java/org/springframework/core/type/classreading" rel="noopener ugc nofollow" target="_blank">对于每个 bean，它读取字节码并执行运行时分析</a></li><li id="f61b" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated"><a class="ae nk" href="https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java" rel="noopener ugc nofollow" target="_blank">创建完整的注释元数据，即关于源代码中注释的元信息</a></li><li id="2635" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated"><a class="ae nk" href="https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java" rel="noopener ugc nofollow" target="_blank">为每个 bean 生成反射元数据，进行依赖注入，并进行 Bean 自检</a></li></ul><p id="c0f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，运行时有什么问题呢？嗯，它消耗了<strong class="jx io"> <em class="kt">整整一大堆内存。<br/> </em> </strong> Spring 的运行时反射方式导致<strong class="jx io"> <em class="kt">更长的启动时间</em> </strong>也是如此。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="12ba" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">Micronaut 有何不同？</h1><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a8d7ffd63a680a3ee45d8f61daa8090e.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*PAamYhgSsijIcXp-"/></div></figure><p id="4c88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，剩下的问题是—</p><p id="4bd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">“我们如何才能在控制内存的同时，充分利用 Spring 的优势和它的生产力优势？”</strong></p><p id="c709" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，答案是<a class="ae nk" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Micronaut </strong> </a> <strong class="jx io">。</strong>它通过大幅减少启动时间和 RAM 消耗来弥补性能问题。而且，这是打开真正的无服务器世界的大门。</p><p id="2b50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，它到底是如何做到这一点的呢？答案是<strong class="jx io">编译！！！</strong></p><p id="db36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Micronaut 使用<strong class="jx io"> <em class="kt">提前编译(AOT) </em> </strong>到<strong class="jx io"> <em class="kt"> </em> </strong>在编译时收集必要的信息。并表演—</p><ul class=""><li id="a92d" class="lm ln in jx b jy jz kc kd kg lo kk lp ko lq ks lr ls lt lu bi translated">依赖和配置注入(DI)</li><li id="0349" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated">AOP 代理</li><li id="f80b" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated">预计算注释元数据</li></ul><p id="1017" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，<strong class="jx io">它提供了春天的美好，但尽可能无反射。因此，它避免了支付更多内存和更长启动时间的成本。这无疑增加了编译时间，但这是为更多好处付出的小小代价！！！</strong></p><p id="6c07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想了解更多信息，请浏览 Micronaut 创始人 Graeme Rocher 的精彩演讲</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="40b7" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">示例 Micronaut 应用程序</h1><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/991c88e298df25789b3b837f68e987c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5wCjJAhoDgNik0OYLKrYjA.png"/></div></figure><p id="8846" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们编写一个 Micronaut 应用程序。它将完全基于我们在第 1 部分编写的 Spring Boot 应用程序。应用程序将公开两个 REST 端点，这两个端点都将接受 HTTP GET 请求。</p><ul class=""><li id="046a" class="lm ln in jx b jy jz kc kd kg lo kk lp ko lq ks lr ls lt lu bi translated">第一个端点应该提供对应于 Github 用户<strong class="jx io"> ( /users/{githubUserName})的信息。</strong></li><li id="e5aa" class="lm ln in jx b jy lv kc lw kg lx kk ly ko lz ks lr ls lt lu bi translated">第二个端点应该提供一个 Github 库的贡献者<br/><strong class="jx io">(</strong><a class="ae nk" href="http://localhost:8081/contributors/%7BgithubOrgName%7D/%7BgithubRepoName%7D" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">/contributors/{ githubOrgName }/{ githubRepoName }</strong></a><strong class="jx io">)对应的信息。</strong></li></ul><p id="223b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr ns b">GithubController</code>可以定义如下—</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="b9a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在 Micronaut 中使用<code class="fe np nq nr ns b">@ Controller</code>注释来编写 Rest 控制器。<br/> <code class="fe np nq nr ns b">HttpResponse</code>是 Micronaut 相当于 Spring Boot 的<code class="fe np nq nr ns b">ResponseEntity</code>。</p><p id="e097" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe np nq nr ns b">GithubClient</code>类来获取用户或贡献者的详细信息。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="a548" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们使用 Micronaut 内置的反应式非阻塞 HTTP 客户端— <code class="fe np nq nr ns b">RxHttpClient</code>。我们使用<code class="fe np nq nr ns b">@ Client</code>注释注入它。<br/>注意<code class="fe np nq nr ns b">@ Singleton</code>注释被用在类的顶部来声明必须创建一个单独的 bean。另外，请注意，<code class="fe np nq nr ns b">toBlocking()</code>被用作我们在第 1 部分中使用的<code class="fe np nq nr ns b">RestTemplate</code>,在 Spring Boot 是一个阻塞的 HTTP 客户端。</p><p id="cd2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看<code class="fe np nq nr ns b">User</code> DTO 类，它将被用作 REST 响应。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="217a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仔细注意这里使用了<code class="fe np nq nr ns b">@ Introspected</code>注释。它使您能够进行<strong class="jx io">无反射 bean 自省</strong>。这有助于在不使用反射的情况下封送/解封送 JSON。</p><p id="96cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Github API <strong class="jx io">强加了一个速率限制</strong>，因此你不能在一个小时内从一个给定的 IP 发出超过<code class="fe np nq nr ns b">60</code>个请求。我们可以使用 Github 身份验证令牌来提高这个速率限制。</p><p id="5a26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将<code class="fe np nq nr ns b">GithubProperties</code>定义为微型机器人<code class="fe np nq nr ns b">ConfigurationProperties</code>。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="67a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，现在我们可以在<code class="fe np nq nr ns b">application.properties</code> / <code class="fe np nq nr ns b">application.yaml</code>中添加一个名为<code class="fe np nq nr ns b">github.token</code>的属性。</p><p id="0e95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在尝试调用 Github API 时，如何使用这个令牌呢？嗯，我们需要实现<code class="fe np nq nr ns b">HttpClientFilter</code>。这与我们在第 1 部分中定义的<code class="fe np nq nr ns b">RestTemplate</code>拦截器的工作原理相同。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="5cd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<code class="fe np nq nr ns b">GithubAppTokenFilter</code>的<code class="fe np nq nr ns b">doFilter</code>函数添加了一个<code class="fe np nq nr ns b">Authorization</code>请求头，其中包含所提供令牌的编码值。<br/>由于使用了<code class="fe np nq nr ns b">@ Valid</code>和<code class="fe np nq nr ns b">@ Pattern</code>注释，因此将确保属性遵循上述正则表达式。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="116a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr ns b">RateLimitHeaderFilter</code>的<code class="fe np nq nr ns b">doFilter</code>功能提取<br/> <code class="fe np nq nr ns b">X-RateLimit-Remaining</code>响应报头并提供<code class="fe np nq nr ns b">log</code>语句以提供关于剩余速率限制的信息。</p><p id="3691" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码的最后一部分是应用程序的入口点。</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nt nn l"/></div></figure><p id="6f32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止我们讨论过的代码可以在这里找到—</p><div class="ku kv gp gr kw kx"><a href="https://github.com/shivamgarg7276/graal-micronaut/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">shivamgarg7276/graal-micronaut</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">这个示例项目展示了一个没有 AOT 的 Micronaut 应用程序，然后使用 GraalVM 将它转换成一个本机映像…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">github.com</p></div></div><div class="lg l"><div class="nu l li lj lk lg ll jt kx"/></div></div></a></div><p id="93e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，使用<code class="fe np nq nr ns b">mvn clean install</code>进行构建。<br/>Spring Boot 应用程序的构建时间是<code class="fe np nq nr ns b">2.6 sec</code>，而 Micronaut 显然需要更长的时间— <code class="fe np nq nr ns b">4.3 sec</code>。</p><p id="aed1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后运行<code class="fe np nq nr ns b">mvn mn:run</code>命令，应用程序将在<code class="fe np nq nr ns b">8080</code>端口启动。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/b12c111c4bf7eb85ad236b7df5db4b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEV1ViurWmX4gI4mf81QzQ.png"/></div></div></figure><p id="d1e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在我的机器上启动大约需要<code class="fe np nq nr ns b"><strong class="jx io">600 ms</strong></code>，内存消耗大约为<code class="fe np nq nr ns b"><strong class="jx io">155 MB</strong></code>，这比我们在 Spring Boot 应用程序中看到的结果要好得多。</p><p id="f741" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着负载的增加，Micronaut 应用程序消耗的内存越来越少。每秒请求数也相当好。</p><p id="f335" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">您可以在这里根据多项指标查看这两者之间的深入比较— </strong></p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="c6e2" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">❤️·格拉沃姆</h1><p id="0ac8" class="pw-post-body-paragraph jv jw in jx b jy nw ka kb kc nx ke kf kg ny ki kj kk nz km kn ko oa kq kr ks ig bi translated">您一定已经在第 1 部分中了解了 GraalVM 如何使用 AOT 来形成原生映像，从而大幅改善了启动时间和内存消耗。</p><p id="c983" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae nk" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> GraalVM </strong> </a> <strong class="jx io">使用静态分析来完成所有这些工作，由于 Micronaut 消除了反射、运行时代理、动态类加载和字节码生成，它在 GraalVM 中开箱即用，效果非常好。</strong></p><p id="421b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们将同一个应用程序转换成本机映像。</p><p id="c137" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不像在第 1 部分中，我们必须使用<strong class="jx io"> Spring Native，在本例中是</strong>——GraalVM<code class="fe np nq nr ns b">native-image-maven-plugin</code>已经在<br/> <code class="fe np nq nr ns b">micronaut-parent</code> maven 依赖中派上了用场。</p><p id="3ad5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，对于用 AOT 构建，您可以简单地使用这个命令- <br/> <code class="fe np nq nr ns b">mvn package -Dpackaging=native-image</code>来构建模块</p><p id="da2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将在模块的<code class="fe np nq nr ns b">target</code>文件夹下创建一个包含 Micronaut 应用程序的本地可执行文件。<br/>简单调用— <code class="fe np nq nr ns b">target/rest-service</code>。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/11db12f7f4d776f9a79ee39b0f905cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ve1UwjndmPDYwh3gJALKrg.png"/></div></div></figure><p id="3a93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你现在看到，我机器的启动时间是<code class="fe np nq nr ns b"><strong class="jx io">21 ms</strong></code>😳 😯</p><p id="36fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">快如闪电！！！</strong></p><p id="8cf5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，与 JIT 变体中的<code class="fe np nq nr ns b"><strong class="jx io">155 MB</strong></code>相比，这次的内存消耗应该在<code class="fe np nq nr ns b"><strong class="jx io">30 MB</strong></code>左右。</p><p id="7c07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这清楚地证明了 GraalVM + Micronaut 是一个致命的组合。低 RAM 消耗显示了这种方法对于无服务器世界的价值，在这个世界中，每兆字节的 RAM 都是要花钱的。</strong></p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="5e49" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">结论</h1><p id="3983" class="pw-post-body-paragraph jv jw in jx b jy nw ka kb kc nx ke kf kg ny ki kj kk nz km kn ko oa kq kr ks ig bi translated">Micronaut 框架提供了 Spring 的所有优点，而不必牺牲内存和启动时间。</p><p id="6d16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">那么，我们应该抛弃 Spring，开始使用 Micronaut 吗？🤔</strong></p><p id="3573" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">老实说，超越春天是一项艰巨的任务。有很多 Spring 的粉丝和用户(包括我😂)，而切换到 Micronaut 并不是一个容易做出的选择。</p><p id="330d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Micronaut 仍处于新兴状态，正在证明自己的勇气。它获得应有的巨大认可只是时间问题。<strong class="jx io">和 GraalVM 在一起，那绝对是一头野兽！！！</strong></p><p id="cfc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">竞争对行业总是有好处的。也许，Micronaut 的设计改进很少能进入 Spring 框架😁</strong></p><p id="ba50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文的下一部分，我们将讨论 GraalVM 的高级配置设置和一些关键案例。</p><p id="6523" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以在评论里发表自己的看法，给出建议。</p><p id="2713" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢😊</p></div></div>    
</body>
</html>