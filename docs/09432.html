<html>
<head>
<title>3 Java Features Experts Wish Would Be Better and What Are the Alternatives Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3 个专家希望更好的 Java 特性，现在有什么替代方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-java-features-experts-wish-would-be-better-and-what-are-the-alternatives-today-d9279bc55d98?source=collection_archive---------7-----------------------#2022-08-20">https://blog.devgenius.io/3-java-features-experts-wish-would-be-better-and-what-are-the-alternatives-today-d9279bc55d98?source=collection_archive---------7-----------------------#2022-08-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="86cd" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">#3 字符串插值</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/546efac97a5f4d63bad255556a31cbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q-SDGosAyVFilg9Q.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://www.freepik.com/photos/business" rel="noopener ugc nofollow" target="_blank">亚娜拉·www.freepik.com 创作的商业照片</a></figcaption></figure><p id="56cf" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你想要的 Java 特性远不止三个。</p><p id="a00b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">即便如此，这个故事也只讲几个。<strong class="kv is"> <em class="lp">打包、流和字符串插值。</em>T12】</strong></p><p id="fb52" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们将介绍目前可用的产品，以及有哪些替代产品。</p><p id="4fec" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们开始吧。</p><h1 id="b9b6" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">对目前的包装满意吗？</h1><p id="a2b4" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">在 Java 14 之前，没有本地打包工具。我们的意思是你需要在你的系统上安装 JDK/JRE。<em class="lp">没有来自 Java 的点击式可执行构建流程。</em></p><p id="7239" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">虽然有一个<code class="fe mn mo mp mq b">javapackager</code>并不是在所有的 JDK 发行版中都有。尽管如此，这是在 JDK 11 号中被移除的。<em class="lp">这个工具就是我们今天的</em> <code class="fe mn mo mp mq b"><em class="lp">jpackage</em></code> <em class="lp">工具的前身。</em></p><p id="837f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以在<code class="fe mn mo mp mq b">jpackage</code>之前，你需要 JRE 或 JDK 来运行应用程序。交付 JDK/JRE 更容易支持更新，并且这种方法的安全性不成问题。</p><p id="320b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">今天有什么活动？jpackage、jdeps 和 jlink。</p><p id="df02" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b"><a class="ae ks" href="https://docs.oracle.com/en/java/javase/14/docs/specs/man/jpackage.html" rel="noopener ugc nofollow" target="_blank">jpackage</a></code>首先创建应用程序映像。然后使用这些信息生成本地打包格式(dmg、pkg、exe)。</p><p id="c800" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">jlink</code>是一个归档员。你可以修改包含的内容，或者删除一些脂肪依赖。你仍然需要将应用程序与运行时打包。没有包装，它只是一个档案。</p><p id="5b26" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">结合 jlink 和 jpackage 获得自定义运行时。Jlink 受益于模块化 Java。因此，如果没有模块化结构，jlink 可能很难配置。</p><p id="34b4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里有一个 jlink 和 jdeps 可以提供帮助的真实例子。<a class="ae ks" href="https://levelup.gitconnected.com/java-developing-smaller-docker-images-with-jdeps-and-jlink-d4278718c550" rel="noopener ugc nofollow" target="_blank">乔使用这些工具</a>创建了一个定制的 JRE。这样做，他削减了大量脂肪或 250 兆脂肪。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="7db4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">还是，没有交叉编译。</em> </strong>你还是需要在 macOS 机器上编译 macOS app。</p><p id="7b2b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">即使有了 GraalVM 编译器，仍然没有办法交叉编译。Github 动作支持交叉编译。你可以为每个平台创建图像，这里是教程<a class="ae ks" href="https://github.com/marketplace/actions/github-action-for-graalvm#building-a-helloworld-with-graalvm-native-image-on-different-platforms" rel="noopener ugc nofollow" target="_blank">。<strong class="kv is"> <em class="lp">即便如此，GraalVM 也没有计划为本地开发加入交叉编译。</em> </strong></a></p><p id="378d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是托马斯(甲骨文实验室)<a class="ae ks" href="https://github.com/oracle/graal/issues/407#issuecomment-1188978769" rel="noopener ugc nofollow" target="_blank">对这个问题的看法:</a></p><p id="0604" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">“但是，目前还没有计划为不同的操作系统提供这种交叉编译支持，即从 Linux 创建 Windows 二进制文件，反之亦然。总的来说，我们简化本机映像创建的策略更倾向于提供本机映像生成服务，用户可以在其中指定所需的体系结构。”</em></p><p id="6d80" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是交叉编译的问题:<br/> <em class="lp">“在操作系统之间，JDK 或第三方库依赖项的初始化以及最终快照到本机映像的方式可能会有所不同。因此，本机映像的交叉编译问题比 C 程序的交叉编译更难解决。”</em></p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="358b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">至于优化的容器映像，现在我们有了 Spring Native。还有一个<a class="ae ks" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#executable-jar-to-native" rel="noopener ugc nofollow" target="_blank">工具</a>可以将可执行文件 JAR 转换成本机映像。</p><p id="8269" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这方面另一个值得一提的工具是:<a class="ae ks" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank">GitHub—Google container tools/jib:🏗为您的 Java 应用程序构建容器映像。</a>下面是<a class="ae ks" href="https://www.baeldung.com/jib-dockerizing" rel="noopener ugc nofollow" target="_blank">如何在 maven 项目中使用 jib</a>。Jib 使用图像分层技术，因此构建更加精细和增量。<strong class="kv is"> <em class="lp">有了 Jib 到位，就不需要 dockerfile 了，一切都是用 Java 构建的。</em>T24】</strong></p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="36d3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">包装 Java 应用仍在探索中。</em> </strong>有些<a class="ae ks" href="https://github.com/oracle/graal/issues/1069#issuecomment-473649871" rel="noopener ugc nofollow" target="_blank">还在争论 Graal JIT vs AOT 的利弊</a>。尽管如此，Java 工具的这一特性仍在不断发展。<em class="lp">我们可以期待未来更多的包装改进，比如</em> <a class="ae ks" href="https://mail.openjdk.org/pipermail/leyden-dev/2022-June/thread.html#42" rel="noopener ugc nofollow" target="_blank"> <em class="lp">莱顿项目</em> </a> <em class="lp">。</em></p><p id="314a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp"> JIT 编译还是会有的。</em> </strong></p><p id="e93c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因为<a class="ae ks" href="https://github.com/oracle/graal/issues/1069#issuecomment-647672692" rel="noopener ugc nofollow" target="_blank"> AOT 和 PGO 对于某些应用来说可能很贵</a>。并不是所有东西都可以移植到本机，一个例子就是<a class="ae ks" href="https://github.com/bazelbuild/bazel/issues/7884" rel="noopener ugc nofollow" target="_blank">巴泽尔构建系统</a>。</p><h1 id="5822" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">你如何处理流中的错误？</h1><p id="be50" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">大多数 Java 开发人员厌倦了在流中使用 try-catch。</p><p id="5209" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因为这是处理检查异常的唯一方法。你会发现很多关于这个问题的帖子。<strong class="kv is"> <em class="lp">即使到了今天，流中的检查异常处理似乎也被忽略了。</em> </strong></p><p id="5818" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">看看<a class="ae ks" href="https://mail.openjdk.org/pipermail/lambda-dev/2010-June/thread.html#1484" rel="noopener ugc nofollow" target="_blank">无休止的对话</a>没有给出具体的解决方案。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gi gj my"><img src="../Images/4feb4284c196261ecf39107a6237c5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0wcUUoKvpO2cMCU-Cvnew.png"/></div></div></figure><p id="1060" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">您现在可以用什么来缓解这个问题？</em></p><p id="0807" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们可以使用这个库来帮助解决这个问题。<br/><a class="ae ks" href="https://github.com/jOOQ/jOOL#orgjooqlambdaunchecked" rel="noopener ugc nofollow" target="_blank">GitHub—jOOQ/jOOL:jooλ—Java 8 缺失的部分—未检查</a></p><p id="8cf2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">还有人提议<code class="fe mn mo mp mq b">@SneakyThrows</code>从龙目岛出发。尽管这是一种无摩擦的方法，但是这个偷偷抛出的异常有一个问题。</p><p id="4dc7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">如果你使用@SneakyThrows，你需要处理上游的异常</em>。换句话说，您无法捕捉用 SneakyThrows 注释的方法抛出的异常。这种处理需要在其他地方进行，可能需要管理员的建议。</p><p id="5415" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">另外，SneakyThrows 诱使 javac 生成不可编译的字节码。基本上欺骗 javac 来产生 JVM 不介意运行的字节码。正如<code class="fe mn mo mp mq b">SneakyThrows</code> <a class="ae ks" href="https://github.com/projectlombok/lombok/blob/master/src/core/lombok/Lombok.java#L30" rel="noopener ugc nofollow" target="_blank">描述中所说的</a> : <br/> <em class="lp">“异常仍然被抛出——javac 将停止抱怨它。”</em></p><p id="80b9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因此在使用前请阅读<a class="ae ks" href="https://projectlombok.org/features/SneakyThrows#small-print" rel="noopener ugc nofollow" target="_blank">小字</a>。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="b65c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp"> Brian Goetz </em> <a class="ae ks" href="https://stackoverflow.com/a/27648758" rel="noopener ugc nofollow" target="_blank"> <em class="lp">提出</em> </a> <em class="lp">来包装例外。尽管如此，这看起来更像是样板文件，我们仍然不能抛出检查过的异常。</em></p><p id="3463" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">第三方的另一个解决方案是 Vavr。 <a class="ae ks" href="https://docs.vavr.io/#_try" rel="noopener ugc nofollow" target="_blank"> Vavr 尝试</a>可以解决这个问题，并且是专门为这个场景设计的。</p><p id="cf8e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">不管是哪种，都是用这个特性自己挑毒。在这个问题上，人们做得不多。至少我接触的代码库大多都有 SneakyThrows。<strong class="kv is"> <em class="lp"> SneakyThrows 是邪恶的，但其他替代方案需要更多的第三方依赖。</em> </strong></em></strong></p><h1 id="8986" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">Java 中的字符串插值在哪里？</h1><p id="2af7" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated"><code class="fe mn mo mp mq b">String#format</code>是我们今天拥有的最接近的东西。即便如此，它还是很笨重。您需要添加所有参数并指明它们的类型。</p><p id="1602" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">String#format</code>的表现值得怀疑。你可以找到一些关于这个问题的帖子<a class="ae ks" href="https://stackoverflow.com/questions/29747912/can-i-precompile-the-format-string-in-string-format-or-do-any-other-thing-to-m" rel="noopener ugc nofollow" target="_blank">这里</a>那里<a class="ae ks" href="https://stackoverflow.com/questions/513600/should-i-use-javas-string-format-if-performance-is-important" rel="noopener ugc nofollow" target="_blank">那里</a>。</p><p id="468d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们可以感谢 Claes 在 JDK17 中让<code class="fe mn mo mp mq b">String#format</code>变得更快。</p><p id="d4b8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">以下是他在 17 版本以下的 Java 中对<code class="fe mn mo mp mq b">String#format</code>的基准测试。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="c516" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">根据他的更新，我们得到了以下结果。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="4254" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">尽管如此，复杂的格式仍然很慢。但是让我们看看简单的场景。平均而言，这一变化使<code class="fe mn mo mp mq b">String#format</code>的速度提高了 3 倍。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="5d16" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">在此之前的另一个选项是</em></strong><a class="ae ks" href="https://guava.dev/releases/31.0-jre/api/docs/com/google/common/base/Strings.html#lenientFormat(java.lang.String,java.lang.Object...)" rel="noopener ugc nofollow" target="_blank"><strong class="kv is"><em class="lp"/></strong></a><strong class="kv is"><em class="lp">。</em> </strong></p><p id="e5e0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">宽松仅将字符串识别为输入。你可以在为这个方法编写的<a class="ae ks" href="https://github.com/google/guava/commit/7fe1702aeacff37ad4a7aca5d82ac9958e46e639#diff-8150a60b2bcf1a4afddf059f85b35a0dcc0bea9626d2ccc82edebe1cd1a24ef2" rel="noopener ugc nofollow" target="_blank">测试</a>中检查它是如何被使用的。</p><p id="f876" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">随着最近的改进，什么是更快的宽容格式或字符串#格式？</em>让我们看看<a class="ae ks" href="https://gist.github.com/zivce/bf1110a4f0f8b1d8a6fdacbf5dad343d" rel="noopener ugc nofollow" target="_blank">基准</a>的结果。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="5a22" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">如果你需要提高简单日志的性能，我会选择<code class="fe mn mo mp mq b">lenientFormat</code>。</p><p id="7ffd" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">还有其他的选择，但都归结为相同的格式。如果您可以使用 Apache Commons Text，您可以查看<a class="ae ks" href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StringSubstitutor.html" rel="noopener ugc nofollow" target="_blank">string substitutor(Apache Commons Text 1.9 API)</a>。</p><p id="03c2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">今天我们只有这个</em></strong><a class="ae ks" href="https://openjdk.org/jeps/8273943" rel="noopener ugc nofollow" target="_blank"><strong class="kv is"><em class="lp">JEP</em></strong></a><strong class="kv is"><em class="lp">作为 Java 中字符串插值的前驱。</em> </strong></p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="2481" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">在评论里让我知道你用 Java 的痛点。</em></p></div></div>    
</body>
</html>