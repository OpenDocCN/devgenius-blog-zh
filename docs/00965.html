<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/python-tutorial-collections-one-of-the-most-useful-library-in-python-19d52a5b37c3?source=collection_archive---------34-----------------------#2020-06-20">https://blog.devgenius.io/python-tutorial-collections-one-of-the-most-useful-library-in-python-19d52a5b37c3?source=collection_archive---------34-----------------------#2020-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/22a2e990003a66532ba97e0a29abedf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fTz2-c0io0PLy9Gb.jpeg"/></div></div></figure><p id="e23d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">今天我要分享一个强大的基础工具库，叫做‘集合’。</p><p id="3bd2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在英语中，collections 也有容器的意思，所以这是一个容器库。图书馆里有几个容器，有些很有用很受欢迎，有些不那么受欢迎。我从中挑选了应用最广泛的。我们来详细看看。</p><h2 id="d6fa" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">默认字典</h2><p id="aace" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">' Defaultdict '是库中最简单的容器之一，我们可以通过名字猜测用法。它解决了我们使用 dict 时一个很常见的问题:缺少键。</p><p id="0ed2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在正常情况下，当我们从字典中获取值时，我们需要注意关键字不在字典中的情况。如果我们忽略它，当我们调用一个不存在的键时，它可能会导致一个异常。</p><p id="113b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这个问题有几个解决方法，比如我们可以在调用之前检查这个键是否存在。但是代码不是很清楚:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b6e6" class="jv jw iy ky b gy lc ld l le lf">if key in dict:<br/>    return dict[key]<br/>else:<br/>    return None</span></pre><p id="0bb1" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">此外，如果键不存在，我们可以使用“get”函数给出一个默认值。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="924a" class="jv jw iy ky b gy lc ld l le lf">return dict.get(key, None)</span></pre><p id="c81e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">通过使用' get '函数，当键不存在时，它将返回我们设置的默认值，将会省去很多麻烦。但是它仍然有一些无法解决的问题。</p><p id="0b2e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">假设我们有重复的键，我们想使用列表来存储每个键的值。所以每次我们有一对新的键值时，我们都需要检查这个键的存在。如果关键字存在于字典中，我们只需将值追加到列表中，否则我们需要为它创建一个新的列表。</p><p id="dcb7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在此解决方案中，代码将是:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="41ac" class="jv jw iy ky b gy lc ld l le lf">data = [(1, 3), (2, 1), (1, 4), (2, 5), (3, 7)]<br/>d = {}<br/>for k, v in data:<br/>    if k in d:<br/>        d[k].append(v)<br/>    else:<br/>        d[k] = [v]</span></pre><p id="a445" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">由于 dict 的值是列表，所以我们需要确定它是否是 None，使用' get '函数肯定是可以的，但是不够简单。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="fee9" class="jv jw iy ky b gy lc ld l le lf">for k, v in data:<br/>    cur = d.get(k, [])<br/>    cur.append(v)<br/>    d[k] = v</span></pre><p id="ec3e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">为了完美解决，我们可以在集合中使用名为‘default dict’的工具。当我们初始化 defaultdict 时，我们需要为它设置一个默认类型。每次我们调用一个不存在的键，它都会返回该类型的空值。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1b13" class="jv jw iy ky b gy lc ld l le lf">from collections import defaultdict<br/>d = defaultdict(list)<br/><br/>for k, v in data:<br/>    d[k].append(v)</span></pre><p id="cf3f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">例如，如果我们初始化一个 defaultdict(int ),当键不存在时，它将返回 0。如果我们初始化一个 defaultdict(list ),当键不存在时，它将返回[]。</p><p id="5e3c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">另外，给它传递一个函数也是可以接受的，它会返回函数值。这里有一个例子。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ef1c" class="jv jw iy ky b gy lc ld l le lf">d = defaultdict(lambda: 3)<br/><br/>for k, v in data:<br/>    d[k] += v</span></pre><h2 id="91cb" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">计数器</h2><p id="719f" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">计数器是一个非常强大的工具，我们经常使用它。</p><p id="32b8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在实际编程中，我们经常会遇到计数和排序的问题。例如，我们正在分析一篇文章，我们有大量的单词。由于马太效应，它们中的大多数出现的次数很少，但是有几个出现的次数更多。我们希望统计每个单词出现的次数，并保留出现次数最多的几个单词。</p><p id="3f11" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这个任务对我们来说并不难实现，我们可以构建一个字典来解决它。我们需要迭代所有的单词，并统计它们的显示次数。之后，我们需要对它们进行排序。但是如果我们使用计数器，它将只花费我们一行。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="99da" class="jv jw iy ky b gy lc ld l le lf">words = ['apple', 'apple', 'pear', 'watermelon', 'pear', 'peach']<br/>from collections import Counter<br/>counter = Counter(words)<br/><br/>print(counter)<br/><br/>Counter({'apple': 2, 'pear': 2, 'watermelon': 1, 'peach': 1})</span></pre><p id="bb66" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">此外，我们可以将一个数组直接传递给计数器进行初始化。</p><p id="56a2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们想得到前 K 个项目，它有一个名为‘most _ common’的函数，它将返回最频繁的 K 个项目。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="9d34" class="jv jw iy ky b gy lc ld l le lf">counter.most_common(1)<br/><br/>[('apple', 2)]</span></pre><p id="ebd3" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">除此之外，它的构造函数也接受 dict 类型。我们可以通过一个值为 int 类型的字典来初始化一个计数器。例如:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c6a6" class="jv jw iy ky b gy lc ld l le lf">c = Counter({'apple': 5, 'pear': 4})<br/>c = Counter(apple=4, pear=3)</span></pre><p id="9349" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以得到正负两个计数器的结果。它会自动合并两个计数器。正运算等于做两个集合的并集，负运算等于做差集运算。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/3a9cf3f6342e626826649b278c5a53a2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9dy7oLGdm61IO3i-9k0sgw.jpeg"/></div></figure><h2 id="8560" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">双端队列</h2><p id="7cca" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">我们都知道队列的意思，“队列”也是一个队列，但是一个特殊的队列，它有两端。对于队列，我们只能从后端插入，从前端弹出。而对于 deque，我们可以从两端弹出和插入元素。所以它比队列更灵活。</p><p id="82e7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">除了常用的 api 如 clear、copy、count 和 extend 等，deque 常用的 api 有 append、pop、appendLeft 和 popLeft。正如我们从它们的名字中看到的，“append”和“pop”与 list 或 queue 相同，“appendLeft”和“popLeft”在队列的左侧执行。我想这并不难理解。</p><p id="22ab" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">实际上没有太多的算法使用双端队列。大多数情况下，我们使用 deque 有两个主要原因，第一个原因是 deque 由 GIL 管理，代表全局解释器锁，这使得它是线程安全的。在并发场景中，如果我们使用 list，可能会导致一些一致性问题，而 deque 不会。另一个原因是，deque 支持固定长度，当 deque 已满时，如果我们继续追加值，它会自动弹出最老的元素。</p><p id="d265" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">举个例子，如果我们有海量的数据，但是我们只需要其中最后的数据，那么使用 deque 就非常方便。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1b7a" class="jv jw iy ky b gy lc ld l le lf">from collections import deque<br/>dque = deque(maxlen=10)<br/># assume that we just need the last 10 rows<br/>for i in f.read():<br/>    dque.append(i)</span></pre><h2 id="9545" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">命名元组</h2><p id="1227" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">“命名元组”有点特殊，它与元编程有关。先简单介绍一下元编程的概念，这个我们就不太深入讨论了。</p><p id="9762" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">简而言之，在面向对象编程中，定义一个类并使用它来创建实例是非常常见的。而元编程意味着我们定义一个元类，这个元类的实例实际上是另一个类，而不是真正的实例。元类喜欢定义一个类的一个类。</p><p id="c6e9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">而‘named tuple’是一个非常简单的元类，我们可以用它来轻松定义类。</p><p id="6f32" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们来看一个例子，假设我们需要定义一个学生班级，有三个字段:姓名、分数和年龄。通常情况下，代码是:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="aa73" class="jv jw iy ky b gy lc ld l le lf">class Student:<br/>    def __init__(self, name=None, score=None, age=None):<br/>        self.name = name<br/>        self.score = score<br/>        self.age = age</span></pre><p id="7b90" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">它是最简单的类，没有任何其他定义。如果我们使用 namedtuple，我们可以只用一行代码创建这个类。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2e52" class="jv jw iy ky b gy lc ld l le lf">from collections import namedtuple<br/># We can also defines columns by 'name score age'<br/>Student = namedtuple('Student', ['name', 'score', 'age'])<br/><br/># Create an instance<br/>student = Student(name='Bob', score=99, age=10)<br/>print(student.name)</span></pre><p id="c12d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">它还支持使用参数“defaults”为字段设置默认值。我们可以向它传递一个列表或元组。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c1e8" class="jv jw iy ky b gy lc ld l le lf">Student = namedtuple('Student', ['name', 'score', 'age'], defaults=(0, 0))</span></pre><p id="ff53" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以看到，我们定义了一个包含三个字段的类，但是我们只设置了两个默认值。它仍然是合法的，因为它将匹配默认的“分数”和“年龄”。那是因为在 Python 中，可选参数只在末尾定义，所以‘name’字段一定不是可选的。</p><h2 id="6794" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">结论</h2><p id="b675" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">在今天的文章中，我们讨论了 defaultdict、Counter、deque 和 namedtuple 这四种数据结构的用法。除了这四个，我们在收藏库中还有一些其他工具，但是我们使用它们的频率有点低。如果你对它们感兴趣，你可以从官方文件中得到更多的细节。</p><p id="1601" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">本文到此为止，祝你有一个伟大的 Python 之旅。</p></div></div>    
</body>
</html>