<html>
<head>
<title>JavaScript Scope Can Be Dicey</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 范围可能是不确定的</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-scope-can-be-dicey-12a9f48bf328?source=collection_archive---------9-----------------------#2020-08-08">https://blog.devgenius.io/javascript-scope-can-be-dicey-12a9f48bf328?source=collection_archive---------9-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="902a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理解范围可以帮助你避免可怕的<em class="ki">代码味道。让我们剥离 JavaScript 中的作用域层——全局、局部、函数和块。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e4324ec6f58bc2903cd3471146ff2343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjDhAjpgS7YSfckEhK9LlQ.png"/></div></div></figure><p id="7675" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">学习范围规则(尤其是 JavaScript)对任何新开发人员来说都是痛苦的，甚至会继续困扰经验丰富的开发人员。受<em class="ki">代码味道</em>困扰的调试代码通常会暴露出对作用域的肤浅理解(比臭名昭著的洋葱味还要糟糕)。我将暂停洋葱类比，直接切入正题。</p><p id="142b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在单个模块中工作时，理解最高级别的范围是一个很好的起点:</p><ol class=""><li id="f941" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">作用域描述了程序的哪一部分可以访问特定的变量。</li><li id="d726" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">一个变量可以有<strong class="jm io">全局</strong>或<strong class="jm io">局部</strong>作用域，这取决于它的声明位置和方式。</li></ol><p id="533d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以从程序中的任何地方访问全局变量。这意味着你可以从程序的任何地方检索和重新分配全局变量，而不会有任何问题。(嗯，这可能有点夸张…变量隐藏<em class="ki">会</em>影响你在外部作用域中访问变量的能力。你可以在这里阅读关于如何避免可变阴影<a class="ae lj" href="https://medium.com/dev-genius/foxy-javascript-a647f9a18dc2" rel="noopener">的更详细描述。)全局变量可以在程序中的任何地方声明，也可以用<code class="fe lk ll lm ln b">let</code>或<code class="fe lk ll lm ln b">const</code>关键字声明(<code class="fe lk ll lm ln b">var</code>也是一个选项，但有自己的注意事项)，只要它们不是在函数或块中声明的。</a></p><pre class="kk kl km kn gt lo ln lp lq aw lr bi"><span id="baf9" class="ls lt in ln b gy lu lv l lw lx">let veggies = ['garlic', 'cabbage', 'celery'];</span><span id="2de1" class="ls lt in ln b gy ly lv l lw lx">if (true) {<br/>  veggies.push('onion');<br/>}</span><span id="26c8" class="ls lt in ln b gy ly lv l lw lx">console.log(veggies);<br/> <br/>// ⟶ ['garlic', 'cabbage', 'celery', 'onion'];</span></pre><p id="9dcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，变量<code class="fe lk ll lm ln b">veggies</code>在全局范围内，被称为“全局变量”</p><p id="c01d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非全局作用域的变量被称为具有<strong class="jm io">局部作用域</strong>，局部作用域有两种形式:</p><ol class=""><li id="0d11" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">函数作用域</strong>:函数体内定义的变量被认为具有函数作用域，并且只能从该函数内部访问。</li><li id="be08" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io">块范围</strong>:块被认为是由左花括号和右花括号<code class="fe lk ll lm ln b">{ }</code>组成的代码语句。我们看到最常使用<code class="fe lk ll lm ln b">if/else</code>、<code class="fe lk ll lm ln b">for</code>循环和<code class="fe lk ll lm ln b">while</code>循环来定义块。</li></ol><p id="143b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下示例说明了函数范围:</p><pre class="kk kl km kn gt lo ln lp lq aw lr bi"><span id="2876" class="ls lt in ln b gy lu lv l lw lx">let veggies = ['garlic', 'cabbage', 'celery', 'onion'];</span><span id="09d8" class="ls lt in ln b gy ly lv l lw lx">function chop(food) {  </span><span id="6a29" class="ls lt in ln b gy ly lv l lw lx">  let dinner = food.slice(0, 2);<br/>  <br/>  veggies = food.slice(2);</span><span id="adbd" class="ls lt in ln b gy ly lv l lw lx">  return dinner;<br/>}</span><span id="b744" class="ls lt in ln b gy ly lv l lw lx">chop(veggies);</span><span id="e10a" class="ls lt in ln b gy ly lv l lw lx">console.log(dinner);    // <em class="ki">ReferenceError: dinner is not defined</em></span><span id="7dd9" class="ls lt in ln b gy ly lv l lw lx">console.log(veggies);    <em class="ki">// ['celery', 'onion'];</em></span></pre><p id="ba06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，变量<code class="fe lk ll lm ln b">veggies</code>在全局范围内，可以从代码中的任何地方访问，而变量<code class="fe lk ll lm ln b">dinner</code>具有局部范围，因为它是在<code class="fe lk ll lm ln b">chop</code>的函数体内声明的。请注意，我们可以在函数中访问和重新分配<code class="fe lk ll lm ln b">veggies</code>，而这些更改在函数范围之外仍然存在。</p><p id="5c37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于块范围，它的工作方式类似:</p><pre class="kk kl km kn gt lo ln lp lq aw lr bi"><span id="69ed" class="ls lt in ln b gy lu lv l lw lx">let veggies = ['garlic', 'cabbage', 'celery', 'onion'];</span><span id="ae92" class="ls lt in ln b gy ly lv l lw lx">for (let veggie of veggies) {<br/>  let firstLetter = veggie[0];<br/>  let dinner = [];</span><span id="62bd" class="ls lt in ln b gy ly lv l lw lx">  if (firstLetter !== 'c') {<br/>    dinner.push(veggie);<br/>  } else {<br/>    let scrap = veggie;<br/>    console.log(scrap);<br/>  }<br/>}</span><span id="4c14" class="ls lt in ln b gy ly lv l lw lx">console.log(dinner);    // <em class="ki">ReferenceError: dinner is not defined</em></span><span id="f25a" class="ls lt in ln b gy ly lv l lw lx">console.log(scrap);    // <em class="ki">ReferenceError: scrap is not defined</em></span></pre><p id="63f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">试图访问其本地范围之外的<code class="fe lk ll lm ln b">dinner</code>(<code class="fe lk ll lm ln b">for</code>块)会导致引用错误，因为<code class="fe lk ll lm ln b">dinner</code>在该块之外是不可访问的。</p><p id="c6be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，在上面的例子中，我们有两个块:一个<code class="fe lk ll lm ln b">for</code>块和嵌套在其中的<code class="fe lk ll lm ln b">if/else</code>条件块。就像剥洋葱的皮一样，您会看到变量的作用域是由<strong class="jm io">嵌套</strong>进一步定义的:在嵌套函数或嵌套块的最内层声明的变量只能从该最内层访问。在上面的例子中，变量<code class="fe lk ll lm ln b">scrap</code>只有在声明后才能在<code class="fe lk ll lm ln b">if/else</code>块中访问。</p><p id="4b04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然可以说变量的范围都是相对的，但它比理论或相对论更容易理解(我希望！).让我们试一试:</p><ul class=""><li id="1609" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh lz lb lc ld bi translated">在最里面的块中声明的变量(比如<code class="fe lk ll lm ln b">scrap</code>)可以从<strong class="jm io">任何</strong>外部作用域中访问变量，包括全局作用域中的变量。</li><li id="74ef" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh lz lb lc ld bi translated">外部块<strong class="jm io">不能</strong> <em class="ki"> </em>访问任何内部作用域(嵌套比那个块更深)中声明的变量。所以试图从全局范围访问<code class="fe lk ll lm ln b">dinner</code>或<code class="fe lk ll lm ln b">scrap</code>会抛出一个错误。</li></ul><p id="0c7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">意识到外部作用域中的变量不仅可以被内部作用域访问，还可以被变异或重新分配，这很好。这是避免简短或模糊变量名的另一个重要原因。(当同一级别的两个函数或两个块使用相同的变量名时，这不是问题，也称为<em class="ki">对等作用域</em>，但这可能会使您的代码更难阅读。)</p><p id="f235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理需求时考虑范围也很重要。如果一个函数应该被设计为返回一个特定的变量，那么在考虑这些需求时，考虑作用域的分支是很重要的。在下面的例子中，应该在哪里声明<code class="fe lk ll lm ln b">missingItems</code>数组？</p><pre class="kk kl km kn gt lo ln lp lq aw lr bi"><span id="0567" class="ls lt in ln b gy lu lv l lw lx">let dinner = ['garlic', 'cabbage', 'celery', 'onion'];<br/>let foodWeHave = ['cabbage', 'celery'];</span><span id="ad79" class="ls lt in ln b gy ly lv l lw lx">function makeGroceryList(meal, food) {</span><span id="1590" class="ls lt in ln b gy ly lv l lw lx">  for (let veggie of dinner) {<br/>    if (!foodWeHave.includes(veggie)) {<br/>       missingItems.push(veggie);<br/>    }<br/>  }<br/>  return missingItems;<br/>}</span><span id="d0c1" class="ls lt in ln b gy ly lv l lw lx">console.log(makeGroceryList(dinner, foodWeHave));</span></pre><p id="85ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">答:</strong>变量<code class="fe lk ll lm ln b">missingItems</code>应该在紧接着函数声明的那一行声明，因为它需要在函数作用域级别可访问，才能在 return 语句中可访问。(这也意味着嵌套的<code class="fe lk ll lm ln b">for</code>和<code class="fe lk ll lm ln b">if </code>块可以访问它。)如果<code class="fe lk ll lm ln b">missingItems</code>只需要作为<code class="fe lk ll lm ln b">makeGroceryList</code>函数的一部分，它可能不需要在全局范围内。</p><p id="145e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像洋葱一样，范围可以减少一些眼泪。仔细跟踪变量的作用域，记住总是显式声明变量，并且在命名变量时要有意识，这有助于避免任何失败。最后，如果你还不熟悉可变阴影和全局范围污染这些概念，现在是时候重温一下了。重用变量名并在全局范围内声明大部分变量可能很诱人，但这可能会导致意想不到的错误，并使您的代码难以测试。你可以在这里找到这些陷阱的概要。</p><p id="9f84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论如何，理解 JavaScript 中的作用域将使您(和您的团队)远离可怕的代码味道，这种味道可能是由于不小心使用作用域而导致的。</p></div></div>    
</body>
</html>