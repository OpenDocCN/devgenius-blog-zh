<html>
<head>
<title>Deep dive into the .env file in JavaScript projects and implement its mechanism on our own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究。env 文件并自己实现它的机制</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deep-dive-into-the-env-file-in-javascript-projects-and-implement-its-mechanism-on-our-own-e1ff003c2116?source=collection_archive---------2-----------------------#2022-04-22">https://blog.devgenius.io/deep-dive-into-the-env-file-in-javascript-projects-and-implement-its-mechanism-on-our-own-e1ff003c2116?source=collection_archive---------2-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8905" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> JavaScript 深潜系列— 1 </em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/006a2e8587f76b7982bf960416c47577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*dtZUsG88aTRwS9HesUEy2Q.jpeg"/></div></figure><p id="2820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您使用前端框架如 Vue.js 或 React.js 已经有一段时间了，您可能已经熟悉了项目中的<code class="fe kr ks kt ku b">.env</code>文件。我们用它们来切换到不同的<code class="fe kr ks kt ku b">modes</code>，例如<code class="fe kr ks kt ku b">development</code>、<code class="fe kr ks kt ku b">test</code>和<code class="fe kr ks kt ku b">production</code>。基本上，我们可以在那些文件中定义一些“环境变量”，然后在代码中，我们可以通过<code class="fe kr ks kt ku b">process.env.xxxx</code>访问它们。比如这里是关于这个题目的<a class="ae kv" href="https://cli.vuejs.org/guide/mode-and-env.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki"> Vue CLI 文档</em> </strong> </a>。</p><p id="8a24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">知道<code class="fe kr ks kt ku b">.env</code>文件在幕后是如何工作的一定很有趣，所以让我们自己实现它的机制。</p><h1 id="d2d4" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义步骤并实施</h1><p id="2710" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><code class="fe kr ks kt ku b">.env</code>文件在项目中是如何工作的？这是它做的三件事:</p><ul class=""><li id="79a9" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">将读取<code class="fe kr ks kt ku b">.env</code>文件</li><li id="97f1" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">文件的内容将被处理</li><li id="61cd" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">文件中定义的“环境变量”将被添加到<code class="fe kr ks kt ku b">process.env</code>对象上。</li></ul><p id="cb5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建一个示例<code class="fe kr ks kt ku b">.env</code>文件，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/a25cb0e43da4aa85717f6a10d4f5769a.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*XiuB6eCHrsZ5YbaMM_i1uw.png"/></div></figure><p id="db0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这个机制是在 Node.js 环境下运行的，所以我们新建一个名为<code class="fe kr ks kt ku b">env-parser.js</code>的 js 文件，并把它和<code class="fe kr ks kt ku b">.env</code>文件放在同一个目录下。在<code class="fe kr ks kt ku b">env-parser.js</code>中，由于我们需要从磁盘中读取<code class="fe kr ks kt ku b">.env</code>文件，我们将在 Node.js 中导入<code class="fe kr ks kt ku b">fs</code>和<code class="fe kr ks kt ku b">path</code>模块:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/cf54487f77f1f00d2d77eb708d8a50f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*7XvbODFq-QIXivKni-TjAQ.png"/></div></figure><p id="3cba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，还创建了一个名为<code class="fe kr ks kt ku b">parse</code>的函数，我们的主逻辑将在其中。</p><p id="c0d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们继续阅读文件并输出其内容:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6b7e0925dfbee709350e4cdd580c8efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*fiLkVyMRAz8YNJcLwUC2hA.png"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/83564a67ebbd7ad77179348e1d447122.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*xSmgxB1FnWrZdWTfz9tLUA.png"/></div></figure><p id="9f2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以字符串格式成功读取内容。第一步完成了。</p><p id="2afd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将解析内容字符串，并最终将“环境变量”添加到<code class="fe kr ks kt ku b">process.env</code>对象上。因为内容字符串由<code class="fe kr ks kt ku b">\n</code>分隔，所以我们可以将其转换成数组以便于后续处理:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0f7a17bfdd9266119107de616d3f704f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*88wvX1NDq8IT_8caJzAhYA.png"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6a701210f5e63d0f329d89f3703d7b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*MFo1CYYd5wOEmmmWcoeE9Q.png"/></div></figure><p id="7e5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以迭代这个数组。对于每一项，我们将使用分隔符<code class="fe kr ks kt ku b">=</code>将其拆分，<code class="fe kr ks kt ku b">split()</code>的结果是一个字符串数组。然后我们从数组中获取键和值部分，并将它们添加到前面定义的对象<code class="fe kr ks kt ku b">obj</code>中:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/292b379cd05d499614fb1a67ac6ca04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*hw0Xnn3OxouFzL4pjQcghQ.png"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6324cfe71ec2998cca8732fef7596cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*q71BOioXNz984ZcsAOfuZA.png"/></div></figure><p id="0e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一大进步！最后一步是将<code class="fe kr ks kt ku b">obj</code>的内容添加到<code class="fe kr ks kt ku b">process.env</code>上。为此，我们将检查来自<code class="fe kr ks kt ku b">obj</code>的键是否已经存在于<code class="fe kr ks kt ku b">process.env</code>上，如果不存在，只将键-值对添加到<code class="fe kr ks kt ku b">process.env</code>上:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/208473e666931daff8713e51bd541bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*klcusdaMZqx7XwoayYGy3w.png"/></div></div></figure><p id="0c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您输出<code class="fe kr ks kt ku b">process.env</code>，您可以看到最初在<code class="fe kr ks kt ku b">.env</code>文件中定义的三个新的键值对。这就是每个<code class="fe kr ks kt ku b">.env</code>文件在 JavaScript 项目中的工作方式！</p><h1 id="20c1" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="3e12" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如果你打开你的 Vue 或者 React 项目，在它的<code class="fe kr ks kt ku b">node_modules</code>目录中你会发现一个名为<code class="fe kr ks kt ku b">dotenv</code>的依赖项。这是读取和解析所有<code class="fe kr ks kt ku b">.env</code>文件的实际库。如果你看一下它的<a class="ae kv" href="https://github.com/motdotla/dotenv/blob/master/lib/main.js" rel="noopener ugc nofollow" target="_blank">源代码</a>，核心逻辑和我们上面的例子差不多。<code class="fe kr ks kt ku b">dotenv</code>主要有两个名为<code class="fe kr ks kt ku b">config</code>和<code class="fe kr ks kt ku b">parse</code>的函数，但是在我们的简化实现中，我们只使用了一个函数。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="1b97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你觉得这篇文章很有用，请关注我，因为我每周都会发布 web 开发文章。</p></div></div>    
</body>
</html>