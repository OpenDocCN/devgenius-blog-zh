<html>
<head>
<title>Real-Time Key Value Store in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的实时键值存储</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/real-time-key-value-store-in-golang-d53b27ea4947?source=collection_archive---------1-----------------------#2021-03-27">https://blog.devgenius.io/real-time-key-value-store-in-golang-d53b27ea4947?source=collection_archive---------1-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="52b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章的目标是建立一个实时的T2数据库。为简单起见，我们将范围限制为:</p><ul class=""><li id="ab57" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">持久键值存储。</li><li id="5c69" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">每个客户端都必须有自己的存储版本。</li><li id="75fd" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">与其他客户端制作的事件同步。</li></ul><p id="ceba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我处理这个问题的方法。</p><h1 id="9bd2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">V1:使用散列表的简单KV存储</h1><p id="4a9d" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">让我们从一个简单的散列表开始，并在其上构建一个抽象。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6bbd" class="mj ky in mf b gy mk ml l mm mn">type Store struct {<br/>	db map[string]string<br/>}</span><span id="99d3" class="mj ky in mf b gy mo ml l mm mn">func NewStore() *Store {<br/>	store := &amp;Store{db: map[string]string{}}<br/>	return store<br/>}</span><span id="9f30" class="mj ky in mf b gy mo ml l mm mn">func (k Store) Get(key string) string {<br/>	return k.db[key]<br/>}</span><span id="d001" class="mj ky in mf b gy mo ml l mm mn">func (k Store) Put(key string, value string) {<br/>	k.db[key] = value<br/>}</span></pre><p id="d9ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，虽然这是一个关键价值存储，但它不是。它不持久存储数据，不了解其他客户端，所以基本上不能解决我们的问题。</p><h1 id="2fbb" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">V2:使用Redis作为发布订阅引擎来同步客户端</h1><p id="25c5" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">为了在客户端之间同步数据，我们使用Redis的发布-订阅功能。这个想法是每个客户将广播所有的<code class="fe mp mq mr mf b">PUT</code>事件。所有其他客户端都订阅了相同的频道，并将基于事件更新其本地数据库。我们不做任何冲突解决，只是让最新的事件获胜。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="43f4" class="mj ky in mf b gy mk ml l mm mn">type Store struct {<br/>	db          map[string]string<br/>	redisClient redis.Client<br/>}</span><span id="9832" class="mj ky in mf b gy mo ml l mm mn">func NewStore() *Store {</span><span id="7887" class="mj ky in mf b gy mo ml l mm mn">	redisClient := redis.NewClient(&amp;redis.Options{<br/>		Addr:     "localhost:6379",<br/>		Password: "",<br/>		DB:       0,<br/>	})</span><span id="fc45" class="mj ky in mf b gy mo ml l mm mn">	store := &amp;Store{db: map[string]string{},<br/>		redisClient: *redisClient,<br/>	}<br/>}</span></pre><figure class="ma mb mc md gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/b53381e304e58eda9f22c1713ce943c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Pj3msWTHBOjbV-t.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">每个客户端都订阅了一个redis主题，每当有PUT请求时，get就会得到通知。</figcaption></figure><h1 id="2cfd" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">V3:为冷启动在每个节点上保存数据</h1><p id="5966" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">到目前为止，我们的客户还没有持久化数据，因为我们只使用了内存中的散列表。Bitcask 是一个嵌入式键值存储。我们用它来替换内存中的散列表。Bitcask强制在给定时间只有一个操作系统进程可以打开数据库进行写入。所以我们的每个客户都需要有自己的客户id。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="12d0" class="mj ky in mf b gy mk ml l mm mn">type Store struct {<br/>	db          *bitcask.Bitcask<br/>	redisClient redis.Client<br/>}</span><span id="2945" class="mj ky in mf b gy mo ml l mm mn">func NewStore() *Store {</span><span id="51d8" class="mj ky in mf b gy mo ml l mm mn">	redisClient := redis.NewClient(&amp;redis.Options{<br/>		Addr:     redisAddr,<br/>		Password: redisPassword,<br/>		DB:       redisDB,<br/>	})<br/>	var dbFile = "/tmp/" + *clientId</span><span id="1a64" class="mj ky in mf b gy mo ml l mm mn">	db, err := bitcask.Open(dbFile)</span><span id="1858" class="mj ky in mf b gy mo ml l mm mn">	if err != nil {<br/>		log.Fatal("Failed to open db " + err.Error())<br/>	}<br/>	store := &amp;Store{db: db,<br/>		redisClient: *redisClient,<br/>	}<br/>	return store<br/>}</span></pre><figure class="ma mb mc md gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/f70586e42d0617836483363d932d2e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-MJBo7M8T-Fv3f_5.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">每个客户端都使用Bitcask维护数据库的本地副本</figcaption></figure><h1 id="0112" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">V4:事件缓冲区</h1><p id="2046" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">现在，我们已经解决了保存数据的本地持久副本以及在客户端之间同步事件的问题。还有一个问题是冷启动。</p><ol class=""><li id="ca0f" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh nf kp kq kr bi translated">我们现在通过在bitcast和redis中保存数据来解决这个问题。</li><li id="9d09" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh nf kp kq kr bi translated">在所有客户端中引入事件缓冲区。</li></ol><p id="f2f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦客户端启动，它开始从redis中读取旧数据，它还向redis订阅新事件并将它们存储在缓冲区中，一旦它从redis中读取初始状态，它就开始处理新事件。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="431a" class="mj ky in mf b gy mk ml l mm mn">type Store struct {<br/>	db          *bitcask.Bitcask<br/>	redisClient redis.Client<br/>	buffer      chan string<br/>	initDone    chan bool<br/>	bufferSize  int64<br/>}</span><span id="972e" class="mj ky in mf b gy mo ml l mm mn">func NewStore(redisAddr string, redisPassword string, redisDB int, redisChannel string, clientId string, bufferSize int64) *Store {</span><span id="2941" class="mj ky in mf b gy mo ml l mm mn">	redisClient := redis.NewClient(&amp;redis.Options{<br/>		Addr:     redisAddr,<br/>		Password: redisPassword,<br/>		DB:       redisDB,<br/>	})<br/>	var dbFile = "/tmp/" + clientId<br/>	bufferChan := make(chan string, 100)</span><span id="afac" class="mj ky in mf b gy mo ml l mm mn">	db, err := bitcask.Open(dbFile)</span><span id="bf3e" class="mj ky in mf b gy mo ml l mm mn">	if err != nil {<br/>		log.Fatal("Failed to open db " + err.Error())<br/>	}<br/>	store := &amp;Store{db: db,<br/>		redisClient: *redisClient,<br/>		buffer:      bufferChan,<br/>		initDone:    make(chan bool),<br/>		bufferSize:  bufferSize,<br/>	}<br/>	go store.loadData()<br/>	go store.subscribe()<br/>	return store<br/>}</span></pre><figure class="ma mb mc md gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/fc187c7211e7ca8b8338644125695066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SBbCvA_pUco3fKx3.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">每个客户端将订阅的事件存储在事件缓冲区中。新客户端首先从redis读取当前状态，同时将活动事件存储在事件缓冲区中。</figcaption></figure><p id="7b51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仍然有很大的改进空间，但是到目前为止，对于我正在开发的一个简单的应用程序来说，这种设置工作得很好。</p><p id="a88e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">源代码可在<a class="ae ne" href="https://github.com/lastlegion/rtdb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得</p><p id="e68b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初发表于<a class="ae ne" href="https://iyer.ai/realtime-db-in-golang/" rel="noopener ugc nofollow" target="_blank">https://iyer.ai/realtime-db-in-golang/</a></p></div></div>    
</body>
</html>