<html>
<head>
<title>Differences Between Arrow and Regular Functions in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中箭头函数和常规函数的区别</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/differences-between-arrow-and-regular-functions-in-javascript-737b76ba875f?source=collection_archive---------6-----------------------#2022-05-11">https://blog.devgenius.io/differences-between-arrow-and-regular-functions-in-javascript-737b76ba875f?source=collection_archive---------6-----------------------#2022-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/25989fe2cc29a303eb028ba6a00bf803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nUdBgFOsAxJ7qBLd"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">弗洛里安·奥利佛在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9b9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以用多种方式定义 JavaScript 函数。</p><p id="942c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一种通常的方法是使用<code class="fe ky kz la lb b">function</code>关键字:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="5a98" class="lk ll in lb b gy lm ln l lo lp">// Function declaration<br/>function greet(who) {<br/>    return `Hello, ${who}!`;<br/>}</span><span id="e122" class="lk ll in lb b gy lq ln l lo lp">// Function expression<br/>const greet = function(who) {<br/>    return `Hello, ${who}`;<br/>}</span></pre><p id="4b3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我要作为常规函数引用的函数声明和函数表达式。</p><p id="d791" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从 ES2015 开始，第二种方法是箭头函数语法:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="6847" class="lk ll in lb b gy lm ln l lo lp">const greet = (who) =&gt; {<br/>    return `Hello, ${who}!`;<br/>}</span></pre><p id="24b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然常规语法和箭头语法都定义函数，但是什么时候你会选择一个而不是另一个呢？这个问题问得好。</p><p id="ac9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将展示两者之间的主要区别，这样你就可以根据自己的需要选择正确的语法。</p><h1 id="941c" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目录</h1><ul class=""><li id="7795" class="mo mp in kc b kd mq kh mr kl ms kp mt kt mu kx mv mw mx my bi translated">这个值</li><li id="5785" class="mo mp in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">构造器</li><li id="1b3a" class="mo mp in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">参数对象</li><li id="451e" class="mo mp in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">隐性回报</li><li id="3790" class="mo mp in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">方法</li><li id="4c37" class="mo mp in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">摘要</li></ul><h1 id="b5bf" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.这个值</h1><h2 id="900a" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">正则函数</h2><p id="9d26" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">在常规 JavaScript 函数内部，<code class="fe ky kz la lb b">this</code>值(也称为执行上下文)是动态的。</p><p id="9689" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">动态上下文意味着<code class="fe ky kz la lb b">this</code>的值取决于函数是如何被调用的。在 JavaScript 中，有 4 种方法可以调用常规函数。</p><p id="7650" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个简单的调用过程中，<code class="fe ky kz la lb b">this</code>的值等于全局对象(或者如果函数在严格模式下运行，则等于<code class="fe ky kz la lb b">undefined</code>):</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="9cd3" class="lk ll in lb b gy lm ln l lo lp">function myFunction() {<br/>    console.log(this);<br/>}</span><span id="6497" class="lk ll in lb b gy lq ln l lo lp">// Simple invocation<br/>myFunction(); // logs global object (window)</span></pre><p id="ad37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在方法调用期间，<code class="fe ky kz la lb b">this</code>的值是拥有该方法的对象:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="ab8f" class="lk ll in lb b gy lm ln l lo lp">const myObject = {<br/>    method() {<br/>        console.log(this);<br/>    }<br/>}</span><span id="d8a0" class="lk ll in lb b gy lq ln l lo lp">// Method invocation<br/>myObject.method(); // logs myObject</span></pre><p id="8baf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在使用<code class="fe ky kz la lb b">myFunc.call(thisVal, arg1, ..., argN)</code>或<code class="fe ky kz la lb b">myFunc.apply(thisVal, [arg1, ..., argN])</code>的间接调用中，<code class="fe ky kz la lb b">this</code>的值等于第一个参数:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="774b" class="lk ll in lb b gy lm ln l lo lp">function myFunction() {<br/>    console.log(this);<br/>}</span><span id="612b" class="lk ll in lb b gy lq ln l lo lp">const myContext = { value: 'A' };</span><span id="1199" class="lk ll in lb b gy lq ln l lo lp">myFunction.call(myContext);  // logs { value: 'A' }<br/>myFunction.apply(myContext); // logs { value: 'A' }</span></pre><p id="1e26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在构造函数调用期间，使用关键字<code class="fe ky kz la lb b">new</code>等于新创建的实例:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="8e35" class="lk ll in lb b gy lm ln l lo lp">function MyFunction() {<br/>    console.log(this);<br/>}</span><span id="39e6" class="lk ll in lb b gy lq ln l lo lp">new MyFunction(); // logs an instance of MyFunction</span></pre><h2 id="8291" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">箭头功能</h2><p id="50ca" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">箭头函数内部的<code class="fe ky kz la lb b">this</code>行为与常规函数的<code class="fe ky kz la lb b">this</code>行为有很大不同。arrow 函数没有定义自己的执行上下文。</p><p id="f389" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论在何处或以何种方式执行，箭头函数内的<code class="fe ky kz la lb b">this</code>值总是等于外部函数的<code class="fe ky kz la lb b">this</code>值。换句话说，arrow 函数在词汇上解析<code class="fe ky kz la lb b">this</code>。</p><p id="3a44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，<code class="fe ky kz la lb b">myMethod()</code>是<code class="fe ky kz la lb b">callback()</code>箭头函数的外部函数:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="ded5" class="lk ll in lb b gy lm ln l lo lp">const myObject = {<br/>    myMethod(items) {<br/>        console.log(this); // logs myObject<br/>        const callback = () =&gt; {<br/>            console.log(this); // logs myObject<br/>        };<br/>        items.forEach(callback);<br/>    }<br/>};</span><span id="44ce" class="lk ll in lb b gy lq ln l lo lp">myObject.myMethod([1, 2, 3]);</span></pre><p id="c2d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>箭头函数<code class="fe ky kz la lb b">callback()</code>内的值等于外部函数<code class="fe ky kz la lb b">myMethod()</code>的<code class="fe ky kz la lb b">this</code>。</p><p id="5dd8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>词法解析是 arrow 函数的一大特点。当在方法中使用回调时，你肯定 arrow 函数没有定义自己的<code class="fe ky kz la lb b">this</code>:没有更多的<code class="fe ky kz la lb b">const self = this</code>或<code class="fe ky kz la lb b">callback.bind(this)</code>变通方法。</p><p id="b475" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与常规函数相反，使用<code class="fe ky kz la lb b">myArrowFunc.call(thisVal)</code>或<code class="fe ky kz la lb b">myArrowFunc.apply(thisVal)</code>对 arrow 函数的间接调用不会改变<code class="fe ky kz la lb b">this</code>的值:上下文值总是按词法解析的。</p><h1 id="5829" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.构造器</h1><h2 id="cb96" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">正则函数</h2><p id="6f67" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">正如上一节所看到的，正则函数可以很容易地构造对象。</p><p id="a0c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，<code class="fe ky kz la lb b">new Car()</code>函数创建一辆汽车的实例:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="7f9e" class="lk ll in lb b gy lm ln l lo lp">function Car(color) {<br/>    this.color = color;<br/>}</span><span id="a04d" class="lk ll in lb b gy lq ln l lo lp">const redCar = new Car('red');</span><span id="3570" class="lk ll in lb b gy lq ln l lo lp">redCar instanceof Car; // =&gt; true</span></pre><p id="d383" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">Car</code>是常规函数。当用<code class="fe ky kz la lb b">new</code>关键字<code class="fe ky kz la lb b">new Car('red')</code>调用时，创建<code class="fe ky kz la lb b">Car</code>类型的新实例。</p><h2 id="c8f5" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">箭头功能</h2><p id="3da1" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>的词法解析的结果是箭头函数不能用作构造函数。</p><p id="fb4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您试图调用以<code class="fe ky kz la lb b">new</code>关键字为前缀的箭头函数，JavaScrip 会抛出一个错误:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="95ac" class="lk ll in lb b gy lm ln l lo lp">const Car = (color) =&gt; {<br/>    this.color = color;<br/>};</span><span id="4f71" class="lk ll in lb b gy lq ln l lo lp">const redCar = new Car('red'); <br/>// TypeError: Car is not a constructor</span></pre><p id="0f60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用<code class="fe ky kz la lb b">new Car('red')</code>，其中<code class="fe ky kz la lb b">Car</code>是一个箭头函数，抛出<code class="fe ky kz la lb b">TypeError: Car is not a constructor</code>。</p><h1 id="fce2" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">3.参数对象</h1><h2 id="68f2" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">正则函数</h2><p id="1057" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">在常规函数体内，<code class="fe ky kz la lb b">arguments</code>是一个特殊的类似数组的对象，包含调用函数所用的参数列表。</p><p id="8465" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用两个参数调用<code class="fe ky kz la lb b">myFunction()</code>函数:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="87f5" class="lk ll in lb b gy lm ln l lo lp">function myFunction() {<br/>    console.log(arguments);<br/>}</span><span id="473f" class="lk ll in lb b gy lq ln l lo lp">myFunction('a', 'b'); // logs { 0: 'a', 1: 'b', length: 2 }</span></pre><p id="3223" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe ky kz la lb b">myFunction()</code>主体内部，<code class="fe ky kz la lb b">arguments</code>是一个类似数组的对象，包含调用参数:<code class="fe ky kz la lb b">'a'</code>和<code class="fe ky kz la lb b">'b'</code>。</p><h2 id="1d66" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">箭头功能</h2><p id="fe87" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">另一方面，在箭头函数中没有定义特殊关键字。</p><p id="bcf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次说明(与<code class="fe ky kz la lb b">this</code>值相同)，<code class="fe ky kz la lb b">arguments</code>对象被词法解析:arrow 函数从外部函数访问<code class="fe ky kz la lb b">arguments</code>。</p><p id="1554" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们尝试访问箭头函数内部的<code class="fe ky kz la lb b">arguments</code>:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="544d" class="lk ll in lb b gy lm ln l lo lp">function myRegularFunction() {<br/>    const myArrowFunction = () =&gt; {<br/>        console.log(arguments);<br/>    }<br/>    myArrowFunction('c', 'd');<br/>}</span><span id="cd01" class="lk ll in lb b gy lq ln l lo lp">myRegularFunction('a', 'b'); // logs { 0: 'a', 1: 'b', length: 2 }</span></pre><p id="6fc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">箭头函数<code class="fe ky kz la lb b">myArrowFunction()</code>被参数<code class="fe ky kz la lb b">'c'</code>、<code class="fe ky kz la lb b">'d'</code>调用。然而，在其主体内部，<code class="fe ky kz la lb b">arguments</code>对象等于<code class="fe ky kz la lb b">myRegularFunction()</code>调用的参数:<code class="fe ky kz la lb b">'a'</code>，<code class="fe ky kz la lb b">'b'</code>。</p><p id="0636" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想访问 arrow 函数的直接参数，那么你可以使用<a class="ae jz" href="https://dmitripavlutin.com/javascript-function-parameters/#5-rest-parameters" rel="noopener ugc nofollow" target="_blank">rest 参数</a>特性:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="863c" class="lk ll in lb b gy lm ln l lo lp">function myRegularFunction() {<br/>    const myArrowFunction = (...args) =&gt; {<br/>        console.log(args);<br/>    }<br/>    myArrowFunction('c', 'd');<br/>}</span><span id="722f" class="lk ll in lb b gy lq ln l lo lp">myRegularFunction('a', 'b'); // logs ['c', 'd']</span></pre><p id="3d5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">...args</code> rest 参数收集 arrow 函数的执行参数:<code class="fe ky kz la lb b">['c', 'd']</code>。</p><h1 id="eb82" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.隐性回报</h1><h2 id="10be" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">正则函数</h2><p id="47e4" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated"><code class="fe ky kz la lb b">return expression</code>语句返回函数的结果:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="a932" class="lk ll in lb b gy lm ln l lo lp">function myFunction() {<br/>    return 42;<br/>}</span><span id="1e28" class="lk ll in lb b gy lq ln l lo lp">myFunction(); // =&gt; 42</span></pre><p id="db26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果缺少<code class="fe ky kz la lb b">return</code>语句，或者 return 语句后没有表达式，正则函数隐式返回<code class="fe ky kz la lb b">undefined</code>:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="3e89" class="lk ll in lb b gy lm ln l lo lp">function myEmptyFunction() {<br/>    42;<br/>}</span><span id="415f" class="lk ll in lb b gy lq ln l lo lp">function myEmptyFunction2() {<br/>    42;<br/>    return;<br/>}</span><span id="d0f0" class="lk ll in lb b gy lq ln l lo lp">myEmptyFunction();  // =&gt; undefined<br/>myEmptyFunction2(); // =&gt; undefined</span></pre><h2 id="ce8a" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">箭头功能</h2><p id="9cd4" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">可以像从常规函数中返回值一样从 arrow 函数中返回值，但有一个有用的例外。</p><p id="7f9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果 arrow 函数包含一个表达式，并且您省略了函数的花括号，那么表达式将隐式返回。这些是内嵌箭头函数。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="d9d9" class="lk ll in lb b gy lm ln l lo lp">const increment = (num) =&gt; num + 1;<br/>increment(41); // =&gt; 42</span></pre><p id="22bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">increment()</code>箭头只包含一个表达式:<code class="fe ky kz la lb b">num + 1</code>。该表达式由 arrow 函数隐式返回，不使用<code class="fe ky kz la lb b">return</code>关键字。</p><h1 id="f11c" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">5.方法</h1><h2 id="d8e8" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">正则函数</h2><p id="5d2f" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">正则函数是在类上定义方法的常用方式。</p><p id="d356" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的类<code class="fe ky kz la lb b">Hero</code>中，使用常规函数定义了方法<code class="fe ky kz la lb b">logName()</code>:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="f57b" class="lk ll in lb b gy lm ln l lo lp">class Hero {<br/>    constructor(heroName) {<br/>        this.heroName = heroName;<br/>    }<br/>    <br/>    logName() {<br/>        console.log(this.heroName);<br/>    }<br/>}</span><span id="9a89" class="lk ll in lb b gy lq ln l lo lp">const batman = new Hero('Batman');</span></pre><p id="dfb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，常规函数作为方法是可行的。</p><p id="d4fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时你需要提供一个回调方法，比如给<code class="fe ky kz la lb b">setTimeout()</code>或者一个事件监听器。在这种情况下，您可能会遇到访问<code class="fe ky kz la lb b">this</code>值的困难。</p><p id="f904" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，让我们使用 use <code class="fe ky kz la lb b">logName()</code>方法作为对<code class="fe ky kz la lb b">setTimeout()</code>的回调:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="0121" class="lk ll in lb b gy lm ln l lo lp">setTimeout(batman.logName, 1000);<br/>// after 1 second logs "undefined"</span></pre><p id="910b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1 秒钟后，<code class="fe ky kz la lb b">undefined</code>被记录到控制台。<code class="fe ky kz la lb b">setTimeout()</code>执行对<code class="fe ky kz la lb b">logName</code>(其中<code class="fe ky kz la lb b">this</code>是全局对象)的简单调用。这就是方法与对象分离的时候。</p><p id="797c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们手动将<code class="fe ky kz la lb b">this</code>值绑定到正确的上下文:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="bb9b" class="lk ll in lb b gy lm ln l lo lp">setTimeout(batman.logName.bind(batman), 1000);<br/>// after 1 second logs "Batman"</span></pre><p id="803e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">batman.logName.bind(batman)</code>将<code class="fe ky kz la lb b">this</code>值绑定到<code class="fe ky kz la lb b">batman</code>实例。现在你确定这个方法没有丢失上下文。</p><p id="f866" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">手动绑定<code class="fe ky kz la lb b">this</code>需要样板代码，尤其是当你有很多方法的时候。有一种更好的方法:箭头充当类字段。</p><h2 id="b554" class="lk ll in bd ls ne nf dn lw ng nh dp ma kl ni nj me kp nk nl mi kt nm nn mm no bi translated">箭头功能</h2><p id="bffe" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">多亏了<a class="ae jz" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">类字段提议</a>(此时在阶段 3)你可以在类中使用箭头函数作为方法。</p><p id="3c7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，与常规函数相比，使用箭头定义的方法将<code class="fe ky kz la lb b">this</code>在词汇上绑定到类实例。</p><p id="6489" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将箭头函数用作字段:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="1b77" class="lk ll in lb b gy lm ln l lo lp">class Hero {<br/>    constructor(heroName) {<br/>        this.heroName = heroName;<br/>    }</span><span id="94f1" class="lk ll in lb b gy lq ln l lo lp">    logName = () =&gt; {<br/>        console.log(this.heroName);<br/>    }<br/>}</span><span id="87a0" class="lk ll in lb b gy lq ln l lo lp">const batman = new Hero('Batman');</span></pre><p id="0965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在您可以使用<code class="fe ky kz la lb b">batman.logName</code>作为回调，而无需手动绑定<code class="fe ky kz la lb b">this</code>。<code class="fe ky kz la lb b">logName()</code>方法中<code class="fe ky kz la lb b">this</code>的值总是类实例:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="fe41" class="lk ll in lb b gy lm ln l lo lp">setTimeout(batman.logName, 1000);<br/>// after 1 second logs "Batman"</span></pre><h1 id="937f" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">摘要</h1><p id="10b4" class="pw-post-body-paragraph ka kb in kc b kd mq kf kg kh mr kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ig bi translated">理解常规函数和箭头函数之间的差异有助于为特定需求选择正确的语法。</p><p id="a18e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>常规函数中的值是动态的，取决于调用。但是箭头函数内部的<code class="fe ky kz la lb b">this</code>是词汇绑定的，等于外部函数的<code class="fe ky kz la lb b">this</code>。</p><p id="19f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">arguments</code>常规函数内的对象包含参数列表。相反，arrow 函数没有定义<code class="fe ky kz la lb b">arguments</code>(但是您可以使用 rest 参数<code class="fe ky kz la lb b">...args</code>轻松访问 arrow 函数参数)。</p><p id="cebe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果 arrow 函数有一个表达式，那么即使不使用<code class="fe ky kz la lb b">return</code>关键字，表达式也会被隐式返回。</p><p id="72d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后但同样重要的是，您可以在类内部使用 arrow 函数语法来定义方法。粗箭头方法将<code class="fe ky kz la lb b">this</code>值绑定到类实例。</p><p id="4f75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论如何，粗箭头方法被调用，<code class="fe ky kz la lb b">this</code>总是等于类实例，这在方法被用作回调时很有用。</p><p id="95f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了理解 JavaScript 中所有类型的函数，我推荐查看 6 种声明 JavaScript 函数的方法。</p><p id="a197" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">想要连接？<br/> </strong>本文由马来西亚<a class="ae jz" href="https://arkmind.com.my" rel="noopener ugc nofollow" target="_blank"> Arkmind </a>技术负责人韩胜撰写。他对软件设计/架构相关的东西、计算机视觉以及边缘设备充满热情。他开发了几个基于人工智能的网络/移动应用程序来帮助客户解决现实世界的问题。请随意通过他的<a class="ae jz" href="https://github.com/hansheng0512" rel="noopener ugc nofollow" target="_blank"> Github 个人资料</a>来了解他。</p></div></div>    
</body>
</html>