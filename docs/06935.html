<html>
<head>
<title>Rust and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 和 OpenCV</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rust-and-opencv-bb0467bf35ff?source=collection_archive---------0-----------------------#2022-02-13">https://blog.devgenius.io/rust-and-opencv-bb0467bf35ff?source=collection_archive---------0-----------------------#2022-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="968e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们都知道为什么铁锈如此重要。然而，与 C/C++等老牌巨头相比，它有点太新太耀眼了，我们经常需要在没有适当文档的情况下使用 C++绑定(不过，我非常高兴它们的存在，谢谢社区！).</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="b271" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">背景</h1><p id="4083" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">现在，让我们首先回答这个问题，为什么我们会关心在 Rust 中运行 OpenCV？为什么不用 C++、Java 或 Python 呢？</p><p id="05ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++是相当老的冠军，与 Rust 或 Go 相比，编译 C++代码并不有趣。对于伴随 Python 长大的年轻一代来说，用 C++安装包似乎相当过时。呀，没错。谁想花时间安装软件包？尤其是在好的厉害的那么多的今天。而且 Rust 的包经理货也很厉害。</p><p id="d8d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Python 中使用 OpenCV 很容易。易于安装，易于在大型社区中使用。如果你真的想把事情做好，Python 是最好的选择。尽管 Python 语言非常慢，但是很少的 Python 代码是真正的 Python 代码(正如我们大多数人所知道的)。最后一句话可能会激起你的一点愤怒。可怜的美国人，他们不得不离开 Python 的快乐之路，去编写痛苦缓慢的代码，或者绑定到其他语言，让其他人免受痛苦。</p><blockquote class="ls lt lu"><p id="3d71" class="jk jl lv jm b jn jo jp jq jr js jt ju lw jw jx jy lx ka kb kc ly ke kf kg kh ig bi translated">如果你只是想做一些需要 for 循环的额外功能呢？或者，如果您想并行运行，该怎么办？Python 可以做到，只是不太好。—我</p></blockquote><h1 id="9f07" class="kp kq in bd kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm bi translated">Rust OpenCV</h1><h2 id="f6bb" class="me kq in bd kr mf mg dn kv mh mi dp kz jv mj mk ld jz ml mm lh kd mn mo ll mp bi translated">入门—安装(MacOS)</h2><p id="64e9" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated"><em class="lv"> Linux 用户通常足够聪明，知道如何在他们的机器上安装 OpenCV，</em> <a class="ae mq" href="https://github.com/twistedfall/opencv-rust" rel="noopener ugc nofollow" target="_blank"> <em class="lv">否则请遵循此处的指南</em> </a> <em class="lv">和</em> <a class="ae mq" href="https://github.com/twistedfall/opencv-rust" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Windows 用户可能会遵循此指南</em> </a> <em class="lv">。对于 Mac 用户，你可以按照下面的超级短教程。</em></p><p id="c892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从安装 OpenCV 开始。不幸的是，OpenCV 不是另一个生锈的包。它要求在你的计算机上安装 OpenCV (C++)。然而，在 Rust 中，不需要痛苦的链接和编写 CMake 文件。Rust 中的 OpenCV 实际上比 C++更容易(IMHO ),并且当您想要引入许多依赖项时不会让您感到头痛(对于大量的 CMake 文件而言，这是个大问题)。</p><p id="7b77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 macOS 上安装它非常容易。假设您有 brew，只需运行</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9093" class="me kq in mw b gy na nb l nc nd">brew install opencv</span></pre><p id="a27a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在你的货物里加上</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d73a" class="me kq in mw b gy na nb l nc nd">[dependencies]<br/>opencv = "0.63.0" # or whatever version is the latest</span></pre><p id="cf58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以按照<a class="ae mq" href="https://github.com/twistedfall/opencv-rust" rel="noopener ugc nofollow" target="_blank"> opencv-rust repo 获得完整的安装帮助。</a>当我安装它的时候，我遇到了一个编译问题，但是按照<strong class="jm io">故障排除</strong>部分可以很容易地修复。所以如果你遇到问题，一定要在拉头发之前检查一下那个部分。</p><p id="8b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个 OpenCV Rust 绑定绑定到了 C++ API(这很好，因为 C++已经被抛弃了)。由于 Rust 可以直接与 C 接口，C++被包裹在一个额外的 C 层中，然后暴露于 Rust。</p><h2 id="e625" class="me kq in bd kr mf mg dn kv mh mi dp kz jv mj mk ld jz ml mm lh kd mn mo ll mp bi translated">简码</h2><p id="265f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我的第一个例子是基于<a class="ae mq" href="https://www.youtube.com/channel/UC-QQTgv-P_9_8tW1m7GSUTQ" rel="noopener ugc nofollow" target="_blank"> Makeitnow </a>的<a class="ae mq" href="https://www.youtube.com/watch?v=zcfixnuJFXg" rel="noopener ugc nofollow" target="_blank">视频教程</a>。对于一个有经验的 OpenCV 用户来说，这非常简单。</p><p id="4f8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之我喜欢使用<a class="ae mq" href="https://docs.rs/anyhow/latest/anyhow/" rel="noopener ugc nofollow" target="_blank">来处理结果，所以我将使用它来代替 opencv::Result。让我们写代码吧！</a></p><figure class="mr ms mt mu gt ne"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1c10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！我们可以打开一个网络摄像头，将结果帧放入 frame 变量中。代码应该是不言自明的。不然看视频！</p><p id="3141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">PS。这将是等效的 Python 代码</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="99b7" class="me kq in mw b gy na nb l nc nd">import cv2</span><span id="e67d" class="me kq in mw b gy nh nb l nc nd">vid = cv2.VideoCapture(0)<br/>while True:<br/>    ret, frame = vid.read()<br/>    cv2.imshow('window', frame)<br/>    if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>        break</span><span id="2883" class="me kq in mw b gy nh nb l nc nd">vid.release()<br/>cv2.destroyAllWindows()</span></pre><h1 id="14d2" class="kp kq in bd kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm bi translated">使用 OpenCV-Rust 绑定变得越来越热</h1><p id="be42" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">让我们做……</p><ul class=""><li id="30d1" class="ni nj in jm b jn jo jr js jv nk jz nl kd nm kh nn no np nq bi translated">从文件中读取图像</li><li id="ddf1" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">使用 SIFT 和 ORB 检测关键点</li><li id="0f87" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">用不同的颜色画关键点</li><li id="0d7b" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">画一个长方形</li><li id="79c7" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">将图像转换为 n 数组(快速)</li><li id="a8e8" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">将 ndarray 转换为 image::rgbi image(为了测试我们的上述步骤是否按预期工作)</li><li id="dbbd" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">保存图像</li></ul><p id="7d4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我将首先把代码作为一个块，然后一步一步地分解它。</p><figure class="mr ms mt mu gt ne"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="76bc" class="me kq in bd kr mf mg dn kv mh mi dp kz jv mj mk ld jz ml mm lh kd mn mo ll mp bi translated">阅读图像</h2><p id="4d78" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">你不明白如何找到不同的类型？检查下面的矩形部分！它是一个更全面的指南！</p><p id="9982" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阅读图像非常简单。您可能希望在所有这些选项上添加一个检查，以确保映像加载成功。如果找不到图像，OpenCV 不会抛出错误。不要被 Rust 的结果所迷惑，它不会检查图像是否被正确加载。</p><p id="a174" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">锈</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c911" class="me kq in mw b gy na nb l nc nd">// Read image<br/>let img = opencv::imgcodecs::imread("./assets/demo_img.png", cv::imgcodecs::IMREAD_COLOR)?;</span></pre><p id="0086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a10f" class="me kq in mw b gy na nb l nc nd">cv::Mat I = cv::imread("./assets/demo_img.png", 0);</span></pre><p id="415f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">计算机编程语言</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ccc5" class="me kq in mw b gy na nb l nc nd">img: np.ndarray = cv2.imread("./assets/demo_img.png)</span></pre></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h2 id="8a19" class="me kq in bd kr mf mg dn kv mh mi dp kz jv mj mk ld jz ml mm lh kd mn mo ll mp bi translated">关键点检测和绘制</h2><p id="a25f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">ORB 和 SIFT 代码非常相似，所以我只对 ORB 部分进行评论。</p><p id="3e8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以首先创建<strong class="jm io">检测器</strong></p><p id="d9f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">锈</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="35e2" class="me kq in mw b gy na nb l nc nd">let mut orb = &lt;dyn cv::features2d::ORB&gt;::create(<br/>        500,<br/>        1.2,<br/>        8,<br/>        31,<br/>        0,<br/>        2,<br/>        cv::features2d::ORB_ScoreType::HARRIS_SCORE,<br/>        31,<br/>        20,<br/>    )?;</span></pre><p id="7591" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e1ab" class="me kq in mw b gy na nb l nc nd">cv::Ptr&lt;cv::ORB&gt; orbPtr = cv::ORB::create();</span></pre><p id="61ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这与 C++非常相似。需要提供稍微不同的名称空间和参数。<em class="lv">注意，所有的默认变量都可以在 Rust 的文档中找到。只需将鼠标悬停在“创建”功能上，您就会看到文档[VSCode]。</em></p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/124bc0f9e13ca91ab88b1aec9eea51c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E811pWD9lmijiAuFKRDfrg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">在 VSCode 中可以看到 C++默认参数。如果使用另一个 IDE，您可能只需转到函数定义并读取 docstring。</figcaption></figure><p id="dbcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">计算关键点</strong></p><p id="8cce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次 Rust vs C++。</p><p id="ed8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">锈</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c85c" class="me kq in mw b gy na nb l nc nd">let mut orb_keypoints = cv::core::Vector::default();<br/>let mut orb_desc = cv::core::Mat::default();<br/>orb.detect_and_compute(&amp;img, &amp;mask, &amp;mut orb_keypoints, &amp;mut orb_desc, false)?;</span></pre><p id="290d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5969" class="me kq in mw b gy na nb l nc nd">std::vector&lt;cv::KeyPoint&gt; keypoints;<br/>orbPtr-&gt;detect(image, keypoints);<br/>cv::Mat desc;<br/>orbPtr-&gt;compute( image, keypoints, desc );</span></pre><p id="2464" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，没有什么太疯狂的差异。首先，可能很难知道如何初始化关键点和描述符。但是一旦看到，就很简单了。从上面的代码来看，不能说 Rust 代码比 C++更复杂。</p><p id="b7df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">画出</strong><strong class="jm io"/><strong class="jm io">关键点</strong></p><p id="ffb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">锈</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1204" class="me kq in mw b gy na nb l nc nd">let mut dst_img = cv::core::Mat::default();<br/>cv::features2d::draw_keypoints(<br/>        &amp;img,<br/>        &amp;orb_keypoints,<br/>        &amp;mut dst_img,<br/>        cv::core::VecN([0., 255., 0., 255.]),<br/>        cv::features2d::DrawMatchesFlags::DEFAULT,<br/> )?;</span></pre><p id="39ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c89f" class="me kq in mw b gy na nb l nc nd">cv::Mat dst_img;<br/>cv::drawKeypoints(image, keypoints, dst_img);</span></pre><p id="748c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">弄清楚铁锈的种类有点棘手。使用类型推理和一点点直觉是有可能找到它的！</p><h2 id="da89" class="me kq in bd kr mf mg dn kv mh mi dp kz jv mj mk ld jz ml mm lh kd mn mo ll mp bi translated">侦查工作—绘制矩形(更具指导性的步骤)</h2><p id="28c7" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">由于 OpenCV Rust 绑定几乎没有文档，这是一种侦探游戏。我决定展示 C++代码是有原因的。我们可以看到的是，大部分 Rust 代码都可以从 C++中推断出来(某种程度上)。利用今天难以置信的 IDE，我们有机会(感谢 LSP)。此外，Rust 有一个很好对接系统。我的策略是依靠<a class="ae mq" href="https://docs.rs/opencv/latest/opencv/index.html" rel="noopener ugc nofollow" target="_blank"> opencv-rust docs </a>和来自 C++的命名。所以让我们用这个策略来弄清楚如何画矩形。</p><p id="22fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们决定我们想做什么，即:</p><ul class=""><li id="6b79" class="ni nj in jm b jn jo jr js jv nk jz nl kd nm kh nn no np nq bi translated">绘制矩形(在 C++中是<code class="fe oh oi oj mw b">cv::rectangle</code>)</li></ul><p id="0a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们前往<a class="ae mq" href="https://docs.rs/opencv/latest/opencv/index.html" rel="noopener ugc nofollow" target="_blank"> opencv-rust docs </a>。</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ok"><img src="../Images/b16a5de39f512bed4fd483b7a7763c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_Gl4mNLYQxaE37DRfAoIA.png"/></div></div></figure><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ok"><img src="../Images/57328bf527fe51492b986992999220da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEBsjTulIguyuMh0-BnKjg.png"/></div></div></figure><p id="4cc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们要做的就是找出类型(说起来容易做起来难)。这里我们将利用 IDE(在我的例子中是 VSCode)。使用 LSP，Nvim 或 Emacs 应该也可以。第一个论点应该很明显，图像。那就是 cv::core::Mat。很明显对吗？(不尽然)。但是，我们可以通过直觉来弄清楚。Mat 是存储图像数据的默认类型，所以应该是 Mat。Mat 实现了输出数组的特性，一切都很好。接下来，什么是 Rect 类型？</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ok"><img src="../Images/9a3446c37f2b49aff03014811e520c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA3rT4bnSQewugdsnSoMFA.png"/></div></div></figure><p id="8fb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">似乎我们可以在核心找到它。那很好。但是，我如何建立一个矩形呢？</p><p id="2683" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 LSP，我们可以为合适的构造函数找到自动补全。这里，再一次，快速找到它需要一点直觉和运气(尽管 C++代码补全远没有 Rust 那么容易)。如果你被困在 C++中，在网上寻找解决方案通常也是不愉快的。</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ol"><img src="../Images/65dc7042aa4478af2531bc4003ed28a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umyg04WOlBvjROwuXhd9-Q.png"/></div></div></figure><p id="c6b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好，让我们看看 from_points 构造函数要说什么</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi om"><img src="../Images/e15c220b218049256643383ab361049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnmG9gK4E-teVJdyo4h9Cw.png"/></div></div></figure><p id="5351" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要两分！…但这有什么意义呢？🥁</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi on"><img src="../Images/2640af09b3104c6ba67a8b19edccff76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbaCLeBVNGmhIKgz86Ldcg.png"/></div></div></figure><p id="aec1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在核心似乎是！让 LSP 为我们做更多的提升！</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/338327a6f724daf7584ef1ece7760a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*woXvX0kFo33DQvpy_K9YNw.png"/></div></figure><p id="3b90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，“new”看起来很有前途，但“from_vec2”也是！嗯……我们也许可以用其中任何一个。但我们还是选“新”吧。(通常，查找 new 或 from)。</p><figure class="mr ms mt mu gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi op"><img src="../Images/19f303a3d5232924b5130bba17a2a109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIWlm01zNg4Cs7K6dt7qRw.png"/></div></div></figure><p id="071e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，我们就给它输入两个整数，看看会发生什么(编译器应该不会抱怨)！所以现在我们已经搞清楚了第二个论点！</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d88a" class="me kq in mw b gy na nb l nc nd">cv::core::Rect::from_points(<br/>  cv::core::Point::new(0, 0),<br/>  cv::core::Point::new(50, 50<br/>)</span></pre><p id="38f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(剩下的也是同样的方法…)。这有点乏味，但是一旦你开始了解类型，生活就变得容易了。在那个阶段，感觉很自然，你不会介意用 Rust 而不是 C++工作。</p><h1 id="240d" class="kp kq in bd kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm bi translated">敬恩达雷！</h1><p id="f6c9" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">ndarray 似乎是 Rust 上适应性最强的矩阵库(对于想为 Python 的 NumPy 包编写绑定的年轻人来说，ndarray 是一个不错的选择)。后面还有一篇关于用 Python 和 NumPy 绑定 Rust 的文章！</p><p id="8082" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就有点棘手了。现在我们需要将一个 C++类型转换成 Rust 类型。我们知道我们正在处理一个矩阵类型。并且一般实现为<a class="ae mq" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" rel="noopener ugc nofollow" target="_blank">行主</a>。OpenCV Mat 和 ndarray 数组(视图)都是行主数组。并且数据按顺序(通常)存储在底层缓冲区中。为了确保我们的情况下，我们将检查垫是连续的。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6dfe" class="me kq in mw b gy na nb l nc nd">if !mat.is_continuous() {<br/>    return Err(anyhow!("Mat is not continuous :("));<br/>}</span></pre><p id="a728" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用这些知识快速(无复制，零成本)将 cv::Mat 转换为 ndarray::Array。但是，必须注意的是，数组将指向存储在 Mat 中的数据。因此，当 Mat 掉落时，阵列也必须掉落。否则我们(可能)会指向已分配的内存，这样不好！但似乎锈为我们处理这个！</p><p id="3c4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将提取 Mat 的数据字节。由于图像是以 8 位(u8)的无符号格式存储的，我们可以直接读取数据而不需要类型转换(是的！).</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a845" class="me kq in mw b gy na nb l nc nd">let data_bytes: &amp;[u8] = mat.data_bytes()?; // &lt;-- This is the image data in sequence! Note it is pointing to the data in mat</span></pre><p id="b768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们需要计算出这些数据的大小。当我们获取数据字节时，我们不是以我们想要的形状获取它们，而是以一个长序列获取它们。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ac9e" class="me kq in mw b gy na nb l nc nd">let size = mat.size()?;<br/>let h:i32 = size.height;<br/>let w:i32 = size.width;</span></pre><p id="fec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以根据这些信息构建一个数组视图 3 <u8/></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f11a" class="me kq in mw b gy na nb l nc nd">let a = ArrayView3::from_shape((h as usize, w as usize, 3), data_bytes)?; // The 3 is because we have bgr. For gray image this will be 1</span></pre><p id="3344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不错！我们得到了一个将 Mat 转换为 ArrayView3 <u8>的方法，具有性能。<strong class="jm io">注意，这只对连续数组有效。</strong></u8></p><p id="ac34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个特征，它看起来就像</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5753" class="me kq in mw b gy na nb l nc nd">trait AsArray {<br/>    fn try_as_array(&amp;self) -&gt; Result&lt;ArrayView3&lt;u8&gt;&gt;;<br/>}</span><span id="afff" class="me kq in mw b gy nh nb l nc nd">impl AsArray for cv::core::Mat {<br/>    fn try_as_array(&amp;self) -&gt; Result&lt;ArrayView3&lt;u8&gt;&gt; {<br/>        if !self.is_continuous() {<br/>            return Err(anyhow!("Mat is not continuous"));<br/>        }<br/>        let bytes = self.data_bytes()?;<br/>        let size = self.size()?;<br/>        let a = ArrayView3::from_shape((size.height as usize, size.width as usize, 3), bytes)?;<br/>        Ok(a)<br/>    }<br/>}</span></pre><p id="b995" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了快速将 Mat 转换为 Array，我们现在可以调用:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4c24" class="me kq in mw b gy na nb l nc nd">let array: ArrayView&lt;u8&gt; = mat.try_as_array()?;</span></pre><h1 id="0379" class="kp kq in bd kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm bi translated">结论</h1><p id="d85e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">Rust 中的 OpenCV 肯定是可能的。这需要更深入的知识才能在不同类型和意志力之间转换，以找出绑定。但是很管用！:))</p><p id="26d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于 Rust package manager Cargo 非常好，它鼓励使用其他人的包(如<a class="ae mq" href="https://crates.io/crates/cv-convert" rel="noopener ugc nofollow" target="_blank"> cv-convert </a>用于在许多流行的板条箱之间转换图像类型)使生活变得更容易。我希望在未来我们会看到更多更酷的软件包。一些 Rust GPU 包开始出现，谁知道呢，也许在未来有可能将 Rust 直接编译到 SPIR-V 上进行真正快速的计算！那将是多么美好的未来啊！</p><p id="8f54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你一路来到这里，感谢你花时间阅读，并希望你在途中学到一些东西。</p><p id="8b51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">干杯！</p></div></div>    
</body>
</html>