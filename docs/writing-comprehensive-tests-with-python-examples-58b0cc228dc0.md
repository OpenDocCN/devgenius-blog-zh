# 编写全面的测试(使用 Python 示例)

> 原文：<https://blog.devgenius.io/writing-comprehensive-tests-with-python-examples-58b0cc228dc0?source=collection_archive---------9----------------------->

全面的测试只有 100%的覆盖率是不够的。了解如何在代码中找到未经测试的逻辑，以防止潜在的错误。

当测试代码时，目标是确保无论未来发生什么变化，如果测试通过，我们知道代码的行为完全符合预期。我们的目标应该是用最少的测试次数得到它。

![](img/f62f31e03f1632eb4c1d1340546702cc.png)

大概就是这个意思。我将给出一个例子，以及如何为它找到所需的测试用例。假设我们有这个函数:

```
def divide(a, b):
    """Divide a by b, a and b can be a number or a string, if any of them is a string it will be converted to a number."""
    if type(a) == str:
        a = int(a)
    if type(b) == str:
        b = int(b)
    return a / b
```

# 线覆盖率

对于这个功能，需要多少个测试用例来获得 100%的行覆盖率？我一一列举:

```
assert divide(10, 2) == 5
```

这是最简单的测试。然而，行`a = int(a)`和`b = int(b)`不会被执行，这意味着在某个时候，有人会编辑它们(为了添加新特性或重构)，我们不会自动知道它们是否工作，所以我们需要添加一个测试用例来覆盖这些行:

```
assert divide("10", "2") == 5
```

# 报表覆盖范围

您还应该注意到，有时在一行中有多个语句，所以我们需要确保涵盖所有语句。例如，如果我们有这个函数:

```
def divide(a, b):
   # Note: you might say that we can just do `a = int(a)` but that’s not the point here, convert this example to anything you want
   a = int(a) if type(a) == str else a
   b = int(b) if type(b) == str else b
   return a / b
```

如果我们只有这个测试:

```
assert divide(10, 2) == 5
```

然后将执行所有的行，但不是所有的语句，所以请记住这一点。

# 分支覆盖率(或决策覆盖率)

您通常不需要 100%的分支覆盖率，但是您需要记住这一点，并决定添加一个将覆盖额外分支的测试是否会增加价值。例如，假设我们有这个函数:

```
def divide(a, b):
    if type(a) == str:
        # Note: you might say that we shouldn’t do it this way, however this is just an example, sometimes you have this situation in your code and you can’t avoid it
        a = int(a)
        b = int(b)
    return a / b
```

在这个函数中，我们有之前的两个测试:

```
assert divide(10, 2) == 5assert divide("10", "2") == 5
```

我们将拥有 100%的行和 100%的语句覆盖率，并且这两个测试都将通过。但是，有一个输入会破坏代码，我们没有对它进行测试，那就是:

```
assert divide(10, "2") == 5
```

你需要做的是阅读代码，思考代码中有多少分支，测试更多的分支是否有意义。

# 最大的问题

回到最初的例子:

```
def divide(a, b):
    if type(a) == str:
        a = int(a)
    if type(b) == str:
        b = int(b)
    return a / b
```

如果我们有这些测试:

```
assert divide(10, 2) == 5assert divide("10", "2") == 5
```

我们现在的情况是:

*   我们有 100%的线路覆盖率
*   我们有 100%的报表覆盖率
*   测试更多的分支不会增加任何价值

就这些吗？可惜没有。

我们需要问自己一个最大的问题:**有人能在不导致测试失败的情况下修改我们的代码并破坏我们预期的行为吗？**

如果答案是肯定的，我们必须添加一个测试来验证这个行为是否如预期的那样工作，从而得出否定的答案。

如果我们仔细观察，可以发现我们没有一个结果是浮点数的测试，这意味着如果有人编辑代码并将`/`更改为`//`，行为将中断，测试将通过，因此我们需要添加这个测试:

```
assert divide(10, 4) == 2.5
```

# 更多地方发现未经测试的行为

我们需要注意我们使用但没有测试的代码(即，没有包含在这个功能的测试范围内)。我们需要确保只发送一个有效的输入，并处理每一个可能的输出。在本例中，有两个这样的例子:

1.  `int()`功能
2.  当我们在 python 中做`/`时，将两个数相除的函数

我们不需要知道这些函数的内部实现，因为我们不会测试它们。我们只想测试我们对它的使用，我们可以通过问自己这些问题来验证这一点:

1.  我们是否测试我们只提供允许的输入？
2.  我们是否测试了每一种允许的输入？
3.  我们是否测试我们处理了所有可能的输出？

现在让我们看看第一个函数`int()`，问我们自己三个问题:

1.  我们是否测试我们只提供允许的输入？

在我们的代码中，我们只向`int()`发送字符串，所以类型是正确的，但是函数只接受表示数字的字符串，但是我们向它发送任何字符串。我们应该问问自己，将非数字字符串传递给函数是否应该被视为一个错误。如果它是一个 bug，那么我们可以让它保持原样，不进行测试，但是如果我们认为它是糟糕的用户输入，那么我们需要:

*   用我们的代码处理它。
*   记录行为。
*   为它添加一个测试。

2.我们是否测试了每一种允许的输入？

包含浮点数的字符串呢？目前，我们的函数将引发一个异常，而我们的测试没有捕捉到这个异常，所以我们需要编辑我们的代码来使用`float()`函数而不是`int()`函数，这样函数将会是:

```
def divide(a, b):
    if type(a) == str:
        a = float(a)
    if type(b) == str:
        b = float(b)
    return a / b
```

我们需要增加这个测试:

```
assert divide("10.5", "2") == 5.25
```

3.我们是否测试我们处理了所有可能的输出？

在我们的例子中，这个函数总是返回相同的输出类型，所以没什么好担心的，但是我们需要检查一下。

关于函数`/`，你也应该问自己同样的三个问题。

# 如果我们错过了一个边缘案例呢？

如果我们在测试中错过了一个边缘案例，我们将不会知道，直到有人更改了代码并破坏了它，然后当我们部署这个被破坏的更改时，无论何时我们的一个用户得到一个错误，我们都应该得到一个警告，然后我们将修复这个错误。

然而，我们必须总是为我们发现的错误添加一个测试，这样随着时间的推移，我们将覆盖我们以前遇到的任何边缘情况。否则，我们将会陷入这样一种境地:我们有太多未经测试的边缘案例，并且随时都可能崩溃。

如果你想谈论我在这里写的任何东西，请随时联系，我们可以讨论更多。