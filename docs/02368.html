<html>
<head>
<title>React Tips — Query Params, Inputs, Multiple Routes, Hooks vs Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 提示—查询参数、输入、多路径、挂钩与生命周期方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-query-params-inputs-multiple-routes-hooks-vs-lifecycle-methods-9f61cd581a6d?source=collection_archive---------2-----------------------#2020-07-31">https://blog.devgenius.io/react-tips-query-params-inputs-multiple-routes-hooks-vs-lifecycle-methods-9f61cd581a6d?source=collection_archive---------2-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eff4afbd6702801517ebbb694bf8f5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVqgE_u9B2Oa0hJv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰克·卡塔拉诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2b4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React 是一个用于创建 web 应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的 React 应用程序的技巧。</p><h1 id="3ffc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">以编程方式更新 React 路由器中的查询参数</h1><p id="1b6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过调用<code class="fe me mf mg mh b">history.push</code>用 React Router 更新查询参数。</p><p id="ba5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用一个对象来调用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dab0" class="mq lc iq mh b gy mr ms l mt mu">history.push({<br/>  pathname: '/cars',<br/>  search: '?color=green'<br/>})</span></pre><p id="546b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c49f" class="mq lc iq mh b gy mr ms l mt mu">history.push('/car?color=green')</span></pre><h1 id="edcb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">contentEditable 的更改事件</h1><p id="c5a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不是通过监听 change 事件来监听<code class="fe me mf mg mh b">contentEditable</code>元素中的内容变化，而是监听输入事件。</p><p id="fbb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8663" class="mq lc iq mh b gy mr ms l mt mu">&lt;div<br/>  contentEditable<br/>  onInput={e =&gt; console.log(e.currentTarget.textContent)}<br/>&gt;<br/>  foo bar<br/>&lt;/div&gt;</span></pre><p id="ff40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向<code class="fe me mf mg mh b">onInput</code>道具传递一个事件处理程序。</p><p id="7228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">e.currentTarget.textContent</code>得到内容的值。</p><h1 id="7fcd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ReactJS 函数组件内的生命周期方法</h1><p id="cfee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们用功能组件中的钩子代替生命周期方法。</p><p id="b711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useEffect</code>相当于生命周期挂钩。</p><p id="55f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">useState</code>相当于<code class="fe me mf mg mh b">setState</code>。</p><p id="2c79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1fac" class="mq lc iq mh b gy mr ms l mt mu">const Grid = (props) =&gt; {<br/>  const [data, setData] = useState();<br/>  <br/>  const getData = () =&gt; {<br/>    const data = await fetchData();<br/>    setData(data);<br/>  }</span><span id="c6c3" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    getData();<br/>  }, []);</span><span id="322a" class="mq lc iq mh b gy mv ms l mt mu">  return(<br/>    &lt;div&gt;<br/>      {data.map(d =&gt; &lt;Row data={data} /&gt;)}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="155f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">useState</code>钩子，它返回带有最新状态值的数组和设置状态的函数。</p><p id="bb5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有了<code class="fe me mf mg mh b">useEffect</code>钩子，它让我们产生副作用。</p><p id="f3c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是需要注意的值。</p><p id="537f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是空的，那么<code class="fe me mf mg mh b">useEffect</code>中的回调只在组件被挂载时运行。</p><p id="d82c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在一个组件中有多个<code class="fe me mf mg mh b">useEffect</code>钩子，不像类组件的生命周期方法。</p><p id="2c5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们在返回的 JSX 表达式中呈现项目。</p><p id="b706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe me mf mg mh b">componentWillUnmount</code>等价的是我们在<code class="fe me mf mg mh b">useEffect</code>回调中返回的函数。</p><p id="02c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e2e2" class="mq lc iq mh b gy mr ms l mt mu">useEffect(() =&gt; {<br/>  window.addEventListener('click', handler);<br/>  return () =&gt; {<br/>    window.removeEventListener('click', handler);<br/>  }<br/>}, [])</span></pre><p id="272b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用任何代码来清除我们在<code class="fe me mf mg mh b">useEffect</code>回调中返回的函数中的资源。</p><p id="96c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">componentDidUpdate</code>的等效操作是将值传递给<code class="fe me mf mg mh b">useEffect</code>的第二个参数中的数组。</p><p id="3e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想观察<code class="fe me mf mg mh b">foo</code>状态和<code class="fe me mf mg mh b">bar</code>属性的值的变化，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6904" class="mq lc iq mh b gy mr ms l mt mu">useEffect(() =&gt; {<br/>  //...<br/>}, [foo, props.bar])</span></pre><p id="db6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是把它们传入数组，然后我们总是得到最新的值。</p><h1 id="ecda" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无法在 React 输入文本字段中键入内容</h1><p id="91c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们希望能够在输入文本字段中键入内容，那么我们必须使它成为一个受控的输入。</p><p id="a90b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们用事件处理程序中最新输入的值来设置状态的值。</p><p id="c364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将它传递给<code class="fe me mf mg mh b">onChange</code> prop。</p><p id="9607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">value</code>属性设置为该状态的值。</p><p id="ec5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2348" class="mq lc iq mh b gy mr ms l mt mu">&lt;input<br/>  type="text"<br/>  value={this.props.value}<br/>  onChange={this.handleChange}<br/>/&gt;</span></pre><p id="4953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点。</p><p id="154a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的例子，我们可以写成:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cbe2" class="mq lc iq mh b gy mr ms l mt mu">class Form extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {value: ''};</span><span id="356b" class="mq lc iq mh b gy mv ms l mt mu">    this.handleChange = this.handleChange.bind(this);<br/>    this.handleSubmit = this.handleSubmit.bind(this);<br/>  }</span><span id="9902" class="mq lc iq mh b gy mv ms l mt mu">  handleChange(event) {<br/>    this.setState({ value: event.target.value });<br/>  }</span><span id="399a" class="mq lc iq mh b gy mv ms l mt mu">  handleSubmit(event) {<br/>    alert(this.state.value);<br/>    event.preventDefault();<br/>  }</span><span id="cce7" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;form onSubmit={this.handleSubmit}&gt;<br/>        &lt;label&gt;<br/>          &lt;input type="text" value={this.state.value} onChange={this.handleChange} /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="c4bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">handleChange</code>方法设置输入的最新值，该值作为<code class="fe me mf mg mh b">value</code>状态的值存储在<code class="fe me mf mg mh b">event.target.value</code>中。</p><p id="be4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们单击 Submit 时，我们可以在<code class="fe me mf mg mh b">handleSubmit</code>方法中得到它。</p><h1 id="1c29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React 路由器中同一组件的多个路径名</h1><p id="dbfc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过向<code class="fe me mf mg mh b">path</code>属性传递一个包含所有路径名的数组来分配多个路径重定向到同一个路径。</p><p id="80a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1151" class="mq lc iq mh b gy mr ms l mt mu">&lt;Router&gt;<br/>  &lt;Route path={["/home", "/user", "/profile"]} component={Home} /&gt;<br/>&lt;/Router&gt;</span></pre><p id="9f27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需将它们传递到<code class="fe me mf mg mh b">Router</code>组件的<code class="fe me mf mg mh b">path</code> prop 中，它们就会全部匹配。</p><p id="640d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组中的每个 pat 都是一个正则表达式字符串。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8e415a14242f44c03849bd25fea7408a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ddi7BboFrORZ6Ufu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@dawnhylon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">黎明</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8424" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="78b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可以指定多个路径名来访问同一个组件。</p><p id="b39c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">history.push</code>来更新查询参数。</p><p id="d4ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在功能组件的类组件中有组件生命周期方法的等价物。</p><p id="aa41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们键入一个输入，我们必须用最近输入的值来设置状态，并将其设置为值。</p></div></div>    
</body>
</html>