<html>
<head>
<title>Binary Search Tree Traversal (in-order, pre-order and post-order) in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的二叉查找树遍历(按序、前序和后序)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/binary-search-tree-traversal-in-order-pre-order-and-post-order-in-go-8bec81a7abd6?source=collection_archive---------5-----------------------#2021-01-04">https://blog.devgenius.io/binary-search-tree-traversal-in-order-pre-order-and-post-order-in-go-8bec81a7abd6?source=collection_archive---------5-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9acd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉树是一种数据结构，其中每个节点最多有两个子节点。下面是一个样本二叉树。最顶层的节点是根节点。</p><p id="1cd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">底部所有没有附加任何子节点的节点称为叶节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/191a9a9d91be37d2d4da5f7dc35d3d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*4Q63RnQpiS1vsv50cigMAA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">简单的二叉树</figcaption></figure><p id="222f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一棵二叉树的高度为<em class="ku"> h </em>，那么可以有最多<em class="ku">个 2⁽ ʰ⁺ ⁾-1 </em>个节点。设<em class="ku"> n </em>为节点数。然后:<br/>=&gt;<em class="ku">n =2⁽ʰ⁺⁾-1</em><br/>=&gt;<em class="ku">n+1 =2⁽ʰ⁺⁾</em><br/>=&gt;<em class="ku">log₂(n+1)=log₂(2⁽ʰ⁺⁾)</em><br/>=&gt;<em class="ku">log₂(n+1)</em>=<em class="ku">(h+1)log₂2</em><br/>=&gt;<em class="ku">log₂(n+1)-1</em>= h 或<em class="ku">h = log₂(n+1)-1<em class="ku"/></em></p><p id="1693" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根节点位于第 0 层。在每个级别上可以有最大的<em class="ku"> 2ˡ </em>节点，其中<em class="ku"> l </em>是级别。</p><p id="8897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数学够了！现在让我解释一下二叉查找树。二叉查找树是一种特殊的数据结构，左侧子节点中的数据小于其父节点，右侧子节点中的数据大于其父节点。下面是一个二叉查找树的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/2c270273a2cff7cf4fe7a7e7c388eedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*ZgCIxASZaME77byHjpabeA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">这是一个简单的二叉查找树</figcaption></figure><p id="b8a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Go 中，我们可以这样定义节点:</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="cfd8" class="lb lc in kx b gy ld le l lf lg">type Node struct{<br/> Data int<br/> Left *Node<br/> Right *Node<br/>}</span></pre><p id="d00f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所知,<em class="ku"> struct </em>是一种聚合数据类型，它在一个保护伞下包含任何数据类型的值。这些值被称为<em class="ku">字段</em>。<br/>在我们的例子中，有三个字段属于<code class="fe lh li lj kx b">Node</code>结构，即<code class="fe lh li lj kx b">Data</code>用于保存整数数据，<code class="fe lh li lj kx b">Left</code>指向左子节点，<code class="fe lh li lj kx b">Right</code>指向右子节点。</p><p id="058f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的二叉查找树结构看起来更简单。大概是这样的:</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="2364" class="lb lc in kx b gy ld le l lf lg">type BinSearchTree struct{<br/> root *Node<br/>}</span></pre><p id="9fc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lh li lj kx b">root</code>节点指向二叉查找树的第一个节点或<em class="ku">根</em>节点。让我们来看看插入逻辑。</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="3b10" class="lb lc in kx b gy ld le l lf lg">func (t *BinSearchTree) Insert(data int){<br/>  newNode := Node{data, nil, nil}</span><span id="7086" class="lb lc in kx b gy lk le l lf lg">  if t.root == nil {<br/>    t.root = &amp;newNode<br/>    return<br/>  }</span><span id="0dd4" class="lb lc in kx b gy lk le l lf lg">  iter, prev := t.root, t.root</span><span id="53f6" class="lb lc in kx b gy lk le l lf lg">  for iter != nil {<br/>    prev = iter<br/>    if data &lt; iter.Data {<br/>      iter = iter.Left<br/>    } else {<br/>      iter = iter.Right<br/>    }<br/>  }</span><span id="2a6f" class="lb lc in kx b gy lk le l lf lg">  if data &lt; prev.Data {<br/>    prev.Left = &amp;newNode<br/>  } else {<br/>    prev.Right = &amp;newNode<br/>  }<br/>}</span></pre><p id="d4cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一行<code class="fe lh li lj kx b">func (t *BinSearchTree) Insert(data int)</code>告诉我们函数<code class="fe lh li lj kx b">Insert</code>与<code class="fe lh li lj kx b">struct BinSearchTree</code>相关联。就 Go 而言，我们称这些函数为<em class="ku">方法</em>。<code class="fe lh li lj kx b">(t *BinSearchTree)</code>是一个<em class="ku">接收器</em>，它告诉我们<code class="fe lh li lj kx b">Insert</code>只能被<code class="fe lh li lj kx b">BinSearchTree</code>类型的文字调用。</p><p id="aae5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你可能已经注意到的，我没有使用<em class="ku">递归</em>将数据插入合适的节点，而是使用<code class="fe lh li lj kx b">for</code>循环找到合适的位置来插入节点。</p><p id="3d88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lh li lj kx b">newNode := Node{data, nil, nil}</code>创建一个新节点，其中<code class="fe lh li lj kx b">newNode.Data</code>是<code class="fe lh li lj kx b">data</code> , <code class="fe lh li lj kx b">newNode.Left</code>是<code class="fe lh li lj kx b">nil</code>,<code class="fe lh li lj kx b">newNode.Right</code>是<code class="fe lh li lj kx b">nil</code>。</p><p id="3c13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开始时<code class="fe lh li lj kx b">root</code>节点将为<em class="ku">零</em>。因此对第一个节点的引用被分配给<code class="fe lh li lj kx b">root</code>，如下所示:</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="91dc" class="lb lc in kx b gy ld le l lf lg">if t.root == nil {<br/>  t.root = &amp;newNode<br/>  return<br/>}</span></pre><p id="ffe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在继续前进之前，对<code class="fe lh li lj kx b">Insert</code>的后续调用将检查这个<code class="fe lh li lj kx b">if</code>条件(并且将被评估为假)。要插入另一个节点，我们需要检查数据是小于还是大于根节点。如果数据小于根节点，那么我们需要向左移动，否则向右移动，这应该反复检查，直到我们找到正确的位置，如下所示。</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="11ba" class="lb lc in kx b gy ld le l lf lg">iter, prev := t.root, t.root</span><span id="e4e4" class="lb lc in kx b gy lk le l lf lg">for iter != nil {<br/>    prev = iter<br/>    if data &lt; iter.Data {<br/>      iter = iter.Left<br/>    } else {<br/>      iter = iter.Right<br/>    }<br/>}</span></pre><p id="2dc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们找到合适的位置，我们插入元素:</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="31c1" class="lb lc in kx b gy ld le l lf lg">if data &lt; prev.Data {<br/>    prev.Left = &amp;newNode<br/>} else {<br/>    prev.Right = &amp;newNode<br/>}</span></pre><p id="88b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们不能遍历树，那么创建树又有什么意义呢？二叉查找树可以按顺序、前序和后序方式遍历。</p><p id="98e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<em class="ku">有序</em>遍历中，我们遍历左边的子节点，然后是父节点，然后是右边的子节点。<br/>在<em class="ku">前序</em>遍历中，我们遍历父节点，然后是左子节点，然后是右子节点。<br/>在<em class="ku">后序</em>遍历中，我们先遍历左侧子节点，然后是右侧子节点，最后是父节点。</p><p id="b175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用于<em class="ku">按顺序</em>遍历的方法看起来是这样的:</p><pre class="kj kk kl km gt kw kx ky kz aw la bi"><span id="22e7" class="lb lc in kx b gy ld le l lf lg">func (t *BinSearchTree) InOrder(node *Node){<br/> if node == nil {<br/>  return<br/> }<br/> t.InOrder(node.Left)<br/> fmt.Println(node.Data)<br/> t.InOrder(node.Right)<br/>}</span></pre><p id="789c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您已经注意到的用于遍历二叉查找树的递归技术。完整的源代码可以在这里找到<a class="ae ll" href="https://gist.github.com/sandeep-sarkar/07e47cdae0c63f14b695370536b434ab" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/sandeep-sarkar/07 e 47 cdae 0 c 63 f 14 b 695370536 b 434 ab</a></p><p id="eb76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你喜欢阅读这篇文章。请通过评论分享您的反馈。</p></div></div>    
</body>
</html>