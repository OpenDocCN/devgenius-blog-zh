<html>
<head>
<title>Golang Kafka 100: Intro to Managing Golang Kafka Consumer Lag</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang Kafka 100:Golang Kafka 消费者滞后管理介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9?source=collection_archive---------8-----------------------#2022-04-01">https://blog.devgenius.io/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9?source=collection_archive---------8-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="71c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一系列文章将解释我的团队在 Kafka 的实时过程中导出一个最重要的指标的过程:消费者滞后。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/15676be2129a5818238d83176efeed2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RFtQ7wCFo2eyCTPX.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="3269" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a728" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">消费者滞后是一个很难在<a class="ae mh" href="https://github.com/confluentinc/confluent-kafka-go" rel="noopener ugc nofollow" target="_blank">融合 kafka go </a>包中提取的指标，但我们设计了一种方法来同步我们的消费者/pod 以计算它，并触发一个自定义 HPA，该 HPA 采用该指标并根据我们的负载缩小/扩大我们的消费者。这些都运行在 Kubernetes/On Prem 环境中。</p><h1 id="6e83" class="le lf iq bd lg lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb bi translated">介绍</h1><p id="654f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们的第一篇文章将高度概括我们为什么采用这种方法，解释我们面临的约束以及我们如何设计解决方案。文章的其余部分将包含与所采取的步骤相关的所有代码。</p><ol class=""><li id="c335" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">简介:管理戈朗卡夫卡消费滞后</li><li id="0ce5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><a class="ae mh" href="https://javiersotodev.medium.com/golang-kafka-101-extract-and-calculate-our-consumer-lag-40f902158948" rel="noopener">提取并计算我们的消费滞后</a></li><li id="89ee" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">构建和使用我们的定制 HPA</li><li id="fc53" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">深入了解我们的 Kubernetes 控制器</li></ol><h1 id="0c10" class="le lf iq bd lg lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb bi translated">问题是</h1><p id="65da" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们是一个实时处理团队，非常依赖于尽可能快地在我们的 APIs 数据库中反映 Kafka 的这些变化。对于这些，我们有一组用 go 编写的服务，它们消费消息，执行业务逻辑，并将它们插入到我们的数据库中。每个服务都是同一个使用者组的一部分，并且它有多个 pod 在同一个部署(我们的副本集)下运行。为了扩展我们的服务，我们需要检查控制中心，查看我们积压的消息，并相应地增加/减少 pod 计数。正如您可能认为的那样，这一过程是手动的、乏味的，因为我们喜欢创新，尽可能做得最少，所以我们自动化了这一过程。</p><p id="709b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得一提的是，由于我们无法控制的限制，我们的空间(公司)没有能力拥有普罗米修斯驱动的 HPA。</p><h1 id="02d2" class="le lf iq bd lg lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb bi translated">我们的建筑</h1><p id="ccf6" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">为了简化您对我们接下来步骤的理解，我将向您展示并解释我们解决方案的高层次示意图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/c0180dd9706d33d060eca368953e5de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mIxRkTmL9duL1fb1SOtwQ.png"/></div></div></figure><p id="1442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从左到右，您会看到我们的摄取服务(我们的消费者群体)和它们各自的副本集。这些服务将有一个反映该 pod(单个消费者)的消费者滞后的端点。适当的函数将只计算分配给该消费者的分区的滞后，而不是消费者组已经分配的所有分区的滞后。解决方法是直接进入我们的每个 pod，汇总所有信息，然后获得消费者群体的总滞后。</p><p id="be2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，您会看到另一个服务充当我们的 kubernetes 控制器，它负责向我们提供 pod IPs，还将在运行时扩展/缩减我们的服务。</p><p id="784e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我们有一组 3 个服务，它们之间将进行交互，管理与我们的负载相关的资源。</p><h1 id="9f31" class="le lf iq bd lg lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb bi translated">这个计划</h1><p id="2f8c" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">接下来的步骤将是所有人都参与进来，因为我们将实现从我们的服务中提取我们的 lag 的功能，建立我们的 HPA 服务，并且作为一个额外的功能，我们将建立我们的 Kubernetes 控制器。这一切都发生在戈朗。</p><p id="28c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望在你读完这一系列文章后，你能更好地理解我们提供的解决方案，以及如果你正在努力应对消费者滞后管理，它能如何帮助你。</p></div></div>    
</body>
</html>