<html>
<head>
<title>Evolutionary Design: An example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进化设计:一个例子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/evolutionary-design-an-example-d9889a262e3d?source=collection_archive---------2-----------------------#2021-02-28">https://blog.devgenius.io/evolutionary-design-an-example-d9889a262e3d?source=collection_archive---------2-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="884d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进化设计和TDD为什么是相关的？。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/1ed3537d87764f74958c7712d9b961d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VP0oUHZJKz1WYGgi6RnFpg.png"/></div></figure><p id="b25d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我发表了我的<a class="ae kt" href="https://medium.com/dev-genius/evolutionary-design-cfb1795e8f81?sk=b32e3f4396a3576ea88726d8ce8fc73b" rel="noopener">进化设计</a>博文，我就收到了一些关于为什么TDD与它相关的反馈。诚然，当我们谈论进化设计(紧急设计)时，有不同的层次。如今，敏捷公司在他们引入的每个特性中改变他们的软件设计。这通常以预先设计的方式完成，所以在编码之前要考虑如何解决整个特性。<br/>事实上，当你必须实现一个特性时，有两种情况:</p><ul class=""><li id="293d" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">你知道如何实现一个特性，因为你过去做过很多次，所以你不需要推断什么是正确的设计。</li><li id="31b0" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">你不知道怎么解决问题，也不知道设计会怎么样。</li></ul><p id="af08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以我的经验来看，第一件事时有发生，而第二件事是常事。进化设计可以帮助你在第二种情况下，基本上进化设计是试图找到你的系统的设计，而你正在努力找到你的系统如何运作。</p><p id="ba66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们拥有比功能更多的粒度级别:</p><ul class=""><li id="1edd" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">用户故事</li><li id="462a" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">用户情景中的场景</li><li id="2aaf" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">任务</li></ul><h2 id="ae73" class="li lj iq bd lk ll lm dn ln lo lp dp lq jy lr ls lt kc lu lv lw kg lx ly lz ma bi translated">有没有可能通过场景做进化设计？。</h2><p id="8444" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为了解决整个特性，我们需要解决所有的用户故事，为了解决它们，我们需要解决它们的所有场景。如果我们能够一个接一个地解决每个场景，我们就能更频繁地改进设计。小步骤总是更好，因为风险更小，我们可以从中获得早期反馈。<br/>总之，很明显，要一直改变事物，你需要一种快速的方法来知道你是否引入了错误。你会说，等等，但是做这个测试已经足够了，我同意。所以我们需要测试来发展，对我们的改变有信心。</p><p id="4fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然需要计划下一个场景，所以为了理解要计划什么，我们首先需要理解要做什么。通常用户故事的场景都带有一些验收标准，事实上这些验收标准描述了我们可以用来知道我们的软件是否实现了问题的解决方案的测试。因此，编写测试是一种了解我们是否理解问题的方法(这是计划如何解决问题之前的一步)。</p><p id="ef73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一件事是计划如何解决它。但是等等，如果场景足够小，并且我选择了正确的顺序，我需要计划什么呢？。我只需要为下一个场景调整我的代码。</p><p id="1c15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所描述的正是<a class="ae kt" href="https://medium.com/dev-genius/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157" rel="noopener"> TDD </a>试图解决的问题:</p><ul class=""><li id="24ef" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">思考下一个要解决的更简单的问题是什么</li><li id="e692" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">创建一个测试来理解要解决的问题</li><li id="1c08" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">创建通过测试的代码</li><li id="5057" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">改进您的设计</li><li id="207f" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">重新开始</li></ul><p id="5608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不需要<a class="ae kt" href="https://medium.com/dev-genius/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157" rel="noopener"> TDD </a>来浮现你的设计，但是你需要解决这些问题，否则你会有一个混乱的代码库。TDD解决了我描述的问题，这就是为什么我认为它是实现进化设计的最简单的方法。</p><h2 id="746b" class="li lj iq bd lk ll lm dn ln lo lp dp lq jy lr ls lt kc lu lv lw kg lx ly lz ma bi translated">问题是</h2><p id="72a5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在这个例子中，我们将使用<a class="ae kt" href="https://kata-log.rocks/bowling-game-kata" rel="noopener ugc nofollow" target="_blank">保龄球形</a>，我们将在TDD之后用Java来做:</p><blockquote class="mg mh mi"><p id="1afa" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">这个游戏由10帧组成。在每一局中，玩家有两次机会击倒10个球瓶。这一局的分数是击倒的球瓶总数，加上好球和空球的奖励。</p><p id="66cf" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">备用球是指球员在两轮比赛中击倒所有10个球瓶。该帧的奖励是下一次掷骰子击倒的瓶数。</p><p id="465c" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">好球是指玩家在第一次掷骰子时击倒所有10个球瓶。然后用一个辊就完成了框架。该帧的奖金是接下来两次掷骰的价值。</p><p id="8b64" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">在第十局中，掷出备用球或全中球的玩家可以掷出多余的球来完成这一局。然而，在第十帧中最多只能滚动三个球。</p><p id="3803" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">要求</p><p id="fa8a" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">编写一个有两个方法的类<code class="fe mn mo mp mq b">Game</code></p><p id="8cad" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><code class="fe mn mo mp mq b">void roll(int)</code>在玩家每次滚动一个球时被调用。争论点是击倒的球瓶数量。</p><p id="3675" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><code class="fe mn mo mp mq b">int score()</code>返回该游戏的总分。</p></blockquote><p id="77dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，明白了。现在第一件事应该是找到更小的问题来指导我们解决整个事情。试图编写一个测试来解决整个问题是没有任何价值的，因为这样我们需要在第一次尝试时找到正确的解决方案，这非常困难。</p><p id="3834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显你不需要打十帧来问分数。所以我可以要求我们已经玩过的每一帧的分数。这是增加问题的一种方式，我们的第一个测试可能是:</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="6167" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>noFrame(){<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(0));<br/>}</span><span id="1b6c" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private int </em>totalScore = 0;<br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>totalScore;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        totalScore = pins;<br/>    }<br/>}</span></pre><p id="26a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要通过这个测试，我需要创建游戏类和评分方法。到目前为止，返回0就足以解决这个问题。</p><p id="3295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来要做的应该是一帧打一个滚，看结果。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="0bd2" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>oneFrameOneRoll(){<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    bowling.roll(1);<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(1));<br/>}</span></pre><p id="db6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，游戏将需要改变，以返回被撞倒的瓶。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="7950" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private int </em>totalScore = 0;<br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>totalScore;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        totalScore = pins;<br/>    }<br/>}</span></pre><p id="044c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是一个框架有两个卷，让我们尝试一下那个场景，看看如何解决它。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="dbd8" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>oneFrameTwoRolls(){<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    bowling.roll(1);<br/>    bowling.roll(1);<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(2));<br/>}</span></pre><p id="2510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要将击倒的瓶加入到最终得分中。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="eb83" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private int </em>totalScore = 0;<br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>totalScore;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        totalScore += pins;<br/>    }<br/>}</span></pre><p id="8e86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，让我们强制创建一个管理备件的方法，这将是我们下一个要解决的小问题。如果我们在第一帧做了备用，我们需要在下一次掷骰子时增加一个奖励。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="7d03" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>twoFramesFirsIsSpare(){<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    bowling.roll(9);<br/>    bowling.roll(1);<br/><br/>    bowling.roll(1);<br/>    bowling.roll(1);<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(13));<br/>}</span></pre><p id="9a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了管理备件，我们需要创建一些东西，我想到了一个框架(它在问题的描述中)。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="4682" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private </em>Frame frame0 = <em class="mj">new </em>Frame();<br/>    <em class="mj">private </em>Frame frame1 = <em class="mj">new </em>Frame();<br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frame0.score()+frame1.score();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <em class="mj">if</em>(frame0.isFrameOpen()){<br/>            frame0.roll(pins, <em class="mj">false</em>);<br/>        }<em class="mj">else</em>{<br/>            frame1.roll(pins, frame0.isSpare());<br/>        }<br/>    }<br/>}</span><span id="17f5" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class </em><strong class="mq ir">Frame</strong> {<br/>    <em class="mj">private int </em>roll0 = 0;<br/>    <em class="mj">private int </em>roll1 = 0;<br/>    <em class="mj">private int </em>rollsPlayed = 0;<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">boolean </em>previousFrameIsSpare) {<br/>        <em class="mj">if </em>(rollsPlayed == 0) {<br/>            roll0 = previousFrameIsSpare ? 2*pins : pins;<br/>        } <em class="mj">else </em>{<br/>            roll1 = pins;<br/>        }<br/>        rollsPlayed++;<br/>    }<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>roll0 + roll1;<br/>    }<br/><br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>rollsPlayed &lt; 2;<br/>    }<br/><br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return </em>roll0 + roll1 == 10 &amp;&amp; rollsPlayed==2;<br/>    }<br/>}</span></pre><p id="c214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我需要创建Frame类来支持播放两个帧，并且在第一个帧是备用帧时有一个额外的奖励。这是很大的一步，因为一旦我们能够创建帧类，我们就需要管理备用的额外逻辑。所以更容易的是先重构游戏类，轻松地创建框架概念，然后引入新特性(当我们处于绿色状态时重构)。</p><p id="5817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，每一帧我们都需要一个变量。因此，让我们重构代码，使用一个数组而不是两个变量来表示帧。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="4411" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private </em>Frame frames[] = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 2).mapToObj(i -&gt; <em class="mj">new </em>Frame()).toArray(Frame[]::<em class="mj">new</em>);<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>Arrays.<em class="mj">stream</em>(frames).mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        Frame previousFrame = <em class="mj">new </em>Frame();<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, previousFrame.isSpare());<br/>                <em class="mj">return</em>;<br/>            }<br/>            previousFrame = frame;<br/>        }<br/>    }<br/>}</span></pre><p id="dd37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的游戏只支持两帧，让我们允许十帧没有奖金。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="43a5" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>tenFrames() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">for</em>(<em class="mj">int </em>i=0; i&lt;20; i++){<br/>        bowling.roll(1);<br/>    }<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(20));<br/>}</span><span id="9e43" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final </em>Frame[] frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, <strong class="mq ir">10</strong>).mapToObj(i -&gt; <em class="mj">new </em>Frame()).toArray(Frame[]::<em class="mj">new</em>);<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">int </em>result = 0;<br/>        <em class="mj">boolean </em>isSpare = <em class="mj">false</em>;<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            result += frame.score(isSpare);<br/>            isSpare = frame.isSpare();<br/>        }<br/>        <em class="mj">return </em>result;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <em class="mj">if </em>(frame.isOpen()) {<br/>                frame.roll(pins);<br/>                <em class="mj">return</em>;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="c441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们改变了创建的帧数，现在我们需要迭代数组，直到我们找到一个开放的帧来播放一卷。分数将是分数的总和，如果前一帧是备用帧以增加奖金，我们将通过。</p><p id="73d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比起数组，我更喜欢列表，所以让我们在这里做一个小的重构。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="7323" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final </em><strong class="mq ir"><em class="mj">List</em>&lt;Frame&gt;</strong> frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(i -&gt; <em class="mj">new </em>Frame()).collect(Collectors.<em class="mj">toList</em>());<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        Frame previousFrame = <em class="mj">new </em>Frame();<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, previousFrame.isSpare());<br/>                <em class="mj">return</em>;<br/>            }<br/>            previousFrame = frame;<br/>        }<br/>    }<br/>}</span></pre><p id="71a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有备件，但没有正方形，所以让我们尝试引入两个框架和一个正方形，以获得奖金。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="68a5" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>twoFramesFirstOneIsSquare() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    bowling.roll(10);<br/>    bowling.roll(1);<br/>    bowling.roll(1);<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(14));<br/>}</span></pre><p id="853f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们可以像处理备用轮胎一样处理，但是要处理方形轮胎。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="bf15" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final List</em>&lt;Frame&gt; frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(i -&gt; <em class="mj">new </em>Frame()).collect(Collectors.<em class="mj">toList</em>());<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        Frame previousFrame = <em class="mj">new </em>Frame();<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, previousFrame.isSpare(), <strong class="mq ir">previousFrame.isSquare()</strong>);<br/>                <em class="mj">return</em>;<br/>            }<br/>            previousFrame = frame;<br/>        }<br/>    }<br/>}</span></pre><p id="8ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用前一帧来了解是否需要在当前帧中应用奖金。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="d029" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Frame {<br/>    <em class="mj">private int </em>roll0 = 0;<br/>    <em class="mj">private int </em>roll1 = 0;<br/>    <em class="mj">private int </em>rollsPlayed = 0;<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">boolean </em>previousFrameIsSpare, <em class="mj">boolean </em>previousFrameIsSquare) {<br/>        <em class="mj">if </em>(rollsPlayed == 0) {<br/>            roll0 = <strong class="mq ir">(previousFrameIsSpare ||  previousFrameIsSquare) ? 2*pins : pins;</strong><br/>        } <em class="mj">else </em>{<br/>            roll1 = <strong class="mq ir">previousFrameIsSquare ? 2*pins : pins;</strong><br/>        }<br/>        rollsPlayed++;<br/>    }<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>roll0 + roll1;<br/>    }<br/><br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>rollsPlayed &lt; 2 &amp;&amp; (roll0&lt;10);<br/>    }<br/><br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return </em>roll0 + roll1 == 10 &amp;&amp; rollsPlayed==2;<br/>    }<br/><br/>    <strong class="mq ir"><em class="mj">public boolean </em>isSquare() {<br/>        <em class="mj">return </em>roll0  == 10 &amp;&amp; rollsPlayed==1;<br/>    }</strong><br/>}</span></pre><p id="791d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一下代码，很明显，这对于连续的几个方格是行不通的，因为我们需要记住最后两个，如果我们有两个奖金要申请，这也是行不通的。但是我们需要改进当前的设计来简化下一步，也许是时候引入奖金的概念了。</p><p id="78b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以开始在游戏中引入奖金，这样我们就可以用它来计算何时需要应用奖金。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="35b3" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final List</em>&lt;Frame&gt; frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(i -&gt; i &lt; 9 ? <em class="mj">new </em>NormalFrame() : <em class="mj">new </em>TenthFrame()).collect(Collectors.<em class="mj">toList</em>());<br/>    <strong class="mq ir"><em class="mj">private Bonus </em>bonus = <em class="mj">new </em>Bonus(0);</strong><br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, bonus);<br/>                <strong class="mq ir">bonus = <em class="mj">Bonus</em>.<em class="mj">newBonus</em>(bonus, frame);</strong><br/>                <em class="mj">return</em>;<br/>            }<br/>        }<br/>    }<br/>}</span><span id="e889" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class Frame</em> <em class="mj">implements </em>Frame {<br/>    <em class="mj">private int </em>roll0 = 0;<br/>    <em class="mj">private int </em>roll1 = 0;<br/>    <em class="mj">private int </em>rollsPlayed = 0;<br/><br/>    @Override<br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">Bonus </em>bonus) {<br/>        <em class="mj">if </em>(rollsPlayed == 0) {<br/>            roll0 = <strong class="mq ir">calculateScore(pins, bonus);</strong><br/>        } <em class="mj">else </em>{<br/>            roll1 = <strong class="mq ir">calculateScore(pins, bonus);</strong><br/>        }<br/>        rollsPlayed++;<br/>    }<br/><br/>    <strong class="mq ir"><em class="mj">private int </em>calculateScore(<em class="mj">int </em>pins, <em class="mj">Bonus </em>bonus) {<br/>        <em class="mj">return </em>bonus.applies() ? 2 * pins : pins;<br/>    }</strong><br/><br/>    @Override<br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>roll0 + roll1;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>rollsPlayed &lt; 2 &amp;&amp; (roll0 &lt; 10);<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return </em>roll0 + roll1 == 10 &amp;&amp; rollsPlayed == 2;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isSquare() {<br/>        <em class="mj">return </em>roll0 == 10 &amp;&amp; rollsPlayed == 1;<br/>    }<br/>}</span></pre><p id="4974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从零奖金开始，这就像没有奖金，并移动所有的逻辑，以了解我们是否需要将奖金应用到奖金类。在这里，我注意到roll0和roll1不足以计算框架是备用的还是方形的，也不足以计算该roll的分数，这超出了我们当前的步骤，但我们可以考虑接下来的功能。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="f12a" class="li lj iq mq b gy mv mw l mx my"><strong class="mq ir"><em class="mj">public class </em>Bonus</strong> {<br/>    <em class="mj">private int </em>applyForThisNumberOfRolls;<br/>    <em class="mj">private int </em>numberOfRollsConsumed;<br/><br/>    <em class="mj">public </em>Bonus(<em class="mj">int </em>applyForThisNumberOfRolls) {<br/>        <em class="mj">this</em>.applyForThisNumberOfRolls = applyForThisNumberOfRolls;<br/>        <em class="mj">this</em>.numberOfRollsConsumed = 0;<br/>    }<br/><br/>    <em class="mj">public boolean </em>applies() {<br/>        <em class="mj">return </em>numberOfRollsConsumed &lt; applyForThisNumberOfRolls;<br/>    }<br/><br/>    <em class="mj">public void </em>consumeRoll() {<br/>        <em class="mj">this</em>.numberOfRollsConsumed++;<br/>    }<br/><br/>    <em class="mj">public static  </em>Bonus newBonus(Bonus currentBonus, Frame frame){<br/>        Bonus bonus = currentBonus;<br/>        bonus.consumeRoll();<br/>        <em class="mj">if </em>(frame.isSpare()) {<br/>            bonus = <em class="mj">new </em>Bonus(1);<br/>        } <em class="mj">else if </em>(frame.isSquare()) {<br/>            bonus = <em class="mj">new </em>Bonus(2);<br/>        }<br/>        <em class="mj">return </em>bonus;<br/>    }<br/>}</span></pre><p id="0fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">奖励取决于应用的掷骰数和激活奖励时的掷骰数，因此我们可以使用它来代替isSpare isSquare参数。</p><p id="b9f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们用三个连续的方块来试一试。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="3510" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>threeFramewWithSquaresInAllOfThem() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; 3; i++) {<br/>        bowling.roll(10);<br/>    }<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(60));<br/>}</span></pre><p id="b364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的担心现在出现了，我们需要有一种方法来记住击倒的掷骰子(实现isSpare、isSquare方法)和那些带有奖金的掷骰子的分数，以便能够计算总分。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="ca09" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Frame {<br/>    <strong class="mq ir"><em class="mj">private final int</em>[] scores;</strong><br/>    <strong class="mq ir"><em class="mj">protected final int</em>[] rolls;</strong><br/>    <em class="mj">protected int </em>rollsPlayed = 0;<br/><br/>    <em class="mj">public </em>Frame() {<br/>        scores = <em class="mj">new int</em>[2];<br/>        rolls = <em class="mj">new int</em>[2];<br/>        <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; 2; i++) {<br/>            scores[i] = 0;<br/>            rolls[i] = 0;<br/>        }<br/>        <em class="mj">this</em>.rollsPlayed = 0;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">Bonus </em>bonus) {<br/>        rolls[rollsPlayed] = pins;<br/>        scores[rollsPlayed] = bonus.calculateScore(pins);<br/>        rollsPlayed++;<br/>    }<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return stream</em>(scores).sum();<br/>    }<br/><br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>rollsPlayed &lt; 2 &amp;&amp; (rolls[0] &lt; 10);<br/>    }<br/><br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return </em>rolls[0] + rolls[1] == 10 &amp;&amp; rollsPlayed == 2;<br/>    }<br/><br/>    <em class="mj">public boolean </em>isSquare() {<br/>        <em class="mj">return </em>rolls[0] == 10 &amp;&amp; rollsPlayed == 1;<br/>    }<br/><br/>    <em class="mj">public int </em>getRollsPlayed() {<br/>        <em class="mj">return </em>rollsPlayed;<br/>    }<br/>}</span></pre><p id="474e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一步的重构阶段，我们还通过一个数组改变了roll0和roll1，我们对scores数组采用了相同的方法。以前分数和卷占据相同的概念，现在在这一步之后他们被一分为二。</p><p id="a25b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是测试没有通过，因为我们需要在第三步应用两个加成。这迫使我们创造另一个概念——多重奖金。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="b217" class="li lj iq mq b gy mv mw l mx my"><strong class="mq ir"><em class="mj">public class </em>MultipleBonus <em class="mj">implements Bonus </em>{</strong><br/>    <em class="mj">private final Bonus </em>firstBonus;<br/>    <em class="mj">private final Bonus </em>secondBonus;<br/><br/>    <em class="mj">public </em>MultipleBonus(<em class="mj">Bonus </em>firstBonus, <em class="mj">Bonus </em>secondBonus) {<br/>        <em class="mj">this</em>.firstBonus = firstBonus;<br/>        <em class="mj">this</em>.secondBonus = secondBonus;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>applies() {<br/>        <em class="mj">return </em>firstBonus.applies() || secondBonus.applies();<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public void </em>consumeRoll(<em class="mj">int </em>rollsPlayed) {<br/>        <em class="mj">if </em>(firstBonus.applies()) {<br/>            firstBonus.consumeRoll(rollsPlayed);<br/>        }<br/>        <em class="mj">if </em>(secondBonus.applies()) {<br/>            secondBonus.consumeRoll(rollsPlayed);<br/>        }<br/>    }<br/><br/>    <em class="mj">public int </em>calculateScore(<em class="mj">int </em>pins) {<br/>        <em class="mj">int </em>result = 0;<br/>        <em class="mj">if </em>(firstBonus.applies()) {<br/>            result = firstBonus.calculateScore(pins);<br/>        }<br/>        <em class="mj">if </em>(secondBonus.applies()) {<br/>            result += secondBonus.calculateScore(pins) - pins;<br/>        }<br/>        <em class="mj">return </em>result;<br/>    }<br/>}</span></pre><p id="1b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是为了在我们的程序中引入这个新概念，我们需要从Bonus中提取一个接口，并将Bonus类改为SingleBonus。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="5980" class="li lj iq mq b gy mv mw l mx my"><strong class="mq ir"><em class="mj">public interface Bonus</em></strong><em class="mj"> </em>{<br/>    <strong class="mq ir"><em class="mj">static Bonus </em>newBonus(<em class="mj">Bonus </em>currentBonus, Frame frame) {<br/>        <em class="mj">Bonus </em>bonus = currentBonus;<br/>        <em class="mj">if </em>(frame.isSpare()) {<br/>            bonus = <em class="mj">newBonus</em>(currentBonus, <em class="mj">spareBonus</em>());<br/>        } <em class="mj">else if </em>(frame.isSquare()) {<br/>            bonus = <em class="mj">newBonus</em>(currentBonus, <em class="mj">squareBonus</em>());<br/>        }<br/>        <em class="mj">return </em>bonus;<br/>    }<br/><br/>    <em class="mj">static Bonus </em>newBonus(<em class="mj">Bonus </em>currentBonus, SingleBonus singleBonus) {<br/>        <em class="mj">return </em>currentBonus.applies() ? <em class="mj">new </em>MultipleBonus(currentBonus, singleBonus) : singleBonus;<br/>    }</strong><br/><br/>    <em class="mj">static </em>SingleBonus squareBonus() {<br/>        <em class="mj">return new </em>SingleBonus(2);<br/>    }<br/><br/>    <em class="mj">static </em>SingleBonus spareBonus() {<br/>        <em class="mj">return new </em>SingleBonus(1);<br/>    }<br/><br/>    <em class="mj">boolean </em>applies();<br/><br/>    <em class="mj">void </em>consumeRoll(<em class="mj">int </em>rollsPlayed);<br/><br/>    <em class="mj">int </em>calculateScore(<em class="mj">int </em>pins);<br/>}</span><span id="6950" class="li lj iq mq b gy mz mw l mx my"><em class="mj"><br/></em><strong class="mq ir"><em class="mj">public class </em>SingleBonus <em class="mj">implements Bonus</em></strong><em class="mj"> </em>{<br/>    <em class="mj">private int </em>applyForThisNumberOfRolls;<br/>    <em class="mj">private int </em>numberOfRollsConsumed;<br/><br/>    <em class="mj">public </em>SingleBonus(<em class="mj">int </em>applyForThisNumberOfRolls) {<br/>        <em class="mj">this</em>.applyForThisNumberOfRolls = applyForThisNumberOfRolls;<br/>        <em class="mj">this</em>.numberOfRollsConsumed = 0;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>applies() {<br/>        <em class="mj">return </em>numberOfRollsConsumed &lt; applyForThisNumberOfRolls;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public void </em>consumeRoll(<em class="mj">int </em>rollsPlayed) {<br/>        <em class="mj">this</em>.numberOfRollsConsumed += rollsPlayed;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public int </em>calculateScore(<em class="mj">int </em>pins) {<br/>        <em class="mj">return this</em>.applies() ? 2 * pins : pins;<br/>    }<br/>}</span><span id="8279" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final List</em>&lt;Frame&gt; frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(i -&gt; i &lt; 9 ? <em class="mj">new </em>Frame(2) : <em class="mj">new </em>TenthFrame()).collect(Collectors.<em class="mj">toList</em>());<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <strong class="mq ir"><em class="mj">Bonus </em>bonus = <em class="mj">new </em>SingleBonus(0);</strong><br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            <strong class="mq ir">bonus.consumeRoll(frame.getRollsPlayed());</strong><br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, bonus);<br/>                <em class="mj">return</em>;<br/>            }<br/>            <strong class="mq ir">bonus = <em class="mj">Bonus</em>.<em class="mj">newBonus</em>(bonus, frame);</strong><br/>        }<br/>    }<br/>}</span></pre><p id="9d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我意识到像全局属性这样的奖励不是一个好主意，我们也需要一种方法来消耗我们正在工作的帧所应用的滚动。因此，计算适用于开放帧的奖金是一个迭代过程，消耗先前封闭帧的所有掷骰子加上在开放帧中玩的掷骰子。这就是为什么奖金被移动到滚动方法中，并在每次迭代中计算，根据它创建的帧，一个新的奖金。如果在最后一帧中没有方块或备用方块，那么我们继续之前的奖励。</p><p id="9875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在bonus中应用了工厂模式，将逻辑放在这里，以决定我们是需要创建多个还是单个Bonus实例。</p><p id="6ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在想，画四个正方形很好，但是不行。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="af75" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>fourFramesWithSquaresInAllOfThem() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; 4; i++) {<br/>        bowling.roll(10);<br/>    }<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(90));<br/>}</span></pre><p id="6f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的多重奖金没有考虑到，如果我们不应用第一个奖金，第二个奖金必须应用，我不能减去第一个奖金的分数计算的引脚，因为它没有计算。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="2b57" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>MultipleBonus <em class="mj">implements Bonus </em>{<br/>    <em class="mj">private final Bonus </em>firstBonus;<br/>    <em class="mj">private final Bonus </em>secondBonus;<br/><br/>    <em class="mj">public </em>MultipleBonus(<em class="mj">Bonus </em>firstBonus, <em class="mj">Bonus </em>secondBonus) {<br/>        <em class="mj">this</em>.firstBonus = firstBonus;<br/>        <em class="mj">this</em>.secondBonus = secondBonus;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>applies() {<br/>        <em class="mj">return </em>firstBonus.applies() || secondBonus.applies();<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public void </em>consumeRoll(<em class="mj">int </em>rollsPlayed) {<br/>        <em class="mj">if </em>(firstBonus.applies()) {<br/>            firstBonus.consumeRoll(rollsPlayed);<br/>        }<br/>        <em class="mj">if </em>(secondBonus.applies()) {<br/>            secondBonus.consumeRoll(rollsPlayed);<br/>        }<br/>    }<br/><br/>    <em class="mj">public int </em>calculateScore(<em class="mj">int </em>pins) {<br/>        <em class="mj">int </em>result = 0;<br/>        <em class="mj">if </em>(firstBonus.applies()) {<br/>            result = firstBonus.calculateScore(pins);<br/>        }<br/>        <em class="mj">if </em>(secondBonus.applies()) {<br/>            <strong class="mq ir">result += secondBonus.calculateScore(pins) - (firstBonus.applies() ? pins: 0);</strong><br/>        }<br/>        <em class="mj">return </em>result;<br/>    }<br/>}</span></pre><p id="1d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第十帧比较特殊，大家重点关注一下，看看规律。但是在我们需要一种方法来扩展框架以具有不同的行为之前，在不添加任何行为的情况下，我们可以重构框架以遵循模板模式，从而有两个实现</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="6d5d" class="li lj iq mq b gy mv mw l mx my"><strong class="mq ir"><em class="mj">public abstract class </em>Frame {</strong><br/>    <em class="mj">private final int</em>[] scores;<br/>    <em class="mj">protected final int</em>[] rolls;<br/>    <em class="mj">protected int </em>rollsPlayed = 0;<br/><br/>    <em class="mj">public </em>Frame(<em class="mj">int </em>numberOfRollsAllowed) {<br/>        scores = <em class="mj">new int</em>[numberOfRollsAllowed];<br/>        rolls = <em class="mj">new int</em>[numberOfRollsAllowed];<br/>        <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; numberOfRollsAllowed; i++) {<br/>            scores[i] = 0;<br/>            rolls[i] = 0;<br/>        }<br/>        <em class="mj">this</em>.rollsPlayed = 0;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">Bonus </em>bonus) {<br/>        rolls[rollsPlayed] = pins;<br/>        scores[rollsPlayed] = bonus.calculateScore(pins);<br/>        rollsPlayed++;<br/>    }<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return stream</em>(scores).sum();<br/>    }<br/><br/>    <em class="mj">public int </em>getRollsPlayed() {<br/>        <em class="mj">return </em>rollsPlayed;<br/>    }<br/><br/>    <em class="mj">public abstract boolean </em>isFrameOpen();<br/><br/>    <em class="mj">public abstract boolean </em>isSpare();<br/><br/>    <em class="mj">public abstract boolean </em>isSquare();<br/>}</span><span id="d4aa" class="li lj iq mq b gy mz mw l mx my"><strong class="mq ir"><em class="mj">public class </em>NormalFrame <em class="mj">extends </em>Frame{</strong><br/>    <em class="mj">public </em>NormalFrame() {<br/>        <em class="mj">super</em>(2);<br/>    }<br/>    @Override<br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>rollsPlayed &lt; 2 &amp;&amp; (rolls[0] &lt; 10);<br/>    }<br/>    @Override<br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return </em>rolls[0] + rolls[1] == 10 &amp;&amp; rollsPlayed == 2;<br/>    }<br/>    @Override<br/>    <em class="mj">public boolean </em>isSquare() {<br/>        <em class="mj">return </em>rolls[0] == 10 &amp;&amp; rollsPlayed == 1;<br/>    }<br/>}</span></pre><p id="c4de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在解决这个新问题就容易了</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="f56e" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>tenFramesOneSpareTenthFrame() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">for</em>(<em class="mj">int </em>i=0; i&lt;18; i++){<br/>        bowling.roll(1);<br/>    }<br/>    bowling.roll(9);<br/>    bowling.roll(1);<br/>    bowling.roll(1);<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(29));<br/>}</span></pre><p id="b638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第十帧类似于帧，但根据某些情况允许3次滚动。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="39ce" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>TenthFrame <em class="mj">extends </em>Frame {<br/>    <em class="mj">public </em>TenthFrame() {<br/>        <em class="mj">super</em>(3);<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isFrameOpen() {<br/>        <em class="mj">return </em>(rollsPlayed == 2 &amp;&amp; (rolls[0] + rolls[1] &gt;= 10)) || rollsPlayed &lt; 2;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isSpare() {<br/>        <em class="mj">return false</em>;<br/>    }<br/><br/>    @Override<br/>    <em class="mj">public boolean </em>isSquare() {<br/>        <em class="mj">return false</em>;<br/>    }<br/>}</span></pre><p id="feb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个扩展，我们只需要改变游戏，用我们的新实现创建第十帧。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="2f96" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public class </em>Game {<br/>    <em class="mj">private final List</em>&lt;Frame&gt; frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(<strong class="mq ir">i -&gt; i &lt; 9 ? <em class="mj">new </em>NormalFrame() : <em class="mj">new </em>TenthFrame()</strong>).collect(Collectors.<em class="mj">toList</em>());<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <em class="mj">Bonus </em>bonus = <em class="mj">new </em>SingleBonus(0);<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            bonus.consumeRoll(frame.getRollsPlayed());<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, bonus);<br/>                <em class="mj">return</em>;<br/>            }<br/>            bonus = <em class="mj">Bonus</em>.<em class="mj">newBonus</em>(bonus, frame);<br/>        }<br/>    }<br/>}</span></pre><p id="60ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用与上面相同的方法对此进行重构。我们可以将决定创建什么框架的逻辑移到抽象框架类中的工厂方法中。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="d84e" class="li lj iq mq b gy mv mw l mx my"><em class="mj">public abstract class </em>Frame {<br/>    <em class="mj">private final int</em>[] scores;<br/>    <em class="mj">protected final int</em>[] rolls;<br/>    <em class="mj">protected int </em>rollsPlayed = 0;<br/><br/>    <em class="mj">public </em>Frame(<em class="mj">int </em>numberOfRollsAllowed) {<br/>        scores = <em class="mj">new int</em>[numberOfRollsAllowed];<br/>        rolls = <em class="mj">new int</em>[numberOfRollsAllowed];<br/>        <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; numberOfRollsAllowed; i++) {<br/>            scores[i] = 0;<br/>            rolls[i] = 0;<br/>        }<br/>        <em class="mj">this</em>.rollsPlayed = 0;<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins, <em class="mj">Bonus </em>bonus) {<br/>        rolls[rollsPlayed] = pins;<br/>        scores[rollsPlayed] = bonus.calculateScore(pins);<br/>        rollsPlayed++;<br/>    }<br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return stream</em>(scores).sum();<br/>    }<br/><br/>    <em class="mj">public int </em>getRollsPlayed() {<br/>        <em class="mj">return </em>rollsPlayed;<br/>    }<br/><br/>    <em class="mj">public abstract boolean </em>isFrameOpen();<br/><br/>    <em class="mj">public abstract boolean </em>isSpare();<br/><br/>    <em class="mj">public abstract boolean </em>isSquare();<br/><br/>    <strong class="mq ir"><em class="mj">public static </em>Frame newFrame(<em class="mj">int </em>framePosition) {<br/>         <em class="mj">return </em>framePosition &lt; 9 ? <em class="mj">new </em>NormalFrame() : <em class="mj">new </em>TenthFrame();<br/>    }</strong><br/>}</span><span id="4749" class="li lj iq mq b gy mz mw l mx my"><em class="mj">public class </em>Game {<br/>    <strong class="mq ir"><em class="mj">private final List</em>&lt;Frame&gt; frames = <em class="mj">IntStream</em>.<em class="mj">range</em>(0, 10).mapToObj(Frame::<em class="mj">newFrame</em>).collect(Collectors.<em class="mj">toList</em>());</strong><br/><br/>    <em class="mj">public int </em>score() {<br/>        <em class="mj">return </em>frames.stream().mapToInt(Frame::score).sum();<br/>    }<br/><br/>    <em class="mj">public void </em>roll(<em class="mj">int </em>pins) {<br/>        <em class="mj">Bonus </em>bonus = <em class="mj">new </em>SingleBonus(0);<br/>        <em class="mj">for </em>(Frame frame : frames) {<br/>            bonus.consumeRoll(frame.getRollsPlayed());<br/>            <em class="mj">if </em>(frame.isFrameOpen()) {<br/>                frame.roll(pins, bonus);<br/>                <em class="mj">return</em>;<br/>            }<br/>            bonus = <em class="mj">Bonus</em>.<em class="mj">newBonus</em>(bonus, frame);<br/>        }<br/>    }<br/>}</span></pre><p id="cee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一件事是验证我们能够计算一个完美的游戏。</p><pre class="km kn ko kp gt mr mq ms mt aw mu bi"><span id="619a" class="li lj iq mq b gy mv mw l mx my">@Test<br/><em class="mj">public void </em>perfectGame() {<br/>    Game bowling = <em class="mj">new </em>Game();<br/>    <em class="mj">for </em>(<em class="mj">int </em>i = 0; i &lt; 12; i++) {<br/>        bowling.roll(10);<br/>    }<br/>    <em class="mj">assertThat</em>(bowling.score(), <em class="mj">is</em>(300));<br/>}</span></pre><p id="373f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们设计的最终照片:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/e84154e639e3f098acd45db66dfadeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJIg9ENh4dTpSCDCL2J03w.png"/></div></div></figure></div></div>    
</body>
</html>