<html>
<head>
<title>A Better Definition of the DRY Programming Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DRY 规划原理的更好定义</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-better-definition-of-the-dry-programming-principle-13a3d0af4d40?source=collection_archive---------5-----------------------#2022-04-22">https://blog.devgenius.io/a-better-definition-of-the-dry-programming-principle-13a3d0af4d40?source=collection_archive---------5-----------------------#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f98c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank">《T4》一书打造分层微服务 </a>已经过时了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank">learn backnd . dev</a>购买自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d9161f75de75c677d89f6f6a02c9b0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAojeDWuntM_lnX3eMUB-g.jpeg"/></div></div></figure><p id="cf4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">低级开发人员最常忽略和误解的一个编码原则是 DRY 原则，它代表<em class="ky">不要重复自己。</em></p><p id="c81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常被视为 WET(WET 代表<em class="ky">将所有内容写两次</em>)的直接对立面，DRY 原则实际上并不完全是关于通过使用复杂的抽象不惜一切代价避免代码重复，而是主要关于避免知识重复。</p><p id="7bb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管人们普遍认为，在整个应用程序中复制粘贴同一段代码是导致不一致和错误的最佳方法，但仅仅关注这一方面实际上是一个错误，因为过早的优化尝试通常会导致复杂性和代码耦合的增加。</p><h1 id="ef48" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">更好的 DRY 定义</h1><p id="ebfb" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">话虽如此，DRY 的更好定义将是选自《实用主义程序员》一书的以下定义，该书指出:</p><blockquote class="mc md me"><p id="c015" class="jn jo ky jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">在一个系统中，每一条知识都必须有一个单一的、明确的、权威的表示。</p></blockquote><p id="136a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中一条知识是业务领域中的特定逻辑或算法。</p><p id="56e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用三个例子来说明这一点，它们将让您更好地了解什么时候应该根据上下文进行重构，什么时候不应该进行重构，首先从常量开始。</p><h1 id="16dc" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">示例 1:常量</h1><p id="78d6" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">重构常量可能是尝试应用 DRY 原则时首先想到的。</p><p id="6c68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有以下三个用于显示文本的 React 组件，它们都使用相同的深灰色代码。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="abe5" class="mn la iq mj b gy mo mp l mq mr">/*<br/> * File: text.js<br/> */</span><span id="f1d4" class="mn la iq mj b gy ms mp l mq mr">function Title(props) {<br/>  return (<br/>    &lt;h1 style={{color: "#3A3B3C"}}&gt;<br/>      {props.title}<br/>    &lt;/h1&gt;<br/>  );<br/>}</span><span id="d8e1" class="mn la iq mj b gy ms mp l mq mr">function Subtitle(props) {<br/>  return (<br/>    &lt;h2 style={{color: "#3A3B3C"}}&gt;<br/>      {props.title}<br/>    &lt;/h2&gt;<br/>  );<br/>}</span><span id="9d83" class="mn la iq mj b gy ms mp l mq mr">function Paragraph(props) {<br/>  return (<br/>    &lt;p style={{color: "#3A3B3C"}}&gt;<br/>      {props.text}<br/>    &lt;/p&gt;<br/>  );<br/>}</span></pre><p id="c40b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，如果你要决定明天采用哪种不同的灰色调，你就必须手工更换每一个出现的颜色代码，确保不要忘记任何一个，这确实需要投入比它应该投入的更多的精力和工作。</p><p id="bb7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确的方法是创建一个名为<code class="fe mt mu mv mj b">colours</code>的新常量文件，其中包含该色阶的值，并在整个应用程序中代表唯一的真值来源。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="77c0" class="mn la iq mj b gy mo mp l mq mr">/*<br/> * File: colours.js<br/> */</span><span id="3dd1" class="mn la iq mj b gy ms mp l mq mr">export default {<br/>  DARK_GRAY: <!-- -->'#3A3B3C'<br/>};</span></pre><p id="a4a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，下一次您想要更新它时，只有一个快速变化适用。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="bd4c" class="mn la iq mj b gy mo mp l mq mr">/*<br/> * File: text.js<br/> */</span><span id="be14" class="mn la iq mj b gy ms mp l mq mr">import { DARK_GRAY } from '../constants/colours';</span><span id="0b32" class="mn la iq mj b gy ms mp l mq mr">function Title(props) {<br/>  return (<br/>    &lt;h1 style={{color: DARK_GRAY}}&gt;<br/>      {props.title}<br/>    &lt;/h1&gt;<br/>  );<br/>}</span><span id="9fd5" class="mn la iq mj b gy ms mp l mq mr">function Subtitle(props) {<br/>  return (<br/>    &lt;h2 style={{color: DARK_GRAY}}&gt;<br/>      {props.title}<br/>    &lt;/h2&gt;<br/>  );<br/>}</span><span id="424d" class="mn la iq mj b gy ms mp l mq mr">function Paragraph(props) {<br/>  return (<br/>    &lt;p style={{color: DARK_GRAY}}&gt;<br/>      {props.text}<br/>    &lt;/p&gt;<br/>  );<br/>}</span></pre><h1 id="0b7f" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">示例 2:相同的域逻辑</h1><p id="a2f0" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在让我们考虑以下两个函数<code class="fe mt mu mv mj b">editPost</code>和<code class="fe mt mu mv mj b">deletePost</code>，它们分别用于在博客平台如 media 上编辑和删除帖子。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="5597" class="mn la iq mj b gy mo mp l mq mr">function editPost(userId, postId) {<br/>  const post = database.fetch(postId);</span><span id="643a" class="mn la iq mj b gy ms mp l mq mr">  if (post &amp;&amp; post.ownerId === userId) {<br/>    // Edit post<br/>  } else {<br/>    // Throw error<br/>  }<br/>}</span><span id="4cb4" class="mn la iq mj b gy ms mp l mq mr">function deletePost(userId, postId) {<br/>  const post = database.fetch(postId);<br/>  <br/>  if (post &amp;&amp; post.ownerId === userId) {<br/>    // Delete post<br/>  } else {<br/>    // Throw error<br/>  }<br/>}</span></pre><p id="1ad9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，用于检查用户是否被允许执行这些操作的相同验证逻辑在两个函数中被复制，这导致了两个问题。</p><p id="4404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个是，如果逻辑随着时间的推移而改变，它将不得不再次复制，如果不小心的话，这可能会引入错误。</p><p id="6b18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个是，这些功能被赋予了处理其范围之外的业务逻辑的责任，而不是单独做它们应该做的事情——即更新和删除。</p><p id="24b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，合适的做法是将这个逻辑提取到一个单独的组件中，这反过来将使这些功能同时摆脱这两个问题。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="93b4" class="mn la iq mj b gy mo mp l mq mr">function isUserPermitted(userId, postId) {<br/>  const post = database.fetch(postId);<br/>  <br/>  return post &amp;&amp; post.ownerId === userId;<br/>}</span><span id="88b3" class="mn la iq mj b gy ms mp l mq mr">function editPost(userId, postId, data) {<br/>  if (!isUserPermitted(userId, postId)) {<br/>    // Throw error<br/>  }<br/>  // Edit post<br/>}</span><span id="4a67" class="mn la iq mj b gy ms mp l mq mr">function deletePost(userId, postId) {<br/>  if (!isUserPermitted(userId, postId)) {<br/>    // Throw error<br/>  }<br/>  // Delete post<br/>}</span></pre><h1 id="b43b" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">示例 3:不同的域逻辑</h1><p id="32dd" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">最后，让我们假设我们正在运行一个实现以下两个功能的电子商务平台，<code class="fe mt mu mv mj b">getAmountWithVAT</code>计算客户必须为一个订单支付的金额(包括增值税)和<code class="fe mt mu mv mj b">getLatePaymentPenalties</code>计算如果客户没有按时付款将在账单上应用的罚款。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="275a" class="mn la iq mj b gy mo mp l mq mr">function getAmountWithVAT(amount) {<br/>  const VAT = 0.20;</span><span id="e15d" class="mn la iq mj b gy ms mp l mq mr">  return amount + (amount * VAT);<br/>}</span><span id="110b" class="mn la iq mj b gy ms mp l mq mr">function getLatePaymentPenalties(amount) {<br/>  const penalty = 0.20;</span><span id="954f" class="mn la iq mj b gy ms mp l mq mr">  return amount + (amount * penalty);<br/>}</span></pre><p id="1b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这两个函数似乎共享相同的逻辑，例如，您可能想通过将它们合并成一个名为<code class="fe mt mu mv mj b">addPercentage</code>的函数来重构代码，但是在实践中，这被证明是一个非常糟糕的想法，因为这两个函数实际上并不共享相同的业务领域。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="d55b" class="mn la iq mj b gy mo mp l mq mr">function addPercentage(amount, percentage) {<br/>  return amount + (amount * percentage);<br/>}</span></pre><p id="bde4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，如果明天您决定不仅对逾期付款应用固定费用，而且应用每周增加 10%的累进费用，您将不得不将这个<code class="fe mt mu mv mj b">addPercentage</code>函数再次拆分成两个不同的函数，以便能够实现您的新逻辑并摆脱您之前创建的耦合。</p><p id="d6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，请确保您选择重构的代码片段实际上共享相同的业务领域，并努力记住，有时看似重复的知识只是纯粹的巧合。</p><h1 id="6f98" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="3efc" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">最后，为了避免陷入创建不必要或错误的抽象的陷阱，这些抽象最终可能会破坏另一个重要的编程原则，称为 YAGNI——代表<em class="ky">你不会需要它</em>——请记住代码复制并不自动意味着干违反原则，但知识复制会。</p><h1 id="ac4d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">下一步是什么？</h1><p id="66cc" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">不要忘记👏🏻如果你喜欢读我的作品！</p><p id="7989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👉你喜欢这种内容？在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《如何使用 Express framework 构建生产就绪的分层认证微服务》一书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">构建分层微服务</strong> </a>，该书从第一行代码到最后一行文档都符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>