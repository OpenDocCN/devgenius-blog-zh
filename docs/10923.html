<html>
<head>
<title>PHP — P109: Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP — P109:递归</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/php-p109-recursion-f19657ac95e9?source=collection_archive---------6-----------------------#2022-12-07">https://blog.devgenius.io/php-p109-recursion-f19657ac95e9?source=collection_archive---------6-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/508e44dffc27a68e55364688b6af615a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un4FN_LEOYzoaA4lchyXDQ.jpeg"/></div></div></figure><p id="61b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我转到 Laravel 之前，递归是 PHP 的最后一个主题。递归不是 PHP 的主题，但是我经常被问到这个问题，所以我想我们应该写一篇关于它的文章。这是一次有趣的经历，感谢您阅读这个 PHP 系列。</p><p id="3e67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是递归？你可以深入了解它，但为了简单起见，它是一个从函数体内部调用自身的函数。实际上，这是一种解决问题的方法，通过使用函数作为解决问题的手段，从较小的问题中产生解决方案。</p><p id="366e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们构建一个逐步调用自身的函数。</p><p id="4324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们将创建一个接受整数的函数。我们将从<code class="fe kw kx ky kz b">1</code>到<code class="fe kw kx ky kz b">n</code>取每个整数，并将它们相加。一旦完成，我们将回复您。在我们使用递归函数之前，先用一个<code class="fe kw kx ky kz b">for</code>循环。所以，如果我们说<code class="fe kw kx ky kz b">n = 5</code>，我们将从<code class="fe kw kx ky kz b">1 + 2 + 3 + 4 + 5 = 15</code>开始得到<code class="fe kw kx ky kz b">15</code>。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="b471" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>// Result should be: 1 + 2 + 3 + 4 + 5 = 15<br/>$sum = 0;<br/>$n = 5;<br/><br/>for ($i = 1; $i &lt;= $n; $i++) {<br/>    $sum += $i;<br/>}<br/><br/>var_dump($sum);</span></pre><p id="6ae9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以用我们的<code class="fe kw kx ky kz b">for</code>循环以相反的顺序进行。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="e840" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>// Result should be: 5 + 4 + 3 + 2 + 1 = 15<br/>$sum = 0;<br/>$n = 5;<br/><br/>for ($i = $n; $i &gt; 0; $i--) {<br/>    $sum += $i;<br/>}<br/><br/>var_dump($sum);</span></pre><p id="bc25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以把它可视化了，我们可以开始构建递归函数了。让我们一步一步来。首先，让我们创建函数。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="7711" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function recursiveSum( $n ) {<br/>    // implement recursion<br/>}</span></pre><p id="28c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道我们的函数需要接收一个参数，比如<code class="fe kw kx ky kz b">$n</code>，它需要将从<code class="fe kw kx ky kz b">1</code>到<code class="fe kw kx ky kz b">$n</code>的所有整数相加并返回总和。</p><p id="3f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道你在想什么。我们能不能不把 for 循环塞进这里？:)当然可以，但那不是递归函数。</p><p id="3b78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你以前从未见过递归函数，准备好大吃一惊吧。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="6a01" class="li lj iq kz b be lk ll l lm ln">function recursiveSum( $n ) : int<br/>{<br/>    return $n + recursiveSum($n - 1);<br/>}</span></pre><p id="747d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？让我们插入一个数字，看看会发生什么。让我们从像<code class="fe kw kx ky kz b">$n = 3</code>这样的小东西开始。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="6f22" class="li lj iq kz b be lk ll l lm ln">recursiveSum( 3 );<br/>// return 3 + recursiveSum(3 - 1) OR return 3 + recursiveSum(2)<br/>// We're now at $n = 2<br/>recursiveSum( 2 );<br/>// return 2 + recursiveSum(2 - 1) OR return 3 + recursiveSum(1)<br/>// This is where we want to stop, but our function keeps going.</span></pre><p id="3f30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还没有准备好遍历这个例子，因为递归永远不会停止。它将无限期地继续下去，或者直到 PHP 超时。我们需要阻止这一切。这意味着，如果我们把 1 作为参数传递，我们不需要做任何事情；我们只需要将 1 返回给用户。任何小于 1 的值都应该被忽略。让我们实现这两个检查。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="4877" class="li lj iq kz b be lk ll l lm ln">function recursiveSum( $n ) : int<br/>{<br/>    if ($n &lt; 1) {<br/>        return 0;<br/>    }<br/><br/>    if ($n == 1) {<br/>        return 1;<br/>    }<br/><br/>    return $n + recursiveSum($n - 1);<br/>}</span></pre><p id="3dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有人输入小于<code class="fe kw kx ky kz b">1</code>的内容，我们可能会抛出一个错误，但是为了简单起见，我们将返回<code class="fe kw kx ky kz b">0</code>。让我们来看几个场景。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="f1b3" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>recursiveSum(0); // returns 0<br/>recursiveSum(-42); // returns 0</span></pre><p id="c1b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的每一个都将返回<code class="fe kw kx ky kz b">0</code>，因为我们首先检查它，并且函数停止执行。让我们看看如果我们完全通过<code class="fe kw kx ky kz b">1</code>会发生什么。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="4f63" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>recursiveSum(1); // returns 1</span></pre><p id="12cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，因为跳过了第一次检查，所以返回<code class="fe kw kx ky kz b">1</code>。现在，当我们经过<code class="fe kw kx ky kz b">2</code>时会发生什么？</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="53ac" class="li lj iq kz b be lk ll l lm ln">recursiveSum(2);<br/>// Skips both of the checks, since it passes both of them, and goes to the final step<br/>// return 2 + recursiveSum(2 - 1) or return 2 + recursiveSum(1)<br/>recursiveSum(1);<br/>// We know what the recursiveSum of 1 is. We just did it, it's 1!<br/>// Since 1 is returned we can now substitute recursiveSum(1) with 1<br/>// i.e. return 2 + recursiveSum(1) EQUALS return 2 + 1;<br/>// We get 3!</span></pre><p id="6958" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们继续用<code class="fe kw kx ky kz b">3</code>作为我们的论点会怎么样。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="18d8" class="li lj iq kz b be lk ll l lm ln">recursiveSum(3)<br/>  = 3 + recursiveSum(2)<br/>    = 2 + recursiveSum(1)<br/>    = 2 + 1<br/>  = 3 + 3</span></pre><pre class="lo le kz lf bn lg lh bi"><span id="852e" class="li lj iq kz b be lk ll l lm ln">recursiveSum(3);<br/>// Skips both of the checks, since it passes both of them, and goes to the final step<br/>// return 3 + recursiveSum(3 - 1) OR return 3 + recursiveSum(2)<br/>recursiveSum(2);<br/>// Skips both of the checks, since it passes both of them, and goes to the final step<br/>// return 2 + recursiveSum(2 - 1) or return 2 + recursiveSum(1)<br/>recursiveSum(1);<br/>// We know what the recursiveSum of 1 is. We just did it, it's 1!<br/>// Since 1 is returned we can now substitute recursiveSum(1) with 1<br/>// i.e. return 2 + recursiveSum(1) EQUALS return 2 + 1;<br/>// We now know what recursiveSum(2) equals. It's 3! We substitute recursiveSum(2) with 3<br/>// i.e. return 3 + recursiveSum(2) EQUALS return 3 + 3<br/>// We get 6!</span></pre><p id="69c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你能看到这是如何深入的。另一种思考方式是这样的，如果你还是不明白的话。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="36dd" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function one() {<br/>    return 1;<br/>}<br/><br/>function two() {<br/>    return 2;<br/>}<br/><br/>function three() {<br/>    return 3;<br/>}<br/><br/>$a = one() + two() + three();<br/>var_dump($a);</span></pre><p id="f9fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们有三个不同的功能:<code class="fe kw kx ky kz b">one</code>、<code class="fe kw kx ky kz b">two</code>和<code class="fe kw kx ky kz b">three</code>。在计算时，它们都返回一个整数值。所以<code class="fe kw kx ky kz b">$a = one() + two() + three();</code>产生<code class="fe kw kx ky kz b">6</code>。让我们稍微改写一下。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="4e35" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function one() {<br/>    return 1;<br/>}<br/><br/>function two() {<br/>    return 2;<br/>}<br/><br/>function three() {<br/>    return 3;<br/>}<br/><br/>function result () {<br/>    return one() + two() + three();<br/>}<br/><br/>$a = result();<br/>var_dump($a);</span></pre><p id="658f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">result</code>函数调用其他函数。一旦它们被评估，它们被加在一起并返回结果。所以，如果函数调用自己，有什么区别。差别不大。这似乎是最难理解的概念，所以让我们再看一个例子。我们将创建一个最简单的函数，名为<code class="fe kw kx ky kz b">testFunction</code>，它只返回传递给它的参数。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="dc40" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function testFunction($n) {<br/>    return $n;<br/>}</span></pre><p id="b0a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以给它传递不同的参数，让它返回不同的结果。因此，如果我们想复制我们的递归功能，我们可以这样做。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="88ef" class="li lj iq kz b be lk ll l lm ln">function testFunction($n) {<br/>    return $n;<br/>}<br/><br/>$n = 3;<br/>$result = testFunction($n) + testFunction($n - 1) + testFunction($n - 2);<br/>var_dump($result);</span></pre><p id="e205" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到了什么？</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="3ece" class="li lj iq kz b be lk ll l lm ln">testFunction($n)<br/>   = testFunction(3)<br/>   = 3<br/><br/>testFunction($n - 1)<br/>   = testFunction(3 - 1)<br/>   = testfunction(2)<br/>   = 2<br/><br/>testFunction($n - 2)<br/>   = testFunction(3 - 2)<br/>   = testFunction(1)<br/>   = 1</span></pre><p id="bab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果出来到<code class="fe kw kx ky kz b">3 + 2 + 1 = 6</code>。我知道在这一点上这有点过了，但是我希望你能看到当你从内部调用一个函数时会发生什么。它到达某个基本情况，然后返回。再加上其他东西的结果被返回，如此类推，直到你到达顶端。</p><p id="b2ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再看一遍这个例子，自己走一遍。把它写出来，你会发现它是有意义的，如果它还没有的话。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="a1fe" class="li lj iq kz b be lk ll l lm ln">function recursiveSum( $n ) : int<br/>{<br/>    if ($n &lt; 1) {<br/>        return 0;<br/>    }<br/><br/>    if ($n == 1) {<br/>        return 1;<br/>    }<br/><br/>    return $n + recursiveSum($n - 1);<br/>}</span></pre><h1 id="8b5a" class="lp lj iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">回文测验</h1><p id="b7d7" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我想我们已经准备好看一些例子了。对于第一个例子，让我们创建一个名为<code class="fe kw kx ky kz b">isPalindrome</code>的函数来测试一个字符串是否是回文。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="5ef8" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function isPalindrome($word) <br/>{<br/>    if ( empty($word) ) {<br/>        return true;<br/>    }<br/><br/>    if ( $word[0] == $word[ strlen($word) - 1 ] ) {<br/>        return isPalindrome( substr($word, 1, -1) );<br/>    }<br/><br/>    return false;<br/>}<br/><br/>var_dump( isPalindrome("") );<br/>var_dump( isPalindrome("dino") );<br/>var_dump( isPalindrome("dinoonid") );<br/>var_dump( isPalindrome("dinonid") );<br/>var_dump( isPalindrome("hello") );</span></pre><p id="6633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们浏览一下示例。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="227c" class="li lj iq kz b be lk ll l lm ln">isPalindrome("");<br/>// enters the isPalindrome function.<br/>// Since the argument $word is set to an empty string, we pass the first<br/>// test: empty($word). Since it passes, it returns true.</span></pre><pre class="lo le kz lf bn lg lh bi"><span id="53b7" class="li lj iq kz b be lk ll l lm ln">isPalindrome("dino");<br/>// enters the isPalindrome function<br/>// It's not an empty string so it skips the first test: empty($word)<br/>// Next, it checks whether the first character of the $word is equal to<br/>// the last character in the $word. Since d does not equal o, it skips it.<br/>// It sees false and returns false.</span></pre><pre class="lo le kz lf bn lg lh bi"><span id="a555" class="li lj iq kz b be lk ll l lm ln">isPalindrome("dinoonid")<br/>   = isPalindrome("inooni")<br/>      = isPalindrome("noon")<br/>         = isPalindrome("oo")<br/>            = isPalindrome("")<br/>            = true<br/>         = true<br/>      = true<br/>   = true<br/>= true </span></pre><ul class=""><li id="3a1c" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">isPalindrome(“dinoonid”)</code>进入<code class="fe kw kx ky kz b">isPalindrome</code>功能。</li><li id="46a3" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它不是一个空字符串，所以它跳过了第一个测试:<code class="fe kw kx ky kz b">empty($word)</code>。</li><li id="10e5" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">接下来，检查<code class="fe kw kx ky kz b">$word</code>的第一个字符是否等于<code class="fe kw kx ky kz b">$word</code>的最后一个字符。</li><li id="e871" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">由于<code class="fe kw kx ky kz b">d</code>等于<code class="fe kw kx ky kz b">d</code>，所以进入体内。</li><li id="dbf6" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们再次调用<code class="fe kw kx ky kz b">isPalindrome</code>函数，并传递给它一个子字符串。</li><li id="70a8" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们去掉第一个字符和最后一个字符。</li><li id="037f" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们叫，<code class="fe kw kx ky kz b">isPalindrome(“inooni”)</code>。</li><li id="b7ac" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它再次经历相同的过程，并调用<code class="fe kw kx ky kz b">isPalindrome(“noon”)</code>。</li><li id="2a88" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它穿过<code class="fe kw kx ky kz b">isPalindrome</code>的身体，呼叫<code class="fe kw kx ky kz b">isPalindrome(“oo”)</code>。</li><li id="e8f6" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它穿过<code class="fe kw kx ky kz b">isPalindrome</code>的身体，呼叫<code class="fe kw kx ky kz b">isPalindrome(“”)</code>。</li><li id="3658" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">这次它返回<code class="fe kw kx ky kz b">true</code>。所以，我们知道<code class="fe kw kx ky kz b">isPalindrome(“”)</code>是真的。</li><li id="9017" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它返回 up，所以<code class="fe kw kx ky kz b">isPalindrome(“oo”)</code>也返回<code class="fe kw kx ky kz b">true</code>。</li><li id="7e50" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">然后它再次上升，<code class="fe kw kx ky kz b">isPalindrome(“noon”)</code>返回<code class="fe kw kx ky kz b">true</code>。</li><li id="83a3" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它上升并为<code class="fe kw kx ky kz b">isPalindrome(“inooni”)</code>返回<code class="fe kw kx ky kz b">true</code>。</li><li id="f8fe" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">最后，它为<code class="fe kw kx ky kz b">isPalindrome(“dinoonid”)</code>返回<code class="fe kw kx ky kz b">true</code>。</li></ul><p id="7a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将让您自己浏览其他示例。</p><h1 id="bd7d" class="lp lj iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">斐波那契递归函数</h1><p id="565c" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">不如来点简单的:斐波那契数列。斐波那契公式是 F<em class="nf">n</em>= F<em class="nf">n-2</em>+F<em class="nf">n-1</em>。我们通常知道前两个斐波那契数，F <em class="nf"> 0 = </em> 1，F <em class="nf"> 1 </em> = 1。有时，F <em class="nf"> 1 </em> = 1，F <em class="nf"> 2 </em> = 1。斐波那契是一个递归函数。我们可以说:</p><ul class=""><li id="5825" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = F(4–2) + F(4–1)</code></li><li id="bb31" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = F(2) + F(3)</code></li><li id="80e5" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们知道<code class="fe kw kx ky kz b">F(2) = 1</code>，所以<code class="fe kw kx ky kz b">F(4) = 1 + F(3)</code></li><li id="da6f" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = 1 + ( F(3–2) + F(3–1) )</code></li><li id="751e" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = 1 + ( F(1) + F(2) )</code></li><li id="0a0b" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们知道<code class="fe kw kx ky kz b">F(1) = 1</code>和<code class="fe kw kx ky kz b">F(2)</code>也等于<code class="fe kw kx ky kz b">1</code></li><li id="5019" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = 1 + ( 1 + 1 )</code></li><li id="3ae9" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">F(4) = 3</code></li></ul><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="50ae" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function fibonacci($num)<br/>{<br/>    if ($num &lt;= 2) {<br/>        return 1;<br/>    }<br/><br/>    return fibonacci($num - 1) + fibonacci($num - 2);<br/>}<br/><br/>var_dump(fibonacci(0));<br/>var_dump(fibonacci(1));<br/>var_dump(fibonacci(2));<br/>var_dump(fibonacci(3));<br/>var_dump(fibonacci(4));<br/>var_dump(fibonacci(5));</span></pre><p id="77c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 fibonacci 函数中，当我们调用<code class="fe kw kx ky kz b">fibonacci(0)</code>、<code class="fe kw kx ky kz b">fibonacci(1)</code>和<code class="fe kw kx ky kz b">fibonacci(2)</code>时，我们通过了<code class="fe kw kx ky kz b">$num ≤ 2</code>测试，该测试返回<code class="fe kw kx ky kz b">1</code>。所以，让我们看下一个例子:<code class="fe kw kx ky kz b">fibonacci(3)</code>。</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="22a3" class="li lj iq kz b be lk ll l lm ln">fibonacci(3)<br/>   = return fibonacci(2) + fibonacci(1)<br/>   = return 1 + 1 = 2<br/>= 2</span></pre><p id="1b2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个怎么样？</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="93a3" class="li lj iq kz b be lk ll l lm ln">fibonacci(4)<br/>   = return fibonacci(3) + fibonacci(2)<br/>   = return fibonacci(3) + 1<br/>      = (return fibonaci(2) + fibonacci(1)) + 1<br/>   = (return 1 + 1) + 1<br/>   = return 2 + 1<br/>= 3<br/>   </span></pre><ul class=""><li id="8d62" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">我们从调用<code class="fe kw kx ky kz b">fibonacci(4)</code>开始</li><li id="fde2" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">从大于<code class="fe kw kx ky kz b">2</code>的<code class="fe kw kx ky kz b">$num = 4</code>开始，第一次测试被跳过。</li><li id="f53b" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们输入返回语句:<br/> <code class="fe kw kx ky kz b">return fibonacci($num — 1) + fibonacci($num-2)</code> <br/> <code class="fe kw kx ky kz b">return fibonacci(4-1) + fibonacci(4-2)</code> <br/> <code class="fe kw kx ky kz b">return fibonacci(3) + fibonacci(2)</code></li><li id="2085" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">对于<code class="fe kw kx ky kz b">fibonacci(3)</code>，我们通过<code class="fe kw kx ky kz b">3</code>作为自变量。由于<code class="fe kw kx ky kz b">$num = 3</code>大于我们的测试值<code class="fe kw kx ky kz b">2</code>，我们进入下一步:<br/> <code class="fe kw kx ky kz b">return fibonacci($num-1) + fibonacci($num-2)</code> <br/> <code class="fe kw kx ky kz b">return fibonacci(3-1) + fibonacci(3-2)</code> <br/> <code class="fe kw kx ky kz b">return fibonacci(2) + fibonacci(1)</code></li><li id="a89a" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们又要深入了。调用<code class="fe kw kx ky kz b">fibonacci(2)</code>并返回<code class="fe kw kx ky kz b">1</code>。</li><li id="a74c" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们现在将<code class="fe kw kx ky kz b">fibonacci(2)</code>替换为<code class="fe kw kx ky kz b">1</code>，并评估下一个函数:<br/> <code class="fe kw kx ky kz b">return 1 + fibonacci(1)</code></li><li id="33f3" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们输入<code class="fe kw kx ky kz b">fibonacci(1)</code>，它返回<code class="fe kw kx ky kz b">1</code>。</li><li id="d92d" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们现在回到<code class="fe kw kx ky kz b">return 1 + fibonacci(1)</code>，可以用<code class="fe kw kx ky kz b">1</code> : <br/> <code class="fe kw kx ky kz b">return 1 + 1;</code>代替<code class="fe kw kx ky kz b">fibonacci(1)</code></li><li id="8a25" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">这在哪里被归还？以下表达式返回<code class="fe kw kx ky kz b">fibonacci(3)</code>:<code class="fe kw kx ky kz b">return fibonacci(3) + fibonacci(2)</code>。</li><li id="14c3" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">所以我们得到<code class="fe kw kx ky kz b">return 2 + fibonacci(2)</code>。</li><li id="61c4" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">我们输入<code class="fe kw kx ky kz b">fibonacci(2)</code>，得到<code class="fe kw kx ky kz b">1</code>。</li><li id="d7c6" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kw kx ky kz b">fibonacci(2)</code>替换为<code class="fe kw kx ky kz b">1</code> : <br/> <code class="fe kw kx ky kz b">return 2 + fibonacci(2)</code> <br/> <code class="fe kw kx ky kz b">return 2 + 1</code></li><li id="4861" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">为<code class="fe kw kx ky kz b">fibonacci(4)</code>返回值<code class="fe kw kx ky kz b">3</code>。</li></ul><p id="ecb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用递归有很多有趣的方式。当我在写我的算法书时，很难不对大多数算法使用递归。例如，下面是冒泡排序算法:</p><pre class="la lb lc ld gt le kz lf bn lg lh bi"><span id="597f" class="li lj iq kz b be lk ll l lm ln">&lt;?php<br/><br/>function bubbleSort(&amp;$sort, $length) {<br/><br/>    if ($length &lt;= 1) {<br/>        return;<br/>    }<br/><br/>    for ( $i = 0; $i &lt; $length - 1; $i++ ) {<br/>        if ( $sort[$i] &gt; $sort[$i + 1] ) {<br/>            $temp         = $sort[$i];<br/>            $sort[$i]     = $sort[$i + 1];<br/>            $sort[$i + 1] = $temp;<br/>        }<br/>    }<br/><br/>    bubbleSort($sort, $length - 1);<br/>}<br/><br/>$array = [78,39,14,56,88,94,108,5,15];<br/>$length = count($array);<br/><br/>bubbleSort($array, $length);<br/><br/>var_dump($array);</span></pre><p id="12eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会让你自己找出答案，或者你可以在这里阅读关于它的文章。是用 Java 写的，但是一样的东西:)。</p><p id="129f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">嗯，这就是所有的乡亲。拉勒维尔庄园见！创建这个 PHP 文章系列很有趣。希望你觉得它有教育意义。</strong></p><div class="ng nh gp gr ni nj"><a href="https://medium.com/geekculture/constructing-the-bubble-sort-algorithm-77fa5e908794" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">构造冒泡排序算法</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">讲述如何在 Java 中从头开始构建冒泡排序算法的逻辑。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://github.com/dinocajic/php-youtube-tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub-dinocajic/PHP-YouTube-tutorials:PHP YouTube 教程的代码</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">PHP YouTube 教程的代码确保你已经安装了 Docker。克隆回购。运行以下命令…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jw nj"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/21e575df7fd0a644e17c90d176185272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S5ofpc7eOSoPgPCB.jpeg"/></div></figure><p id="bd1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dino Cajic 目前是<a class="ae oh" href="http://absolutebiotech.com/" rel="noopener ugc nofollow" target="_blank"> Absolute Biotech </a>的 IT 负责人，该公司是<a class="ae oh" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae oh" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank"> Absolute 抗体</a>、<a class="ae oh" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae oh" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank"> Everest BioTech </a>、<a class="ae oh" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank"> Nordic MUbio </a>和<a class="ae oh" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的母公司。他还担任我的自动系统的首席执行官。他拥有计算机科学学士学位，辅修生物学，并拥有十多年的软件工程经验。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="09eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae oh" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae oh" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae oh" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="0e9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读 Dino Cajic(以及 Medium 上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。T25】</p></div></div>    
</body>
</html>