<html>
<head>
<title>Head First Java- Chapter 11 (exception handling)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Head First Java-第 11 章(异常处理)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/head-first-java-chapter-11-exception-handling-acdd970d4265?source=collection_archive---------2-----------------------#2022-07-10">https://blog.devgenius.io/head-first-java-chapter-11-exception-handling-acdd970d4265?source=collection_archive---------2-----------------------#2022-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ul class=""><li id="94ec" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Java 的异常处理机制是处理运行时突然出现的“异常情况”的一种简洁明了的方式；它允许您将所有的错误处理代码放在一个易于阅读的地方。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/ca27f821d093a39ff9d7e5b75c5c9ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*_jmvgI6xrUB2k4eOeiXKUw.png"/></div></figure><ul class=""><li id="d5bd" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">编译器需要知道你知道你在调用一个有风险的方法。如果你把有风险的代码放在一个 try/catch 中，编译器会放松。try/catch 块告诉编译器，您知道在您调用的方法中可能会发生异常情况，并且您已经准备好处理它。那个编译器不在乎你怎么处理它；它只在乎你说你在处理它。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kk"><img src="../Images/3963252c09736307aa5489fa0345ecb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sexs0D6MghyjOPYpwpRJCg.png"/></div></div></figure><p id="c077" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated"><strong class="jm io">已检查和未检查的异常:</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi le"><img src="../Images/d8cbdc3805474cd1a79d500b761ffd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTK2PejXUhQgL1XHyOEZlw.png"/></div></div></figure><ul class=""><li id="a787" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">编译器会检查不是 RuntimeException 子类的异常。它们被称为“<strong class="jm io">检查异常</strong>”。</li><li id="795e" class="jk jl in jm b jn lf jp lg jr lh jt li jv lj jx jy jz ka kb bi translated">编译器不检查运行时异常。他们被称为(此处大惊喜)“<strong class="jm io">未检查的例外</strong>”。您可以抛出、捕捉和声明 RuntimeExceptions，但您不必这样做，编译器也不会检查。</li></ul><p id="448d" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">除了 RuntimeExceptions 之外，编译器检查所有内容。</p><ol class=""><li id="8fa9" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx lk jz ka kb bi translated">如果在代码中抛出异常，必须在方法声明中使用 throws 关键字来声明它。</li><li id="05d0" class="jk jl in jm b jn lf jp lg jr lh jt li jv lj jx lk jz ka kb bi translated">如果你调用一个抛出异常的方法，你必须承认你知道异常的可能性。让编译器满意的一种方法是将调用包装在 try/catch 中。</li></ol><blockquote class="ll lm ln"><p id="177b" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">要点</p><p id="e339" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">当某个东西在运行时失败时，方法可以抛出异常。</p><p id="c4dc" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">异常总是异常类型的对象。(正如您在多态性章节中所记得的，这意味着该对象来自一个在其继承树上某处有异常的类。)</p><p id="4ee6" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">编译器不会关注 RuntimeException 类型的异常。RuntimeException 不一定要在 try/catch 中声明或包装(尽管您可以自由地做这两件事中的一件或两件)</p><p id="1ebd" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">编译器关心的所有异常都被称为“检查过的异常”，这实际上意味着编译器检查过的异常。编译器检查只排除 RuntimeExceptions。根据规则，所有其他异常都必须在代码中得到确认。</p><p id="1f91" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">一个方法抛出一个带有关键字 throw 的异常，后跟一个新的异常对象:</p><p id="0abb" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated"><strong class="jm io">抛出新的 NoCaffeineException()；</strong></p><p id="1bcc" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">可能引发检查异常的方法必须用 throws 异常声明来声明它。</p><p id="b7f1" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">如果您的代码调用检查异常抛出方法，它必须向编译器保证已经采取了预防措施。</p><p id="aa55" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">如果您准备好处理异常，将调用包装在 try/catch 中，并将您的异常处理/恢复代码放在 catch 块中。</p><p id="fa6d" class="kp kq lo jm b jn jo kr ks jp jq kt ku lp kv kw kx lq ky kz la lr lb lc ld jx ig bi translated">如果您不准备处理异常，您仍然可以通过正式“回避”异常来让编译器高兴。</p></blockquote><p id="25f5" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated"><strong class="jm io">try/catch 块中的流量控制</strong></p><ul class=""><li id="f9dd" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">当你调用一个有风险的方法时，有两种情况会发生。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/25a4a5c12e77f797090d47f57cfb9942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEYcklj3V3yWmFn5WZbDBg.png"/></div></div></figure><p id="eea9" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated"><strong class="jm io">最终阻塞</strong></p><ul class=""><li id="fa5a" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">这是放置代码的地方，这些代码必须在没有任何异常同意的情况下运行。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/56f826d929153423c9d61250eea50e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*SNC71dAzL19coeYz5ixk7g.png"/></div></figure><ul class=""><li id="e3eb" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如果没有 finally，你必须在 try 和 catch 中都放上 turnOvenOff()，因为无论如何你都必须关掉烤箱。</li><li id="0471" class="jk jl in jm b jn lf jp lg jr lh jt li jv lj jx jy jz ka kb bi translated">该块允许您将所有清理代码放在一个地方，而不是像下面这样复制代码:</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/3e35b7c00a18a1ad69209da46c1cad99.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*RNdiNi9rmvAMXeAn8aYNuw.png"/></div></figure><ul class=""><li id="17fb" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="jm io">如果 try 块失败(异常):</strong></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/2707347bad3f1f1e81d003769509f068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8OlyfrkWU7Bu92eet3Jqg.png"/></div></div></figure><ul class=""><li id="7871" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="jm io">如果 try 块成功(无异常):</strong></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/ebdac18cf8c8f3b73ff61f1d42415b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNWh68ndY850LETViorvbQ.png"/></div></div></figure><ul class=""><li id="d10a" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="jm io">如果 try 或 catch 块有返回语句:</strong></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/2a54975cc7c18b16abe5ea1e21b56dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xj3C1wgPETLObc6DjbWNew.png"/></div></div></figure><p id="71de" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">现在让我们检查两个用例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4014" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">此处变量“测试”的值为“是”。</p><p id="319d" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">所以我们编译后得到这个结果。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/dea171ac0b560f6c180a28abd99f6440.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*9bxyHu9I7ghpFbBxuy5mFA.jpeg"/></div></figure><p id="f54e" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">当我将变量“test”的值改为“no”时。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mb"><img src="../Images/f722ea5ebf4c36f4531756b7d8f6dba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*7_35Q_8_STIZ3AMXCD46Dw.jpeg"/></div></div></figure><p id="30f0" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated"><strong class="jm io">捕捉多个异常:</strong></p><p id="0f6e" class="pw-post-body-paragraph kp kq in jm b jn jo kr ks jp jq kt ku jr kv kw kx jt ky kz la jv lb lc ld jx ig bi translated">编译器会确保你已经处理了所有被你调用的方法抛出的异常。将 catch 块一个接一个地堆叠在 try 下。有时你堆叠 catch 块的顺序很重要，但是我们稍后会讲到。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/64d8d96111c70d30eaab3abde5d4acda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmTRXOI6tyj9EVCvvAT2Fw.png"/></div></div></figure><ul class=""><li id="46c5" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">多个 catch 块必须从最小到最大排序。</li><li id="558f" class="jk jl in jm b jn lf jp lg jr lh jt li jv lj jx jy jz ka kb bi translated">Catch 块不像重载方法那样选择最佳匹配。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi md"><img src="../Images/3388dc66e0ee5f182c754fe606dd78cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*ZIfLI0cBX77i4koGC9OykA.png"/></div></figure></div></div>    
</body>
</html>