<html>
<head>
<title>Writing an X86–64 Assembly Language Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写 X86–64 汇编语言程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-84e2432cf16b?source=collection_archive---------2-----------------------#2021-11-28">https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-84e2432cf16b?source=collection_archive---------2-----------------------#2021-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d3a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第六部分:如何确定字符串长度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da7b6482f2d7ae4677c5313dcd217732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yTKewkoHrAxomQwM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="3180" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">本指南是系列的第六部分</h1><ul class=""><li id="4901" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第一部分:<a class="ae kv" href="https://medium.com/@tony.oreglia/getting-started-writing-assembly-language-8ecc116f3627" rel="noopener">开始编写汇编语言</a></li><li id="cb16" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">第二部分:<a class="ae kv" href="https://medium.com/@tony.oreglia/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a" rel="noopener">寻找编写汇编语言的高效开发周期</a></li><li id="0f19" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">第三部分:<a class="ae kv" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-648b6005e8e" rel="noopener">编写 X86–64 汇编语言程序:打印命令行参数</a></li><li id="bd33" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">第四部分:编写 X86–64 汇编语言程序:<a class="ae kv" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee" rel="noopener">发送函数参数并接收返回值</a></li><li id="5411" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">第五部分:编写 X86–64 汇编语言程序:<a class="ae kv" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">条件、跳转和循环</a></li><li id="90a7" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">第七部分:<a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-f847d4edf577" rel="noopener">快速参考</a></li></ul><h1 id="2d07" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何计算字符串长度</h1><p id="fe0c" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">为了计算字符串的长度，我们首先需要知道是什么决定了给定字符串的结尾。</p><p id="d7e7" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">内存中的字符串表示为指针。指向的位置是一个字节的数据，代表一个字符，后跟内存中连续的其他字符。重要的一点是，这个字节序列由字节<code class="fe nd ne nf ng b">0x00</code>终止。这被称为零终止字符，这是一种终止字符串的方法(例如，C 使用这种方法)。有一些对字符串进行编码的方法，我们在这里不做介绍。</p><p id="298f" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">例如，字符串“HELLO WORLD！”将在内存中保存以下值(以十六进制表示的二进制值):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6e14" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">因此，可以通过遍历字符串中的每个内存字节直到到达零终止字符来确定长度。这是如何实现的一个初步实现，但是如果你仔细观察，会发现有几个错误，看看你是否能发现这个代码片段的问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8b6b" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">如果你发现了问题，干得好。如果你只是想学习，请继续阅读。问题是[rdi]可能指向一个空字符串，所以在这种情况下[rdi]处的字符是 0x00。这是一个在编写解决方案时不考虑边角情况的典型例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0bf4" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">现在[rax] = 1，即使字符串的长度是 0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1793" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">现在程序指向内存中字符串的第一个字符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bb89" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">现在，[rax]可能等于 2，即使字符串长度是 0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e8c4" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">[rdi]处的字节不是 0x00，因为程序直接跳过了该字节。这个循环什么时候结束？程序不知道，因为它在看它不应该看的内存。</p><p id="5cb2" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">第二个 bug 是终值长了一个。长度不需要包括终止空字符。</p><p id="9146" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">该解决方案的修订版可能如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8134" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">当然，有一点重复的代码。也许您可以优化这个解决方案以避免重复。如果你有，请在评论中让人们知道！</p><p id="d767" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">我希望你喜欢这个系列。要了解更多，请查看我在制作这个系列时收集的资源<a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-f847d4edf577" rel="noopener">这里</a>。</p></div></div>    
</body>
</html>