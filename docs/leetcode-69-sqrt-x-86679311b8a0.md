# LeetCode 69: Sqrt(x)(用图像获取解决方案)

> 原文：<https://blog.devgenius.io/leetcode-69-sqrt-x-86679311b8a0?source=collection_archive---------0----------------------->

链接:→[https://leetcode.com/problems/sqrtx/](https://leetcode.com/problems/sqrtx/)

![](img/0af30454b047b51fad2782f4efb8ce59.png)

丹·克里斯蒂安·pădureț在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

![](img/29cd36fc549ec81429e58b74658211d1.png)

# 问题:→

给定一个非负整数`x`，计算并返回 `x`的平方根*。*

由于返回类型是整数，小数位数被**截断**，只返回结果的整数部分**。**

**注意:**不允许使用任何内置的指数函数或运算符，如`pow(x, 0.5)`或`x ** 0.5`。

**例 1:**

```
**Input:** x = 4
**Output:** 2
```

**例二:**

```
**Input:** x = 8
**Output:** 2
**Explanation:** The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
```

**约束:**

*   `0 <= x <= 231 - 1`

# 解决方案:→

这个解决方案可以使用**线性时间复杂度**轻松实现，如下所示

假设我们要求 9 的平方根，

1*1 = 1

2 * 2 = 4

**3 * 3 = 9**

所以，在这里， **3** 是结果，但是我们试图避免这种方法，

让我们看看二分搜索法的其他可能性。

同上，我们试图用**二分搜索法**求出 **9** 的平方根。

首先我们会放一些条件，比如，如果给定值是 **0** 或 **1** ，那么它的平方根是相同的，所以我们可以返回那个值，而不是做他们的计算，

![](img/ec8481d28878cf99c702ec4ceccd7e8a.png)

在二分搜索法，我们需要两个终点，在这两个终点之间，我们将努力取得结果，

![](img/00a9e64af5fcf6b9178ba6199cc379a2.png)

这里， **end** 我们取了 **x/2** ，这是因为，任何值(不包括 0 和 1)的平方根，总是小于或等于它的一半值，

比如，

**4** 的平方根是 2，即**等于**的 4/2。

**9** 的平方根是 3，比**小 9/2。**

**16** 的平方根是 4，小于**16/2，以此类推。**

因此，为了减少步骤，我们将用 **x/2 设置**结束**值。**

现在，我们将经历 while 循环条件，

![](img/74075103db2cd156bade7068fe29f3ca.png)

首先，我们将检查，

> **开始≤结束**=>**1 ≤( x/2)**=>**1 ≤( 9/2)**=>**1≤4**=>**真。**

![](img/bd00a495454847110a7daf3f3ca403cd.png)

现在，我们将尝试获取 **mid** 值，

> **中期** = > **(开始+结束)/2**=>**(1+4)/2**=>**(5/2)**=>**2。**

![](img/1b5fda295b6c4dd66230fcab39654881.png)

现在，我们将检查，

> **中期*中期>x**=>**2 * 2>9**=>**4>9**=>**假**。

![](img/56988706e8d345f3fcf923b2fcd81c37.png)

由于 **4 > 9** ，我们需要消除 **1，2** 值，因为我们得到的想法是，如果 **2 的平方**不会比 **9** 多**，那么 **1 的平方**也不会比 **9** 多。所以，**启动**值应该大于 **2** ，也就是 2 + 1 = **3** 。**

![](img/805e0a308210160b6c477f6ed430da66.png)

现在，对于下一次迭代，while 条件，

> **开始≤结束**=>**3 ≤( 4)**=>**真。**

![](img/a9368c91e6985d7177a28a341e9bc07a.png)

同样，我们将尝试获取 **mid** 值，

> **中期** = > **(开始+结束)/2**=>**(3+4)/2**=>**(7/2)**=>**3。**

![](img/7babc9f19f4173f07c51b33623cbe30d.png)

现在，我们将检查，

> **mid * mid>x**=>**3 * 3>9>=**9>9**=>**假。****

![](img/1c6a8193a1e1112f05e85d1c4fb06bdc.png)

> **开始** = **中期+1**=>**3+1**=>**4**

![](img/84d7532239ffd75afe88e6fad0552a1a.png)

现在，对于下一次迭代，while 条件，

> **开始≤结束**=>**4 ≤( 4)**=>**真。**

![](img/50e97959daba07e3eb72d86cc8a1a557.png)

同样，我们将尝试获取 **mid** 值，

> **中期** = > **(开始+结束)/2**=>**(4+4)/2**=>**(8/2)**=>**4。**

![](img/5c7503dfd4ebf58656cc87b738f067ee.png)

现在，我们将检查，

> **mid * mid>x**=>**4 * 4>9**=>**16>9**=>**真。**

![](img/f053555d256d3ac069a79bc67cb38267.png)

> **end**=**mid—1**=>**4–1**=>**3**

![](img/c8a6897b45c7cfe81d540fb311d78ca4.png)

现在，对于下一次迭代，while 条件，

> **开始≤结束**=>**4 ≤( 3)**=>**假。**

![](img/09fdafcbc0226f4b977749b95a2c9969.png)

现在，当条件变为**假**时。

现在，最后我们会回来，

![](img/e6bbddd6c4460ebe0a1016b9d92bd224.png)

哪一个是 **3、**这是我们的答案。

现在，让我们看看完整的源代码。

# 代码(Java): →

# 代码(Python): →

# 时间复杂度

既然我们在这里使用了二分搜索法，那么时间复杂度将是 **O(log(n))** 。

# 空间复杂性

由于我们没有使用任何额外的数组，所以，空间复杂度将是***【O(1)***。

感谢你阅读这篇文章，❤

如果我做错了什么？让我在评论中。我很想进步。

拍手声👏如果这篇文章对你有帮助。