<html>
<head>
<title>RelayHooks vs. RelayContainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中继书籍与中继容器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/relayhooks-vs-relaycontainers-fc179db4d1d1?source=collection_archive---------4-----------------------#2020-11-15">https://blog.devgenius.io/relayhooks-vs-relaycontainers-fc179db4d1d1?source=collection_archive---------4-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="02bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">React</strong></a><strong class="jp ir">+</strong><a class="ae kl" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Relay</strong></a><strong class="jp ir">+</strong><a class="ae kl" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">graph QL</strong></a>”combo 是目前构建任何浏览器 app 最先进、最简便的框架套件。在这三者中，Relay 相对来说比较难学，因为它的 API 在进化:容器→钩子。</p><p id="5587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，基于我在脸书的第一手经验，我将分享为什么新的继电器盒比继电器盒更好。</p><h1 id="d7e8" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">定义</h1><p id="f5ab" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">RelayContainer 是一个 React 组件，通常是中继组件树的根，如<strong class="jp ir"> QueryRenderer、FragmentContainer、PaginationContainer </strong>等。</p><p id="c3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> QueryRenderer </strong>处理获取查询，并使用 render prop 来呈现结果数据。</p><p id="883b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> FragmentContainer </strong>不会直接获取数据；相反，数据将由根处的<strong class="jp ir"> QueryRenderer </strong>祖先获取，它将聚合中继组件树所需的所有数据，并在<strong class="jp ir">单个往返行程</strong>中获取。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/226484e360d95c8bf3e246e656fe739b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*9ZWROcrNBBgIULBJ9qBXYw.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">relay 容器示例</figcaption></figure><p id="7a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RelayHooks 是一个类似于 ReactHooks 的 API，包括像 useFragment，useLazyLoadQuery 这样的 API。它将数据加载逻辑和 React 组件呈现代码分开。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/2a81dde2befb7bec43af6d47aced8479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFDYHHJl7J8_KqNKUG_cPg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">RelayHooks 示例</figcaption></figure><blockquote class="mg mh mi"><p id="9e6c" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">注意:<strong class="jp ir">中继组件将正确地互操作</strong>，不管它们是被写成中继钩子还是中继容器。</p></blockquote><h1 id="083e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">利益</h1><h2 id="5dfe" class="mn kn iq bd ko mo mp dn ks mq mr dp kw jy ms mt la kc mu mv le kg mw mx li my bi translated">简单的</h2><p id="4ce6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">钩子是有特定输入和输出的函数。比发生在高阶组件中的“<strong class="jp ir"> <em class="mj">魔法</em> </strong>”更清晰，你从上面传过去的道具和你在组件内部收到的道具是不一样的。</p><p id="8d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还允许我们不要用多层嵌套的高阶组件来污染 React 树，这些组件包装了您的实际组件，如 refetch 和 pagination 容器。</p><h2 id="7a24" class="mn kn iq bd ko mo mp dn ks mq mr dp kw jy ms mt la kc mu mv le kg mw mx li my bi translated">类型安全</h2><p id="6e21" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">钩子对于<a class="ae kl" href="http://flow.org" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">流</strong> </a>类型来说也要简单得多，使用中继钩子，我们能够保证比使用我们的 HOC/Renderer API 更好的类型安全性。</p><p id="ae61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们更容易推理，需要更少的间接性，并且更容易调试。</p><h2 id="05a0" class="mn kn iq bd ko mo mp dn ks mq mr dp kw jy ms mt la kc mu mv le kg mw mx li my bi translated">并发安全</h2><p id="5420" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">与容器相比，钩子有更多的功能，例如，通过与加载状态的悬念集成，并提供新的功能，例如直接呈现缓存在中继存储中的数据，这是以前没有的。</p><p id="fbc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还允许您使用更新的<strong class="jp ir">usePreloadedQuery</strong>API，减少了空渲染、意外的悬念和意外的过度获取。</p></div></div>    
</body>
</html>