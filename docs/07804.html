<html>
<head>
<title>Using Bull Queues in NestJS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 NestJS 应用程序中使用 Bull 队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-bull-queues-in-nestjs-application-dd8421b3f3b?source=collection_archive---------7-----------------------#2022-04-24">https://blog.devgenius.io/using-bull-queues-in-nestjs-application-dd8421b3f3b?source=collection_archive---------7-----------------------#2022-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在许多情况下，您将不得不处理异步的 CPU 密集型任务。尤其是当应用程序通过 REST API 请求数据时。REST 端点应该在有限的时间范围内做出响应。</p><p id="8c9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示我们如何使用队列来处理异步任务。我们将在一个简单的 NestJS 应用程序中使用 Bull 队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/8d418587ad24ac2c2d4a5aa21ef16d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*HolY2gNzQzZ1cX3a"/></div></figure><p id="5e04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">队列是一种遵循线性顺序的数据结构。在大多数系统中，队列就像一系列任务。发布者将消息或任务发布到队列。消费者提取该消息以进行进一步处理。这可以异步发生，为 CPU 密集型任务提供急需的喘息机会。一旦消费者使用了该消息，任何其他消费者都不能使用该消息。</p><p id="aa73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">牛市队列基于 Redis。在我之前的文章中，我介绍了如何在<a class="ae kq" href="https://betterjavacode.com/programming/adding-health-checks-in-nestjs-application" rel="noopener ugc nofollow" target="_blank"> NestJS 应用程序</a>中添加 Redis 或数据库的健康检查。</p><ul class=""><li id="093d" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">设置 NestJS 应用程序</li><li id="6cce" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">NestJS 应用程序中的 Bull 队列</li><li id="3631" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">实现处理器来处理队列数据</li><li id="f3c0" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">集成公牛仪表板</li><li id="f8d5" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">添加牛纸板类</li><li id="d8f3" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">添加控制器</li><li id="02cc" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">结论</li></ul><h1 id="24fb" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置 NestJS 应用程序</h1><p id="db60" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">作为演示的一部分，我们将创建一个简单的应用程序。我们将通过 csv 文件上传用户数据。控制器将接受该文件，并将其传递给队列。处理器将拾取排队的作业并处理文件，以将数据从 CSV 文件保存到数据库中。</p><p id="ec81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">nest new bullqueuedemo</code></p><p id="f317" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦这个命令为<code class="fe mi mj mk ml b">bullqueuedemo</code>创建了文件夹，我们将设置 Prisma ORM 来连接数据库。(注意-确保安装 prisma 依赖项。).</p><p id="33c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">npx prisma init</code></p><p id="3ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您使用的是 Windows 机器，运行 prisma init 时可能会遇到错误。考虑到所有的事情，设置一个环境变量来避免这个错误。</p><p id="6e28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">set PRISMA_CLI_QUERY_ENGINE_TYPE=binary</code> <code class="fe mi mj mk ml b">set PRISMA_CLIENT_ENGINE_TYPE=binary</code></p><p id="2b1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦模式被创建，我们将用我们的数据库表更新它。对于这个演示，我们正在创建一个表<code class="fe mi mj mk ml b">user</code>。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="508a" class="mq lg in ml b gy mr ms l mt mu">// This is your Prisma schema file,<br/>// learn more about it in the docs: https://pris.ly/d/prisma-schema<br/><br/>generator client {<br/>  provider = "prisma-client-js"<br/>  engineType = "binary"<br/>}<br/><br/>datasource db {<br/>  provider = "mysql"<br/>  url      = env("DATABASE_URL")<br/>}<br/><br/><br/>model User {<br/>  id    Int     @default(autoincrement()) @id<br/>  email String  @unique<br/>  first_name  String<br/>  last_name   String?<br/>}</span></pre><p id="f8ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们运行<code class="fe mi mj mk ml b">npm run prisma migrate dev</code>，它将创建一个数据库表。</p><p id="8921" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，到目前为止，我们已经创建了一个 NestJS 应用程序，并用 Prisma ORM 建立了我们的数据库。让我们看看我们必须为 Bull Queue 添加的配置。</p><h1 id="7a41" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">NestJS 应用程序中的 Bull 队列</h1><p id="6d58" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">安装<code class="fe mi mj mk ml b">@nestjs/bull</code>依赖关系。这个依赖封装了<a class="ae kq" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"> bull </a>库。我们将假设您已经安装并运行了<code class="fe mi mj mk ml b">redis</code>。默认情况下，Redis 将在端口 6379 上运行。</p><p id="b2ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在我们的<code class="fe mi mj mk ml b">.env</code>文件中添加<code class="fe mi mj mk ml b">REDIS_HOST</code>和<code class="fe mi mj mk ml b">REDIS_PORT</code>作为环境变量。为 Bull 安装两个依赖项，如下所示:</p><p id="4fb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">npm install @nestjs/bull</code> <code class="fe mi mj mk ml b">npm install @types/bull</code></p><p id="868e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们将通过向我们的 app 模块添加<code class="fe mi mj mk ml b">BullModule</code>来建立与 Redis 的连接。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="b3bb" class="mq lg in ml b gy mr ms l mt mu">@Module({<br/>  imports: [<br/>    BullModule.forRootAsync({<br/>      imports: [ConfigModule],<br/>      useFactory: async (configService: ConfigService) =&gt; ({<br/>        redis: {<br/>          host: configService.get('REDIS_HOST'),<br/>          port: Number(configService.get('REDIS_PORT')),<br/>        },<br/>      }),<br/>      inject: [ConfigService]<br/>    }),<br/>    BullModule.registerQueue({<br/>      name: 'file-upload-queue'<br/>    }), <br/>  ],<br/>  controllers: [AppController, BullBoardController],<br/>  providers: [UserService, PrismaService, FileUploadProcessor,],<br/>})<br/>export class AppModule {}</span></pre><p id="7583" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们正在注入 ConfigService。这个服务允许我们在运行时获取环境变量。有了这个，我们将能够在我们的应用程序中使用<code class="fe mi mj mk ml b">BullModule</code>。</p><p id="1880" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面的代码中看到的，我们有<code class="fe mi mj mk ml b">BullModule.registerQueue</code>，它注册了我们的队列<code class="fe mi mj mk ml b">file-upload-queue</code>。现在让我们将这个队列添加到我们的控制器中，在那里将使用它。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="ace8" class="mq lg in ml b gy mr ms l mt mu">@Controller('/api/bullqueuedemo')<br/>export class AppController {<br/>  constructor(@InjectQueue('file-upload-queue') private fileQueue: Queue) {<br/>    queuePool.add(fileQueue);<br/>  }<br/><br/>  @Post('/uploadFile')<br/>  @UseInterceptors(FileInterceptor("csv", {<br/>    storage: diskStorage({<br/>      destination: './csv',<br/>      fileName: (req, file, cb) =&gt; {<br/>        const randomName = Array(32).fill(null).map(() =&gt; (Math.round(Math.random() * cb(null, `${randomName}${extname(file.originalname)}`))))<br/>      }<br/>    })<br/>  }))<br/>  async uploadCsvFile(@UploadedFile() file): Promise {<br/>    const job = await this.fileQueue.add('csvfilejob', {file: file});<br/>    console.log(`created job ${ job.id}`);<br/>  }<br/><br/>  @Get('/')<br/>  async getHello(): Promise {<br/>    return "Hello World";<br/>  }<br/>}</span></pre><p id="5377" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们慢慢地看一下这段代码，以理解发生了什么。</p><ul class=""><li id="5ad3" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">在构造函数中，我们注入了队列<code class="fe mi mj mk ml b">InjectQueue('file-upload-queue')</code>。</li><li id="5d11" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">我们的 POST API 用于上传 csv 文件。</li><li id="4be1" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">我们正在使用一个<a class="ae kq" href="https://docs.nestjs.com/techniques/file-upload" rel="noopener ugc nofollow" target="_blank">文件拦截器</a>。这是 NestJS 提供的一个特性，用于拦截请求并从请求中提取文件。这个拦截器有两个参数<code class="fe mi mj mk ml b">fieldName</code>和<code class="fe mi mj mk ml b">options</code>。</li><li id="8750" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated"><code class="fe mi mj mk ml b">storage</code>选项允许我们将上传的文件存储在当前执行目录下的一个名为<code class="fe mi mj mk ml b">csv</code>的文件夹中。上传的文件将以随机生成的名称和扩展名<code class="fe mi mj mk ml b">.csv</code>重命名。</li><li id="d7bf" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">在方法<code class="fe mi mj mk ml b">uploadCsvFile</code>中，我们接收上传的文件。这来自我们的文件拦截器。我们使用注入队列来添加一个名为<code class="fe mi mj mk ml b">csvfilejob</code>的作业和包含该文件的数据。</li></ul><h1 id="10b8" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">实现处理器来处理队列数据</h1><p id="abce" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">此后，我们在队列中添加了一个任务<code class="fe mi mj mk ml b">file-upload-queue</code>。现在为了进一步处理这个任务，我们将实现一个处理器<code class="fe mi mj mk ml b">FileUploadProcessor</code>。</p><p id="2fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们用<code class="fe mi mj mk ml b">@Processor('file-upload-queue')</code>来注释这个消费者。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="3a36" class="mq lg in ml b gy mr ms l mt mu">@Processor('file-upload-queue')<br/>export class FileUploadProcessor {<br/><br/>    constructor(private readonly userService: UserService){}<br/><br/>    @Process('csvfilejob')<br/>    async processFile(job: Job) {<br/>        const file = job.data.file;<br/>        const filePath = file.path;<br/>        const userData = await csv().fromFile(filePath);<br/><br/>        console.log(userData);<br/><br/>        for(const user of userData) {<br/>            const input = {<br/>                email: user.email,<br/>                first_name: user.first_name,<br/>                last_name: user.last_name,<br/>            };<br/>            const userCreated = await this.userService.createUser(input);<br/>            console.log('User created -', userCreated.id );<br/>        }<br/><br/>    }<br/>    <br/>}</span></pre><p id="7000" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，我们可以看到我们使用队列中的作业，并从作业数据中获取文件。请注意，我们必须将<code class="fe mi mj mk ml b">@Process(jobName)</code>添加到消耗作业的方法中。<code class="fe mi mj mk ml b">processFile</code>方法消耗工作。我们将 CSV 数据转换成 JSON，然后使用<code class="fe mi mj mk ml b">UserService.</code>处理每一行，将用户添加到我们的数据库中</p><p id="a881" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你创建了<code class="fe mi mj mk ml b">FileUploadProcessor</code>，确保在你的应用模块中注册为一个提供者。</p><p id="7231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了说明这一点，如果我通过 Postman 执行 API，我将在控制台中看到以下数据:</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="6014" class="mq lg in ml b gy mr ms l mt mu">[Nest] 21264  - 04/22/2022, 4:57:19 PM     LOG [NestFactory] Starting Nest application...<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] DiscoveryModule dependencies initialized +43ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] ConfigHostModule dependencies initialized +0ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] BullModule dependencies initialized +4ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] ConfigModule dependencies initialized +0ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] BullModule dependencies initialized +12ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] BullModule dependencies initialized +10ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [InstanceLoader] AppModule dependencies initialized +1ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [RoutesResolver] AppController {/api/bullqueuedemo}: +62ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [RouterExplorer] Mapped {/api/bullqueuedemo/uploadFile, POST} route +3ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [RouterExplorer] Mapped {/api/bullqueuedemo, GET} route +1ms<br/>[Nest] 21264  - 04/22/2022, 4:57:20 PM     LOG [NestApplication] Nest application successfully started +582ms<br/>created job 2<br/>[<br/>  {<br/>    id: '1',<br/>    email: 'john.doe@gmail.com',<br/>    first_name: 'John',<br/>    last_name: 'Doe'<br/>  },<br/>  {<br/>    id: '2',<br/>    email: 'jacob.drake@gmail.com',<br/>    first_name: 'Jacob',<br/>    last_name: 'Drake'<br/>  },<br/>  {<br/>    id: '3',<br/>    email: 'jos.butler@gmail.com',<br/>    first_name: 'Jos',<br/>    last_name: 'Butler'<br/>  }<br/>]<br/>User created - 1<br/>User created - 2<br/>User created - 3</span></pre><p id="251e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多头队列提供了许多功能:</p><ul class=""><li id="3b3b" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">最小 CPU 使用率</li><li id="db5c" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">基于 redis 的稳健设计</li><li id="8fe9" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">并发</li><li id="c56c" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">重试</li><li id="4292" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">限速器</li><li id="936d" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">事件监督</li></ul><p id="75a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经常出现的一个问题是，如果作业失败或暂停，我们如何监控这些队列。一个简单的解决方案是使用 Redis CLI，但是 Redis CLI 并不总是可用，尤其是在生产环境中。最后，出现了一个简单的基于 UI 的仪表板——Bull 仪表板。</p><h1 id="fed1" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">集成公牛仪表板</h1><p id="12e3" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">关于 Bull 队列的伟大之处在于有一个 UI 可以用来监视队列。还可以添加一些选项，允许用户重试处于失败状态的作业。让我们安装两个依赖项<code class="fe mi mj mk ml b">@bull-board/express</code>和<code class="fe mi mj mk ml b">@bull-board/api</code>。</p><p id="7f34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">npm install @bull-board/express</code> -安装 express 服务器专用适配器。如果您在 NestJS 应用程序中使用<code class="fe mi mj mk ml b">fastify</code>，您将需要<code class="fe mi mj mk ml b">@bull-board/fastify</code>。</p><p id="0359" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mi mj mk ml b">npm install @bull-board/api</code> -安装一个核心服务器 API，允许创建一个 Bull 仪表板。</p><h1 id="fb04" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加牛纸板类</h1><p id="fd20" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我们将创建一个 bull board queue 类，它将为我们设置一些属性。它将创建一个队列池。每次注入新队列时，这个队列池都会被填充。我们还需要一个方法<code class="fe mi mj mk ml b">getBullBoardQueues</code>在加载 UI 时提取所有队列。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="f0ad" class="mq lg in ml b gy mr ms l mt mu">@Injectable()<br/>export class BullBoardQueue { }<br/><br/>export const queuePool: Set = new Set();<br/><br/>export const getBullBoardQueues = (): BaseAdapter[] =&gt; {<br/>    const bullBoardQueues = [...queuePool].reduce((acc: BaseAdapter[], val) =&gt; {<br/>        acc.push(new BullAdapter(val))<br/>        return acc<br/>    }, []);<br/><br/>    return bullBoardQueues<br/>}</span></pre><h1 id="3fc4" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加控制器</h1><p id="9e90" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">有几种方法可以访问 UI，但我更喜欢通过控制器添加，这样我的前端就可以调用 API。我们创建一个<code class="fe mi mj mk ml b">BullBoardController</code>来映射传入的请求、响应和下一个 like Express 中间件。在我们的 UI 路径中，我们有一个 Express 的服务器适配器。这允许我们设置一个基本路径。我们使用上面描述的<code class="fe mi mj mk ml b">getBullBoardQueues</code>方法获取所有注入的队列。然后我们使用<code class="fe mi mj mk ml b">createBullBoard</code> API 来获得<code class="fe mi mj mk ml b">addQueue</code>方法。<code class="fe mi mj mk ml b">serverAdapter</code>为我们提供了一个路由器，我们用它来路由传入的请求。在我们路由请求之前，我们需要做一点小改动，用<code class="fe mi mj mk ml b">/</code>替换 entryPointPath。</p><pre class="kj kk kl km gt mm ml mn mo aw mp bi"><span id="fa68" class="mq lg in ml b gy mr ms l mt mu">@Controller('/queues/admin')<br/>export class BullBoardController{<br/>    <br/>    @All('*')<br/>    admin(<br/>        @Request() req: express.Request,<br/>        @Response() res: express.Response,<br/>        @Next() next: express.NextFunction,<br/>    ) {<br/>        const serverAdapter = new ExpressAdapter();<br/>        serverAdapter.setBasePath('/queues/admin');<br/>        const queues = getBullBoardQueues();<br/>        const router = serverAdapter.getRouter() as express.Express;<br/>        const { addQueue } = createBullBoard({<br/>            queues: [],<br/>            serverAdapter,<br/>        });<br/>        queues.forEach((queue: BaseAdapter) =&gt; {<br/>            addQueue(queue);<br/>        });<br/>        const entryPointPath = '/queues/admin/';<br/>        req.url = req.url.replace(entryPointPath, '/');<br/>        router(req, res, next);<br/>    }<br/>}</span></pre><p id="9086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们运行我们的应用程序并访问 UI，我们将看到一个漂亮的 Bull Dashboard UI，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d503e75868f19bb10bbdd2a8f593a8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*yfXDv4TNr1SLcDBG"/></div></figure><p id="8f29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，这个用户界面的好处是你可以看到所有隔离的选项。</p><h1 id="8309" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="eb20" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">Bull 队列是管理一些资源密集型任务的一个很好的特性。在这篇文章中，我们学习了如何在 NestJS 应用程序中添加 Bull 队列。我们还轻松地将一个公告板集成到我们的应用程序中来管理这些队列。这篇文章的代码可以在<a class="ae kq" href="https://github.com/yogsma/betterjavacode/tree/main/bullqueuedemo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c2ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想看更多关于 NestJS 的帖子吗？请在此将您的反馈<a class="ae kq" href="https://betterjavacode.com/contact-us" rel="noopener ugc nofollow" target="_blank">发送给我。</a></p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="bdae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nc">原载于 2022 年 4 月 24 日 https://betterjavacode.com</em><a class="ae kq" href="https://betterjavacode.com/programming/using-bull-queues-in-nestjs-application" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a><em class="nc">。</em></p></div></div>    
</body>
</html>