<html>
<head>
<title>Building a Go REST client in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022 年打造 Go REST 客户端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-go-rest-client-in-2022-1ba8bb4c2201?source=collection_archive---------1-----------------------#2022-08-10">https://blog.devgenius.io/building-a-go-rest-client-in-2022-1ba8bb4c2201?source=collection_archive---------1-----------------------#2022-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3cee5d008f9f5fe2a02d997b627edd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pBfOmkYRA6KABgj-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片由克里斯蒂娜@ wocintechchat.com 提供，来自<a class="ae jz" href="https://unsplash.com/photos/glRqyWJgUeY" rel="noopener ugc nofollow" target="_blank"> unsplash </a></figcaption></figure><p id="fb1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是 2022 年，RESTful APIs 还在被开发者消费。随着超过 90%的开发人员实现或集成 REST APIss，REST API 实现了 Roy Fielding 的抱负。Go 中泛型的引入简化了 REST API 集成。在这篇文章中，我将向你展示我用 Go 构建类型安全 API 客户端的方法。我将在的 API 中使用<a class="ae jz" href="https://reqres.in/api/users?page=2" rel="noopener ugc nofollow" target="_blank"> https://reqres .来获取测试数据。本文中定义的类型代表 reqres 的 API 数据。</a></p><h1 id="59ba" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有数据吗？</h1><p id="4dbf" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">因为这意味着是一个类型安全的客户端，所以我将从定义我的 API 类型开始。下面是类似于我的 API 将返回的 JSON 的类型:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="bd13" class="mk kz in mg b gy ml mm l mn mo">type RequestObj struct {<br/> TotalPage int       `json:"total"`<br/> Data      []Profile `json:"data"`<br/>}</span><span id="28f2" class="mk kz in mg b gy mp mm l mn mo">type Profile struct {<br/> Avatar string    `json:"avatar"`<br/> Email string     `json:"email"`<br/> FirstName string `json:"first_name"`<br/> LastName string  `json:"last_name"`<br/>}</span></pre><p id="9520" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mq mr ms mg b">RequestObj</code>类似于 API 返回的数据结构。接下来，我将开始定义一个通用函数来处理<code class="fe mq mr ms mg b">GET</code>请求。该函数将具有以下签名:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="538a" class="mk kz in mg b gy ml mm l mn mo">func Get[T any](ctx context.Context, url string) (T, error)</span></pre><p id="31ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我要添加的第一行代码是<code class="fe mq mr ms mg b">var m T</code>，这将定义一个通用变量。我将把它用于早期返回，因为我还没有处理任何 JSON。下一行将初始化一个<code class="fe mq mr ms mg b">http.Request</code>对象。下面的代码将做到这一点:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="94e5" class="mk kz in mg b gy ml mm l mn mo">r, err := http.NewRequestWithContext(ctx, "GET", url, nil)</span></pre><p id="797e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我选择用一个上下文来初始化请求对象，以便能够设置请求超时。下一步是实际执行请求。我将使用<code class="fe mq mr ms mg b">http</code>包的默认客户端。启动请求的代码如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0c85" class="mk kz in mg b gy ml mm l mn mo">res, err := http.DefaultClient.Do(r)</span></pre><p id="109a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我将使用<code class="fe mq mr ms mg b">io</code>包从响应中读取所有字节。一旦读取完毕，我将把带有泛型类型的字节传递给 Go 的 JSON 解组器。以下是完整的<code class="fe mq mr ms mg b">Get</code>功能:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="51f2" class="mk kz in mg b gy ml mm l mn mo">func Get[T any](ctx context.Context, url string) (T, error) {</span><span id="0208" class="mk kz in mg b gy mp mm l mn mo">  var m T<br/>  r, err := http.NewRequestWithContext(ctx, "<strong class="mg io">GET</strong>", url, nil)</span><span id="fef7" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="a4a9" class="mk kz in mg b gy mp mm l mn mo">  res, err := http.DefaultClient.Do(r)</span><span id="d225" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="4727" class="mk kz in mg b gy mp mm l mn mo">  body, err := io.ReadAll(res.Body)<br/>  res.Body.Close()</span><span id="8cab" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="0a0b" class="mk kz in mg b gy mp mm l mn mo">  return parseJSON[T](body)<br/>}</span><span id="da0f" class="mk kz in mg b gy mp mm l mn mo">func parseJSON[T any](s []byte) (T, error) {<br/>  var r T</span><span id="8f17" class="mk kz in mg b gy mp mm l mn mo">  if err := json.Unmarshal(s, &amp;r); err != nil {<br/>    return r, err<br/>  }</span><span id="121b" class="mk kz in mg b gy mp mm l mn mo">  return r, nil<br/>}</span></pre><p id="7847" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我有了所有这些简洁的代码，是时候实现它了。下面是上面定义的客户端的一个实现。这将获取数据，并将第一个条目记录到控制台:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="f785" class="mk kz in mg b gy ml mm l mn mo">package main</span><span id="837e" class="mk kz in mg b gy mp mm l mn mo">import (<br/> "context"<br/> "fmt"<br/> "log"<br/> "time"<br/>)</span><span id="8c4a" class="mk kz in mg b gy mp mm l mn mo">func main() {</span><span id="5845" class="mk kz in mg b gy mp mm l mn mo">  ctx := context.Background()<br/>  timeout := 30 * time.Second</span><span id="c9f3" class="mk kz in mg b gy mp mm l mn mo">  reqContext, _ := context.WithTimeout(ctx, timeout)<br/>  m, err := Get[RequestObj](reqContext, "<a class="ae jz" href="https://reqres.in/api/users?page=2" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users?page=2</a>")</span><span id="5b80" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>   log.Fatal(err)<br/>  }</span><span id="ab7d" class="mk kz in mg b gy mp mm l mn mo">  fmt.Println(m.Data[0])</span><span id="e333" class="mk kz in mg b gy mp mm l mn mo">}</span></pre><p id="973d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是实际运行的代码:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5204be17c0c166ba9d880f0e3e80805a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*jKJS5czfCH5XhN01.gif"/></div></figure><p id="bf36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步将是处理张贴数据。</p><h1 id="2b65" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">制作数据</h1><p id="234f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我将首先定义我将用于 POST 请求的类型。下面是定义类型的代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cbda" class="mk kz in mg b gy ml mm l mn mo">type User struct {<br/>  Name string         `json:"name,omitempty"`<br/>  Job string          `json:"job,omitempty"`<br/>  ID string           `json:"id,omitempty"`<br/>  CreatedAt time.Time `json:"createdAt,omitempty"` <br/>}</span></pre><p id="5642" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你注意到了，我大量使用了<code class="fe mq mr ms mg b">omitempty</code>，这将阻止向 API 服务器发送默认字段数据。接下来，我将定义向 API 发送数据的通用函数。该函数将具有以下签名:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7143" class="mk kz in mg b gy ml mm l mn mo">func Post[T any](ctx context.Context, url string, data any) (T, error)</span></pre><p id="936e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mq mr ms mg b">Post</code>函数将类似于<code class="fe mq mr ms mg b">Get</code>，除了它将初始化一个<code class="fe mq mr ms mg b">io</code>阅读器并为请求设置一个报头。因此，我将介绍这两个过程。我还需要将我的类型转换成一个字节数组。下面是将执行所述任务的函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7576" class="mk kz in mg b gy ml mm l mn mo">func toJSON(T any) ([]byte, error) {<br/> return json.Marshal(T)<br/>}</span></pre><p id="db4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到<code class="fe mq mr ms mg b">Post</code>函数，我将用我的类型生成的字节初始化一个<code class="fe mq mr ms mg b">io</code>读取器。我将使用以下代码执行此任务:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="005b" class="mk kz in mg b gy ml mm l mn mo">b,_ := toJSON(data)<br/>...</span><span id="a10a" class="mk kz in mg b gy mp mm l mn mo">byteReader := bytes.NewReader(b)</span></pre><p id="b488" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我有了一个<code class="fe mq mr ms mg b">io</code>阅读器，我将用它初始化一个请求:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="27e5" class="mk kz in mg b gy ml mm l mn mo">r, err := http.NewRequestWithContext(ctx, "POST", url, byteReader)</span></pre><p id="faec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦请求被初始化，我将为请求添加一个头。这将告诉 REST 服务器如何理解我发送的数据。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2b3a" class="mk kz in mg b gy ml mm l mn mo">r.Header.Add("Content-Type", "application/json")</span></pre><p id="c6b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是完整的<code class="fe mq mr ms mg b">Post</code>功能:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e4ca" class="mk kz in mg b gy ml mm l mn mo">func Post[T any](ctx context.Context, url string, data any) (T, error) {</span><span id="ea9f" class="mk kz in mg b gy mp mm l mn mo">  var m T</span><span id="fce9" class="mk kz in mg b gy mp mm l mn mo">  <strong class="mg io">b, err := toJSON(data)</strong></span><span id="a7c2" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="ebda" class="mk kz in mg b gy mp mm l mn mo">  <strong class="mg io">byteReader</strong> := bytes.NewReader(<strong class="mg io">b</strong>)</span><span id="5d6a" class="mk kz in mg b gy mp mm l mn mo">  r, err := http.NewRequestWithContext(ctx, "<strong class="mg io">POST</strong>", url, <strong class="mg io">byteReader</strong>)</span><span id="7a22" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="5d63" class="mk kz in mg b gy mp mm l mn mo">  // Important to set<br/> <strong class="mg io"> r.Header.Add("Content-Type", "application/json")</strong></span><span id="1d7b" class="mk kz in mg b gy mp mm l mn mo">  res, err := http.DefaultClient.Do(r)</span><span id="8c64" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>   return m, err<br/>  }</span><span id="8d4d" class="mk kz in mg b gy mp mm l mn mo">  body, err := io.ReadAll(res.Body)<br/>  res.Body.Close()</span><span id="1152" class="mk kz in mg b gy mp mm l mn mo">  if err != nil {<br/>    return m, err<br/>  }</span><span id="0a7c" class="mk kz in mg b gy mp mm l mn mo">  return parseJSON[T](body)<br/>}</span></pre><p id="feb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是函数<code class="fe mq mr ms mg b">Post</code>的一个实现:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a9c3" class="mk kz in mg b gy ml mm l mn mo">package main</span><span id="a190" class="mk kz in mg b gy mp mm l mn mo">import (<br/> "context"<br/> "fmt"<br/> "log"<br/> "time"<br/>)</span><span id="2579" class="mk kz in mg b gy mp mm l mn mo">func main() {</span><span id="67ec" class="mk kz in mg b gy mp mm l mn mo"> ctx := context.Background()<br/> timeout := 30 * time.Second<br/> // Post data<br/> <strong class="mg io">user</strong> := <strong class="mg io">User</strong>{ Name : "morpheus", Job : "leader"}</span><span id="d06c" class="mk kz in mg b gy mp mm l mn mo"> addContext, _ := context.WithTimeout(ctx,  timeout) </span><span id="fe93" class="mk kz in mg b gy mp mm l mn mo"> <strong class="mg io">newUser</strong>, err := Post[<strong class="mg io">User</strong>](addContext, "<a class="ae jz" href="https://reqres.in/api/users" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users</a>", <strong class="mg io">user</strong>)</span><span id="ee34" class="mk kz in mg b gy mp mm l mn mo"> if err != nil {<br/>   log.Fatal(err)<br/> }</span><span id="09cf" class="mk kz in mg b gy mp mm l mn mo"> fmt.Println( <strong class="mg io">newUser</strong> )</span><span id="923d" class="mk kz in mg b gy mp mm l mn mo">}</span></pre><p id="cb48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是运行中的代码，您还可以看到服务器生成的附加数据:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/da5d3d3027df9e80975dc08d293f38bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*vk0178AIVfowtxt4.gif"/></div></figure><h1 id="755d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="b7a2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">泛型是一个很好的补充。它使我能够为我的 API 客户端增加流动性。从某种意义上说，我可以用一行代码检索数据并将其断言为一种类型；).它还消除了定义变量并传递它来模拟一般行为的过时过程。我没有提到的一个重要的提醒是:不要忘记检查 HTTP 错误代码！</p><h1 id="556e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">附加说明</h1><div class="mu mv gp gr mw mx"><a href="https://github.com/cheikhshift/medium_examples/tree/main/http-client" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">medium _ examples/http-client at main cheikh shift/medium _ examples</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jt mx"/></div></div></a></div><div class="mu mv gp gr mw mx"><a href="https://nordicapis.com/20-impressive-api-economy-statistics/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">20 项令人印象深刻的 API 经济统计|北欧 APIs |</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">科技发展很快。它还使用自己的技术术语，这些术语发展很快。可能很难跟上…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">nordicapis.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl jt mx"/></div></div></a></div></div></div>    
</body>
</html>