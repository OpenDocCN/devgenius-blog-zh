<html>
<head>
<title>POJOs in Java with Lombok</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇和龙目岛的 POJOs</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pojos-in-java-with-lombok-307944323b8?source=collection_archive---------0-----------------------#2021-11-14">https://blog.devgenius.io/pojos-in-java-with-lombok-307944323b8?source=collection_archive---------0-----------------------#2021-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1f10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们用更好的方式来玩 POJOs</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08e2e4b47ff80a0922466795e08af614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMg0Csu-m1cQej7lGVIuJg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">龙目岛在行动</figcaption></figure><p id="9044" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨，开发者们！我非常兴奋地告诉你，这是我第一篇关于媒体的技术文章！作为一个很好的开始，我想写一些对我们这些开发者真正有帮助的东西。这一切都是为了让我们的生活更轻松，让现实世界中的应用程序代码更少。使用 Lombok 库和我一起玩 POJO 类吧！</p><p id="5a4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以让我们征服吧！！！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="0633" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是龙目岛？</h1><p id="50ba" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这是龙目岛的创造者对它的定义。</p><blockquote class="mi mj mk"><p id="1a98" class="jk jl ml jm b jn jo jp jq jr js jt ju mm jw jx jy mn ka kb kc mo ke kf kg kh ig bi translated">java 库，自动插入到你的编辑器和构建工具中，增加你的 java 的味道。</p></blockquote><p id="3c3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，简单地说，这是一个可以用来使我们的事情变得更简单的库，而不是从头开始实现预期的功能。暂时记住这件事。你以后会意识到这个事实的。</p><h1 id="675e" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">如何申请 POJOs？</h1><h1 id="6af9" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">装置</h1><p id="07e3" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">所以，根据你的项目的构建插件，Lombok 必须被安装到你的项目中。可以是 Maven/Sbt，也可以是其他。所以，我会给你 maven 依赖，因为它是 Java 项目中最常用的构建工具。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="93b8" class="mz lg in mv b gy na nb l nc nd">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;version&gt;1.18.20&lt;/version&gt;<br/>    &lt;scope&gt;provided&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><h2 id="a4b3" class="mz lg in bd lh ne nf dn ll ng nh dp lp jv ni nj lt jz nk nl lx kd nm nn mb no bi translated">使用</h2><p id="4a44" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">首先，我会把这个部分分成多个部分。那我们就可以一个一个讨论清楚了。</p><p id="2aeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ml">龙目岛在波若斯有什么不同？</em>T3】</strong></p><p id="626d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我深入研究一下。所以通常，当我们创建一个 POJO(或 DTO)时，我们指定一些字段和它们的访问方法，以便在我们插入它的地方操作它。然后我们基于这个类做很多事情，比如创建新的实例，存储对象，将它们转换成 JSON 等等。我们使用的所有这些操作都是某种相同的样板，我们重复它。例如，我们在类中显式定义 getters 和 setters，以实现封装。</p><p id="1bed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我说当我们使用龙目语时，我们不必这样做，你认为怎么样？听起来是不是很棒？？？ </p><p id="f779" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是龙目岛有多疯狂！让我们一步一步的开始了解吧。</p><h1 id="fdb6" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">Getters、Setters 和 ToString 方法</h1><p id="f680" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">所以，这是使用 Lombok 最简单也是最重要的一步。当我们创建一个 POJO 并将 Lombok 插入其中时，我们只需<strong class="jm io"> <em class="ml">将字段及其类型</em> </strong>放入类中！甚至没有访问字段的修饰符。默认情况下，Lombok 将它们视为私有字段。</p><p id="7f70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们有 3 种方法来实现封装。</p><ol class=""><li id="5583" class="np nq in jm b jn jo jr js jv nr jz ns kd nt kh nu nv nw nx bi translated"><strong class="jm io">数据标注</strong></li></ol><p id="7d3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须将<strong class="jm io"> "@Data" </strong>注释放在类定义的顶部。因此，它将负责每个字段的 Getters 和 Setters，ToString 方法，Hashcode 方法，Equals 方法。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9733" class="mz lg in mv b gy na nb l nc nd">@Data<br/>public class Employee {<br/>    String userName;<br/>    String email;<br/>}</span></pre><p id="cc7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，userName 的 getterss 和 setterss 为<em class="ml"> getUserName() </em>，email 的 getter 和 setter 为<em class="ml"> getEmail() </em>。您必须等到文章的构造函数部分完成后再尝试。</p><p id="f44f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。Getter 和 Setter 注释</strong></p><p id="804d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您只需要 Getters 或 Setters。那么你可以用<strong class="jm io"> "@Getter" </strong>或者<strong class="jm io"> "@Setter" </strong>来代替" @Data "。很简单！但是这里我们没有像在“@Data”注释中那样得到任何其他方法。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="82fd" class="mz lg in mv b gy na nb l nc nd">@Getter<br/>public class Employee {<br/>    String userName;<br/>    String email;<br/>}</span></pre><p id="bd1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。数值注释</strong></p><p id="b0f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您需要维护不可变对象时，可以使用这种注释。简单地说，没有设定者。您不能修改这些字段。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="04fe" class="mz lg in mv b gy na nb l nc nd">@Value<br/>public class Employee {<br/>    String userName;<br/>    String email;<br/>}</span></pre><h1 id="5639" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">构造器</h1><p id="7970" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我们需要构造函数来创建新对象。所以，我们必须告诉 Lombok 我们需要这些构造函数。这里我们给出了 3 个选择。</p><ol class=""><li id="57df" class="np nq in jm b jn jo jr js jv nr jz ns kd nt kh nu nv nw nx bi translated"><strong class="jm io">无 rgs 构造器</strong></li></ol><p id="aef2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这和 Java 默认构造函数一样！当我们使用它时，我们可以创建一个没有参数值的对象。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2124" class="mz lg in mv b gy na nb l nc nd">@NoArgsConstructor<br/>public class Employee {<br/>    String userName;<br/>    String email;<br/>}</span></pre><p id="10ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:雇员 emp =新雇员()；</p><p id="ff47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试创建一个新的对象！现在您可以看到如何访问 getters 和 setters 了…</p><p id="26f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。AllArgsConstructor </strong></p><p id="dcb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们放置这个注释时，我们有机会通过提供所有字段作为参数来创建一个对象。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="fafd" class="mz lg in mv b gy na nb l nc nd">@NoArgsConstructor<br/>@AllArgsConstructor<br/>public class Employee {<br/>    String userName;<br/>    String email;<br/>}</span></pre><p id="d9d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。RequiredArgsConstructor </strong></p><p id="a0e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个注释还帮助我们用一些强制参数来构造函数。但是我们必须使用另一个名为<strong class="jm io"> "@NonNull" </strong>的注释告诉 Lombok 那些强制字段是什么。那么 Lombok 将按照我们在 POJO 类中定义的顺序来考虑它们。假设用户名和电子邮件是强制性的。所以我们可以这样修改这个类。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e739" class="mz lg in mv b gy na nb l nc nd">@Data<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>@RequiredArgsConstructor<br/>public class Employee {<br/>    @NonNull String userName;<br/>    @NonNull String email;<br/>    double salary;<br/>}</span></pre><p id="61af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以用三种构造函数创建对象。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="535c" class="mz lg in mv b gy na nb l nc nd">Employee employee1 = new Employee();<br/>Employee employee2 = new Employee("sailtha", "salitha@gmail.com");<br/>Employee employee3 = new Employee("sailtha", "salitha@gmail.com", 50500.50);</span></pre><h1 id="5a41" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">显式 Equals 和 Hashcode</h1><p id="670c" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这是我们在 Java 中操作对象时发现的一个非常棘手的情况。通常，根据 Java 内存模型在堆空间中创建对象。只有它们的引用被保存在堆栈内存中。因此，假设您将 Employee 对象存储在这样一个映射中:Map <id employee="">。所以你必须确定一件事！</id></p><blockquote class="mi mj mk"><p id="9162" class="jk jl ml jm b jn jo jp jq jr js jt ju mm jw jx jy mn ka kb kc mo ke kf kg kh ig bi translated">如何区分员工对象？协议是什么？</p></blockquote><p id="8bd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">否则，由于在不知情的情况下一次又一次地创建同一个雇员，您将在堆上遇到内存问题！令人惊讶的是，堆空间会被太多的对象填满。</p><p id="ae34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了克服这个问题，我们必须在 Java 中覆盖从最父类 Object 提供的<strong class="jm io"> equals() </strong>和<strong class="jm io"> hashcode() </strong>方法。在那里，我们可以选择一些字段来创建一个独特的员工。Lombok 提供了一个很棒的方法来做到这一点。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1a48" class="mz lg in mv b gy na nb l nc nd">@EqualsAndHashCode(onlyExplicitlyIncluded = true)</span></pre><p id="76ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们将这个注释放在类定义的顶部时，我们就可以标记所需的字段了。<strong class="jm io">记住，注释内的条件[onlyExplicitlyIncluded = true]将限制 POJO 使用注释文件区分对象，如下图</strong>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="8820" class="mz lg in mv b gy na nb l nc nd">@EqualsAndHashCode.Include</span></pre><p id="8f14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在每当你用相同的用户名和电子邮件创建对象时，它们将被指向同一个对象<strong class="jm io"> <em class="ml">，避免一次又一次地创建新对象</em> </strong>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="72c0" class="mz lg in mv b gy na nb l nc nd">@Data<br/>@EqualsAndHashCode(onlyExplicitlyIncluded = true)<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>@RequiredArgsConstructor<br/>public class Employee {<br/><br/>    String firstName;<br/><br/>    String lastName;<br/><br/>    @EqualsAndHashCode.Include<br/>    @NonNull String userName;<br/><br/>    @EqualsAndHashCode.Include<br/>    @NonNull String email;</span><span id="940f" class="mz lg in mv b gy ny nb l nc nd">    int age;</span><span id="41f2" class="mz lg in mv b gy ny nb l nc nd">    double salary;<br/>}</span></pre><p id="174e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有各种方法可以试试这个家伙！由于文章已经有点冗长，我就不一一解释了。:)</p><h1 id="6f89" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">使用生成器设计模式</h1><p id="593b" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这是我至今在龙目岛发现的最不可思议的特征。您可能已经了解了生成器设计模式。简单来说<strong class="jm io"> <em class="ml">它允许我们创建我们想要的对象，并且实体与构造函数</em> </strong>不紧密耦合。假设我们的雇员对象有 30 个属性/字段。所以很难通过提供所有这些来创建一个对象。在大多数情况下，我们也不需要某些属性，因为有些属性对于员工来说是可选的。不像我们以传统方式实现嵌套的构建器类，Lombok 只为我们提供了<strong class="jm io">一个注释来实现整个构建器模式</strong>！这不是很好吗？</p><p id="3aef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们必须注意一些事情:</p><ul class=""><li id="545e" class="np nq in jm b jn jo jr js jv nr jz ns kd nt kh nz nv nw nx bi translated">如果使用<strong class="jm io"> "@Builder" </strong>注释，不要定义构造函数注释。因为现在对象创建是完全松散耦合的。</li><li id="e764" class="np nq in jm b jn oa jr ob jv oc jz od kd oe kh nz nv nw nx bi translated">如果您用<strong class="jm io"> "@NonNull" </strong>注释字段，那么您<strong class="jm io">不能在不提供标有" @NonNull "的对象的情况下使用 builder 创建</strong>对象。它会抛出一个异常！因此，您必须取消空检查。</li><li id="c5ff" class="np nq in jm b jn oa jr ob jv oc jz od kd oe kh nz nv nw nx bi translated">当需要通过 JSON 格式反序列化对象时，使用<strong class="jm io"> "@Jacksonized" </strong>注释。当你把 Lombok 和 JSON 库一起使用的时候会很有帮助，比如<strong class="jm io">“Jackson”</strong>。</li><li id="578f" class="np nq in jm b jn oa jr ob jv oc jz od kd oe kh nz nv nw nx bi translated">如果我们没有使用“@Builder”注释为任何参数设置值，Lombok 会将其值视为“NULL”。</li></ul><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9726" class="mz lg in mv b gy na nb l nc nd">@Jacksonized<br/>@Builder<br/>@Data<br/>@EqualsAndHashCode(onlyExplicitlyIncluded = true)<br/>public class Employee {<br/><br/>    String firstName;<br/><br/>    String lastName;<br/><br/>    @EqualsAndHashCode.Include<br/>    String userName;<br/><br/>    @EqualsAndHashCode.Include<br/>    String email;<br/><br/>    int age;<br/><br/>    double salary;</span><span id="404c" class="mz lg in mv b gy ny nb l nc nd">}</span></pre><p id="5577" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，如何在旅途中创建对象呢？看看下面的例子！</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1dd4" class="mz lg in mv b gy na nb l nc nd">Employee employee1 = Employee.<em class="ml">builder</em>()<br/>        .userName("salitha")<br/>        .age(28)<br/>        .email("salitha@gmail.com")<br/>        .designation("SE")<br/>        .build();<br/><br/>Employee employee2 = Employee.<em class="ml">builder</em>()<br/>        .userName("salitha")<br/>        .email("salitha@gmail.com")<br/>        .build();<br/><br/>Employee employee3 = Employee.<em class="ml">builder</em>()<br/>        .firstName("salitha")<br/>        .lastName("chathuranga")<br/>        .salary(50000)<br/>        .build();</span></pre><p id="4269" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到对象创建的差异。在第一种情况下，所有未定义的字段(如 firstName，lastName)将为 NULL。同样，它也适用于其他情况。</p><h1 id="b2b4" class="lf lg in bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">为字段设置默认值</h1><p id="6289" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">假设您想要<em class="ml">创建一个状态始终为“活动”的员工。</em>简单来说，所有员工都必须有，不用明确设置。正如您现在所知道的，<strong class="jm io"> Builder 默认将这个属性值视为 NULL，因为我们不会在创建对象</strong>时设置它。这就是我们要使用构建器<strong class="jm io">默认</strong>机制的地方。我们只需要如下注释该字段。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="db82" class="mz lg in mv b gy na nb l nc nd">@Builder.Default<br/>String status = "active";</span></pre><p id="750c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，随着这一变化，雇员类将如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f178" class="mz lg in mv b gy na nb l nc nd">@Builder<br/>@Data<br/>@EqualsAndHashCode(onlyExplicitlyIncluded = true)<br/>public class Employee {<br/><br/>    String firstName;<br/><br/>    String lastName;<br/><br/>    @EqualsAndHashCode.Include<br/>    String userName;<br/><br/>    @EqualsAndHashCode.Include<br/>    String email;<br/><br/>    int age;<br/><br/>    double salary;<br/><br/>    @Builder.Default<br/>    String status = "active";</span><span id="999f" class="mz lg in mv b gy ny nb l nc nd">}</span></pre><p id="52c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以创建一个对象并打印以查看员工的状态！应该是这样的…</p><blockquote class="mi mj mk"><p id="8c80" class="jk jl ml jm b jn jo jp jq jr js jt ju mm jw jx jy mn ka kb kc mo ke kf kg kh ig bi translated">雇员(名=空，姓=空，用户名=萨利塔，email=salitha@gmail.com，职务=SE，年龄=28，薪金=0.0，状态=活跃)</p></blockquote><p id="847c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以根据需要创建员工了！</p><p id="9e1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你能从这篇文章中获得一些知识。我只是想让你知道我们如何在许多方面利用龙目岛图书馆。我必须告诉你:当我们将<strong class="jm io">杰克森</strong>和<strong class="jm io">龙目</strong>图书馆连接在一起时，可以实现更多有趣的事情！POJO 和 JSON 之间的序列化和去序列化非常容易。下次见面时我会带着它。</p><p id="1b47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在那之前，再见！注意安全！！！</p></div></div>    
</body>
</html>