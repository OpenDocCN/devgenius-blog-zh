<html>
<head>
<title>Comparison Inheritance And Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较遗传和多态性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/comparison-inheritance-and-polymorphism-12064ce8a5aa?source=collection_archive---------7-----------------------#2022-06-05">https://blog.devgenius.io/comparison-inheritance-and-polymorphism-12064ce8a5aa?source=collection_archive---------7-----------------------#2022-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/14797620e6ce1037bd8df5aed5aaf92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B46g9F10tKcyv_Zm.jpg"/></div></div></figure><h2 id="91f4" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">继承:</strong></h2><ul class=""><li id="799c" class="kr ks in kt b ku kv kw kx ke ky ki kz km la lb lc ld le lf bi translated">继承是一种允许创建层次分类的组织机制。</li><li id="cd76" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">使用继承，我们可以创建一个新类，它是现有类的专门化。</li><li id="ae5b" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">在 java 的术语中，被继承的类被称为超类。进行继承的类称为子类。</li><li id="98ce" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">因此，子类是超类的特殊版本。</li></ul><p id="0318" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated"><strong class="kt io">可重用性:</strong>当我们想要创建一个新的类，并且已经有一个类包含了一些我们想要的代码时，我们可以从现有的类中派生出我们的新类。通过这样做，我们可以重用现有类的字段和方法。</p><p id="33eb" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated"><strong class="kt io">为什么我们需要在 JAVA 中使用继承？</strong></p><blockquote class="mc md me"><p id="fed2" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated">对于<strong class="kt io">方法重写</strong>(这样<em class="in">运行时多态</em>就可以实现了)。</p><p id="6144" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated">对于代码<strong class="kt io">的可重用性</strong>。</p></blockquote><p id="8b3e" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">使用的关键字:<strong class="kt io">扩展了</strong></p><blockquote class="mc md me"><p id="5c23" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated"><strong class="kt io">语法:</strong></p><p id="6386" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated"><strong class="kt io">类子类名称扩展超类名{ </strong></p><p id="0334" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated"><strong class="kt io"> //类的主体</strong></p><p id="2eb0" class="ll lm mf kt b ku ln lo lp kw lq lr ls mg lt lu lv mh lw lx ly mi lz ma mb lb ig bi translated"><strong class="kt io"> } </strong></p></blockquote><h1 id="44aa" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated"><strong class="ak">Java 中的继承类型</strong></h1><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/bcda54f8e157a886a48fab03d4434c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKno8b5rje30PJnnaZaW3w.png"/></div></div></figure><p id="525f" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated"><strong class="kt io">继承树:</strong> <br/> Java 只支持单继承。这意味着一个类只能扩展另一个类。因此，在 java 中，继承关系定义了一棵继承树。</p><h1 id="7ddc" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated"><strong class="ak"> 1。单一继承</strong></h1><p id="c4cb" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">当一个单独的类从另一个单独的类继承时，它被称为单独继承。示例:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/1f9b2e94d67978d646d94b76e78209a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5QRW89KdixPwDaTN3TD3Q.png"/></div></div></figure><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="11fc" class="jv jw in nk b gy no np l nq nr">package ExampleInheritance;<br/><br/>class Animal{<br/>    void eat(){System.<em class="mf">out</em>.println("eating...");}<br/>}<br/>class Dog extends Animal{<br/>    void bark(){System.<em class="mf">out</em>.println("barking...");}<br/>}<br/>class TestInheritance{<br/>    public static void main(String args[]){<br/>        Dog d=new Dog();<br/>        d.bark();<br/>        d.eat();<br/>    }}</span></pre><p id="dfc8" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">输出:</p><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="9433" class="jv jw in nk b gy no np l nq nr">barking...<br/>eating...</span></pre><h1 id="75bb" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">2.多级遗传</h1><p id="c2a9" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">当存在继承链时，称为多级继承。继承已经被另一个类继承的类。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/92a18646909106f110c81a5a68f28886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zl1kdzShrg6sBqOOMOB3lw.png"/></div></div></figure><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="df31" class="jv jw in nk b gy no np l nq nr">package ExampleInheritance;<br/><br/>class Animal{<br/>    void eat(){System.<em class="mf">out</em>.println("eating...");}<br/>}<br/>class Dog extends Animal{<br/>    void bark(){System.<em class="mf">out</em>.println("barking...");}<br/>}<br/>class BabyDog extends Dog{<br/>    void weep(){System.<em class="mf">out</em>.println("weeping...");}<br/>}<br/>class TestInheritance2{<br/>    public static void main(String args[]){<br/>        BabyDog d=new BabyDog();<br/>        d.weep();<br/>        d.bark();<br/>        d.eat();<br/>    }}</span></pre><p id="47c2" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">输出:</p><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="5666" class="jv jw in nk b gy no np l nq nr">weeping...<br/>barking...<br/>eating...</span></pre><h1 id="8986" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">3.分层继承</h1><p id="bfc4" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">当两个或更多的类继承一个类时，这叫做层次继承。示例:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/2f305445a0093a62ff5ddc9af6e43a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPizDha1AALpZ2zqJg-Gxg.png"/></div></div></figure><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="2215" class="jv jw in nk b gy no np l nq nr">package ExampleInheritance;<br/><br/>class Animal{<br/>    void eat(){System.<em class="mf">out</em>.println("eating...");}<br/>}<br/>class Dog extends Animal{<br/>    void bark(){System.<em class="mf">out</em>.println("barking...");}<br/>}<br/>class Cat extends Animal{<br/>    void meow(){System.<em class="mf">out</em>.println("meowing...");}<br/>}<br/>class TestInheritance3{<br/>    public static void main(String args[]){<br/>        Cat c=new Cat();<br/>        c.meow();<br/>        c.eat();<br/>    }}</span></pre><p id="91e1" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">输出:</p><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="7ce3" class="jv jw in nk b gy no np l nq nr">meowing...<br/>eating...</span></pre><h1 id="6cbb" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">4.多重遗传</h1><p id="b801" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">当一个类从多个类继承时，它被称为多重继承。例如:C 类继承自 A 类和 b 类。</p><p id="668c" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated"><em class="mf"> Java 不允许多重继承，以避免由此带来的歧义。</em></p><h1 id="6f44" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">5.混合遗传</h1><p id="1a14" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">Java 中的混合继承是两种或多种类型继承的组合。例如:D 类继承自 C 类和 B 类，B 类和 C 类都继承自 a 类。</p><p id="2568" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">Java 也不支持混合继承。</p><h1 id="a8c7" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">多态性</h1><ul class=""><li id="653e" class="kr ks in kt b ku kv kw kx ke ky ki kz km la lb lc ld le lf bi translated">多态性是指一个事物以多种形式存在。</li><li id="dafd" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">简单地说，多态是一个消息以多种格式显示的能力。</li><li id="3ad1" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">多态性允许我们以不同的方式执行一个动作。换句话说，多态性允许您定义一个接口并拥有多个实现。</li><li id="a756" class="kr ks in kt b ku lg kw lh ke li ki lj km lk lb lc ld le lf bi translated">单词“poly”的意思是许多，“morphs”的意思是形式，所以它的意思是许多形式。</li></ul><h1 id="bad3" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">多态性的类型</h1><blockquote class="nu"><p id="38ad" class="nv nw in bd nx ny nz oa ob oc od lb dk translated">1.编译时多态性</p><p id="fd89" class="nv nw in bd nx ny nz oa ob oc od lb dk translated">2.运行时多态性</p></blockquote><h1 id="148e" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq oe ms kh mt of mv kl mw og my kp mz bi translated">1.编译时多态性</h1><p id="1612" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">编译时多态性是根据它在编译过程中出现而命名的。编译器在构建时检查方法签名，以确定在构建时为给定的方法调用调用哪个方法。它也被称为早期绑定、静态多态或重载。</p><p id="a56a" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">在 Java 中实现编译时多态性的一种方法是使用<a class="ae oh" href="https://www.codingninjas.com/codestudio/guided-paths/basics-of-java/content/120298/offering/1404433" rel="noopener ugc nofollow" target="_blank">方法重载</a>。这种多态性还包括构造函数重载和方法隐藏。</p><p id="1a21" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">现在让我们看一个编译时多态性的例子。</p><h1 id="3ab3" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">例子</h1><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="c173" class="jv jw in nk b gy no np l nq nr">class SimpleMultiplication<br/>{<br/><br/>    <em class="mf">/* Two different functions with same name */<br/>    </em>int multiply(int a, int b)<br/>    {<br/>        return a*b;<br/>    }<br/>    int  multiply(int a, int b, int c)<br/>    {<br/>        return a*b*c;<br/>    }<br/>}<br/><br/>class Demo<br/>{<br/>    public static void main(String args[])<br/>    {<br/>        SimpleMultiplication num = new SimpleMultiplication();<br/><br/>        <em class="mf">/* Calling functions */<br/>        </em>System.<em class="mf">out</em>.println(num.multiply(10, 20));<br/>        System.<em class="mf">out</em>.println(num.multiply(10, 20, 30));<br/>    }<br/>}</span></pre><h2 id="acbb" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">输出</h2><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="aab9" class="jv jw in nk b gy no np l nq nr"><strong class="nk io">200</strong></span><span id="2f31" class="jv jw in nk b gy oi np l nq nr"><strong class="nk io">6000</strong></span></pre><h2 id="f96d" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解释:</h2><p id="8a35" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">即使这两个函数有相同的名称，即“乘法”,但它们执行的是不同的操作，这证明了多态性的含义，即相同的名称和不同的函数。</p><h1 id="719b" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">2.运行时多态性</h1><p id="92a9" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">在 java 中，运行时多态性也称为动态绑定或动态方法分派。在这种方法中，对重写方法的调用是在运行时而不是在构建时动态解析的。<a class="ae oh" href="https://www.codingninjas.com/codestudio/library/exception-handling-with-method-overriding-in-java" rel="noopener ugc nofollow" target="_blank">方法覆盖</a>就是这样一种用于实现运行时多态性的方法。</p><p id="e869" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">现在让我们看一个运行时多态性的例子。</p><h1 id="813e" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">例子</h1><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="4fb2" class="jv jw in nk b gy no np l nq nr">class ABC{<br/>    public void myMethod(){<br/>        System.<em class="mf">out</em>.println("Overridden Method");<br/>    }<br/>}<br/>public class XYZ extends ABC{<br/><br/>    public void myMethod(){<br/>        System.<em class="mf">out</em>.println("Overriding Method");<br/>    }<br/>    public static void main(String args[]){<br/>        ABC obj = new XYZ();<br/>        obj.myMethod();<br/>    }<br/>}</span></pre><h1 id="bd67" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">输出</h1><pre class="nb nc nd ne gt nj nk nl nm aw nn bi"><span id="9f9d" class="jv jw in nk b gy no np l nq nr"><strong class="nk io">Overriding Method</strong></span></pre><h1 id="87d2" class="mj jw in bd jx mk ml mm ka mn mo mp kd mq mr ms kh mt mu mv kl mw mx my kp mz bi translated">说明</h1><p id="2f3a" class="pw-post-body-paragraph ll lm in kt b ku kv lo lp kw kx lr ls ke nf lu lv ki ng lx ly km nh ma mb lb ig bi translated">在这个例子中，我们有两个班级:ABC 和 XYZ。父类别是 ABC，而子类别是 XYZ。父类的函数 myMethod()被子类覆盖。在这个例子中，我们有一个分配给父类引用的子类对象。因此，将在运行时识别对象的类型，以确定将调用哪个方法。将被调用的方法的版本由对象的类型(而不是引用的类型)决定。</p><p id="a9b7" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">现在，学习这两个概念，我们现在可以区分这两个，</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b34d4c4492c59edd251531d2d4dc3e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*ocPmvBSp8BS8bPrNCrIx4A.png"/></div></figure><p id="eb2b" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">继承和多态是面向对象编程中的一个重要概念。在上面的文章中，我们已经彻底讨论了<strong class="kt io">继承</strong>的概念，并且已经看到了它在 Java 中的实现。试着在 JAVA 中不同类实现的基础上比较它们。我们希望你能理解这种比较，并清楚这些概念。</p><p id="b744" class="pw-post-body-paragraph ll lm in kt b ku ln lo lp kw lq lr ls ke lt lu lv ki lw lx ly km lz ma mb lb ig bi translated">留下评论，分享你的想法。</p></div></div>    
</body>
</html>