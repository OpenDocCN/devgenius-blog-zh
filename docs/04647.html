<html>
<head>
<title>Build a Stack Game using three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 three.js 构建一个堆栈游戏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-stack-game-using-three-js-ea4d09963a62?source=collection_archive---------0-----------------------#2021-04-15">https://blog.devgenius.io/build-a-stack-game-using-three-js-ea4d09963a62?source=collection_archive---------0-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9df6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 three.js 从头开始制作 3D 游戏。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b6d6fd0d591ee07e2c65fa7452d4573d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yy7j_ulAOktRqKoQ1_kEew.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://play.google.com/store/apps/details?id=com.ketchapp.stack&amp;hl=en_IN&amp;gl=US" rel="noopener ugc nofollow" target="_blank">堆栈</a></figcaption></figure><p id="0a02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">js 是一个跨浏览器的 JavaScript 库，它有助于创建和显示动画 3D 图形。它在引擎盖下使用 WebGL。</p><p id="24b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要用物理创造 3D 游戏。我们将使用 Three.js 来生成 3D 图形，使用 Cannon.js 来模拟物理。</p><p id="f570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章主要是为初学者写的。</p><h1 id="1765" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.用盒子设置场景</h1><p id="f0f7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我们创建一个 3D 场景。然后，我们将使用一个盒子的几何形状，并设置宽度，高度，深度的方块。初始化材质选项，我们使用 MeshLamberMaterial，因为它关心灯光。定位网格后，添加到场景中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="12aa" class="mu lt iq mq b gy mv mw l mx my">// Scene<br/>scene = new THREE.Scene();</span><span id="8852" class="mu lt iq mq b gy mz mw l mx my">// Add a cube to the scene<br/>const geometry = new THREE.BoxGeometry(3, 1, 3);<br/>const material = new THREE.MeshLambertMaterial({ color: 0xff0000 });<br/>const mesh = new THREE.Mesh(geometry, material);<br/>mesh.position.set(0, 0, 0);<br/>scene.add(mesh);</span></pre><h1 id="84a7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.添加灯光</h1><p id="626a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们有两种灯光——环境光和平行光。环境光从每个方向照射都有基色和强度。平行光从我们初始化的给定位置发出。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bb1b" class="mu lt iq mq b gy mv mw l mx my">// Set up lights<br/>const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);<br/>scene.add(ambientLight);</span><span id="9432" class="mu lt iq mq b gy mz mw l mx my">const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);<br/>dirLight.position.set(10, 20, 0);<br/>scene.add(dirLight);</span></pre><h1 id="effb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.摄像机位置</h1><p id="bd6c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将使用正投影。在这个投影中，无论物体离摄像机多远，它看起来都一样大，而且不会扭曲几何形状。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="52ac" class="mu lt iq mq b gy mv mw l mx my">// Camera<br/>const aspect = window.innerWidth / window.innerHeight;<br/>const width = 10;<br/>const height = width / aspect;</span><span id="ce69" class="mu lt iq mq b gy mz mw l mx my">camera = new THREE.OrthographicCamera(<br/>width / -2, // left<br/>width / 2, // right<br/>height / 2, // top<br/>height / -2, // bottom<br/>0, // near plane<br/>100 // far plane<br/>);</span><span id="b2bb" class="mu lt iq mq b gy mz mw l mx my">camera.position.set(4, 4, 4);<br/>camera.lookAt(0, 0, 0);</span></pre><h1 id="8ef4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.渲染器</h1><p id="b0a4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">它会将我们的场景渲染到浏览器中。我们正在使用 WebGL 渲染器，它会渲染一切。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1dae" class="mu lt iq mq b gy mv mw l mx my">// Set up renderer<br/>renderer = new THREE.WebGLRenderer({ antialias: true });<br/>renderer.setSize(window.innerWidth, window.innerHeight);<br/>renderer.render(scene, camera);</span><span id="7198" class="mu lt iq mq b gy mz mw l mx my">document.body.appendChild(renderer.domElement);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/57a0f7f9acc67a093af845fac4326e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DckdmZwl976wCiazd47RAg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><h1 id="6bd3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.设置游戏</h1><p id="2a78" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们已经重新构造了代码，并使一些周围的对象成为全局的。让我们制作场景、相机和渲染器全局对象，这样我们就可以在游戏中使用它来实现其他功能。</p><p id="94e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创造了游戏的基础，现在又增加了新的层面。每当我们添加一个新的层时，我们就调用基本函数。我们只需要盒子的 x &amp; z 位置，我们用这个函数计算 y 位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/61b28d32aa5fe7c2f88e19d0a33ccabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6U0BRogIkozHPNP32ILRQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">重构的基本代码</figcaption></figure><p id="ffb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了添加新层，我们创建了一个简单的 JavaScript 函数，用于将新层添加到堆栈中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5de5" class="mu lt iq mq b gy mv mw l mx my">let stack=[];<br/>const boxHeight = 1; //Height of each layer</span><span id="e651" class="mu lt iq mq b gy mz mw l mx my">function addLayer(x, z, width, depth, direction) {<br/>  const y = boxHeight * stack.length; // Add the new box one layer higher<br/>  const layer = generateBox(x, y, z, width, depth, false);<br/>  layer.direction = direction;<br/>  stack.push(layer);<br/>}</span></pre><p id="cdf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个生成框的功能。我们让它们成为独立函数，因为随着游戏的进行，我们需要不同大小的盒子，而且我们每次只调用一个函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d298" class="mu lt iq mq b gy mv mw l mx my">function generateBox(x, y, z, width, depth, falls) {<br/>  // ThreeJS<br/>  const geometry = new THREE.BoxGeometry(width, boxHeight, depth);<br/>  const color = new THREE.Color(`hsl(${30 + stack.length * 4}, 100%, 50%)`);<br/>  const material = new THREE.MeshLambertMaterial({ color });<br/>  const mesh = new THREE.Mesh(geometry, material);<br/>  mesh.position.set(x, y, z);<br/>  scene.add(mesh);</span><span id="4547" class="mu lt iq mq b gy mz mw l mx my">return {<br/>    threejs: mesh,<br/>    width,<br/>    depth<br/>  };<br/>}</span></pre><h1 id="198a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.事件处理和动画</h1><p id="5b58" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">添加一个新的全局对象来指示游戏是否开始。然后，添加一个点击监听器，它将做两件不同的事情。如果游戏已经开始，它将开始游戏，如果游戏正在进行，它将停止移动盒子并添加新层。</p><p id="550e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在动画函数中，我们选择顶层堆栈项目，并从 addlayer 函数中得知其方向。然后我们改变它的摄像机位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/642316916e83e44e0059627e9e103544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzJlVFFn1UOhQYJAl71EnA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">事件和动画功能</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d299f67c1b9b83540000b9b2ca8bdc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PJax3p7KKP-gWCiZF0U_WA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><h1 id="12a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.分割盒子</h1><p id="606f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们将做一些计算，看看移动的盒子是否与下面的盒子重叠。如果它重叠，我们分成 2 块。哪一部分突出物会散架。</p><p id="2c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将挑选前两个顶级堆栈项目并进行比较。然后我们计算网格的增量值，并从它的大小中减去。它将给出悬垂面积的大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/5e9002e962890c5ac2178ae0bf0438a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJfim0j_FIWYhiFCwUfhgg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在 eventListener 中添加了突出代码</figcaption></figure><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f846" class="mu lt iq mq b gy mv mw l mx my">let overhangs = [];<br/>function addOverhang(x, z, width, depth) {<br/>  const y = boxHeight * (stack.length - 1); // Add the new box one the same layer<br/>  const overhang = generateBox(x, y, z, width, depth, true);<br/>  overhangs.push(overhang);<br/>}</span></pre><h1 id="b0a6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.添加 Cannon.js</h1><p id="e608" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">js 是一个独立的库，它模拟物理而不是视觉。它会更新位置和方向，然后 three.js 会对其进行渲染。</p><p id="89aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 cannon.js 中设置重力</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0df6" class="mu lt iq mq b gy mv mw l mx my">// Initialize CannonJS<br/>  world = new CANNON.World();<br/>  world.gravity.set(0, -10, 0); // Gravity pulls things down<br/>  world.broadphase = new CANNON.NaiveBroadphase();<br/>  world.solver.iterations = 40;</span></pre><p id="f34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正在移动的盒子和那些在堆栈顶部的盒子没有质量，我们控制它们。</p><p id="d085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">落下来的悬垂部分有质量，Cannon.js 移动它们。</p><p id="7e16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建了两个长方体—一个有质量(cannon.js 长方体)和一个没有质量(three.js 长方体)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/6f77f68d039d1de636ced6536b4ab8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8-4SW5F0K6BbA884-8JHQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">添加了 cannon.js</figcaption></figure><p id="735c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们改变一些东西时，我们需要保持 cannon.js 同步。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4de6b788168caac60924f9377f603bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Jd8Pj_X_EHFBwDMDc3CWIQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="c3b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以按照完整的源代码更好地理解，这里是<a class="ae kv" href="https://github.com/Vikalp2502/Stack-Game" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div></div>    
</body>
</html>