<html>
<head>
<title>Build flexible abstraction for any Kubernetes Resources with CUE and KubeVela</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 CUE 和 KubeVela 为任何 Kubernetes 资源构建灵活的抽象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-flexible-abstraction-for-any-kubernetes-resources-with-cue-and-kubevela-2a7abaac4504?source=collection_archive---------9-----------------------#2022-05-30">https://blog.devgenius.io/build-flexible-abstraction-for-any-kubernetes-resources-with-cue-and-kubevela-2a7abaac4504?source=collection_archive---------9-----------------------#2022-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ea79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">由孙建波·库贝拉团队</em></p><p id="dde0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客将介绍如何使用 CUE 和 KubeVela 来构建你自己的抽象 API，以降低 Kubernetes 资源的复杂性。作为平台构建者，您可以动态定制抽象，为您的开发人员根据需求构建由浅入深的路径，适应越来越多的不同场景，满足公司长期业务发展的迭代需求。</p><h1 id="0cc5" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">将 Kubernetes API 对象转换成定制组件</h1><p id="282d" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们以使用<a class="ae lm" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> Kubernetes StatefulSet </a>为例开始这个旅程，我们将把它转换成一个定制的模块并提供功能。</p><p id="77ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将 StatefulSet 的 YAML 示例保存在本地的正式文档中，并命名为<code class="fe ln lo lp lq b">my-stateful.yaml</code>，然后执行如下命令:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="f9ae" class="lz kk in lq b gy ma mb l mc md">vela def init my-stateful -t component --desc "My StatefulSet component." --template-yaml ./my-stateful.yaml -o my-stateful.cue</span></pre><p id="2420" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看生成的“my-stateful.cue”文件:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="7242" class="lz kk in lq b gy ma mb l mc md">$ cat my-stateful.cue<br/>"my-stateful": {<br/>    annotations: {}<br/>    attributes: workload: definition: {<br/>        apiVersion: "&lt;change me&gt; apps/v1"<br/>        kind:       "&lt;change me&gt; Deployment"<br/>    }<br/>    description: "My StatefulSet component."<br/>    labels: {}<br/>    type: "component"<br/>}<br/><br/>template: {<br/>    output: {<br/>        apiVersion: "v1"<br/>        kind:       "Service"<br/>            ... // omit non-critical info<br/>    }<br/>    outputs: web: {<br/>        apiVersion: "apps/v1"<br/>        kind:       "StatefulSet"<br/>            ... // omit non-critical info<br/>    }<br/>    parameter: {}<br/>}</span></pre><p id="5948" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">按如下方式修改生成的文件:</p><ol class=""><li id="f911" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">官方 StatefulSet 网站的例子是由两个对象<code class="fe ln lo lp lq b">StatefulSet</code>和<code class="fe ln lo lp lq b">Service</code>组成的复合组件。根据 KubeVela <a class="ae lm" href="https://kubevela.io/docs/platform-engineers/components/custom-component" rel="noopener ugc nofollow" target="_blank">定制组件</a>的规则，在复合组件中，需要用<code class="fe ln lo lp lq b">template.output</code>字段来表示资源之一(我们例子中的 StatefulSet)作为核心工作负载，其他辅助对象用<code class="fe ln lo lp lq b">template.outputs</code>来表示，所以我们做了一些调整，所有自动生成的输出和输出都进行了切换。</li><li id="4540" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">然后我们将核心工作负载的 apiVersion 和 kind 数据填入标记为<code class="fe ln lo lp lq b">&lt;change me&gt;</code>的部分</li></ol><p id="9b2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">修改后，您可以使用<code class="fe ln lo lp lq b">vela def vet</code>进行格式检查和验证。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="87c2" class="lz kk in lq b gy ma mb l mc md">$ vela def vet my-stateful.cue<br/>Validation succeed.</span></pre><p id="5cc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经过两步修改后的文件如下:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="7e28" class="lz kk in lq b gy ma mb l mc md">$ cat my-stateful.cue<br/>"my-stateful": {<br/>    annotations: {}<br/>    attributes: workload: definition: {<br/>        apiVersion: "apps/v1"<br/>        kind:       "StatefulSet"<br/>    }<br/>    description: "My StatefulSet component."<br/>    labels: {}<br/>    type: "component"<br/>}<br/><br/>template: {<br/>    output: {<br/>        apiVersion: "apps/v1"<br/>        kind:       "StatefulSet"<br/>        metadata: name: "web"<br/>        spec: {<br/>            selector: matchLabels: app: "nginx"<br/>            replicas:    3<br/>            serviceName: "nginx"<br/>            template: {<br/>                metadata: labels: app: "nginx"<br/>                spec: {<br/>                    containers: [{<br/>                        name: "nginx"<br/>                        ports: [{<br/>                            name:          "web"<br/>                            containerPort: 80<br/>                        }]<br/>                        image: "k8s.gcr.io/nginx-slim:0.8"<br/>                        volumeMounts: [{<br/>                            name:      "www"<br/>                            mountPath: "/usr/share/nginx/html"<br/>                        }]<br/>                    }]<br/>                    terminationGracePeriodSeconds: 10<br/>                }<br/>            }<br/>            volumeClaimTemplates: [{<br/>                metadata: name: "www"<br/>                spec: {<br/>                    accessModes: ["ReadWriteOnce"]<br/>                    resources: requests: storage: "1Gi"<br/>                    storageClassName: "my-storage-class"<br/>                }<br/>            }]<br/>        }<br/>    }<br/>    outputs: web: {<br/>        apiVersion: "v1"<br/>        kind:       "Service"<br/>        metadata: {<br/>            name: "nginx"<br/>            labels: app: "nginx"<br/>        }<br/>        spec: {<br/>            clusterIP: "None"<br/>            ports: [{<br/>                name: "web"<br/>                port: 80<br/>            }]<br/>            selector: app: "nginx"<br/>        }<br/>    }<br/>    parameter: {}<br/>}</span></pre><p id="0a55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将 ComponentDefinition 安装到 Kubernetes 集群中:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="c6f4" class="lz kk in lq b gy ma mb l mc md">$ vela def apply my-stateful.cue<br/>ComponentDefinition my-stateful created in namespace vela-system.</span></pre><p id="a6d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以通过<code class="fe ln lo lp lq b">vela components</code>命令看到一个<code class="fe ln lo lp lq b">my-stateful</code>组件:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="4de4" class="lz kk in lq b gy ma mb l mc md">$ vela components<br/>NAME        NAMESPACE   WORKLOAD                                DESCRIPTION<br/>...<br/>my-stateful vela-system statefulsets.apps                       My StatefulSet component.<br/>...</span></pre><p id="f863" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您将这个定制的组件放入<code class="fe ln lo lp lq b">Application</code>时，它看起来像:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="1e19" class="lz kk in lq b gy ma mb l mc md">cat &lt;&lt;EOF | vela up -f -<br/>apiVersion: core.oam.dev/v1beta1<br/>kind: Application<br/>metadata:<br/>  name: website<br/>spec:<br/>  components:<br/>    - name: my-component<br/>      type: my-stateful<br/>EOF</span></pre><h1 id="3dfb" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">为组件定义自定义参数</h1><p id="c398" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在上一节中，我们已经定义了一个没有参数的 ComponentDefinition。在这一节中，我们将展示如何公开参数。</p><p id="7224" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，我们向用户公开了以下参数:</p><ul class=""><li id="dc1f" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh ms mk ml mm bi translated">图像名称，允许用户自定义图像</li><li id="fdb1" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh ms mk ml mm bi translated">实例名，允许用户自定义生成的 StatefulSet 对象和服务对象的实例名</li></ul><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="47ad" class="lz kk in lq b gy ma mb l mc md">... # Omit other unmodified fields<br/>    template: {<br/>        output: {<br/>            apiVersion: "apps/v1"<br/>            kind:       "StatefulSet"<br/>            metadata: name: parameter.name<br/>            spec: {<br/>                selector: matchLabels: app: "nginx"<br/>                replicas:    3<br/>                serviceName: "nginx"<br/>                template: {<br/>                    metadata: labels: app: "nginx"<br/>                    spec: {<br/>                        containers: [{<br/>                            image: parameter.image<br/>        <br/>                            ... // Omit other unmodified fields<br/>                        }]<br/>                    }<br/>                }<br/>                    ... // Omit other unmodified fields<br/>            }<br/>        }<br/>        outputs: web: {<br/>            apiVersion: "v1"<br/>            kind:       "Service"<br/>            metadata: {<br/>                name: "nginx"<br/>                labels: app: "nginx"<br/>            }<br/>            spec: {<br/>                ... // Omit other unmodified fields <br/>            }<br/>        }<br/>        parameter: {<br/>            image: string<br/>            name: string<br/>        }<br/>    }</span></pre><p id="53c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">修改后，使用<code class="fe ln lo lp lq b">vela def apply</code>安装到集群:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="66a4" class="lz kk in lq b gy ma mb l mc md">$ vela def apply my-stateful.cue<br/>ComponentDefinition my-stateful in namespace vela-system updated.</span></pre><p id="f3df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，作为平台构建者，您已经完成了设置。看看现在的开发者体验如何。</p><h1 id="6588" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">开发者体验</h1><p id="8bf0" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">你的开发者唯一需要学习的是<a class="ae lm" href="https://oam.dev/" rel="noopener ugc nofollow" target="_blank">开放应用模型</a>，它总是遵循统一的格式。</p><h2 id="85f3" class="lz kk in bd kl mt mu dn kp mv mw dp kt jv mx my kx jz mz na lb kd nb nc lf nd bi translated">发现组件</h2><p id="08cc" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">开发人员可以发现并检查<code class="fe ln lo lp lq b">my-stateful</code>组件的参数，如下所示:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="7f38" class="lz kk in lq b gy ma mb l mc md">$ vela def list<br/>NAME                            TYPE                    NAMESPACE   DESCRIPTION<br/>my-stateful                     ComponentDefinition     vela-system My StatefulSet component.<br/>...snip...</span><span id="71ec" class="lz kk in lq b gy ne mb l mc md">$ vela show my-stateful<br/># Properties<br/>+----------+-------------+--------+----------+---------+<br/>|   NAME   | DESCRIPTION |  TYPE  | REQUIRED | DEFAULT |<br/>+----------+-------------+--------+----------+---------+<br/>| name     |             | string | true     |         |<br/>| image    |             | string | true     |         |<br/>+----------+-------------+--------+----------+---------+</span></pre><p id="3c96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新 ComponentDefinition 不会影响现有的应用程序。只有在下次更新应用程序后，它才会生效。</p><h2 id="20bb" class="lz kk in bd kl mt mu dn kp mv mw dp kt jv mx my kx jz mz na lb kd nb nc lf nd bi translated">在应用程序中使用组件</h2><p id="db25" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">开发人员可以在应用程序中轻松指定三个新参数:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="99fe" class="lz kk in lq b gy ma mb l mc md">apiVersion: core.oam.dev/v1beta1<br/>    kind: Application<br/>    metadata:<br/>      name: website<br/>    spec:<br/>      components:<br/>        - name: my-component<br/>          type: my-stateful<br/>          properties:<br/>            image: nginx:latest<br/>            name: my-component</span></pre><p id="7413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">剩下唯一要做的就是通过执行<code class="fe ln lo lp lq b">vela up -f app-stateful.yaml</code>来部署 yaml 文件(假设名称为<code class="fe ln lo lp lq b">app-stateful.yaml</code>)。</p><p id="f21a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后您可以看到 StatefulSet 对象的名称、图像和实例数量已经更新。</p><h1 id="c4f7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">用于诊断或集成的试运行<a class="ae lm" href="https://kubevela.io/blog/2022/05/30/abstraction-kubevela#dry-run-for-diagnose-or-integration" rel="noopener ugc nofollow" target="_blank"> # </a></h1><p id="5323" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">为了确保开发人员的应用程序能正确运行参数，你也可以使用<code class="fe ln lo lp lq b">vela dry-run</code>命令来验证你的模板的试运行。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="55da" class="lz kk in lq b gy ma mb l mc md">vela dry-run -f app-stateful.yaml</span></pre><p id="3bcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过查看输出，您可以比较生成的对象是否与您实际期望的对象一致。您甚至可以直接在 Kubernetes 集群中执行这个 YAML，并使用操作的结果进行验证。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="6cbb" class="lz kk in lq b gy ma mb l mc md"># Application(website) -- Component(my-component)<br/>---<br/><br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: nginx<br/>    app.oam.dev/appRevision: ""<br/>    app.oam.dev/component: my-component<br/>    app.oam.dev/name: website<br/>    workload.oam.dev/type: my-stateful<br/>  name: nginx<br/>  namespace: default<br/>spec:<br/>  clusterIP: None<br/>  ports:<br/>  - name: web<br/>    port: 80<br/>  selector:<br/>    app: nginx<br/>  template:<br/>    spec:<br/>      containers:<br/>      - image: saravak/fluentd:elastic<br/>        name: my-sidecar<br/><br/>---<br/>apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  labels:<br/>    app.oam.dev/appRevision: ""<br/>    app.oam.dev/component: my-component<br/>    app.oam.dev/name: website<br/>    trait.oam.dev/resource: web<br/>    trait.oam.dev/type: AuxiliaryWorkload<br/>  name: web<br/>  namespace: default<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  serviceName: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - image: k8s.gcr.io/nginx-slim:0.8<br/>        name: nginx<br/>        ports:<br/>        - containerPort: 80<br/>          name: web<br/>        volumeMounts:<br/>        - mountPath: /usr/share/nginx/html<br/>          name: www<br/>      terminationGracePeriodSeconds: 10<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: www<br/>    spec:<br/>      accessModes:<br/>      - ReadWriteOnce<br/>      resources:<br/>        requests:<br/>          storage: 1Gi<br/>      storageClassName: my-storage-class</span></pre><p id="749d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以使用<code class="fe ln lo lp lq b">vela dry-run -h</code>查看更多可用的功能参数。</p><h1 id="5da8" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">使用<code class="fe ln lo lp lq b">context</code>避免重复</h1><p id="98ac" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">KubeVela 允许您通过<code class="fe ln lo lp lq b"><a class="ae lm" href="https://kubevela.io/docs/platform-engineers/components/custom-component#cue-context" rel="noopener ugc nofollow" target="_blank">context</a></code> <a class="ae lm" href="https://kubevela.io/docs/platform-engineers/components/custom-component#cue-context" rel="noopener ugc nofollow" target="_blank">关键字</a>引用应用程序的运行时信息。</p><p id="9109" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，属性中的字段<code class="fe ln lo lp lq b">name</code>和组件的字段<code class="fe ln lo lp lq b">name</code>具有相同的含义，所以我们可以使用<code class="fe ln lo lp lq b">context</code>来避免重复。我们不能在运行时使用<code class="fe ln lo lp lq b">context.name</code>来引用组件名，因此不再需要<code class="fe ln lo lp lq b">parameter</code>中的 name 参数。</p><p id="d52a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需将定义文件(my-stateful.cue)修改如下</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="85c5" class="lz kk in lq b gy ma mb l mc md">... # Omit other unmodified fields<br/>template: {<br/>    output: {<br/>        apiVersion: "apps/v1"<br/>        kind:       "StatefulSet"<br/>-       metadata: name: parameter.name<br/>+       metadata: name: context.name<br/><br/>            ... // Omit other unmodified field<br/><br/>    }<br/>    parameter: {<br/>-       name: string<br/>        image: string<br/>    }<br/>}</span></pre><p id="2159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后通过以下方式部署更改:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="084d" class="lz kk in lq b gy ma mb l mc md">vela def apply my-stateful.cue</span></pre><p id="fe64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，开发人员可以立即运行如下应用程序:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="14f6" class="lz kk in lq b gy ma mb l mc md">apiVersion: core.oam.dev/v1beta1<br/>    kind: Application<br/>    metadata:<br/>      name: website<br/>    spec:<br/>      components:<br/>        - name: my-component<br/>          type: my-stateful<br/>          properties:<br/>            image: "nginx:latest"</span></pre><p id="1f37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">任何系统都没有升级或重启，它们都在根据您的需要动态运行。</p><h1 id="6849" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">按需添加运营特征</h1><p id="7e95" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">OAM 遵循“关注点分离”的原则，在开发人员完成组件部分后，操作员可以将特性添加到应用程序中，以控制部署的其余部分配置。例如，操作员可以<br/>控制副本，添加标签/注释，注入环境变量/侧车，添加持久卷，等等。</p><p id="fd0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从技术上讲，特质系统以两种方式工作:</p><ul class=""><li id="380a" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh ms mk ml mm bi translated">修补/覆盖组件中定义的配置。</li><li id="9c5a" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh ms mk ml mm bi translated">生成更多配置。</li></ul><p id="b9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">定制过程与组件的工作方式相同，它们都使用 CUE，但是对于路径和覆盖有一些不同的关键字，具体可以参考<a class="ae lm" href="https://kubevela.io/docs/platform-engineers/traits/customize-trait" rel="noopener ugc nofollow" target="_blank">定制特性</a>。</p><h1 id="a2d7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">操作员对特性的经验</h1><p id="9def" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">KubeVela 安装后，已经有了一些内置特性。操作员可以使用<code class="fe ln lo lp lq b">vela traits</code>查看，用<code class="fe ln lo lp lq b">*</code>标记的性状是一般性状，可以对常见的库本内特资源对象进行操作。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="2e1d" class="lz kk in lq b gy ma mb l mc md">$ vela traits<br/>NAME                        NAMESPACE   APPLIES-TO          CONFLICTS-WITH  POD-DISRUPTIVE  DESCRIPTION<br/>annotations                 vela-system *                                   true            Add annotations on K8s pod for your workload which follows<br/>                                                                                            the pod spec in path 'spec.template'.<br/>configmap                   vela-system *                                   true            Create/Attach configmaps on K8s pod for your workload which<br/>                                                                                            follows the pod spec in path 'spec.template'.<br/>labels                      vela-system *                                   true            Add labels on K8s pod for your workload which follows the<br/>                                                                                            pod spec in path 'spec.template'.<br/>scaler                      vela-system *                                   false           Manually scale K8s pod for your workload which follows the<br/>                                                                                            pod spec in path 'spec.template'.<br/>sidecar                     vela-system *                                   true            Inject a sidecar container to K8s pod for your workload<br/>                                                                                            which follows the pod spec in path 'spec.template'.<br/>...snip...</span></pre><p id="219a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以 sidecar 为例，您可以查看 sidecar 的使用情况:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="2f13" class="lz kk in lq b gy ma mb l mc md">$ vela show sidecar<br/># Properties<br/>+---------+-----------------------------------------+-----------------------+----------+---------+<br/>|  NAME   |               DESCRIPTION               |         TYPE          | REQUIRED | DEFAULT |<br/>+---------+-----------------------------------------+-----------------------+----------+---------+<br/>| name    | Specify the name of sidecar container   | string                | true     |         |<br/>| cmd     | Specify the commands run in the sidecar | []string              | false    |         |<br/>| image   | Specify the image of sidecar container  | string                | true     |         |<br/>| volumes | Specify the shared volume path          | [[]volumes](#volumes) | false    |         |<br/>+---------+-----------------------------------------+-----------------------+----------+---------+<br/><br/><br/>## volumes<br/>+------+-------------+--------+----------+---------+<br/>| NAME | DESCRIPTION |  TYPE  | REQUIRED | DEFAULT |<br/>+------+-------------+--------+----------+---------+<br/>| path |             | string | true     |         |<br/>| name |             | string | true     |         |<br/>+------+-------------+--------+----------+---------+</span></pre><p id="883d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用侧车直接向容器内注射，应用说明如下:</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="62fc" class="lz kk in lq b gy ma mb l mc md">apiVersion: core.oam.dev/v1beta1<br/>kind: Application<br/>metadata:<br/>  name: website<br/>spec:<br/>  components:<br/>    - name: my-component<br/>      type: my-stateful<br/>      properties:<br/>        image: nginx:latest<br/>        name: my-component<br/>      traits:<br/>      - type: sidecar<br/>        properties:<br/>          name: my-sidecar<br/>          image: saravak/fluentd:elastic</span></pre><p id="ad71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">部署并运行应用程序，您可以看到一辆满载的侧车已经在 StatefulSet 中部署并运行。</p><p id="f95c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">组件和特性都可以在任何 KubeVela 系统上重复使用，我们可以将组件、特性和 CRD 控制器打包成一个插件。社区中有越来越多的插件目录。</p><h1 id="0f82" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">总结</h1><p id="6ccc" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">本博客介绍了如何通过 CUE 提供完整的模块化功能。其核心是可以根据用户需求动态增加配置能力，逐步暴露更多的功能和用途，从而降低用户的整体学习门槛，最终提高 R&amp;D 效率。KubeVela 提供的现成功能，包括组件、特性、策略和工作流，也被设计成可插入和可修改的功能。</p></div></div>    
</body>
</html>