<html>
<head>
<title>Iterator &amp; Composite patterns for managing aggregates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迭代器&amp;管理聚合的复合模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/iterator-composite-patterns-for-managing-collection-kotlin-fda036ffda9f?source=collection_archive---------11-----------------------#2022-04-11">https://blog.devgenius.io/iterator-composite-patterns-for-managing-collection-kotlin-fda036ffda9f?source=collection_archive---------11-----------------------#2022-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="61c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di"> W </span>欢迎回到致力于<strong class="jm io">设计模式的老牌系列</strong>🙌。如果你是第一次来这里:这是一系列的文章，其中我分解了每个模式&amp;提供代码解决方案、设计原则、绘图——以使模式在你的 brain🧠中很好地堆叠</p><p id="d8f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面你可以看到发表的文章。请务必深入研究，因为其中包含大量信息:</p><ul class=""><li id="b7ef" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="f90b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="c5dc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="109f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li><li id="4d76" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">单例模式:<a class="ae la" href="/dev-genius/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/singleton-pattern-for-one-of-a-class-objects-Java-a63c 774 d9d 4</a></li><li id="bb4f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">命令模式:<a class="ae la" href="/dev-genius/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/command-pattern-for-encapsulated-invocation-kot Lin-4338 EB 23 D2 ca</a></li><li id="a923" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">适配器和外观模式:<a class="ae la" href="/dev-genius/adapter-facade-pattern-for-perfect-adapting-kotlin-ccbc8f8cfcd6" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/adapter-Facade-pattern-for-perfect-adapting-kot Lin-ccbc 8 f 8 cfcd 6</a></li><li id="fa67" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">模板模式:<a class="ae la" href="https://medium.com/dev-genius/template-pattern-for-encapsulating-algorithms-kotlin-3ded81377fc5" rel="noopener">https://medium . com/dev-genius/template-pattern-for-encapsulating-algorithms-kot Lin-3d ed 81377 fc 5</a></li></ul><p id="c275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像往常一样，感谢<a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----fda036ffda9f--------------------------------" rel="noopener" target="_blank">奥莱利传媒</a>创作出这样一部恒星书:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="bf8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="9b78" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="2c0c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题:迭代器模式</li><li id="7e7a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">题外话第一节</li><li id="c18c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">要遵循的设计原则</li><li id="2f57" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">题外话第二节</li><li id="2c41" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码:迭代器模式</li><li id="2f52" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题:复合模式</li><li id="891d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码:复合模式</li><li id="7618" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="f30f" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">迭代器和复合模式</h1><h2 id="d041" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">介绍</h2><p id="af4f" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">有许多数据结构允许你存储数据💼。每一种都有它的优点和缺点。我们有数组、链表、各种类型的树、哈希表、哈希集、图表等等…</p><blockquote class="ne nf ng"><p id="a2eb" class="jk jl nh jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated">嘿，看看我的关于 AVL 树的文章，在那里我讨论了各种数据结构，然后分解了 AVL 树🌲:<a class="ae la" href="https://medium.com/dev-genius/run-down-of-avl-trees-full-run-down-e8551a5fc981" rel="noopener">https://medium . com/dev-genius/run-down-of-AVL-trees-full-run-down-e 8551 a5 fc 981</a></p></blockquote><p id="04da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果我们的服务需要与具有不同数据结构的系统进行交互，该怎么办呢？你可能会问什么问题🤔？</p><p id="d8c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，一个系统将数据保存在<strong class="jm io">数组</strong>中，而另一个保存在<strong class="jm io">数组列表</strong>中。请看下面它们是如何被穿越的:</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有 10 多个系统与我们的服务进行交互。这会是巨大的痛苦😓</p><p id="6210" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决方案？-&gt;用一些熟练的 technique⚡️统一遍历</p><h2 id="b86d" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">问题:迭代器模式</h2><p id="2731" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">继续我在上一节中提到的扣人心弦的话题。很明显，我们需要一些模式，特别是这里的——<strong class="jm io">迭代器</strong> ➰.</p><p id="ddd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在之前的设计中有什么不好的地方(当我们需要有多个循环的时候):</p><ul class=""><li id="2606" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">我们编码到<strong class="jm io">实现</strong>，而不是<strong class="jm io">接口</strong></li><li id="970e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">新数据结构将促使我们重新开放服务，并添加代码来遍历特定的结构</li><li id="45fd" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">服务需要知道<strong class="jm io">如何</strong>遍历数据结构——违反封装原则</li><li id="8094" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">重复代码——相同的迭代(好的，不完全相同，但是非常相似)</li></ul><p id="f976" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决所有 mess❓的方法-&gt; <strong class="jm io">封装迭代</strong>。(不能不提<strong class="jm io">封装调用</strong>的命令模式。是的，如果你对我的文章感到困惑，可以看看🤷🏻‍♂️:<a class="ae la" href="/dev-genius/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/command-pattern-for-encapsulated-invocation-kot Lin-4338 EB 23 D2 ca</a></p><p id="8068" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在大多数情况下，我们使用迭代器的<code class="fe ns nt nu nv b">interface</code>，它公开了两个方法:<code class="fe ns nt nu nv b">hasNext()</code> &amp; <code class="fe ns nt nu nv b">next()</code>。前者是检查当前数据结构是否有下一个元素，后者是完成遍历。</p><p id="7f3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们创建<em class="nh">自定义迭代器</em>，它继承自那个<code class="fe ns nt nu nv b">interface</code>。它实现了这两种方法，这两种方法包含了特定数据结构上的迭代方式。不要惊慌🤚，我将在代码部分进行详细的运行。</p><p id="7f4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们的服务与 classes⚙️.系统内部的具体实现是分离的</p><blockquote class="ne nf ng"><p id="0e39" class="jk jl nh jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated">数据结构可以命名为<strong class="jm io">聚合</strong>。也记住这个单词</p></blockquote><p id="7934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理想情况下，这些系统应该有一些支配性的<code class="fe ns nt nu nv b">interface</code>,我们可以在我们的服务中使用这些系统，以便进一步解耦。当然，这并不总是可能的，但是要记住这一点👌🏼</p><h2 id="7c25" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">题外话第一节🎏</h2><p id="98e4" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">如果我告诉你我们并不总是需要从头开始实现<strong class="jm io">迭代器</strong>呢？有些数据结构有内置的迭代器，比如<code class="fe ns nt nu nv b">ArrayList()</code>。我们只需调用<code class="fe ns nt nu nv b">currArrayList.iterator()</code>，一切都像 charm🪄一样工作。你可以看看下面的代码示例，看看它是如何在 Java 中完成的:</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="22d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，看看<code class="fe ns nt nu nv b">Iterator&lt;MenuItem&gt;</code>:它属于迭代器类型，在聚合中有<strong class="jm io">的内容。这是什么意思？我尽量锤家的是，不要写:<code class="fe ns nt nu nv b">Iterator&lt;ArrayList&lt;MenuItem&gt;&gt;</code> <strong class="jm io">不！</strong> ⛔️我们指定那个<strong class="jm io">集合</strong>里面是什么。</strong></p><p id="dd2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在理想情况下，我们有以下结构:</p><pre class="nl nm nn no gt nw nv nx ny aw nz bi"><span id="7ee2" class="mn lq in nv b gy oa ob l oc od">Interface for systems   &lt;-  Our Service  -&gt; Interface for Iterator<br/>      /     \                                  /            <br/>SomeSystem1 SomeSystem2             Implemented Interface             </span></pre><p id="efb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">只是重复一下</strong>😬<strong class="jm io"> : </strong>当我们使用内置接口时，不需要为迭代器实现那个<code class="fe ns nt nu nv b">interface</code>。</p><p id="3d52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">❗️byway❗️，如果你错过了:系统<strong class="jm io">必须提供</strong>方法，我们的服务用它来接收迭代器对象。这意味着:系统为它们的<strong class="jm io">集合</strong>实现<strong class="jm io">迭代器</strong>，并赋予那个<strong class="jm io">迭代器</strong>。我们知道，有 2 种方法:<code class="fe ns nt nu nv b">hasNext()</code> &amp; <code class="fe ns nt nu nv b">next()</code>。所以，我们用它们来遍历数据结构。</p><p id="90d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就引出了非常重要的<strong class="jm io">设计原则</strong> …</p><h2 id="c405" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">要遵循的设计原则</h2><ol class=""><li id="5500" class="kr ks in jm b jn mz jr na jv oe jz of kd og kh oh kx ky kz bi translated"><strong class="jm io">单一责任原则</strong> ☝️: a 类应该只有一个改变的理由。</li></ol><ul class=""><li id="1100" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">如果我们允许一个类<strong class="jm io">保持</strong> <strong class="jm io">聚合</strong> &amp;来<strong class="jm io">遍历</strong>它会怎么样？- &gt;糟糕👎🏼如果我们想改变数据结构= &gt;改变的 2 个原因:第一是<strong class="jm io">聚合</strong>本身&amp;第二是<strong class="jm io">我们迭代</strong>的方式。</li><li id="c36d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">迭代器模式</strong>帮助我们:<strong class="jm io">系统</strong>保持聚合&amp; <strong class="jm io">迭代器</strong>遍历它= &gt;关注点是分开的</li></ul><blockquote class="ne nf ng"><p id="d67e" class="jk jl nh jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated">内聚性:类被构造的方式。如果围绕类似功能:<em class="in">高内聚</em>。如果不是:<em class="in">衔接度低</em> = &gt;非常不好</p></blockquote><h2 id="52bc" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">题外话第二节👣</h2><p id="cdd6" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">本节涵盖了一点侧面:</p><ul class=""><li id="b930" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><code class="fe ns nt nu nv b">Iterator</code>-&gt;-<code class="fe ns nt nu nv b">Iterable</code>-&gt;-<code class="fe ns nt nu nv b">Collections</code>是链条中第一个是所有的父。这是什么意思？<code class="fe ns nt nu nv b">Iterable</code>提供增强的<code class="fe ns nt nu nv b">for</code>循环，如果您确定只有这种类型的<strong class="jm io">聚集</strong>，这可能会简化您的模式。然而，<code class="fe ns nt nu nv b">Array</code>不是一个<code class="fe ns nt nu nv b">iterable</code>，因此在我们的代码中，我们不会以它作为模式的基础。而且，如果我们有集合，那么我们肯定能够在它上面调用<code class="fe ns nt nu nv b">iterator()</code>。</li><li id="ba25" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe ns nt nu nv b">HashMap</code>有所谓的创建迭代器的隐式方式:<code class="fe ns nt nu nv b">ourHashMap.values().iterator()</code>作为<code class="fe ns nt nu nv b">values()</code>代码返回<strong class="jm io">集合</strong>。所以，我们可以使用内置的<strong class="jm io">迭代器</strong>，因为<strong class="jm io">集合</strong>继承自<strong class="jm io">可迭代</strong>，后者又继承自<strong class="jm io">迭代器</strong>。</li></ul><h2 id="fe3c" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">最终解决方案代码:迭代器模式</h2><p id="99cd" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">现在，让我们深入代码，观察一切是如何匹配的。像往常一样，我的回购，我会描述如下:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/Iterator_Composite/IteratorPattern" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd io gy z fp oq fr fs or fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/Iterator _ Composite/Iterator pattern at main…</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">Kotlin + Medium 文章中的设计模式。通过以下方式为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz pa ol"/></div></div></a></div><ol class=""><li id="0487" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh oh kx ky kz bi translated"><code class="fe ns nt nu nv b">OurService.kt</code>是我们的服务，它获取具体的系统类，我们对它们进行迭代:<br/> *我们提供我们想要迭代的对象<br/> * <code class="fe ns nt nu nv b">createIterator()</code>应用于它们以获取迭代器。<br/> *我们调用方法，该方法使用<code class="fe ns nt nu nv b">hasNext()</code>来检查集合&amp; <code class="fe ns nt nu nv b">next()</code>中是否还有一些元素，以实际单步执行<br/> *我们在所有系统(<code class="fe ns nt nu nv b">interface</code>)上提供从那个<strong class="jm io">抽象</strong>继承的对象。如果你有这样的选择就好了——代码变得更加<strong class="jm io">解耦</strong>。</li><li id="6b70" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh oh kx ky kz bi translated"><code class="fe ns nt nu nv b">Iterator.kt</code>、<code class="fe ns nt nu nv b">CustomIteratorArrayList.kt</code>、<code class="fe ns nt nu nv b">CustomIterator.kt</code>是文件，其中:<code class="fe ns nt nu nv b">interface</code>用于所有迭代器&amp;具体迭代器实现具体数据结构迭代的逻辑</li></ol><p id="01a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">❗️Attention:❗️我没有故意在数组列表上使用<code class="fe ns nt nu nv b">iterator()</code>，因为 Kotlin 和 Java 有些不同。此外，为了简单起见，我使用了<code class="fe ns nt nu nv b">List</code>，这也是因为 Java &amp; Kotlin 之间的一些差异，我不想在这里公开。</p><p id="78a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<code class="fe ns nt nu nv b">Menu.kt</code>是我们的<code class="fe ns nt nu nv b">interface</code>对于拥有它的系统来说是件好事(我之前已经提到过几次了)</p><p id="5756" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<code class="fe ns nt nu nv b">MenuWithArray.kt</code>、<code class="fe ns nt nu nv b">MenuWithArrayList.kt</code>是我们在系统中的具体类</p><p id="c94c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.<code class="fe ns nt nu nv b">MenuItem.kt</code>是我们在&amp;之上的那些类中创建的内容，是放在<strong class="jm io">聚合</strong>中的内容。所以，当使用<strong class="jm io">迭代器</strong>时，我们得到这个对象。</p><p id="4e31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，如果你仔细考虑一下我们向服务添加新元素的方式——这并不是最好的方式，因为我们违反了"<strong class="jm io">开放封闭原则</strong>"(我在专门讨论"装饰模式"的文章中讨论过这一点—<a class="ae la" href="https://medium.com/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener">https://medium . com/towardsdev/Decorator-Decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a>)。在这种特殊情况下，这并不坏，因为这可能是我们要坚持的设计的怪癖(是的，并不是所有的模式指南都应该被视为必要的东西。有时我们会为了适应现在的 design🧑‍而离开💻)</p><p id="8767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们需要解决更多的问题，但是让我们在下一部分讨论它🤟🏼</p><h2 id="9079" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">问题:复合模式</h2><p id="11ef" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">因此，假设我们不仅想为我们的<strong class="jm io">集合</strong>提供元素，还想为我们的系统提供包含元素的子类:</p><pre class="nl nm nn no gt nw nv nx ny aw nz bi"><span id="bcbc" class="mn lq in nv b gy oa ob l oc od">                       System<br/>                     /      |    <br/>                element   sub-system<br/>                           |       \<br/>                         element  element</span></pre><ul class=""><li id="19c7" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">其中<code class="fe ns nt nu nv b">element</code>可以不是简单的<code class="fe ns nt nu nv b">Int</code>、<code class="fe ns nt nu nv b">String</code>，而是某个类的实例，比如<strong class="jm io">迭代器模式</strong> — <code class="fe ns nt nu nv b">MenuItem</code>的例子</li></ul><p id="9e47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，我们可能在这里利用迭代器，但这将是某种混乱🌪如果我们有单独的模式，致力于这样的任务，为什么要这样做呢？</p><p id="06ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相遇👐🏽:<strong class="jm io">复合图案</strong></p><p id="ebcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此模式允许您:</p><ul class=""><li id="4096" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">统一处理系统<strong class="jm io">中的对象</strong></li><li id="d400" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">代表部分-整体结构(系统-元素)</li></ul><p id="2362" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一律</strong>🧐是什么意思？—我们可以对两者都应用方法:系统&amp;元素，而不必在意。所以，我们可以忽略&amp;系统元素之间的差异。</p><p id="b3c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿，让我们使用与模式相关的词汇👻：</p><ul class=""><li id="940b" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">所有元件都是<strong class="jm io">组件</strong></li><li id="730f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">由其他元素组成的元素— <strong class="jm io">复合</strong></li><li id="24e0" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">没有其他元素的元素——<strong class="jm io">叶子</strong></li></ul><p id="612b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哦，听起来对树形结构很熟悉？事实上，它是👀。这种模式通常以树的形式表示🌳：</p><pre class="nl nm nn no gt nw nv nx ny aw nz bi"><span id="2b05" class="mn lq in nv b gy oa ob l oc od">                     All Systems</span><span id="c5e6" class="mn lq in nv b gy pb ob l oc od">                    /       |          \<br/>               System    System      System<br/>              /   |         |  \           \<br/>        element1 element2 sub-system     element1<br/>                          /    \<br/>                     element1 element2</span></pre><ul class=""><li id="e306" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">其中<em class="nh">系统</em>是一个<strong class="jm io">复合</strong> &amp; <em class="nh">元素</em>是一个<strong class="jm io">叶</strong></li><li id="fb74" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">但是它们都被认为是<strong class="jm io">组件</strong></li></ul><p id="9b6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我给了你模式的整体结构&amp;告诉你它的实现方式。让我们继续到代码部分，在那里我将展示一切应该如何实现&amp;哪些时刻需要注意🌝</p><h2 id="6491" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">最终解决方案代码:复合模式</h2><p id="6c5a" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">和以前一样，这里是我的回购的链接:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/Iterator_Composite/Composite" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd io gy z fp oq fr fs or fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/Iterator _ Composite/Composite at main…</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">Kotlin + Medium 文章中的设计模式。通过以下方式为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz pa ol"/></div></div></a></div><ol class=""><li id="9f73" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh oh kx ky kz bi translated">我们需要基本的<strong class="jm io">组件</strong>，它将是<strong class="jm io">复合</strong> &amp; <strong class="jm io">叶<br/> * </strong>文件:<code class="fe ns nt nu nv b">MenuComponent.kt</code> <br/> *使用<code class="fe ns nt nu nv b">abstract class</code>作为我们提供的默认实现:<code class="fe ns nt nu nv b">throw</code>异常<br/> *一些方法将被<strong class="jm io">叶</strong>覆盖/实现，一些被<strong class="jm io">复合</strong>覆盖/实现</li></ol><p id="bc1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<code class="fe ns nt nu nv b">MenuItem.kt</code>是一片<strong class="jm io">叶子</strong>。实际上，您可以从<strong class="jm io">迭代器</strong>部分回忆起这个类。这里它从<code class="fe ns nt nu nv b">MenuComponent</code>继承并实现了一些方法</p><p id="700f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<code class="fe ns nt nu nv b">Menu.kt</code>是一个<strong class="jm io">复合</strong>，它也继承自<code class="fe ns nt nu nv b">MenuComponent</code>。它有一个由类型<code class="fe ns nt nu nv b">MenuComponent</code> = &gt;组成的<strong class="jm io">集合</strong>，这意味着我们可以放置两者:<strong class="jm io">复合</strong> &amp; <strong class="jm io">叶</strong>。它还实现/覆盖了<code class="fe ns nt nu nv b">abstract class</code>中的一些方法</p><p id="986f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.在<code class="fe ns nt nu nv b">main.kt</code>中，我们创建<code class="fe ns nt nu nv b">allMenus</code>，在那里我们转储由<strong class="jm io">叶</strong>或<strong class="jm io">复合</strong>(子菜单)组成的<strong class="jm io">复合</strong></p><p id="c8c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，关于来自<code class="fe ns nt nu nv b">abstract class</code>的方法:</p><ul class=""><li id="860e" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">有些只在<strong class="jm io">叶</strong>中实现，有些—只在<strong class="jm io">复合</strong>中实现。但是，这两个类中都实现了一些方法。因此，如果它们在两者中都实现了——统一处理对象<strong class="jm io">和</strong></li><li id="8f38" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">如果我们没有实现某些方法，而用户最终使用了它们，就会弹出异常<em class="nh"/></li><li id="b5e7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe ns nt nu nv b">print()</code>是一种我们将在下面详细讨论的方法</li></ul><p id="ab23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于<code class="fe ns nt nu nv b">print()</code>:</p><ul class=""><li id="3b60" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">它遍历一个<strong class="jm io">复合</strong>的集合中的项目，并执行以下操作:<br/> *如果<strong class="jm io">叶</strong>:打印<strong class="jm io">叶</strong> <br/> *如果<strong class="jm io">复合</strong>:输入<strong class="jm io">复合</strong>并打印该<strong class="jm io">复合</strong>的<strong class="jm io">叶</strong>的信息。然后回到初始合成:如果满足<strong class="jm io"> leaf </strong> - &gt;打印其信息，如果满足<strong class="jm io">composite</strong>-重复上述过程</li><li id="99ea" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">此外，对于集合，我使用<code class="fe ns nt nu nv b">iterator pattern</code>而不是<code class="fe ns nt nu nv b">for loop</code>来遍历复合(<code class="fe ns nt nu nv b">Menu.kt </code>)中的元素，因为我们可能会在某些<strong class="jm io">复合</strong>中遇到<strong class="jm io">数组</strong>，这将使我们处于不利的位置。这里我们把每个元素一个一个的&amp;应用<code class="fe ns nt nu nv b">print()</code>在上面。然后，该过程将如上所述——取决于组件:<strong class="jm io">叶</strong> || <strong class="jm io">复合</strong></li><li id="493f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">是的，如果你在目前的情况下不想/需要一个单独的<code class="fe ns nt nu nv b">interface</code>,你需要或者为这个<strong class="jm io">聚合</strong>迭代器实现<code class="fe ns nt nu nv b">interface</code>,或者在<strong class="jm io">聚合</strong>上使用<code class="fe ns nt nu nv b">.iterator()</code></li></ul><p id="4d91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有就是<strong class="jm io">复合迭代器</strong>这种东西。它类似于普通的，但有它自己的怪癖。然而，我想在本文中跳过它🚵🏼‍♂️</p><h2 id="ba5e" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">图画🏮</h2><p id="4ac2" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated"><strong class="jm io">迭代器模式</strong></p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="pe pf di pg bf ph"><div class="gh gi pd"><img src="../Images/02a2dbc2f1cc714d6e92b28b95f2c01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuKL_sH6ZPEELtDdtI31Dg.jpeg"/></div></div></figure><p id="4d4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">复合图案</strong></p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="pe pf di pg bf ph"><div class="gh gi pd"><img src="../Images/44118307e4dda9617f0ccea26c13c627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snEfz9z257ZKyfPxfDb1aQ.jpeg"/></div></div></figure><p id="9d00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，你可以看到两个独立的图形，分别对应于每一种图案💫</p><p id="b65d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试分解设计，但是如果有不清楚的地方——留下评论&amp;我会来回答的👋🏻</p><h2 id="9b4e" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">结尾部分🤙</h2><blockquote class="ne nf ng"><p id="1fa0" class="jk jl nh jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated"><strong class="jm io">迭代器模式</strong>的学术定义:提供了一种在不暴露数据结构内部机制的情况下访问特定聚合内部元素的方法</p><p id="cf1e" class="jk jl nh jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated"><strong class="jm io">复合模式</strong>的学术定义:允许您以树形结构的形式组合对象，以表示部分-整体层次结构。在大多数情况下，复合材料叶片可以统一处理</p></blockquote><p id="327d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想，一次消化两种模式是很难的🤯这就是为什么你需要读多少遍就读多少遍&amp;如果你想让我帮助 you✌️，就不要发表评论</p><p id="f8ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="0371" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="6001" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="3174" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:【https://leetcode.com/SleeplessChallenger/】T21</li><li id="c0fe" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>