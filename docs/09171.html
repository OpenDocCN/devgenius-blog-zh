<html>
<head>
<title>How Algorithms Time Complexity Works(and why it’s useful)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法时间复杂度如何工作(以及它为什么有用)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/time-complexity-for-algorithms-simply-explained-part-1-2-ca41f2ebf21a?source=collection_archive---------11-----------------------#2022-08-03">https://blog.devgenius.io/time-complexity-for-algorithms-simply-explained-part-1-2-ca41f2ebf21a?source=collection_archive---------11-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/43e0ef24bc205b171f374eb016084396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7RJoSt2RqzBjShOaCKvTQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">沙哈达特·拉赫曼在<a class="ae jz" href="https://unsplash.com/s/photos/function?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f6b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在软件工程行业中，经常看到对例程和算法交付结果所需时间的担忧。</p><p id="ebb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下，你正试图找出去你所在城市的一家餐馆的路。很可能，你会使用谷歌地图之类的应用。给定起点和目的地，应用程序将尝试找到到达目的地的最佳路线。在幕后，它会运行一个算法，以便找到你可以采取的最短路径。</p><p id="0d6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要考虑这个算法要运行多长时间才能给出答案。</p><p id="e7c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果超过几秒钟，就用户体验而言，它做得不好。</p><p id="82f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">时间复杂性的目的是给我们一些工具来评估一个算法在速度方面做得有多好。以下是我们将涉及的主题的摘要:</p><ol class=""><li id="c7dc" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">什么是算法时间复杂度？</li><li id="4a0d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">大 O 符号。</li><li id="90dd" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">我们如何衡量它？</li><li id="bd42" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">最佳情况、最差情况和一般情况</li></ol></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="6503" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">算法时间复杂度的定义</strong></p><p id="2302" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单地说，算法的时间复杂度是运行时间和输入大小之间的关系。它也可以考虑其他参数。但是通常它只与输入的大小有关。</p><p id="8d8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个未排序的数字数组，我们想计算数字 47 在数组中出现了多少次:</p><p id="14d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:[1，4，2，10，40，25，47，11]</p><p id="f3f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">已知数组是未排序的，为了得到数字 47 出现的次数，必须遍历整个数组。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="43a7" class="mc md in ly b gy me mf l mg mh">inputArray = [1, 4, 2, 10, 40, 25, 47, 11]<br/>count = 0</span><span id="ec3b" class="mc md in ly b gy mi mf l mg mh">## Loop checking each element of the array<br/>for element in inputArray<br/>  <br/>  ## Is element equal to 47?  <br/>  if element == 47<br/>    <br/>    ## If that is the case<br/>    ## Update the count value<br/>    count = count + 1<br/></span></pre><p id="02e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果将是<strong class="kc io"> count = 1 </strong>最后，我们必须遍历数组中的所有元素以获得正确的计数。</p><p id="2feb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有理由假设这段代码运行的计算机时间与其输入的大小成正比(我们将称之为<strong class="kc io"> n </strong>)。因此可以把它写成<strong class="kc io"> n. </strong>的函数</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0a67" class="mc md in ly b gy me mf l mg mh">Computer Time = f(n)</span></pre><p id="f3e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们在每次迭代中唯一要做的事情就是检查一个值是否等于 47。如果我们输入一个两倍大的数组，那么遍历整个数组需要两倍的时间。</p><p id="d0b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2。大 O 符号</strong></p><p id="59ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，时间复杂度用 big-O 符号表示。在计算机科学中，根据算法的运行时间和输入大小(以及其他相关参数)之间的相关性对算法进行分类是一种惯例。</p><p id="0501" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几个例子:</p><ul class=""><li id="eff9" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mj le lf lg bi translated">O(n):算法运行时间的增长与输入大小成正比，正如我们在计算一个数字在数组中出现的次数的例子中所看到的。</li><li id="c602" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">O(n):算法运行时间的增长与输入大小的平方成正比。</li><li id="5d73" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">O(log n):运行时增长率与 n 的对数(通常以 2 为底)成正比，与 O(n)和 O(n)相比，它的增长速度要慢得多。</li></ul><p id="7dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下图显示了这些增长率在比较您可能会发现的一些常见时间复杂性时的差异:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/4688b0415b5c7dd7690027b1d44660b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nlWQNamld9-gjcjA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">增长率对比，图片来自维基百科:<a class="ae jz" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Big_O_notation</a></figcaption></figure><p id="46a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常我们感兴趣的是找到一种以尽可能低的增长率运行的算法版本:对数或平方根被认为是最好的。</p><p id="0992" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个与 n 成正比甚至与 n 成正比的增长率并不理想，但在某些情况下是可以接受的。</p><p id="8abd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，指数或阶乘增长的 rates(2^n 和<strong class="kc io"> n！</strong>)在性能方面简直是噩梦。</p><p id="c08b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">只有主导术语才重要</strong></p><p id="41f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们正在运行一个具有以下复杂性表达式的算法:</p><p id="715e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml"> f(n) </em> = <em class="ml"> 8n + 2n </em></p><p id="d642" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">意味着它的运行时间与上面的函数成正比。</p><p id="9140" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着<em class="ml"> n </em>变得非常大，在<em class="ml"> f(n) </em>表达式中<em class="ml"> 2n </em>的影响变小。换句话说，<em class="ml"> n </em>是<em class="ml"> f(n)的主导项。</em></p><p id="22ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，我们不需要把这个算法的复杂度写成:</p><p id="d9b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">O( <em class="ml"> 8n + 2n </em></p><p id="5dcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仅仅表示为 O( <em class="ml"> n </em>)就足够了，注意我们甚至没有包括常数乘以<em class="ml"> n . </em></p><p id="008f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个推理可以应用到任何其他复杂度类型:<em class="ml"> log n </em>，<em class="ml"> n </em>等等。它简化了表达复杂性的方式，我们只需要关心与其他项相比增长最快的项。</p><p id="7d64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是 big-O 符号如此有趣的原因，它允许我们将最终在运行时间和输入大小之间具有相同依赖性的算法组合在一起。</p><p id="c82f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们如何衡量它？</p><p id="760c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们理解了时间复杂性的含义以及如何表达它，我们需要问自己:我们如何测量或估计它？</p><p id="1df2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，没有固定的数学公式可以找到它，它是通过计算算法执行的运算次数来估计的。</p><p id="c65e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到最初的例子:要计算数组中数字的出现次数，涉及的操作有:</p><ul class=""><li id="fdde" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mj le lf lg bi translated">遍历数组</li><li id="3d84" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">检查一个元素是否等于 47(或任何其他数字)</li><li id="94af" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">递增计数器</li></ul><p id="11a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以认为等式检查总是要花费相同的时间(我们称之为单一操作)。此外，我们正在重复这个操作<strong class="kc io"> n </strong>次。</p><p id="c2c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们假设，在运行我们的出现计数算法时，我们还想计数我们得到小于 10 的数的次数。</p><p id="8086" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新算法看起来会像这样:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="aa85" class="mc md in ly b gy me mf l mg mh">inputArray = [1, 4, 2, 10, 40, 25, 47, 11]<br/>count = 0<br/>countLessThan10 = 0</span><span id="34fb" class="mc md in ly b gy mi mf l mg mh">## Loop checking each element of the array<br/>for element in inputArray<br/>  <br/>  ## Is element equal to 47?  <br/>  if element == 47<br/>    <br/>    ## If that is the case<br/>    ## Update the count value<br/>    count = count + 1<br/>  <br/>  if 10 &gt; element<br/>  <br/>    countLessThan10 = countLessThan10 + 1</span></pre><p id="2555" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正在运行的操作有:</p><ol class=""><li id="ff61" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">遍历数组</li><li id="05d8" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">检查元素是否等于 47(或任何其他数字)。<br/>如果是这种情况，增加计数器</li><li id="4675" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">检查元素是否小于 10(或任何其他数字)。<br/>如果是这种情况，增加计数器</li></ol><p id="0413" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">条件检查将在每次迭代中发生，因此，如果计数器频繁递增<strong class="kc io">，时间复杂度将是类似于<strong class="kc io"> 2n </strong>或<strong class="kc io"> 3n </strong>的东西。</strong></p><p id="a019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于优势原理，我们可以把乘法常数放在一边。时间复杂度仍然可以表示为<strong class="kc io"> O(n)。</strong></p><p id="4bb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">最佳情况、最差情况和一般情况</strong></p><p id="b168" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">区分算法可以运行和落入一些不同的情况是很重要的。让我们用另一个算法例子来理解这一点:</p><p id="8e3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们只想检查一个数字数组中是否有某个值:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5ca2" class="mc md in ly b gy me mf l mg mh">function checkArrayHasValue(searchedNum, array)<br/>  <br/>  for element in array<br/>    ## Equality check<br/>    if element == searchedNum<br/>     ## Return true if the element has been found      <br/>     return true<br/>  <br/>  ## Return false if the searched number<br/>  ## Was not found<br/>  return false</span><span id="02b4" class="mc md in ly b gy mi mf l mg mh">## Worst case example</span><span id="a0c1" class="mc md in ly b gy mi mf l mg mh">## Check if the array [1, 2, 3, 4] has the number 10 in it<br/>checkArrayHasValue(10, [1, 2, 3, 4])</span><span id="2dfc" class="mc md in ly b gy mi mf l mg mh">## Best case example<br/>checkArrayHasValue(10, [10, 2, 3, 4])</span><span id="8a11" class="mc md in ly b gy mi mf l mg mh">## Average case<br/>checkArrayHasValue(10, [1, 2, 10, 3, 4])</span></pre><p id="ce10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在最坏的情况下，我们必须遍历整个数组。<strong class="kc io"> (O(n)) </strong></p><p id="6972" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在最好的情况下，我们能够马上确定答案，因为数字 10 在数组的开始。<strong class="kc io"> (O(1)) </strong></p><p id="4f43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般情况下会介于这两者之间。<br/> <strong class="kc io"> (O(n/2)(大致)= &gt; O(n)) </strong></p><p id="f6ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">我们应该用哪一个？</strong></p><p id="a814" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更有趣的是，我们的算法有一个执行上限。它告诉我们运行一个算法的最大计算机时间。</p><p id="55f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，通常将时间复杂度表示为陷入最坏情况。除了最坏的情况极不可能发生，而一般情况在大多数时候能更好地预测会发生什么的情况。然后，我们可以采用平均用例来表示时间复杂度。</p><p id="3b91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">实际例子:二分搜索法</strong></p><p id="6175" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二分搜索法算法广泛用于在<strong class="kc io">排序的</strong>值列表中查找元素。它是这样工作的:</p><p id="c050" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输入:一个大小为<strong class="kc io"> n </strong>的数组和一个我们想要查找的值(<strong class="kc io"> val </strong>)</p><ol class=""><li id="ed4e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">我们首先将数组分成两半，检查中间的元素是否等于<strong class="kc io"> val </strong>。如果不是这样，我们转到以下步骤。</li><li id="a052" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果中间的元素大于<strong class="kc io"> val，</strong>我们丢弃数组的后半部分。如果中间的元素小于<strong class="kc io"> val </strong>，我们丢弃数组的前半部分。</li><li id="a438" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">对于数组的剩余部分，我们重复这个过程，直到找到所需的元素。</li></ol><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/2120f71fab9d69882d180b43fff12133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeH5gw4oD9uhtPWYVx3jdQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">二分搜索法的例子。作者图片</figcaption></figure><p id="efa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最好的情况:最好的情况是当我们在第一次试验中发现期望值正好在数组的中间，O(1)</p><p id="d8fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况:下面的图片将帮助我们想象最坏情况的复杂性</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/43243b72b786e614686672b375021a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uxoqcvaHlLp-AMGw8ATFw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">二分搜索法图。作者图片</figcaption></figure><p id="c2fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花了三次迭代才找到期望值。换句话说，我们必须将数组划分两次，才能找到搜索到的值。由于数组的原始大小为 8，我们最多只能将数组划分三次:</p><p id="065d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是<em class="ml"> 8 = 2 </em></p><p id="aebf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上图来看，更准确地说，最糟糕的情况是搜索<strong class="kc io"> val = 10 </strong>。最坏的情况与阵列可以被分成两半的次数成正比。</p><p id="8c84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4 号的 2 倍，</p><p id="d5ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8 码的 3 倍，</p><p id="3a42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">16 码的 4 倍，以此类推。</p><p id="2e69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对应的是对数增长。我们可以得出结论，最坏情况的复杂度是 O(log n)</p><p id="4e23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均情况也将与 log n 成正比。</p><p id="e62d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们观察到，在二分搜索法:</p><ul class=""><li id="e911" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mj le lf lg bi translated">最佳情况:O(1)</li><li id="eb05" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">最坏情况:O(log n)</li><li id="c777" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">平均情况:O(对数 n)</li></ul><p id="82b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="b668" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们探讨了时间复杂性的含义。以下是一些关键要点:</p><ul class=""><li id="55de" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mj le lf lg bi translated">时间复杂性是一种表达算法运行时间与其输入大小和其他相关参数之间的相关性的方式。</li><li id="6f56" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">它作为一种效率的衡量标准，允许我们比较不同算法的性能。</li><li id="9c52" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">这种度量通常用 big-O 符号表示。通常我们只考虑它的主导项。</li><li id="08f6" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mj le lf lg bi translated">我们可以通过计算执行的操作数来估计时间复杂度。</li></ul><p id="7af8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你坚持到最后！如果这些见解有所帮助，请考虑关注我的<a class="ae jz" href="https://medium.com/@leonardo5621_66451" rel="noopener"> Medium </a>以获取更多像这样的故事！</p></div></div>    
</body>
</html>