<html>
<head>
<title>5 Things You Must Know About Serialization and Deserialization in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 Java 中的序列化和反序列化，你必须知道的 5 件事</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-things-you-must-know-about-serialization-and-deserialization-in-java-b7fbb580b472?source=collection_archive---------4-----------------------#2022-11-27">https://blog.devgenius.io/5-things-you-must-know-about-serialization-and-deserialization-in-java-b7fbb580b472?source=collection_archive---------4-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="10c8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="3ef5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Java 序列化和反序列化软件工程师必须知道</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9a70cf77ab25b30011511d96d6ec5904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k-atH-yHdCwyvicN"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自 unsplash.com<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">的</a>图片</figcaption></figure><h1 id="6bdf" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">概观</h1><p id="1f04" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Java 中的序列化有助于将现有对象转换成字节流。相反，反序列化使序列化字节流成为对象。通过使用 Java 中的序列化和反序列化，对象的信息可以从一个 JVM 传输到另一个 JVM。让我们转到文章的细节来理解序列化和反序列化是如何工作的。</p><h1 id="e81e" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#1 序列化</h1><p id="71dc" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在开始详述本文之前，我想提供一个 SerializeUtils.java 和 Person.java 类，它们将帮助我们处理本文中所有示例的序列化和反序列化。</p><p id="baea" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">【SerializeUtils.java T4】</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="90b3" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.*;<br/><br/>public class SerializeUtils {<br/>    public static &lt;T&gt; void serialize(T input, String fileName) throws IOException {<br/>        FileOutputStream file = new FileOutputStream(fileName);<br/>        ObjectOutputStream out = new ObjectOutputStream(file);<br/>        out.writeObject(input);<br/>        out.close();<br/>        file.close();<br/>    }<br/><br/>    public static &lt;T&gt; T deserialize(String fileName) throws IOException, ClassNotFoundException {<br/>        FileInputStream file = new FileInputStream(fileName);<br/>        ObjectInputStream in = new ObjectInputStream(file);<br/>        T result = (T) in.readObject();<br/><br/>        return result;<br/>    }<br/><br/>    public static void externalSeialize(Externalizable e, String fileName) throws IOException {<br/>        FileOutputStream file = new FileOutputStream(fileName);<br/>        ObjectOutputStream out = new ObjectOutputStream(file);<br/>        e.writeExternal(out);<br/>        out.close();<br/>        file.close();<br/>    }<br/><br/>    public static void externalDeseialize(Externalizable e, String fileName) throws IOException, ClassNotFoundException {<br/>        FileInputStream file = new FileInputStream (fileName);<br/>        ObjectInputStream in = new ObjectInputStream (file);<br/>        e.readExternal(in);<br/>        in.close();<br/>        file.close();<br/>    }<br/>}</span></pre><p id="17da" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Person.java</strong></p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="7259" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.Serializable;<br/><br/>public class Person implements Serializable {<br/>    private static final long serialVersionUID = 1L;<br/><br/>    private int id;<br/>    private String name;<br/>    private int age;<br/><br/>    public int getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public int getAge() {<br/>        return age;<br/>    }<br/><br/>    public void setAge(int age) {<br/>        this.age = age;<br/>    }<br/>}</span></pre><p id="369f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如概述中提到的，更改对象的序列化变成了字节流。这意味着对象的所有信息都被转换成字节流，比如方法、属性和数据。让我们来看看如何序列化一个对象的例子:</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="a5ae" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.IOException;<br/><br/>public class SerializationMain {<br/><br/>    public static void main(String[] args) throws IOException {<br/>        Person p = new Person();<br/>        p.setId(1);<br/>        p.setName("Tech team members");<br/>        p.setAge(20);<br/><br/>        SerializeUtils.serialize(p, "/person.txt");<br/>    }<br/>}</span></pre><p id="3e18" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在序列化过程之后，我们有一个内容如下的文件:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/ee75eea8eac26a527a5d00625a33def4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pv5GXPOc4VfnaEKl"/></div></div></figure><h1 id="3d83" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#2 反序列化</h1><p id="ad89" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在序列化部分，我们通过序列化一个对象创建了一个字节流。根据流数据给出的信息，让我们看看如何通过下面的例子返回到带有反序列化的对象:</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="9715" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.IOException;<br/><br/>public class DeserializationMain {<br/>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br/>        Person p = SerializeUtils.deserialize("/person.txt");<br/><br/>        System.out.println("Person data:");<br/>        System.out.println(p.getId());<br/>        System.out.println(p.getName());<br/>        System.out.println(p.getAge());<br/>    }<br/>}</span></pre><p id="8688" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">以下是反序列化过程后的数据:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2a5b40bbc0006fcb5a6153a29a36c4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*-7JU-91sgdpPuS0Z"/></div></figure><h1 id="3db1" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#3 系列版本 UID</h1><p id="11f1" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">serialVersionUID 表示序列化和反序列化过程的每个版本的唯一标识号。这个数字用于确保序列化和反序列化的对象都使用兼容的类。对于 person.txt，我想将 serialVersionUID 增加到 2，现在让我们看看反序列化 person.txt 文件时的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/d7516bcee304f61d0dc977841492b672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-h6i16CV95UUkm8"/></div></div></figure><h1 id="7361" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#4 瞬态关键字</h1><p id="1600" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">对于序列化和反序列化过程，有时我们不需要序列化一个对象的所有信息。通过对变量使用 transient，它将忽略可序列化对象之外的那些变量。下面的例子将帮助你更清楚地了解它:</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="7d09" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.IOException;<br/>import java.io.Serializable;<br/><br/>public class PersonWithTransient implements Serializable {<br/><br/>    private static final long serialVersionUID = 1L;<br/><br/>    private int id;<br/>    private String name;<br/>    private transient int age;<br/><br/>    public int getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public int getAge() {<br/>        return age;<br/>    }<br/><br/>    public void setAge(int age) {<br/>        this.age = age;<br/>    }<br/><br/>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br/>        PersonWithTransient p = new PersonWithTransient();<br/>        p.setId(2);<br/>        p.setName("Tech team members(transient)");<br/>        p.setAge(50);<br/><br/>        SerializeUtils.serialize(p, "/person_transient.txt");<br/><br/>        PersonWithTransient deserializeP = SerializeUtils.deserialize("/person_transient.txt");<br/>        System.out.println("Person without transient data:");<br/>        System.out.println(deserializeP.getId());<br/>        System.out.println(deserializeP.getName());<br/>        System.out.println(deserializeP.getAge());<br/>    }<br/>}</span></pre><p id="248a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在上面的代码中，我们为 age 变量使用了 transient 键，现在让我们看看序列化和反序列化过程后的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ef543a410a2cdfd4bb5110df734be2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*0Gc4mHLxROM5TF4Q"/></div></figure><h1 id="a963" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#5 外部化接口</h1><p id="a69f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在 Java 中，当我们想要定制一个序列化和反序列化过程时，我们可以使用 transient 来忽略那些我们不希望在序列化和反序列化过程中使用的变量。另一种使它更容易并获得更高性能的方法是使用可外部化接口，而不是直接使用可序列化接口。为了证明这一点，让我们看看下面的例子:</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="93e0" class="nd lg iq mz b be ne nf l ng nh">package com.techteam.serialization;<br/><br/>import java.io.Externalizable;<br/>import java.io.IOException;<br/>import java.io.ObjectInput;<br/>import java.io.ObjectOutput;<br/><br/>public class PersonExternalizable implements Externalizable {<br/>    private static final long serialVersionUID = 1L;<br/>    private int id;<br/>    private String name;<br/>    private int age;<br/><br/>    public int getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public int getAge() {<br/>        return age;<br/>    }<br/><br/>    public void setAge(int age) {<br/>        this.age = age;<br/>    }<br/><br/>    @Override<br/>    public void writeExternal(ObjectOutput out) throws IOException {<br/>        out.writeUTF(this.name);<br/>        out.writeInt(this.age);<br/>    }<br/><br/>    @Override<br/>    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {<br/>        this.name = in.readUTF();<br/>        this.age = in.readInt();<br/>    }<br/><br/>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br/>        PersonExternalizable p = new PersonExternalizable();<br/>        p.setId(3);<br/>        p.setName("Tech team members(Externalizable)");<br/>        p.setAge(30);<br/><br/>        SerializeUtils.externalSeialize(p, "/person_externalizable.txt");<br/><br/>        PersonExternalizable deserializeP = new PersonExternalizable();<br/>        SerializeUtils.externalDeseialize(deserializeP, "/person_externalizable.txt");<br/>        System.out.println("Person data:");<br/>        System.out.println(deserializeP.getId());<br/>        System.out.println(deserializeP.getName());<br/>        System.out.println(deserializeP.getAge());<br/>    }<br/>}</span></pre><p id="e4af" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如你所看到的，使用 Externalizable，我们可以很容易地编写自定义逻辑，忽略变量，并获得比直接使用 Serializable 更高的性能。现在，让我们用上面的代码来看看我们的流程的输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/66e0bc49804418922b041ab6fb895f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/0*lP__kbEZ646jtQF1"/></div></figure><h1 id="d97e" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="a6a4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">通过这篇文章，我想你可以了解序列化和反序列化在 Java 中是如何工作的。有了上面的那些例子，它也可能对你的实践经验有所帮助。这就是我想与您分享的关于序列化和反序列化的全部内容。希望内容对你有帮助。谢谢大家！</p></div></div>    
</body>
</html>