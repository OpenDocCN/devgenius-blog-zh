<html>
<head>
<title>Robust media upload with Golang and Cloudinary — Fiber Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Golang 和 Cloudinary 实现强大的媒体上传—光纤版本</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/robust-media-upload-with-golang-and-cloudinary-fiber-version-a08e28af0053?source=collection_archive---------13-----------------------#2022-02-08">https://blog.devgenius.io/robust-media-upload-with-golang-and-cloudinary-fiber-version-a08e28af0053?source=collection_archive---------13-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5bfccbd2c1673824035a23cdb7b7a740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JblqV7QeQbivBXHSO-ZGMw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">封面照片</figcaption></figure><p id="a5ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">近年来，移动和 web 应用程序支持文件上传的需求大幅增长，从图像和视频到 excel、CSV 和 PDF 等文档。最重要的是，我们必须具备将文件上传支持集成到我们的应用程序中所需的知识。</p><p id="c55f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章将讨论使用<a class="ae kx" href="https://github.com/gofiber/fiber" rel="noopener ugc nofollow" target="_blank"> Fiber </a>框架和<a class="ae kx" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>为 REST API 添加媒体上传支持。在本教程的最后，我们将学习如何构建一个 Fiber 应用程序，如何将 Cloudinary 与 Golang 集成，以及如何使用远程 URL 和本地文件存储将媒体文件上传到 Cloudinary。</p><p id="629d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Fiber 是一个受 Express 启发的 HTTP web 框架，用 Golang 编写，支持高性能和零内存分配。Fiber 构建在用 Golang 编写的 http 引擎<a class="ae kx" href="https://github.com/valyala/fasthttp" rel="noopener ugc nofollow" target="_blank"> Fasthttp </a>之上。</p><p id="7a01" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Cloudinary 提供了一个强大的视觉媒体平台，用于为网站和应用程序上传、存储、管理、转换和交付图像和视频。该平台还为框架和库提供了大量的软件开发工具包(SDK)。</p><p id="9289" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以在这个<a class="ae kx" href="https://github.com/Mr-Malomz/fiber-cloudinary-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到完整的源代码。</p><h1 id="1512" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="3a80" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这篇文章中的以下步骤需要 Golang 的经验。使用 Cloudinary 的经验不是必需的，但是拥有它是很好的。</p><p id="2baa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要以下物品:</p><ul class=""><li id="7347" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">存储媒体文件的<a class="ae kx" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank">云二进制账户</a>。<a class="ae kx" href="https://cloudinary.com/users/register/free" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">报名</strong> </a> <strong class="kb io">完全免费</strong>。</li><li id="d9fe" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">邮递员或任何你选择的 API 测试应用程序。</li></ul><h1 id="eda2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们编码</h1><h2 id="04b8" class="mp kz in bd la mq mr dn le ms mt dp li kk mu mv lm ko mw mx lq ks my mz lu na bi translated">入门指南</h2><p id="135d" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行以下命令:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="73c6" class="mp kz in ng b gy nk nl l nm nn">mkdir fiber-cloudinary-api &amp;&amp; cd fiber-cloudinary-api</span></pre><p id="4e3c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令创建一个<code class="fe no np nq ng b">fiber-cloudinary-api</code>文件夹，并导航到项目目录。</p><p id="1ae7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要通过运行以下命令来初始化 Go 模块以管理项目依赖关系:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c2c5" class="mp kz in ng b gy nk nl l nm nn">go mod init fiber-cloudinary-api</span></pre><p id="6cd2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令将创建一个<code class="fe no np nq ng b">go.mod</code>文件，用于跟踪项目依赖关系。</p><p id="cd00" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们继续安装所需的依赖项:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ece9" class="mp kz in ng b gy nk nl l nm nn">go get -u github.com/gofiber/fiber/v2 github.com/cloudinary/cloudinary-go github.com/joho/godotenv github.com/go-playground/validator/v10</span></pre><p id="94ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/gofiber/fiber/v2 </code>是一个构建 web 应用程序的框架。</p><p id="8a69" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/cloudinary/cloudinary-go</code>是集成 Cloudinary 的库。</p><p id="418d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/joho/godotenv</code>是一个管理环境变量的库。</p><p id="351b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/go-playground/validator/v10</code>是一个用于验证结构和字段的库。</p><h1 id="ef01" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">应用程序入口点</h1><p id="e5b4" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">安装好项目依赖项后，我们需要在根目录下创建<code class="fe no np nq ng b">main.go</code>文件，并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c54c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="7aea" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="0175" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">New</code>功能初始化光纤应用。</li><li id="541a" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">Get</code>函数路由到<code class="fe no np nq ng b">/</code>路径和一个返回<code class="fe no np nq ng b">Hello from Cloudinary</code>的 JSON 的处理函数。<code class="fe no np nq ng b">fiber.Map</code>是<code class="fe no np nq ng b">map[string]interface{}</code>的快捷方式，对 JSON 返回有用。</li><li id="fafe" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">设置应用程序监听端口<code class="fe no np nq ng b">6000</code>。</li></ul><p id="dc30" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们可以通过在终端中运行下面的命令来启动开发服务器，从而测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e036" class="mp kz in ng b gy nk nl l nm nn">go run main.go</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/9567a1ebe8a8c96ccdc239368ecfdf84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rs2GDPb7opcr3LUe.png"/></div></div></figure><h1 id="fa74" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Golang 的模块化</h1><p id="ceb0" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">对于我们的项目来说，有一个好的文件夹结构是很重要的。良好的项目结构简化了我们在应用程序中处理依赖关系的方式，并使我们和其他人更容易阅读我们的代码库。</p><p id="bb8b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们需要在我们的项目目录中创建<code class="fe no np nq ng b">configs</code>、<code class="fe no np nq ng b">services</code>、<code class="fe no np nq ng b">controllers</code>、<code class="fe no np nq ng b">helper</code>、<code class="fe no np nq ng b">models</code>和<code class="fe no np nq ng b">dtos</code>文件夹。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2ad2848bd7e3c1f538d3da221ee174e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*IXC2Ydv0AtssxklR.png"/></div></figure><p id="6e6c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">PS</strong>:<em class="nv"/><code class="fe no np nq ng b"><em class="nv">go.sum</em></code><em class="nv">文件包含所有依赖校验和，由 go 工具管理。我们不必为此担心。</em></p><p id="33ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">configs</code>用于模块化项目配置文件</p><p id="715e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">services</code>用于模块化应用逻辑。它有助于保持控制器的清洁。</p><p id="d206" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">controllers</code>用于模块化应用程序传入的请求和返回的响应。</p><p id="82e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">helper</code>用于模块化用于执行另一个文件的计算的文件。</p><p id="cada" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">models</code>用于模块化数据和数据库逻辑。</p><p id="8f98" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">dtos</code>用于模块化文件，描述我们希望 API 给出的响应。这一点以后会变得更加清楚。<br/> <a class="ae kx" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> <em class="nv">数据传输对象(DTO) </em> </a> <em class="nv">简单来说就是将数据从一点传输到另一点的对象。</em></p><h1 id="0566" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置云阵列</h1><p id="125d" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">完成后，我们需要登录或注册我们的<a class="ae kx" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>账户，以获取我们的<strong class="kb io">云名称</strong>、<strong class="kb io"> API 密钥</strong>和<strong class="kb io"> API 秘密</strong>。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/1ba3f3253a570a378619ee38d4f1c814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CJCoVjeklHxcRtFC.png"/></div></div></figure><p id="3c49" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要创建一个文件夹来存储我们的媒体上传。为此，导航到<strong class="kb io">媒体库</strong>选项卡，点击<strong class="kb io">添加文件夹</strong>图标，输入<code class="fe no np nq ng b">go-cloudinary</code>作为文件夹名称，然后<strong class="kb io">保存</strong>。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/01f32217a3fe6db73e96c5f4b42b401b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Grat-Q6SZ_uagwDV.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/0e89e1ac8d82fc3fed7986fe0ae43554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p60ycRMOjkKM019-.png"/></div></div></figure><p id="db1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">设置环境变量<br/> </strong>接下来，我们需要将仪表板中的参数包含到环境变量中。为此，首先，我们需要在根目录下创建一个<code class="fe no np nq ng b">.env</code>文件，并在这个文件中添加下面的代码片段:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="98f9" class="mp kz in ng b gy nk nl l nm nn">CLOUDINARY_CLOUD_NAME=&lt;YOUR CLOUD NAME HERE&gt;</span><span id="08c4" class="mp kz in ng b gy nx nl l nm nn">CLOUDINARY_API_KEY=&lt;YOUR API KEY HERE&gt;</span><span id="ae76" class="mp kz in ng b gy nx nl l nm nn">CLOUDINARY_API_SECRET=&lt;YOUR API SECRET HERE&gt;</span><span id="041d" class="mp kz in ng b gy nx nl l nm nn">CLOUDINARY_UPLOAD_FOLDER=go-cloudinary</span></pre><p id="140b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">加载环境变量<br/> </strong>完成后，我们需要使用我们之前安装的<code class="fe no np nq ng b">github.com/joho/godotenv</code>库创建助手函数来加载环境变量。为此，我们需要导航到<code class="fe no np nq ng b">configs</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">env.go</code>文件，并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f4fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="b7c7" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="1304" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">EnvCloudName</code>、<code class="fe no np nq ng b">EnvCloudAPIKey</code>、<code class="fe no np nq ng b">EnvCloudAPISecret</code>、<code class="fe no np nq ng b">EnvCloudUploadFolder</code>函数，检查环境变量是否正确加载并返回环境变量。</li></ul><p id="bfd6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> Cloudinary helper 函数<br/> </strong>为了方便从我们的应用程序进行远程和本地上传，我们需要导航到<code class="fe no np nq ng b">helper</code>文件夹，并在该文件夹中创建一个<code class="fe no np nq ng b">media_helper.go</code>文件并添加以下代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8fce" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="0a2e" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="e8e7" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">ImageUploadHelper</code>函数，它首先将一个<code class="fe no np nq ng b">interface</code>作为参数，并返回远程 URL 或错误(如果有的话)。<code class="fe no np nq ng b">interface</code>通过接受<strong class="kb io">远程 URL </strong>和<strong class="kb io">表单文件</strong>，使得我们的代码可以重用。该函数还执行以下操作:<br/> -定义了连接到 Cloudinary 时的 10 秒超时。<br/> -通过传入<strong class="kb io">云名称</strong>、<strong class="kb io"> API 密钥</strong>和<strong class="kb io"> API 秘密</strong>作为参数，并检查是否有错误，初始化一个新的 Cloudinary 实例。<br/> -使用<code class="fe no np nq ng b">Upload</code>功能上传媒体，并使用<code class="fe no np nq ng b">EnvCloudUploadFolder</code>功能指定存储媒体的文件夹。获取上传结果和错误(如果有)。<br/> -当没有错误时，返回媒体安全 URL 和<code class="fe no np nq ng b">nil</code>。</li></ul><h1 id="194c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置模型和响应类型</h1><p id="283d" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated"><strong class="kb io">模型<br/> </strong>接下来，我们需要一个模型来表示我们的应用数据。为此，我们需要导航到<code class="fe no np nq ng b">models</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">media_model.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d313" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="9154" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="081a" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个具有本地文件上传和远程 URL 上传所需属性的<code class="fe no np nq ng b">File</code>和<code class="fe no np nq ng b">Url</code>结构。</li></ul><p id="ca56" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">响应类型<br/> </strong>接下来，我们需要创建一个可重用的<code class="fe no np nq ng b">struct</code>来描述我们的 API 的响应。为此，导航到<code class="fe no np nq ng b">dtos</code>文件夹，在该文件夹中，创建一个<code class="fe no np nq ng b">media_dto.go</code>文件并添加以下代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d7f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段创建了一个具有<code class="fe no np nq ng b">StatusCode</code>、<code class="fe no np nq ng b">Message</code>和<code class="fe no np nq ng b">Data</code>属性的<code class="fe no np nq ng b">MediaDto</code>结构来表示 API 响应类型。</p><h1 id="660c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后，创建 REST API</h1><p id="ece0" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">完成后，我们需要创建一个<strong class="kb io">服务</strong>来托管所有的媒体上传应用逻辑。为此，导航到<code class="fe no np nq ng b">services</code>文件夹，在该文件夹中，创建一个<code class="fe no np nq ng b">media_service.go</code>文件并添加以下代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9051" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="5f14" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="e031" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用我们之前安装的<code class="fe no np nq ng b">github.com/go-playground/validator/v10</code>库创建一个<code class="fe no np nq ng b">validate</code>变量来验证模型。</li><li id="f8b6" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">mediaUpload</code>接口，用方法描述我们想要做的上传类型。</li><li id="3f8b" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个将实现<code class="fe no np nq ng b">mediaUpload</code>接口的<code class="fe no np nq ng b">media</code>结构。</li><li id="b296" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">NewMediaUpload</code>构造函数，将媒体结构和它实现的<code class="fe no np nq ng b">mediaUpload</code>接口联系起来。</li><li id="5b85" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">用<code class="fe no np nq ng b">media</code>指针接收器创建所需的方法<code class="fe no np nq ng b">FileUpload</code>和<code class="fe no np nq ng b">RemoteUpload</code>，如果有错误，返回 URL 或错误。所需的方法还验证来自用户的输入，并使用我们之前创建的<code class="fe no np nq ng b">ImageUploadHelper</code>函数将媒体上传到 Cloudinary。</li></ul><p id="80dc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">文件上传端点<br/> </strong>通过服务设置，我们现在可以创建一个从本地文件存储器上传媒体的功能。为此，我们需要导航到<code class="fe no np nq ng b">controllers</code>文件夹，在该文件夹中，创建一个<code class="fe no np nq ng b">media_controller.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bbf4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="67e3" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="08d7" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个返回<code class="fe no np nq ng b">error</code>的<code class="fe no np nq ng b">FileUpload</code>函数。在函数内部，我们首先使用<code class="fe no np nq ng b">FormFile</code>函数来检索包含<strong class="kb io"> </strong> <code class="fe no np nq ng b">formFile</code>对象的<strong class="kb io"> formHeader </strong>。其次，我们使用附加到<strong class="kb io">表单头</strong>的<code class="fe no np nq ng b">Open</code>方法来检索相关文件。我们使用之前为两个操作创建的<code class="fe no np nq ng b">MediaDto</code>结构返回了适当的消息和状态代码。第三，我们使用<code class="fe no np nq ng b">NewMediaUpload</code>构造函数通过传递<code class="fe no np nq ng b">formFile</code>作为参数来访问<code class="fe no np nq ng b">FileUpload</code>服务。该服务还返回上传媒体的 URL 或错误(如果有的话)。最后，如果媒体上传成功，我们将返回正确的响应。</li></ul><p id="3aa2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">远程 URL 上传端点<br/> </strong>要从远程 URL 上传图像，我们需要修改<code class="fe no np nq ng b">media_controller.go</code>如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3ea2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">RemoteUpload</code>函数的功能与<code class="fe no np nq ng b">FileUpload</code>函数相同。然而，我们创建了<code class="fe no np nq ng b">url</code>变量，并使用纤程的<code class="fe no np nq ng b">BodyParser</code>方法对其进行了验证。我们还将变量作为参数传递给<code class="fe no np nq ng b">RemoteUpload</code>服务，并返回适当的响应。</p><p id="1c8d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">完成媒体 _ 控制器. go </strong></p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="74a9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">将所有这些放在一起<br/> </strong>完成后，我们需要为我们的端点创建一个从本地文件存储和远程 URL 上传媒体的路由。为此，我们需要用控制器修改<code class="fe no np nq ng b">main.go</code>，并指定相对路径，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4df1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，我们可以通过在终端中运行下面的命令启动开发服务器来测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="eb32" class="mp kz in ng b gy nk nl l nm nn">go run main.go</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/3a933ce073cae8d1aeb6321c8b7bc488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SVxV9oGXnqiFAE-Q.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/c9e9971af3c5f9ae53fd99d415589717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kBbDawWf3y_HshGo.png"/></div></div></figure><p id="a08b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上传完成后，我们可以查看 Cloudinary 上的<code class="fe no np nq ng b">go-cloudinary</code>文件夹，查看上传的媒体文件。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/dd96512fac13e03535c3be1ed30c3cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*40kol5WEBrE4OKVm.png"/></div></div></figure><h1 id="799b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="0bbd" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这篇文章讨论了如何构建一个 Fiber 应用程序，如何将 Cloudinary 与 Golang 集成，以及如何使用远程 URL 和本地文件存储将媒体文件上传到 Cloudinary。</p><p id="12c8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可能会发现这些资源很有帮助:</p><ul class=""><li id="8440" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated"><a class="ae kx" href="https://github.com/gofiber/fiber" rel="noopener ugc nofollow" target="_blank">纤维框架</a></li><li id="cddf" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://cloudinary.com/documentation/go_integration" rel="noopener ugc nofollow" target="_blank"> Cloudinary Go SDK </a></li><li id="68c2" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://go.dev/tour/methods/4" rel="noopener ugc nofollow" target="_blank"> Go 指针接收器</a></li></ul></div></div>    
</body>
</html>