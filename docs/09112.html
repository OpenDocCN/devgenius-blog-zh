<html>
<head>
<title>Inheritance in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/inheritance-in-swift-390cd55e601c?source=collection_archive---------5-----------------------#2022-07-30">https://blog.devgenius.io/inheritance-in-swift-390cd55e601c?source=collection_archive---------5-----------------------#2022-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0e6e59379deb3556dd0dcdd51e308e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PRdzNzqNW0nkKb3JaoJAbQ.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">阿兰·范在<a class="ae jv" href="https://unsplash.com/s/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5866" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">继承允许您创建基于其他类的类。通过重用您已经编写的代码，您可以编写不同的实现，同时保持相同的行为。今天的文章将集中在如何创建一个基类和子类化它，覆盖属性和方法<strong class="jy io"> </strong>以及覆盖属性观察者。</p><p id="1701" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">本文是<a class="ae jv" href="https://swiftsimplified.medium.com/list/swift-basics-b2f15c120a96" rel="noopener"> <strong class="jy io"> Swift 基础知识</strong> </a>系列的一部分，帮助初学者以更加简单实用的方式理解 Swift 的基本概念。请随意查看关于其他基本 Swift 概念的文章。这些教程的全部内容可以在<a class="ae jv" href="https://github.com/harshvardhanarora/Swift_Basics" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们开始吧！</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="6db4" class="lb lc in bd ld le lf dn lg lh li dp lj kh lk ll lm kl ln lo lp kp lq lr ls lt bi translated">基础类</h2><p id="40e2" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">一个<em class="lz">基类</em>不继承任何东西。让我们看一个例子——</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/3317049ca23303fe2decc167d1b7b504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJfNLybiXGA663dhSt7kDg.png"/></div></div></figure><p id="2155" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">现在我们将尝试创建这个类的一个实例—</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/621dec405d101da56a0803dbe0b1757a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeplyOiGt1xW6hpDS4rWAw.png"/></div></div></figure><p id="9b68" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">注意，我们不需要为我们的类创建一个<strong class="jy io">初始化器</strong>方法，因为没有需要初始化的属性。</p><p id="e5bb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这个类不从任何类继承，但是其他类可以从它继承并覆盖我们这里的属性和方法。让我们看看如何！</p><h2 id="1442" class="lb lc in bd ld le lf dn lg lh li dp lj kh lk ll lm kl ln lo lp kp lq lr ls lt bi translated">亚纲</h2><p id="b980" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">一个<em class="lz">子类</em>是一个继承自<em class="lz">基类</em>的类，就像我们上面定义的那个。这基本上意味着我们在另一个类的基础上构建我们的新类，而不影响那个类本身。让我们看一个例子——</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mk"><img src="../Images/b878968e483940a9136c2465ac012728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_D_jwzlJMHiHyntsqdK7Ow.png"/></div></div></figure><p id="45d9" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这是声明我们的类<strong class="jy io">狗</strong>想要继承我们的类<strong class="jy io">宠物</strong>的语法。现在它所做的是让<strong class="jy io">宠物</strong>到<strong class="jy io">狗</strong>的所有公共属性可用。我们还在 Dog 类中创建了一个额外的属性，宠物不能访问。让我们看一个例子——</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/bcdc3a85d5ad4aba185dd4be83bd3647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlXCcJrisg8ROIHeGvDIwg.png"/></div></div></figure><p id="5ba2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如您所见，Dog 类型的实例可以访问属于 Cat 类的属性。你也可以子类化一个子类本身。现在让我们看看如何在子类中改变基类的属性！</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="d607" class="mm lc in bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">最重要的</h1><p id="1ba3" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">对于从基类继承的属性或方法，子类可以有自己的实现。我们称之为<strong class="jy io">超越</strong>。即使您选择重写方法、属性或下标，您仍然可以使用基类中的现有实现。让我们看看如何！</p><h2 id="0f63" class="lb lc in bd ld le lf dn lg lh li dp lj kh lk ll lm kl ln lo lp kp lq lr ls lt bi translated">重写方法</h2><p id="bb8a" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">让我们从<em class="lz">宠物</em> <strong class="jy io"> <em class="lz"> </em> </strong>类创建另一个子类，并尝试覆盖<em class="lz">speak()</em><strong class="jy io"><em class="lz"/></strong>方法。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/575208f9b767611ecffafe5d923fb5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x03_of9YbQbomlr75TebXg.png"/></div></div></figure><p id="386f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">注意<strong class="jy io"> override </strong>关键字，让 Swift 知道您正试图为超类中的方法编写一个自定义实现。让我们来看看它的实际应用—</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/35d7bd4178f00fbc02d6e88977feaa6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFinvPk2lkw2ry6NqMYmiw.png"/></div></div></figure><p id="938a" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">就这么简单！现在，尽管我们最初实现的方法<em class="lz">speak()</em><strong class="jy io"><em class="lz"/></strong>是空的，但是让我们看看如何调用它。我们使用<strong class="jy io"> super </strong>关键字来访问超类—</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/153cdea4729e97964a4e2b57b839dc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DjI2kNkCiPxd4dcDptYnw.png"/></div></div></figure><h2 id="97e1" class="lb lc in bd ld le lf dn lg lh li dp lj kh lk ll lm kl ln lo lp kp lq lr ls lt bi translated">覆盖属性</h2><p id="b81b" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">您不能重写存储属性以将其设置为新值。另一方面，您可以为继承的属性覆盖<strong class="jy io"> getter </strong>和<strong class="jy io"> setter </strong>方法。您还可以添加<strong class="jy io">属性观察者</strong>来响应底层属性的变化。</p><p id="158b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">覆盖 Getter 和 Setter </strong></p><p id="8027" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在我们看一个覆盖 getter 和 setter 方法的例子之前，您需要理解一个简单的规则。您可以为只读属性提供 getter-setter 重写，但不能只为读写属性提供 getter 重写。现在让我们跳到一个例子来理解它是如何工作的—</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/cc0433127b35dac44d9625d973b90aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ixOyiaeQ3lYgEiohRv8iw.png"/></div></div></figure><p id="53c7" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果你回去，你会记得我们班的<strong class="jy io">宠物</strong>有一个名为<strong class="jy io"> name </strong>的属性，它是一个<strong class="jy io"> var </strong>。让我们逐行看看上面的代码是什么意思— <br/> <strong class="jy io"> 63 — </strong>定义继承自<strong class="jy io"> Pet </strong>的子类<strong class="jy io"> NamedPet </strong>。<br/> <strong class="jy io"> 64 — </strong>创建一个可选属性<strong class="jy io">宠物名</strong>。<br/> <strong class="jy io"> 66 — </strong>在提供 getter 和 setter 方法<br/> <strong class="jy io"> 68 — </strong>返回<strong class="jy io"> petName </strong>如果不为空，否则使用关键字<strong class="jy io"> super </strong>从基类返回<strong class="jy io"> name </strong>属性。</p><p id="bb2d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">希望在我们看到这个类的例子之前，你能理解它是做什么的。另外，尝试移除第 69 行中的<strong class="jy io">名称</strong>属性的<strong class="jy io">设置器</strong>，您将收到一个错误，提示您不能用<strong class="jy io">只获取</strong>属性覆盖可变属性。希望你现在也能理解我们上面讨论的规则。让我们看一个这个类工作的例子—</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/6a2e966d366c0dd20fa2a7485f2d2809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FH3mzvZ7MZ5B4vYXxLRyaQ.png"/></div></div></figure><p id="89ca" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我们创建一个名为<strong class="jy io"> max </strong>的类<strong class="jy io">的对象。最初，它被设置为 Margo 的默认值，这就是我们在输出中看到的。但是在将属性<strong class="jy io">名称</strong>改为<strong class="jy io">最大值</strong>后，我们看到现在属性<strong class="jy io">宠物名称</strong>和<strong class="jy io">名称</strong>都被设置为<strong class="jy io">"最大值"</strong>。</strong></p><p id="41e0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">压倒一切的财产观察家</strong></p><p id="aec6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">就像覆盖属性 setter 和 getter 一样，在覆盖属性 observers 之前，您需要理解一些事情。不能将属性观察器添加到继承的属性中，这些属性是常量存储属性或只读计算属性。理性——观察无法改变的事物的变化毫无意义。</p><p id="3111" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在这一点上，你一定认为我们仍然可以<strong class="jy io">覆盖子类中的 setter 方法</strong>。你这样想是正确的，但是这里有另一条规则——你<strong class="jy io">不能</strong>为同一个属性提供一个<strong class="jy io">覆盖设置器</strong>和<strong class="jy io">覆盖属性观察者</strong>。您可以简单地处理 setter <strong class="jy io"> </strong>方法本身内部的观察。现在，让我们来看一个例子</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/4ba2ea4408f97ef726c6b848f9965530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxeiTVl_ukDsUQvbM0m_Qw.png"/></div></div></figure><p id="baf5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在这个例子中，我们覆盖 name 属性来添加一个<strong class="jy io"> didSet </strong>属性观察者。每当名称改变时，就会执行 didSet 中的闭包。让我们看一个例子——</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/eaa43566eb242d9219acdde1486891b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlM6Lk4iJhIgy-IFsq2wJQ.png"/></div></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="13c5" class="lb lc in bd ld le lf dn lg lh li dp lj kh lk ll lm kl ln lo lp kp lq lr ls lt bi translated">防止覆盖</h2><p id="9668" class="pw-post-body-paragraph jw jx in jy b jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt ig bi translated">您可以通过在任何属性、方法或下标之前使用关键字<strong class="jy io"> final </strong>来防止覆盖它们。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/fbd3925814381e64f6880c4f8022ae36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImJYQxiUsYlfGI1Ex_gVJA.png"/></div></div></figure><p id="e07e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果您试图在子类中覆盖这个属性，您将会收到一个错误。</p><p id="861d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">你也可以在一个类前使用<strong class="jy io"> final </strong>，这样就不允许任何其他类继承你的类。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="2ee5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">就是这样！这是一个很大的范围。给自己时间吸收全部，尝试自己写出代码，看看<a class="ae jv" href="https://github.com/harshvardhanarora/Swift_Basics" rel="noopener ugc nofollow" target="_blank">操场</a>本身，以防卡住。如果你有任何问题，请随时在 LinkedIn 上联系我。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="51cd" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">为你创作这些文章，占用了我大量的精力和资源。你可以通过<a class="ae jv" href="https://www.buymeacoffee.com/swiftsimplified" rel="noopener ugc nofollow" target="_blank"> <strong class="jy io">给我买一杯咖啡</strong> </a>来支持我的旅程。如果目前你还不能贡献金钱，如果你能把这篇文章分享给你的网络，那就太好了！希望能继续给大家带来这样的内容，帮助你的 iOS 开发之旅。</p></div></div>    
</body>
</html>