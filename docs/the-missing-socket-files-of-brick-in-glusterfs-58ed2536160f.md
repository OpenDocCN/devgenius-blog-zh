# 格鲁斯特夫斯缺失的砖的插座文件

> 原文：<https://blog.devgenius.io/the-missing-socket-files-of-brick-in-glusterfs-58ed2536160f?source=collection_archive---------3----------------------->

有一天，在与 glusterfs 一起工作时，我发现了一些奇怪的事情。I/O 正常进行，所有的砖块进程也在节点上运行，但是在尝试获取卷的状态时，我发现某些砖块处于停止状态！很奇怪不是吗？

我们将探究到底是什么造成了这一点，为什么不与叶旧袜子文件。

所以，我开始深入挖掘(这是一个查看日志的时髦术语。如果没有日志，对于任何项目中的任何问题，调试都将是一项艰巨的任务！).现在，程序块进程已经启动，I/O 照常进行，没有任何停顿…那么，谁该受到责备呢？

在跳到日志分析(日志的 grep 的时髦术语)之前，我实际上已经尝试了通常的方法

```
# gluster vol start <volume-name> force
```

甚至

```
# systemctl restart glusterd
```

因此，砖块进程正在运行，glusterd 也在运行，但是 glusterd 仍然认为砖块进程没有启动..

过了一段时间(用头撞木头……也许我们应该对 glusterfs 做些日志分析？而不是手动浏览…)我确实在 glusterd.log 中看到了一些奇怪的东西。

*   glusterd 进程发现 brick 进程已经在运行了(是的，因为我没有杀死它)
*   它接收/var/run/gluster 中的 sock 文件，该文件特定于 brick 进程，并尝试建立连接。
*   出现一条消息，其中砖块的状态设置为已停止！

因此，下一步自然是检查 sock 文件有什么问题，因为这是用于通信的文件。

你瞧 sock 文件不见了(现在我不知道这是怎么回事…或者为什么…只是它不见了…也许是一些流氓脚本在这里造成的…)。这就是状态被设置为 stopped 的原因，因为 glusterd 无法连接到 brick 进程。

我已经在上游提出了一个问题，并且正在考虑对被 glusterd 视为理所当然的 sock 文件路径进行一个健全性检查。

我们也许应该检查一下它是否存在，因为我们在尼克斯有相当多的孤儿和僵尸，现在没有人需要一个幽灵:p