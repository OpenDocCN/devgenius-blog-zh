<html>
<head>
<title>Deserialize Child Classes With Pydantic, Is it Gonna Work?!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Pydantic 反序列化子类，有用吗？！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deserialize-child-classes-with-pydantic-that-gonna-work-784230e1cf83?source=collection_archive---------2-----------------------#2022-03-31">https://blog.devgenius.io/deserialize-child-classes-with-pydantic-that-gonna-work-784230e1cf83?source=collection_archive---------2-----------------------#2022-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dda4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用 Pydantic 反序列化子类的问题，以及如何解决。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b24299bf62fb201b66e32f0901fefb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpikzKzDOy7CismOlw7IFQ.jpeg"/></div></div></figure><p id="c937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Pydantic 是一个很棒的包，用于在 Python 中序列化和反序列化数据类。<br/>当我们试图使用内置的 JSON 库进行反序列化时，它不会像预期的那样处理类。Python 是一种动态类型语言，因此不支持指定加载到什么类型。在 Pydantic 中，每个属性的类的提示类型以及序列化和反序列化的魔力将开箱即用。(欲了解更多信息，请阅读<a class="ae ku" href="https://motcke.medium.com/is-c-superior-to-python-in-serializing-data-5c122dfbd57c" rel="noopener">文章</a>)</p><p id="0051" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，当处理类继承时，Pydatic 将无法反序列化对象。让我们看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="b0fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们暗示<code class="fe kx ky kz la b">ducks</code>是一个<code class="fe kx ky kz la b">list[DuckBase]</code>——这意味着<code class="fe kx ky kz la b">ducks</code>可以包含<code class="fe kx ky kz la b">DuckBase</code>的任何子类。序列化<code class="fe kx ky kz la b">disney_movie</code>时，一切都将按预期进行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="c559" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，当将这些原始数据反序列化回它的类时，我们在 python 对象中只得到部分数据——所有的<code class="fe kx ky kz la b">ducks</code>都被解析为<code class="fe kx ky kz la b">DuckBase</code>而不是正确的类！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="f609" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的课在哪里？！我要他们回来！</p><h1 id="5ec5" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">为什么解析成正确的类如此重要？</strong></h1><p id="fc95" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">在 pydantic 中，当加载特定类的数据时，有一些强大的实用程序。例如:类型注释、默认值、数据无效时的用户友好错误、验证器等。</p><p id="b32f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当加载到错误的类时，会丢失那些强实用程序。例如，我们可以添加一个验证器来验证<code class="fe kx ky kz la b">DaisyDuck</code>中的<code class="fe kx ky kz la b">voice_by_years</code>值必须是 1945 年到 2022 年之间的一组年份。当我们加载到<code class="fe kx ky kz la b">DuckBase</code>类时，这个验证将不会运行。</p><p id="9e9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这个有问题的场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="972c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们试图用错误的<code class="fe kx ky kz la b">voice_by_years</code>反序列化一个<code class="fe kx ky kz la b">DaisyDuck</code>到<code class="fe kx ky kz la b">DaisyDuck</code>类时。我们不会得到预期的<code class="fe kx ky kz la b">ValueError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="a3f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，当我们试图用错误的<code class="fe kx ky kz la b">voice_by_years</code>反序列化一个<code class="fe kx ky kz la b">DaisyDuck</code>到<code class="fe kx ky kz la b">DuckBase</code>类而不是<code class="fe kx ky kz la b">DaisyDuck</code>时。我们不会得到预期的异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="8d63" class="lb lc in bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated"><strong class="ak">提示可能的子类</strong></h1><p id="daaa" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">于是我找到了一个解决办法，不提示<code class="fe kx ky kz la b">ducks</code>为<code class="fe kx ky kz la b">list[DuckBase]</code>，我会提示<code class="fe kx ky kz la b">ducks</code>为<code class="fe kx ky kz la b">list[DonaldDuck|DaisyDuck]</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="5811" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看 JSON 会是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="a357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哦！突然我看到<code class="fe kx ky kz la b">DaisyDuck</code>物体有一个额外的场——<code class="fe kx ky kz la b">nick_name</code>。我不想要。为什么会这样？</p><p id="9061" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Pydantic 看到鸭子中的每只鸭子都有两个选项作为其类型。它试图序列化为第一种类型<code class="fe kx ky kz la b">DonaldDuck</code>。属性<code class="fe kx ky kz la b">nick_name</code>在<code class="fe kx ky kz la b">DaisyDuck’s</code>对象中缺失。但是，有一个缺省值 None，所以 pydantic 解析为带有<code class="fe kx ky kz la b">nick_name = None</code>的<code class="fe kx ky kz la b">DonaldDuck</code> JSON。</p><p id="ddfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将改变<code class="fe kx ky kz la b">ducks</code>类型列表的顺序(首先是<code class="fe kx ky kz la b">DaisyDuck</code>，然后是<code class="fe kx ky kz la b">DonaldDuck</code>)，那么在序列化 JSON 时，将包括来自<code class="fe kx ky kz la b">DaisyDuck</code>的所有属性的默认值。</p><p id="55da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mq">一定有更好的办法！</em> </strong> <em class="mq">不包括额外属性。</em></p><p id="d8b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们删除默认值，看看 JSON:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="9088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哦！现在我已经有了我想要的字段，<strong class="jm io">，没有了额外的默认值字段</strong>:)</p><p id="6d7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们反序列化这些原始数据时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="6bef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据 JSON 中的原始数据将<code class="fe kx ky kz la b">ducks</code>的每个 duck 解析为正确的子类。</p><p id="1987" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我想保留我的默认值。<strong class="jm io"> <em class="mq">一定有更好的办法！</em> </strong></p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="ae2d" class="lb lc in bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated"><strong class="ak">注释元数据字段提示</strong></h1><p id="0288" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">让我们将新类型的<code class="fe kx ky kz la b">Duck</code>声明为<code class="fe kx ky kz la b">[DonaldDuck, DaisyDuck]</code>，并为每个子类添加一个名为<code class="fe kx ky kz la b">duck_type</code>的元数据属性，该属性将描述 duck 类型(<code class="fe kx ky kz la b">‘donald’</code> / <code class="fe kx ky kz la b">’daisy’</code>)。并使用这种类型的<code class="fe kx ky kz la b">Duck</code>作为鸭子列表的类型。让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="cf8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 JSON 中，我们可以看到<code class="fe kx ky kz la b">duck_type</code>元数据也被保存了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="8b7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们反序列化这些原始数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="00a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">耶，一切都像预期的那样解析！</p><p id="eb9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是当我们将添加一个新的<code class="fe kx ky kz la b">DuckBase</code>的孩子时，我们将需要处理类型<code class="fe kx ky kz la b">Duck</code>，我不想每次都更新这个类型。<strong class="jm io"> <em class="mq">一定有更好的办法！</em> </strong> <em class="mq"> </em>我能做什么？</p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="5fa4" class="lb lc in bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated"><strong class="ak">元数据字段动态提示</strong></h1><p id="e5f4" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">我可以在<code class="fe kx ky kz la b">DuckBase</code>类中实现<code class="fe kx ky kz la b">__<strong class="jm io">init_subclass__</strong></code>函数。这个函数将在创建<code class="fe kx ky kz la b">DuckBase</code>的子类时调用。在这个函数中，我将在<code class="fe kx ky kz la b">subclass_registry</code>中自动保存 Duck 类的所有子类。</p><p id="6bf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当初始化<code class="fe kx ky kz la b">DuckMovie</code>类时，<code class="fe kx ky kz la b"><strong class="jm io">__init__</strong></code>函数将:</p><ol class=""><li id="5a4f" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">通过属性<code class="fe kx ky kz la b">duck_type</code>检查每只鸭子的类型。</li><li id="77ae" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">在<code class="fe kx ky kz la b">subclass_registry</code>中寻找与<code class="fe kx ky kz la b">duck_type</code>相同的子类。</li><li id="10ef" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">用鸭子的原始数据创建匹配子类的实例:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="1c8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看看迪士尼 _ 电影的 JSON:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="0148" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在反序列化的结果中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="6f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太棒了！我有正确的课程。</p><p id="70bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，我不想存储每个孩子的类的元数据！<br/> <strong class="jm io"> <em class="mq">一定有更好的办法！</em> </strong></p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="8962" class="lb lc in bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated"><strong class="ak">通过属性名称动态提示</strong></h1><p id="a6c8" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">我可以通过查看类中存在哪些属性来了解类的类型，而不是将元数据存储在原始数据中。</p><blockquote class="nf ng nh"><p id="c8bd" class="jk jl mq jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated">如果它看起来像只鸭子，游泳像只鸭子，叫声像只鸭子，那么它很可能是只鸭子。</p></blockquote><p id="f5f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在将鸭子解析到正确的类时使用鸭子类型的概念！当初始化<code class="fe kx ky kz la b">DuckMovie</code>类时，<code class="fe kx ky kz la b"><strong class="jm io">__init__</strong></code>函数将:</p><ol class=""><li id="bb4b" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">检查每只鸭子的属性名称。</li><li id="05c1" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">在<code class="fe kx ky kz la b">subclass_registry</code>中寻找具有相同属性名称的子类。</li><li id="1002" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">用鸭子的原始数据创建匹配子类的实例:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="d4c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看 JSON:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="80e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！<strong class="jm io">没有多余字段</strong>！</p><p id="194c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反序列化的结果看起来如何？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="aa9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">精彩！！！</p><p id="7a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论:</strong></p><p id="694e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们看到 Pydantic 没有将子类反序列化为正确的类。在本文中，我们试图帮助 Pydantic 理解反序列化到哪个孩子的类中。</p><p id="fb00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们通过暗示所有可能的子类来做到这一点(使用<code class="fe kx ky kz la b">Union</code>)。如果我们不需要默认值，这可能会很棒。然而，当我们使用默认值时，Pydantic 从第一个可能的子类中序列化实例的额外默认值。</p><p id="a179" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其次，我们向每个子类添加了子类类型的元数据，这些元数据也被保存到 JSON 中。这样 Pydantic 就能明白哪个子类被反序列化了。然而，我们不想将元数据保存到 JSON 中。</p><p id="0132" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们找到了告诉 Pydantic 如何确定子类类型的方法，方法是将现有的 JSON 属性与子类属性进行匹配。</p></div></div>    
</body>
</html>