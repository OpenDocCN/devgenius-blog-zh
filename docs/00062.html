<html>
<head>
<title>Microservices VS Monolith architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务与整体架构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservices-vs-monolith-architecture-8a45ac1c902a?source=collection_archive---------2-----------------------#2019-09-11">https://blog.devgenius.io/microservices-vs-monolith-architecture-8a45ac1c902a?source=collection_archive---------2-----------------------#2019-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4b1876e4d8a782e973ee45186ccb2a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isE12u3zpuCVtD8crb32nw.png"/></div></div></figure><p id="6f35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">软件开发主要使用的现代范式有:</em></p><p id="93cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">bug 驱动开发</em></p><p id="cd65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> CV 驱动开发</em></p><p id="1726" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">时尚驱动发展</em></p><h1 id="81d0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="c8cc" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">写这篇文章的原因是经常需要向开发人员(<em class="kt">甚至架构师</em>)解释一个显而易见的事实，即他们最大的麻烦是错误地选择了项目的基础架构，并且没有考虑到引入任何新特性都有其自身的成本和后果这一基本事实。</p><p id="c7b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如亚伯拉罕·马斯洛(Abraham Maslow)在 1966 年所说，“我认为，如果你唯一的工具是一把锤子，那么把一切都当成钉子是很有诱惑力的”。如果锤子是新的、闪亮的、有吸引力的多功能锤子，在同事面前炫耀它(并以更高的价格卖给顾客)的诱惑几乎不可避免。唯一能够真正给我们的辉煌前景蒙上阴影的是一个可悲的事实，即令人愉快的锤子不仅从长远来看非常昂贵，并且有足够的长度可以挂在上面，而且还对整个系统的整个生命周期提出了许多完全不明显的要求。</p><p id="776a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，我们经常会遇到丑陋的巨石柱，它们在开发过程中非常昂贵，而且在生产过程中无法维护。但是，通常从这种整体架构过渡到不合理或设计糟糕的微服务架构会更加昂贵，并且几乎无法纠正这种情况。同时，一个拥有良好开发组织的设计良好的整体展示了不亚于微服务的伸缩能力(运行时和开发)。在本文的相应章节中，我将尝试简要描述这些方法。</p><h1 id="4e6d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">现代趋势</h1><p id="a726" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">今天，我们没有采用长时间的开发过程(通常基于瀑布或足够长的迭代),而是遵循敏捷方法，通常处理一系列短迭代，旨在向用户快速交付中间结果，获得快速反馈，逐步提高质量并澄清整个任务。</p><p id="9cc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">迭代的频率变得比当前的性能更有价值，因为我们总是可以优化代码，甚至临时增加更多的硬件来加速缓慢的系统。</p><p id="b2cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更重要的是能够快速更新功能、解决问题或在业务中获得竞争优势。</p><p id="ac56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从技术角度来看，现代系统变得更加复杂。它们通常使用多个数据源，与多个远程服务进行交互，同时部署在多个独立数据中心中具有大量节点的集群中。</p><p id="7592" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现代软件不再是辅助设备，而是一步一步地成为企业的引擎和主要竞争资源。它允许他们引入新的收入流，并优化传统收入流的使用。</p><p id="1848" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于迫切需要快速交付，业务需求每周(甚至每天)都会发生变化。越来越多的客户不想同步，而是依赖单一的发布周期。原则上，他们所要求的功能集通常不允许计划渐进的发布周期。</p><p id="4e17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现代对生产力和可扩展性的要求大大提高:</p><p id="fbee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总负载可能会快速增长。通常的垂直可伸缩性(甚至是水平的，基于实例的简单乘法)是不够的。</p><p id="a36c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">负载峰值和下降是不可预测的。我们需要能够非常快速和频繁地扩展/收缩系统的容量，因为云资源非常昂贵。</p><p id="ba76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要处理的现代数据量通常超出了单个甚至集群数据库实例的限制。它需要能够在不同的物理数据库之间分发数据，并以从拥有应用程序的角度来看最佳的表示形式存储数据。</p><p id="f1c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还必须应对苛刻的应用程序可用性要求(SLO 和 SLA):</p><p id="03cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于系统的不断发展和不可预测的负载水平，在系统的某些部分，临时问题(直至并包括服务的完全断开)是不可避免的和经常性的。</p><p id="25d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从另一个角度来看，它们不应该通过整个系统级联，影响整个应用程序的可用性和性能。</p><h1 id="026e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">庞然大物</h1><p id="f2da" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">三层整体式建筑是最常见的建筑之一。这意味着用户界面、业务逻辑和数据访问逻辑作为一个单一的工件一起开发、构建和部署在一个/几个专用的应用服务器上，通常在公司自己的内部基础设施中心。</p><p id="3733" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常这种应用程序只与一个数据库一起工作，与其他系统的集成很少。它很少更新——通常一年发布几次(每月一次是一个很大的成就)。其上的负载是足够可预测的或者在时间上几乎是恒定的，这使得系统所需的容量容易预测，并且使得有可能提前为增加它的必要性做准备。为了执行更新或维护，停止它实际上总是不成问题的。计划的或特别的，但尽管如此，它对大多数用户来说是足够无痛的。</p><p id="666e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">系统开发和支持阶段划分得很好。当一个开发团队将一个应用程序的下一个版本引入验收测试的狭窄“出口”时，这意味着从现在开始全部责任被转移到另一个团队。</p><p id="8070" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种应用程序的未来是足够透明和可预测的。它允许应用具有长期影响的基础架构和设计解决方案，这些影响可能是积极的，也可能是消极的。</p><h1 id="af68" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">优势</h1><p id="378b" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">主要的、明显的和最大的优点:它已经被知道很长时间了，因此几乎每个专业人员都已经非常了解如何设计、开发、调试、监控、分析等。这样的应用。为了强调我们过去默认使用的并不总是很清楚的特性，必须对这一陈述稍加阐述:</p><p id="dad6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">IDE 和其他开发工具主要适用于单片开发。</p><p id="29ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">执行全局重构很容易。这在开发的早期阶段尤其重要，那时架构和设计还没有确定下来，需求也经常变化。</p><p id="e7c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件的兼容性没有问题:所有的 API 不一致性都可以在编辑、编译过程中检测到，而不是在运行时检测到。</p><p id="b0c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本地呼叫的执行简单而快速。</p><p id="c087" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 ACID 事务并总是以一致的状态查看数据是可能的。</p><p id="6330" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">端到端测试可以很容易地实现，并且可以同时访问应用程序的所有级别:从 UI 到数据库。</p><p id="895a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建和部署是琐碎的:每个应用程序一个工件(例如，WAR 或者甚至是一个可执行的 JAR)。</p><p id="7d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运营成本可以最小化:单个源代码存储库，每个交付阶段一个 CI / CD 作业。</p><p id="e29c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只有当实现的功能范围、处理的数据量和参与开发的人数显著增加时，我们才开始遇到问题。通常在这个时候，一个应用程序不知何故自己变成了一个“大泥球”。这个过程只是规模的结果。不幸的是，这是不可避免的，只能通过定期的额外努力来推迟。</p><h1 id="1cd2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">不足之处</h1><p id="53d2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">主要常见问题是单一应用程序的技术和组织可伸缩性。它通常被称为“铁板一块的地狱”。一般来说，在软件开发的世界中，集中化和维护的增加总是会降低失败的风险，但同时也会增加引入任何变更的成本。</p><p id="4221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只要这个庞然大物的规模和复杂性不断增长，参与者之间的沟通和协调成本就会直线上升。让所有开发人员参与整个应用程序的完整上下文的成本也是如此，这对于保持架构的一致性和干净的代码是绝对必要的。临界尺寸通常被定义为“两块披萨法则”。从这个经验上的参与者数量开始，增加新的开发人员将会减慢整个系统的开发过程。</p><p id="7086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了不断增长的代码库，ide 还降低了源代码、应用程序启动速度、运行测试等所有基本操作的速度。开发人员的生产力不可避免地在下降，而工作站和服务器的硬件需求却在增长。开发人员的沮丧程度和他们在过程中的参与对经理来说也是不愉快的。</p><p id="6eff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着开发人员数量的增长，他们在相同的积极开发的代码片段上的交集的概率增加了。意思是:</p><p id="b020" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单个代码分支合并的常见问题。</p><p id="f00a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有一个开发人员处理应用程序的真正整体状态。它增加了运行时出错的可能性。</p><p id="f129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">冲刺阶段结束时/发布前的测试和稳定期被显著延长。</p><p id="d9f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单一的源代码空间引入了额外的工作:每次你需要在一个部分做一些改变，你需要组装、测试和部署整个整体。这导致组件生命周期的不一致:整体构件不同部分的发布日期变得相互依赖。它导致所有参与者之间的额外协调的必要性，同时降低了开发的性能。</p><p id="83f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，典型的抱怨是:组件“A”的功能已经完全实现，但是我们不能执行集成测试，因为:组件“B”和“C”没有准备好或者抛出了一个错误/应用程序根本不能启动/业务工作流没有到达我们的组件，因为其他一些错误等等。</p><p id="7909" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果，所有问题定期地从一次迭代到另一次迭代，在发布周期结束时累积，并积极地阻止彼此的修正。有问题的发布的可能性显著增加。</p><p id="e0db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个版本被感知得越痛苦，它就越被推迟，剩下的就越有可能是隐藏的问题等等。总的来说，我们有一大堆正面“负面”反馈的问题。</p><p id="19e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">端到端和集成测试的开发速度大大减慢。为了运行测试，有必要执行大量的准备工作，将应用程序移动到特定测试所需的初始状态。测试脚本变得越来越复杂，它们的需求开始相互矛盾。</p><p id="8448" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个特别大的问题是整体建筑的统一架构。正常情况下，所有组件都应遵循这一原则，即使对许多组件而言，这是次优或多余的:</p><p id="4d93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在特定语言和调用技术的基础上，一个整体的各个组件变得紧密相连，而不是使用开放平台中立的协议进行交互。</p><p id="5769" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">长路径效应:如果在一个单一应用程序中做出了一些糟糕的架构或设计决策</p><p id="a946" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 它很可能已经蔓延到整个系统，根除它需要大量成本(以及解决方案的稳定性受到威胁时的过渡期)。</p><p id="71d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，它会继续产生一系列糟糕的决策和妥协。</p><p id="b4b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想要放弃一个遗留的/过时的/折衷的库或框架，我们必须立刻对所有的应用程序进行修改，这可能是相当困难的。</p><p id="4c32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 结果，转换被推迟到无穷大，只是随着时间的推移增加了具有脏依赖/的气味代码的量。</p><p id="c1f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 顺便说一下，如果我们使用 Java 9 / OSGi /多类加载器，这个问题可以部分绕过，但是需要付出很多努力，而且不够透明。</p><p id="2f9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，现在应用程序需求可以经常改变，这意味着架构和设计的“最优性”只能在短期内实现。这种单一架构的“根本”不会带来任何好处，反而会导致复杂的问题。此外，对于一个大型且快速发展的项目来说，即使已经获得了统一架构的最优性，也不太可能持续很长时间。</p><p id="0da6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个常见的问题是一个整体的高可用性不相关的组件彼此的资源；因此，它们的实现具有高度的内聚性。结果，在粗心设计的情况下(这意味着几乎总是在长时间开发系统的情况下):</p><p id="8a88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个组件实现的内部细节往往会“泄露”。尤其是通过数据库的结构，为了“优化”的目的，这在组件之间产生隐含的依赖性。</p><p id="f15f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">过了一段时间(特别是如果没有特别的努力去预防)，一切都已经变得依赖于一切。因此，所有开发人员必须拥有所有代码，随着项目的增长，这显然是不可能的。</p><p id="828f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出现这种问题的一个明显症状是，看似简单的局部变化开始产生不明显的后果(所谓的“涟漪效应”)。在这种情况下，即使是在单个组件范围内的小变化的情况下，全局测试也是必要的。另一个可怕的症状是一些变更经常不完整:当一个 bug 最终被修复时，我们会收到十个或几个新的 bug。新功能的引入也有类似的情况。随着时间的推移，每一个新的变化都需要越来越多的工作，从长远来看通常是无限的工作。</p><p id="5dea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着应用程序的增长，我们不仅在开发阶段，而且在运行时也开始面临复杂的问题:</p><p id="6bbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Monolith 应用程序仅在整体上是可扩展的，尽管有时可能只需要其中一个组件的额外资源。典型示例:在文档的生命周期中呈现 UI /处理文档/生成报告/图像处理/记账。这种“同伴”代码只会吞噬资源，例如，通过增加在多线程或内存耗尽的上下文之间切换的成本。</p><p id="78f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不同的模块可能对硬件有完全不同的要求:有人需要更多的内存来缓存数据，有人需要更多的 CPU 来处理电子签名。此外，有必要考虑特定环境(例如，PCI DSS)中特定硬件/操作系统/软件/安全策略/网段的各个模块的不同需求。</p><p id="5bab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任何这些组件的运行时问题都会立即成为整个实例的问题。此外，如果所有节点都大致相同，并且同时启动，那么每个节点可能几乎同时出现问题，这将导致整个应用程序失败。或者它们会被一个个拒绝，增加其他的负载，迫使它们依次关闭。</p><p id="ed9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一下，如果我们甚至将一个应用程序分割成单独的服务，但是在安装之后所有的东西都在同一个应用服务器上(特别是在同一个 JVM 实例中)，这个问题仍然没有解决。同样的问题，如果所有这些“分离的”服务都连接到同一个数据库(或另一个共享资源):连接耗尽或长事务的问题仍然会影响所有这些服务。</p><h1 id="1dc1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">常见的误解</h1><p id="9b9a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">与常见的误解相反，monolith 应用程序可以以非常模块化的方式在内部进行组织。此外，强烈建议从开发之初就遵循这样的风格。它使开发人员的生活变得更容易，并提供了拆分(未来不可避免的)成微服务的可能性。</p><p id="4076" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，这种方法需要相当多的纪律和所有开发人员的定期努力。随着团队的成长和意识水平的降低，事情会变得越来越复杂。但是在微服务架构中编写跨服务代码需要同样多的努力，而且我们还有很多额外的麻烦。</p><p id="db6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些技术可以极大地促进应用程序的模块化:</p><p id="43c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，具有模块化组织和“强制禁止依赖”插件的 Maven 项目；这允许限制模块/模块组的可能依赖性。</p><p id="33bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于编写架构控制测试的 ArcUnit 项目。</p><p id="2e01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">OSGi 容器和 Java 9 模块。</p><p id="ed17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与另一个流行的观点相反，这种独石非常具有可扩展性和防故障性。对于负载分布，我们可以使用 HTTP 平衡器或 JMS 消息队列。一个整体的所有运行实例通常依赖于一个单一的数据仓库。</p><p id="0a91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是这种方法的可扩展性有限。例如，如果我们执行许多连接到单个数据库的等价实例，我们会有一个有限的数据库带宽，以及在高度竞争的表上的乐观事务的问题，当所有参与者“踩在门阶上”时。当然，这样的问题是可以解决的:我们可以应用 CQRS +几个数据库，以及数据分片，而不需要实现完全分布式的架构。</p><h1 id="9fee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">微服务</h1><p id="d903" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">微服务通常被理解为分布式的、松散连接的、易于管理的服务，它们执行少量定义明确(如果可能，定义严格)的任务。微服务的架构没有行业标准。它更像是一套组织原则，而不是明确定义的技术栈(比如 web 服务)。</p><p id="e3db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个微服务开发团队都拥有源代码和相关的基础设施。它包括一个独立的存储库，必要的服务器(应用程序/数据库等)的单独安装，用于独立于其他服务构建/发布/部署/测试自己的服务的工具。开发人员通常不仅负责开发本身，还负责整个操作序列，包括最终部署；以及底层系统的操作方面。众所周知的亚马逊原则:“你创造了这个产品；你维持它的工作”。</p><p id="2965" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个微服务都可以独立于其他应用服务进行构建/部署/测试。由于微服务的规模很小，这些操作非常便宜和快速。</p><p id="c730" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个微服务都有自己明确定义的业务领域和职责范围，并对此完全独立负责。在某种意义上，它遵循 UNIX 模型——应用程序只不过是服务的集合，每个服务只做一件事，但做得很好。微服务本身及其开发团队都是围绕特定的业务流程组织的，他们对这些流程的成功负有全部责任。团队成为专注于具有可衡量商业价值的特定结果的团体。</p><p id="8c6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个微服务都有自己的数据存储，只有通过它才能访问。即使几个微服务使用相同的数据，每个微服务都以自己的最佳形式存储自己的副本。一般来说，任何共享资源(不仅是数据库，还包括应用服务器等)都难以扩展功能，减缓了从开发到部署的过程，并且难以管理。当 Amazon 在开发扩展过程中面临几个命令共享访问一个数据库的必要性时，他们建立了一个原则，即数据集成只能通过 API 来执行，而不是基于共享的数据结构。</p><p id="bf10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">微服务是松散耦合的。微服务之间的交互通过系统的标准 API 来描述，这是各个团队之间协议的主题。如果这个 API(以及其中包含的一组前置/后置条件)保持不变，服务的开发人员就有权对其进行任何修改。</p><p id="316c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">微服务之间的通信是基于轻量级协议执行的，不依赖于任何技术平台。通常是 HTTP + JSON / XML，但是消息系统、二进制格式等等。可以使用。一个基本原则是:“哑传输+智能客户端”。例如，不建议将 ESB 作为微服务之间的交互方法。</p><h1 id="d3d4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">优势</h1><p id="1d07" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">微服务的好处广为人知。因此，我们简单列举一下。</p><p id="8d06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有操作都更容易:从开发和测试到 CI 和 CD。</p><p id="d27e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发/执行/维护的灵活性和可扩展性。</p><p id="f50c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">个体开发团队的自主性。组之间相互等待执行系统更新的时间最少。</p><p id="1135" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员需要记住的信息量显著减少。然而，当然有必要协调各个小组之间的工作。</p><p id="fa89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单、快速和独立的系统发布和“一部分一部分”升级。作为一个整体，应用程序总是处于为下一个版本做好准备的状态。一个小的错误更新也可以快速回滚—错误代价降低。经常更新系统是可能的。理论上，这是一个持续的过程。</p><p id="3423" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在传统情况下，刷新率较低，刷新的准备/安装时间较长。对于微服务架构(至少在理论上)，情况正好相反。</p><p id="9ea6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户由于技术原因无法使用某个应用程序时，不需要“维护窗口”。2014 年，亚马逊每 11 秒就更新一次软件。网飞大约有 16 分钟的安装更新准备时间。</p><p id="d1e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缩短向客户交付新功能的时间(上市时间)。</p><p id="72bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">减少开发人员反馈的时间，从而增加他们对过程的参与和动力。</p><p id="67b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个很大的优势是通过将单个服务相互隔离，提高了系统的稳定性。在大多数问题的情况下，放弃一部分功能以挽救基本用例的可能性对于业务来说是至关重要的(如果负载急剧增加，能够发送信件是至关重要的，但是通过第一个字母暗示收件人的功能可能会下降)。</p><p id="c7c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">引入微服务是重新考虑以前做出的不成功决策的好方法。今天消除它们的负面影响，更重要的是，明天。即使我们在某个地方再次做出一个糟糕的决定，其负面后果的范围也会低很多，修复它的成本也会低很多。</p><h1 id="c03a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">不足之处</h1><p id="873a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">微服务的缺点(以及使用的总成本)通常不会被广泛宣传，而是通过许多神奇的工具来掩盖，这些工具旨在从根本上简化开发新手的生活。</p><p id="cc12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，对于微服务架构来说，将所有功能正确划分为单独的服务既重要又困难。如果服务太大，我们就有一个整体乘以新的独立模块的数量的所有问题。如果它太小，我们在远程交互方面会有重大损失，降低系统的可靠性，不可能实现有保证的数据一致性，等等。此外，不要忘记影响几个服务的一个功能的实现/部署的经常性问题。显然，没有最优的分手技术；还是某种艺术吧。</p><p id="0771" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二，任何远程交互都更难实现，尤其是当我们想要并行调用、执行结果处理的异步延续等等。它总是比最小延迟相对较高的本地呼叫慢至少一个数量级。任何事情都可能在任何时候出错:</p><p id="d9c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">查询/响应可能会丢失，甚至出现错误的顺序；服务可能会暂时停止响应或根本不可用。</p><p id="8ae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当根本没有收到回答，并且不清楚操作是否被执行(丢失请求或响应)时，我们会特别头疼。最简单的处理方法是幂等运算，这使得业务逻辑更加困难。</p><p id="323e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">IDE 和其他工具不太适合开发/执行/测试分布式系统。调试分布式系统要困难得多，因为每个调用都要经过服务器的多个实例。因此，当远程访问请求时，没有完整的上下文，也不可能继续调试请求。同样，日志记录和监控也是如此。需要收集和联合分析日志的特殊系统、用于监控系统和业务指标的面板，等等。</p><p id="49b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任何测试都会以这样或那样的方式导致集成测试的所有缺点。或者每样东西单独运行都很好，但是不能一起运行，例如，因为调用参数的数据完整性错误。</p><p id="3cb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无法使用正常和众所周知的 ACID 事务。分布式事务不是正确的方式；它们不稳定，会降低性能。</p><p id="d615" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应用程序数据的不同部分经常处于稍微不一致的状态，设计业务流程时应该考虑到这一点。很少有商业分析师平静地接受这样的规则变化，尤其是在金融和银行业。</p><p id="cb68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个令人痛苦的基本区别是:从现在开始，远程调用的错误不能总是通过回滚事务来自动处理。这通常会导致特殊的业务流程，进而导致错误等等。</p><p id="b89e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些都使得有必要应用 SAGA 模板，甚至在复杂的情况下实施 BPMN 引擎，这在开发过程和维护期间都是昂贵的。</p><p id="1e78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">常见业务代码分离的问题:通常不够稳定。只要一更改，一波潜在的更改就席卷所有微服务，甚至不涉及可变功能。因此，需要代码复制(每次都写)。</p><p id="33fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运营成本也不可避免地大幅增加:</p><p id="8086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至少必须引入一个独立的每个服务的存储库，并引入一系列 CI 任务，用于组装/测试/验收/部署。</p><p id="a939" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个功能片段的实现通常涉及几个存储库——很难分析变更，在开发和部署期间需要团队之间的额外协调。</p><p id="8e99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工件的数量正在快速增长，至少<number of="" services=""> x 3:服务 API、服务实现、带有服务的 Docker 容器等等。此外，对于每个运行时环境的每个服务配置，必须作为工件存储和交付。</number></p><p id="e9d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">版本化:每个服务都有独立的生命周期，所以它们都有不同的版本，我们会不时地切换它们。</p><p id="969d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于在不同环境中部署和状态监控的特殊基础设施。例如，网飞 Spinnaker，Docker Smarm，Kubernetes 或 PaaS 平台，如 Pivotal Cloud Foundry，Red Hat Open Shift。当然，它们使任务变得更容易，但是它们的正确实现也需要相当大的努力。因此，我们需要专门的 DevOps 专家来支持整个动物园，没有他们，成功的机会微乎其微。</p><h1 id="003e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">分布式整体</h1><p id="eb09" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这是一个非常著名且经常遇到的反模式。当分布式架构的使用不够合理，微服务的所有好处都可以安全地丢弃时，它来自于使分布式应用程序的开发过程尽可能容易的愿望。不幸的是，这种体系结构的分布式本质无法回避。因此，它创造性地结合了两种方法的主要缺点。</p><p id="0d30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常这种应用程序是由一个大型团队开发的，其中每个成员都必须拥有系统的全部代码。这些代码位于一个单独的存储库中，每次都从这个存储库中构建具有相同版本的整套微服务。</p><p id="5d07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在大多数情况下，具有相同版本的这组服务是作为一个整体在客户的场所发布和部署的。有时可能会看到一个技巧:服务集是作为一个整体构建的，但另一组不同版本的服务被交付给客户。这当然是更聪明的方法，但是它也有几个严重的缺点:</p><p id="f0f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不可能向客户提供与系统当前状态相匹配的可构建源代码。但是能够做到这一点是通过安全审计程序的一个重要机会。</p><p id="1533" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们需要调试应用程序的某些已定义状态，我们被迫多次下载源代码库(根据部署组件的各种版本),并遇到为 IDE 设置项目的不简单过程。</p><p id="6ece" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多公共业务代码，这些代码由所有服务共享，并作为定期级联更改的来源。因此，几乎任何用例的实现都会导致大多数模块的改变。</p><p id="b88e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，这种应用程序基于一个数据库，在所有服务之间共享。</p><p id="f95a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使大多数表没有在不同的服务之间共享，它们仍然相互使用外键来维护引用完整性。结果，即使我们使用分布式事务，我们仍然有问题，因为在数据库级，一个共享事务被实现为几个本地事务。因为对此，不同的服务看不到彼此所做的改变。</p><p id="1ba5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使每个服务都有自己的数据方案，它们仍然隐式地相互依赖，因为它们共享公共的数据库服务器资源，例如:用于处理传入连接的池或共享的内存区域。</p><p id="93a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不顾一切地遵循将一个整体应用程序分成内部组件的惯例，开发人员很容易就达到了“纳米服务”的水平。</p><p id="9f6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，它们通常分离 CRUD 组件，然后遇到大量冗余网络调用，且必须应用共享事务来达到数据的一致性。</p><p id="6d38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，这种分离反映了应用程序的技术设计，而不是其各个部分和常见用例的业务细节</p><p id="0abd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的应用最终有 90 个微服务，也许你相当幸运，开发出一个大家都知道的世界级应用…</p><p id="08e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调用的远程特性通常被创造性地隐藏在 API 后面，这产生了局部性的假象，并对开发人员隐藏了底层细节。在最初的活跃开发阶段，这对于开发人员来说是相当舒适的，并且为他们提供了一种完全控制复杂性的感觉。但是随着时间的推移(特别是当遇到真正的用户时)，它导致了严重的缺陷:</p><p id="c2dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它通常需要使用复杂的协议，比如 SOAP。在开发的初始阶段，仅仅遵循指导方针通常就足以取得成功。但是，当谈到在负载下实现可观的性能和稳定性时，情况很快变得更加糟糕。另一方面，在这种情况下，开发人员通常会小心地避免任何异步交互。首先，因为在他们看来，这更多的是关于集成，而不是组件之间的内部通信。</p><p id="6bab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员通常会遭受“漏抽象”的困扰。例如，他们无疑可以在 N 循环中进行多次远程调用，而不是实现批处理操作。他们已经习惯了在 monolith 应用程序中的这种做法，目前他们没有理由拒绝。您很少看到允许您将多个相同类型的请求打包到一个批处理命令中的工具，代价是响应时间略有增加。</p><p id="5b03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提供客户端弹性的工具(断路器、重试策略、隔板等)的实现通常会推迟到最终灾难发生的时刻，此时应用程序会定期承受负载。开发人员只是不想理解，在分布式系统中，失败不再是一个例外，而是一个规则。</p><p id="a0e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务发现的基础设施被认为太复杂、太神奇、不确定、不安全等等。它通常被接入点的静态配置所取代，与一组微服务一起安装。结果，在临界条件下，应用变得没有弹性和不稳定。</p><p id="d0d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对分布式系统中固有的特定问题的有意识的和一贯的忽视导致许多必要的高级基础设施元素没有被实现，或者它们的实现被显著地延迟。例如:分布式日志的收集、分析和可视化、带有系统各个组件健康指标的仪表板、自动识别和重启“生病”实例的方法、负载预测工具等等。</p><p id="4863" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不可能不特别提到分布式事务。如果应用程序到服务的分离粒度不是最佳的，开发人员没有任何其他方法来应用它们。它成为强制性的，因为它们需要实现原子操作并具有一致的观点。不幸的是，这样的方法牺牲了性能并提供了效果，这对于开发者来说似乎是神秘的。</p><p id="d3e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发和调试只有通过同时运行组成 monolith 的所有微服务才有可能。首先，它导致系统发布速度明显减慢。其次，需要经常更新本地开发平台，因为各个组件之间的一致性经常会丢失。如此繁重的操作，当为了测试两行修改的代码，必须花几个小时来更新整个服务器时，极大地挫伤了开发人员的士气，将 agility &amp; scrum 变成了一出真正的悲喜剧。</p><p id="031d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在同一个应用服务器上集中安装所有微服务的单一“超级智能”程序。我观察到一个非常棘手的项目组织，当一个应用程序作为一个整体开发和测试，直到最后一刻，才在安装阶段重新打包为一组服务。我认为没有必要解释所有最神秘的问题都出现在这个阶段，通常是在将系统传递给客户之前。</p><p id="1eb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总而言之，在微服务的所有优势中，按照这种方式，我们只有一个机会来提出额外的服务实例。但是，通常没有相应的基础设施来确定需求并自动执行。</p><h1 id="14c4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">大型成功巨石的样本</h1><p id="4f3c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有几个著名的大而成功的例子，它们有重要的代码库和大范围的实现功能。</p><p id="2db5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，它是 Shopify——SaaS 在线商店平台。2018 年年中，它处理了约 60 万名客户，每月带来 1700 万美元的收入。考虑到构建这个整体需要 15-20 分钟，并涉及数百名并行 CI 工作人员来运行所有 100k 测试，可以揭示系统复杂性的一些想法。</p><p id="74f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个流行的例子是 base camp——2004 年推出的基于网络的项目管理工具，有数百万用户使用。有 6 个平台:Web+iOS+Android+Mac+Windows+Email。该应用程序包含数百个屏幕，这些屏幕与 200 多个控制器交互，而这些控制器又有大约 100 种方法。一个领域模型由大约 200 个类和 1500 多个方法组成。这个系统是由一个足够小的团队开发的，大约 12 名程序员。</p><p id="d6f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就我个人而言，6 年来，我一直是一名建筑师和首席开发人员，负责建造另一个真正的大型建筑，这是远程银行和金融管理部门几个大型产品的基础——corre qts(<a class="ae lx" href="http://coreqts.org/en/solutions/financial-institutions/correqts/" rel="noopener ugc nofollow" target="_blank">http://core qts . org/en/solutions/financial-institutions/corre qts/</a>)。基于它的最著名的产品是 corre qts Retail(【http://tadviser.com/index.php/Product:Correqts_Retail】)和 corre qts banking(【http://tadviser.com/index.php/Product:Correqts】)，它们被安装(深度定制)在许多大银行，如 Sberbank(最大的部署，每天处理数百万份金融文件)、Raiffeisen 银行、瑞士瑞信银行、Credit Europe 银行、Nordea、Gazprom 银行等。</p><p id="6f6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CORREQTS 的核心功能基于大约 100 种文档、400 本词典、900 个数据库表、几十个标准网关和外部系统适配器(例如会计或欺诈检测器)。</p><p id="9500" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于正在处理的文档是供公司用户而不是个人使用的，因此相应的 GUI 表单足够复杂——每一个都有 20-100 个数据组件，并且有多达 5 级的父/子对话组织。大约 30 种主要类型的文档是业务流程的基础，用自制的状态机实现。</p><h1 id="b321" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">运行时可伸缩性</h1><p id="032d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">运行时可伸缩性和容错性的实现是通过几种相当简单的方法来保证的，这些方法主要基于消息交换:</p><p id="fa29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该系统基于两种类型的服务器，实现为 war-s。</p><p id="3748" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">有状态 web 服务器(WEB) </strong>用于处理客户端的会话，并从应用程序接收的元数据描述中生成基于 Zkoss(【https://www.zkoss.org/】)的 UI 模型。该服务器通常位于 DMZ 中，仅作为应用服务器的通用入口。它总是完全不受任何业务特定的可执行代码的约束(在运行时和开发时)。唯一必需的配置参数是到 JMS 服务器的连接。</p><p id="119d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">无状态应用服务器(APP) </strong>用于处理来自 WEB 服务器的 UI 事件，以及处理业务文档。在开发过程中，它们是通用的，也没有特定于业务的代码，但是在启动过程中，它们从数据库加载可执行的业务代码。唯一强制的配置参数是连接到与 WEB 相同的 JMS 服务器和数据库服务器，在所有应用服务器之间共享。</p><p id="4b41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WEB 和 APP 之间的事件交换通常是通过位于 DMZ 中的活动 MQ 实例的 JMS 消息来执行的。此外，HTTP 和基于内存队列的传输可用于安全性要求较低的情况。所有应用服务器都连接到相同的传入事件队列。因此，在过载的情况下，我们可以简单地添加更多的应用程序/网络服务器。这些服务器的所有实例都是等价配置的，所以我们只需要增加虚拟机、docker 映像或类似的实例。</p><p id="1d5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每条消息都有一个特殊的“创建时间”属性。所有应用程序服务器上的特定专用监听器正在接收过期的消息，从 SLA 的角度来看，这很关键。所以，所有的应用服务器都在互相窃取额外的负载。在过载的情况下，如果我们添加新的应用程序实例，首先将处理过时的事件。</p><p id="cdd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由每个用户的 HTTP 会话生成的消息流半粘在某个应用服务器上，对于这个会话是永久的。这允许我们有效地使用二级 Hibernate 缓存，而不会将所有引用数据分散到所有服务器上。如果某个应用服务器出现故障，则另一个应用服务器会拾取过期的附加流并将其粘贴到自身。</p><p id="ea1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">带有可执行业务代码的 jar 存储在数据库中，并在启动时加载到应用服务器。这意味着 anz 模块可以由业务系统管理员轻松更新，而无需访问低级系统控制台。更重要的是，通过替换数据库中的 jar 文件并一个接一个地重启应用服务器，我们可以在不中断用户服务的情况下平稳地更新整个应用程序的功能。</p><p id="c5e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理文档的状态机执行业务操作，并通过向位于内部安全网络域中的另一个活动 MQ 实例发送事件来将文档从一种状态转换到另一种状态(是的，这是第三个可选配置参数)。通过观察一些队列的长度，可以很容易地监控一些业务流程的相应阶段的性能。如果我们需要更高的性能，我们可以简单地添加根本不与网络连接的应用服务器。</p><p id="f2a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们设计了三种类型的服务器来执行三种主要类型的操作(生成 UI、处理 UI 事件、处理文档)，它们可以彼此独立地扩展。</p><p id="6878" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正确组织与数据库的交互在实现高性能和可伸缩性方面起着非常重要的作用。不幸的是，经常看到 java 开发人员将关系数据库视为一个被 JPA 隐藏起来的黑匣子，不去分析内部真正发生了什么，或者只将它分配给管理员。以下关键措施极大地简化了开发人员的工作:</p><p id="fa18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 来自任务调度程序的完全拒绝，任务调度程序定期轮询数据库中准备好由任何业务操作处理的文档。负责文档处理的状态机是完全被动的</p><p id="2063" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 当填写文件时，数据通常是从当前词典中复制的，而不是使用参考。从通过数字签名进行数据完整性控制的角度来看，这一点至关重要，但它也最大限度地减少了请求查询中的连接数量。最小数量的对应外键允许加速新数据的插入。</p><p id="feed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 拒绝将继承适用于文件的执行。每个文档都存储在自己的一组表中。因此，我们消除了高度并发的热表和额外的连接操作。</p><p id="ef9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 以一种为使用而优化的格式(CQRS 模式)缓存常用词典的内容。这尤其与有效访问权相关，在计算时考虑到组织和管理相关结构的等级。</p><p id="36cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 为大多数用户提供有限的过滤和排序选项。整理它们生成的 SQL 片段，以确保有限的一组可能的查询计划。</p><p id="26c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 在服务器端和数据库端对文档集执行用户查询时，严格执行超时</p><p id="336b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o 定期测试系统性能，测试的基础是接近实际情况的数据集和不同用户组同时访问的场景。这是检查查询计划的最优性、索引的使用等的唯一方法。接近空数据库，开发者发明的完全脱离真实用户需求的随机数据和抽象访问场景，原则上不提供这样的机会。</p><p id="3872" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个有趣且基本的特征是完全没有业务相关结构的 DTO 对象。应用程序和 WEB 服务器之间的交换基于一组最小的数据类型，这些数据类型描述了诸如“用户点击了按钮”这样的简单事件。必要的附带数据(例如，某组输入字段的内容)作为映射结构传输。因此，应用程序消除了 DTO 对象封送/解封形式的大量负载。这也从整体上大大减少了类的数量和 GC 的负载。</p><h1 id="35db" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开发过程的可伸缩性</h1><p id="14d9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">主要的困难挑战之一是开发过程的高可伸缩性。这与几种情况有关:</p><p id="78a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">俄罗斯的银行政策相当灵活，并且由于积极的立法过程而经常变化。通常新的需求必须被实现并快速交付给客户。因此，必须在有限的时间内同时开发/更改大量文档。</p><p id="0edf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论是在系统领域还是业务领域，都缺乏足够合格的开发人员，而且他们都同意将自己的生命奉献给这个应用程序。顺便说一下，公司所有产品迁移到新的统一平台的目标之一是雇佣几十名以前只处理 Visual Basic 和 Delphi 的遗留员工。</p><p id="86a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于 CORREQTS 的产品不“按原样”交付，而是在每个银行的集成过程中进行深度定制。根据每个特定银行的要求，每次大约有 5–10%的功能发生变化。它不仅涉及屏幕表单，还涉及文档的模式和生命周期的附加操作。</p><p id="9aee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，该公司要处理几个密切相关的项目的大量非常不稳定的源代码，这些代码由许多技术水平不高的开发人员不断更改。每个错误或延迟的成本都足够高。开发的可伸缩性是通过以下方法的一致应用实现的:</p><p id="7f84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有业务代码的开发都基于不同类型的元数据，包含声明性描述符和可执行代码片段。元数据由基于 Groovy 的 DSL 描述。因此，事实上元数据是在加载和预处理过程中以编程方式创建的，因此可以被另一个“定制”元数据或元数据相关代码更改。</p><p id="101a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有源代码分为以下几个部分，由不同类型的专家开发:</p><p id="eaf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">系统核心(或平台)</strong> —系统最稳定的部分。它包括 WEB 和应用服务器的通用代码。这样的代码根本不涉及任何业务领域。它是由 5-6 个非常熟练的系统架构师组成的小组开发的。这一部分非常紧凑——大约 2500 个 java 类(在这里和更远的地方，有大约六年开发后的统计数据),作为一个 monolith maven 项目实现，有大约 30 个顶级模块。由于它的规模小，我们没有任何合作和开发的可伸缩性的问题。系统的这一部分非常稳定，大约每年发布 4-5 次。与其他开发者的互动只能以书面形式进行:通过文档(大约 800 页)和 Confluence。</p><p id="0c36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">业务核心(或产品核心</strong> ) —特定于业务领域的基本概念的实现(在本例中为银行业)。在这一阶段，引入了账户、余额和限额等概念。此外，一些复杂的功能，如分层预算引擎，也在这一层实现。这个级别大约大两倍—大约 5000 个类。它与下一部分一起实现，致力于文档，作为一个整体的 maven 项目，包含大约 50 个顶级模块。这个级别主要是由大约 3-4 个高业务技能的开发人员和架构师开发的。</p><p id="d251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">产品文档</strong> —所有文档的实现，提供所有客户可见的系统特性。它可以是技术文档(例如，申请新证书)或财务文档(银行转账指令)。文档的实现通常不是很专业，而是对系统和业务领域知之甚少的廉价开发人员。在这个级别的组织中，我们可以看到大约 3000 个类和 10-15 个开发人员。由于在这一层有相当大的功能不稳定性，通常在这一层广泛应用代码设计的湿(每次都写)原则，而不是传统的干(不要重复自己)原则。通常一组开发人员主要处理一组相关的文档，由于是湿式组织，他们之间冲突的风险是最小的。理论上，很有可能将单独的文档或文档组视为微服务。</p><p id="d027" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">o <strong class="jx io">定制</strong> —在特定银行实施产品的独立项目。每个这样的项目都有自己独特的资源库，一个独立的 maven 项目，大约有 50-200 个类和杰出的开发团队。主要的变更涉及特定的文档，但有时在相当深度的定制的情况下(例如，在其他国家的实施过程中)，产品核心功能也可能改变。这些团队通常很小(2-3 个开发人员)，彼此独立，也独立于产品团队。这是通过以下事实实现的:任何修改都可以在不改变基本产品代码的情况下进行。</p><p id="7a11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，一组平台架构师做出了巨大的努力来简化业务开发人员的日常工作，以最小化错误的概率并加速其纠正。这不仅仅是一个开发人员舒适度的问题，而是对正在开发的系统的一个关键约束。代码越新(作为开发某些功能的基础)，结果和已经更改的代码之间发生冲突的可能性就越低。</p><p id="d47f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最重要和最有效的措施是:</p><p id="6aeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员无需打包和部署 war 档案即可启动应用程序。取而代之的是，不可变的特殊类加载器(在业务开发层面)和联合应用程序和 WEB 服务器直接从 maven 项目的/target 文件夹中收集类和资源。一种特殊的描述符，允许复制特定银行交货的一组特征和文件。</p><p id="6885" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同一个“仅用于开发”的类加载器允许重新执行基于 Groovy DSL 的元数据描述符，并重新加载修改过的类。这导致极少数情况下需要重启整个服务器。相反，开发人员可以在保存相应的 groovy 文件后立即观察到几乎任何修复的结果。</p><p id="d5de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于 UI 处理的命令序列与存储在 WEB 服务器上的用户视图的状态模型相结合，允许实现对 UI 组织模型的巧妙简化。例如，业务开发人员可以用老式的桌面风格实现代码。例如，在一个完整的方法中:准备一些数据，打开表单，让用户填充它，接收结果并继续执行该方法。从其他平台迁移过来的开发人员尤其需要这样的机会。此外，它使 UI 的实现更加透明和易于理解。</p><p id="94a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于没有 DTO，开发人员只处理一个基于 JPA 实体的数据模型。没有任何神奇的数据转换器和手动实现的转换代码，可以将数据从一种形式转换为另一种形式。这使得开发更容易，并大大降低了结构不一致的风险。</p><p id="25d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于所有的 UI 表单和数据表都是从元数据描述中构建的，因此可以轻松地实现自动通用集成测试，这些测试在构建过程中执行，并验证 UI / JPA 实体/数据库表之间的数据结构的一致性、所有组合用户过滤器/排序的可执行性、在访问数据库期间缺少完全扫描(当然有很多限制)等等。</p><p id="675a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WEB 和 APP 之间基于命令的流量允许实现基于 DSL 的系统级 UI 测试，该测试对业务活动进行操作，例如“填写字段并按下按钮”。这种测试可以应用于功能和性能测试，并且必须使用真正的互联网浏览器。</p><h1 id="cb9b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">未来的</h1><p id="cdc6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这一计划和组织架构在过去 10 年中已经存在。据我所知，至少实施了 3 个产品和大约 50 个定制，该公司不打算改变其开发方法。考虑到只有一个创始架构师在大约五年后还留在公司，有必要承认架构是成功的、可扩展的(从所有意义上来说)、有弹性的和万无一失的。</p><p id="fc84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以我的拙见，作为系统的思想家之一，成功的原因如下:</p><p id="1052" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对整体架构的优势和劣势进行彻底的初步分析。</p><p id="1e00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不同性质和稳定性的代码模块在不同开发人员能力组之间的仔细分配。</p><p id="1ddd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所需功能扩展点的智能初步识别。</p><p id="c845" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对开发人员每天所花时间的彻底分析。优先考虑技术解决方案，这些解决方案在架构纯度和单节点性能方面可能不是最佳的，但可以被开发人员理解，并且能够最大限度地减少暂停和错误计数。</p><p id="169d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还应注意的是，从划分为独立的微服务到系统整体架构只有短短的一步之遥。这可以简单地通过将应用服务器分成 UI-APP 和 DOC-APP 服务器来实现，它们相应地面向处理 UI 事件和文档生命周期操作。另外，需要实现将不同组的文档加载到不同组的应用服务器的类路径中。看起来至少对初学者来说这就足够了。</p><h1 id="270a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="98b4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">微服务不是一种开始的方法。这是一种相当困难、昂贵和痛苦的方式来解决仍然需要增长的问题。大多数项目，尤其是内部的和企业部门内部的项目，从来没有真正解决这些问题。</p><p id="928d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们应该清楚地认识到，当我们应用微服务时，我们只是用显著的额外努力和资源来换取扩展的可能性(开发和运行时)。如果缩放不是真正需要的，或者可以通过其他方式实现，那么努力和资源就可能仅仅为了时尚而浪费。</p><p id="d59b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">过渡到微服务架构意味着在组织结构和开发过程中实施不可避免且经常是痛苦的变化的必要性。否则，我们会得到某种“分布式整体”。一般来说，微服务架构的主题与组织应用程序开发过程和操作/治理本身一样关注技术细节。</p><p id="4dc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多试图借助微服务解决的问题不是由单一应用程序的细节引起的，而是由 rush 架构和整个开发过程引起的。向现代先进方法的过渡不会解决这些问题，只会增加复杂性。</p><h1 id="548c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">禁忌症</h1><p id="74fb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">拥有少量代码的初创公司，对代码的需求正在快速发展。此外，如果我们需要尽快进入市场的工作(即使不是最佳的)产品(所谓的 MVP 最小可行产品)。</p><p id="5687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具有平均并发用户数和可预测工作负载的常见企业应用程序。</p><p id="c9ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">项目刚开始时，系统的一切都不清楚，很难将整个系统正确划分为独立的服务。设计微服务始终是一门妥协的艺术，实现这一点需要经验和大量知识。</p><p id="07fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一家公司不同意在自动化和专门的 DevOps 专家方面进行大量投资，那么处理微服务就毫无意义。同样，如果公司没有准备好从根本上改变组织的发展结构。</p><p id="1ae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个没有开发和维护分布式系统的实际经验的开发团队。最好从对猫的训练开始(让动物保护主义者见谅)。</p><p id="c889" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完全“扔”给客户用于未来维护的产品。当开发人员根本不(没有机会)参与它的操作或者只是很少参与时。</p><p id="72fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同时对数据完整性和可用性有严格的要求。</p><p id="2fcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发过程的瀑布式组织。其中一个主要优势是消除了连续交货的可能性。</p><h1 id="a31c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">指示</h1><p id="606e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">作为公司业务基础的应用程序，由开发人员自己动态开发和利用。</p><p id="cd96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常大的代码库和大量的开发人员。</p><p id="4d1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">各种各样的组件:生命周期的差异、所需的资源/硬件/平台和软件/网络环境、不同的 SLA/SLO 等等</p><p id="2f16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">持续应用交付的苛刻要求。</p><p id="13b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要摆脱过时的架构/依赖性或巨大的技术债务。然而，如果你的 monolith 是一大堆 sh*t，那么你就很难做出基于 sweet candy 的微服务架构。但至少你可以试着一块一块的挑，清理干净。或者至少确保这一块不会在整个应用程序中到处都是气味。</p><p id="bd4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对系统的弹性、可伸缩性和容错性有非常苛刻的要求。处理来自数百万客户的并行请求</p><p id="71df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">海量数据的分布式处理</p><p id="4ef4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于独立数据源和服务的客户端混搭应用程序</p><h1 id="759c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最优策略</h1><p id="f2a0" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">从一块巨石开始，记住，如果你非常幸运和成功，有一天你将不得不把它劈开。不允许在设计开发过程中出现任何明显的泥巴。一般来说，一个组织良好的整体总是离足够容易地分离成单独的服务只有一步之遥。</p><p id="258f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着功能数量的增加，根据专业技能和代码稳定性，将应用程序和所有开发人员分成几个团队/模块。记住在模块之间的边界实现不透明和知识收集策略。</p><p id="4082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着负载的增加，转到由负载平衡器或入站消息队列连接的多个整体实例的部署。如果处理的数据量开始急剧增加，转而使用智能缓存和命令-查询责任分离(CQRS)。</p><p id="cee9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，只有当功能的数量和开发人员的数量变得难以管理时，在彻底分析问题后，才可能开始将 monolith 的最热部分逐步提取到单独的微服务中。</p><p id="3637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我想对我的雇主表示感谢，在过去的十年里，他们为我提供了关于这个话题的丰富材料。还有我的朋友阿列克谢·克罗托夫(<a class="ae lx" href="https://www.linkedin.com/in/alex-k-5479a5/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/alex-k-5479a5/</a>)和罗迪斯拉夫·摩尔多瓦(<a class="ae lx" href="https://www.linkedin.com/in/rodislav/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/rodislav/</a>)，他们在这篇文章的编辑过程中给了我很多帮助。</p></div></div>    
</body>
</html>