# Python 中的 Generator 是什么，它是如何工作的？

> 原文：<https://blog.devgenius.io/what-is-generator-in-python-and-how-does-it-work-e6e0588785c3?source=collection_archive---------1----------------------->

![](img/545e5db27afbb2774deededde6a78bbb.png)

一个**生成器**是一个公正的函数，**返回一个可迭代的对象，我们可以迭代这个对象(一次一个值)**。此外，生成器函数与常规函数有一个主要区别。它有一个`yield`语句，而不是常规函数中的`return`语句。

要用 Python 构建迭代器，你需要做很多工作。你必须用`__iter__`和`__next__`魔法方法实现一个类，跟踪内部状态并在没有值返回时抛出`StopIteration`。

生成器是创建迭代器的一种非常简单的方法，因为生成器会自动完成所有这些步骤。

## **内容计划:**

1.  [创建生成器](#dc2a)
2.  [发电机功能和常规功能的区别](#c263)
3.  [带回路的发电机](#37c2)
4.  [生成器表达式](#d92b)
5.  [使用生成器](#dbf5)
    5.1 [易于实现](#069f)
    5.2 [内存高效](#521a)
    5.3 [表示无限流](#807f)
    5.4 [流水线化生成器](#807f)
6.  [结论](#61b2)

![](img/983644260e97e3770520454c31b0e314.png)

# 1.创建生成器

**一个函数如果包含至少一个** `**yield**` **语句**(可能包含几个`yield`甚至`return`)就成为生成器函数。为了清楚起见，`yield`和`return`从一个函数返回一些值。所以，你只需要用至少一个`yield`来构建函数

主要区别在于`return`语句完全终止一个函数，而`yield`语句暂停一个函数并保存其所有状态，然后在后续调用中继续。

# 2.生成函数和正则函数的区别

让我们来看看生成器函数和常规函数之间的所有差异:

*   生成器函数包括一个或多个`yield`语句。
*   它返回一个迭代器对象，但不立即执行。
*   像`__iter__()`和`__next__()`这样的方法是自动实现的。这意味着我们可以使用`next()`遍历条目。
*   一旦函数让步，它就被暂停，控制权移交给调用者。
*   局部变量及其状态在连续调用之间被记忆。
*   当一个生成器函数完成时，`StopIteration`会在进一步调用时自动产生。

以下示例说明了所有这些要点:

**输出:**

```
1 -- This is first
2 -- This is second
3 -- This is third and the last
Traceback (most recent call last):
...
StopIteration
```

`simple_generator()`是一个有几个`yield`语句的生成器函数。

值得注意的一件有趣的事情是，变量`num`的值在每次调用之间被记忆。

与常规函数不同，当函数屈服时，局部变量不会被破坏。此外，一个生成器对象只能迭代一次。

要重新开始这个过程，您必须使用类似`gen = simple_generator()`的东西创建另一个生成器对象。

最后要注意的一点是，你可以直接使用带有`for`循环的发生器。

这是因为一个`for`循环接受一个迭代器，并使用一个`next()`函数对其进行迭代。当`StopIteration`上升时自动结束。

# 3.带回路的发电机

上面的例子毫无意义，我展示它只是为了让你理解发电机的工作过程。

**通常，发生器功能通过具有合适终止条件的回路实现**。

那么，让我们来看看下面的例子:

**输出:**

```
o
l
l
e
h
```

代码使用了一个`range()`函数，通过`for`循环来反转接收到的字符串。

# 4.生成器表达式

使用生成器表达式可以很容易地创建简单的生成器。这有助于轻松制造发电机。

类似于创建 [**匿名函数**](https://towardsdev.com/lambda-function-python-e05171925c98) 的 lambda 函数，生成器表达式创建匿名生成器函数。

生成器表达式的语法类似于 [**列表理解**](/is-list-comprehension-the-most-effective-way-to-solve-any-tasks-python-b6bb3f5391fa) 。但是，方括号被圆括号取代。

列表理解和生成器表达式之间的主要区别在于,**列表理解**产生**整个列表**,而**生成器**表达式一次产生**一个项目**。

他们有一个懒惰的执行(只在需要的时候产生项目)。正因为如此，生成器表达式比等价的列表理解更节省内存。

**输出:**

```
[100, 324, 169, 529]
<generator object <genexpr> at 0x7fafb4473bd0>
```

我们可以从上面看到，生成器表达式没有立即产生所需的结果。相反，它返回一个生成器对象，该对象仅在请求时生成项目。

以下是如何开始从生成器接收项目:

当您运行上面的代码时，您会得到下面的**输出:**

```
100
324
169
529
Traceback (most recent call last):
  ...
StopIteration
```

生成器表达式可以用作函数参数。这样使用时，圆括号可以去掉。

```
sum(x**2 for x in list_numbers)
1122max(x**2 for x in list_numbers)
529
```

![](img/b5685b10fad5d64b66ffd82e6241156e.png)

# 5.发电机的使用

有几个原因可以解释为什么生成器实现起来很强大。

# 5.1.易于实施

**与对应的迭代器类**相比，生成器可以清晰简洁地实现。下面是一个使用迭代器类实现 2 次方序列的例子。

上面的代码又长又混乱。现在，让我们使用一个生成器函数做同样的事情。

由于生成器会自动跟踪细节，所以实现变得简洁、干净得多。

# 5.2.内存高效

返回序列的常规函数**将在返回结果之前在内存**中创建整个序列。如果序列中的项目数量非常大，这就太多了。

这种序列**的**生成器**实现是内存友好的，并且是优选的**，因为它一次只产生一个项目。

# 5.3.表示无限流

**生成器是表现无限数据流的优秀媒介。无限流不能存储在内存中，由于生成器一次只能产生一个项目，所以它们可以表示无限的数据流。**

下面的生成器函数可以生成(理论上)所有的偶数。

# 5.4.流水线发电机

多个**发生器可用于流水线化一系列操作**。有一个例子可以很好地说明这一点。

假设您有一个生成斐波纳契数列中的数字的生成器。我们还有另一个平方数的生成器。

如果我们想找出斐波纳契数列中数字的平方和，我们可以通过以下方式将生成器函数的输出流水线化在一起。

**输出**

```
1120149658760
```

这种流水线是高效的，易于阅读的，这是一个很好的方法。

![](img/cadcac86b773887ef1d63b3a997e5013.png)

# 6.结论

让我们结束这一切。现在你知道了:

*   如何用 Python 编写和使用生成器
*   正则函数和生成函数的区别
*   列表和生成器的区别
*   发电机的好处
*   在这种情况下，可以使用发电机

*P.S .如果你喜欢这篇文章，* [*关注我*](https://medium.com/@vlad.bashtannyk) ，*点几下“拍手”* *留下反馈。祝你好运，高效编程！谢谢大家！*

[*LinkedIn*](https://www.linkedin.com/in/vladyslav-bashtannyk/)*——*[*Twitter*](https://twitter.com/VladyslavBasht2)