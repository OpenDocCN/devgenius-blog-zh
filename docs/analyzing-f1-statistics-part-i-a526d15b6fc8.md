# 分析 F1 统计数据-第一部分

> 原文：<https://blog.devgenius.io/analyzing-f1-statistics-part-i-a526d15b6fc8?source=collection_archive---------15----------------------->

在介绍了 Ergast 数据集的用法之后，是时候进行分析了！

![](img/1288827937fcb375c928d776336faaa8.png)

作者照片

在[的上一篇文章](https://medium.com/p/5112279d743a)中，`F1Stats`类是作为一种分析来自 [Ergast](http://ergast.com/mrd/) 的 F1 历史数据的便捷方式而引入的。所以现在是时候开始使用它了！

可能性几乎是无穷无尽的。下面的列表显示了一些可能的分析，它们是 github 上的 [Jupyter 笔记本的一部分。这个笔记本实现了`F1Stats`类和这些统计数据。本文描述了粗体打印的统计数据，其他的将在下一篇文章中介绍。读者可以发挥想象力，想出更有趣的分析。](https://github.com/lmeulen/F1Analysis/blob/master/Eregast-analysis.ipynb)

*   **历史** - **车手/建造师的最多胜利**
    -最多连续胜利
    -冠军赢得的比赛数量，绝对和相对
    -拥有最多 DNF
    **的冠军-从未成为冠军的车手的最多胜利**
    -最多杆位和杆位+胜利
    **-每个赛季车手的平均年龄**
    -最受支配的赛季

*   **赛季**
    - **WDC 一轮后的积分排名**-
    -**将当前积分与上一赛季积分进行比较**
    -每位车手的平均完赛位置
    - **两位车手的积分统计**
    -最近 6 场比赛的积分
*   **比赛**
    - **比赛中获得或失去的名次**
    -比较两位车手的圈速
    -比赛中的圈速图

## 用助手方法扩展基类

在深入研究这些数字之前，是时候完成 F1Stats 类并完成所有辅助方法了:

所以增加了以下方法:

*   get_winners() —通过过滤位置 equls 1 上的比赛结果返回所有大奖赛获胜者。
*   get_quali_results() —返回所有资格的结果，遵循与上一篇文章中的 get_race_results()相同的逻辑
*   get_pole_sitters() —通过过滤位置等于 1 的限定结果返回极点位置。
*   get_dnfs() —返回所有没有完成比赛的车手。在这种情况下，文本字段“positionText”不包含数字。
*   get _ WCC _ standing()-返回车队世界锦标赛中每场比赛后的排名
*   get_wdc_champions() —返回所有车手世界冠军。首先找到所有的决赛回合，然后将这些决赛回合排列在排名中等于“1”的位置。还计算该赛季赢得的比赛数。
*   get _ laps _ for _ race()-获取特定比赛的所有圈数。一场比赛是由年份和回合数或赛事名称来标识的。

## 获胜次数最多的车手

哪些车手在他们的职业生涯中赢得了最多的大奖赛？

获得职业生涯冠军最多的车手是刘易斯·汉密尔顿。前 10 名中，4 名车手依然活跃。他们是汉密尔顿、维特尔、阿隆索和韦尔斯塔彭。

![](img/232f08ca6c21990b7d4533a80ead7dc4.png)

获胜次数最多的车手(图片由作者提供)

当我们看制造商时，法拉利是明显的赢家。

![](img/62c08dee644fd06b16d3971bdcec7cb0.png)

每个构造者最多获奖(图片由作者提供)

## 从未成为世界冠军的获胜次数最多的车手

不是所有的比赛都是世界冠军赢得的。但是谁赢得了必须的比赛却没有成为世界冠军呢？这个有点难以计算:

首先，我们决定所有大奖赛的最后赢家。这等于上一章。下一步是过滤掉世界冠军。`champs`变量包含所有世界冠军车手的`driverID`(第 5 行)。获奖者名单是根据这份名单筛选出来的。如果`driverID`在世界冠军列表中，那么`.isin()`函数返回 True。既然我们想把它们过滤掉，比较的结果就用“`~`”反过来。结果列表与驱动程序信息合并，以添加驱动程序的名称(和其他信息)。

![](img/ad4a4be50067834c8d86bfc749218da0.png)

赢得最多但没有冠军的车手(图片由作者提供)

## 历年平均司机年龄

一级方程式车手越来越年轻。最年轻的车手是马克斯维尔斯塔彭(17y166d)和兰斯·斯特罗尔(18y148d)。近年来，规则发生了变化，参加 f 1 比赛的最低年龄要求是 18 岁。但是过去的司机年龄有多大呢？让我们找出答案。

数据帧`races`包含每个事件的日期，数据帧`drivers`包含每个驾驶员的生日。数据帧`results`将比赛与车手联系起来，因此通过合并车手和比赛的结果，我们可以为每场比赛中的每位车手获得一行，其中包含车手的出生日期和比赛日期。年龄是这两者之差，但用纳秒表示，需要换算成年。

当我们将列`age`添加到数据框中时，它按年分组，并计算所有年龄的平均值。得到的数据被绘制成图表。

![](img/986644dce19daa2a28f666729910aa62.png)

每年驾驶员的平均年龄(图片由作者提供)

该图显示，与当前时代相比，早年的司机要老得多。2014 年是车手最年轻的一年(27.3 岁)，但自那以后，年龄开始缓慢增长。随着一些老司机的退休，这个数字会再次下降。

查看每十年的平均年龄(对`groupby`函数的巧妙修改)

```
df.groupby((df['year']//10)*10).mean()[['age']].round(1)
```

我们得到:

![](img/df18b8a2681082223ba40dd5cb6065ad.png)

每十年平均司机年龄(图片由作者提供)

平均年龄下降了近 8 岁，在过去的 20 年里似乎趋于稳定。由于最低年龄，它很可能保持在这个水平左右。

## 当前领域的经验如何？

但是现在的领域经验如何？如果我们将经验转化为比赛次数，这可以从数据中确定。首先，我们必须确定当前赛季的车手(第 2 行)。下一步(第 4 行)是在它们的`driverID`上过滤所有结果的列表。

在第 5 行中，一个`groupby`用于计算结果中每个驱动程序出现的次数。这将生成一个包含车手 id、车手姓名和参赛次数的表格。臭名昭著的`horizontal_barplot`用来可视化结果。注意，这个方法被移到了`F1Stats`类中。

![](img/c0e1288c936035f8740687d534294b10.png)

当前 F1 领域的经验(图片由作者提供)

从这个角度来看，所有参加过 F1 比赛的车手的平均比赛次数是 30 次。在目前的领域中，只有周冠宇的比赛较少。赛季包含比过去更多的比赛，但车手们比以往任何时候都参加更多的比赛。

## 赛季期间站立的 WDC

是时候抛开历史的洞见，看看现在的季节了。首先，让我们看看车手积分榜在赛季中的变化。

由于引入了助手函数，这变得非常容易。我们获得一个季度的 wdc 结果。该数据帧包含车手、轮次以及每位车手在每轮比赛后的冠军积分。这已经是我们进行概述所需的所有信息。

![](img/71247652b7020b654d1243ccb9652068.png)

冠军排名(图片由作者提供)

图表显示了每位车手在锦标赛中的位置。它没有给出驾驶员之间的点差异的洞察力。通过将第 4 行中的“`position’` 替换为“`points`”，将绘制每位驾驶员的分数:

![](img/9cbd2d5f65a39d8709fe7511c725957d.png)

赛季中的冠军积分(图片由作者提供)

它弄乱了图表的底部，但让我们看到了莱克勒克和佩雷斯之间以及拉塞尔和赛恩斯之间的激烈战斗，尽管汉密尔顿正在逼近他们。

## 将当前积分与上一赛季进行比较

今年，F1 的排名发生了很多变化。法拉利似乎又回到了巅峰，梅赛德斯已经有点落后了。但是像迈凯轮和阿尔法·托里这样的车队似乎表现不佳。

正如在这样的文章中所预期的，让我们深入研究这些数字。我们想知道与去年相比，一支球队的表现有多好。与去年同期相比，我们最好的指标是车队在今年 13 轮比赛后的积分。

首先，确定当前的积分(第 3-5 行),从而选择该轮作为最后一轮比赛(此时是匈牙利大奖赛第 13 轮)。接下来，确定赛季中同一时刻(比赛回合)的点数(第 7-9 行)。第 3–5 行和第 7–9 行之间的唯一区别是年份。

合并两个年份的结果数据(第 11 行)，并计算两个年份之间的点数差异(第 12 行)。第 13-14 行确定颜色，绿色为正，红色为负。情节最终出现在第 16-27 行，包括带有标签的布局等。

![](img/b62b8e0fb77194d178f4c018f36709ef.png)

与去年相比的积分差异(图片由作者提供)

与去年相比，红牛和法拉利都做得更好。令人惊讶的是，梅赛德斯并不是积分受挫最大的车队。这项荣誉属于迈凯轮阿尔法牛。梅赛德斯和红牛之间的差距比去年大了 140 分，但主要是因为红牛的表现更好。法拉利几乎脱离了天平，但凭借去年糟糕的表现，它并没有把他们带到图表的顶端。

## 两个司机面对面

一种常用的比较队友的可视化方式是面对面。两位车手在排位赛和正赛数据上都进行了一对一的比较。使用的统计数据包括:在队友前面完成的比赛，在队友前面通过的比赛，得分，本赛季登上领奖台的次数以及比赛胜利的次数。如果两位车手不争夺领奖台的位置，最好的完成位置和最好的资格位置通常被使用。

![](img/cdef9faa4d6a8a1b4cb9bcafef522ea6.png)

驱动程序比较(图片由作者提供)

因此，这需要一些代码来计算统计数据:

第一步是定义年份、定义驱动因素(通过缩写)并检索`driverId`(第 1-7 行)。第 9–17 行计算比赛结果统计。该循环遍历所选赛季中的所有比赛。对于每个驾驶员，终点位置是确定的。如果驾驶员 1 在驾驶员 2 之前完成，则他的计数器增加，反之亦然。如果他们的终点位置相同，他们都没有完成比赛，因此没有计数器增加。

计数器数组有第三个字段，预先填充了值 10。该值用于绘图，将在那里解释。

第 19 行到第 20 行执行相同的逻辑，但是用于鉴定结果。第 29 到 32 行计算目前为止的得分。首先确定本赛季的最后一轮比赛结果，然后存储这一轮之后两位车手的积分。

对于获胜者，获胜者的数据帧在车手和终点位置“1”进行过滤。得到的数据帧的长度是车手赢得比赛的次数。当过滤条件变为等于或小于 3 时，计算领奖台结束次数。

现在我们有了所有的单个计数，就可以创建比较两个驱动因素的图表了

比较图由第一个驾驶员左侧的条和第二个驾驶员右侧的条构成。这是通过将第一个驱动因素的值标绘为负值，将第二个驱动因素的值标绘为正值来实现的。通过绘制具有相同 y 值的条形，它们显示在相同的高度上。

通过将值除以行上的最大值，将每行缩放到最大值 1。这确保了所有的行都是可见的，并且不会被例如所得分的点推出视线之外。这就是前面提到的数字 10 发挥作用的地方。它确保 10 以下数字不会相对于其最大值进行缩放，而是缩放到值 10。因此，如果两位车手都赢得了一场比赛，绘制的条形是最大宽度的 1/10。它使图表更容易直观地使用。

首先，准备带有 y 值、x 值、标签和颜色的数组。这些颜色代表驱动程序 1 的颜色，接着是驱动程序 2，然后是驱动程序 1。等等。numpy `tile`函数用于指定两种颜色的重复。然后在第 16 行绘制矩形。plot 命令将创建的数组作为(x，y)值和要绘制的颜色的输入。

第 21–24 行通过设置 x 轴宽度，在“0”值处绘制一条垂直线，从而划分两个驱动因素，并移除图形的边界框，从而对图形进行布局(22–25)。第 26 行删除了 x 轴上的刻度，因为它们不代表实际值。

## 比赛中获得或失去的名次

在比赛层面，一个有趣的综述是在比赛中获得和失去的位置。

首先，我们全年过滤结果。按年份过滤是在`get_race_results()`方法中实现的，按轮次过滤需要单独完成(尽管它可以添加到 get_results 方法中)。在这一步中，数据帧的列也被减少到所需的子集(第 4 行)。

产生的数据帧已经包含开始和结束位置，因此通过计算这两个位置之间的差，很容易计算获得或失去的位置数。

因为我们使用的是 Jupyter 笔记本，所以可以给 dataframe 添加显示样式(第 10 行)。在这种情况下，我们向列`change`添加一个显示样式(`color_red_or_green`)，它根据正值或负值改变背景颜色。这导致:

![](img/c23005f2d7e9cbeeb8e76b795722afbe.png)

获得和失去的地方(图片由作者提供)

不需要额外的排序，因为`get_race_result`方法已经按位置排序。

## 结论

在前一篇文章中准备好数据之后，开始分析数据和收集新的见解就相对简单了。这个笔记本描述了一些例子，而 [Jupyter 笔记本](https://github.com/lmeulen/F1Analysis/blob/master/Eregast-analysis.ipynb)甚至更多。但是极限是由你自己的想象决定的！

正如在上一篇文章中已经提到的，花费在数据准备上的时间是值得的。它减少了本文的工作量。互联网上充满了数据，只要认真努力，可用性还是不错的。

# 最后的话

我希望你喜欢这篇文章。要获得更多灵感，请查看我的其他文章:

*   [F1 分析和 Python 入门](https://medium.com/p/5112279d743a)
*   [F1 匈牙利:一些观察](https://leo-vander-meulen.medium.com/f1-hungary-2022-some-observations-7d1e80d3831)
*   [使用 Python 和“scikit-learn”进行燃油价格预测](https://betterprogramming.pub/how-to-predict-fuel-prices-609f7ec417fb)
*   [太阳能电池板发电分析](https://towardsdatascience.com/solar-panel-power-generation-analysis-7011cc078900)
*   [对 CSV 文件中的列执行功能](https://towardsdev.com/perform-a-function-on-columns-in-a-csv-file-a889ef02ca03)
*   [根据活动跟踪器的日志创建热图](https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657)
*   [使用 Python 的并行 web 请求](https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989)

如果你喜欢这个故事，请点击关注按钮！

*免责声明:本文包含的观点和看法仅归作者所有。*