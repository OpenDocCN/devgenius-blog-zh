<html>
<head>
<title>Running Superset with OpenIdConnect (Keycloak) in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Docker 中使用 OpenIdConnect (Keycloak)运行超集</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/running-superset-with-openidconnect-keycloak-in-docker-9ef1558d1ea3?source=collection_archive---------0-----------------------#2022-12-23">https://blog.devgenius.io/running-superset-with-openidconnect-keycloak-in-docker-9ef1558d1ea3?source=collection_archive---------0-----------------------#2022-12-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8a54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">超集是一个伟大的现代数据探索和可视化平台。我们这里要讲的是认证！</p><p id="d9e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据超集文档:</p><blockquote class="ki kj kk"><p id="333f" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">超集中的安全性由 Flask AppBuilder (FAB)处理，这是一个构建在 Flask 之上的应用程序开发框架。FAB 提供认证、用户管理、权限和角色。</p></blockquote><p id="7f84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，如 FAB 文档中所述，支持五种身份验证类型:</p><ul class=""><li id="c88d" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">数据库ˌ资料库</li><li id="2145" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">开放 Id</li><li id="5aa6" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">轻量级目录访问协议</li><li id="4f6b" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">远程用户</li><li id="e857" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">OAuth(需要 authib)</li></ul><p id="376b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，人们很容易感到困惑，认为 OpenId Connect 可以开箱即用，因为 OpenId 是受支持的，但 sadl 并非如此。</p><p id="498e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个简单的解决方法是使用 Oauth，因为 OpenId Connect 扩展了 OAuth，通常可以使用 OAuth 进行连接。</p><p id="b97c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在我们的例子中，我们希望完全使用 OpenId Connect，所以我们的手会有点乱。</p><p id="3a19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用 Keycloak 作为我们的 OIDC 提供商，因为它是开源的。然而，OIDC 作为一个标准，这篇文章应该适用于几乎所有的供应商。</p><p id="9951" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了确保您可以在家里测试，我们将在本地机器上使用 Docker 来完全实现它！这使得事情变得更加棘手，因为联网和安全不像公开访问时那么容易。</p><p id="fd82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">这已经通过了 Keycloak v20.0.2 和超集 v2.0.1 的测试。</em></p><h1 id="766f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设置</h1><p id="944e" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了让事情更清楚一些，我们的设置如下所示:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/825cd8755ad8f216edcd50963bf8d276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1IfrFjEV_wPmryNBFL-xA.png"/></div></div></figure><p id="3383" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将有 3 个独立的 docker-compose 文件来使事情变得更好和独立:</p><ul class=""><li id="48a4" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">小盒子</li><li id="dbcc" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">钥匙锁</li><li id="7af9" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">超集</li></ul><p id="a927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Caddy 是一个很好的反向代理，它甚至可以在您的本地机器上为您处理 SSL 证书。这使得它很容易保护您的服务。</p><p id="6690" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多关于球童的信息可以在 https://caddyserver.com/docs/的<a class="ae ms" href="https://caddyserver.com/docs/" rel="noopener ugc nofollow" target="_blank">找到</a></p><p id="8fa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是我们这里的情况，但是 Caddy 也可以用来反向代理其他服务。这就是为什么把它放在自己的 docker compose 文件中很好。</p><p id="aeb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让我们所有容器之间的交流更好更容易，让我们在应用程序之间创建一个网络。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="3f6e" class="my le in mu b be mz na l nb nc">docker network create caddy-internal</span></pre><p id="1e93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了减轻我们的本地开发者/用户体验，我修改了我的 hosts 文件来为 Keycloak 和 Superset 创建假的 URL。</p><p id="9fc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 windows 中可以在<em class="kl">C:\ Windows \ System32 \ drivers \ etc</em>中找到，在 Linux 或 Mac 上你会在<em class="kl"> /etc/hosts </em>文件夹中找到这个文件。</p><p id="634e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向其中添加以下几行:</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="9c3e" class="my le in mu b be mz na l nb nc">127.0.0.1           keycloak.local<br/>127.0.0.1           superset.local</span></pre><p id="7b15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果需要，将 ip 地址更改为可以访问 docker 实例的地址。</p><h1 id="2948" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">钥匙锁</h1><p id="1aae" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">根据 Keycloak 文档，建议您构建映像以获得优化的体验。很明显，您可以尝试一下，但是出于这个示例的目的，我们将使用已经编译好的 dev 映像。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="cf4c" class="my le in mu b be mz na l nb nc">services:<br/>  app:<br/>    image: quay.io/keycloak/keycloak:latest<br/>    container_name: keycloak<br/>    environment:<br/>      - KEYCLOAK_ADMIN=admin<br/>      - KEYCLOAK_ADMIN_PASSWORD=admin<br/>    restart: always<br/>    ports:<br/>      - 8088:8088<br/>    networks:<br/>      - keycloak<br/>      - caddy-internal<br/>    command: "start-dev --db=postgres --features=token-exchange --proxy=edge --db-url=jdbc:postgresql://db:5432/keycloak --db-username=keycloak --db-password=keycloak --hostname=keycloak.local"<br/><br/>  db:<br/>    image: postgres:12<br/>    restart: always<br/>    environment:<br/>      - POSTGRES_USER=keycloak<br/>      - POSTGRES_PASSWORD=keycloak<br/>      - POSTGRES_DB=keycloak<br/>    networks:<br/>      - keycloak<br/>    volumes:<br/>      - keycloak_db:/var/lib/postgresql/data<br/>volumes:<br/>  keycloak_db:<br/><br/>networks:<br/>  keycloak:<br/>    external: false<br/>  caddy-internal:<br/>    external: true</span></pre><p id="e9cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些重要的事情:</p><ul class=""><li id="623c" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">确保根据您的需要更新— db-url。如果你照原样使用这个 docker compose，它应该就可以了。</li><li id="fa7b" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">相应地更改主机名。同样，如果你在你的本地机器上并且像我一样编辑了主机文件，你应该已经设置好了。</li><li id="2761" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">如你所见，keycloak 应用程序将加入球童内部网络。这将使事情变得简单。</li></ul><p id="a342" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们去旋转吧！</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="8539" class="my le in mu b be mz na l nb nc">docker compose up -d</span></pre><p id="981b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一切顺利，那么您应该能够在 http://localhost:8088 上访问 Keycloak。</p><p id="d461" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl"> Keycloak 本身可以处理端口 8443 上的 https，但是因为我们将使用 Caddy 进行 SSL，所以我们将坚持使用 http 版本。</em></p><h1 id="8003" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">小盒子</h1><p id="ba0d" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了确保一切正常，让我们设置球童！</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="2dcc" class="my le in mu b be mz na l nb nc"># docker-compose.yaml<br/>services:<br/>  caddy:<br/>    image: caddy:latest<br/>    restart: unless-stopped<br/>    networks:<br/>      - caddy-internal<br/>    ports:<br/>      - "443:443"<br/>    volumes:<br/>      - $PWD/Caddyfile:/etc/caddy/Caddyfile<br/>      - caddy_data:/data<br/>      - caddy_config:/config<br/><br/>volumes:<br/>  caddy_data:<br/>  caddy_config:<br/><br/>networks:<br/>  caddy-internal:<br/>    external: true</span></pre><p id="d1a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Caddy 的配置存储在 Caddyfile 中，在我们的例子中，caddy file 位于 docker 编写文件的旁边。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="aff3" class="my le in mu b be mz na l nb nc"># Caddyfile<br/><br/>keycloak.local {<br/>    reverse_proxy keycloak:8080<br/>}<br/><br/>superset.local {<br/>    reverse_proxy superset_app:8088<br/>}</span></pre><p id="c6fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Caddyfile 语法非常简单。在这里，我们只需声明我们的两个域(本地域)并反向代理到所需的服务和端口。因为 Caddy、Keycloak 和 Superset 都共享同一个网络(caddy-internal ),所以可以直接使用容器名。</p><p id="1cf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们启动 Caddy 并检查是否一切正常。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="4dfe" class="my le in mu b be mz na l nb nc">docker compose up -d</span></pre><p id="7258" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在 Keycloak 应该可以在<a class="ae ms" href="https://keycloak.local." rel="noopener ugc nofollow" target="_blank"> https://keycloak.local </a> /上访问了</p><p id="d335" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，现在我们可以使用 HTTPS，而不仅仅是 HTTP，因为 Caddy 处理我们的证书。</p><p id="a95b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要检查我们的 Keycloak 是否配置正确，请尝试使用用户名 admin 和密码 admin 登录管理界面。</p><p id="c465" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你停留在加载页面上，检查 Keycloak 中设置的主机名变量是否正确。否则 Keycloak 可能无法加载一些资源。</p><p id="fc56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于 Keycloak 配置，我不再赘述。有大量的资源，包括 Keycloak 文档。但是，在继续之前，请确保您已经配置了以下内容:</p><ul class=""><li id="9e25" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">至少一个客户端(OIDC)</li><li id="10c4" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">至少有一个注册了电子邮件、名字和姓氏以及密码的用户</li><li id="9dfd" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">确保在实际设置中，要求 SSL 选项设置为“外部请求”</li></ul><p id="e0d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一切都准备好了，你就可以继续了！</p><h1 id="6d74" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">超集</h1><p id="7b9f" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">现在到了有趣(也可能是最棘手)的部分！</p><p id="b3c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们必须调整超集，所以我们需要它的源代码。正如它的文档(<a class="ae ms" href="https://superset.apache.org/docs/installation/installing-superset-using-docker-compose/" rel="noopener ugc nofollow" target="_blank">https://superset . Apache . org/docs/installation/installing-superset-using-docker-compose/</a>)中所建议的那样，无论如何，对于 Docker 安装，让我们继续克隆 repo。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="85e4" class="my le in mu b be mz na l nb nc">git clone https://github.com/apache/superset.git</span></pre><p id="a206" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在启动超集之前，我们要稍微调整一下它的配置。下面是我编辑的 docker-compose-non-dev.yml 文件。</p><p id="3b46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">因为我们不需要改变前端的任何东西，我们可以使用非开发文件来减轻负担。</em></p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="80b1" class="my le in mu b be mz na l nb nc"># docker-compose-non-dev.yml<br/>#<br/># Licensed to the Apache Software Foundation (ASF) under one or more<br/># contributor license agreements.  See the NOTICE file distributed with<br/># this work for additional information regarding copyright ownership.<br/># The ASF licenses this file to You under the Apache License, Version 2.0<br/># (the "License"); you may not use this file except in compliance with<br/># the License.  You may obtain a copy of the License at<br/>#<br/>#    http://www.apache.org/licenses/LICENSE-2.0<br/>#<br/># Unless required by applicable law or agreed to in writing, software<br/># distributed under the License is distributed on an "AS IS" BASIS,<br/># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/># See the License for the specific language governing permissions and<br/># limitations under the License.<br/>#<br/>x-superset-image: &amp;superset-image apache/superset:${TAG:-latest-dev}<br/>x-superset-depends-on: &amp;superset-depends-on<br/>  - db<br/>  - redis<br/>x-superset-volumes:<br/>  &amp;superset-volumes # /app/pythonpath_docker will be appended to the PYTHONPATH in the final container<br/>  - ./docker:/app/docker<br/>  - superset_home:/app/superset_home<br/><br/>version: "3.7"<br/>services:<br/>  redis:<br/>    image: redis:latest<br/>    container_name: superset_cache<br/>    restart: unless-stopped<br/>    volumes:<br/>      - redis:/data<br/>    networks:<br/>      - superset<br/><br/>  db:<br/>    env_file: docker/.env-non-dev<br/>    image: postgres:10<br/>    container_name: superset_db<br/>    restart: unless-stopped<br/>    volumes:<br/>      - db_home:/var/lib/postgresql/data<br/>    networks:<br/>      - superset<br/><br/>  superset:<br/>    env_file: docker/.env-non-dev<br/>    image: *superset-image<br/>    container_name: superset_app<br/>    command: ["/app/docker/docker-bootstrap.sh", "app-gunicorn"]<br/>    user: "root"<br/>    restart: unless-stopped<br/>    ports:<br/>      - 8088:8088<br/>    networks:<br/>      - caddy-internal<br/>      - superset<br/>    depends_on: *superset-depends-on<br/>    volumes: *superset-volumes<br/><br/>  superset-init:<br/>    image: *superset-image<br/>    container_name: superset_init<br/>    command: ["/app/docker/docker-init.sh"]<br/>    env_file: docker/.env-non-dev<br/>    depends_on: *superset-depends-on<br/>    user: "root"<br/>    volumes: *superset-volumes<br/>    networks:<br/>      - superset<br/>    healthcheck:<br/>      disable: true<br/><br/>  superset-worker:<br/>    image: *superset-image<br/>    container_name: superset_worker<br/>    command: ["/app/docker/docker-bootstrap.sh", "worker"]<br/>    env_file: docker/.env-non-dev<br/>    restart: unless-stopped<br/>    depends_on: *superset-depends-on<br/>    user: "root"<br/>    volumes: *superset-volumes<br/>    networks:<br/>      - superset<br/>    healthcheck:<br/>      test:<br/>        [<br/>          "CMD-SHELL",<br/>          "celery inspect ping -A superset.tasks.celery_app:app -d celery@$$HOSTNAME",<br/>        ]<br/><br/>  superset-worker-beat:<br/>    image: *superset-image<br/>    container_name: superset_worker_beat<br/>    command: ["/app/docker/docker-bootstrap.sh", "beat"]<br/>    env_file: docker/.env-non-dev<br/>    restart: unless-stopped<br/>    depends_on: *superset-depends-on<br/>    user: "root"<br/>    volumes: *superset-volumes<br/>    networks:<br/>      - superset<br/>    healthcheck:<br/>      disable: true<br/><br/>volumes:<br/>  superset_home:<br/>    external: false<br/>  db_home:<br/>    external: false<br/>  redis:<br/>    external: false<br/><br/>networks:<br/>  caddy-internal:<br/>    external: true<br/>  superset:<br/>    external: false</span></pre><p id="4295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个文件中，我刚刚更改了以下内容:</p><ul class=""><li id="a939" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">添加了 caddy 内部网络，并为其分配了应用程序容器</li><li id="72f4" class="kp kq in jm b jn ky jr kz jv la jz lb kd lc kh ku kv kw kx bi translated">添加了超集网络，以确保其余的保持一起工作，并为其分配所有容器</li></ul><p id="7601" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们试着启动它！</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="7e2f" class="my le in mu b be mz na l nb nc">docker compose up -d</span></pre><p id="4893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一切顺利，你应该能够访问<a class="ae ms" href="http://localhost:8088" rel="noopener ugc nofollow" target="_blank"> http://localhost:8088 </a>上的超集，也可以访问<a class="ae ms" href="https://superset.local" rel="noopener ugc nofollow" target="_blank"> https://superset.local </a>上的超集，因为 Caddy 已经配置好了。</p><p id="5587" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">如果第二个 url 不起作用，尝试在/docker/python path _ dev/superset _ config . py 文件中添加以下行:</em></p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="924f" class="my le in mu b be mz na l nb nc">ENABLE_PROXY_FIX = True<br/>PROXY_FIX_CONFIG = {"x_for": 1, "x_proto": 1, "x_host": 1, "x_port": 0, "x_prefix": 1}</span></pre><p id="520b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以使用默认的“本地”凭证登录。现在让我们尝试将 Keycloak 和 Superset 连接在一起！</p><p id="7a1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的 Keycloak 实例或者你的超集实例不能正常工作，不要再尝试了！</p><h2 id="95eb" class="nd le in bd lf ne nf dn lj ng nh dp ln jv ni nj lr jz nk nl lv kd nm nn lz no bi translated">将 OIDC 功能添加到超集</h2><p id="097a" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">现在到了有趣的部分！</p><p id="14a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们不要试图重新发明轮子，让我们使用现有的软件包来处理所有 OIDC 的东西。</p><p id="c7c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们将使用 flask-oidc。</p><p id="5a2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了添加我们的自定义代码超集，repo 的根目录下有一个名为“docker”的便利文件夹。在这个文件夹中，我们添加一个名为 requirements-local.txt 的新文件。</p><p id="9aa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该文件应包括以下内容:</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="a85e" class="my le in mu b be mz na l nb nc"># /docker/requirements-local.txt<br/># Custom packages required<br/><br/>flask-oidc==1.3.0<br/>itsdangerous==2.0.1<br/>flask_openid</span></pre><p id="f471" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，当我们启动超集容器时，它会自动为我们获取那些 Python 包！太好了！</p><p id="8e72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经有了所有的包，让我们添加完成所有魔术的代码。</p><p id="6984" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，我们将不得不覆盖两个路由(/登录和/注销)。我们也将不得不存储有关我们的 OIDC 提供商的信息(网址，客户端 id，客户端秘密等)。为此，首先在/docker/pythonpath_dev 目录中添加一个名为 client_secret.json 的新文件。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="1c20" class="my le in mu b be mz na l nb nc">{<br/>  "web": {<br/>    "issuer": "https://keycloak.local/realms/master",<br/>    "auth_uri": "https://keycloak.local/realms/master/protocol/openid-connect/auth",<br/>    "client_id": "myclientid",<br/>    "client_secret": "4H6sra49h4BpV4J1SIGlx0YedwqSUNVx",<br/>    "redirect_uris": ["https://superset.local/*"],<br/>    "userinfo_uri": "http://keycloak:8080/realms/master/protocol/openid-connect/userinfo",<br/>    "token_uri": "http://keycloak:8080/realms/master/protocol/openid-connect/token",<br/>    "token_introspection_uri": "http://keycloak:8080/realms/master/protocol/openid-connect/token/introspect"<br/>  }<br/>}</span></pre><p id="f34a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的设置和我的一样，那你应该没问题！注意，因为我们在本地使用它，所以我们有两种类型的 URL。Issuer 和 auth_uri 也将用作重定向。因为我们修改了我们的主机文件，所以我们会很好。</p><p id="cc48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Userinfo、token 和 token_introspection 将由超集“内部”使用。由于 Superset 不知道我们的 hosts 文件，我们将对这些 URL 使用“docker”DNS 名称。</p><p id="019d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">如果你是公开设置，那么你就不需要这两种类型。把公开网址到处放就行了。</em></p><p id="bb23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了能够使用这些信息，我们必须修改同一个目录中的 superset_config.py 文件。</p><p id="0c84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向其中添加以下几行。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="89b3" class="my le in mu b be mz na l nb nc">'''<br/>---------------------------KEYCLOACK ----------------------------<br/>'''<br/>curr  =  os.path.abspath(os.getcwd())<br/>AUTH_TYPE = AUTH_OID<br/>OIDC_CLIENT_SECRETS =  curr + '/docker/pythonpath_dev/client_secret.json'<br/>OIDC_ID_TOKEN_COOKIE_SECURE = False<br/>OIDC_REQUIRE_VERIFIED_EMAIL = False<br/>OIDC_OPENID_REALM: 'master'<br/>OIDC_INTROSPECTION_AUTH_METHOD: 'client_secret_post'<br/>CUSTOM_SECURITY_MANAGER = OIDCSecurityManager<br/>AUTH_USER_REGISTRATION = True<br/>AUTH_USER_REGISTRATION_ROLE = 'Gamma'<br/>OIDC_VALID_ISSUERS = ['https://keycloak.local/realms/master']<br/>'''<br/>--------------------------------------------------------------<br/>'''</span></pre><p id="7aab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果需要，请确保调整领域和 OIDC _ 有效 _ 发行者的 url。</p><p id="8807" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，创建一个名为 keycloack_security_manager.py 的新文件，并向其中添加以下内容。</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="8316" class="my le in mu b be mz na l nb nc">from flask import redirect, request<br/>from flask_appbuilder.security.manager import AUTH_OID<br/>from superset.security import SupersetSecurityManager<br/>from flask_oidc import OpenIDConnect<br/>from flask_appbuilder.security.views import AuthOIDView<br/>from flask_login import login_user<br/>from urllib.parse import quote<br/>from flask_appbuilder.views import ModelView, SimpleFormView, expose<br/>import logging<br/>import urllib.parse<br/><br/>class OIDCSecurityManager(SupersetSecurityManager):<br/><br/>    def __init__(self, appbuilder):<br/>        super(OIDCSecurityManager, self).__init__(appbuilder)<br/>        if self.auth_type == AUTH_OID:<br/>            self.oid = OpenIDConnect(self.appbuilder.get_app)<br/>        self.authoidview = AuthOIDCView<br/><br/>class AuthOIDCView(AuthOIDView):<br/><br/>    @expose('/login/', methods=['GET', 'POST'])<br/>    def login(self, flag=True):<br/>        sm = self.appbuilder.sm<br/>        oidc = sm.oid<br/><br/>        @self.appbuilder.sm.oid.require_login<br/>        def handle_login():<br/>            user = sm.auth_user_oid(oidc.user_getfield('email'))<br/><br/>            if user is None:<br/>                info = oidc.user_getinfo(['preferred_username', 'given_name', 'family_name', 'email'])<br/>                user = sm.add_user(info.get('preferred_username'), info.get('given_name'), info.get('family_name'),<br/>                                   info.get('email'), sm.find_role('Gamma'))<br/><br/>            login_user(user, remember=False)<br/>            return redirect(self.appbuilder.get_url_for_index)<br/><br/>        return handle_login()<br/><br/>    @expose('/logout/', methods=['GET', 'POST'])<br/>    def logout(self):<br/>        oidc = self.appbuilder.sm.oid<br/><br/>        oidc.logout()<br/>        super(AuthOIDCView, self).logout()<br/>        redirect_url = urllib.parse.quote_plus(request.url_root.strip('/') + self.appbuilder.get_url_for_login)<br/><br/>        return redirect(<br/>            oidc.client_secrets.get('issuer') + '/protocol/openid-connect/logout?client_id='+ oidc.client_secrets.get('client_id')+'&amp;post_logout_redirect_uri=' + quote(redirect_url))</span></pre><p id="7cdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们可以清楚地看到两个不同的路由，登录和注销。</p><p id="8ce3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Flask-oidc 处理大部分的魔法，但是如果你想的话，你可以根据你的需要稍微调整一下。在 handle_login 定义中你可以改变我们不存在的用户被创建。也就是说，如果所有声明都没有在 IdToken 中公开，那么您总是可以用其他信息覆盖它。创建用户时，您还可以自定义角色属性。</p><p id="c262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在注销路由上，执行两个动作。首先从超集中注销，然后重定向到 Keycloak 注销页面。如果第二步没有完成，那么只需重新加载超集页面就可以让您再次登录。</p><p id="b7e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是测试这一切的时候了！</p><p id="bc89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关闭所有正在运行的超集容器，并使用以下命令再次启动它们:</p><pre class="mh mi mj mk gt mt mu mv bn mw mx bi"><span id="23ad" class="my le in mu b be mz na l nb nc">docker compose up -d</span></pre><p id="416a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦他们开始运作，试着去 https://superset.local/</p><p id="3180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该会立即被重定向到 Keycloak 登录页面。测试登录，如果一切正常，那么你应该重定向回超集。</p><p id="e8eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后尝试注销。您应该被重定向到 Keycloak 注销页面，然后返回到登录页面，因为您将被重定向到 Superset 的登录过程。</p><p id="e848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章是有用的！它是基于许多来源和大量测试编写的。请注意，超集和 Keycloak 都变化得非常快，确保您使用的版本与“测试”版本相比没有重大变化是很重要的。</p></div></div>    
</body>
</html>