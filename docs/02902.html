<html>
<head>
<title>What is the best IDE setup for developing in Haskell?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Haskell开发最好的IDE设置是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-the-best-ide-setup-for-developing-in-haskell-468066f31ff?source=collection_archive---------1-----------------------#2020-09-10">https://blog.devgenius.io/what-is-the-best-ide-setup-for-developing-in-haskell-468066f31ff?source=collection_archive---------1-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d4246c039b5c2109517fed74fd420b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCuXkBbkJxSkw6iI8ohrhw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a>在<a class="ae kc" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="917d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Haskell 是一种纯函数式编程语言，具有声明性的静态类型代码。对于处理大量数据的高效应用程序来说，这是一个添加到工具箱中的很好的工具，因此它对于数据操作来说特别有用。一般来说，它在学术界用于编程语言的研究，也是一种可以用来自动化数学证明研究的语言；行业应用也有。</p><p id="ff8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您是初学者还是经验丰富的老手，看看其他开发人员如何在不同类型的设置中使用这种语言总是一个很好的练习。</p><p id="ad09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将介绍各种Haskell IDE设置，并在互联网上对每种设置发表意见；希望到最后，您会对现有的选项有一个更好的了解，从而决定什么是最适合您的ide设置。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a8d4" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">虚拟代码</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/48899b08bb04d5e2dc17f1a936b610c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XD6sqoYm_Wpn1H4P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">代码评估支持。通过VSCode Haskell、<a class="ae kc" href="https://github.com/haskell/vscode-haskell" rel="noopener ugc nofollow" target="_blank"> GitHub </a>开源</figcaption></figure><h2 id="d295" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://github.com/haskell/vscode-haskell" rel="noopener ugc nofollow" target="_blank">哈斯克尔扩展</a></h2><ul class=""><li id="0e4f" class="mw mx iq kf b kg my kk mz ko na ks nb kw nc la nd ne nf ng bi translated">警告，通过GHC进行错误诊断</li><li id="5755" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">悬停时的类型信息</li><li id="55c2" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">悬停时的类型文档</li><li id="1e87" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">跳转到定义支持</li><li id="054b" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">文档符号支持</li><li id="339d" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">能够突出显示文档中的引用</li><li id="e462" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码完成</li><li id="77e2" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用Brittany、Floskell、Ormolu或时尚Haskell进行格式化</li><li id="fcc3" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" href="https://code.visualstudio.com/docs/editor/multi-root-workspaces" rel="noopener ugc nofollow" target="_blank">多根工作空间</a>支持</li><li id="6539" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">用Haskell语言服务器进行代码评估</li><li id="9906" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">"如果你使用的是Visual Studio代码，<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=haskell.haskell" rel="noopener ugc nofollow" target="_blank"> Haskell扩展</a>会自动为你下载并安装<code class="fe nm nn no np b">haskell-language-server</code>"<a class="ae kc" href="https://github.com/haskell/haskell-language-server" rel="noopener ugc nofollow" target="_blank"> Haskell语言服务器GitHub </a></li></ul><h2 id="4f01" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=Vans.haskero" rel="noopener ugc nofollow" target="_blank"> Haskero扩展</a></h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/881db686a077e1b0ad0cc97110ef2386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*zV1iUoKGHZg3Vs9T.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">悬停时的标识符类型定义。VSCode Haskero，<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=Vans.haskero" rel="noopener ugc nofollow" target="_blank"> Visual Studio Marketplace </a>。</figcaption></figure><ul class=""><li id="43d7" class="mw mx iq kf b kg kh kk kl ko nr ks ns kw nt la nd ne nf ng bi translated">代码突出显示</li><li id="06b1" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码片段(依赖于<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=justusadam.language-haskell" rel="noopener ugc nofollow" target="_blank"> Haskell语法高亮</a>)</li><li id="3f0f" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">编译错误</li><li id="74ba" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">编译警告</li><li id="ef31" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">插入类型签名，黄色灯泡帮助</li><li id="df3a" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">转到定义支持</li><li id="745d" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">查找所有参考支持</li><li id="5592" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码完成</li><li id="e54a" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">重命名标识符支持</li><li id="603e" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">切换阴谋集团的目标支持</li></ul><h2 id="a74c" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://github.com/haskell/haskell-ide-engine" rel="noopener ugc nofollow" target="_blank"> Haskell IDE引擎</a></h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bdb07c77fc6d41ebb31e35396957957b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*1OM1-TD8AA2if4D5"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">代码操作和快速修复。开源，Haskell IDE引擎，<a class="ae kc" href="https://github.com/haskell/haskell-ide-engine" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</figcaption></figure><ul class=""><li id="9fa4" class="mw mx iq kf b kg kh kk kl ko nr ks ns kw nt la nd ne nf ng bi translated">平原GHC，阴谋集团，堆栈项目都支持</li><li id="ef41" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">编译信息缓存以提高速度</li><li id="7821" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用LSP</li><li id="bb1f" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">hlint诊断公司</li><li id="8905" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">GHC警告和错误</li><li id="07d6" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用apply-refact进行代码操作和快速修复</li><li id="5005" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">光标悬停时键入信息和文档(使用haddock)</li><li id="d7c0" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">跳转到定义支持</li><li id="2461" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">列出支持的所有顶级定义</li><li id="cf2d" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码完成</li><li id="47c5" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码格式</li><li id="8219" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">打字错误快速修复</li></ul><blockquote class="nv nw nx"><p id="b90b" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我个人偏好是Visual Studio代码和Haskero。对我来说效果很好。</p></blockquote><p id="072b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/Exallium" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a><strong class="kf ir">在/r/haskell </strong></p><blockquote class="nv nw nx"><p id="6c09" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我秒VS代码。不过，我用的是<code class="fe nm nn no np b">dramforever.vscode-ghc-simple</code>插件。有一段时间我在这个和Haskero之间切换，但是在过去的几个月里我一直使用<code class="fe nm nn no np b">dramforever.vscode-ghc-simple</code>没有问题。</p></blockquote><p id="8cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/runeks" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/haskell</strong>上的runeks  </a> <strong class="kf ir"/></p><blockquote class="nv nw nx"><p id="0593" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我同意。我曾经使用Emacs和Haskell，但是现在我发现VS代码是一个更好的选择。我仍然保留了一个很好的Emacs配置，以便通过SSH在远程服务器上使用，但是对于本地，我现在真的很喜欢我的VS代码设置。</p></blockquote><p id="ffaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.reddit.com/user/MWatson" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">—MWatson</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="15b3" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我使用的Visual Studio代码带有<a class="ae kc" href="https://github.com/haskell/haskell-ide-engine" rel="noopener ugc nofollow" target="_blank"> Haskell IDE引擎</a>及其相应的<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server" rel="noopener ugc nofollow" target="_blank">扩展</a>。它工作得很好，尽管设置它并不简单，因为它们不提供二进制文件。尽管最近他们已经提高了构建的可靠性。我也不是Haskell超级用户，我仍然只是在学习和试验它，所以YMMV可能。</p></blockquote><p id="1d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/akcilap" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/haskell</strong>上的阿克西拉普 </a> <strong class="kf ir"/></p><blockquote class="nv nw nx"><p id="6358" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">使用HIE的Vs代码。由于nix支持(GHCJS)不佳，我放弃了spacemacs + intero，并很高兴地发现这种体验远远优于其他选择。</p><p id="a73f" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">通过git和make build-all安装需要一点时间来编译，但在那之后，从市场上安装扩展，一切都为我工作(OS X)。</p></blockquote><p id="5421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/01l101l10l10l10" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">01l 101 L10 l 10 l 10</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="3c14" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">不知道它是否适合hie的I部分，但我最稳定和有效的工作流程是在我屏幕的左2/3部分使用VS代码，只有一些语法高亮显示，当它不阻塞时使用HIE，在右1/3部分我使用GHCID。我教过的大多数来自其他语言的人嘲笑ghcid方法，但是给他们一个月的时间，他们开始喜欢它，而不是编辑器中的红色曲线。</p></blockquote><p id="035c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/captjakk" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/haskell</strong>上的captjakk  </a> <strong class="kf ir"/></p><blockquote class="nv nw nx"><p id="ba05" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">现在，我建议使用<a class="ae kc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>并设置Haskell相关的扩展，如语法高亮器、linter、<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server&amp;source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Haskell语言服务器</a>和调试器。你可以从这篇文章中得到帮助。</p></blockquote><p id="bb8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/zarinfam" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">zarinfam</strong></a><strong class="kf ir">on/r/haskell</strong></p><h1 id="f46f" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">智能理念</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/0ef8da7b2540a927bbe78843c121744e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ExngHFofRso7Yjkb.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由JetBrainsScreenshot:Soontobegone—自拍；衍生作品，CC BY-SA 4.0，<a class="ae kc" href="https://commons.wikimedia.org/w/index.php?curid=90004920" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><h2 id="4c66" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://github.com/rikvdkleij/intellij-haskell" rel="noopener ugc nofollow" target="_blank"> Haskell插件</a></h2><ul class=""><li id="4ee0" class="mw mx iq kf b kg my kk mz ko na ks nb kw nc la nd ne nf ng bi translated">没有集成调试</li><li id="f692" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">自动完成</li><li id="47f7" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">建议</li><li id="7dd7" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">完整的功能列表<a class="ae kc" href="https://github.com/rikvdkleij/intellij-haskell#features" rel="noopener ugc nofollow" target="_blank">在这里</a></li></ul><blockquote class="nv nw nx"><p id="21cd" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我对Haskell很陌生，但我真的很喜欢这个设置。我用IntelliJ做其他事情，所以感觉很自然。</p></blockquote><p id="c893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— <a class="ae kc" href="https://www.reddit.com/user/joeyGibson" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">乔伊·吉布森</strong></a><strong class="kf ir">on/r/哈斯克尔</strong></p><blockquote class="nv nw nx"><p id="184d" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我组里的每个人都这么称呼哈斯克尔。最新的测试版(44)带来了许多不错的功能和改进。第一次启动可能会很慢，因为它安装了intero，stylistic等，但对于它带来的所有功能和漂亮的UI来说，它的价格很低。</p></blockquote><p id="20bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/Sir4ur0n" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">sir 4 ur0n</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="58f8" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">IDEA + Intellij-Haskell。前者提供了最佳的IDE体验，后者增加了Haskell支持。</p></blockquote><p id="5784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— <a class="ae kc" href="https://www.reddit.com/user/develop7" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">在/r/哈斯克尔</strong>上开发7  </a> <strong class="kf ir"/></p><h1 id="fcc6" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">原子</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/83a6d64d2cafc46328a72bf76c54af8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T-98rkwaKqK2H33O.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由GitHub提供—附票:2019102510008114，麻省理工学院，<a class="ae kc" href="https://commons.wikimedia.org/w/index.php?curid=83383583" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><ul class=""><li id="ee44" class="mw mx iq kf b kg kh kk kl ko nr ks ns kw nt la nd ne nf ng bi translated"><a class="ae kc" href="https://atom.io/packages/atom-haskell" rel="noopener ugc nofollow" target="_blank"> atom-haskell软件包</a></li><li id="0d8d" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">提供语法突出显示</li><li id="014f" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">自动完成</li><li id="761b" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">转到声明</li></ul><blockquote class="nv nw nx"><p id="3c36" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我一直在和atom一起使用HIE。</p><p id="5522" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我只能用Nix tho正确地设置它。</p></blockquote><p id="1a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/AesaKamar" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">AesaKamar</strong></a><strong class="kf ir">on/r/haskell</strong></p><h1 id="e4cd" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">宇宙飞船</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/71eb08f4217a1f91aa6c28684cc364ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CvmLs9E6KtiSxcqi.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="http://spacemacs.org/" rel="noopener ugc nofollow" target="_blank">http://spacemacs.org/</a>——<a class="ae kc" href="http://spacemacs.org/" rel="noopener ugc nofollow" target="_blank">http://spacemacs.org/</a>，CC BY-SA 4.0，<a class="ae kc" href="https://commons.wikimedia.org/w/index.php?curid=55181158" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><ul class=""><li id="371c" class="mw mx iq kf b kg kh kk kl ko nr ks ns kw nt la nd ne nf ng bi translated"><a class="ae kc" href="https://develop.spacemacs.org/layers/+lang/haskell/README.html" rel="noopener ugc nofollow" target="_blank">哈斯克尔层</a></li><li id="7862" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">本质上只是Emacs，但带有配置文件，因为它是基于Emacs构建的</li><li id="6c36" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">haskell源代码的语法高亮显示</li><li id="3ac2" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">cabal文件的语法高亮显示</li></ul><blockquote class="nv nw nx"><p id="7b12" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我用过带Haskell Layer (intero后端)的Spacemacs。也用Haskero试过VSCode。根据我的经验，这两种方式都相当好，尽管第一印象我更喜欢Spacemacs中Haskell层的工作方式(不过公平地说，我最近没有做足够多的Haskell来形成一个超级有价值的观点，所以要有所保留)。</p></blockquote><p id="5118" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/HKei" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">HKei</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="4e27" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">取决于你想要什么。Spacemacs是一种简单的体验，它应该基本上是可行的。如果您喜欢自己动手修改和编写配置，可以使用普通的Emacs。就我个人而言，我再也不想这么做了。无论如何，你应该可以从这两者中获得相同的体验。</p><p id="b11d" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">对于Spacemacs，以下是您需要的:</p><p id="3d31" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><code class="fe nm nn no np b">stack install apply-refact hlint stylish-haskell hasktags hoogle cabal-install happy intero hindent ghc-mod</code></p><p id="e9c1" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">比严格要求的要多一点，但你会得到保障。对于<code class="fe nm nn no np b">.spacemacs</code>,你需要以下几层:</p><p id="530e" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><code class="fe nm nn no np b">auto-completion<br/>haskell<br/>syntax-checking<br/>yaml</code></p><p id="61a7" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">默认自动补全使用<code class="fe nm nn no np b">ghci</code>，但<code class="fe nm nn no np b">ghc-mod</code>和<code class="fe nm nn no np b">intero</code>也可用。如果您想使用intero:</p><p id="435b" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><code class="fe nm nn no np b">(haskell :variables<br/> haskell-completion-backend 'intero)</code></p><p id="0e86" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">默认情况下，intero会禁用lints。如果您仍然想在intero中使用它们，您需要将它添加到dotspacemacs/user-config中:</p><p id="01f4" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><code class="fe nm nn no np b">(with-eval-after-load 'intero<br/> (flycheck-add-next-checker 'intero '(warning . haskell-hlint)))</code></p><p id="536e" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">详见完整的<a class="ae kc" href="https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell" rel="noopener ugc nofollow" target="_blank"> haskell层文档</a>。</p></blockquote><p id="fda1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">——<a class="ae kc" href="https://www.reddit.com/user/letheed" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a><strong class="kf ir">/r/哈斯克尔</strong></p><h1 id="a7e3" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">Emacs</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/457daa367591cd111656baa8dd7d7ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y2bTL9lo9NROkV7D.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Emacs开发团队——Ferk(截屏用户)、GPL、<a class="ae kc" href="https://commons.wikimedia.org/w/index.php?curid=6412319" rel="noopener ugc nofollow" target="_blank"> Wikimedia </a></figcaption></figure><h2 id="098a" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://github.com/jyp/dante" rel="noopener ugc nofollow" target="_blank">但丁</a></h2><ul class=""><li id="f327" class="mw mx iq kf b kg my kk mz ko na ks nb kw nc la nd ne nf ng bi translated">交互式Haskell的Emacs模式</li><li id="a272" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">Flycheck类型检查和更多功能在此列出<a class="ae kc" href="https://github.com/jyp/dante#features" rel="noopener ugc nofollow" target="_blank"/></li></ul><blockquote class="nv nw nx"><p id="b3b2" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">到目前为止，对我来说最好的是Nix+Cabal+HIE+direnv和Emacs。我得到了大量的类型信息、即时反馈和良好的完成。不过，我还没有非常彻底地使用过重构机制，所以我不能说。</p></blockquote><p id="5344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— <a class="ae kc" href="https://www.reddit.com/user/NihilistDandy" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">虚无安迪</strong> </a> <strong class="kf ir"> on /r/haskell </strong></p><blockquote class="nv nw nx"><p id="c28f" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我用Emacs + Dante +结构化的Haskell模式来处理company、flycheck和attrap，我对此很满意。如果你愿意投入到Emacs和nix的学习曲线中(不是一个要求，但是Dante与其他ide相比对它有很好的支持，并且nix有它自己的好处)或者已经投入了，那么它是非常令人满意的。</p></blockquote><p id="abd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/robreim" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/haskell上的robreim </strong> </a> <strong class="kf ir"/></p><blockquote class="nv nw nx"><p id="9fbb" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我在一个单独的窗口中使用Emacs和ghcid，就这样。</p></blockquote><p id="a723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/mrkkrp" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">mrkkrp</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="3f8c" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">对于我来说，<code class="fe nm nn no np b">emacs</code>和<code class="fe nm nn no np b">dante</code>。这是特性和健壮性之间的最佳折衷。(c.f. <code class="fe nm nn no np b">ghcid</code>更健壮，<code class="fe nm nn no np b">ghc-mod</code>更有特色)。</p><p id="05d8" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/jyp/dante" rel="noopener ugc nofollow" target="_blank">https://github.com/jyp/dante</a></p></blockquote><p id="4496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/spirosboosalis" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">—</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="4015" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我最喜欢的是Emacs中的dante，它是Intero的一个分支，很好地支持多个构建系统。它还有一个很好的特性，可以让我交互式地评估注释中的表达式，所以我不必切换到单独的GHCI缓冲区。</p></blockquote><p id="bce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/davidchristiansen" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/haskell</strong>上的davidchristiansen</a><strong class="kf ir"/></p><h1 id="2829" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">精力</h1><h2 id="b555" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://github.com/neovimhaskell/haskell-vim" rel="noopener ugc nofollow" target="_blank">自定义Haskell vimscripts </a></h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/370a50336f01ffcf98357355c07428d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*MlZ1VH-QN8ZnjyPr"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">开源，<a class="ae kc" href="http://haskell-vim" rel="noopener ugc nofollow" target="_blank">Neovimhaskell/haskell-vim</a>。</figcaption></figure><ul class=""><li id="faae" class="mw mx iq kf b kg kh kk kl ko nr ks ns kw nt la nd ne nf ng bi translated">更多关键词覆盖</li><li id="f3e1" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">更多上下文突出显示</li><li id="024b" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">更智能的缩进</li><li id="4017" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">更好的阴谋支持</li></ul><blockquote class="nv nw nx"><p id="7f8d" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">在Vim方面，我发现hdevtools + ale是最稳定和响应最快的，但是:</p><p id="b52b" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">它仍然是易碎的</p><p id="d02e" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">它不是一个ide！</p></blockquote><p id="5b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/wrkbt" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">wrkbt</strong></a><strong class="kf ir">on/r/haskell</strong></p><blockquote class="nv nw nx"><p id="3880" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我最喜欢的是不去尝试任何类似IDE的东西。相反，只需使用一个简单但功能强大的文本编辑器(一个相当普通的vim设置是我选择的武器)，结合一个合适的反馈循环在一个副手窗口中运行。</p><p id="6f20" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">这可能看起来很原始，但有几个不明显的优势对我来说非常重要:它快速、可预测、可靠、可扩展，可以跨所有语言、框架和堆栈工作。很少有移动部件，它们都是“用户可维护的”和松散耦合的。</p><p id="da9d" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我对所有的语言和情况都使用这种方法，尽管IME认为它对像Haskell这样的语言特别有效，在Haskell中，许多通常用IDE工具解决的问题都在语言本身中解决了。您可以经常使用Haskell的抽象能力来实现同样的事情，而不是搭建强制性的样板文件；或者采用类型错误驱动的重构(不要求助于花哨的重构工具，您只需大胆地进行血腥的更改，然后修复所有编译器错误，直到它再次工作)。</p></blockquote><p id="392a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/tdammers" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/哈斯克尔</strong>上的tdammers  </a> <strong class="kf ir"/></p><h1 id="7db0" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">SublimeText</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/4f0beac35ae9ad4685d0d95bb9c221d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*thFjBrAsVpa8cjaM.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源(WP:NFCC#4)，合理使用，<a class="ae kc" href="https://en.wikipedia.org/w/index.php?curid=55236299" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><h2 id="3931" class="mk lj iq bd lk ml mm dn lo mn mo dp ls ko mp mq lw ks mr ms ma kw mt mu me mv bi translated"><a class="ae kc" href="https://packagecontrol.io/packages/SublimeHaskell" rel="noopener ugc nofollow" target="_blank"> SublimeHaskell插件</a></h2><ul class=""><li id="7d82" class="mw mx iq kf b kg my kk mz ko na ks nb kw nc la nd ne nf ng bi translated">秘密建筑</li><li id="06f7" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">错误和警告突出显示</li><li id="314c" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">智能完成</li><li id="961b" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">ghc-mod集成</li><li id="ae21" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">堆栈支持</li><li id="d4ef" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">增强型完成</li><li id="82b8" class="mw mx iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">带有符号信息以及错误、警告和提示详细信息的弹出窗口</li></ul><blockquote class="nv nw nx"><p id="5b92" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">在这一点上，SublimeText看起来几乎是可行的。缺点似乎是手动安装过程，以及在用户体验中完全缺乏指导。恐怕目前我也不能向客户推荐这个。</p></blockquote><p id="6dc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— <strong class="kf ir">克里斯完成</strong> <a class="ae kc" href="https://www.fpcomplete.com/blog/mainstream-ides-haskell/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> FP完成</strong> </a></p><blockquote class="nv nw nx"><p id="59ec" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我使用SublimeHaskell插件，它与Cabal项目集成(保存文件触发重新加载)，标记代码中的错误，并添加一个颜色方案，看起来像Hackage的源代码浏览器。</p><p id="f9c6" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我对它非常满意，我很少再用vim做任何事情了。(特别是因为你可以使用Sublime的CLI，subl，并将其设置为你的$EDITOR)</p></blockquote><p id="3cbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/tazjin" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a><strong class="kf ir">on/r/haskell</strong></p><h1 id="618f" class="li lj iq bd lk ll oc ln lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf bi translated">某人巨大的大脑</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/b44fcbd1fc0ae50385c83d537c0bfb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KBEkEPUU5bZPYqGOlvtmg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@averey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Robina Weermeijer </a>在<a class="ae kc" href="https://unsplash.com/s/photos/brain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="nv nw nx"><p id="992f" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我的经验是，大多数ide都不足以支持有效的Haskell编程。相反，我用我巨大的大脑的力量想象完整的代码库，作为一个纯能量的生物，直接操纵存储上的比特，使其成为正确的编译形式，甚至使GHC变得不必要。</p><p id="1eaf" class="kd ke ny kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"/></blockquote><p id="ce3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—<a class="ae kc" href="https://www.reddit.com/user/peterb12" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">/r/哈斯克尔</strong>上的彼得布12  </a> <strong class="kf ir"/></p><div class="on oo gp gr op oq"><a href="https://tremaineeto.medium.com/membership" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">通过我的推荐链接加入媒体</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">tremaineeto.medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jw oq"/></div></div></a></div></div></div>    
</body>
</html>