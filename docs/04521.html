<html>
<head>
<title>Spring Retry vs Resilience4j Retry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring重试与Resilience4j重试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-retry-vs-resilience4j-retry-ac92606bd795?source=collection_archive---------1-----------------------#2021-03-28">https://blog.devgenius.io/spring-retry-vs-resilience4j-retry-ac92606bd795?source=collection_archive---------1-----------------------#2021-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9ddd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示两种重试的比较——Spring重试与Resilience4j重试。通常，您可以在实现时将重试与断路器结合使用，以使您的应用程序更加健壮。我已经报道了<a class="ae ki" href="https://betterjavacode.com/spring-boot/how-to-use-circuit-breaker-in-spring-boot-application" rel="noopener ugc nofollow" target="_blank">断路器演示</a>。另外，如果你有兴趣了解更多关于Spring安全的知识，我已经用Okta Demo更新了我的书<a class="ae ki" href="https://gumroad.com/l/VgSdH" rel="noopener ugc nofollow" target="_blank">简化Spring安全</a>。</p><h1 id="ab4f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Spring重试与Resilience4j重试</h1><p id="37dc" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated"><a class="ae ki" href="https://docs.spring.io/spring-batch/docs/current/reference/html/retry.html" rel="noopener ugc nofollow" target="_blank">弹簧重试</a>允许应用程序自动重试失败的操作。在大多数情况下，如果您的服务正在调用另一个服务，而另一个服务由于某种原因没有响应，您可以使用Spring Retry来重试相同的操作。这提供了另一种使您的服务更加可用的方法。</p><p id="dd21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重试使您的应用程序更健壮，更不容易失败。您可以在您认为可能失败的方法上配置Spring Retry，也可以配置一个<code class="fe lm ln lo lp b">RetryTemplate</code>。易于配置使得Spring Retry成为编写代码时更容易的选择。</p><p id="11fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，Resilience4j Retry模块提供了同样简单的配置——通过代码或通过属性。</p><p id="12a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示如何在调用任何方法或服务时使用Spring Retry和Resilience4j Retry模块。</p><h1 id="1586" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">何时使用重试？</h1><p id="523a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">通常，在某些情况下，您应该考虑重试操作。</p><ol class=""><li id="2f10" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">对REST端点的HTTP调用</li><li id="f7c0" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">从SQS发送或检索消息</li><li id="b4d4" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">远程过程调用或web服务</li><li id="2d86" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">从数据库获取或存储数据</li></ol><p id="867f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，如果操作失败，我们可以返回一个错误。但是随着应用程序的可用性变得越来越重要，大多数时候，这些错误是微不足道的，大多数服务在几毫秒到几秒内就可以恢复在线。</p><p id="629f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，应用重试是有意义的。您必须注意，您正在应用重试的操作必须是幂等的。假设，您的应用程序发送了一个请求，目标服务收到了请求，但是在此期间发生了一些事情，您的目标服务无法及时响应。然后，使用重试，目标服务不应该将重试尝试视为单独的或新的请求。</p><h1 id="4957" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">弹簧重试</h1><p id="97d6" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在这一节中，我将展示使用Spring Retry的各种方法。首先，我们将有一个简单的Spring Boot REST应用程序来从数据库中检索公司列表。像往常一样，我不会展示如何构建Spring Boot应用程序。你可以访问我的其他博客。</p><h1 id="0320" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">梯度依赖性</h1><p id="c3cd" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">要使用Spring Retry，我们的配置中需要两个依赖项。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="2316" class="mm kk in lp b gy mn mo l mp mq">implementation 'org.springframework.retry:spring-retry:1.3.1' implementation 'org.springframework:spring-aspects:5.3.5'</span></pre><h1 id="336d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">启用重试批注</h1><p id="7ba9" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">一旦我们有了<code class="fe lm ln lo lp b">spring-retry</code>依赖，我们将能够用注释<code class="fe lm ln lo lp b">@EnableRetry</code>注释我们的主类，如下所示:</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="ea34" class="mm kk in lp b gy mn mo l mp mq">package com.betterjavacode.retrydemo;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.data.jpa.repository.config.EnableJpaRepositories;<br/>import org.springframework.retry.annotation.EnableRetry;<br/>import org.springframework.retry.backoff.FixedBackOffPolicy;<br/>import org.springframework.retry.policy.SimpleRetryPolicy;<br/>import org.springframework.retry.support.RetryTemplate;<br/><br/><br/>@SpringBootApplication<br/>@EnableRetry<br/>@EnableJpaRepositories(basePackages = "com.betterjavacode.retrydemo.daos")<br/>public class RetrydemoApplication {<br/><br/>	public static void main(String[] args) {<br/>		SpringApplication.run(RetrydemoApplication.class, args);<br/>	}<br/><br/>	@Bean<br/>	public RetryTemplate retryTemplate()<br/>	{<br/>		RetryTemplate retryTemplate = new RetryTemplate();<br/><br/>		FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy();<br/>		backOffPolicy.setBackOffPeriod(100);<br/><br/>		SimpleRetryPolicy simpleRetryPolicy = new SimpleRetryPolicy();<br/>		simpleRetryPolicy.setMaxAttempts(2);<br/><br/>		retryTemplate.setRetryPolicy(simpleRetryPolicy);<br/>		retryTemplate.setBackOffPolicy(backOffPolicy);<br/>		return retryTemplate;<br/>	}<br/><br/><br/>}</span></pre><p id="e415" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会在后面解释剩下的代码，但是请注意这里的注释<code class="fe lm ln lo lp b">@EnableRetry</code>。这将在我们的应用程序中启用重试。</p><h1 id="397f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">休息控制器</h1><p id="2edd" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们将以两种不同的方式展示Spring Retry。</p><ol class=""><li id="60df" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">使用<code class="fe lm ln lo lp b">@Retryable</code>注释</li><li id="1561" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">使用<code class="fe lm ln lo lp b">RetryTemplate</code></li></ol><p id="e17d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的REST控制器将为我们获取一个公司列表，一个按id的公司，或者一个按名称的公司列表。它看起来会像下面这样:</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="3369" class="mm kk in lp b gy mn mo l mp mq">package com.betterjavacode.retrydemo.controllers;<br/><br/>import com.betterjavacode.retrydemo.dtos.CompanyDto;<br/>import com.betterjavacode.retrydemo.service.CompanyService;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.List;<br/><br/>@RestController<br/>@RequestMapping("/v1/betterjavacode/companies")<br/>public class CompanyController<br/>{<br/>    @Autowired<br/>    CompanyService companyService;<br/><br/>    @GetMapping<br/>    public ResponseEntity&lt;List&gt; getAllCompanies()<br/>    {<br/>        List companyDtos = companyService.getAllCompanies();<br/><br/>        if(companyDtos.isEmpty())<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);<br/>        }<br/><br/>        return new ResponseEntity&lt;&gt;(companyDtos, HttpStatus.OK);<br/>    }<br/><br/>    @GetMapping("/{id}")<br/>    public ResponseEntity getCompanyById(@PathVariable("id") long id)<br/>    {<br/>        CompanyDto companyDto = companyService.getCompany(id);<br/>        if(companyDto == null)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);<br/>        }<br/>        return new ResponseEntity&lt;&gt;(companyDto, HttpStatus.OK);<br/>    }<br/><br/>    @GetMapping("/")<br/>    public ResponseEntity&lt;List&gt; searchCompanies(@RequestParam("name") String companyName)<br/>    {<br/>        List companyDtos = companyService.searchCompanyByName(companyName);<br/>        if(companyDtos.isEmpty())<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);<br/>        }<br/><br/>        return new ResponseEntity&lt;&gt;(companyDtos, HttpStatus.OK);<br/>    }<br/>}</span></pre><p id="efa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的控制器中，我们使用了一个名为<code class="fe lm ln lo lp b">CompanyService</code>的<code class="fe lm ln lo lp b">@Service</code>对象。这个服务对象为我们提供了一种实现获取公司数据的方法的方式。</p><h1 id="2328" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">具有各种重试配置的服务</h1><p id="ffe2" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">因此，我们将看看如何使用注释<code class="fe lm ln lo lp b">@Retryable</code>:</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="3066" class="mm kk in lp b gy mn mo l mp mq">@Retryable(value = SQLException.class, maxAttempts = 2, backoff =    @Backoff(delay = 100))<br/>    public List getAllCompanies()<br/>    {<br/>        List companies =  companyRepository.findAll();<br/>        List companyDtos = new ArrayList&lt;&gt;();<br/>        for(Company company : companies)<br/>        {<br/>            CompanyDto companyDto = new CompanyDto(company.getName(), company.getType(),<br/>                    company.getCity(), company.getState(), company.getDescription());<br/>            companyDtos.add(companyDto);<br/>        }<br/><br/>        return companyDtos;<br/>    }</span></pre><p id="d28b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们获取了一个公司列表。如果该方法未能获取结果，并出现与<code class="fe lm ln lo lp b">SQLException</code>相关的任何异常，我们将重试获取。我们将按照<code class="fe lm ln lo lp b">maxAttempts</code>的配置重试两次。在每次尝试之间，会有100毫秒的延迟。现在，如果我们运行我们的应用程序并调用这个方法，我们将看到这个重试是如何工作的。</p><p id="d492" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了模拟该错误，我将从Windows服务中停止SQL服务。我将在下面显示成功响应和重试响应:</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5236f9409928a7f8650757d53eb402c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*vaoFuUrVGua3tZCt"/></div></figure><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7967a7b4eb4226169870e46ee2de8db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*Xcb2KoXOf-LQPy3B"/></div></figure><p id="e01b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面的截图中看到的，有两次重试的尝试。在每次重试中，它会尝试连接MySQL服务器三次。</p><h1 id="9867" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">重试模板</h1><p id="2087" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">类似地，我们也可以使用Spring-Retry提供的重试模板。在下面的代码中，我展示了一个我在<code class="fe lm ln lo lp b">CompanyService</code>中添加的方法来获取id的公司数据。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="170a" class="mm kk in lp b gy mn mo l mp mq">public CompanyDto getCompany(long id)<br/>{<br/>        CompanyDto companyDto = retryTemplate.execute(rt -&gt; {<br/>           Company company = companyRepository.findById(id).get();<br/>           CompanyDto localCompanyDto = new CompanyDto(company.getName(), company.getType(),<br/>                   company.getCity(),<br/>                   company.getState(), company.getDescription());<br/>           return localCompanyDto;<br/>        });<br/><br/>        return companyDto;<br/>}</span></pre><p id="852b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个retryTemplate bean用<code class="fe lm ln lo lp b">simpleRetryPolicy</code>配置，有两次尝试，每次尝试之间有100毫秒的延迟。然而，如果我尝试以与对<code class="fe lm ln lo lp b">@Retryable</code>相同的方式执行该方法，我们将看到下面的输出:</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/385d225df9c874e698b409b82620dd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*-6Aj2k_QsVmwlGdH"/></div></figure><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/719a11c542b3ca0bccc758f67ec57ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*AGDIXYKkkXTUqiuh"/></div></figure><p id="3775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，我所做的就是从windows服务中停止我的MySQL服务，并允许我的方法重试。</p><h1 id="ea8a" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Resilience4j重试</h1><p id="aa3f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">使用<code class="fe lm ln lo lp b">resilience4j-retry</code>库时，您可以向<code class="fe lm ln lo lp b">RetryRegistry</code>构建器注册一个自定义全局<code class="fe lm ln lo lp b">RetryConfig</code>。使用此注册表建立重试。在获取公司数据的演示中，我们添加了一个新的方法来按名称检索公司。</p><p id="5523" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个方法将如下所示:</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="5963" class="mm kk in lp b gy mn mo l mp mq">public List searchCompanyByName(String name)<br/>    {<br/>        LOGGER.info("Search for company = {}", name);<br/><br/>        RetryConfig retryConfig =<br/>                RetryConfig.custom().maxAttempts(4).waitDuration(Duration.of(2, SECONDS)).build();         <br/><br/>        RetryRegistry retryRegistry = RetryRegistry.of(retryConfig);<br/><br/>        Retry retryConfiguration = retryRegistry.retry("companySearchService", retryConfig);<br/><br/>        Supplier&lt;List&gt; companiesSupplier = () -&gt; companyRepository.findAllByName(name);<br/><br/>        Supplier&lt;List&gt; retryingCompaniesSearch =<br/>                Retry.decorateSupplier(retryConfiguration, companiesSupplier);<br/><br/>        List companyDtos = new ArrayList&lt;&gt;();<br/>        List companies = retryingCompaniesSearch.get();<br/>        LOGGER.info("Retrying..");<br/>        for(Company company : companies)<br/>        {<br/>            CompanyDto companyDto = new CompanyDto(company.getName(), company.getType(),<br/>                    company.getCity(), company.getState(), company.getDescription());<br/>            companyDtos.add(companyDto);<br/>        }<br/><br/>        return companyDtos;<br/>    }</span></pre><p id="d944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的方法中，我们首先创建<code class="fe lm ln lo lp b">RetryConfig</code>。我们创建一个<code class="fe lm ln lo lp b">RetryRegistry</code>并在注册表中添加<code class="fe lm ln lo lp b">RetryConfig</code>。然后当我们创建获取公司列表的调用时。我们用<code class="fe lm ln lo lp b">retryConfiguration</code>来修饰这个调用。</p><h1 id="d793" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">具有Resilience4j的自定义-重试</h1><p id="f20c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated"><code class="fe lm ln lo lp b">RetryConfig</code>提供不同的定制:</p><ol class=""><li id="94d2" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">max attempts-3是默认的重试次数。</li><li id="e8c4" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">waitDuration —每次重试之间的固定等待时间。</li><li id="97e0" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">intervalFunction —修改故障后等待间隔的功能。</li><li id="fbaa" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">retryOnResultPredicate配置一个谓词，用于评估是否应该重试结果。</li><li id="34ea" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">retryExceptions配置用于重试的可抛出类的列表</li><li id="4900" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">ignoreExceptions配置被忽略的可抛出类的列表</li><li id="3e65" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">failAfterMaxRetries一个布尔值，用于在重试次数达到配置的最大尝试次数时启用或禁用引发maxretriesexceededededexception</li></ol><h1 id="751f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">演示</h1><p id="44fd" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在，让我们看看用<code class="fe lm ln lo lp b">resilience4j-retry</code>执行这个方法会发生什么。以下屏幕截图显示了SQL服务仍在运行时的成功响应。</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/a0a67a2e0c1abcd145751d7d5e0ccf08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*Vc2GqQWsEvhjh6OS"/></div></figure><p id="e8ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我停止SQL服务，我们将看到重试尝试4次，因为我们已将其配置为4次。</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1a69d13e026b6de85f492e715ea0b0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*EWegWDPhOI3zexcO"/></div></figure><h1 id="68c2" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">密码</h1><p id="a127" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这个演示的代码可以在我的<a class="ae ki" href="https://github.com/yogsma/betterjavacode/tree/main/retrydemo" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><h1 id="f3ea" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="1450" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在这篇文章中，我展示了Spring Retry和Resilience4j Retry之间的比较。何时使用这些库取决于您的场景。通常，如果您还计划Resilience4j断路器模块，resilience4j重试会很顺利。使用<code class="fe lm ln lo lp b">RetryTemplate</code>，弹簧重试对于各种配置都很方便。</p><p id="c06b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这篇文章，请在这里订阅我的博客<a class="ae ki" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="5f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nc">原载于2021年3月28日https://betterjavacode.com</em><a class="ae ki" href="https://betterjavacode.com/programming/spring-retry-vs-resilience4j-retry" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a><em class="nc">。</em></p></div></div>    
</body>
</html>