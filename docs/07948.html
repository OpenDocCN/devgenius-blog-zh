<html>
<head>
<title>HTML5 RSS Reader: filtering the custom list component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML5 RSS 阅读器:过滤自定义列表组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/html5-rss-reader-filtering-the-custom-list-component-c3ba366c08fd?source=collection_archive---------9-----------------------#2022-05-05">https://blog.devgenius.io/html5-rss-reader-filtering-the-custom-list-component-c3ba366c08fd?source=collection_archive---------9-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/60733bea977fd3a9ae0c25e448cd5e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tBZOfzA_MFtKpgma"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·温克勒在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">开始</a>编写一个 HTML、Javascript 和 CSS 专用的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f">应用程序</a>，由一个最小的 Rust web 服务器支持。我们看到了如何只使用原生 Javascript 编写 web 组件，试图远离框架、构建器或捆绑器。我们研究了 CSS 导入和 Javascript <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-specialized-web-components-8c8a972e681a">模块导入</a>，实现了一个无框架的 web 应用程序，所有依赖项都按需加载。</p><p id="1a4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个练习只是探索现代 Javascript 现在如何能够覆盖以前只能通过使用各种 UI 框架获得的架构。尽管最终的结果看起来很优雅，选择框架和构建者的负担也减轻了，但是每个项目都是不同的，因此必须遵循常识。</p><p id="55ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个<code class="fe lb lc ld le b">CustomList</code>组件和一个<code class="fe lb lc ld le b">CustomListItem</code>，然后我们将<code class="fe lb lc ld le b">CustomListItem</code>扩展为<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>，因为它们有特定的渲染需求。今天我们将为<code class="fe lb lc ld le b">CustomList</code>添加过滤功能，并为<code class="fe lb lc ld le b">CustomListItem</code>添加一些支持功能。</p><h2 id="bb4c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">搜索自定义列表项</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/61e063682bac2d98ad96949d790be107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeP5mT03HphLsKX4f97tpQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对 CustomListItem 类的一个小补充</figcaption></figure><p id="2745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了两个列表，一个包含提要，另一个包含文章，如果我们更改<code class="fe lb lc ld le b">CustomList</code>来添加一个新特性，它将可用于我们页面上的每个实例。同样，如果我们给<code class="fe lb lc ld le b">CustomListItem</code>添加一个特性，它也将适用于<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>。所以首先，让我们修改我们的<code class="fe lb lc ld le b">CustomListItem</code>并添加几个函数来支持过滤:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="d23c" class="lf lg iq le b gy mh mi l mj mk">hide() {<br/>  this.classList.add("hidden");<br/>}<br/>show() {<br/>  this.classList.remove("hidden");<br/>}<br/>isHidden() {<br/>  return this.classList.contains("hidden");<br/>}</span><span id="01a7" class="lf lg iq le b gy ml mi l mj mk">dataItemContains(word) {<br/>  return this.dataItem.toLowerCase().indexOf(word.toLowerCase()) !== -1;<br/>}</span></pre><p id="e298" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">CustomListItem</code>需要支持隐藏，以便<code class="fe lb lc ld le b">CustomList</code>可以隐藏当前过滤器不可用的项目。它还需要一个功能，允许搜索给定单词的数据项。这就是<code class="fe lb lc ld le b">dataItemContains</code>功能。还记得<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>包含不同属性的对象，但是它们都设置了一个<code class="fe lb lc ld le b">dataset.item</code>用于搜索。<code class="fe lb lc ld le b">FeedListItem</code>正在将进给<code class="fe lb lc ld le b">name</code>属性设置为<code class="fe lb lc ld le b">dataset.item</code>，<code class="fe lb lc ld le b">ArticleListItem</code>正在设置物品<code class="fe lb lc ld le b">title</code>。所以<code class="fe lb lc ld le b">dataItemContains</code>基本上会检查给定的<code class="fe lb lc ld le b">word</code>是否能在<code class="fe lb lc ld le b">FeedListItem</code>的进给<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">ArticleListItem</code>的文章<code class="fe lb lc ld le b">title</code>中找到。</p><p id="7de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>都可以重新实现<code class="fe lb lc ld le b">dataItemContains</code>功能。它会覆盖默认的，并使用他们自己的。如果搜索会更复杂，默认功能不够用的话。但是在我们的例子中，在<code class="fe lb lc ld le b">dataset.item</code>中搜索<code class="fe lb lc ld le b">word</code>对于<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>都足够了。我们还需要在<code class="fe lb lc ld le b">custom-list-item.css</code>中定义<code class="fe lb lc ld le b">hidden</code>类:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="0c4d" class="lf lg iq le b gy mh mi l mj mk">li.custom-list-item.hidden {<br/>  display: none !important;<br/>}</span></pre><h2 id="774b" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">将过滤器功能添加到自定义列表</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/78205708c11f84f5130406901fc5e73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gafej7nyBbAABZjNAA7jTg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CustomList 类的小变化</figcaption></figure><p id="c9ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">CustomList</code>只需要增加一个功能:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="9658" class="lf lg iq le b gy mh mi l mj mk">filter(word) {<br/>  this.querySelectorAll("li.custom-list-item").forEach((e) =&gt; {<br/>    if (e.dataItemContains(word)) e.show();<br/>    else e.hide();<br/>  });<br/>}</span></pre><p id="2311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这将如何工作呢？我们将在<code class="fe lb lc ld le b">index.html</code>中添加一个文本框，用户可以在其中输入用于过滤提要列表的单词。当用户输入时，我们将调用列表的<code class="fe lb lc ld le b">filter</code>函数，它将询问它的条目是否有响应给定单词的数据。让我们看看。</p><h2 id="f24a" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">变化中的 index.html</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/60e0260abf29e6a8679c78abeee9b80e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2xuet8cGY_7GvLkVuFh7g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将输入元素添加到 index.html</figcaption></figure><p id="3a7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需在提要列表前向<code class="fe lb lc ld le b">index.html</code>添加一行代码:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="73c3" class="lf lg iq le b gy mh mi l mj mk">&lt;input id="feedFilter" type="text" placeholder="Search feeds..."&gt;</span></pre><p id="47c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，用户将输入他们的搜索项，应用程序将通过调用<code class="fe lb lc ld le b">feeds.filter(feedFilter.value)</code>来响应。让我们在<code class="fe lb lc ld le b">index.js</code>中这样做:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="3bac" class="lf lg iq le b gy mh mi l mj mk">document.getElementById("feedFilter").addEventListener("input", (e) =&gt; {<br/>  document.getElementById("feeds").filter(e.target.value);<br/>});</span></pre><p id="f2d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们给<code class="fe lb lc ld le b">base.css</code>增加一个小的造型变化:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="4361" class="lf lg iq le b gy mh mi l mj mk">body {<br/>  grid-column-gap: 1em;<br/>}</span><span id="4529" class="lf lg iq le b gy ml mi l mj mk">input {<br/>  width: 100%;<br/>  box-sizing: border-box;<br/>}</span></pre><p id="bec4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在提要列表和文章列表之间添加了一个小间隙。我们还扩展了<code class="fe lb lc ld le b">input</code>来填充所有可用空间，并确保在调整大小时<code class="fe lb lc ld le b">input</code>边界也算在内。</p><h2 id="4e5c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">结果呢</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/995965f0ecba36c607d1f8e56f1707eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjWLvevB-8tWNI2kjbs0Vg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">改进的 RSS 阅读器应用程序</figcaption></figure><p id="7b78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">全部完成！我们在提要列表上方有搜索输入，如果我们输入字母:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/09a1c29e56afbdfa982674596224a967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jewU6YXrXN6R_d28OqhhzA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">过滤在行动</figcaption></figure><p id="de26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过滤器工作原理:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/236eff625898bed13a2c28d6bbac3a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZwup4-VD7_iFsYMyYI0tQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用更多字母进行过滤</figcaption></figure><p id="43a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，由于我们之前在<code class="fe lb lc ld le b">index.css</code>中轻松定义的响应式布局，如果我们将浏览器调整为移动宽度，一切都可以开箱即用:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e37f4f51cc6946aca666fc21ff0396b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*SrUk3jXLQR1uQp11-ik3Qw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的 RSS 阅读器应用程序的移动版本</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="0185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的结尾，我们的新过滤功能工作正常，编写时改动和中断很少。我们甚至不用接触<code class="fe lb lc ld le b">FeedListItem</code>和<code class="fe lb lc ld le b">ArticleListItem</code>，一切都在它们的基类中完成。代码一如既往地在 Github 上可用，但是正如我一直说的，不要急于克隆它:尝试通读这篇文章并编写自己的代码。</p><p id="450e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次我们将谈论<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-shadow-dom-of-an-html5-web-component-d99af7844192">阴影 DOM </a>。这是一个与 HTML5 web 组件相关的概念，它允许组件进一步隐藏其实现细节。那里见！</p></div></div>    
</body>
</html>