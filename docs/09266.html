<html>
<head>
<title>Day 120 of Game Dev: What are Abstract Classes and Methods — C#?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏开发的第 120 天:什么是抽象类和方法——c#？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/day-120-of-game-dev-what-are-abstract-classes-and-methods-c-1f80f14c6585?source=collection_archive---------8-----------------------#2022-08-10">https://blog.devgenius.io/day-120-of-game-dev-what-are-abstract-classes-and-methods-c-1f80f14c6585?source=collection_archive---------8-----------------------#2022-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b47f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">目的:</strong>复习抽象类及其用途。</p><p id="1290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抽象类允许我们强制继承。抽象方法允许我们强制实现这些方法。</p><p id="f27a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着我们基本上可以创建一个继承类的模板，然后他们可以完成自己的添加。</p><p id="9f76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要举的例子是一个敌人职业，它将作为不同类型敌人的模板。然后我将创建一个继承敌人职业的蛇职业。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/77e230c74dcdc22684a84f4d9a25fa3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*ywAVetDD_1NCy9w6u9nebA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/aeb2f5137d295be5a3f13610cf30260b.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*R5sHea4MdQlEGX3rWBkH5g.png"/></div></figure><p id="aefe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在非抽象或标准的类设置中，您会注意到，尽管一个类继承了另一个类，但调用基类方法仍然是可选的。</p><p id="b821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我有一个敌方类的 Attack()方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/17b3865c319e43ddb421be195fbd4a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*kFs2rk0SyIRBKvARMLmERw.png"/></div></figure><p id="59da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Snake 类可以选择使用该方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/013245c22074eaf145d83f1574444fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*2Pal5mxqur-P3Xdw0FAsKA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/1d8b1162c398b0ccc35a572483e4f495.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*URkx6yclBknJk7nSD7MUYQ.png"/></div></figure><p id="31dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">唯一的问题是，有时我们希望一个继承类使用一个方法，而不给它一个选项。我们如何设置它？</p><p id="b112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要确保这个类是一个抽象类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/b8f35ae0d7085cb272ebf583d185a025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Gqi-bly_fmjVRUloMgIa-Q.png"/></div></figure><p id="4a3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，如果一个类是一个抽象类，它不能被附加到游戏对象上。</p><p id="b5e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅仅这一点并不能使 Attack()方法成为 Snake 类的非可选方法。我们还需要将 Attack()方法抽象化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/e907242bec73bb5be02aa3f9c98eda18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*Js4XyJo5fMn_Uy_K1VCV3A.png"/></div></figure><p id="1c12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，抽象方法不能被基类赋予功能。取而代之的是，每个继承类将会选择它们赋予该方法什么功能。在这里，我在敌人类中声明了一个抽象的 Attack()方法，任何从它继承的类都将选择给 Attack()方法提供什么功能。</p><p id="d448" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然这个方法是抽象的，那么 Snake 类就会出现一个错误，提示您必须实现 Attack()方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kw"><img src="../Images/097473d01c6d51baa8ee6b319a587071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jcep6nGj8ut1btAPOk2NEA.png"/></div></div></figure><p id="0f39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样做之后，错误就消失了，抽象方法的目的也实现了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/d06c4b684adbdfeb47499088aea74215.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*wAjhr5u3yFxrdpO00S356g.png"/></div></figure><p id="6935" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想知道为什么我们必须把 override 放在那里，那是因为默认情况下抽象方法的行为就像虚方法一样，需要继承类来覆盖它的功能。关于重写方法和虚拟方法的更多信息，请查看我以前的<a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/day-111-of-game-dev-overriding-methods-from-inheriting-classes-in-c-d54a429c1e30">文章</a>。</p><p id="f7a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你可能会问另一个问题:如果我们希望一些方法共享相同的功能，而不是被迫实现它们自己的功能，那会怎么样？</p><p id="40a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设在敌人类中有一个 Die()方法，Die()中的功能(大部分)在所有敌人中都是相同的，不像 Attack()方法会根据敌人的不同而不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/93ad54db76f8b9fba4516d6211803ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*WLmRL73eWYFKQlP49Oz7gg.png"/></div></figure><p id="12cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不是抽象类中的所有方法都必须是抽象的。这意味着我可以用标准实现向我的敌人类添加一个虚拟的 Die()方法。</p><p id="74a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这个方法不是抽象的，所以我没有被迫在 Snake 类中调用它。但是如果我想调用它，因为它是虚拟的，我可以像平常一样调用它，这将默认调用基类的(敌人)实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi le"><img src="../Images/d05ba28936550df95e3d1df747803500.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*WXdkbBRytDfjktdHl9_3fQ.png"/></div></figure><p id="0ad2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者我可以覆盖它，调用基类实现，并根据它是什么敌人添加我自己的定制代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/dec9d839c1be8f3ebbfa103dbaff23ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*N5dHwxxb2Dxlo0FFkqB-EA.png"/></div></figure><p id="6d99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以只添加自定义代码并完全覆盖 Die()方法，而不是像上面那样添加。</p><p id="47ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这能帮助你更好地理解抽象类。如果你有任何问题或想法，请随意评论。让我们制作一些令人敬畏的游戏！T3】</p></div></div>    
</body>
</html>