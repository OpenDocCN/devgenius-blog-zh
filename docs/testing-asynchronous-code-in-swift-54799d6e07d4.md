# 在 Swift 中测试异步代码

> 原文：<https://blog.devgenius.io/testing-asynchronous-code-in-swift-54799d6e07d4?source=collection_archive---------35----------------------->

![](img/a7754e439c77ce3af061e91d5464c417.png)

费伦茨·阿尔马西在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

当您开始测试代码时，您可能会发现测试异步方法有点棘手。

但是不要担心，如果你想断言一个异步块**将**执行，或者甚至断言它**将不会**执行， *XCTestExpectation* 会帮你搞定。

在这篇文章中，我将向您展示一个真正常见的情况，您将想要测试一个异步方法，以及如何使用 *XCTestExpectation* 来创建一个块将在未来执行的预期，以及如何创建一个反向预期来断言一个块将不会在未来执行。

# 使用案例

假设您正在创建一个功能，显示您的应用程序销售的商品的信息。每当用户从列表中选择一个项目时，此功能将从服务器上的端点下载项目详细信息。然后，您将获得商品 ID，并向该端点发出 HTTP 请求以检索商品详细信息。但是为了更有效地使用数据，您还应该缓存获取的每个项目，因此如果用户想要查看已经缓存的项目的详细信息，而不是从端点获取，您将返回缓存的项目。

为了实现这个目标，这个特性将有一个 *ItemWorker* 类。它的目标是返回一个项目，给定一个 ID。该类将包含通过 *CacheRepository* 从缓存中获取项目的机制，或者使用*网络*向端点请求项目。

这是该类的一个可能实现:

注意这个例子中的*网络*和*缓存库*是**单例**，但是，我没有直接使用它们的共享实例。我使用了**依赖注入**技术来使 *ItemWorker* 依赖于协议。这样，当我们测试这个类时，我们可以创建符合*网络协议*和*CacheRepositoryProtocol*的模拟类，让我们完全控制测试任何我们想要的网络场景或缓存状态。如果你从未听说过这个概念，我强烈推荐你阅读马丁·福勒的定义。掌握依赖注入将把你的测试能力带到一个全新的水平。

如果你需要更多一点的上下文来理解我的 *ItemWorker* 的实现，你可以看到下面的*网络协议*、 *CacheRepositoryProtocol* 、 *ItemRequest* 和 *Item* 的定义。

# xct 预期

现在我们有了一个满足需求的 *ItemWorker* ，我们应该编写一个测试来断言需求确实得到了满足。只有当*项*没有被缓存时，我们的 worker 类才会从网络上获取*项*。

首先，我们将定义我们的测试用例。我喜欢真正描述性的，使用函数名来陈述正在测试什么，以及应该发生什么。因此，如果在未来某个时间点这个测试失败了，就很容易理解出了什么问题。

然后，我们应该模拟*网络*和*缓存存储库*，因为我们不能让我们的测试依赖于测试设备上的网络可用性或缓存状态。如果代码正确，一个好的测试应该总是通过，如果代码不正确，它应该总是失败。

请注意我是如何添加属性*cachedObjectToBeReturned*来轻松控制一个假想的场景 *CacheRepository* 状态的。

现在我们已经准备好实现我们的测试用例了。让我们从没有缓存的情况开始， *ItemWorker* 要从*网络*中取。我们将使用 *XCTestExpectation* 来完成。

一个 *XCTestExpectation* 是你现在正在创造的、将来要实现的承诺(使用`*expectation*` *)。履行()*)。它与“wait(for expectations:，timeout:)”方法一起使用，该方法断言在给定的时间间隔内所有的期望都得到满足。看一看第一个测试用例的实现，这样您就可以理解这意味着什么。也可以阅读苹果的[文档。](https://developer.apple.com/documentation/xctest/asynchronous_tests_and_expectations/testing_asynchronous_operations_with_expectations)

上面的测试应该通过，因为:

*   *CacheRepositoryMock* 不返回任何项目。
*   调用了 NetworkSpy ，实现了预期。
*   *等待*等待的期望在 1 秒钟超时前实现。

现在，对于测试用例，其中 *CacheRepository* 确实缓存了*项*，并且我们不应该从*网络*请求它，我们将使用来自 *XCTestExpectation* 的属性 *isInverted* 。这使得期望函数与非反转函数完全相反。这意味着 *wait(for expectations:，timeout:)* 现在断言在预期实现之前超时已经过期。对于反向期望，如果期望实现了，测试就失败了。并且这是断言代码在未来不被执行的完美方式。

上面的测试应该通过，因为:

*   *CacheRepositoryMock* 返回一个项目。
*   工人没有调用 *NetworkSpy* 就返回了这个项目，所以期望永远不会实现。
*   在*等待*方法上定义的 1 秒超时时间到期。

# 专业提示:使用合理的超时

```
wait(for: [expectation], timeout: 10)
```

在上面的代码中，如果预期没有反转，并且在 1 秒钟内实现，测试将通过，而不需要实际等待整个 10 秒钟。但另一方面，如果它是一个倒置的期望，测试将需要 10 秒来结束断言。

测试需要很长时间才能完成，这对你的项目是有害的。如果你在一个大型的企业应用程序上工作，这一点尤其重要，因为测试会使 CI/CD 机器变得混乱，降低团队的生产力并耗费公司的资金。

感谢您的阅读！我希望这是一次有益的学习。小心和良好的编码！