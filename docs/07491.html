<html>
<head>
<title>Transforming nested json with pyjq: recommended for a deep night sleep</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 pyjq 转换嵌套 json:推荐用于深度睡眠</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/transforming-nested-json-with-pyjq-recommended-for-a-deep-night-sleep-3870b1c88091?source=collection_archive---------3-----------------------#2022-03-30">https://blog.devgenius.io/transforming-nested-json-with-pyjq-recommended-for-a-deep-night-sleep-3870b1c88091?source=collection_archive---------3-----------------------#2022-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/cc4c7a9206725d4146ad8dc3bfdc4b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ZJni5cheK_Jwv4cURDg_BQ.jpeg"/></div></figure><p id="29a7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你以前被分配过解析、过滤和转换 json 文件的任务吗？还记得遍历节点和属性并检查传入文件中的空值吗？还记得当他们改变上游的数据结构时，你有多沮丧吗？让我告诉你一个好消息，pyjq 可以最小化你的代码并保护它免受上游模式变化的影响。</p><p id="9003" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">jq 是什么？</p><blockquote class="kq kr ks"><p id="a49c" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">jq 程序是一个“过滤器”:它接受输入，产生输出。有许多内置的过滤器，用于提取对象的特定字段，或者将数字转换为字符串，或者其他各种标准任务。</p><p id="e0e7" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">来源:https://stedolan.github.io/jq/manual/<a class="ae kw" href="https://stedolan.github.io/jq/manual/" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="5eb8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">红色药丸还是蓝色药丸</strong>？</p><p id="e616" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你好 Neo，pyjq 是你的“瑞士军刀”——一个将解决许多挑战的库，如过滤、映射和转换结构化数据。要打印下面例子中的 c 值，可以写最简单的脚本<strong class="jt io"> <em class="kp"> .a.b.c </em> </strong>交给 pyjq 库，pyjq 有了输入文件和脚本，它会施展魔法打印出“嘿漂亮”:)</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ccfc" class="lg lh in lc b gy li lj l lk ll">{<br/>    "a": {<br/>        "b": {<br/>            "c": {<br/>                "hey beautiful"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="68bd" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如何开始？</h1><blockquote class="kq kr ks"><p id="c3a5" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">你将需要 flex、bison (3.0 或更新版本)、libtool、make、automake 和 autoconf 来构建 jq。通过自制、APT 或其他方式安装它们。<br/>安装完以上内容后，您可以继续安装 pyjq:</p><p id="e402" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">pip 安装 pyjq</p><p id="29e4" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">来源:<a class="ae kw" href="https://pypi.org/project/pyjq/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/pyjq/</a></p></blockquote><p id="f07c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在你有了你的机器设置，让我们开始写一个简单的例子，你有一个 json 文件需要在保存到 dynamoDB 之前重新格式化，json 文件有<em class="kp">名称</em>和<em class="kp">城市</em>属性，但是数据需要保存为<em class="kp">职员</em>和<em class="kp">地址</em>。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3c6c" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 1:</em></strong></span><span id="282c" class="lg lh in lc b gy mj lj l lk ll">input1 = {<br/>            "name": "Saif",<br/>            "city": "Irbid"<br/>        }<br/>result1 = pyjq.<strong class="lc io"><em class="kp">one</em></strong>('{Staff: .name , Address: .city}', input1)</span><span id="72e8" class="lg lh in lc b gy mj lj l lk ll">print(result1)</span><span id="d3e7" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'Staff': 'Saif', 'Address': 'Irbid'}</span></pre><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/c6ebaeb25e020194a810e29101d3310f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ugc_yTU9x72IGGhCkhTZXg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">pyjq 将替换每个以()开头的键。)和来自输入的键值(如果存在的话)</figcaption></figure><p id="4c88" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在您已经熟悉了 pyjq 正在做的事情，让我们来讨论您将经常遇到的更高级的案例。</p><blockquote class="mt"><p id="f17a" class="mu mv in bd mw mx my mz na nb nc ko dk translated">C <em class="nd"> ase I:传入属性为空</em></p></blockquote><p id="171c" class="pw-post-body-paragraph jr js in jt b ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko ig bi translated">如果输入中缺少属性，其值将为<strong class="jt io"> <em class="kp">无</em> </strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a818" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 2:</em></strong></span><span id="9fe6" class="lg lh in lc b gy mj lj l lk ll"># name attribute is missing from <em class="kp">input1</em><br/>input1 = {<br/>            "city": "Irbid"<br/>        }<br/>result1 = pyjq.one('{Staff: .name , Address: .city}', input1)<br/>print(result1)</span><span id="cb32" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'Staff': <strong class="lc io"><em class="kp">None</em></strong>, 'Address': 'Irbid'}</span></pre><p id="b236" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<strong class="jt io"> <em class="kp">无</em> </strong>的情况下，可以使用 if 语句指定默认值:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5751" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 3:</em></strong></span><span id="5150" class="lg lh in lc b gy mj lj l lk ll">input1 = {<br/>            "city": "Irbid"<br/>        }<br/>result1 = pyjq.one("{Staff: (if .name == null then \"Ahmad\" else .name end) , Address: .city}", input1)</span><span id="aa67" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'Staff': 'Ahmad', 'Address': 'Irbid'}</span></pre><blockquote class="mt"><p id="76c7" class="mu mv in bd mw mx nj nk nl nm nn ko dk translated">C <!-- --> ase II:作为数组的传入属性</p></blockquote><p id="db7e" class="pw-post-body-paragraph jr js in jt b ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko ig bi translated">假设您正在接收一个事件列表，但是您对最新的事件感兴趣，假设较高的索引代表最新的事件。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9bc2" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 4:</em></strong></span><span id="d111" class="lg lh in lc b gy mj lj l lk ll">input2 = [{"event": "DELETE", "data": "Saif"}, {"event": "INSERT", "data": "Ahmad"}]<br/>result2 = pyjq.one(".[1]", input2)<br/>print(result2)</span><span id="1fab" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'event': 'INSERT', 'data': 'Ahmad'}</span></pre><blockquote class="mt"><p id="f43b" class="mu mv in bd mw mx nj nk nl nm nn ko dk translated">ase III:处理不同的数据类型，比如整数和字符串</p></blockquote><p id="fad6" class="pw-post-body-paragraph jr js in jt b ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko ig bi translated">jq 提供了一些可以动态转换输入类型的转换器，一个用于整型，另一个用于字符串数据类型。在示例 5 中，我们解析数组中的第二个条目，并使用<strong class="jt io"> <em class="kp"> tonumber </em> </strong>函数将版本从字符串转换为数字</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bfb7" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 5:</em></strong></span><span id="000b" class="lg lh in lc b gy mj lj l lk ll">input3 = [{"event": "DELETE", "status": "False",  "version": "1"},<br/>          {"event": "INSERT", "status": "True", "version": "2"}<br/>          ]</span><span id="aa73" class="lg lh in lc b gy mj lj l lk ll">result3 = pyjq.one("{event_status:.[1]|.status, <br/>                     event_version: .[1]|.version|<strong class="lc io">tonumber</strong>}", input3)</span><span id="1d66" class="lg lh in lc b gy mj lj l lk ll">print(result3)</span><span id="7fe4" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'event_status': 'True', 'event_version': <strong class="lc io">2</strong>}</span></pre><p id="04b3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们想将输入解析为字符串，我们可以应用<strong class="jt io"> tostring </strong>函数，参见示例 6。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="207d" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example 6: </em></strong></span><span id="f8a2" class="lg lh in lc b gy mj lj l lk ll">input3 = [{"event": "DELETE", "status": False,  "version": "1"},<br/>          {"event": "INSERT", "status": True, "version": "2"}<br/>          ]<br/><br/>result4 = pyjq.<strong class="lc io">first</strong>("{event_status: .[]|.status<strong class="lc io">|tostring</strong>, event_version: .[]|.version|tonumber}", input3)<br/>print(result4)</span><span id="2230" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; {'event_status': <strong class="lc io">'false'</strong>, 'event_version': 1}</span></pre><blockquote class="mt"><p id="13e3" class="mu mv in bd mw mx nj nk nl nm nn ko dk translated">ase IV:输入排序</p></blockquote><p id="6d8f" class="pw-post-body-paragraph jr js in jt b ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko ig bi translated">答案是肯定的，可以使用两个函数对输入进行排序:<strong class="jt io"><em class="kp">sort</em></strong>and<strong class="jt io"><em class="kp">sort _ by(expression)</em></strong></p><blockquote class="kq kr ks"><p id="ff74" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><code class="fe no np nq lc b">sort</code>函数对其输入进行排序，输入必须是一个数组。值按以下顺序排序:<strong class="jt io"> null </strong>，<strong class="jt io"> false </strong>，<strong class="jt io"> true </strong>，<strong class="jt io"> numbers </strong>，<strong class="jt io"> strings </strong>，按字母顺序(按 unicode 码点值)排列，在词法顺序对象中</p><p id="0c6b" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">对象的排序有点复杂:首先，通过比较它们的键集(作为按排序顺序排列的数组)来比较它们，如果它们的键相等，则逐个键地比较它们的值。</p><p id="6a63" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><code class="fe no np nq lc b">sort</code>可用于按对象的特定字段排序，或应用任何 jq 过滤器。</p><p id="98e5" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><code class="fe no np nq lc b">sort_by(foo)</code>通过比较<code class="fe no np nq lc b">foo</code>对每个元素的结果来比较两个元素。</p><p id="75f3" class="jr js kp jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">来源:<a class="ae kw" href="https://stedolan.github.io/jq/manual/#TypesandValues" rel="noopener ugc nofollow" target="_blank">https://stedolan.github.io/jq/manual/#TypesandValues</a></p></blockquote><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bf3b" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp">example7:</em></strong></span><span id="620a" class="lg lh in lc b gy mj lj l lk ll">input5 = [None, "Saif", "Ahmad", 1984, True]<br/>result_5 = pyjq.one("<strong class="lc io"><em class="kp">sort</em></strong>", input5)<br/>print(result_5)</span><span id="70c2" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; [None, True, 1984, 'Ahmad', 'Saif']</span><span id="6b33" class="lg lh in lc b gy mj lj l lk ll"><strong class="lc io"><em class="kp">example 8:</em></strong></span><span id="0c51" class="lg lh in lc b gy mj lj l lk ll">input6 = [{"id": 9, "name": "Ahmad"}, {"id": 2, "name": "Saif"},<br/>          {"id": 1, "name": "Ammar"}, {"id": 3, "name": "Asharf"},<br/>          {"id": 5, "name": "Wahid"}]<br/>result_6 = pyjq.one("<strong class="lc io"><em class="kp">sort_by</em></strong>(.id)", input6)<br/>print(result_6)</span><span id="cd95" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; [{'id': 1, 'name': 'Ammar'}, {'id': 2, 'name': 'Saif'}, {'id': 3, 'name': 'Asharf'}, {'id': 5, 'name': 'Wahid'}, {'id': 9, 'name': 'Ahmad'}]</span></pre><blockquote class="mt"><p id="3b6f" class="mu mv in bd mw mx nj nk nl nm nn ko dk translated">让我们把它放在一个 dynamoDB 流例子中</p></blockquote><p id="fa22" class="pw-post-body-paragraph jr js in jt b ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko ig bi translated">现在，我们已经介绍了 pyjq 中的一些主要函数，让我们一起来构建一个关于 dynamoDB 流的场景，每当数据发生变化(更新、删除和插入)时，这个流都会触发 lambda 函数。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nr"><img src="../Images/ad498d73567853ebf0cb545a4fcd644f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qv2dRLRjU5qhSCEu-eRGhQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用 DynamoDB 流和 Lambda 处理项目</figcaption></figure><p id="d8ee" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在下面的例子中，dynamoDB 记录被修改，它被推送到 dynamoDB 流，dynamoDB 流触发了 Lambda。当 Lambda 函数接收到事件时，它将采用<strong class="jt io"> <em class="kp"> modify_event </em> </strong>格式，它将事件作为输入，并使用 pyjq 库应用保存在<strong class="jt io"><em class="kp">modify _ template . txt</em></strong>中的格式，并生成如下图所示的输出。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="31a3" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"><em class="kp"> example 9:<br/></em></strong></span><span id="97a0" class="lg lh in lc b gy mj lj l lk ll"><strong class="lc io"><em class="kp">modify_template.txt</em></strong></span><span id="3b61" class="lg lh in lc b gy mj lj l lk ll">{<br/>    "key_date": .dynamodb.Keys."key.date".S,<br/>    "key_id":   .dynamodb.Keys."key.id".S,<br/>    "new_name": .dynamodb.NewImage.name.S,<br/>    "old_name": .dynamodb.OldImage.name.S<br/>}</span><span id="fff8" class="lg lh in lc b gy mj lj l lk ll"><strong class="lc io"><em class="kp">test.py</em></strong></span><span id="6c12" class="lg lh in lc b gy mj lj l lk ll">modify_event = {<br/>    "eventID": "xxx",<br/>    "eventName": "MODIFY",<br/>    "eventVersion": "1.1",<br/>    "eventSource": "aws:dynamodb",<br/>    "awsRegion": "us-east-1",<br/>    "dynamodb": {<br/>        "ApproximateCreationDateTime": 1611697668,<br/>        "Keys": {<br/>            "key.date": {<br/>                "S": "2020-11-03"<br/>            },<br/>            "key.id": {<br/>                "S": "Id12345"<br/>            }<br/>        },<br/>        "NewImage": {<br/>            "name": {<br/>                "S": "Saif"<br/>            }<br/>        },<br/>        "OldImage": {<br/>            "name": {<br/>                "S": "Ahmad"<br/>            }<br/>        }<br/>    }<br/>}<br/><br/><br/>def import_template(template_name):<br/>    parent_path = str(pathlib.Path(__file__).parent)<br/>    path = parent_path + '/' + template_name<br/>    with open(path, 'r') as file:<br/>        template = file.read().replace('\n', '')<br/>        return template<br/><br/><br/>modify_template = import_template('modify_template.txt')<br/>formatted_modify = pyjq.one(<strong class="lc io"><em class="kp">modify_template</em></strong>, modify_event)<br/>print(formatted_modify)<br/></span><span id="99dc" class="lg lh in lc b gy mj lj l lk ll">&gt;&gt; <em class="kp">{<br/>    "key_date": .dynamodb.Keys."key.date".S,<br/>    "key_id":   .dynamodb.Keys."key.id".S,<br/>    "new_name": .dynamodb.NewImage.name.S,<br/>    "old_name": .dynamodb.OldImage.name.S<br/>}</em></span></pre><blockquote class="mt"><p id="b0cf" class="mu mv in bd mw mx nj nk nl nm nn ko dk translated">我从使用 pyjq 中得到了什么？</p></blockquote><ol class=""><li id="4a00" class="ns nt in jt b ju ne jy nf kc nu kg nv kk nw ko nx ny nz oa bi translated">您将模板从代码中分离出来，您可以将模板保存为资源下的文本文件，并且无论何时上游发生变化，您都可以在不接触代码的情况下更改模板。</li><li id="723f" class="ns nt in jt b ju ob jy oc kc od kg oe kk of ko nx ny nz oa bi translated">您不必使用 if/else 检查嵌套 json 中的空节点，而是从代码中取出该逻辑，并将其添加到模板中。</li><li id="e0b9" class="ns nt in jt b ju ob jy oc kc od kg oe kk of ko nx ny nz oa bi translated">您还可以使用 tonumber 和 tostring 在模板中进行一些数据转换。</li><li id="2ea3" class="ns nt in jt b ju ob jy oc kc od kg oe kk of ko nx ny nz oa bi translated">可以使用 pyjq 库进行排序、分组、映射等。所有这些都可以放在模板文本文件中。</li></ol><p id="33bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以上所有导致的配置设置可以保存在外部文件中，如 s3，或者任何您喜欢的存储，这样您就不必在每次上游/输出格式改变时重新部署您的代码。</p></div></div>    
</body>
</html>