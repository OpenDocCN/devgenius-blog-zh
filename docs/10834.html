<html>
<head>
<title>Testing in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产中的测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/testing-in-production-a8deeea29459?source=collection_archive---------6-----------------------#2022-12-03">https://blog.devgenius.io/testing-in-production-a8deeea29459?source=collection_archive---------6-----------------------#2022-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="392a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在有些情况下，尝试在预生产环境中创建测试条件的成本非常高，因此在生产环境中进行测试会更好。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4842f761c97e90d9e4fbf6a0f546a742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqNFfAjHTYA5Tw-Atk-Z5Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://pixabay.com/es/illustrations/posible-imposible-oportunidad-4058672/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><blockquote class="lc ld le"><p id="b250" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">右移测试是一种在后期生产环境中持续测试软件的方法。也被称为“生产中的测试”，这种方法帮助软件开发人员发现新的、意想不到的场景，这些场景可能在开发环境中没有被检测到。右移测试的目标是确保应用程序在生产使用过程中的正确行为、性能和可用性。https://www.browserstack.com/guide/testing-in-production<br/>T3</p></blockquote><p id="2051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工程师应该找到解决问题的最佳和最便宜的方案。在我看来，在软件领域，大多数人害怕使用产品来检查问题，因为对于某些问题来说，产品只是最便宜的使用环境。</p><p id="6d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并不是所有的问题都是一样的，但是我们知道创建短的反馈循环来获得早期反馈通常是更便宜的选择。例如，TDD 是创建这些短反馈循环来开发我们的解决方案的一个很好的方法。<br/>但答案并不总是在我的实验室中进行测试，有时我们不得不去真实世界进行测试，因为有时试图创建一个短的反馈循环，我们会创建一个很长的循环。让我们想象一下，我们想要了解我们的新服务将如何处理 web 应用程序中客户的流量。对许多人来说，性能测试是答案，但是:</p><ul class=""><li id="57ef" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">我们有多少客户？</li><li id="6e82" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">它们在时间上的分布如何？</li><li id="039a" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">他们要做哪些请求？</li><li id="fda4" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">我从哪里获得数据来支持我的测试环境呢？</li><li id="198f" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">如何构建性能测试环境？</li></ul><p id="ae6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的服务是新的，你将如何回答这些问题，猜测？。它们对于查看我们的服务在当前环境下是否会正常运行至关重要。</p><p id="8636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，所有这些听起来都是大量的工作，有许多不确定性和环境，创建性能测试试图理解和复制真实客户端的行为。但是还有另一种选择，在生产中测试。使用生产作为我们的实验室来检查我们的服务是否如我们所愿。下一个问题是如何降低将生产用作实验室的风险？。</p><h2 id="d388" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">生产测试的风险</h2><p id="144f" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">为了允许我们在生产中测试某些东西，我们需要有一种方法来衡量生产表现的好坏。所以我们需要在可观测性上投入一些努力，我们需要一个可观测的系统。</p><blockquote class="lc ld le"><p id="eb25" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir">可观测性</strong>是一个衡量系统<a class="ae lb" href="https://en.wikipedia.org/wiki/System" rel="noopener ugc nofollow" target="_blank">的内部状态</a>可以从其外部输出的知识中推断出来的程度。(<a class="ae lb" href="https://en.wikipedia.org/wiki/Observability" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></blockquote><p id="8020" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在软件系统中，可观察性是收集关于程序执行、模块内部状态和组件间通信的数据的能力。</p><p id="1c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可观察性的三个支柱是:</p><ul class=""><li id="96ff" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">日志:一个<em class="lf">事件日志</em>是一个不可变的、有时间戳的记录，记录了随时间发生的离散事件。</li><li id="c5a3" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">跟踪:一个<em class="lf">跟踪</em>是一系列因果相关的分布式事件的表示，这些事件对通过分布式系统的端到端请求流进行编码。</li><li id="8dca" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">指标:指标是在一段时间间隔内测量的数据的数字表示。度量可以利用数学建模和预测的能力来获取系统在现在和未来的时间间隔内的行为知识。</li></ul><p id="6942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">围绕这一切，我们将需要警报来了解生产中的重要问题。</p><blockquote class="lc ld le"><p id="6f77" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">警报仍然应该是以硬故障为中心和以人为中心的。使用监控数据进行警报的目标没有改变，即使警报的范围已经缩小。</p><p id="5d3b" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">通过记录和公开系统所有组件(负载平衡器、缓存、队列、数据库和无状态服务)随时间变化的高级指标，监控数据应始终提供分布式系统整体健康状况的鸟瞰图。伴随警报的监控数据应提供深入系统组件和单元的能力，作为任何事件响应中的第一个呼叫端口，以诊断任何故障的范围和粗略性质。</p><p id="074d" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">此外，在出现故障的情况下，监控数据应该能够立即提供故障的影响以及所部署的任何修复的效果的可见性。</p><p id="82e8" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">最后，为了使随叫随到的体验更加人性化和可持续，所有警报(以及用于产生警报的监控信号)都需要<em class="iq">可操作</em>。<br/><a class="ae lb" href="https://ebookreading.net/view/book/EB9781492033431_5.html" rel="noopener ugc nofollow" target="_blank">https://ebookreading.net/view/book/EB9781492033431_5.html</a></p></blockquote><p id="384f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，即使我们有一个可观察的系统，我们也需要工具来更快地回滚我们的更改，以最小化可能的问题，一些工具与此相关:</p><ul class=""><li id="2203" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><a class="ae lb" href="https://martinfowler.com/articles/feature-toggles.html" rel="noopener ugc nofollow" target="_blank">功能切换</a></li><li id="aa02" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank">金丝雀释放</a></li><li id="97aa" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://martinfowler.com/bliki/DarkLaunching.html" rel="noopener ugc nofollow" target="_blank">暗发射</a></li><li id="5246" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://javi-kata.medium.com/ci-cd-for-dummies-b45ed917f9dc?sk=28eede1d5fec71121eea4954583130e9" rel="noopener">连续部署</a></li></ul><h2 id="d358" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">A/B 测试</h2><blockquote class="lc ld le"><p id="8bcd" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">我们最优先考虑的是通过早期和持续交付<br/>有价值的软件来满足客户<br/>。【https://agilemanifesto.org/principles.html】T5<br/>T6】</p></blockquote><p id="c415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何衡量我们正在构建的软件对客户的价值？大多数公司试图通过与客户谈论他们的偏好或问题，构思解决方案，实施并发布给他们的客户来做到这一点。这种方法的问题是，每一步都会丢失前一步的信息，即使是第一次调查也是非常主观的，我们的假设可能总是错误的。</p><p id="12d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能以不同的方式做到这一点吗？我们能验证我们的假设并减少投资去做不正确的事情吗？。这就是假设驱动开发的意义所在，它是关于在研究、构建和部署之间创建一个短的反馈回路。<br/>连续交付/部署是关键，但也是使用产品进行测试的关键，使用一个非常小的功能来帮助我们验证我们必须在我们决定的方向上投入更多的假设。</p><p id="dc2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.linkedin.com/pulse/why-45-all-software-features-production-never-used-david-rice/" rel="noopener ugc nofollow" target="_blank">为什么生产中 45%的软件特性从未使用过。</a></p><blockquote class="lc ld le"><p id="cc30" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir"> A/B 测试</strong>(也称为<strong class="jp ir">桶测试</strong>、<strong class="jp ir">分割运行测试</strong>或<strong class="jp ir">分割测试</strong>)是一种用户体验研究方法论。A/B 测试由一个随机实验组成，通常涉及两个变量(A 和 B)，尽管这个概念也可以扩展到同一变量的多个变量。它包括统计假设检验或统计学领域中使用的“双样本假设检验”的应用。A/B 测试是一种比较单个变量的多个版本的方法，例如通过测试受试者对变量 A 和变量 B 的反应，并确定哪个变量更有效。<br/><a class="ae lb" href="https://en.wikipedia.org/wiki/A/B_testing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/A/B_testing</a></p></blockquote><h2 id="2c04" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">简化您的测试架构</h2><p id="83e9" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">你真的需要这么多的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/long-lived-environments-93f097786aa6?sk=84eba6ba390918a6a9a89fff6454e3b4">长寿环境吗？保守地说，你只需要两个:</a></p><ul class=""><li id="9dcf" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">脚手架</li><li id="684e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">生产</li></ul><p id="601c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长期环境的维护成本很高，通常我们用它们来沟通团队中的部门或角色，不要再这样做了。</p><p id="494a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们应该在生产中多试验，生产是更接近生产的环境。</strong></p></div></div>    
</body>
</html>