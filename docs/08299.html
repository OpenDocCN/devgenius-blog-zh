<html>
<head>
<title>The Compression Chronicles: Huffman Encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">压缩编年史:霍夫曼编码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-compression-chronicles-huffman-encoding-ab063e28dfb1?source=collection_archive---------8-----------------------#2022-06-03">https://blog.devgenius.io/the-compression-chronicles-huffman-encoding-ab063e28dfb1?source=collection_archive---------8-----------------------#2022-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">霍夫曼编码是一种无损压缩数据的方式。它用于传统的压缩格式，如 GZIP，PKZIP 等。它也用于(稍加修改)压缩图像数据到。png 格式。</p><p id="abbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">算法背后的想法很简单，比如我有一个文本，说“我在酒吧吃了一个苹果”。这个句子包含 23 个字符，这相当于总共 23×8 位(字符的大小)= 184 位。然而，我们实际上并没有使用 1 字节(8 位)所允许的全部 256 个 unicode 字符。事实上，我们只使用了 10 个，并且我们在这些发行版中使用它们…</p><p id="3401" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">char | occurrences<br/>———<br/>e | 2<br/>I | 1<br/>l | 1<br/>a | 6<br/>| 6<br/>n | 1<br/>p | 2<br/>b | 1<br/>r | 1<br/>t | 2</p><p id="90df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们采用这个新的字母表，只用 4 位来包含我们的 10 个独特的字符(剩下 6 位是为了好玩)。我们可以把尺寸减半！而且只需要用 87 位！但在这种情况下，我们能做得更好吗？霍夫曼同意了。</p><p id="2390" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们仔细看看这些情况，如果我们能为这些频繁出现的字符使用更少的空间，比如 a 和空格，那就太好了。如果我们能创造出用更少的比特来表示的字母表，会怎么样呢？假设 a 是 01，空间是 10，那么我们可以从我们的大小中删除 2*2*6 位=&gt; 75 位。但是我们怎么知道 0110 是“a”还是字母表中的其他字符呢？答案是，用一棵树！我们可以说每一个左边的分支给二进制数加一个“0 ”,每一个右边的分支加一个“1 ”,然后我们将把我们的字符放在叶子上，这样我们可以最小化频繁使用的字符的深度。下面是一个简单字符串“AABBBC”的示例树</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4e20c72b9bec73b8ce574f1ceb81de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-vlQZmFBwYnRcKy8E4ZyQ.png"/></div></div></figure><p id="34db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“_”是虚拟节点，真正的编码在叶子上，左分支为 0，右分支为 1。(B =&gt; 0，C =&gt; 10，A =&gt; 11)。请注意，由于 B 出现的频率最高，我们的树将它放在更靠近顶部的位置，因此可以使用更少的比特进行编码。</p><p id="539f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们如何创建这样一棵树呢？让我们通过创建一个交互式 java 程序来研究这个算法。</p><h1 id="828b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">密码</h1><p id="73ff" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们从导入开始，为树创建节点，并为节点创建一个比较器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="ac58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这非常简单，它只引用了它的子元素(如果存在的话)和它所代表的字符以及它出现的次数。</p><p id="91f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们添加类文件的其余部分。</p><p id="52ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Huffman.java</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4661" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了很多事情，所以我们将一步一步地来。</p><p id="ae85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">变量和构造函数</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="941f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们创建一个根节点，这是我们访问树的顶部的方式。我们还创建了 charToBinaryMap，以便在确定了正确的映射后对字符串进行编码。我们还有一个基本的构造函数和一个根的 getter。</p><p id="d96d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">编码</strong></p><p id="fb53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们类中最复杂的函数，它负责为我们的字符串创建最优树。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><ol class=""><li id="afa3" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">首先，我们接受一个人类可读的字符串，比如“我在酒吧吃了一个苹果”</li><li id="e79a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">接下来，我们在字符和它在字符串中出现的次数之间创建一个映射</li><li id="1df9" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">然后，我们将为所有的事件映射条目创建一个 priorityQueue(将事件编号最小的条目放在队列的前面)</li><li id="6026" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">我们遍历这个队列，得到两个最小的节点，并用两个组合的出现值创建一个虚拟父节点，然后我们将这个虚拟节点放入队列，并进行迭代，直到队列完成，给出我们的树！</li><li id="a9c7" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">我们使用助手函数在线创建 charToBinaryMap 并打印出事件图</li><li id="6892" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">然后，我们打印出编码的统计数据，如编码前的位数与编码后的位数以及压缩率。</li></ol><p id="426f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">createchartobinarimap</strong></p><p id="88a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个简单的按顺序遍历树，因为实际的角色节点将只在叶子上，我们只在两个孩子都为空时添加到映射中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="851b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解码</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="e2ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将接收一个编码的字符串，遍历树，直到遇到一片叶子(遵循模式' 1' = &gt;向右' 0' = &gt;向左)。一旦它到达一片叶子，它将把那个字符添加到我们的字符串生成器中，并返回到根，它将继续这个模式，直到它在二进制字符串的末尾。</p><p id="cb62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">客户端</strong></p><p id="bae0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以运行它了！！！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c276" class="ms kv in mo b gy mt mu l mv mw">Char | Huffman code | occurrences<br/>----------------------------------<br/>e   |  000  |  2<br/>I   |  0010  |  1<br/>l   |  0011  |  1<br/>a   |  01  |  6<br/>    |  10  |  6<br/>n   |  1100  |  1<br/>p   |  1101  |  2<br/>b   |  11100  |  1<br/>r   |  11101  |  1<br/>t   |  1111  |  2<br/>Original bits:184<br/>Binary Encoding: 00101001111100010011100100111011101001100010011111100110111000111101<br/>After bits (content): 68<br/>After bits (tree): 103<br/>After bits (total): 171<br/>Compression ratio: 0.9293478260869565<br/>I ate an apple at a bar</span></pre></div></div>    
</body>
</html>