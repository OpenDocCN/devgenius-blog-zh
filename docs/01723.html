<html>
<head>
<title>Essential Problem-Solving Patterns for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的基本问题解决模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/problem-solving-patterns-to-know-javascript-d91da5ae6fde?source=collection_archive---------8-----------------------#2020-07-10">https://blog.devgenius.io/problem-solving-patterns-to-know-javascript-d91da5ae6fde?source=collection_archive---------8-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/97330e5054a32fd0e9f47dd6e01c632e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*adtnu61uWsywvQMt.gif"/></div></div></figure><p id="d3b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几周里，我在做项目和为面试而学习的同时，一直在努力提高算法水平。一路走来，我遇到了一些有用的策略，想和全世界分享一下！</p><p id="d9fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我见过的一些大的:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/50c313b971168566cffd40f0ac20202d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rur65XT4GPISgLlPCK8rdg.png"/></div></div></figure><p id="30e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些模式不会帮助你解决你将面临的每一个问题，但它们可以大大提高你的机会。本文将讨论前三个:频率计数器、多指针和滑动窗口。首先，我们来谈谈…</p><h1 id="30c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">频率计数器模式</strong></h1><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/e50bdc7678fc66124dee52d30d58de40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Lm46P9xgSOlAhppo"/></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fa2a418893890e6704a6129da57092c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*bpjd3SK4WOdHWi7afmtbFg.png"/></div></figure><p id="c6f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">频率计数器模式在需要比较多条数据/输入的问题中最有用。例如，您可能会尝试查看两个输入是否由相似的值组成，是否是彼此的变位组合，或者一个值是否包含在另一个值中。<strong class="ka ir">频率计数器模式可以将算法的时间复杂度降低到O(n)而不是O(n ) </strong>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/f1bc06bcbbd1a944ebd7de6efb84a1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t76LI4vlsx9evBvE4YK1aA.png"/></div></div></figure><p id="807a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种不使用频率计数器模式的方法涉及如下所示的嵌套循环:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/8616d45318df4a35a237dbe547921f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_eaZUOwC3PJ8FzRBnPI-g.png"/></div></div></figure><p id="a11a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是由于两个独立的循环比嵌套循环好，我们可以通过应用频率计数器模式来进一步优化我们的解决方案。这看起来像是:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/9b6d930c7808952086185bf9d35b6e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlmLJYMe1kTMPW-Ya7s87A.png"/></div></div></figure><p id="7513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码遍历每个数组，并为每个数组创建一个对象。该对象的键是每个数组的元素，并映射到表示原始数组中每个元素的频率的值。</p><p id="dcba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们遍历第一个对象，检查它的每个平方键是否出现在第二个对象中。我们还检查相应的频率是否相等。如果满足上述所有条件，我们返回true，否则，我们返回false。接下来，让我们把注意力转移到多指针模式上。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="3afa" class="lb lc iq bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated"><strong class="ak">多指针模式</strong></h1><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/6370849084c2f4412be7e2ecbb87a081.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*P07ZLtMjSA-tjBqx.gif"/></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/68a0e4b199ce07d4c02761af3974616c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*J1hVVptwCTEuXIjD6TaWqg.png"/></div></figure><p id="a4f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多指针模式是避免嵌套循环的另一个好方法。这种模式通常以排序的输入为条件。在给定一个字符串或数组，并要求你根据某种条件找到一对的问题中，这很有用。它也有助于在排序列表中查找唯一值。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/c8ebd5d37a4b77fa04c0bab60d0f85b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMQHHk1Dt5cSEzjxiWLJ3g.png"/></div></div></figure><p id="43a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，一个简单的解决方案包含一个嵌套循环，看起来像这样:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/2452e5c8e2ccbbfb15b2cb93d3dc80fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDzRyLUj4pgfJ345nZKHvg.png"/></div></div></figure><p id="a8ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码从外部循环中的第0个元素开始，比较内部循环中从第1个元素开始的所有其他元素，然后返回总和为零的元素。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/0fc7178f77900c869cd7511464840fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHamtzUC_m2WNG1eFMNyww.png"/></div></div></figure><p id="6c04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面，我们的循环只继续while ( <em class="mv">左&lt;右</em>)，而不是while ( <em class="mv">左≤右</em>)。这是因为我们不想在到达输入数组的最中心元素时返回一个误报。</p><p id="e5af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把注意力转向第三种也是最后一种模式，滑动窗口模式。</p><h1 id="369f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">滑动窗口模式</strong></h1><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/97deaf675ccdf9cd2707a3a3d9ff8506.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*KPlZtEY-nAmBYzHm.gif"/></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/66cd7e8be03f25f0ccf904fb31df1ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*2xobVsA8_kY7jYHf-1JHfA.png"/></div></figure><p id="7a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">窗口通常从左向右移动。一个常见的应用是从列表的开始移动到末尾。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/cdfa0568e58ddb683276352876cd8136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1RcWilFl75qpwwlmgcaUA.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/a8627722d6138880991f1fff094d2cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAViTLorbowyU0UoufMzQA.png"/></div></div></figure><p id="b0ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，简单的解决方案包括一个嵌套循环，从外层循环的第0个元素开始。您滑动到第二个(内部)循环中长度为<em class="mv"> num </em>的窗口，并将外部循环的索引向前移动一位。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/ccb63b73e5260168a6dba5433b41eaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziq5piyf-PdkaJ4eR3wChw.png"/></div></div></figure><p id="d5e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重构解决方案的一个明显的好处是我们只对整个数组<strong class="ka ir">循环一次</strong>。让我更详细地解释一下这是如何工作的:假设你在寻找一个数组中任意三个元素的最大和。首先，从第0个索引开始，对前三个元素求和，然后保存总和。然后，不是开始一个新的循环，从第一个索引开始对接下来的三个元素求和，而是减去第零个元素，然后加上第四个元素。您检查该金额是否大于您之前保存的金额。如果是的话，你就用新的总和代替以前的总和。如果没有，你继续前进。滑窗就是这个意思！</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这能帮助你踏上自己的算法之旅。如果你有任何问题或反馈，你可以给我留言<a class="ae nd" href="https://iamraq.github.io/" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></div></div>    
</body>
</html>