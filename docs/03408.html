<html>
<head>
<title>Build a Custom React Search Bar Component Using a Dynamic Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用动态正则表达式构建自定义 React 搜索栏组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-custom-react-search-bar-component-using-a-dynamic-regex-cd89fdd496f5?source=collection_archive---------0-----------------------#2020-10-31">https://blog.devgenius.io/build-a-custom-react-search-bar-component-using-a-dynamic-regex-cd89fdd496f5?source=collection_archive---------0-----------------------#2020-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/94b7f6704279f2657a5df82ba57c75b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pivERpgyMMNAnlu08hPutA.png"/></div></div></figure><p id="438b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我一直在使用 React Hooks 为我妈妈今年的圣诞礼物构建一个渐进式 web 应用程序；这是她的烹饪书和食谱的数字化版本，都在一个地方。</p><p id="dc14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">她有多少食谱，这让我想到，如果她想找到一个食谱，简单地按字母顺序排列可能不会像我希望的那样直观。</p><p id="6184" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这启发我创建了一个搜索栏，当用户输入时，而不是点击按钮时，它会过滤食谱搜索结果。</p><p id="8ba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面，看看我们努力实现的最终目标。希望很明显这是<strong class="jx io">只是一个模板</strong>，并且有<strong class="jx io">个假配方</strong>——我妈妈没有一个叫做“奇怪的东西”的配方！。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">请注意，它只显示菜肴名称中带有当前值(键入的字符)的菜肴</figcaption></figure><p id="8930" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将讨论我是如何制作搜索栏，并在应用程序中实现它的。</p><p id="79b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这包括几个部分，我将逐一介绍这些主题:</p><ol class=""><li id="c68c" class="ld le in jx b jy jz kc kd kg lf kk lg ko lh ks li lj lk ll bi translated">创建 SearchBar 组件</li><li id="6029" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">在我们的应用程序组件中使用钩子包含必要的状态(作为道具传递给 SearchBar 组件)</li><li id="e72f" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">创建一个动态正则表达式，使用搜索栏输入的状态来匹配每个配方。</li><li id="b3dc" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">使用一个 React 钩子(<code class="fe lr ls lt lu b">useEffect</code>)，调用一个 helper 函数，使用 regex 过滤输入状态每次变化的结果。</li></ol><p id="5385" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想亲自看看这个项目，我在这里链接了 Github 库<a class="ae lv" href="https://github.com/tfunk2/the-real-kates-kitchen" rel="noopener ugc nofollow" target="_blank">。此外，我的方法只是制作这种东西的一种方法，我确信还有许多其他的可能性，而且很多可能是更好的方法。现在，让我们开始第一步吧！</a></p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="60ff" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">SearchBar 组件</h1><p id="f26a" class="pw-post-body-paragraph jv jw in jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">如果您正在阅读这篇文章，希望您熟悉如何创建自己的 React 组件，所以我就不赘述了。</p><p id="ba16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建这个组件只是为了成为一个<code class="fe lr ls lt lu b">&lt;div&gt;</code>容器，它包含了<code class="fe lr ls lt lu b">&lt;input&gt;</code>(搜索栏本身)和“X”<code class="fe lr ls lt lu b">&lt;button&gt;</code>，后者清除输入中的文本字段。</p><p id="1707" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看我以当前形式制作的整个组件:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ng ky l"/></div></figure><p id="5913" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们按照重要的路线来划分:</p><p id="a33c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4 </strong>:从道具中析构一些我们需要的变量，分别是<code class="fe lr ls lt lu b">query</code>、<code class="fe lr ls lt lu b">setQuery</code>、<code class="fe lr ls lt lu b">activePage</code> ( <code class="fe lr ls lt lu b">activePage</code>只是用来改变我们<code class="fe lr ls lt lu b">&lt;input&gt;</code>中作为占位符的文字)。我们还没有在<code class="fe lr ls lt lu b">App</code>组件中为它创建状态，但是我们知道为了创建一个受控的表单，我们需要一个从状态中获取值的输入。于是我把那个状态命名为<code class="fe lr ls lt lu b">query</code>，设置<code class="fe lr ls lt lu b">query</code>状态的函数就是<code class="fe lr ls lt lu b">setQuery</code>。</p><p id="8e98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">5–7</strong>:辅助函数，用于处理第<strong class="jx io">24–28</strong>行中的“X”按钮的逻辑。当“X”按钮被点击时，我们将调用我们从 props 中析构的<code class="fe lr ls lt lu b">setQuery</code>函数，并将状态重置回空字符串。实际上，我们正在将<code class="fe lr ls lt lu b">query</code>重置回它的原始状态(我们将在下一节中查看该状态并作为道具传递)。</p><p id="c1b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 15 </strong>:如上所述<code class="fe lr ls lt lu b">&lt;input&gt;</code>的<code class="fe lr ls lt lu b">value</code>支柱需要设置到<code class="fe lr ls lt lu b">query</code>的状态。</p><p id="0509" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 22 </strong>:在每次更改时(每个输入的字符)，我们用<code class="fe lr ls lt lu b">setQuery</code>功能将<code class="fe lr ls lt lu b">query</code>的状态设置为文本字段中输入的内容。</p><p id="51e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是实际创建我们期望作为道具的状态。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="dc3f" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">创造状态&amp;作为道具传递</h1><p id="93c0" class="pw-post-body-paragraph jv jw in jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">我们知道 SearchBar 组件需要一些不同于 App 组件的东西作为道具，我决定把我所有的状态都放在 App 组件中。这就是我们接下来要做的。下面是使用 React 钩子创建的状态，具体是这里的<code class="fe lr ls lt lu b">useState</code>:</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="6f53" class="nl me in lu b gy nm nn l no np">const [activePage, setActivePage] = useState("main");</span><span id="df75" class="nl me in lu b gy nq nn l no np">const [query, setQuery] = useState("");</span></pre><p id="76a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我前面提到的，我只是使用了<code class="fe lr ls lt lu b">activePage</code>状态来改变占位符中的文本，并不是搜索栏功能的一部分。</p><p id="86f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面也提到了，我把<code class="fe lr ls lt lu b">query</code>的原始状态设置为空字符串。</p><p id="caa4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经创建了状态和一个改变状态的函数(<code class="fe lr ls lt lu b">setQuery</code>)，我们可以将它作为一个道具传递给 SearchBar 组件:</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="149c" class="nl me in lu b gy nm nn l no np">&lt;SearchBar<br/>  <em class="nr">query</em>={query}<br/>  <em class="nr">setQuery</em>={setQuery}<br/>  <em class="nr">activePage</em>={activePage}<br/>/&gt;</span></pre><p id="228f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我们的 SearchBar 组件连接到我们的 App 组件一样，它会随着用户的输入而改变查询的状态。</p><p id="4093" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还将为我创建的名为<code class="fe lr ls lt lu b">MainDishes</code>的不同组件创建一个状态。这个组件保存所有的主菜菜谱和必要的函数，以便在<code class="fe lr ls lt lu b">query</code>状态改变时过滤菜谱。我们将在接下来的几节中讨论这一点。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="8077" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">动态正则表达式</h1><p id="aa4c" class="pw-post-body-paragraph jv jw in jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">我们将使用这个正则表达式来确定这道菜是否应该从结果中过滤掉。为了使正则表达式是动态的，需要根据变化的变量来创建它。</p><p id="dbe9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="nr">我们想要的</em> : </strong>如果用户键入“Blu”，正则表达式应该是<code class="fe lr ls lt lu b">/Blu/</code>，同样，对于其他查询，如果他们键入“abc”，正则表达式应该是<code class="fe lr ls lt lu b">/abc/</code>。</p><p id="6d9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过使用<code class="fe lr ls lt lu b">new RegExp</code>语法创建一个这样的正则表达式。</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="723e" class="nl me in lu b gy nm nn l no np">let mainDishesRegex = new RegExp(<em class="nr">query</em>, "i")</span></pre><p id="0c79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了分解它，我们创建了一个新的正则表达式，第一个参数是在正斜杠之间的内容，后面的参数是我们想要的标志。</p><p id="bb8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在<code class="fe lr ls lt lu b">mainDishesRegex</code>中，无论用户键入什么(<code class="fe lr ls lt lu b">query</code>)都在正斜杠之间，我使用的唯一标志是<code class="fe lr ls lt lu b">i</code>标志，这使得正则表达式不区分大小写。</p><p id="0ac6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们准备使用这个正则表达式来过滤结果，在本例中，显示的是哪些食谱。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="17d6" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">过滤功能和使用效果</h1><p id="3754" class="pw-post-body-paragraph jv jw in jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">最后一步是创建助手函数，该函数将根据配方名称以及<code class="fe lr ls lt lu b">mainDishesRegex</code>是否匹配该名称来过滤配方。</p><p id="f676" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先让我们来看看我一直在处理的数据:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ng ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">一组对象，每一个都是伪造的配方</figcaption></figure><p id="b34a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经将所有的菜肴放在一个数组中，让我们在这个组件(<code class="fe lr ls lt lu b">MainDishes</code>)中创建一些状态，它将保存应该显示的所有菜肴。这个状态保存了一个过滤后的盘子的数组，我将其命名为<code class="fe lr ls lt lu b">mainRecipesShown</code>:</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="1765" class="nl me in lu b gy nm nn l no np">const [mainRecipesShown, setMainRecipesShown] =<br/>  useState([...recipes])</span></pre><p id="4fb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将初始状态设置为一个填充了<code class="fe lr ls lt lu b">recipes</code>数组内容的数组，因此所有的菜肴都将显示为开始。</p><p id="fcff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，每次<code class="fe lr ls lt lu b">query</code>的状态改变时(每次输入一个字符时)，我们需要调用一个函数来过滤这个数组。这是使用另一个钩子<code class="fe lr ls lt lu b">useEffect</code>的好时机，它允许我们在某些状态改变时执行代码，在本例中是<code class="fe lr ls lt lu b">query</code>:</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="ca52" class="nl me in lu b gy nm nn l no np">useEffect(() =&gt; {<br/>  filterDishes()<br/>}, [<em class="nr">query</em>])</span></pre><p id="10cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这表示，当<code class="fe lr ls lt lu b">query</code>改变时，调用<code class="fe lr ls lt lu b">filterDishes</code>，我们接下来会看到:</p><pre class="kt ku kv kw gt nh lu ni nj aw nk bi"><span id="ca79" class="nl me in lu b gy nm nn l no np">const filterDishes = () =&gt; {<br/>  if(<em class="nr">query</em>.length &gt; 0) {<br/>    let newDishes = [...recipes].filter(<em class="nr">dish</em> =&gt;<br/>      mainDishesRegex.test(<em class="nr">dish</em>.name))<br/>    setMainRecipesShown(newDishes)<br/>  } else if (<em class="nr">query</em>.length === 0) {<br/>    setMainRecipesShown([...recipes])<br/>  }<br/>}</span></pre><p id="8331" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lu b">filterDishes</code>首先查看<code class="fe lr ls lt lu b">query</code>的<code class="fe lr ls lt lu b">length</code>，如果长度大于 0，则取<code class="fe lr ls lt lu b">recipes</code>数组的一个副本，根据表达式<code class="fe lr ls lt lu b">mainDishesRegex.test(<em class="nr">dish</em>.name)</code>是否返回<code class="fe lr ls lt lu b">true</code>或<code class="fe lr ls lt lu b">false</code>进行过滤。</p><p id="5c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个表达式根据我们的动态正则表达式测试每个菜名，如果输入文本字段的字符串在菜名中的某个位置，表达式返回<code class="fe lr ls lt lu b">true</code>，如果不是，则返回<code class="fe lr ls lt lu b"> false</code>，有效地过滤掉不匹配的内容。然后我们简单地将<code class="fe lr ls lt lu b">mainRecipesShown</code>设置为过滤结果的新数组</p><p id="a903" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果<code class="fe lr ls lt lu b">query</code>的<code class="fe lr ls lt lu b">length</code>正好为 0，这是<code class="fe lr ls lt lu b">query</code>的原始状态，那么只需将<code class="fe lr ls lt lu b">mainRecipesShown</code>的状态重置为数组<code class="fe lr ls lt lu b">recipes</code>的副本即可。</p><p id="fa15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们将所有的部分放在一起，每次用户键入一个字符，这个过滤函数将把<code class="fe lr ls lt lu b">mainRecipesShown</code>设置为适当的配方数组，我们可以自由地使用该数组中找到的所有配方创建元素。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="561a" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">结论</h1><p id="660c" class="pw-post-body-paragraph jv jw in jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">这样一个简单的搜索栏是添加一个特性的简单方法，该特性可以让用户更快地找到特定的数据，从而改善整体用户体验。</p><p id="e647" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我又一次学到了一些关于正则表达式的新东西，以及它们是多么有用的一个工具；我希望这篇文章也能帮助你学到一些东西，或者启发你制作一个自己的反应式搜索栏！</p><p id="53af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一如既往，感谢阅读，祝黑客快乐！</p></div></div>    
</body>
</html>