<html>
<head>
<title>Send and Serialize Your cv::Mat using Msgpack and ZeroMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Msgpack 和 ZeroMQ 发送并序列化您的 cv::Mat</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/send-and-serialize-your-cv-mat-using-msgpack-and-zeromq-17c9ce53eacf?source=collection_archive---------2-----------------------#2022-12-11">https://blog.devgenius.io/send-and-serialize-your-cv-mat-using-msgpack-and-zeromq-17c9ce53eacf?source=collection_archive---------2-----------------------#2022-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="87d8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">OpenCV + MessagePack + ZeroMQ ==三重威胁</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2474ebfe13f872a236dd1988e01434cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3I3MB6vcioP_B-CIs63eQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">三重威胁</figcaption></figure><p id="fb9a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi lo translated">在我实习的时候，我的任务是制作一个类似请求-响应的机制，发送一个 OpenCV 矩阵(cv::Mat)。要求是我们使用<a class="ae lx" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank"> MessagePack </a>来序列化矩阵，使用<a class="ae lx" href="https://zeromq.org/" rel="noopener ugc nofollow" target="_blank"> ZeroMQ </a>来发送和接收请求-响应。一开始，我认为这可能是一个简单的任务，因为在我看来，我只需要<em class="ly">序列化矩阵→发送序列化矩阵→接收序列化矩阵→在客户端反序列化它</em>。但是我错了😔。没我想的那么简单。该流程的主要问题是<strong class="ku io">如何序列化 cv::Mat，以便我们可以使用 ZeroMQ 发送它，以及如何反序列化它，以便我们获得与之前相同的矩阵</strong>。事情变得更难了，因为我在这里使用 C++。因此在这个故事中，我将告诉你我在使用<strong class="ku io">【动态二人组】</strong>、MessagePack 和 ZeroMQ 时的生活故事。尽情享受吧！</p><p id="2fbf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个故事的结尾，我们的目标是:</p><ul class=""><li id="7a8f" class="lz ma in ku b kv kw ky kz lb mb lf mc lj md ln me mf mg mh bi translated">序列化 cv::Mat</li><li id="c70f" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated">使用 ZeroMQ 发送序列化的 cv::Mat</li><li id="ed46" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated">反序列化序列化的 cv::Mat</li></ul></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="c423" class="mu mv in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">先决条件</h1><p id="3b1a" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">你需要以下工具来追踪这个故事:</p><ul class=""><li id="2ea4" class="lz ma in ku b kv kw ky kz lb mb lf mc lj md ln me mf mg mh bi translated">C++17</li><li id="e74e" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><a class="ae lx" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank"> CMake </a>(或者其他你喜欢的构建工具)</li><li id="4221" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><a class="ae lx" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a></li><li id="5f0c" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><a class="ae lx" href="https://github.com/zeromq/cppzmq" rel="noopener ugc nofollow" target="_blank"> cppzmq </a></li><li id="c48e" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><a class="ae lx" href="https://github.com/msgpack/msgpack-c/tree/cpp_master" rel="noopener ugc nofollow" target="_blank"> msgpack </a></li></ul><p id="8681" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">需要注意的一点是，我不会在这里解释如何安装这些东西(opencv、cppzmq 和 msgpack)。相反，你可以浏览我给的链接，自己安装。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="5b5e" class="mu mv in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">[1]准备我们的文件</h1><ul class=""><li id="f869" class="lz ma in ku b kv nm ky nn lb nr lf ns lj nt ln me mf mg mh bi translated"><code class="fe nu nv nw nx b">image.hpp</code></li><li id="8c5a" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><code class="fe nu nv nw nx b">server.cpp</code></li><li id="e6d5" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><code class="fe nu nv nw nx b">client.cpp</code></li><li id="4c5a" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><code class="fe nu nv nw nx b">CMakeLists.txt</code></li></ul><p id="f45b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我将在下面详细解释这些文件。</p><h1 id="fcd9" class="mu mv in bd mw mx ny mz na nb nz nd ne jt oa ju ng jw ob jx ni jz oc ka nk nl bi translated">[2]设置 CMakeLists.txt</h1><p id="5599" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">让我们从我们的构建文件<code class="fe nu nv nw nx b">CMakeLists.txt</code>开始(注意，如果您决定使用其他构建系统，可以跳过这一步)</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">CMakeLists.txt</figcaption></figure><p id="610f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个文件中，我们定义了两个可执行文件:<strong class="ku io">服务器</strong>和<strong class="ku io">客户端</strong>。然后我们使用<code class="fe nu nv nw nx b">find_package()</code>找到我们安装的库 ZeroMQ、MsgPack 和 OpenCV。最后，我们使用<code class="fe nu nv nw nx b">target_link_libraries()</code>链接这些库。对于最低的 CMake 和 C++版本，可以根据需要进行编辑，但是在这个文件中，我们使用的是 CMake 3.10 和 C++17。</p><h1 id="f98d" class="mu mv in bd mw mx ny mz na nb nz nd ne jt oa ju ng jw ob jx ni jz oc ka nk nl bi translated"><strong class="ak"> [3]准备我们的矩阵</strong></h1><p id="dee7" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">打开<code class="fe nu nv nw nx b">image.hpp</code>文件并编写以下代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">image.hpp</figcaption></figure><p id="340b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我们定义了一个名为<strong class="ku io"> Image </strong>的结构，其成员包括:</p><ul class=""><li id="8fc1" class="lz ma in ku b kv kw ky kz lb mb lf mc lj md ln me mf mg mh bi translated"><strong class="ku io">矩阵</strong>:它将保存我们的矩阵数据</li><li id="1741" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><strong class="ku io">行</strong>:我们的矩阵行</li><li id="d190" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><strong class="ku io">列</strong>:我们的矩阵列</li><li id="e5ca" class="lz ma in ku b kv mi ky mj lb mk lf ml lj mm ln me mf mg mh bi translated"><strong class="ku io">类型</strong>:我们矩阵的类型</li></ul><p id="7422" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">不要忘记添加<code class="fe nu nv nw nx b">MSGPACK_DEFINE()</code>宏，以便 msgpack 可以序列化这个结构。</p><h1 id="0403" class="mu mv in bd mw mx ny mz na nb nz nd ne jt oa ju ng jw ob jx ni jz oc ka nk nl bi translated">[4]序列化</h1><p id="cbb0" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">接下来，我们准备我们的矩阵。在这个故事中，为了表示 opencv 矩阵，我们将使用<a class="ae lx" href="https://www.kaggle.com/code/mpwolke/cute-unicorns-computer-vision/data" rel="noopener ugc nofollow" target="_blank">这个图像</a>并将它转换成<code class="fe nu nv nw nx b">cv::Mat</code>。将这段代码保存在<code class="fe nu nv nw nx b">server.cpp</code>文件中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">server.cpp /序列化 opencv 矩阵</figcaption></figure><p id="4ef4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我将我的图像文件命名为<code class="fe nu nv nw nx b">unicorn.png</code>。读取图像后，我们将它保存到图像结构中，与其他数据成员放在一起。为了序列化我们的图像，我们首先创建一个<strong class="ku io"> sbuffer </strong>变量来保存序列化的图像，然后我们<strong class="ku io">用<code class="fe nu nv nw nx b">msgpack::pack()</code>打包/序列化</strong>它，接受我们的图像结构和 sbuffer。</p><h1 id="6b30" class="mu mv in bd mw mx ny mz na nb nz nd ne jt oa ju ng jw ob jx ni jz oc ka nk nl bi translated">[5]请求-答复</h1><p id="d8a0" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">对于请求-响应，我们从设置请求或客户机请求序列化矩阵开始。打开<code class="fe nu nv nw nx b">client.cpp</code>文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">client.cpp /请求或客户端</figcaption></figure><p id="e3bd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我们设置了 zeromq <strong class="ku io">上下文</strong>和<strong class="ku io">套接字</strong>来连接到我们定义的端点。然后，在 while 循环中，我们将请求字符串发送到服务器，如果服务器是活动的并且已经回复了响应，我们将使用<code class="fe nu nv nw nx b">client.recv()</code>捕获响应，接受一个 zeromq <strong class="ku io"> message_t </strong> <em class="ly">(该变量将保存响应数据)</em>和一个可选标志，我们将该标志设置为 none。</p><p id="59c2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来是响应或服务器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">server.cpp / response 或 server</figcaption></figure><p id="4ecd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">与客户端相同，我们设置了 zeromq <strong class="ku io">上下文</strong>和<strong class="ku io">套接字</strong>，但是对于这一个，我们没有使用<code class="fe nu nv nw nx b">connect</code>，而是使用了<code class="fe nu nv nw nx b">bind</code>。接下来，我们使用<code class="fe nu nv nw nx b">server.recv()</code>告诉服务器打开一个请求。下一部分和前面一样，我们序列化数据。最后，我们通过将我们的序列化数据放入 zeromq <strong class="ku io"> message_t </strong>变量中来发送它(<em class="ly">我们首先定义一个新的</em><strong class="ku io"><em class="ly">packed _ msg</em></strong><em class="ly">变量，然后我们</em> <strong class="ku io"> <em class="ly">使用</em> <code class="fe nu nv nw nx b">memcpy</code>将我们所有的序列化矩阵数据复制到这个变量中，然后使用<code class="fe nu nv nw nx b">server.send()</code>发送它。</strong></p><h1 id="93c5" class="mu mv in bd mw mx ny mz na nb nz nd ne jt oa ju ng jw ob jx ni jz oc ka nk nl bi translated">[6]反序列化</h1><p id="99ab" class="pw-post-body-paragraph ks kt in ku b kv nm jo kx ky nn jr la lb no ld le lf np lh li lj nq ll lm ln ig bi translated">最后一个，在从服务器得到响应后，我们反序列化它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">client.cpp /反序列化响应数据</figcaption></figure><p id="1099" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们需要添加的新代码从第 21 行开始。我们首先<strong class="ku io">解包/解串</strong>opencv 矩阵。得到结果后，我们得到了我们的 opencv 矩阵，但是类型仍然在<code class="fe nu nv nw nx b">std::vector&lt;uchar&gt;</code>，而不是<code class="fe nu nv nw nx b">cv::Mat </code>正因为如此，我们不能直接用<strong class="ku io"> cv::imshow() </strong>显示。然而，有一个窍门可以让我们克服这个问题。我们需要调用<strong class="ku io"> cv::Mat() </strong>重载成员函数并传递我们反序列化的数据(第 32 行&amp; 33 行)。</p><p id="8def" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">假设你运行<code class="fe nu nv nw nx b">server.cpp</code>和<code class="fe nu nv nw nx b">client.cpp</code>，你会得到这样的<strong class="ku io">流程:</strong>服务器打开请求→客户端发送他的请求→服务器处理 cv::Mat →然后发回并展示给客户端。如果一切顺利，客户端的图像独角兽图像将与服务器端的图像相同。</p><p id="aaf0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">非常感谢你们坚持到最后。我真的很感谢你的时间，希望我们能在另一个故事中再次看到！拜拜…🤗</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="809e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="ly">参考文献:</em> </strong></p><p id="58e8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢我找到的这些令人敬畏的资源！</p><p id="77b7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">【1】<a class="ae lx" href="https://www.youtube.com/watch?v=nGAJ_vYxWUI" rel="noopener ugc nofollow" target="_blank">超越 HelloWrold </a></p><p id="60f9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">【2】<a class="ae lx" href="https://www.kaggle.com/code/mpwolke/cute-unicorns-computer-vision/data" rel="noopener ugc nofollow" target="_blank">独角兽形象</a></p></div></div>    
</body>
</html>