<html>
<head>
<title>Using GitHub Actions to Deploy a FastAPI Project to Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作将FastAPI项目部署到Heroku</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-github-actions-to-deploy-a-fastapi-project-to-heroku-8ae3f9046178?source=collection_archive---------3-----------------------#2021-05-05">https://blog.devgenius.io/using-github-actions-to-deploy-a-fastapi-project-to-heroku-8ae3f9046178?source=collection_archive---------3-----------------------#2021-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="a53a" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">DevOps</h2><div class=""/><div class=""><h2 id="dcff" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">Heroku使部署变得轻而易举，但是在质量控制和最佳实践上有所妥协。因此，本文展示了如何在保持最佳实践的同时，将GitHub动作与Heroku配合使用。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/91bc37e25e1fc228464d96806aaf14f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cTcYvMWijAvGuEPx.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">GitHub Actions(和GitHub)加Heroku是天作之合</figcaption></figure><p id="7566" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">GitHub Actions(和GitHub)加Heroku是天作之合</p><p id="bbb6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我经常在GitHub存储库上构建Python项目和托管源代码。感谢<a class="ae lx" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>，我也不用担心持续集成的需求。而<a class="ae lx" href="https://www.heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>则负责我的持续部署需求。</p><p id="bd2e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是，有一个问题。Heroku没有提供使用GitHub动作部署项目的直接方法。我需要下载Heroku CLI来代替它。</p><p id="e62c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果你读过我的文章，你会知道我是一个极简主义者。我不喜欢给我的开发机器添加比需要的更多的膨胀软件和额外的依赖。因此，我不得不寻找另一种选择。</p><p id="099b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我目前的开发过程是在我的本地机器上提交更改&amp;然后把它推到远程。这里的remote通常是一个GitHub repo，配置GitHub动作来触发一系列测试。如果一切顺利，就将项目部署到生产环境中。相当标准的做法&amp;这里没有什么特别的。</p><p id="446d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是警告是Heroku CLI使用<code class="fe ly lz ma mb b">git</code>命令将代码推送到Heroku的遥控器。因此，这很像将代码推送到GitHub存储库。但是，没有强大的CI/CD管道。我可以配置Heroku在GitHub上测试通过后进行部署。但是最好坚持标准做法&amp;在一个屋檐下配置一切。</p><p id="8790" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外，在远程机器上调用<code class="fe ly lz ma mb b">git</code>命令听起来不是一个好主意。所以，我觉得分享我用来避免这种棘手情况的技巧是正确的事情。</p><p id="431e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">因此，我们将使用GitHub操作来配置CI/CD管道。并且，<a class="ae lx" href="http://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>来构建我们假设的REST API。</p><p id="a994" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">不多说了，让我们开始学习如何做吧。</p><h1 id="6f06" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">部署前要知道的事情</h1><p id="9be0" class="pw-post-body-paragraph lb lc in ld b le mu jx lg lh mv ka lj lk mw lm ln lo mx lq lr ls my lu lv lw ig bi translated">Heroku的设计反映了简化和降低复杂性的需要。它的用户不需要了解深入的CI/CD概念和实践。但是只要用户非常熟悉Git命令，就可以使用了。</p><p id="339a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">换句话说，将项目部署到Heroku就像将您的代码推送到GitHub repos一样简单！</p><p id="19f2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">您将开发您的项目&amp;然后将您的代码推送到Heroku remote。它触发一个构建过程，在远程服务器上建立一个web服务器。换句话说，部署项目再简单不过了。</p><p id="d636" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是这个过程有一个缺点，Heroku没有提供足够健壮的CI/CD管道。没有办法检查任何突破性的变化或错误。这就是GitHub动作派上用场的地方。</p><p id="531e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">因此，我们将使用<a class="ae lx" href="https://github.com/AkhileshNS" rel="noopener ugc nofollow" target="_blank"> AkhileshNS </a>的<code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/AkhileshNS/heroku-deploy" rel="noopener ugc nofollow" target="_blank">heroku-deploy</a></code>动作来部署项目。所述动作是围绕基本<code class="fe ly lz ma mb b">git</code>命令调用的NodeJS包装器。这些调用与您在Heroku CLI中使用的完全一样。</p><p id="c11b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外，为了保持简单明了，我们的FastAPI应用程序是一个不超过8行代码的单个文件！</p><p id="9711" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">除此之外，Heroku还需要一些额外的文件来运行构建过程。这些文件也会被推送到Heroku remote。它们是纯文本文件，包含Heroku在构建阶段需要解析的信息。在本文的后面，您将会找到关于它们的更多细节。</p><p id="b45b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外，<code class="fe ly lz ma mb b">heroku-deploy</code>动作还需要一个API密钥来进行认证。因此，确保你有它连同项目的名称。</p><p id="399c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">考虑到所有的先决条件，现在让我们来开发这个项目。</p><h1 id="e79f" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">把所有东西放在一起</h1><h1 id="b218" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">我们简单的FastAPI项目</h1><p id="30c1" class="pw-post-body-paragraph lb lc in ld b le mu jx lg lh mv ka lj lk mw lm ln lo mx lq lr ls my lu lv lw ig bi translated">随着所有先决条件的设置和收集，这里是我们的小项目概述。</p><p id="3206" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">首先，FastAPI项目非常简单，只有8行代码！它的源代码在<code class="fe ly lz ma mb b">main.py</code>文件中有详细说明。它配置了路由，以便在查询时返回一组JSON响应。所述路线是:一条<code class="fe ly lz ma mb b">/</code> ( <em class="mz">或根</em>)路线&amp;一条<code class="fe ly lz ma mb b">/healthcheck</code>路线。如您所见，后者在我们的CI/CD渠道中有一定的重要性。</p><p id="f2a1" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">根路由像这样返回一个JSON响应；<code class="fe ly lz ma mb b">{"message": "Hello, World!"}</code>查询时。并且<code class="fe ly lz ma mb b">/healtchcheck</code>路由充当REST API的最后一道防线。但是它也会返回一个JSON响应，以便用户更好地理解。因此，如果您对此路由调用一个<code class="fe ly lz ma mb b">cURL</code>命令，您应该会返回<code class="fe ly lz ma mb b">{"message": "Everything, OK!"}</code>响应。</p><p id="7c1d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我们将配置CI/CD管道来查询健康检查路由，以检查它是否仍在运行。不这样做意味着返回一个<code class="fe ly lz ma mb b">400</code> ( <em class="mz">或类似的</em>)响应代码，将调用回滚。因此，我们生产环境中的REST API将一直保持运行，不管有什么重大变化或错误出现。</p><p id="9a3b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，下面是我们的REST API的源代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">我们简单的FastAPI应用程序</figcaption></figure><h1 id="cfe4" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">配置GitHub操作工作流</h1><p id="e84f" class="pw-post-body-paragraph lb lc in ld b le mu jx lg lh mv ka lj lk mw lm ln lo mx lq lr ls my lu lv lw ig bi translated">构建好REST API后，让我们为它配置一个CI/CD管道。管道是相当标准的&amp;没有什么花哨的。在每个Push和/或PR事件中，它会调用一系列测试，然后进行代码质量检查。如果一切顺利，工作流也将调用部署过程。</p><p id="003c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是在讨论我们的管道之前，让我们先了解一下GitHub动作。</p><p id="581b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">很容易将GitHub动作混淆为“<em class="mz">又一个CI/CD工具</em>”。但是，事实并非如此。GitHub将其定义为一个自动化工具，可以满足所有你能想到的软件开发需求。此外，GitHub和/或社区还正式提供了许多预配置的操作。我们将在用例中使用的一个这样的动作是<code class="fe ly lz ma mb b">AkhileshNS/heroku-deploy</code>动作。</p><p id="68cc" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我们将在每个推送事件上触发我们的工作流。但是您也可以将其配置为触发其他事件。您可以在触发工作流的<a class="ae lx" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">事件列表中找到更多信息</a>这是官方文档。</p><p id="62dc" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">通过<a class="ae lx" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>文件进一步配置工作流程。而且，它们存储在<code class="fe ly lz ma mb b">.github/workflows</code>目录下，这个目录也是受版本控制的。GitHub将解析这些YAML文件，以获得如何设置环境的指令。</p><p id="146b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这是我们的工作流程:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">我们部署FastAPI项目的GitHub Actions工作流</figcaption></figure><p id="c534" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">GitHub动作工作流必须遵循特定的语法。解释语法有点超出了本文的范围。所以，你可以参考<a class="ae lx" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">官方文档</a>来了解语法。</p><p id="1833" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，让我们了解如何定制我们的工作流。</p><p id="d92c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在我们的<code class="fe ly lz ma mb b">main.yml</code>文件的顶部是带有<code class="fe ly lz ma mb b">name</code>关键字的工作流名称。接下来是<code class="fe ly lz ma mb b">on</code>关键字，它指示GitHub动作在<code class="fe ly lz ma mb b">push</code>事件上触发工作流。</p><p id="5fba" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">还有更多"<em class="mz"> on event </em>"关键字可用于触发工作流。因此，请务必查看文档&amp;根据您的需求配置您的管道。</p><p id="39ab" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">继续，工作流程的<code class="fe ly lz ma mb b">jobs</code>部分几乎是流水线的心脏。GitHub将在这里找到何时触发&amp;的指令。根据我们的需要，我们定义了3个任务&amp;,它们将并行运行，除非明确配置不这样做。</p><p id="da0e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这些作业被配置为在最新版本的Ubuntu上运行。此外，<code class="fe ly lz ma mb b">deploy</code>作业依赖于其他先前的作业。因此，当<code class="fe ly lz ma mb b">test</code> &amp; <code class="fe ly lz ma mb b">linter</code>作业并行运行时，<code class="fe ly lz ma mb b">deploy</code>作业将等待它们通过。如果他们不这样做，那么<code class="fe ly lz ma mb b">deploy</code>任务甚至不会执行。</p><p id="d3a8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">管道的这种结构确保了bug永远不会被引入到生产中。从而确保源代码的质量标准。如果你想知道如何为Python项目建立代码质量检查，我有一篇文章给你。查看<a class="ae lx" href="https://jarmos.netlify.app/posts/a-standard-ci-cd-pipeline-for-python-projects" rel="noopener ugc nofollow" target="_blank">一个标准的&amp;完整的CI/CD管道，以了解如何设置它。</a></p><p id="6ba5" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">更深入地研究一下<code class="fe ly lz ma mb b">deploy</code>工作，让我们弄清楚它的确切目的。</p><p id="70a9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">像它的前辈一样，<code class="fe ly lz ma mb b">deploy</code>作业也运行在最新版本的Ubuntu上。然后它指示GitHub解析要执行的步骤。相应地，GitHub " <em class="mz">在虚拟环境中复制</em>"回购的内容。随后执行<code class="fe ly lz ma mb b">heroku-deploy</code>动作。</p><p id="3ff8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><code class="fe ly lz ma mb b">heroku-deploy</code>动作也需要几个变量才能起作用。这些变量是使用<code class="fe ly lz ma mb b">with</code>关键字提供的。上述操作接受的变量比我们正在使用的要多。因此，一定要检查它的回购，以便进一步配置。</p><p id="04b6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，我们使用了<code class="fe ly lz ma mb b">heroku_api_key</code>、<code class="fe ly lz ma mb b">heroku_app_name</code>、<code class="fe ly lz ma mb b">heroku_email</code>、<code class="fe ly lz ma mb b">healthcheck</code>、&amp;、<code class="fe ly lz ma mb b">rollbackonhealthcheckfailed</code>变量。因为，前3个变量接受有价值的用户信息，它们作为GitHub秘密传入。变量<code class="fe ly lz ma mb b">healtcheck</code>接受一个到<code class="fe ly lz ma mb b">/healthcheck</code>路径的URL。最后，<code class="fe ly lz ma mb b">rollbackonhealthcheckfailed</code>接受一个布尔值。</p><p id="1e3b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">最后一个变量作为最后一道防线帮助我们。每当一个事件触发工作流&amp;项目部署时，都会执行健康检查。它将寻找一个<code class="fe ly lz ma mb b">200</code>响应代码&amp;，如果失败，工作流将恢复到以前的工作版本！</p><p id="61a2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果你问我的话，我觉得非常漂亮！</p><p id="1ed0" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是，为什么我们首先需要这样的复杂性呢？</p><p id="7acd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">您知道，在生产环境中，拥有强大的CI/CD管道是很常见的。这些系统测试您的提交推送和PR是否有任何潜在的中断。不要忘记编码最佳实践和质量标准。</p><p id="ad0b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">管道的健康检查和回滚功能是最后一道防线。因为，错误和/或重大变更有可能通过初步检查。这可能会破坏我们生产中的REST API。想象一下对于你的项目的用户来说会是什么样子(<em class="mz">并且他们为使用它而付费</em>)！</p><p id="9f4f" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但幸运的是，你不必担心这种情况会成为现实。借助运行状况检查和回滚功能，问题将像转向南方一样迅速转向北方。所以，换句话说，你可以无忧无虑地睡个好觉。</p><h1 id="3bc1" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">关于<code class="fe ly lz ma mb b">Procfile</code>、<code class="fe ly lz ma mb b">requirements.txt</code>、&amp;、<code class="fe ly lz ma mb b">runtime.txt</code>文件</h1><p id="ebc7" class="pw-post-body-paragraph lb lc in ld b le mu jx lg lh mv ka lj lk mw lm ln lo mx lq lr ls my lu lv lw ig bi translated">如前所述，Heroku在构建过程中需要某些纯文本文件。它解析这些文件来设置web服务器&amp;项目的依赖项。因此，对于我们的REST API项目，它是一个Python应用程序，下面是Heroku需要解析的文件。</p><ul class=""><li id="8b05" class="nc nd in ld b le lf lh li lk ne lo nf ls ng lw nh ni nj nk bi translated">Heroku解析的用于在远程机器上建立网络服务器的<code class="fe ly lz ma mb b">Procfile</code> ( <em class="mz">没有文件扩展名</em>)。因此，在使用uvicorn时，文件的内容应该是:<code class="fe ly lz ma mb b">uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000} --workers 4</code>。</li><li id="3ada" class="nc nd in ld b le nl lh nm lk nn lo no ls np lw nh ni nj nk bi translated"><code class="fe ly lz ma mb b">requirements.txt</code>列出了项目依赖关系。并且，Heroku将解析它来安装项目的依赖项。</li><li id="81c2" class="nc nd in ld b le nl lh nm lk nn lo no ls np lw nh ni nj nk bi translated"><code class="fe ly lz ma mb b">runtime.txt</code>文件声明了用于REST API的特定Python版本。因此，如果它依赖于Python v3.8.10，文件的内容将是<code class="fe ly lz ma mb b">Python-3.8.10</code>。<strong class="ld ix">一定要注意格式</strong> &amp;它必须完全相似，否则它不会工作。</li></ul><p id="76fd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">有了这些文件，您在Heroku上的构建环境应该很快就可以启动并运行了。但是让我们在提交版本控制之前仔细检查一下目录结构。您的目录结构应该是这样的:</p><p id="38b9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">现在，每次您将更改推送到GitHub存储库时，推送事件都会触发工作流。如果测试和代码质量检查通过，工作流将尝试将项目部署到Heroku。最重要的是，如果健康检查URL向我们的工作流返回一个<code class="fe ly lz ma mb b">200</code>响应代码，REST API就开始运行了！</p><p id="900a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">然后您可以导航到<code class="fe ly lz ma mb b">https://&lt;PROJECT-NAME&gt;.herokuapp.com</code> URL来查看我们的REST API。如果工作正常，您应该会在屏幕上看到JSON响应。</p><p id="6f6d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">有了这个设置，现在你就可以两全其美了。Heroku的简单部署和GitHub动作的强大代码质量检查！最棒的是，不需要在本地机器上使用Heroku CLI。😆</p><h1 id="8ea0" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">一些潜在的障碍</h1><p id="d173" class="pw-post-body-paragraph lb lc in ld b le mu jx lg lh mv ka lj lk mw lm ln lo mx lq lr ls my lu lv lw ig bi translated">虽然本文详述的技术和代码可以工作，但还不够健壮。在<code class="fe ly lz ma mb b">heroku-deploy</code>行动中有几个脆弱的地方需要注意。如果你仔细阅读源代码，你会发现这是<a class="ae lx" href="https://github.com/AkhileshNS/heroku-deploy/blob/79ef2ae4ff9b897010907016b268fd0f88561820/index.js#L19" rel="noopener ugc nofollow" target="_blank">使用NodeJS调用实际的</a> <code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/AkhileshNS/heroku-deploy/blob/79ef2ae4ff9b897010907016b268fd0f88561820/index.js#L19" rel="noopener ugc nofollow" target="_blank">git</a></code> <a class="ae lx" href="https://github.com/AkhileshNS/heroku-deploy/blob/79ef2ae4ff9b897010907016b268fd0f88561820/index.js#L19" rel="noopener ugc nofollow" target="_blank">命令</a>。</p><p id="485c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是，NodeJS并不意味着调用shell命令。所以，难怪在使用它的时候东西会坏掉。换句话说，这里使用的操作更像是一种变通方法。</p><p id="8b68" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这个问题的更好的解决方案是包装Heroku提供的API来创建一个动作。对我们来说幸运的是，隧道的另一端似乎出现了一丝曙光。Heroku提供了一个官方API来与他们的构建过程和其他服务进行交互。他们将其命名为<a class="ae lx" href="https://devcenter.heroku.com/articles/platform-api-reference" rel="noopener ugc nofollow" target="_blank"> Heroku平台API </a>。他们甚至分享了一篇文章，使用他们的平台API以编程方式向Heroku 发布代码。</p><p id="631b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">所以，向JavaScript开发者大声疾呼。如果你正在读这篇文章&amp;你有开发GitHub动作的经验，社区需要你。但在此之前，这篇文章应该是任何想将FastAPI应用程序部署到Heroku的人的一个很好的指南。</p><p id="1e8d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">不过，还有其他选择。谷歌无服务器基础设施是由微软Azure和/或亚马逊网络服务提供的。所以，如果你想尝试一下，可以看看我写的这篇关于谷歌无服务器产品的文章。你可以在<a class="ae lx" href="https://jarmos.netlify.app/posts/posts/google-serverless-infrastructure-what-are-the-differences" rel="noopener ugc nofollow" target="_blank">谷歌无服务器基础设施:GCP无服务器计算初级读本&amp;上阅读。</a></p><p id="d7eb" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在那之前，干杯&amp;快乐发展！🍻</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="f48d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><em class="mz">原载于2021年5月5日</em><a class="ae lx" href="https://jarmos.netlify.app/posts/using-github-actions-to-deploy-a-fastapi-project-to-heroku/" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://jarmos . netlify . app</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>