<html>
<head>
<title>Django, Docker Setup Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django，Docker 设置教程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-docker-setup-tutorial-4c3e5f8d6def?source=collection_archive---------2-----------------------#2022-07-21">https://blog.devgenius.io/django-docker-setup-tutorial-4c3e5f8d6def?source=collection_archive---------2-----------------------#2022-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bfc4638d2136b01da26c9358536795eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFR0juIWkRzeaD-3C4c5xA.jpeg"/></div></div></figure><p id="5c18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将使用<strong class="jx io"> Docker </strong> compose 文件创建一个新的<strong class="jx io"> Django </strong>项目。Django 为本地开发提供了内置的 SQLite 支持，这将用于本教程。</p><h1 id="1ca1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用的工具:-</h1><ul class=""><li id="4c93" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">饭桶狂欢</li><li id="749c" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">虚拟代码</li><li id="5e67" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">Windows</li></ul><p id="5049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里下载<strong class="jx io"/><a class="ae mh" href="https://code.visualstudio.com/Download" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">vs code</strong></a><strong class="jx io"/><a class="ae mh" href="https://git-scm.com/download/win" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Git Bash</strong></a>和<a class="ae mh" href="https://docs.docker.com/desktop/install/windows-install/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Docker for Window</strong></a><strong class="jx io">s<em class="mi"/></strong>。</p><h1 id="0d2e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">安装 Docker</h1><p id="6241" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">第一步是为您的本地机器安装桌面 Docker 应用程序:</p><ul class=""><li id="2742" class="lr ls in jx b jy jz kc kd kg mm kk mn ko mo ks ly lz ma mb bi translated"><a class="ae mh" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">Mac Docker</a></li><li id="cd45" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><a class="ae mh" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank">Windows Docker</a></li><li id="78e6" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><a class="ae mh" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">面向 Linux 的 Docker</a></li></ul><p id="ac95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker 的初始下载可能需要一些时间来下载。这是一个大文件。在这一点上，请随意伸展你的腿！</p><p id="a327" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦 Docker 完成安装，我们可以确认正确的版本正在运行。在您的终端中运行命令<code class="fe mp mq mr ms b">docker --version</code>。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6005" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mh" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>是一个附加工具，自动包含在 Docker 的 Mac 和 Windows 下载中。但是，如果您在 Linux 上，您将需要手动添加它。在 Docker 安装完成后，您可以通过运行命令<code class="fe mp mq mr ms b">sudo pip install docker-compose</code>来做到这一点。</p><p id="e7be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望此时 Docker 已经安装完毕。要确认安装成功，请在命令行中键入<code class="fe mp mq mr ms b">docker run hello-world</code>。您应该会看到这样的响应:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b990" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker 现已正确安装在您的计算机上。然后我们可以继续配置一个本地 Django 设置，然后切换到 Docker。</p><h1 id="f8dc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">姜戈成立了</h1><p id="4659" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">这个项目的代码可以存在于你计算机的任何地方，但是<code class="fe mp mq mr ms b">Desktop</code>是一个用于教学目的的简单位置。在命令行导航到桌面，创建一个名为<code class="fe mp mq mr ms b">django-docker</code>的新目录。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="04c5" class="nd ku in ms b gy ne nf l ng nh"><strong class="ms io">#</strong> Windows<br/>$ cd onedrive\desktop<br/>$ mkdir django<strong class="ms io">-</strong>docker<br/><br/><strong class="ms io">#</strong> macOS<br/>$ cd <strong class="ms io">~/</strong>desktop<strong class="ms io">/</strong>code<br/>$ mkdir django<strong class="ms io">-</strong>docker</span></pre><p id="b163" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将遵循创建一个新的 Django 项目的标准步骤:创建一个专用的虚拟环境，激活它，并安装 Django。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="fc3b" class="nd ku in ms b gy ne nf l ng nh"><strong class="ms io">#</strong> Windows<br/>$ python <strong class="ms io">-</strong>m venv .venv<br/>$ <strong class="ms io">Set-</strong>ExecutionPolicy <strong class="ms io">-</strong>ExecutionPolicy RemoteSigned <strong class="ms io">-Scope</strong> CurrentUser<br/>$ .venv\Scripts\Activate.ps1<br/>(.venv) $ python <strong class="ms io">-</strong>m pip install django<br/><br/><strong class="ms io">#</strong> macOS<br/>$ python3 <strong class="ms io">-</strong>m venv .venv<br/>$ <strong class="ms io">source</strong> .venv<strong class="ms io">/</strong>bin<strong class="ms io">/</strong>activate<br/>(.venv) $ python3 <strong class="ms io">-</strong>m pip install django</span></pre><p id="b517" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们可以创建一个名为<code class="fe mp mq mr ms b">django_project</code>、<code class="fe mp mq mr ms b">migrate</code>的新项目，我们的数据库初始化它，并使用<code class="fe mp mq mr ms b">runserver</code>启动本地服务器。通常我不建议在新项目上运行<code class="fe mp mq mr ms b">migrate</code>，直到配置好自定义用户模型之后的<em class="mi">，但是在本教程中，我们将忽略这个建议。</em></p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="644d" class="nd ku in ms b gy ne nf l ng nh">(.venv) $ django-admin startproject django_project .<br/>(.venv) $ python manage.py migrate<br/>(.venv) $ python manage.py runserver</span></pre><p id="3da0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在网络浏览器中导航到<code class="fe mp mq mr ms b">http://127.0.0.1:8000/</code>来确认一切正常。您可能需要刷新页面，但应该看到熟悉的 Django 欢迎页面。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/b63d8c5a842781bbc2a5ae8cc35c062c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKsYFlYLJzYJFCCmzk4JHw.png"/></div></div></figure><p id="6962" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">切换到 Docker 之前的最后一步是用我们当前虚拟环境的内容创建一个<code class="fe mp mq mr ms b">requirements.txt</code>文件。我们可以用一行命令来完成这个任务。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="edae" class="nd ku in ms b gy ne nf l ng nh">(.venv) $ pip freeze &gt; requirements.txt</span></pre><p id="ab3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它应该包含<code class="fe mp mq mr ms b">Django</code>以及安装 Django 时自动包含的包<code class="fe mp mq mr ms b">asgiref</code>和<code class="fe mp mq mr ms b">sqlparse</code>。</p><p id="4ea6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在该换 Docker 了。通过键入<code class="fe mp mq mr ms b">deactivate</code>和<code class="fe mp mq mr ms b">Return</code>退出我们的虚拟环境，因为我们不再需要它。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="6d3b" class="nd ku in ms b gy ne nf l ng nh">(.venv) $ deactivate<br/>$</span></pre><h1 id="cfb4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Docker 图像</h1><p id="07cb" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">Docker <em class="mi">图像</em>是一个只读模板，描述了如何创建 Docker <em class="mi">容器</em>。图像是指令，而容器是图像的实际运行实例。继续本章前面的公寓类比，图像是建造公寓的蓝图或一套计划；集装箱是实际的、完全建成的建筑。</p><p id="7185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图像通常基于另一个图像，并进行一些额外的定制。例如，根据所需的 Python 版本和风格，官方支持的 Python 图片有很长的列表。</p><h1 id="6ce7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Dockerfile 文件</h1><p id="f839" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">对于我们的 Django 项目，我们需要创建一个包含 Python 的定制映像，同时还要安装我们的代码并提供额外的配置细节。为了构建我们自己的映像，我们创建了一个名为<em class="mi"> Dockerfile </em>的特殊文件，它定义了创建和运行定制映像的步骤。</p><p id="48af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用您的文本编辑器在项目级目录中的<code class="fe mp mq mr ms b">manage.py</code>文件旁边创建一个新的<code class="fe mp mq mr ms b">Dockerfile</code>文件。在其中添加下面的代码，我们将在下面一行一行地介绍。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="e1b2" class="nd ku in ms b gy ne nf l ng nh"><strong class="ms io">#</strong> Pull base image<br/><strong class="ms io">FROM</strong> python:3.10.2<strong class="ms io">-</strong>slim<strong class="ms io">-</strong>bullseye<br/><br/><strong class="ms io">#</strong> <strong class="ms io">Set</strong> environment variables<br/>ENV PIP_DISABLE_PIP_VERSION_CHECK 1<br/>ENV PYTHONDONTWRITEBYTECODE 1<br/>ENV PYTHONUNBUFFERED 1<br/><br/><strong class="ms io">#</strong> <strong class="ms io">Set</strong> <strong class="ms io">work</strong> directory<br/>WORKDIR <strong class="ms io">/</strong>code<br/><br/><strong class="ms io">#</strong> Install dependencies<br/><strong class="ms io">COPY</strong> .<strong class="ms io">/</strong>requirements.txt .<br/>RUN pip install <strong class="ms io">-</strong>r requirements.txt<br/><br/><strong class="ms io">#</strong> <strong class="ms io">Copy</strong> project<br/><strong class="ms io">COPY</strong> . .</span></pre><p id="0ae2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建图像时，从上到下读取。第一个指令是一个<code class="fe mp mq mr ms b">FROM</code>命令，它告诉 Docker 我们希望在我们的应用程序中使用什么样的基本图像。Docker 映像可以从其他映像继承，因此我们将使用官方 Python 映像，而不是创建我们自己的基础映像，该映像已经包含了我们的 Django 应用程序所需的所有工具和包。在这种情况下，我们使用 Python <code class="fe mp mq mr ms b">3.10.2</code>和更小的<code class="fe mp mq mr ms b">slim</code>变体，它不包含默认标签中包含的公共包。标签<code class="fe mp mq mr ms b">bullseye</code>指的是最新稳定的 Debian 版本。当有 Debian 的新版本时，显式地设置它来最小化潜在的破坏是一个好主意。</p><p id="61fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们使用<code class="fe mp mq mr ms b">ENV</code>命令来设置三个环境变量:</p><ul class=""><li id="e4fc" class="lr ls in jx b jy jz kc kd kg mm kk mn ko mo ks ly lz ma mb bi translated"><code class="fe mp mq mr ms b">PIP_DISABLE_PIP_VERSION_CHECK</code>每次禁用对<code class="fe mp mq mr ms b">pip</code>更新的自动检查</li><li id="5c7c" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><code class="fe mp mq mr ms b">PYTHONDONTWRITEBYTECODE</code>意味着 Python 不会尝试写<code class="fe mp mq mr ms b">.pyc</code>文件</li><li id="95af" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><code class="fe mp mq mr ms b">PYTHONUNBUFFERED</code>确保我们的控制台输出不被 Docker 缓冲</li></ul><p id="9d77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">命令<code class="fe mp mq mr ms b">WORKDIR</code>用于在运行其余命令时设置默认工作目录。这告诉 Docker 使用这个路径作为所有后续命令的默认位置。因此，我们可以使用基于工作目录的相对路径，而不是每次都键入完整的文件路径。在我们的例子中，工作目录是<code class="fe mp mq mr ms b">/code</code>，但是它通常可以更长，类似于<code class="fe mp mq mr ms b">/app/src</code>、<code class="fe mp mq mr ms b">/usr/src/app</code>或者类似的变化，这取决于项目的特定需求。</p><p id="ad3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是用我们已经创建的<code class="fe mp mq mr ms b">pip</code>和<code class="fe mp mq mr ms b">requirements.txt</code>文件安装我们的依赖项。<code class="fe mp mq mr ms b">COPY</code>命令有两个参数:第一个参数告诉 Docker 要将什么文件复制到映像中，第二个参数告诉 Docker 要将文件复制到哪里。在这种情况下，我们将现有的<code class="fe mp mq mr ms b">requirements.txt</code>文件从本地计算机复制到由<code class="fe mp mq mr ms b">.</code>表示的当前工作目录中。</p><p id="40d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦<code class="fe mp mq mr ms b">requirements.txt</code>文件在图像中，我们可以使用最后一个命令<code class="fe mp mq mr ms b">RUN</code>来执行<code class="fe mp mq mr ms b">pip install</code>。这与我们在本地机器上运行<code class="fe mp mq mr ms b">pip install</code>完全一样，但是这次模块被安装到映像中。<code class="fe mp mq mr ms b">-r</code>标志告诉<code class="fe mp mq mr ms b">pip</code>打开一个文件——这里叫做<code class="fe mp mq mr ms b">requirements.txt</code>——并安装它的内容。如果我们不包含<code class="fe mp mq mr ms b">-r</code>标志，<code class="fe mp mq mr ms b">pip</code>将会尝试安装<code class="fe mp mq mr ms b">requirements.txt</code>失败，因为它本身并不是一个真正的 Python 包。</p><p id="3fae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，我们有一个基于<code class="fe mp mq mr ms b">Python 3.10.2</code>的<code class="fe mp mq mr ms b">slim-bullseye</code>变体的新映像，并且已经安装了我们的依赖项。最后一步是将当前目录中的所有文件复制到映像的工作目录中。我们可以通过使用<code class="fe mp mq mr ms b">COPY</code>命令来完成。记住它需要两个参数，所以我们将把本地文件系统上的当前目录(<code class="fe mp mq mr ms b">.</code>)复制到映像的工作目录(<code class="fe mp mq mr ms b">.</code>)中。</p><p id="d6b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你现在很困惑，不要担心。Docker 很难理解，但好消息是，对现有项目进行“docker 化”的步骤非常相似。</p><h1 id="d660" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">。dockerignore</h1><p id="78b7" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">一个<code class="fe mp mq mr ms b">.dockerignore</code>文件是指定不应该包含在 Docker 映像中的某些文件和目录的最佳实践方式。这有助于减少整体图像大小，并通过将本应保密的内容排除在 Docker 之外来提高安全性。</p><p id="75bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此刻，我们可以安全地忽略本地虚拟环境(<code class="fe mp mq mr ms b">.venv</code>)、未来的<code class="fe mp mq mr ms b">.git</code>目录和未来的<code class="fe mp mq mr ms b">.gitignore</code>文件。在您的文本编辑器中，在现有的<code class="fe mp mq mr ms b">manage.py</code>文件旁边的基本目录中创建一个名为<code class="fe mp mq mr ms b">.dockerignore</code>的新文件。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="baee" class="nd ku in ms b gy ne nf l ng nh">.venv<br/>.git<br/>.gitignore</span></pre><p id="d1af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在已经有了创建自定义图像的完整说明，但实际上我们还没有构建它。不出所料，这样做的命令是<code class="fe mp mq mr ms b">docker build</code>后跟句点<code class="fe mp mq mr ms b">.</code>，表示<code class="fe mp mq mr ms b">Dockerfile</code>位于当前目录中。这里会有很多输出。我只包括了前两行和最后一行。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="05bc" class="nd ku in ms b gy ne nf l ng nh">$ docker build .<br/><strong class="ms io">[</strong>+<strong class="ms io">]</strong> Building 9.1s (10<strong class="ms io">/</strong>10) FINISHED<br/> <strong class="ms io">=&gt;</strong> <strong class="ms io">[</strong>internal<strong class="ms io">]</strong> <strong class="ms io">load</strong> build definition <strong class="ms io">from</strong> Dockerfile<br/>...<br/><strong class="ms io">=&gt;</strong> <strong class="ms io">=&gt;</strong> writing <strong class="ms io">image</strong> sha256:89ede1...</span></pre><h1 id="02f9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">docker-compose.yml</h1><p id="8056" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">我们完全构建的自定义映像现在可以作为容器运行。为了运行容器，我们需要一个名为<code class="fe mp mq mr ms b">docker-compose.yml</code>的文件中的指令列表。用文本编辑器在项目级目录中的<code class="fe mp mq mr ms b">Dockerfile</code>旁边创建一个<code class="fe mp mq mr ms b">docker-compose.yml</code>文件。它将包含以下代码。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="be62" class="nd ku in ms b gy ne nf l ng nh"><em class="mi">version: "3.9"</em><br/><em class="mi">services:</em><br/><em class="mi">  web:</em><br/><em class="mi">    build: .</em><br/><em class="mi">    ports:</em><br/><em class="mi">      - "8000:8000"</em><br/><em class="mi">    command: python manage.py runserver 0.0.0.0:8000</em><br/><em class="mi">    volumes:</em><br/><em class="mi">      - .:/code</em></span></pre><p id="fb59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在最上面一行，我们设置了 Docker Compose 的<a class="ae mh" href="https://docs.docker.com/compose/compose-file/compose-versioning/" rel="noopener ugc nofollow" target="_blank">最新版本</a>，当前版本为<code class="fe mp mq mr ms b">3.9</code>。然后，我们指定希望哪些<code class="fe mp mq mr ms b">services</code>(或容器)在我们的 Docker 主机中运行。有可能有多个<code class="fe mp mq mr ms b">services</code>在运行，但是现在，我们只有一个<code class="fe mp mq mr ms b">web</code>在运行。</p><p id="ba33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe mp mq mr ms b">web</code>中，我们设置<code class="fe mp mq mr ms b">build</code>在当前目录中查找我们的<code class="fe mp mq mr ms b">Dockerfile</code>。我们将使用 Django 默认端口<code class="fe mp mq mr ms b">8000</code>并执行<code class="fe mp mq mr ms b">command</code>来运行本地 web 服务器。最后，<a class="ae mh" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>挂载会自动将 Docker 文件系统与我们本地计算机的文件系统同步。如果我们对 Docker 中的代码进行修改，它将自动与本地文件系统同步。</p><p id="944a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步是使用命令<code class="fe mp mq mr ms b">docker-compose up</code>运行 Docker 容器。该命令将在命令行上产生另一长串输出代码。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="b95d" class="nd ku in ms b gy ne nf l ng nh">$ docker<strong class="ms io">-</strong>compose up</span></pre><p id="bcb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要确认它确实有效，请在您的网络浏览器中返回<code class="fe mp mq mr ms b">http://127.0.0.1:8000/</code>。刷新页面，“Hello，World”页面应该仍然会出现。</p><p id="0bbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Django 现在完全运行在 Docker 容器中。我们不是在本地的虚拟环境中工作。我们没有执行<code class="fe mp mq mr ms b">runserver</code>命令。我们所有的代码现在都存在了，我们的 Django 服务器运行在一个自包含的 Docker 容器中。成功！</p><p id="1552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本书的过程中，我们将创建多个 Docker 图像和容器，通过练习，这个流程将变得更有意义。：</p><ul class=""><li id="5c79" class="lr ls in jx b jy jz kc kd kg mm kk mn ko mo ks ly lz ma mb bi translated">用自定义图像指令创建一个<code class="fe mp mq mr ms b">Dockerfile</code></li><li id="bc7e" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">添加一个<code class="fe mp mq mr ms b">.dockerignore</code>文件</li><li id="8c94" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">建立形象</li><li id="f09c" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">创建一个<code class="fe mp mq mr ms b">docker-compose.yml</code>文件</li><li id="9553" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">旋转容器</li></ul><p id="6df4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用<code class="fe mp mq mr ms b">Control+c</code>停止当前正在运行的容器(同时按下“控制”和“c”按钮)，并输入<code class="fe mp mq mr ms b">docker-compose down</code>。Docker 容器会占用大量内存，所以最好在您使用完它们后停止它们。容器注定是无状态的，这就是为什么我们使用<code class="fe mp mq mr ms b">volumes</code>将我们的代码复制到本地可以保存的地方。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="1757" class="nd ku in ms b gy ne nf l ng nh">$ docker-compose down</span></pre><p id="e9dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在分离模式下运行容器，我们使用<code class="fe mp mq mr ms b">docker-compose up -d</code>。</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="11d7" class="nd ku in ms b gy ne nf l ng nh">$ docker-compose up -d</span></pre><p id="884e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们将结束本教程的地方。我们将在下一部分继续添加新功能，请注意我的下一篇帖子。</p><p id="8c60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这篇文章，请随意鼓掌或鼓掌，如果你有任何问题或疑问，请在下面的评论中留下。</p></div></div>    
</body>
</html>