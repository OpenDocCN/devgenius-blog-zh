<html>
<head>
<title>Git Advanced Topics Part Two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git 高级主题第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/git-advanced-topics-part-two-1833a5f690bf?source=collection_archive---------8-----------------------#2022-04-21">https://blog.devgenius.io/git-advanced-topics-part-two-1833a5f690bf?source=collection_archive---------8-----------------------#2022-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d751a9a843683c769735544916c27e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2BYoO2qvtVO6tjY0ODiIg.png"/></div></div></figure><p id="5e40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你没有读过这个系列的第一部分，请点击这里查看第一部分<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/git-advanced-topics-part-one-5443ff7c9f1b"/>。</p><p id="9744" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续高级主题，我们将讨论 reflog、二分法、search、find，最后是 git 子模块。</p><h1 id="f21b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考日志</h1><p id="99e1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">换句话说，git ref log 是一个可视化 git 历史的工具。它在 git 历史中是什么？基本上，你在 git 中所做的一切，例如，签出、推送、合并等等。</p><p id="becc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过 git reflog，我将教你如何使用它来检索删除的提交或分支，并学习 git ref log 的基础知识。</p><p id="77d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了教授 git reflog 如何工作，我创建了一个带有虚拟提交的 git 存储库。像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="28a8" class="mg kv in mc b gy mh mi l mj mk">➜ git log<br/>* 5c742b2 (HEAD -&gt; main) Commit E<br/>* d569890 Commit D<br/>* 7a42f58 Commit C<br/>* fb7cf42 Commit B<br/>* f251a31 Commit A<br/>* 5f7cfbc Initial Commit</span></pre><p id="c950" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要删除<strong class="jx io">提交 C、D </strong>和<strong class="jx io"> E </strong>，我们可以使用:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="aa58" class="mg kv in mc b gy mh mi l mj mk">➜ git reset --hard HEAD~3</span></pre><p id="0bc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者我们可以使用提交哈希直接重置到目标提交:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8406" class="mg kv in mc b gy mh mi l mj mk">➜ git reset --hard fb7cf42</span></pre><p id="010c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两种方式结果都一样，就选你比较熟悉的那种吧。</p><p id="60e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行<strong class="jx io"> git reset </strong>命令后，您的 git 存储库应该如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="207f" class="mg kv in mc b gy mh mi l mj mk">➜ git log<br/>* fb7cf42 (HEAD, main) Commit B<br/>* f251a31 Commit A<br/>* 5f7cfbc Initial Commit</span></pre><p id="3101" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们所做的是从主分支中删除 3 个提交。现在我们可以使用<strong class="jx io"> git reflog </strong>来查找提交，然后使用<strong class="jx io"> git reset </strong>来检索它们。</p><p id="e151" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先我们要找到<strong class="jx io">“提交 E”</strong>的提交<strong class="jx io"> HASH </strong>，因为<strong class="jx io">“提交 E”</strong>有从<strong class="jx io">“提交 C”</strong>、<strong class="jx io">“提交 D”</strong>、<strong class="jx io">“提交 E”</strong>的变化。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="df7d" class="mg kv in mc b gy mh mi l mj mk">➜ git reflog --no-abbrev-commit OR git reflog<br/>fb7cf42 (HEAD -&gt; main) HEAD@{5}: reset: moving to HEAD~3<br/>5c742b2 HEAD@{6}: commit: Commit E<br/>d569890 HEAD@{7}: commit: Commit D<br/>7a42f58 HEAD@{8}: commit: Commit C<br/>fb7cf42 (HEAD -&gt; main) HEAD@{9}: commit: Commit B<br/>f251a31 HEAD@{10}: commit: Commit A<br/>5f7cfbc HEAD@{11}: commit (initial): Initial Commit</span></pre><p id="6ea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，提交哈希<strong class="jx io"> 5c742b2 </strong>是丢失所有更改的提交，为了检索，我们必须使用<strong class="jx io"> git reset </strong>命令，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3e92" class="mg kv in mc b gy mh mi l mj mk">➜ git reset --hard 5c742b2</span></pre><p id="c37d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行此命令后，您应该已经恢复了更改。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="721c" class="mg kv in mc b gy mh mi l mj mk">➜ git reflog<br/>5c742b2 (HEAD -&gt; main) HEAD@{5}: checkout: moving from main to 5c742b2<br/>fb7cf42 HEAD@{6}: reset: moving to HEAD~3<br/>5c742b2 (HEAD -&gt; main) HEAD@{7}: commit: Commit E<br/>d569890 HEAD@{8}: commit: Commit D<br/>7a42f58 HEAD@{9}: commit: Commit C<br/>fb7cf42 HEAD@{10}: commit: Commit B<br/>f251a31 HEAD@{11}: commit: Commit A<br/>5f7cfbc HEAD@{12}: commit (initial): Initial Commit</span></pre><p id="f6d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的<strong class="jx io"> git 日志</strong>应该是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7308" class="mg kv in mc b gy mh mi l mj mk">➜ git log<br/>* 5c742b2 (HEAD -&gt; main) Commit E<br/>* d569890 Commit D<br/>* 7a42f58 Commit C<br/>* fb7cf42 Commit B<br/>* f251a31 Commit A<br/>* 5f7cfbc Initial Commit</span></pre><h1 id="3c5e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">把…分为两个部分</h1><p id="a95c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Git 二等分是一个很好的工具，可以发现提交之间的错误，二等分所做的是从一个坏的和好的提交开始，这些提交由用户定义，然后二等分工具会抛出一系列介于坏的和好的提交之间的提交，对于每一轮或每一次更改的提交，您可以定义当前提交是好的还是坏的。</p><p id="5d58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个 ReactJS 应用程序有一个 BUG，logo 比正常的要大。我想找到引入错误的提交。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/390b496d2817a10b79e558db4938d610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhmWzQIaqzyjA_RbSnsjDg.jpeg"/></div></div></figure><p id="5762" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正常情况下的徽标应该是这样的。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/ac5e5c8d0cd7fdb649e634c4a09f2b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*052KCCQlunsUCTkF-X1POw.jpeg"/></div></div></figure><p id="b2f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们能解决这个问题吗…</p><p id="be8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，我们有 6 次提交，但我们不知道哪一次提交引入了 bug。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9ddf" class="mg kv in mc b gy mh mi l mj mk">➜ git log<br/>* 3f9168f (HEAD -&gt; master) Commit 6<br/>* f50d187 Commit 5<br/>* 4223b3b Commit 4<br/>* 736ca80 Commit 3<br/>* 07eac97 Commit 2<br/>* 7cc97ba Commit 1</span></pre><p id="94e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道提交 1 没有这个错误，所以让我们使用二分法从提交 2 转到提交 6，并找到导致不需要的行为的提交。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="aafc" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect start</span></pre><p id="b373" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开始等分后，我们必须定义<strong class="jx io">坏</strong>和<strong class="jx io">好</strong>提交。现在我在提交 6，这是一个错误的提交，所以:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ffc7" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect bad</span></pre><p id="ac93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并定义好的提交，即<strong class="jx io">提交 1 </strong>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="acf0" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect good 7cc97ba<br/>Bisecting: 2 revisions left to test after this (roughly 1 step)<br/>[736ca805144488ff1d2be31ded932d4ca17fffa8] Commit 3</span></pre><p id="c20b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们所做的是将提交<strong class="jx io"> 7cc97ba(提交 1) </strong>定义为一个好的提交。现在我们处于提交 3，徽标仍然是好的，因此我们必须将此提交定义为好的。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/ac5e5c8d0cd7fdb649e634c4a09f2b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*052KCCQlunsUCTkF-X1POw.jpeg"/></div></div></figure><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4467" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect good<br/>Bisecting: 0 revisions left to test after this (roughly 1 step)<br/>[f50d187a6263b8c7c360e787c210ee2e5e9f5a31] Commit 5</span></pre><p id="5951" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我去浏览器查看是否有变化时，我注意到徽标变大了。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/390b496d2817a10b79e558db4938d610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhmWzQIaqzyjA_RbSnsjDg.jpeg"/></div></div></figure><p id="eeca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑到这一点，我将当前的<strong class="jx io">提交(提交 5) </strong>定义为<strong class="jx io">错误的</strong>提交:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2397" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect bad<br/>Bisecting: 0 revisions left to test after this (roughly 0 steps)<br/>[4223b3bddc89c31f4ec27d2d353a0e9dd3018aa9] Commit 4</span></pre><p id="d4f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们处于<strong class="jx io">提交 4 </strong>阶段，这是一个<strong class="jx io">良好的</strong>提交，因为徽标是正常的。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fcd4" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect good<br/>f50d187a6263b8c7c360e787c210ee2e5e9f5a31 is the first bad commit<br/>commit f50d187a6263b8c7c360e787c210ee2e5e9f5a31<br/>Author: Marco Antonio Bet &lt;example@example.com&gt;<br/>Date:   Fri Apr 8 19:07:44 2022 -0300</span><span id="dd9c" class="mg kv in mc b gy mm mi l mj mk">    <strong class="mc io">Commit 5</strong></span><span id="1c51" class="mg kv in mc b gy mm mi l mj mk"> src/App.tsx | 2 +-<br/> 1 file changed, 1 insertion(+), 1 deletion(-)</span></pre><p id="5491" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">提交 5 </strong>是有 BUG 的一个，所以要完成平分工具，我们需要运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1bbf" class="mg kv in mc b gy mh mi l mj mk">➜ git bisect reset<br/>Previous HEAD position was 4223b3b Commit 4<br/>Switched to branch 'master'</span></pre><p id="0847" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们在 master，我们需要看看在 Commit 5 中做了哪些破坏 UI 的更改。你可以使用像 Git 北海巨妖和 Git Tower 这样的工具，或者使用命令行。我将向您展示如何使用命令行来查看由 commit 5 插入的更改。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="18ca" class="mg kv in mc b gy mh mi l mj mk">➜ git show f50d187<br/>commit f50d187a6263b8c7c360e787c210ee2e5e9f5a31<br/>Author: Marco Antonio Bet &lt;example@example.com&gt;<br/>Date:   Fri Apr 8 19:07:44 2022 -0300<br/><br/>    Commit 5<br/><br/>diff --git a/src/App.tsx b/src/App.tsx<br/>index a53698a..7c6bcf4 100644<br/>--- a/src/App.tsx<br/>+++ b/src/App.tsx<br/>@@ -6,7 +6,7 @@ function App() {<br/>   return (<br/>     &lt;div className="App"&gt;<br/>       &lt;header className="App-header"&gt;<br/><strong class="mc io">-        &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>+        &lt;img src={logo} className="app-logo" alt="logo" /&gt;</strong><br/>         &lt;p&gt;<br/>           Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload.<br/>         &lt;/p&gt;</span></pre><p id="8de6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然你已经知道了一个 bug 的提交，你可以用<strong class="jx io"> git revert </strong>来恢复这个提交，用<strong class="jx io"> git rebase -i </strong>来编辑，或者只是在所有提交之上添加一个修复提交。</p><p id="aee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想了解更多关于 git rebase 的知识，你可以看看我写的关于它的文章。</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/git-advanced-topics-part-one-5443ff7c9f1b"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">Git 高级主题第一部分</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我开始使用 git 已经一年了，在这篇文章中，我想教一些我的高级 git 技术。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">blog.devgenius.io</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jt mq"/></div></div></a></div><p id="deea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果您想要恢复提交，只需运行以下命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5409" class="mg kv in mc b gy mh mi l mj mk">➜ git revert f50d187<br/>Revert "Commit 5"<br/> <br/>This reverts commit f50d187a6263b8c7c360e787c210ee2e5e9f5a31.<br/> <br/># Please enter the commit message for your changes. Lines starting<br/># with '#' will be ignored, and an empty message aborts the commit.<br/>#<br/># On branch master<br/># Changes to be committed:<br/>#       modified:   src/App.tsx<br/>#</span></pre><p id="b158" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 vim 中，可以先用<code class="fe nf ng nh mc b"><strong class="jx io">ESC</strong></code>再用<code class="fe nf ng nh mc b"><strong class="jx io">:wq</strong></code>保存。最后，日志被固定。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/ac5e5c8d0cd7fdb649e634c4a09f2b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*052KCCQlunsUCTkF-X1POw.jpeg"/></div></div></figure><p id="cdc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能注意到，当使用<strong class="jx io"> git 平分</strong>时，我们从提交 3 开始，然后到提交 5，然后回到提交 4。这是因为<strong class="jx io"> git 二等分</strong>使用<strong class="jx io">二分搜索法</strong>来定位正在被搜索的提交。</p><h1 id="59c1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">搜索和查找</h1><p id="07da" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">搜索和查找不是一个合适的 git 工具，而是 git 日志工具中的一项功能。</p><p id="4583" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个例子，我克隆了 ReactJS 库，让我们从<code class="fe nf ng nh mc b">--before</code>和<code class="fe nf ng nh mc b">--after</code>开始。“之前”和“之后”是日期过滤器，您可以使用它们来查找或过滤<strong class="jx io"> git 日志</strong>中的内容。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ffd3" class="mg kv in mc b gy mh mi l mj mk">➜ git log # main branch ReactJS repository<br/>commit fea6f8da6ab669469f2fa3f18bd3a831f00ab284 (HEAD -&gt; main, origin/main, origin/HEAD)<br/>Author: Luna Ruan &lt;lunaris.ruan@gmail.com&gt;<br/>Date:   Mon Apr 11 16:56:20 2022 -0500</span><span id="f084" class="mg kv in mc b gy mm mi l mj mk">    [Transition Tracing] Add transition to OffscreenState and pendingSuspenseBoundaries to RootState (#24340)<br/>    <br/>    In this PR we:<br/>    <br/>    Add transitions boilerplate to the OffscreenState. The transitions field will be null on initiation. During the commit phase, if there are any new transitions, we will add any new transitions (either as a result of a transition occurring or a parent suspense boundary completing) to the transitions field. Once the suspense boundary resolves, we no longer need to store the transitions on the boundary, so we can put this field on the Offscreen memoized state<br/>    Add pendingSuspenseBoundaries boilerplate to the RootState. This field starts as null. During the commit phase, if a suspense boundary has either gone from fallback to resolved or from resolved to fallback, we will create a new Map if there isn't one, and if there is, we will add (if the boundary is a fallback) or remove the suspense boundary (if the boundary has resolved) from the map.<br/>    Add an optional name field to the Suspense boundary</span><span id="94af" class="mg kv in mc b gy mm mi l mj mk">commit 8e2f9b086e7abc7a92951d264a6a5d048defd914<br/>Author: Luna Ruan &lt;lunaris.ruan@gmail.com&gt;<br/>Date:   Mon Apr 11 16:54:57 2022 -0500</span><span id="9311" class="mg kv in mc b gy mm mi l mj mk">    move passive flag (#24339)</span></pre><p id="8d53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们希望从 4 月 7 日到 4 月 11 日提交:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bed2" class="mg kv in mc b gy mh mi l mj mk">➜ git log --before="4-11-2022" --after="4-7-2022"</span></pre><p id="0031" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以添加作者标志，如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7273" class="mg kv in mc b gy mh mi l mj mk">➜ git log --before="4-11-2022" --after="4-7-2022" --author="dan"</span></pre><p id="7c2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，另一个用途是从特定文件中搜索日志，为此:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f2c8" class="mg kv in mc b gy mh mi l mj mk">➜ git log -- README.md</span></pre><p id="569b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以添加更多过滤器，如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a6c8" class="mg kv in mc b gy mh mi l mj mk">➜ git log --before="4-1-2022" -- README.md</span></pre><p id="62ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件名前的破折号用于<strong class="jx io"> git 日志</strong>搜索具有该名称的文件，而不是具有该名称的分支。</p><p id="b50e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，您可以使用<code class="fe nf ng nh mc b">--grep</code>在提交消息中搜索术语:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6bf9" class="mg kv in mc b gy mh mi l mj mk">➜ git log --grep="refactor"<br/>commit ea7b2ec2898c615f648aec30fcbcf73aed156583<br/>Author: Andrew Clark &lt;git@andrewclark.io&gt;<br/>Date:   Wed Apr 6 23:01:07 2022 -0400<br/><br/>    Remove wrong return pointer warning<br/>    <br/>    I'm about to refactor part of the commit phase to use recursion instead<br/>    of iteration. As part of that change, we will no longer assign the<br/>    `return` pointer when traversing into a subtree. So I'm disabling<br/>    the internal warning that fires if the return pointer is not consistent<br/>    with the parent during the commit phase.<br/>    <br/>    I had originally added this warning to help prevent mistakes when<br/>    traversing the tree iteratively, but since we're intentionally switching<br/>    to recursion instead, we don't need it.<br/><br/>commit 2e0d86d22192ff0b13b71b4ad68fea46bf523ef6<br/>Author: Andrew Clark &lt;git@andrewclark.io&gt;<br/>Date:   Sun Mar 20 16:18:51 2022 -0400<br/><br/>    Allow updating dehydrated root at lower priority without forcing client render (#24082)<br/>    <br/>    * Pass children to hydration root constructor</span></pre><p id="9ae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Grep 也接受正则表达式，所以没有借口找到你想要提交。</p><h1 id="0d42" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">子模块</h1><p id="5f79" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有时你正在做的项目需要来自另一个地方或库的代码，在库的情况下你可以使用像 cargo 和 npm 这样的包管理器，但是如果你想改变代码，这将是很困难的，你会弄得一团糟。Git sobmodules 允许您在另一个 Git 项目中拥有一个 git 项目，这个子库拥有父库拥有的 git 的所有功能，但是上游是不同的，所以在子库中所做的更改将会传递到子库，并且子库可以随着子库来源的更改而更新，但是父库不会。</p><p id="8069" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于教学目的，我创建了两个存储库，一个称为 parent-repo，另一个称为 child-repo。父回购将需要来自子回购的代码，我们将使用 git 子模块将子回购项目导入到我们的父回购存储库中</p><p id="88ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">母回购</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="533d" class="mg kv in mc b gy mh mi l mj mk">➜ la<br/>total 8,0K<br/>drwxrwxr-x 8 mvisia mvisia 4,0K abr 12 21:57 .git<br/>-rw-rw-r-- 1 mvisia mvisia   32 abr 12 21:57 index.js<br/>➜ cat index.js<br/>console.log("Parent project")</span></pre><p id="fa1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">儿童回购</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ca46" class="mg kv in mc b gy mh mi l mj mk">➜ la<br/>total 12K<br/>-rw-rw-r-- 1 mvisia mvisia   44 abr 12 21:54 app.js<br/>drwxrwxr-x 8 mvisia mvisia 4,0K abr 12 21:55 .git<br/>-rw-rw-r-- 1 mvisia mvisia   87 abr 12 21:53 index.js<br/>➜ cat app.js<br/>const pack = require("./index.js")</span><span id="ae04" class="mg kv in mc b gy mm mi l mj mk">pack()<br/>➜ cat index.js<br/>const package = () =&gt; {<br/>        console.log("I am full git repo")<br/>}</span><span id="9804" class="mg kv in mc b gy mm mi l mj mk">module.exports = package</span></pre><p id="fa55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我想从子回购导入 index.js 中的包函数，我可以做的是使用 git 子模块从子回购引入代码，并将 git 功能引入父回购子模块。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="88dd" class="mg kv in mc b gy mh mi l mj mk">➜ git submodule add git@github.com:itsbetma/child-repo.git<br/>Cloning into...<br/>➜ la<br/>total 16K<br/>drwxrwxr-x 2 mvisia mvisia 4,0K abr 19 20:16 child-repo<br/>drwxrwxr-x 9 mvisia mvisia 4,0K abr 19 20:16 .git<br/>-rw-rw-r-- 1 mvisia mvisia   90 abr 19 20:16 .gitmodules<br/>-rw-rw-r-- 1 mvisia mvisia   32 abr 12 21:57 index.js</span></pre><p id="0c63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们在父回购中有了子回购的内容。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7292" class="mg kv in mc b gy mh mi l mj mk">➜ git status <br/>On branch main<br/>Changes to be committed:<br/>  (use "git restore --staged &lt;file&gt;..." to unstage)<br/>	new file:   .gitmodules<br/>	new file:   child-repo</span></pre><p id="9cae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，子回购未登台，让我们提交并推送。</p><p id="1576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您可以在父回购中使用子回购函数。</p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="2346" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在 child-repo 中做了一些更改，现在我想将它们带到 parent-repo 中，我该如何做？</p><p id="7a7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b88f" class="mg kv in mc b gy mh mi l mj mk">➜ cd child-repo # inside parent-repo<br/>➜ git status<br/>On branch main<br/>Your branch is up to date with 'origin/main'.</span><span id="3021" class="mg kv in mc b gy mm mi l mj mk">nothing to commit, working tree clean<br/>➜ git fetch<br/>remote: Counting objects: 100% (5/5), done.<br/>remote: Compressing objects: 100% (3/3), done.<br/>remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0<br/>Unpacking objects: 100% (3/3), 355 bytes | 355.00 KiB/s, done.<br/>From github.com:itsbetma/child-repo<br/>   bdaa0b1..5fd4dcf  main       -&gt; origin/main<br/>➜ git status<br/>On branch main<br/>Your branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.<br/>  (use "git pull" to update your local branch)</span><span id="48be" class="mg kv in mc b gy mm mi l mj mk">nothing to commit, working tree clean</span></pre><p id="f6af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，在 git 获取之后，我们在主分支中有了新的提交，但在本地子回购主分支中没有，为了解决这个问题并带来我们必须从原点获取的更新。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7f96" class="mg kv in mc b gy mh mi l mj mk">➜ git pull<br/>Updating bdaa0b1..5fd4dcf<br/>Fast-forward<br/> index.js | 1 +<br/> 1 file changed, 1 insertion(+)<br/>➜ git log<br/>* 5fd4dcf (HEAD -&gt; main, origin/main, origin/HEAD) changes for parent repo<br/>* bdaa0b1 First commit child</span></pre><p id="824a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一切都是最新的，工作顺利。</p><p id="eab9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是你可以用 git 子模块做的一件简单的事情，git 子模块中有很多你可以使用的功能。</p><p id="019c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个是 foreach 命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="cff9" class="mg kv in mc b gy mh mi l mj mk">➜ git submodule foreach 'git checkout main ; git pull'</span></pre><p id="a188" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在具有多个子模块的项目中使用 foreach 命令，我们需要在每个模块中运行相同的命令。像 git 拉进所有子模块。</p><p id="c994" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您到达了这里，那么恭喜您，现在您又有了四种 git 技术来改进您的工作流程。</p><p id="5030" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多 git 教程。</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/git-advanced-topics-part-one-5443ff7c9f1b"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">Git 高级主题第一部分</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我开始使用 git 已经一年了，在这篇文章中，我想教一些我的高级 git 技术。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">blog.devgenius.io</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jt mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/productivity-with-git-aliases-4829a118eb2"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">使用 Git 别名提高工作效率</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">从我开始实际工作到现在已经一年了，这是我第一次需要使用 git…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">blog.devgenius.io</p></div></div><div class="mz l"><div class="np l nb nc nd mz ne jt mq"/></div></div></a></div><p id="dac4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章很有用，请与你的朋友分享，保存起来以备后用，并给出一个👏。</p><p id="0e04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢关于 Git、Linux、生产率技巧、Typescript 和 Python 的内容，请关注我<a class="ae kt" href="https://medium.com/u/d708e403f9f9?source=post_page-----4829a118eb2-----------------------------------" rel="noopener"> Marco Antonio Bet </a>。</p><p id="575d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">…</p><p id="f5e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要了解更多信息:</p><ul class=""><li id="407b" class="nq nr in jx b jy jz kc kd kg ns kk nt ko nu ks nv nw nx ny bi translated"><a class="ae kt" href="https://git-scm.com/docs/git-reflog" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-reflog</a></li><li id="90c2" class="nq nr in jx b jy nz kc oa kg ob kk oc ko od ks nv nw nx ny bi translated">https://git-scm.com/docs/git-reset<a class="ae kt" href="https://git-scm.com/docs/git-reset" rel="noopener ugc nofollow" target="_blank"/></li><li id="b13b" class="nq nr in jx b jy nz kc oa kg ob kk oc ko od ks nv nw nx ny bi translated">【https://git-scm.com/docs/git-log T4】</li><li id="b321" class="nq nr in jx b jy nz kc oa kg ob kk oc ko od ks nv nw nx ny bi translated"><a class="ae kt" href="https://git-scm.com/docs/git-bisect" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-bisect</a></li><li id="2fe3" class="nq nr in jx b jy nz kc oa kg ob kk oc ko od ks nv nw nx ny bi translated"><a class="ae kt" href="https://git-scm.com/docs/git-submodule" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-submodule</a></li></ul></div></div>    
</body>
</html>