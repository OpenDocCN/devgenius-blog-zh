<html>
<head>
<title>Building a Go(lang) Console/REPL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建 Go(lang)控制台/REPL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-go-lang-console-repl-9df49dd33f12?source=collection_archive---------7-----------------------#2022-08-01">https://blog.devgenius.io/building-a-go-lang-console-repl-9df49dd33f12?source=collection_archive---------7-----------------------#2022-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/55c50a816ac63bddf3c25f5fa9759935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbWL-pogfdjqeuyvGmOmRg.png"/></div></div></figure><div class=""/><p id="cdc5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">REPL 是一种允许用户探索编程语言的计算机环境。在 REPL 环境中，代码由解释器输入和评估。评估后，输出将显示给用户。因为 Go 程序是编译的，所以这种语言没有提供 REPL 环境。最接近的选择是操场，它允许开发者立即运行他们的 Go 代码。我想建造，或者至少模拟一个 REPL 的环境。在这篇文章中，我将尝试构建一个 Go REPL/控制台，并强调我所做的一些设计决策。</p><h1 id="e8c5" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">回声“你好世界”</h1><p id="c6dc" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我构建环境的方法是生成一个 Go 文件。该文件将包括用户定义的代码，以及构建程序所需的其他代码。一旦代码生成，它就作为一个程序被执行，并且输出被记录回用户。这类似于 Go playground 的运行方式，只是支持代码是隐藏的。</p><p id="4df1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将实现一个递归调用的函数，直到程序终止。每次调用该函数时，都会提示用户进行输入。程序将等待输入。一旦输入，文本数据将被记录到控制台。这将是环境的基础，因为程序现在可以读取和打印。代码将如下所示:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/a974412e95f7114ec1223b049476d1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*mMg5Wt8zuJ7gZusNtwxbAw.png"/></div></figure><p id="265a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制台功能有 3 个参数。我把它们放在那里是为了跟踪包导入、变量和用户输入的行。这个函数看起来很混乱，运行之后，传递的数组没有持久化。每次调用后数组都会重置。为了解决可读性问题，我定义了一个自定义的结构类型来跟踪所有这些数据。请记住，我选择为 struct 方法使用指针来保存数组值。代码将如下所示:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/fab71cbec907fd8027f0134969ec36d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*Q8e7GJWRCSCKwoIonBT5UQ.png"/></div></figure><p id="2288" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将函数<code class="fe mc md me mf b">Process</code>实现为一个 struct 方法。该过程将检测用户输入的命令，并确定要采取的行动。switch 语句用于评估输入。未知的用户输入将在默认情况下被处理，因为我们不能可靠地确定它。switch 语句还将使我能够方便地添加更多的动作。如果你注意到了，我保存了一个用户指定的导入列表。该数组在构建时作为一个字符串连接，并写入将被执行以模拟代码评估的文件中。下一步将是更新控制台函数，以使用类型 Terminal。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/806dab9cb02d473fc9831854559a8e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*8ZhVy8AgxE7v4Tli3MzTZQ.png"/></div></figure><p id="21bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过添加终端类型，我减少了函数所需的参数数量。对我来说，它使函数更容易使用。既然存储机制已经存在，是时候为控制台添加新命令了。</p><h1 id="186a" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模拟命令</h1><p id="350f" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">该程序将有 4 个命令。第一个是<code class="fe mc md me mf b">import</code>，<code class="fe mc md me mf b">import</code>会给<code class="fe mc md me mf b">iCache</code>增加一个新条目。第二个命令的工作方式不同于 import。该命令将扫描输入行的等号，一旦检测到，它将把用户指定的行添加到<code class="fe mc md me mf b">vCache</code>中。<code class="fe mc md me mf b">vCache</code>在构建时被连接形成一个代码块，这个代码块被放置在生成的 Go 代码文件的 main 函数内。这将允许开发人员指定和存储变量以供进一步评估。第三个命令是<code class="fe mc md me mf b">clear</code>，该命令将删除<code class="fe mc md me mf b">iCache</code>和<code class="fe mc md me mf b">vCache</code>中的所有值。将列出第四个命令。列表将显示<code class="fe mc md me mf b">iCache</code>和<code class="fe mc md me mf b">vCache</code>中的所有值。任何未知命令都将被视为 Go 代码并进行评估。评估包括将用户代码放在生成的 Go 源文件中并执行它。这是函数<code class="fe mc md me mf b">Process</code>的最终版本:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5df10a71b8b36502b100636ef2ed5bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*rrJ6-ENzWwymVroVVJdOhA.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">变量标记出现了一个错误，带有 clear 的命令不能被识别。命令必须是“全部清除”才能工作</figcaption></figure><p id="900f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个要处理的函数是构建函数。我首先编写了一个函数，可以显示从终端实例生成的源代码。源代码是<code class="fe mc md me mf b">vCache</code>和<code class="fe mc md me mf b">iCache</code>数组的结果。下面是用于生成 Go 代码源的模板字符串:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a551c106796d6315c1ce16cdb946a8b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*isG06K5Bno-Skk2XXDTYnQ.png"/></div></figure><p id="80a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">填充和显示模板字符串的初始函数:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mn"><img src="../Images/d5ee7f90628ff6ca510b20ad354b7439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*2kt8x8P5PupGuXbd7K4cMw.png"/></div></div></figure><p id="b20e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候添加构建和运行代码的代码块了。我决定用命令<code class="fe mc md me mf b">go run</code>执行这个文件。这个命令将构建并执行源代码，为我减少了一个步骤。为了将命令与 REPL 程序集成，我使用了包<code class="fe mc md me mf b">os/exec</code>。我用 exec 包函数<code class="fe mc md me mf b">Command</code>实例化了一个命令。我用函数<code class="fe mc md me mf b">CombinedOutput</code>提取了输出。这确保了该命令发出的任何行文本都会报告给用户。方法<code class="fe mc md me mf b">Output</code>返回的错误对象只有退出状态代码，对我来说这似乎是无用的信息。下面是完整的构建函数:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/11b8ec5d57eebed6c7abd57e127f0541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*P5hhwjpLMx4UX3kJ7vNVqw.png"/></div></figure><p id="aa72" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，我有了一个基本的 Go 代码评估器。下面是运行中的控制台的屏幕截图:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/11abbc71c3e659e6eae7faae7f643a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*HtVxuCrQY4LjqZhzUIsVVg.png"/></div></figure><p id="96dd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住上面的输出，您可以看到一些设计决策是如何反映在控制台的行为中的。未知命令被视为 Go 代码进行评估。这是它是如何建成的，现在，这里有一个解决方案实施的评论家。在此之前，再来一张控制台截图:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/c6f7e8ac7318d8f7d7bbdf46c1d94c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4F-j-jcy6fq8Wy8NPLWwiQ.png"/></div></div></figure><h1 id="b41e" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">批评家们</h1><p id="5137" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我将从您可能已经想到的一个问题开始，为什么要为静态编译语言构建 REPL？这个博客的目标是尝试新的想法。Go playground 也证明了 Go 开发者喜欢测试代码的环境。带来了一系列的限制。箭头键输入被记录为字符，导致控制台没有实际的文本光标。读者返回的文本有多余的字符。这将导致预处理输入，以防止意外的行为。这个解决方案有一个学习曲线。必须告诉用户如何导入包。与其他 REPL 环境不同，这个环境需要调用打印函数来显示输出。这个问题以及更多的批评都可以通过更好的编程来解决。事实上，有一些开源项目提供了有效的 Go 解释器。</p><h1 id="75ef" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="8aba" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如用 Yaegi 演示的那样，做一个 Go 解释器是可能的。这篇文章中的程序被精简到基本组件。我想让读者发现我构建围棋控制台的方法。用复杂的代码很难表达这些观点，所以我选择了简单但有限的实现。希望这些概念可以进一步打磨，落实到自己的使用中。</p><p id="cbcb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来源</p><div class="im in gp gr io mr"><a href="https://github.com/cheikhshift/medium_examples/tree/main/goconsole" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iz gy z fp mw fr fs mx fu fw ix bi translated">medium _ examples/goconsole at main cheikh shift/medium _ examples</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div></div></a></div><div class="im in gp gr io mr"><a href="https://github.com/traefik/yaegi" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iz gy z fp mw fr fs mx fu fw ix bi translated">GitHub - traefik/yaegi: Yaegi 是另一个优雅的 Go 解释器</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Yaegi 是另一个优雅的围棋翻译家。它支持可执行的 Go 脚本和插件，在嵌入式解释器或…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf iu mr"/></div></div></a></div></div></div>    
</body>
</html>