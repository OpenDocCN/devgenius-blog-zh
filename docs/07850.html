<html>
<head>
<title>Go GRPC Fundamentals and Keys Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋 GRPC 基础和关键概念</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-grpc-fundamentals-and-keys-concepts-a6340ac929c?source=collection_archive---------7-----------------------#2022-04-27">https://blog.devgenius.io/go-grpc-fundamentals-and-keys-concepts-a6340ac929c?source=collection_archive---------7-----------------------#2022-04-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0f72" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">gRPC 概念及示例</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d301618700b88b93c0292ef675ac4fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K7bCplaYbV64gmEb"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">美国宇航局在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="9d06" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><p id="af5f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><strong class="ln io"> gRPC </strong>是 Google 开发的高性能远程过程调用框架，帮助构建和消费远程服务。</p><p id="b7f2" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这篇文章着眼于如何创建一个简单的包含 gRPC 服务器和客户端的 gRPC 应用程序。这篇文章将与你分享如何从头开始构建 gRPC 服务的基础知识。</p><blockquote class="mm"><p id="a082" class="mn mo in bd mp mq mr ms mt mu mv mg dk translated">请点击查看完整代码<a class="ae ks" href="https://github.com/imadmaachari/grpc-note-app" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><h1 id="9794" class="kt ku in bd kv kw kx ky kz la lb lc ld jt mw ju lf jw mx jx lh jz my ka lj lk bi translated">gRPC</h1><p id="1bff" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">如前所述，gRPC 是一个 RPC 框架，它利用 HTTP/2 和协议缓冲区(又名 Protobuf)，使其成为微服务的快速和安全的协议。</p><p id="9093" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">但是等等！这是什么 HTTP/2 和协议缓冲区？</p><h2 id="aaac" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">HTTP/2</h2><p id="671f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">gRPC 是为使用 HTTP/2 而设计的，HTTP/2 是 HTTP 的一个主要修订版，与 HTTP 1.x 相比提供了显著的性能优势。</p><p id="5292" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">它支持双向流:一旦建立了连接，客户机或服务器就可以推和拉数据。</p><blockquote class="nl nm nn"><p id="b3be" class="ll lm no ln b lo mh jo lq lr mi jr lt np mj lw lx nq mk ma mb nr ml me mf mg ig bi translated">查看这个<a class="ae ks" href="http://www.http2demo.io/" rel="noopener ugc nofollow" target="_blank">演示</a>，比较 HTTP/2 和 HTTP/1 的性能</p></blockquote><p id="04b3" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">需要注意的是，<strong class="ln io">T11<strong class="ln io">HTTP/2</strong>并不是 gRPC 独有的。许多请求类型，包括带有 JSON 的 HTTP APIs，都可以使用 HTTP/2，并从其性能改进中受益。</strong></p><h2 id="277b" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">协议缓冲区</h2><p id="1ad7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">gRPC 是一个基于<strong class="ln io">合同的</strong>设计工作流，这意味着我们首先需要定义我们的消息的<em class="no">结构。消息使用协议缓冲区(强类型、基于二进制)序列化，这是一种高效的<em class="no">二进制</em>消息格式。Protobuf 在服务器端和客户端序列化非常快。这导致更有效的小消息有效负载。服务定义是以声明方式定义的，用于生成客户机和服务器存根(使用 protocol)。与 JSON(松散类型、基于文本)相比，协议缓冲区可以减小传输的有效载荷的大小，从而降低带宽成本。</em></p><h2 id="7805" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">gRPC 方法类型</h2><p id="ead1" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">gRPC 服务可以有不同类型的方法来描述服务如何发送和接收消息。gRPC 方法类型有:</p><ul class=""><li id="b5b4" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated"><strong class="ln io">一元</strong>:方法是一元类型，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。当返回响应时，一元调用完成。</li></ul><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="613a" class="mz ku in oc b gy og oh l oi oj"><strong class="oc io">rpc</strong> SayHello(HelloRequest) <strong class="oc io">returns</strong> (HelloResponse);`</span></pre><ul class=""><li id="a18e" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated"><strong class="ln io">服务器流:</strong>服务器流方法是客户端向服务器发送一个请求，然后获得一个流来读回一系列消息。当方法返回时，服务器流调用完成。</li></ul><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="b048" class="mz ku in oc b gy og oh l oi oj"><strong class="oc io">rpc</strong> LotsOfReplies(HelloRequest) <strong class="oc io">returns</strong> (stream HelloResponse);</span></pre><ul class=""><li id="ea8d" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated"><strong class="ln io">客户端流式传输:</strong><strong class="ln io"/>客户端流式传输方法是客户端编写一系列消息并发送给服务器。一旦客户端写完消息，它就等待服务器读取消息并返回响应。</li></ul><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="7fe6" class="mz ku in oc b gy og oh l oi oj"><strong class="oc io">rpc</strong> LotsOfGreetings(stream HelloRequest) <strong class="oc io">returns</strong> (HelloResponse);</span></pre><ul class=""><li id="15e9" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated"><strong class="ln io">双向流:</strong>双向流，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序进行读写。</li></ul><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="4b32" class="mz ku in oc b gy og oh l oi oj"><strong class="oc io">rpc</strong> BidiHello(stream HelloRequest) <strong class="oc io">returns</strong> (stream HelloResponse);</span></pre><p id="a61a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们把手弄脏吧🤩</p><h2 id="0e01" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">先决条件</h2><ul class=""><li id="82c7" class="ns nt in ln b lo lp lr ls lu ok ly ol mc om mg nx ny nz oa bi translated">去</li><li id="708d" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated">Protobuf 编译器</li></ul><p id="a4ca" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">除此之外，我们将在下面安装一些 gRPC 专用工具。注意，我们将使用一些特定于<strong class="ln io">窗口</strong>的命令。</p><p id="1251" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">安装 Protobuf 编译器:</p><p id="9269" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">要从预编译的二进制文件中安装<a class="ae ks" href="https://developers.google.com/protocol-buffers/docs/downloads#release-packages" rel="noopener ugc nofollow" target="_blank">最新版本的</a>协议编译器，请从<a class="ae ks" href="https://github.com/google/protobuf/releases" rel="noopener ugc nofollow" target="_blank">github.com/google/protobuf/releases</a>下载与您的操作系统对应的 zip 文件。然后，更新您的环境变量以包含到<code class="fe os ot ou oc b">protoc</code>可执行文件的路径(例如。c:\ Tools \ protocol-3 . 18 . 0-win 64 \ bin)。</p><p id="33fa" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">安装 Go 特定的 gRPC 依赖项:</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="0475" class="mz ku in oc b gy og oh l oi oj">go install http://google.golang.org/protobuf/cmd/protoc-gen-go@v1.26<br/>go install http://google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span></pre><h1 id="d664" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">项目设置</h1><h2 id="7528" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">项目结构</h2><p id="82f0" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">没有商定的项目结构。我们将使用 Go 模块，并从初始化一个新项目开始。所以我们的业务问题是这样的——我们有一个 notestore，我们想通过 RPC 函数公开它的 crud 函数。</p><p id="a066" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们可以为服务器创建一个名为<code class="fe os ot ou oc b">server</code>的新文件夹，并初始化它，如下所示:</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="db3d" class="mz ku in oc b gy og oh l oi oj">go mod init <!-- -->grpc-note-app</span></pre><p id="dfea" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这是这篇文章最后的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7b3198f6d8a77d7db190a5f363deed25.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*XayY4Wa-JLvoDSUBDXw0SQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">项目结构</figcaption></figure><h2 id="8507" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">使用创建服务定义。原型文件</h2><p id="00e4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">请注意，常见的模式是保持。单独文件夹中的原型文件。以便从服务器和客户端都可以访问它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/6178e00a3c8e2367e8d9240c4929903b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9c7TR_TO44miWEzVBqKR7g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">note.proto 文件</figcaption></figure><blockquote class="nl nm nn"><p id="8f89" class="ll lm no ln b lo mh jo lq lr mi jr lt np mj lw lx nq mk ma mb nr ml me mf mg ig bi translated">需要注意的一点是<strong class="ln io">选项</strong>关键字<strong class="ln io">的使用。</strong>它告诉 protoc 我们想把生成的存根放在哪里。在某些情况下，根据用于生成存根的语言，您可能会发现多个选项语句。</p></blockquote><p id="41fd" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">此外，在我们的示例中，我们有 5 条消息来表示注释实体。请求和响应，我们定义了一个名为 NoteService 的服务，它有两个 RPC，分别名为 CreateNoteList 和 GetNoteList，可以从客户端调用。</p><h2 id="5bf0" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">生成我们的存根</h2><p id="81e0" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">创建服务契约(IDL)后，我们可以分别为服务器和客户机生成 Go 存根。</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="7eed" class="mz ku in oc b gy og oh l oi oj">protoc prototype/*.proto -I. --go_out=plugins=grpc:prototype</span></pre><p id="0d6d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">接下来，让我们创建服务器来响应任何传入的请求。</p><h2 id="106d" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">创建 gRPC 服务器</h2><p id="039d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们初始化名为 main 的包，以及实现服务器所需的所有依赖项:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/0e2f8320615c53407975629d5d78e36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2_4iCg01u366UuM8ZuXPw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">服务器主包</figcaption></figure><p id="e302" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们在服务器文件夹中创建服务器文件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/df6ea14f179a6229b8efa5ef1890e978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQdVSs1yLMzygIUsHC8Kew.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">gRPC 服务器</figcaption></figure><ul class=""><li id="422b" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated">我们首先定义一个结构，它将实现我们的服务器 RPC 方法，稍后我们的客户机将调用这些方法。</li><li id="2ed6" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated">在 main 函数中，我们使用 net 在 TCP 端口 50056 上创建一个侦听器。倾听法。我们创建一个新的 gRPC 服务器实例，注册我们的 noteServer。最后但同样重要的是，我们为我们的 note 服务器提供服务，并开始响应传入的请求。</li></ul><h2 id="7f55" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">与服务器交互</h2><p id="33b4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">通常，当与 HTTP/1 之类的服务器交互时，我们使用 REST 工具(Postman，cURL)与 API 交互，发出请求并检查响应，然而，使用 gRPC，我们无法做到这一点(您可以向 HTTP/2 服务发出请求，但这些请求是不可读的)。为此我将使用<a class="ae ks" href="https://github.com/fullstorydev/grpcui" rel="noopener ugc nofollow" target="_blank"> gRPC-UI </a>。</p><p id="3e72" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">您可以使用下面的命令安装它:</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="1e7f" class="mz ku in oc b gy og oh l oi oj">go install github.com/fullstorydev/grpcui/cmd/grpcui@latest</span></pre><p id="a760" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">安装后，您可以运行服务器和 grpc-ui(您应该指向 grpc 服务器端口):</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="1dcf" class="mz ku in oc b gy og oh l oi oj">go run server/server.go<br/>grpcui -plaintext 0.0.0.0:50056</span></pre><p id="fa71" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们如何确定服务的端点？注意，您需要在 gRPC 服务器上注册反射服务(启用反射)<strong class="ln io">或</strong>提供 proto 文件的路径。</p><blockquote class="nl nm nn"><p id="8c95" class="ll lm no ln b lo mh jo lq lr mi jr lt np mj lw lx nq mk ma mb nr ml me mf mg ig bi translated">//在 gRPC 服务器上注册反射服务。</p><p id="badd" class="ll lm no ln b lo mh jo lq lr mi jr lt np mj lw lx nq mk ma mb nr ml me mf mg ig bi translated">反思。登记册</p></blockquote><p id="2cb8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在我们准备好接受客户的请求了。</p><p id="7255" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">以下是使用 gRPC-IU 运行测试的一些截图:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/b8c6eba3154f9524fdb41b83e5ba24de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wH3Xj-hYp1x-KgsFGIGTg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">创建便笺 RPC</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/32b2f9ac2ef351d88973d4106fee09d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBSk-Lp_Q5l3bOjjVWt6Vg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">获取注释 RPC 列表</figcaption></figure><h2 id="46cd" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">创建 gRPC 客户端</h2><p id="5323" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">现在，我们可以创建 gRPC 客户端了，为此，我们需要编辑 client/cli 文件夹中的 client.go 文件。</p><p id="b45b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们初始化名为 main 的包，以及所有需要的依赖项:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pb"><img src="../Images/a60e1d0177b996c43e21b0d9d9151f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBIVohSnA30g8Bql2-yRVg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">客户端主包</figcaption></figure><p id="3621" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">定义我们的主要功能:</p><ul class=""><li id="c5c2" class="ns nt in ln b lo mh lr mi lu nu ly nv mc nw mg nx ny nz oa bi translated">初始化 gRPC 客户端</li><li id="9ccb" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated">连接到 gRPC 服务器</li><li id="75b4" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated">调用服务器 RPC 函数</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pc"><img src="../Images/3d16853a099518b77096759a4d1f9324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2q3_VTTfOKbuT2I39T2Cfw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">gRPC 客户端</figcaption></figure><h2 id="16d6" class="mz ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">让我们测试我们的 gRPC 服务器和客户机</h2><p id="e51a" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">启动我们的 gRPC 服务器:</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="ce82" class="mz ku in oc b gy og oh l oi oj">go run server/server.go</span></pre><p id="f334" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">然后，在终端的另一个选项卡中，启动 gRPC 客户端，它调用我们所有的服务器 RPC 函数:</p><pre class="kd ke kf kg gt ob oc od oe aw of bi"><span id="eabb" class="mz ku in oc b gy og oh l oi oj">go run client/cli/client.go</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/7878debb457e3eb65e7275a8f8029b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpNnlHjRj07GUlj8zVBWbg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">gRPC 客户端调用</figcaption></figure><h1 id="7e61" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">摘要</h1><p id="c7f4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们已经发现了 gRPC 在 Go 语言中的使用，以及构建 gRPC 项目所需的配置工具。此外，我们还研究了如何使用 Go 创建一个简单的 gRPC 服务器和客户端。在接下来的故事中，我们将使用更复杂的模式深入 gRPC，包括流特性。</p><p id="21b5" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">请随意评论和反馈。好书，✌️.</p><h1 id="156b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">链接</h1><ul class=""><li id="3494" class="ns nt in ln b lo lp lr ls lu ok ly ol mc om mg nx ny nz oa bi translated"><a class="ae ks" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区——开发者谷歌</a></li><li id="1846" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated"><a class="ae ks" href="https://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a></li><li id="bb4d" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated"><a class="ae ks" href="https://youtu.be/46O73On0gyI" rel="noopener ugc nofollow" target="_blank">协议缓冲速成班</a></li><li id="6732" class="ns nt in ln b lo on lr oo lu op ly oq mc or mg nx ny nz oa bi translated"><a class="ae ks" href="https://jbrandhorst.com/post/go-protobuf-tips/" rel="noopener ugc nofollow" target="_blank">的原型提示</a></li></ul></div></div>    
</body>
</html>