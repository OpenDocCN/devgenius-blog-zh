# 在函数内部修改 Python 变量的奇怪副作用

> 原文：<https://blog.devgenius.io/the-weird-side-effects-of-modifying-python-variables-inside-a-function-ba1e5ca65192?source=collection_archive---------4----------------------->

![](img/f744a9a03404f590fc600af0f9478ffc.png)

照片由[瓦迪姆·萨多夫斯基](https://unsplash.com/@vadimsadovski?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

在编写 Python 时，你是否遇到过代码中的一个错误，你认为你在修改一个局部变量，但实际上却在函数之外修改了变量？

例如，如果您有这样一个函数:

```
def add_one(x: int, y: list) -> None:
    x += 1
    y += [1]
```

当你称之为

```
a = 0
b = []
add_one(a, b)
```

你发现`a = 0`，但是`b = [1]`。

在本文中，我们将探究是什么导致了这种行为，这样您就可以避免在代码中遇到奇怪的错误。

# 可变和不可变

理解这种行为的第一步是了解可变类型和不可变类型在赋值时的行为差异。

在 Python 中，我们有可变和不可变的数据类型，这意味着您可以修改一些数据类型的值，而不能修改其他数据类型的值。

可变类型的例子有

*   字典
*   列表
*   设置
*   班

不可变类型的例子有

*   用线串
*   整数
*   漂浮物
*   布尔运算
*   元组

拥有可变的数据类型意味着我们可以修改它们并且仍然拥有相同的对象，而如果我们试图修改一个不可变的类型，我们会创建一个新的对象，为了能够在幕后演示这一点，我们将使用内置的`id()`方法，该方法为我们提供了对象的唯一标识符。如果两个对象具有相同的标识符，那么它们引用相同的对象，而如果标识符不同，那么它们引用不同的对象。

通过比较可变数据类型(list)和不可变数据类型(int)，我们可以看到这一点:

```
x = 0
y = []id(x)  # 4353643616
id(y)  # 4356958960x += 1
y += [1]id(x) # 4353643648
id(y)   # 4356958960
```

这里我们可以看到的是，当前引用值 0 的`x`加 1 后，现在引用了一个新的对象，即整数 1。相反，我们的`y`列表仍然引用同一个对象。

因此，我们可以看到，如果我们试图修改一个不可变的数据类型，我们实际上引用了一个新的对象，而对于一个可变的对象，我们保留了对同一对象的引用，而是直接修改对象的内容。

# 通过转让转让

既然我们已经看到了在对可变对象和不可变对象应用操作时它们工作方式的不同，那么让我们来理解这个难题的另一部分，它决定了为什么我们可以像前面看到的那样在一个函数中修改可变对象。

这种行为是由于 Python 如何处理向函数传递参数，这是通过一个叫做“通过赋值传递”的原则来完成的。通过赋值传递意味着我们以处理变量赋值的相同方式传递变量，例如:

```
a = 1
b = ab is a  # Truea += 1
b is a  # False
```

这里发生的事情是，我们将 a 赋值给 integer 对象 1 的引用，然后我们将 b 赋值为等于`a`。用 Python 的术语来说，这意味着`b`现在与`a`引用同一个对象。随后的检查`b is a`检查条件两边的组件是否引用了同一个对象，如果是，则返回 True，否则返回 False。

如果我们修改`a`，给它加 1，因为我们知道整数是不可变的，a 现在引用一个新对象，而`b`仍然引用旧对象，因此它们不再引用同一个对象。

现在知道了赋值是如何工作的，如果我们回头看看我们的列表示例:

```
x = []
y = x
x is y  # Truex += [1]
x is y  # Trueprint(x)  # [1]
print(y)  # [1]
```

这里我们有示例原则，其中`x`和`y`引用同一个对象。然而，由于 list 是一个可变的对象，修改它不会导致创建和引用一个新的对象，相反，我们保持相同的对象引用，只是修改对象的内容。

# 将这一切结合在一起

既然我们已经理解了可变对象和不可变对象的区别，以及 Python 中赋值的工作方式，那么让我们来理解当我们从上面调用 add_one 函数时实际发生了什么。

为了避免滚动太多，让我们再一次复制我们的玩具例子

```
def add_one(x: int, y: list) -> None:
    x += 1
    y += [1]a = 0
b = []add_one(a, b)
print(a) # 0
print(b) # [1]
```

创建函数后，我们做的第一件事是给 a 赋值引用整数对象 0，给 b 赋值一个空列表对象。

接下来我们用`a`和`b`调用函数，这意味着`x`被赋予了`a`的值，而`y`被赋予了`b`的值。从上一节我们知道，这意味着`x`引用了包含在`a`中的值，而`y`引用了包含在`b`中的值。

现在在函数内部，我们通过给`x`加 1 来修改它。因为我们的整数是不可变的，`x`被分配来引用新的整数对象。

接下来，我们将元素 1 添加到列表的末尾。在这种情况下，由于我们的列表是可变的，我们没有创建一个新的对象，而是更新现有的对象。

现在我们已经到达了函数的末尾并离开了它的作用域，`x`和`y`不再存在，因为它们是`add_one`函数作用域的局部变量。我们的值 a 从来没有更新过，因为它引用的对象从来没有改变过(因为它是不可变的)。另一方面，我们的值`b`确实发生了变化，因为它所引用的对象发生了变化。

# 摘要

Python 的内部功能非常强大，允许非常灵活的代码。然而，如果我们没有完全理解幕后发生的事情，有时我们会被他们的行为弄得措手不及。这可能会导致程序中出现奇怪的 bug，让人觉得很难追踪。

了解 Python 的赋值操作是如何工作的，以及可变和不可变数据类型在修改下的不同表现，意味着您不仅可以避免在程序中错误地出现这些“错误”,而且实际上您可以使用这些行为来编写更干净、更简洁的 Python 代码