<html>
<head>
<title>.Net C# — Clean Architecture &amp; Dependency-Inversion-Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。Net C# —干净的架构和依赖倒置原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/net-c-clean-architecture-dependency-inversion-principle-7ea64f586c58?source=collection_archive---------6-----------------------#2022-10-23">https://blog.devgenius.io/net-c-clean-architecture-dependency-inversion-principle-7ea64f586c58?source=collection_archive---------6-----------------------#2022-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c4df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章是关于五个坚实原则中的最后一个——依赖倒置原则。其中一个重要的部分是理解接口在软件开发中的好处。在这种情况下，为了提供最大限度的整洁，我还将深入探讨软件架构的主题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0e0731a48b8c8c3a2a3a24a37443dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQrAbxWH2VYn0cJVlBefyQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/photos/architecture-building-city-design-1840297/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/architecture-building-city-design-1840297/</a></figcaption></figure><p id="e874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">向我的兄弟和导师</em> <a class="ae ky" href="https://medium.com/@tobias.streng" rel="noopener"> <strong class="jm io"> <em class="kz">托比亚斯·斯特兰</em></strong></a><em class="kz">—</em><br/><em class="kz">如果你喜欢这篇文章并想在。</em> <strong class="jm io"> <em class="kz">网</em> </strong> <em class="kz">和</em> <strong class="jm io"> <em class="kz">角</em> </strong> <em class="kz">，请关注我们:P </em></p><h1 id="6a35" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">有意义的代码的关键是有意义的架构</h1><p id="969c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">首先，我们需要建立一个有用的代码架构。我偏爱的模式是基于 Jason Tayors 的 clean Architecture。Net 应用程序。</p><p id="bffe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像 Robert C. Martins 已经解释过的那样:<br/>一个整体系统首先被<strong class="jm io">划分成几个更小的系统/项目，</strong>然后这些系统/项目形成彼此之间明确定义的依赖和接口。这些系统可以分解成不同的模块，每个模块服务于一个特定的目的。这种整体系统的结构基于洋葱层模型，每一层代表一个模块。</p><p id="7705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在模型的中间是<strong class="jm io">域层</strong>，它为所有其他模块提供基本的元素或类，并且不能依赖于任何其他层。</p><p id="c892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二层包含<strong class="jm io">应用层</strong>，负责实际工作逻辑。后续级别使用的元素也可以在这里定义。</p><p id="8781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最外面的两层，即<strong class="jm io">表示和基础设施</strong>，提供外部影响。<br/> <strong class="jm io">基础设施</strong>提供来自外部来源的数据和<strong class="jm io">表示</strong>，例如图形用户界面，如果可用的话。</p><p id="ddd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这种架构形式，各个外层总是依赖于内层，但是内层不依赖于外层。这使得外层可以互换。表示层是 web 界面还是 API 并不重要，逻辑是一样的。也有可能实现另一个数据库，没有任何问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/d101699d95ba973bd82d7fc3b7adac10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBclycTARuwH6cW5hM1kwA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://jasontaylor.dev/clean-architecture-getting-started/" rel="noopener ugc nofollow" target="_blank">https://jasontaylor.dev/clean-architecture-getting-started/</a></figcaption></figure><p id="d80c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">罗伯特·c·马丁首先解释了这一原则，并在本质上描述了<strong class="jm io">更高层次的元素不应该依赖于更低层次的元素。</strong>层次中较高级别的元素可能<strong class="jm io">只知道其服务元素的接口</strong>，而不知道服务元素本身。因此，较低层次的变化会影响较高层次，但反之亦然。在较高和较低的元素之间绘制了一个抽象层，这确保了调用不会发送到执行元素本身，而是发送到它的层</p><h1 id="5b7c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用命令行界面设置项目:</h1><p id="27fb" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">基本上，整个项目被分成几个小项目。<br/>要创建它们，<strong class="jm io">打开控制台</strong>并依次运行以下命令<strong class="jm io">:</strong></p><blockquote class="me mf mg"><p id="fdbb" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">mkdir name your application<br/>CD name your application<br/>dot net new SLN<br/>mkdir src<br/>mkdir test</p><p id="19c4" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">cd src</p><p id="2099" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">mkdir 域<br/> cd 域<br/> dotnet new classlib <br/> cd..</p><p id="bfe9" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">mkdir Application<br/>CD Application<br/>dot net new class lib<br/>CD..</p><p id="cc95" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">mkdir 基建<br/> cd 基建<br/> dotnet new classlib <br/> cd..</p><p id="eef6" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">mkdir Presentation<br/>CD Presentation<br/>dotnet new console<br/>CD..</p><p id="ca2e" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">激光唱片..<br/> cd..</p><p id="46bc" class="jk jl kz jm b jn jo jp jq jr js jt ju mh jw jx jy mi ka kb kc mj ke kf kg kh ig bi translated">dotnet SLN add src/Domain/<br/>dotnet SLN add src/Application<br/>dotnet SLN add src/基建<br/>dotnet SLN add src/Presentation</p></blockquote><h1 id="d064" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">示例数据库</h1><p id="0e4b" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">让我们以下面的场景为例:我们需要来自任何数据库的数据，希望处理这些数据，然后在最后再次输出。然后我们将看到为什么数据来自哪里并不重要。</p><h1 id="eb3c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">域:</h1><p id="9d4c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">域<strong class="jm io">包含从每个项目</strong>调用的所有元素。这些可以是必须普遍可用的类和方法。</p><h2 id="5539" class="mk lb in bd lc ml mm dn lg mn mo dp lk jv mp mq lo jz mr ms ls kd mt mu lw mv bi translated">对象:</h2><p id="b0c9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">首先，我们需要一个例子。让我们创建一个包含一些家具典型属性的对象<em class="kz">表</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4d75d7d087eb7c3da08742b5b341ed6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*bIJhSR2qCYuMumfx8VmOsg.png"/></div></figure><h2 id="be29" class="mk lb in bd lc ml mm dn lg mn mo dp lk jv mp mq lo jz mr ms ls kd mt mu lw mv bi translated">连接</h2><p id="f0d3" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">依赖倒置完全基于使用接口。一个接口有点像一个“模板”或者一个“规则”你的类应该是什么样子。<strong class="jm io">是一个类似于类的类型定义，除了它纯粹代表了一个对象和它的用户之间的契约</strong>。它既不能直接实例化为对象，也不能定义数据成员。因此，接口只不过是方法和属性声明的集合。</p><p id="ff46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在这个例子中，我们只需要方法 GetDataBase( </strong>)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/38c1ff50bcd1a85ee2b9651f76e165fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neQbV3-If9DcWW7UBByagQ.png"/></div></div></figure><h1 id="bc7b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">申请:</h1><p id="6074" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">应用程序<strong class="jm io">包含整个程序的业务逻辑</strong>。这是进行数据处理的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/7b91595f14a444266cee3c80677b8aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-j19nRRb7efep5K76pmdw.png"/></div></div></figure><h1 id="8438" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基础设施:</h1><p id="d599" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">基础设施<strong class="jm io">包含从外部引入到整个项目中的所有元素。</strong>可以是数据库或 API</p><h2 id="ecfc" class="mk lb in bd lc ml mm dn lg mn mo dp lk jv mp mq lo jz mr ms ls kd mt mu lw mv bi translated">数据库:</h2><p id="5afd" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这里我们将模拟一个<strong class="jm io">假数据库</strong>来更好地说明这个原理</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/aac05baa91bfdb783341d181f14beedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS9M2I7IhGKqddA5G4AsJA.png"/></div></div></figure><h1 id="110e" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">项目浏览器:</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c3a89f48c277781df1284a49f24f9ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*GOKGx-7gFoySGovVO6nzHQ.png"/></div></figure><h1 id="bbdc" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="284b" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">将整个项目划分为几个更小的单元在开始时可能有点陌生，但这有助于保持跟踪，并使以后更容易更改代码。与软件开发的其他领域相比，这种方法也非常适合初学者。<br/>通过被限制在接口上，产生错误的可能性被大大降低了，并且未来的改变不会出现预期的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/25c684f524aa3aedb1f25a5efc4616fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6Rv91ujvPDV4lHJYzQHcw.png"/></div></div></figure><h1 id="c952" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">请查看我的其他文章:</h1><ul class=""><li id="579a" class="nb nc in jm b jn ly jr lz jv nd jz ne kd nf kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/codex/linq-how-to-avoid-nested-loops-in-c-ed4ae19886e4" rel="noopener">LINQ——如何避免 C#中的嵌套循环</a></li><li id="ac7c" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/dev-genius/programming-paradigms-a-very-short-brief-5324908640bd" rel="noopener">编程范例—简介</a></li><li id="8ae1" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/codex/c-object-oriented-programming-oop-2d92a5cd336f" rel="noopener"> C# —面向对象编程</a></li><li id="d258" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/@sebastianstreng96/c-single-responsibility-easily-explained-e3fabbf0d877" rel="noopener">c#——简单解释的单一责任</a></li><li id="6694" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/@sebastianstreng96/ocp-what-really-matters-610159d600dc" rel="noopener">OCP——真正重要的是什么</a></li><li id="495a" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/@sebastianstreng96/top-8-tips-to-improve-your-motivation-as-programmer-be63b2baaf7e" rel="noopener">提高程序员积极性的 8 大技巧</a></li><li id="01cb" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/codex/a-brief-insight-into-networks-2171f1e9aea1" rel="noopener">对网络的简要了解</a></li><li id="335f" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/codex/send-receive-the-7-layer-osi-model-e475829b999" rel="noopener">发送&amp;接收—7 层 OSI 模型</a></li><li id="5cf3" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://medium.com/@sebastianstreng96/7-layer-network-protocols-easily-explained-e11e3e09f34d" rel="noopener">七层网络协议浅显易懂</a></li></ul></div></div>    
</body>
</html>