<html>
<head>
<title>LeetCode — 20: Valid Parentheses (get solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode — 20:有效括号(用图像获取解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-20-valid-parentheses-c63972c6f50b?source=collection_archive---------1-----------------------#2022-07-24">https://blog.devgenius.io/leetcode-20-valid-parentheses-c63972c6f50b?source=collection_archive---------1-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:→<a class="ae kl" href="https://leetcode.com/problems/valid-parentheses/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/valid-parentheses/</a></p><h1 id="b31f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题:→ </strong></h1><p id="8a83" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">给定一个仅包含字符<code class="fe lp lq lr ls b">'('</code>、<code class="fe lp lq lr ls b">')'</code>、<code class="fe lp lq lr ls b">'{'</code>、<code class="fe lp lq lr ls b">'['</code>和<code class="fe lp lq lr ls b">']'</code>的字符串<code class="fe lp lq lr ls b">s</code>，确定输入的字符串是否有效。</p><p id="af89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以下情况下，输入字符串有效:</p><ol class=""><li id="fa4e" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">左括号必须用相同类型的括号括起来。</li><li id="70f1" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">左括号必须以正确的顺序结束。</li></ol><p id="365d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 1: </strong></p><pre class="mh mi mj mk gt ml ls mm mn aw mo bi"><span id="dd7b" class="mp kn iq ls b gy mq mr l ms mt"><strong class="ls ir">Input:</strong> s = "()"<br/><strong class="ls ir">Output:</strong> true</span></pre><p id="b9d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例二:</strong></p><pre class="mh mi mj mk gt ml ls mm mn aw mo bi"><span id="17c5" class="mp kn iq ls b gy mq mr l ms mt"><strong class="ls ir">Input:</strong> s = "()[]{}"<br/><strong class="ls ir">Output:</strong> true</span></pre><p id="2037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 3: </strong></p><pre class="mh mi mj mk gt ml ls mm mn aw mo bi"><span id="871d" class="mp kn iq ls b gy mq mr l ms mt"><strong class="ls ir">Input:</strong> s = "(]"<br/><strong class="ls ir">Output:</strong> false</span></pre><p id="6fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">约束:</strong></p><ul class=""><li id="9f91" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk mu lz ma mb bi translated"><code class="fe lp lq lr ls b">1 &lt;= s.length &lt;= 104</code></li><li id="82eb" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk mu lz ma mb bi translated"><code class="fe lp lq lr ls b">s</code>仅由括号组成<code class="fe lp lq lr ls b">'()[]{}'</code>。</li></ul><h1 id="6167" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">回答:→ </strong></h1><p id="2cc3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将从左到右遍历字符串<code class="fe lp lq lr ls b">s</code>,看看左右括号是否与它们对应的部分匹配。</p><ol class=""><li id="26a9" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">我们将从左到右遍历字符串。</li><li id="cdef" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">如果我们遇到左/左括号，那么我们将把它推到<strong class="jp ir"> <em class="mv">栈</em> </strong>，因为它有<code class="fe lp lq lr ls b">Last In First Out (LIFO)</code>属性。</li><li id="10d8" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">如果我们遇到任何右括号，我们将使用堆栈的<code class="fe lp lq lr ls b">top</code>来检查它。如果它是正确的相应左/左括号，我们将进一步移动，否则我们将返回 false。</li><li id="103f" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">最后，对于有效的字符串，堆栈应该是空的，因为所有的左括号都应该与右括号匹配。</li></ol><p id="4642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过例子来理解:</p><p id="5f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您有字符串“<strong class="jp ir"> { } [ ] </strong>”</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d9d899e5a1beaea9012593c6d399490a.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*lLWwuadTVO3tg8Du6u97cQ.png"/></div></figure><p id="a61e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第一步，我们将从左到右遍历字符串。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi na"><img src="../Images/831211cff803e5ee041d379434dfaf4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*4G_x_UnXYmEqeewAc4F2rw.png"/></div></figure><p id="d6b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第二步，如果我们遇到左/左括号，那么我们将把它推到<strong class="jp ir"> <em class="mv">栈</em> </strong></p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e73f4df615b89df291eadefb811553c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*HK9PAN2yksbea9Q4uVkOgQ.png"/></div></figure><p id="c030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三步，如果我们遇到任何右/右括号，我们将用堆栈的<code class="fe lp lq lr ls b">top</code>检查它。如果它是正确的相应左/左括号，我们将进一步移动，否则我们将返回 false。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2fc20ef8a0388c8fec0cd766bbe25ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*lBHYH1o1pGkg6hCagDj-wA.png"/></div></figure><p id="353a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中你可以看到，现在我们得到了右括号<strong class="jp ir"> "}" </strong>，在我们的堆栈中已经有了相对的括号<strong class="jp ir"> "{ "，</strong>，所以我们将<strong class="jp ir">从堆栈中弹出</strong>。由于堆栈只有一个条目，它将是空的，如下图所示。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/f161ce49a1c90a5650816f9549d03d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AK7qR0V5_PauzoQF9i1uHA.png"/></div></div></figure><p id="4f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的第三个值是<strong class="jp ir"> "[" </strong>，它是左/左括号，然后我们将把它推到<strong class="jp ir"> <em class="mv">堆栈中。</em> </strong> <em class="mv">如下图所示。</em></p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/40c0a220cd0ca467ddb9a7776a1d9b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*edQPxV0nN92SUGXaRx3Lgg.png"/></div></figure><p id="f504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如下图所示，现在我们得到了右括号<strong class="jp ir"> "]" </strong>，在堆栈中我们已经有了相对的括号<strong class="jp ir"> "["，</strong>，所以我们将<strong class="jp ir">从堆栈中弹出</strong>。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cf7e870b16161a997bcd8fc692f488ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*gZIv2d22guQ9Qz2LnX_KhA.png"/></div></figure><p id="bee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于堆栈只有一个条目，它将是空的，如下图所示。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f13385d30178844b68e34c88d205e4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*EYqMl9mam3SBtQWZiwMALQ.png"/></div></figure><p id="7f87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，对于有效的字符串，<strong class="jp ir">堆栈</strong>应该为<strong class="jp ir">空</strong>，因为所有的左括号都应该与右括号匹配。</p><p id="5a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的例子“<strong class="jp ir"> { } [ ] </strong>”，我们的栈是空的，所以它是有效的括号。</p><p id="4e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码(Python): </strong></p><figure class="mh mi mj mk gt mx"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6a1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码(Java): </strong></p><figure class="mh mi mj mk gt mx"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="e85a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">时间复杂度</h1><p id="1ad0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们遍历整个字符串一次，所以如果字符串有<strong class="jp ir"> n </strong>个字符，那么时间复杂度将是<strong class="jp ir"> <em class="mv"> O(n) </em> </strong>。</p><h1 id="1e7a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">空间复杂性</h1><p id="b0d4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们使用堆栈来存储字符串中的字符，所以对于<strong class="jp ir"> n 个</strong>数字或字符的空间复杂度将是<strong class="jp ir">O(n)</strong>。</p><p id="6c87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你阅读这篇文章，❤</p><p id="c309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p><p id="63ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拍手声👏如果这篇文章对你有帮助。</p></div></div>    
</body>
</html>