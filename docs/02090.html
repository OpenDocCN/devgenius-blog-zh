<html>
<head>
<title>Introducing Laravel Observers.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍拉弗尔观察员。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introducing-laravel-observers-8f0198c6c9c?source=collection_archive---------0-----------------------#2020-07-19">https://blog.devgenius.io/introducing-laravel-observers-8f0198c6c9c?source=collection_archive---------0-----------------------#2020-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/238e54f47900955cb0ff9eca39da0b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nzFC6JRXsr8J3Zq9BYvGw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">拉勒韦尔观察家报</figcaption></figure><p id="7608" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Laravel 框架有很多令人敬畏的特性，对我来说最突出的是模型<strong class="kb io">观察者</strong>。</p><p id="3511" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">根据 Laravel 框架的文档:</p><blockquote class="kx ky kz"><p id="f3fe" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">如果您正在监听一个给定模型上的许多事件，您可以使用观察器将所有的监听器分组到一个类中。观察者类的方法名反映了你希望听到的有说服力的事件。这些方法都将模型作为唯一的参数。Artisan 命令是创建一个新的观察者类的最简单的方法。</p></blockquote><p id="af2d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">observers 帮助我清理我的控制器中的清理代码，我可能必须在创建模型事件之前或之后运行这些代码，它还为我提供了一种方法来插入模型事件的生命周期，并运行我认为合适的任何逻辑。</p><p id="ae96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">可以观察到的模型事件分布在模型的 CRUD 中，包括:</p><ul class=""><li id="9762" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">恢复</li><li id="a075" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">创造</li><li id="2c97" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">创造</li><li id="aa52" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">更新</li><li id="2e21" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">更新</li><li id="8074" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">节约</li><li id="a68e" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">获救的</li><li id="c9c4" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">删除</li><li id="bcfa" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">删除</li><li id="641c" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">恢复</li><li id="21ed" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">修复</li></ul><p id="db91" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于 Laravel 框架中的每个模型和附加到它的业务逻辑，都可以观察到上述事件，您还可以从观察器调度定制事件，并从应用程序的其他部分监听它。</p><p id="8ffa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可能还没有看到自己使用 observer 类，这很好，对它有一定的了解也很好。</p><p id="2338" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在此之前，要创建一个观察者类，运行:</p><blockquote class="kx ky kz"><p id="f651" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">php 工匠制作:观察者<observername/></p><p id="ecf6" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">(用您正在观察的模型的名称替换 observerName)。</p></blockquote><p id="90f8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将在您的应用程序的 app 目录中创建一个名为<em class="la">观察者</em>的文件夹，并存储观察者类。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="7270" class="me mf in lh b gy mg mh l mi mj">&lt;?php<br/><br/>namespace App\Observers;<br/><br/>class BankObserver<br/>{<br/>    // an empty observer class<br/>}</span></pre><p id="9b7d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这里，您可以使用与我前面列出的事件相匹配的方法来填充类，值得注意的是，您可以在创建观察器时将模型附加到观察器，就像:</p><blockquote class="kx ky kz"><p id="fb83" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">php 工匠制作:观察者<observername> -m= <modelname/></observername></p></blockquote><p id="934b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将创建一个默认填充了一些方法的类，如下所示。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="044c" class="me mf in lh b gy mg mh l mi mj">&lt;?php<br/><br/>namespace App\Observers;<br/><br/>use App\Task;<br/><br/>class Task<br/>{<br/>    <em class="la">/**<br/>     * Handle the task "created" event.<br/>     *<br/>     * </em><strong class="lh io"><em class="la">@param  </em></strong><em class="la">\App\Task  $task<br/>     * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/>     */<br/>    </em>public function created(Task $task)<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="la">/**<br/>     * Handle the task "updated" event.<br/>     *<br/>     * </em><strong class="lh io"><em class="la">@param  </em></strong><em class="la">\App\Task  $task<br/>     * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/>     */<br/>    </em>public function updated(Task $task)<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="la">/**<br/>     * Handle the task "deleted" event.<br/>     *<br/>     * </em><strong class="lh io"><em class="la">@param  </em></strong><em class="la">\App\Task  $task<br/>     * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/>     */<br/>    </em>public function deleted(Task $task)<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="la">/**<br/>     * Handle the task "restored" event.<br/>     *<br/>     * </em><strong class="lh io"><em class="la">@param  </em></strong><em class="la">\App\Task  $task<br/>     * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/>     */<br/>    </em>public function restored(Task $task)<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="la">/**<br/>     * Handle the task "force deleted" event.<br/>     *<br/>     * </em><strong class="lh io"><em class="la">@param  </em></strong><em class="la">\App\Task  $task<br/>     * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/>     */<br/>    </em>public function forceDeleted(Task $task)<br/>    {<br/>        //<br/>    }<br/>}</span></pre><p id="463c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可能想知道什么样的模型动作触发什么样的观察者动作，我将简要解释不同的方法以及触发它们的原因。</p><ul class=""><li id="e141" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">retrieved-当从数据库中检索模型记录时，调用此观察器方法。</li></ul><blockquote class="kx ky kz"><p id="c363" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">model::findOrFail($ id)；//这会触发 observer 类中检索到的方法</p></blockquote><ul class=""><li id="95b6" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">creating——当模型记录处于创建过程中且尚未存储到数据库中时，会调用此观察器方法，这是在为模型生成 id 和默认时间戳之前，此时您可以动态检查缺失的列并为其分配默认值。</li><li id="4ccc" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">created-在成功创建模型记录后调用此 observer 方法。如果在创建过程中出现错误，比如说缺少列数据，这个方法就不会被调用。</li></ul><blockquote class="kx ky kz"><p id="2cf4" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">model::create([])；//这将首先触发创建方法，然后触发 observer 类中的创建方法。</p></blockquote><ul class=""><li id="0412" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">更新-当模型记录处于更新过程中时，调用此观察器方法，此时，更新尚未持久化到数据库中。</li><li id="e2ed" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">updated-在模型记录成功更新后调用此 observer 方法。如果在更新过程中出现错误，这个方法不会被调用。</li></ul><blockquote class="kx ky kz"><p id="e5e9" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">模型::更新([])；//这将首先触发创建方法，然后触发 observer 类中的创建方法。</p></blockquote><ul class=""><li id="ed38" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">保存和保存-这些模型观察器方法可能看起来有点像瑞士军刀，它在任何需要将数据持久化到数据库的事件之前和之后被调用，因此如果您正在创建一个新的模型记录，保存方法首先运行，然后是创建方法，然后是创建的方法，最后是保存的方法，在更新模型时应用相同的例程，保存，更新，更新，保存。</li><li id="1dd0" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">删除-当模型记录处于删除过程中时，调用此观察器方法，此时，记录尚未从数据库中删除，使用其 id 从数据库中检索它将返回适当的数据。</li><li id="e251" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">deleted-在成功删除模型记录后调用此 observer 方法，此时，该记录已从数据库中删除。</li></ul><blockquote class="kx ky kz"><p id="7c01" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">model::destroy($ id)；</p></blockquote><ul class=""><li id="b8fb" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">恢复和已恢复-当已删除的模型记录被恢复(使用软删除实现)时，调用这些观察器方法</li></ul><p id="2d2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">重要注意事项:</strong></p><ul class=""><li id="0a4f" class="li lj in kb b kc kd kg kh kk lk ko ll ks lm kw ln lo lp lq bi translated">updating 和 updated 方法仅在更新更改数据库中模型的列时运行，因此，如果更新请求没有影响更改，则不会触发 updating 和 updated 观察器，只会触发 saving 和 saved 方法。</li><li id="5509" class="li lj in kb b kc lr kg ls kk lt ko lu ks lv kw ln lo lp lq bi translated">当恢复一个被删除的记录时，一系列的方法一个接一个地被触发，检索，恢复，保存，更新，更新，保存，然后恢复。</li></ul><p id="9602" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在任何情况下，如果您想创建一个模型事件而不触发任何观察器方法，您可以保存它而不包含观察器事件。在不触发任何事件的情况下创建模型时使用的方法示例:</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="b8e3" class="me mf in lh b gy mg mh l mi mj">public function saveQuietly(array $options = [])<br/>{<br/>    return static::<em class="la">withoutEvents</em>(function () use ($options) {<br/>        return $this-&gt;save($options);<br/>    });<br/>}</span><span id="aa09" class="me mf in lh b gy mk mh l mi mj">Note: This method should be added in the respective model.</span></pre><p id="e831" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如有必要，您可以重构它以适应其他模型事件。</p><p id="0ad5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，最后一部分，将观察者绑定到一个特定的模型。</p><p id="1034" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这可以在 AppServiceProvider 的类的 boot 方法中完成:</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="e868" class="me mf in lh b gy mg mh l mi mj"><em class="la">/**<br/> * Bootstrap any application services.<br/> *<br/> * </em><strong class="lh io"><em class="la">@return </em></strong><em class="la">void<br/> */<br/></em>public function boot()<br/>{<br/>    Model::<em class="la">observe</em>(Observer::class);<br/>}</span><span id="31d0" class="me mf in lh b gy mk mh l mi mj">Model is the model to be observed and observer is the observer class</span></pre><p id="2d11" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对 Laravel 观察者的介绍到此结束，希望对您有所启发。</p><blockquote class="kx ky kz"><p id="bf0d" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">在推特上关注我:【https://twitter.com/drumzminister T2】</p><p id="56f5" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">韩语版:【https://laravel-semipro.tistory.com/6<a class="ae ml" href="https://laravel-semipro.tistory.com/6" rel="noopener ugc nofollow" target="_blank">翻译</a>https://twitter.com/rzip84<a class="ae ml" href="https://twitter.com/rzip84" rel="noopener ugc nofollow" target="_blank">翻译</a></p></blockquote></div></div>    
</body>
</html>