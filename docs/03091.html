<html>
<head>
<title>Proxy Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的代理设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/proxy-design-pattern-in-modern-c-95134970d82?source=collection_archive---------9-----------------------#2020-09-28">https://blog.devgenius.io/proxy-design-pattern-in-modern-c-95134970d82?source=collection_archive---------9-----------------------#2020-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e67c36363c661c0af262503cac03c2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0vO2dLH8_Uyhr4Ieoeo2w.png"/></div></div></figure><p id="57b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在软件工程中，结构设计模式处理对象之间的关系，即对象/类如何以适合情况的方式交互或建立关系。结构设计模式通过识别关系来简化结构。在这篇关于结构设计模式的文章中，我们将看看C++中的代理设计模式，它的<strong class="jx io"> <em class="kt">决定了你访问对象</em> </strong>的方式。</p><blockquote class="ku kv kw"><p id="30d5" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><em class="in"> /！\:本文已原创发表于我的</em> <a class="ae la" href="http://www.vishalchovatiya.com/proxy-design-pattern-in-modern-cpp" rel="noopener ugc nofollow" target="_blank"> <em class="in">博客</em> </a> <em class="in">。如果你有兴趣接收我的最新文章，</em> <a class="ae la" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="in">请报名参加我的简讯</em> </a> <em class="in">。</em></p></blockquote><p id="6cfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你还没有检查过其他的结构设计模式，那么下面是列表:</p><ol class=""><li id="1ec8" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">适配器</strong> </a></li><li id="7d33" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/bridge-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">桥<strong class="jx io">桥</strong>桥</a></li><li id="5a27" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">复合</strong> </a></li><li id="849f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">装饰者</strong> </a></li><li id="fd7c" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/facade-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">立面</strong> </a></li><li id="0894" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/flyweight-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">飞锤</strong> </a></li><li id="d418" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/proxy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">代理</strong> </a></li></ol><p id="0e9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe lp lq lr ls b">override</code>、<code class="fe lp lq lr ls b">final</code>、<code class="fe lp lq lr ls b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe lp lq lr ls b">struct</code>而不是<code class="fe lp lq lr ls b">class</code>，只是为了节省代码行，有时不写<code class="fe lp lq lr ls b">public:</code>，还会故意忽略<a class="ae la" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae la" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe lp lq lr ls b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="ebc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">注:</em> </strong></p><ul class=""><li id="084d" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae la" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="93ef" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您在本系列文章中遇到的所有这些代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17之前的现代C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了boost库的<a class="ae la" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="93c3" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">目的</h1><blockquote class="ku kv kw"><p id="5ecc" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">访问特定资源的界面</strong> <em class="in">。</em></p></blockquote><ul class=""><li id="94db" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">代理充当特定资源的接口，该特定资源可能是远程的、构建起来很昂贵或者需要一些额外的功能，如日志记录或其他。</li><li id="5a91" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">但是代理的关键是它的接口看起来就像你实际尝试访问的对象的接口。该接口可以是方法、重载操作符或不同/本地类的另一个<a class="ae la" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">对象</a>。</li></ul><h1 id="0e44" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">C++中的代理设计模式示例</h1><ul class=""><li id="4119" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">C++中代理设计模式的一个非常复杂的例子是<a class="ae la" href="http://www.vishalchovatiya.com/understanding-unique-ptr-with-example-in-cpp11/" rel="noopener ugc nofollow" target="_blank">智能指针</a>(如<a class="ae la" href="http://www.vishalchovatiya.com/understanding-unique-ptr-with-example-in-cpp11/" rel="noopener ugc nofollow" target="_blank"> std::unique_ptr </a>，<a class="ae la" href="http://www.vishalchovatiya.com/move-constructor-assignment-operator-with-shared-ptr/" rel="noopener ugc nofollow" target="_blank"> std::shared_ptr </a>等)。)从标准库</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="59a6" class="nf lv in ls b gy ng nh l ni nj">// Ways to access object through pointer<br/>ptr-&gt;print();<br/>*ptr = 5;</span></pre><ul class=""><li id="7cf3" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">所以让我给你一个解释，为什么智能指针会是一个代理。仅仅通过上面的代码片段，你不能决定ptr是原始指针还是智能指针。</li><li id="c4c9" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">因此，智能指针是代理，因为它们满足代理的条件</li></ul><ol class=""><li id="a560" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">提供访问资源的接口。</li><li id="ead9" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">接口看起来就像对象的接口。</li></ol><ul class=""><li id="3971" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">有许多不同种类的代理可用，如远程代理、虚拟代理、保护代理、通信代理。我们将在这里看到其中的一些。</li></ul><h1 id="2566" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">财产代理</h1><ul class=""><li id="90da" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">正如你可能知道的，其他编程语言如C#也有这种属性概念。可能只不过是一个字段加上该字段的getter &amp; setter方法。让我们假设我们想在C++中获得属性，所以我们把<code class="fe lp lq lr ls b">Property</code>类写成:</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="1c3d" class="nf lv in ls b gy ng nh l ni nj">template&lt;typename T&gt;<br/>struct Property {<br/>    T   m_value;</span><span id="8e80" class="nf lv in ls b gy nk nh l ni nj">    Property(const T initialValue) { * this = initialValue; }<br/>    operator T() { return m_value; }<br/>    T operator = (T newValue) { return m_value = newValue; }<br/>};</span><span id="a1fd" class="nf lv in ls b gy nk nh l ni nj">struct Creature {<br/>    Property&lt;int32_t&gt;   m_strength{10};<br/>    Property&lt;int32_t&gt;   m_agility{5};<br/>};</span><span id="a216" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    Creature creature;<br/>    creature.m_agility = 20;<br/>    cout &lt;&lt; creature.m_agility &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="dcea" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">但是看到上面的代码，你可能会奇怪为什么我们不直接把<code class="fe lp lq lr ls b">strength</code> &amp; <code class="fe lp lq lr ls b">agility</code>声明为<code class="fe lp lq lr ls b">int32_t</code>。现在让我们假设，出于某种原因，您实际上想要<strong class="jx io"> <em class="kt">来“拦截”或“必须记录”分配以及对这些字段</em> </strong>的访问。所以你想要一个作为<code class="fe lp lq lr ls b">Property</code>有效的东西，而不是为所有属性设计getter &amp; setter方法。</li></ul><h1 id="9ce9" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">虚拟代理</h1><ul class=""><li id="be0c" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">因此，在某些时候，你肯定会遇到的另一种代理是所谓的虚拟代理。现在，一个虚拟代理<strong class="jx io"> <em class="kt">给你一种与你习惯使用的同一个对象一起工作的感觉，即使这个对象可能还没有被创建</em> </strong>。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="a7d3" class="nf lv in ls b gy ng nh l ni nj">struct Image {<br/>    virtual void draw() = 0;<br/>};</span><span id="290a" class="nf lv in ls b gy nk nh l ni nj">struct Bitmap : Image {<br/>    Bitmap(const string &amp;filename) : m_filename(filename) {<br/>        cout &lt;&lt; "Loading image from " &lt;&lt; m_filename &lt;&lt; endl;<br/>        // Steps to load the image<br/>    }<br/>    void draw() { cout &lt;&lt; "Drawing image " &lt;&lt; m_filename &lt;&lt; endl; }</span><span id="44ef" class="nf lv in ls b gy nk nh l ni nj">    string      m_filename;<br/>};</span><span id="fe4f" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    Bitmap img_1{"image_1.png"};<br/>    Bitmap img_2{"image_2.png"};</span><span id="d191" class="nf lv in ls b gy nk nh l ni nj">    (rand() % 2) ? img_1.draw() : img_2.draw();</span><span id="f019" class="nf lv in ls b gy nk nh l ni nj">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="6554" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">正如你在上面看到的，<code class="fe lp lq lr ls b">Bitmap</code>图像是从具有多态行为的<code class="fe lp lq lr ls b">Image</code>接口派生出来的，如<code class="fe lp lq lr ls b">draw()</code>。<code class="fe lp lq lr ls b">Bitmap</code>急切地将图像加载到其构造函数中。</li><li id="73c4" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">乍一看，这似乎没问题，但这个<code class="fe lp lq lr ls b">Bitmap</code>的问题是，在绘图代码启动之前，我们并不真正需要加载图像。因此，在构造时将这两个图像都加载到内存中是没有意义的。</li><li id="c050" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">现在让我告诉你如何在不改变<code class="fe lp lq lr ls b">Bitmap</code>的情况下改进上面的代码。当你使用第三方库&amp;想要写一个包装器来提高性能时，这种技术非常有用。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="4a27" class="nf lv in ls b gy ng nh l ni nj">struct LazyBitmap : Image {<br/>    LazyBitmap(const string &amp;filename) : m_filename(filename) {}<br/>    void draw() {<br/>        if (!m_bmp) m_bmp = make_unique&lt;Bitmap&gt;(m_filename);<br/>        m_bmp-&gt;draw();<br/>    }</span><span id="cac8" class="nf lv in ls b gy nk nh l ni nj">    unique_ptr&lt;Bitmap&gt;      m_bmp{nullptr};<br/>    string                  m_filename;<br/>};</span><span id="60be" class="nf lv in ls b gy nk nh l ni nj">LazyBitmap img_1{"image_1.png"};<br/>LazyBitmap img_2{"image_2.png"};</span></pre><ul class=""><li id="1760" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如你所见，我们直到需要时才使用<code class="fe lp lq lr ls b">Bitmap</code>。相反，每当有人想要绘制图像时，我们只是缓存文件名来创建<code class="fe lp lq lr ls b">Bitmap</code>。因此，如果没有人想画图像，从文件中加载图像是没有意义的。</li></ul><h1 id="97a7" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">通信代理(C++中直观的代理设计模式)</h1><ul class=""><li id="be06" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">通信代理是你可能遇到过的C++中最常见和直观的代理设计模式。通信代理的一个直接例子是下标操作符重载。考虑以下用户定义类型的示例，即<code class="fe lp lq lr ls b">arr2D</code>，其工作方式与原始类型2维数组完全相同:</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="ee38" class="nf lv in ls b gy ng nh l ni nj">template &lt;typename T&gt;<br/>struct arr2D {<br/>    struct proxy {<br/>        proxy(T *arr) : m_arr_1D(arr) {}<br/>        T &amp;operator[](int32_t idx) {<br/>            return m_arr_1D[idx];<br/>        }</span><span id="4222" class="nf lv in ls b gy nk nh l ni nj">        T   *m_arr_1D;<br/>    };</span><span id="0fd5" class="nf lv in ls b gy nk nh l ni nj">    arr2D::proxy operator[](int32_t idx) {<br/>        return arr2D::proxy(m_arr_2D[idx]);<br/>    }</span><span id="4d53" class="nf lv in ls b gy nk nh l ni nj">    T   m_arr_2D[10][10];<br/>};</span><span id="c8c7" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    arr2D&lt;int32_t&gt; arr;<br/>    arr[0][0] = 1;  // Uses the proxy object<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="2c3d" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">代理设计模式的好处</h1><ol class=""><li id="0cb5" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lg lh li lj bi translated">该代理为复杂的数据安排提供了一个漂亮而简单的接口。</li><li id="360e" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">代理设计模式尤其是虚拟代理也提供了性能改进，正如我们在上面的惰性图像加载案例中看到的。</li><li id="ac8b" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">属性代理提供了记录对对象属性的访问的灵活性，而客户端甚至不知道。</li></ol><h1 id="f074" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见问题汇总</h1><p id="f3a1" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated"><strong class="jx io">装饰者&amp;代理设计模式是一样的吗？</strong></p><p id="fa93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们有点类似(因为两者都使用合成)，但用于不同的目的。例如，如果您考虑上面的例子，代理通常管理生命周期&amp;对对象的访问，而装饰者是具有更多功能的原始对象的包装。</p><p id="82c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">适配器、装饰器&amp;代理设计模式的区别？</strong></p><p id="b589" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">— <strong class="jx io"> <em class="kt">适配器</em> </strong>提供了不同/ <strong class="jx io"> <em class="kt">兼容的接口</em> </strong>给被包装的对象<br/> — <strong class="jx io"> <em class="kt">代理</em> </strong>提供了有些相同或<strong class="jx io"> <em class="kt">轻松的接口</em> </strong> <br/> — <strong class="jx io"> <em class="kt">装饰器</em> </strong>提供了<strong class="jx io"> <em class="kt">增强的接口</em> </strong></p><p id="8254" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">代理设计模式有哪些用例？</strong></p><p id="c283" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—当您的对象消耗资源并且您将它们的大部分时间存储在磁盘上时，您可以使用代理来充当占位符(就像我们在上面的惰性图像加载中所做的那样)。<br/> —当您想要添加访问限制时，如对象以只读方式访问，或在真正执行操作之前进行基于用户的访问控制(例如，如果用户被授权，则执行操作，否则，抛出访问控制异常)</p></div></div>    
</body>
</html>