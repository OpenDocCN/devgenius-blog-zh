<html>
<head>
<title>Generating Chess Puzzles with Genetic Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用遗传算法生成国际象棋谜题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/generating-chess-puzzles-with-genetic-algorithms-1147e81a4e22?source=collection_archive---------10-----------------------#2022-10-18">https://blog.devgenius.io/generating-chess-puzzles-with-genetic-algorithms-1147e81a4e22?source=collection_archive---------10-----------------------#2022-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9f23786db01a2c49923f8551fe07da7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ufxyz4QITCCl7iJcWvUwIg.png"/></div></div></figure><p id="ff55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最喜欢做的事情之一是找到有趣的库，并用它们测试不寻常的用例。python 库<a class="ae kt" href="https://pypi.org/project/geneticalgorithm/" rel="noopener ugc nofollow" target="_blank"> geneticalgorithm </a>是漂亮的开放式——公开了一个简单但强大的接口，我们可以用它来处理各种奇怪的事情。</p><p id="2f7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本帖中，我们将使用它来生成类似这样的国际象棋谜题:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ku"><img src="../Images/7c08d3319a3fbc534b286ab5539c2c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dZc8SGyNIRS3-jHB.png"/></div></div></figure><p id="4471" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者像这样更温顺的:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/7324e73e45a9ef63601a256646b70180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KoaNmZQZb2rlrlcu.png"/></div></div></figure><p id="126f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不熟悉国际象棋，这两个都被称为“三人配对”谜题。这意味着白方可以用 3 步赢得游戏，但前提是他们必须找到一个特定的走法。</p><p id="6f71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个谜题是在“包含尽可能多的骑士”的约束下产生的，这解释了为什么双方都有太多的骑士。</p><p id="f7bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在我们进入所有这些之前，我们将从理解库开始。</p><h2 id="c849" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">遗传算法</h2><p id="0dc5" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">有很多很好的文章解释了什么是遗传算法(比如<a class="ae kt" href="https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b" rel="noopener" target="_blank">这篇</a>)。从那篇文章中，需要注意的主要问题是</p><blockquote class="ly lz ma"><p id="fd51" class="jv jw mb jx b jy jz ka kb kc kd ke kf mc kh ki kj md kl km kn me kp kq kr ks ig bi translated">为了找到一个解决方案使用遗传算法，随机变化适用于目前的解决方案，以产生新的</p></blockquote><p id="d170" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在高层次上，我们对一个问题采取一些解决方案，并随机修改它以获得新的可能的解决方案。我们不会在这里深入讨论细节，而是将重点放在这个库公开了什么接口。让我们从文档中的一个例子开始:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="550c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哪些输出:</p><pre class="kv kw kx ky gt mh mi mj mk aw ml bi"><span id="ca04" class="la lb in mi b gy mm mn l mo mp">The best solution found:<br/> [0. 0. 0.]<br/><br/> Objective function:<br/> 0.0</span></pre><p id="4886" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们把它分解，我们会看到:</p><ul class=""><li id="dcd6" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">我们有一个函数 f(X ),它接受一个由 3 个整数组成的数组</li><li id="7c09" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">那些整数都在 0 到 10 之间，包括 0 和 10</li><li id="6af0" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">我们的目标是最小化函数 f(X)</li><li id="02f9" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">因为 f(X)只是对 3 个整数求和，所以最好的解是如果它们都是 0</li></ul><h2 id="5f30" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">我们的函数可以有多复杂？</h2><p id="5350" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">把三个数字加在一起很酷，但是让我们试试稍微复杂一点的。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ba63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很容易做到。同样值得将这个函数与这个函数进行对比:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5d4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个函数有相同的最佳解决方案，但是第二个偶尔会失败(使用默认参数)，而第一个不会。如果你想一想我们的黑盒<code class="fe ne nf ng mi b">model.run()</code>可能是如何工作的，你可能会明白为什么会发生这种情况。</p><p id="a969" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的第一个函数中，接近[3，1，10]的解比远离[3，1，10]的解具有更低的值。在我们的第二个函数中，我们的算法基本上没有得到反馈，直到我们碰巧得到[3，1，10]。您可以在生成的图表中看到这一点:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/337d6f897e32c385fdcd0a2f708971ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*aQTgtV4QFTAHwwOC.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">随着时间的推移，我们的目标函数 f(X)减小</figcaption></figure><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5be907c327eeb6954013d38e1f2708fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*iER5Hg4x7C5f1HDG.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">随着时间的推移，我们的目标函数 f(X)保持不变</figcaption></figure><p id="8116" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一张图中，我们看到算法很快收敛到正确的答案，得到了它在正确的路径上的反馈。在第二张图中，我们一直得到相同的值，直到我们放弃。</p><h2 id="af11" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">国际象棋模型</h2><p id="7afb" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">不过，我们的函数是相当随意的——谁说它需要表示某种数学函数。</p><p id="5b0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们生成 64 个整数——每个国际象棋位置一个。而整数会在 0 到 12 之间，代表一个空的正方形或者一个棋子。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4d95f76ac2f4ef0e9235279b7405f4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*T5TZ7BY1o5YtTUpL.png"/></div></figure><p id="af2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用 python 库<a class="ae kt" href="https://python-chess.readthedocs.io/en/latest/core.html" rel="noopener ugc nofollow" target="_blank"> python-chess </a>来构造一个棋盘对象。这将允许我们检查棋盘的更多属性——比如它是否是一个有效的位置，它当前是否是一个僵局，等等。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3338" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们只需要一个函数来最小化。让我们从简单开始，让它用尽可能少的棋子生成一个<strong class="jx io">有效棋位</strong>。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d80b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要修改我们的约束来包含 64 个整数:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b7de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文档说我们应该试验我们自己的配置，我用了这个，但是这些都是可以调整的值:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1467" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，让我们运行代码，打印出我们最好的电路板的字符串表示:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="de4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://lichess.org/analysis/standard/" rel="noopener ugc nofollow" target="_blank"> Lichess </a>上可视化 FEN 字符串，你会看到:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/245005e784a417dcafe45d3c59ddd841.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*pm0EoBpTHFH49l9U.png"/></div></figure><p id="ceed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该符合你的预期。要使一个位置“有效”，它必须包括一个黑白国王。它不需要任何其他的棋子，所以这实际上是我们函数的最优解——一个具有最少可能棋子的有效棋盘！</p><h2 id="f5e0" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">使用 Stockfish 生成国际象棋谜题</h2><p id="8d7a" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">一个国际象棋难题是一个位置，在那里有且只有一个好的移动。拼图通常用于训练，因为在一个位置上找到唯一的好动作可能是一个挑战。</p><p id="3ddd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，谜题的生成方式是通过查看真实游戏中的位置，并确定每个位置是否是谜题(意味着主棋是好的，而每个后续棋不是)。</p><p id="2be0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们怎么知道只有一步是好的呢？我们可以使用开源的象棋引擎<a class="ae kt" href="https://stockfishchess.org/" rel="noopener ugc nofollow" target="_blank"> Stockfish </a>。我们的 python-chess 库实际上支持与 Stockfish 这样的引擎进行通信。这意味着获得头寸的详细分析非常简单:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8652" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ne nf ng mi b">info</code>包含了很多字段，但最重要的两个是:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3c94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ne nf ng mi b">score</code>告诉我们 Stockfish 对位置的看法，这是一个配偶。</p><p id="ea8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ne nf ng mi b">pv</code>(<a class="ae kt" href="https://www.chessprogramming.org/Principal_Variation" rel="noopener ugc nofollow" target="_blank">主变</a>的简称)告诉我们引擎期望进行的移动顺序。在这种情况下，它说，它希望白移动他们的皇后 f8 到 g7，这是将死。</p><p id="4952" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在一个函数中使用这两者，在三个谜题中生成<strong class="jx io"> mate，这意味着在这些谜题中，白棋可以在正好三步中获胜。</strong></p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ad4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与上面类似，我们希望靠近目标的棋位比远离目标的棋位具有更低的值。这就是我们添加以下案例的原因:</p><ul class=""><li id="05e9" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">四分之一拼图比七分之一拼图更好</li><li id="1754" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">一个无效的位置会受到很重的处罚，就像比赛已经结束的情况一样</li></ul><p id="6e3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次运行它都会得到不同的结果，但这里有一个例子:</p><p id="2fee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ne nf ng mi b">6kr/7b/8/r6Q/8/B7/5K2/3R2b1 w - - 0 1</code></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/456adf81592ca3c2464dd67ed9374ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cUYA32CfBll1hPJ7.png"/></div></div></figure><p id="5b4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在右边列出了四个最强的引擎走法，但是正如你所看到的，只有一个走法可以让白棋赢得比赛。每隔一步棋就让黑棋扳平甚至取得一点优势。</p><p id="f471" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，我们到底有多少控制权呢？我们当前的功能试图包含尽可能少的部分。如果相反，我们决定要尽可能多的骑士，最好是敌人的骑士？我们将改变我们的函数来添加这个作为惩罚:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="107b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们运行时，我们得到:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ku"><img src="../Images/ba49e1bf4f4d6e77ae6810c7bad2e180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uouBdf7NcqRsI12W.png"/></div></div></figure><p id="0775" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这么多的骑士，然而，它仍然是一个伴侣。</p><h2 id="947c" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">一个简短的题外话:我们能生成现实的谜题吗？</h2><p id="31b5" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">我们生成的所有拼图都有点问题。骑士一号在现实游戏中显然是不可及的。这保证了一个完整的单独的帖子，但是一个有趣的方法是将“现实主义分数”合并到函数中。</p><p id="ea0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有一个分类器，它接受国际象棋的位置，并输出一个分数，表示它有多“真实”,你可以把它加到你的惩罚中，来惩罚不真实的棋盘。这需要许多“现实”位置的例子——但幸运的是，Lichess 令人惊叹，它有一个比你需要建立一个好的分类器多得多的游戏数据集。</p><h2 id="3af3" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">为什么要这么做？</h2><p id="fc0e" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">你从真实游戏中得到的谜题绝对比我们生成的质量高，然而，我认为这是一个有趣的概念证明。</p><p id="4b2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用一个用于函数最小化的库，将 Stockfish 附加到它上面，并使用它在 3 个国际象棋谜题中生成令人惊讶的复杂配对，而无需太多代码。像这样的库让我兴奋，因为它感觉像是你的想象力和你将想法转化为代码的能力的极限。</p></div></div>    
</body>
</html>