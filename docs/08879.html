<html>
<head>
<title>Dockerizing your NodeJS applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 NodeJS 应用程序归档</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dockerizing-your-nodejs-applications-71ae8b9ca913?source=collection_archive---------6-----------------------#2022-07-16">https://blog.devgenius.io/dockerizing-your-nodejs-applications-71ae8b9ca913?source=collection_archive---------6-----------------------#2022-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8de754661b3dbca65e0250d596fe2999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sax945XtJqI6UOrc"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Pic Credit @globenewswire</figcaption></figure><p id="19e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击这个链接在你的机器上安装 docker。我正在使用 Ubuntu，所以你也可以在这里找到另一个操作系统安装指南。</p><p id="113c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">确保您已经正确地按照上面的链接在您的系统上安装 Docker。</p><p id="ea41" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以键入以下命令来检查 docker 是否正在运行</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f3eb" class="lh li in ld b gy lj lk l ll lm">sudo systemctl status docker</span></pre><p id="d489" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您将获得以下输出</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/3df8aa8d17ca2d0b70101554b22ce4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfBkQBRKiCqruyrwXYoH8A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Docker 状态图像</figcaption></figure><p id="58ce" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你在安装过程中遇到任何困难，欢迎在评论中提问。</p><h1 id="8594" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建 NodeJS 项目</h1><p id="2cb9" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">首先为本教程创建一个单独的目录。我正在创建一个名为 dockerTest 的目录，你也可以用相同的名字创建目录，或者你可以命名任何你喜欢的名字</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="af46" class="lh li in ld b gy lj lk l ll lm">mkdir dockerTest</span></pre><p id="37fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在去那个目录</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="84f7" class="lh li in ld b gy lj lk l ll lm">cd dockerTest</span></pre><p id="3e19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建一个节点项目</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c706" class="lh li in ld b gy lj lk l ll lm">npm init -y</span></pre><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/b3d3b300cdaa9e2a7cef75ac778e5373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvz59k2rErLRrIWhmKwFpw.png"/></div></div></figure><p id="3a6e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们在 package.json 中添加 start 命令，我们将添加 index.js 作为我们的主文件。您的整个 package.json 文件将如下所示</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4049" class="lh li in ld b gy lj lk l ll lm">{<br/>  "name": "dockertest",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "start": "node index.js",<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span></pre><p id="f519" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们安装 ExpressJS 作为依赖项并创建 index.js 文件</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6888" class="lh li in ld b gy lj lk l ll lm">npm install express --save<br/>touch index.js</span></pre><p id="1e62" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在 index.js 文件中添加以下代码以运行节点服务器</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c49f" class="lh li in ld b gy lj lk l ll lm">const express = require("express");<br/>const port = 3000;</span><span id="f0fa" class="lh li in ld b gy mr lk l ll lm">const app = express();</span><span id="e1ee" class="lh li in ld b gy mr lk l ll lm">app.get("/", (req, res) =&gt; {<br/>    res.send("Hello Docker!");<br/>});</span><span id="0ad2" class="lh li in ld b gy mr lk l ll lm">app.listen(port, () =&gt; {<br/>    console.log(`App listening to port ${port}`);<br/>})</span></pre><p id="e884" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在运行 npm start 来检查您的应用程序是否正在运行。</p><h1 id="016b" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">为 NodeJS 应用程序创建 Dockerfile</h1><p id="f386" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated"><code class="fe ms mt mu ld b">Dockerfile</code>是一个文本文档，包含用户可以在命令行上调用的所有命令，以组合一个图像。当我们告诉 Docker 通过执行<code class="fe ms mt mu ld b">docker build</code>命令来构建我们的映像时，Docker 将读取这些指令并逐个执行它们，结果创建一个 Docker 映像。</p><p id="be7e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们为我们的应用程序创建一个<code class="fe ms mt mu ld b">Dockerfile</code>。在工作目录的根目录下，创建一个名为<code class="fe ms mt mu ld b">Dockerfile</code>的文件，并在文本编辑器中打开这个文件。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0118" class="lh li in ld b gy lj lk l ll lm">FROM node:11-alpine<br/>WORKDIR /app</span><span id="97bd" class="lh li in ld b gy mr lk l ll lm">COPY package.json package.json</span><span id="73e0" class="lh li in ld b gy mr lk l ll lm">COPY package-lock.json package-lock.json</span><span id="1bde" class="lh li in ld b gy mr lk l ll lm">RUN npm install</span><span id="92fa" class="lh li in ld b gy mr lk l ll lm">COPY . .</span><span id="07e7" class="lh li in ld b gy mr lk l ll lm">CMD ["npm", "run", "start"]</span></pre><p id="e0dd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我会详细解释给你听，上面的代码是什么意思</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1725" class="lh li in ld b gy lj lk l ll lm">FROM node:11-alpine</span></pre><p id="f06a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Docker 图像可以从其他图像继承。因此，我们将使用官方的 Node.js 映像，而不是创建自己的基本映像，该映像已经包含了运行 Node.js 应用程序所需的所有工具和软件包。当我们使用<code class="fe ms mt mu ld b">FROM</code>命令时，我们告诉 docker 在我们的映像中包含<code class="fe ms mt mu ld b">node:11-alpine image</code>的所有功能</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="56f7" class="lh li in ld b gy lj lk l ll lm">WORKDIR /app</span></pre><p id="b85f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这指示 Docker 使用该路径作为所有后续命令的默认位置。这样，我们不必输入完整的文件路径，而是可以使用基于工作目录的相对路径。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="90bc" class="lh li in ld b gy lj lk l ll lm">COPY package.json package.json</span><span id="d870" class="lh li in ld b gy mr lk l ll lm">COPY package-lock.json package-lock.json</span></pre><p id="4d5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在运行 npm 安装之前，我们需要将我们的<code class="fe ms mt mu ld b">package.json</code>和<code class="fe ms mt mu ld b">package-lock.json file</code>放入我们的映像中。我们将使用<code class="fe ms mt mu ld b">COPY</code>命令来做到这一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9732" class="lh li in ld b gy lj lk l ll lm">RUN npm install</span></pre><p id="405b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦我们在映像中有了 package.json 文件，我们就可以使用<code class="fe ms mt mu ld b">RUN</code>命令来执行命令<code class="fe ms mt mu ld b">npm install</code>。这与我们在本地机器上运行 npm install 完全相同，但是这次这些节点模块将被安装到我们的映像中的 node_modules 目录中。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bec3" class="lh li in ld b gy lj lk l ll lm">COPY . .</span></pre><p id="34c8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此时，我们有了一个映像，并且已经安装了依赖项。我们需要做的下一件事是将我们的源代码添加到图像中。我们将使用 COPY 命令，就像我们在上面使用 package.json 文件一样。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="be65" class="lh li in ld b gy lj lk l ll lm">CMD ["npm", "run", "start"]</span></pre><p id="3c86" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此复制命令将获取当前目录中的所有文件，并将它们复制到映像中。现在我们所要做的就是告诉 Docker 当我们的映像在容器中运行时我们想要运行什么命令。我们使用 CMD 命令来实现这一点。</p><h1 id="d7e9" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">建筑图像</h1><p id="e604" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">现在我们已经创建了 docker 文件，让我们来构建我们的映像。为此，我们使用 docker build 命令。<code class="fe ms mt mu ld b">docker build</code>命令从 Docker 文件构建 Docker 映像。</p><p id="6feb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">build 命令可以选择使用–tag 或-t 标志。标签用于设置图像的名称和一个格式为“name:tag”的可选标签。为了简化事情，我们暂时不考虑可选的“标签”。如果您没有传递标签，docker 将使用“latest”作为它的默认标签。您将在构建输出的最后一行看到这一点。</p><p id="b142" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们建立自己的码头工人形象</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ec50" class="lh li in ld b gy lj lk l ll lm">ajay@ajay ~/w/d/dockerTest [1]&gt; docker build  -t node_api .<br/>Sending build context to Docker daemon  2.416MB<br/>Step 1/7 : FROM node:11-alpine<br/> ---&gt; f18da2f58c3d<br/>Step 2/7 : WORKDIR /app<br/> ---&gt; Running in 0d7a6a65877f<br/>Removing intermediate container 0d7a6a65877f<br/> ---&gt; 820672d1fd2a<br/>Step 3/7 : COPY package.json package.json<br/> ---&gt; a19fa22366c4<br/>Step 4/7 : COPY package-lock.json package-lock.json<br/> ---&gt; 9a1ffd1c7ec6<br/>Step 5/7 : RUN npm install<br/> ---&gt; Running in 922d945558b3</span><span id="f720" class="lh li in ld b gy mr lk l ll lm">up to date in 0.862s<br/>found 0 vulnerabilities</span><span id="5815" class="lh li in ld b gy mr lk l ll lm">Removing intermediate container 922d945558b3<br/> ---&gt; 18005269ff51<br/>Step 6/7 : COPY . .<br/> ---&gt; d72f51689d5d<br/>Step 7/7 : CMD ["npm", "run", "start"]<br/> ---&gt; Running in 5b12f51f1331<br/>Removing intermediate container 5b12f51f1331<br/> ---&gt; 04da2371794a<br/>Successfully built 04da2371794a<br/>Successfully tagged node_api:latest</span></pre><h1 id="655b" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">查看本地图像</h1><p id="8cb5" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">要列出图像，只需运行<code class="fe ms mt mu ld b">images</code>命令。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5388" class="lh li in ld b gy lj lk l ll lm">ajay@ajay ~/w/d/dockerTest&gt; docker images<br/>REPOSITORY   TAG         IMAGE ID       CREATED          SIZE<br/>node_api     latest      04da2371794a   34 minutes ago   77.6MB<br/>node         11-alpine   f18da2f58c3d   3 years ago      75.5MB</span></pre><h1 id="e032" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">运行 docker 容器</h1><p id="39cb" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">容器是一个正常的操作系统进程，只是这个进程是独立的，因为它有自己的文件系统、自己的网络和自己独立于主机的进程树。</p><p id="e496" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了在容器内部运行图像，我们使用 docker run 命令。<code class="fe ms mt mu ld b">docker run</code>命令需要一个参数，那就是图像名。</p><p id="64df" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">启动容器，将端口 3000 暴露给主机上的端口 3000。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4383" class="lh li in ld b gy lj lk l ll lm">ajay@ajay ~/w/d/dockerTest&gt; docker run -p 3000:3000  -t node_api</span><span id="e7ff" class="lh li in ld b gy mr lk l ll lm">&gt; dockertest@1.0.0 start /app<br/>&gt; node index.js</span><span id="a889" class="lh li in ld b gy mr lk l ll lm">App listening to port 3000</span></pre><p id="89ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在您可以打开 localhost:3000，您将看到 NodeJS 应用程序正在运行。</p><p id="c560" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae kx" href="https://www.youtube.com/channel/UCvEB7wXUEXGFE9lCx0USR3Q" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">订阅解码获得更多类似内容，我们的 YouTube 频道</strong> </a> <strong class="kb io">！</strong></p><p id="8f0d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢阅读。同样的职位也可以在<a class="ae kx" href="http://ajaykrp.me/" rel="noopener ugc nofollow" target="_blank">http://ajaykrp.me/</a>上找到。</p></div></div>    
</body>
</html>