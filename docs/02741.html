<html>
<head>
<title>Designing Relational Database in Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实例设计关系数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/designing-relational-database-in-example-258e978dabcf?source=collection_archive---------5-----------------------#2020-08-25">https://blog.devgenius.io/designing-relational-database-in-example-258e978dabcf?source=collection_archive---------5-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f175" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这个故事中，我想与你分享一个基本的关系数据库，它帮助我理解了组织关系数据库数据的思想。如果你是设计关系数据库的新手，这份材料是给你的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63f1e85d7bb9b5297ad2a2028d1c9776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3G6B4mn_LuM_C8SH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="10aa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">前言</h1><p id="728e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">几年前，我是一名初级开发人员，雄心勃勃地想开发web应用程序。有一次，我有了一个想法，要分析我花的所有钱，以便更好地了解我的支出。我需要一个应用程序，可以存储付款，显示统计图表，而不仅仅是一个月内所有付款的彩色圆形图。</p><p id="acaf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">出于这些原因，我决定开发一个应用程序，包括我想要的所有功能。<br/>我要和你讨论一个关系数据库的设计，这是我为这个应用程序做的。</p><h1 id="59fa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我需要存储哪些数据？</h1><p id="276d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我用一个例子探讨了这个问题。我想象着我在书店买了《火星人》的书，书店位于“爱书人”书店。然后，我在2020年8月20日下午3:04用现金支付了这本书5美元。</p><p id="1cd7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相应地，此时此刻，购买有几个参数:</p><ul class=""><li id="7e77" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">产品的名字——“火星人”书，</li><li id="4a37" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">价格——5美元，</li><li id="6f4d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">商店的位置——“爱书人”商店，</li><li id="757c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">支付类型—现金，</li><li id="6f8e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">货币—美元，</li><li id="d503" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">日期和时间—2020年8月20日下午3:04。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/dc4553db0cca34a75a8a1529cce364c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnKnDLGjTNKd9l2LUU0UHg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图一。购买参数。</figcaption></figure><p id="ac85" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我一直在想我是否需要指定一个确切的产品。在书店里，除了书，你还可以买很多东西。那在超市购物呢？产品列表可能会非常长。</p><h1 id="1739" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整理表格</h1><p id="cb1a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我决定为一个产品创建一个抽象模型。我将这个参数(产品名)分为类别和子类别表，并通过主键和外键将它们连接起来。对于前面的例子，<em class="ne">类别</em>是商店，而<em class="ne">子类别</em>是书店。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/455af9d418bb59aae33cf063f826d487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlhgMxoo7JV28w4mHGiiOA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图二。两个新表格:类别和子类别。</figcaption></figure><p id="3f02" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一个选择是将<em class="ne">类别</em>和<em class="ne">子类别</em>存储在一个表中。虽然存储类别和子类别简化了整个模型，但是在一个表中设置它们会使从表中选择<em class="ne">类别</em>变得复杂——脚本部分中的这个表就是一个例子。</p><p id="d284" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">支付方式(现金或信用卡)和货币(美元、欧元等)的值是已知且不可改变的。因此，为了存储支付方式和货币，我分别创建了<em class="ne">方式</em>和<em class="ne">货币</em>表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/cce83a65bb030bf0cbe50be6b06e5352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSVLLWwbZYaRNSuoNMTC0Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图3。两个新表:方法和货币。</figcaption></figure><p id="98ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">价格、地点、日期和时间总是不同的。没有必要将这些参数存储在单独的表中。</p><p id="a51d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一个条目是<em class="ne"> payments </em>，它包含所有前面的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b7ee3638a4f9ddb79e60436800c0e503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMn5Tk-ozs5_UANKW35mGQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图4。一个新的表格:付款。</figcaption></figure><h1 id="ed2f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">剧本</h1><p id="ef56" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一步是定义列和约束。</p><p id="1d61" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ne">子类别</em>表包含一个额外的<em class="ne"> category_id </em>列，这是一个外键约束，用于连接到<em class="ne">类别</em>表。</p><p id="599d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有的<em class="ne"> id </em>列都具有<strong class="lq ir">序列</strong>伪数据类型。使用整数数据类型也是正确的。</p><p id="84f2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ne">类别</em>、<em class="ne">货币</em>、<em class="ne">方法</em>中的一个名称列是<strong class="lq ir">跨表唯一的</strong>。子类别的名称不是唯一的，因为一个子类别可以引用许多类别。</p><p id="c6eb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认情况下，PostgreSQL中的所有列都是空的。我为特定的列添加了<strong class="lq ir"> not null </strong>约束，其中的信息是有价值的，并且是分析所必需的。</p><p id="e0b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">执行以下脚本来创建表:</p><p id="4d46" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我包含了<em class="ne">drop table if exists table _ name cascade</em>以便更容易应用新的更改。因此，例如，当您添加属性时，您不需要手动销毁表。</p><p id="7af1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">存储<em class="ne">类别</em>和<em class="ne">子类别</em>的另一个表是:</p><ul class=""><li id="dc2e" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><em class="ne"> id </em>是类别和子类别的标识符。</li><li id="5d1e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><em class="ne">名称</em>是类别和子类别的名称。</li><li id="8f9b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><em class="ne"> category_id </em>仅指一个类别。</li></ul><p id="60d2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ne">产品</em>表的示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/afc33eb254bb38e957fb7e8cd5d82dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*lxCOdy0gDDOlXgOhIhbFlg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">表1。用随机值填充的产品表</figcaption></figure><h1 id="e357" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结果</h1><p id="3e0d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="ne">支付</em>表是这个应用的关键表。该表通过外键连接到<em class="ne">类别</em>、<em class="ne">子类别</em>、<em class="ne">方法</em>和<em class="ne">货币</em>表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/7ffbbcf533c59fb54684f7f084b13cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AVp8kdrZSVigqYF08nIsA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图5。最终的关系数据库模型。</figcaption></figure><h1 id="9245" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">进一步阅读</h1><div class="nk nl gp gr nm nn"><a href="https://www.postgresqltutorial.com/postgresql-foreign-key/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">PostgreSQL外键</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">摘要:在本教程中，您将了解PostgreSQL外键以及如何使用…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.postgresqltutorial.com</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.postgresqltutorial.com/postgresql-primary-key/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">PostgreSQL主键</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">摘要:在本教程中，我们将向您展示什么是主键以及如何管理PostgreSQL主键…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.postgresqltutorial.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kp nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.postgresqltutorial.com/postgresql-not-null-constraint/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">PostgreSQL非空约束</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">摘要:在本教程中，您将学习PostgreSQL非空约束，以确保列的值不被…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.postgresqltutorial.com</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.postgresqltutorial.com/postgresql-unique-constraint/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">PostgreSQL唯一约束</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">摘要:在本教程中，您将了解PostgreSQL唯一约束，以确保存储在</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.postgresqltutorial.com</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.postgresqltutorial.com/postgresql-serial/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">使用PostgreSQL序列创建自动递增列</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">摘要:在本教程中，您将了解PostgreSQL串行伪类型以及如何使用串行伪类型…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.postgresqltutorial.com</p></div></div></div></a></div><h1 id="7734" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关于作者</h1><p id="4b62" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Jane是一名围棋程序员和软件工程方面的技术作家。她已经用英语和俄语写了5年的技术资料。她从新西伯利亚国立技术大学获得了信息安全专业学位，专攻自动化系统的信息安全。你可以在 <a class="ae kv" href="https://twitter.com/enthusiastic_io" rel="noopener ugc nofollow" target="_blank"> <em class="ne">推特</em> </a> <em class="ne">上关注她，在</em><a class="ae kv" href="https://publications.enthusiastic.io/" rel="noopener ugc nofollow" target="_blank"><em class="ne">publications . excellent . io</em></a><em class="ne">上看她的其他文字作品。</em></p></div></div>    
</body>
</html>