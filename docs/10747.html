<html>
<head>
<title>MUST known React questions for your next frontend interview — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一次前端面试必须知道的问题——第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/must-known-react-questions-for-your-next-frontend-interview-part-2-2430fe2d131a?source=collection_archive---------13-----------------------#2022-11-26">https://blog.devgenius.io/must-known-react-questions-for-your-next-frontend-interview-part-2-2430fe2d131a?source=collection_archive---------13-----------------------#2022-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/27f82d91c063ecce1d38d76a16df0e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3I9grcYAKk1Mc5rk.jpg"/></div></div></figure><p id="066a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是上一篇文章的延续，在上一篇文章中，我为你的下一次前端面试列出了一些重要的问题和答案。</p><ol class=""><li id="eabe" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">如何将参数传递给事件处理程序或回调函数？</strong></li></ol><p id="99c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用一个<em class="lc">箭头函数</em>来环绕一个<em class="lc">事件处理程序</em>并传递参数:</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="2c35" class="lm ln in li b be lo lp l lq lr">&lt;button onClick={() =&gt; this.handleClick(id)} /&gt;</span></pre><p id="ca0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这相当于调用<code class="fe ls lt lu li b">.bind</code>:</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="e172" class="lm ln in li b be lo lp l lq lr">&lt;button onClick={this.handleClick.bind(this, id)} /&gt;</span></pre><p id="25f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了这两种方法，您还可以将参数传递给被定义为 arrow function 的函数</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="8221" class="lm ln in li b be lo lp l lq lr">&lt;button onClick={this.handleClick(id)} /&gt;<br/>handleClick = (id) =&gt; () =&gt; {<br/>    console.log("Hello, your ticket number is", id)<br/>};</span></pre><p id="3aac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。参考文献有什么用？</strong></p><p id="9274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lc"> ref </em>用于返回对元素的引用。在大多数情况下，应该避免使用它们<em class="lc"/>,但是，当您需要直接访问 DOM 元素或组件实例时，它们会很有用。</p><p id="50d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。什么是虚拟 DOM？</strong></p><p id="f102" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lc">虚拟 DOM </em> (VDOM)是<em class="lc">真实 DOM </em>的内存表示。UI 的表示保存在内存中，并与“真正的”DOM 同步。这是调用渲染函数和在屏幕上显示元素之间的一个步骤。这整个过程被称为<em class="lc">和解</em>。</p><p id="d846" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。虚拟 DOM 是如何工作的？</strong></p><p id="045d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虚拟 DOM 工作在三个简单的步骤中。</p><ul class=""><li id="d20a" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">每当底层数据发生变化时，整个 UI 都会以虚拟 DOM 表示重新呈现。</li></ul><figure class="ld le lf lg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/4fd05b5bc2fa0c57ec2ec956c7e058c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ambAWihpIu2lhCk.png"/></div></div></figure><ul class=""><li id="66c8" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">然后计算以前的 DOM 表示和新的 DOM 表示之间的差异。</li></ul><figure class="ld le lf lg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/c2d0144ed7c0e54274c8b43751d33fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Njlfxn2-fIrgOTR-.png"/></div></div></figure><ul class=""><li id="96d1" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">一旦计算完成，真正的 DOM 将只更新实际发生变化的内容。</li></ul><figure class="ld le lf lg gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/23ec3938c8c8e823254a1af2e77302ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/0*HJ04jWart6SFB-G4.png"/></div></figure><p id="4d91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。什么是受控组件</strong></p><p id="c307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在后续用户输入中控制表单中的输入元素的组件称为受控组件，也就是说，每个状态突变都有一个关联的处理函数。</p><p id="98d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，要用大写字母写所有的名字，我们使用如下的 handleChange，</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="95ca" class="lm ln in li b be lo lp l lq lr">handleChange(event) {<br/>  this.setState({value: event.target.value.toUpperCase()})<br/>}</span></pre><p id="ebc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">6。什么是不受控制的组件？</p><p id="d2b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不受控制的组件是那些在内部存储它们自己的状态的组件，当需要时，可以使用 ref 查询 DOM 以找到它的当前值。这有点像传统的 HTML。</p><p id="b5d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的 UserProfile 组件中，使用 ref 访问<code class="fe ls lt lu li b">name</code>输入。</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="4fc7" class="lm ln in li b be lo lp l lq lr">class UserProfile extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.handleSubmit = this.handleSubmit.bind(this)<br/>    this.input = React.createRef()<br/>  }<br/><br/>  handleSubmit(event) {<br/>    alert('A name was submitted: ' + this.input.current.value)<br/>    event.preventDefault()<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;form onSubmit={this.handleSubmit}&gt;<br/>        &lt;label&gt;<br/>          {'Name:'}<br/>          &lt;input type="text" ref={this.input} /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b64c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在大多数情况下，建议使用受控组件来实现表单。在受控组件中，表单数据由 React 组件处理。另一种方法是不受控制的组件，表单数据由 DOM 本身处理。</p><p id="c5fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 7。React 的生命周期方法有哪些？</strong></p><p id="83de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 react 开发者访谈中<strong class="jx io">真正重要的问题</strong>。因此，我就这个问题写了整篇文章，我建议您阅读这篇文章，以了解 React 所有生命周期方法。在这里，我附上相同的链接。</p><div class="ly lz gp gr ma mb"><a href="https://medium.com/@mgarg6858/react-component-lifecycle-in-class-and-functional-component-d001f3615a83" rel="noopener follow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd io gy z fp mg fr fs mh fu fw im bi translated">在类和功能组件中反应组件生命周期</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">介绍</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jt mb"/></div></div></a></div><p id="5a21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 8。什么是高阶元件？</strong></p><p id="1cf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<em class="lc">高阶组件</em> ( <em class="lc"> HOC </em>)是一个接受一个组件并返回一个新组件的函数。基本上，这是一种源自 React 的组合性质的模式。</p><p id="9242" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们称它们为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制其输入组件的任何行为。</p><p id="1469" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 9。什么是儿童道具？</strong></p><p id="8ebf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lc"> Children </em>是一个道具(<code class="fe ls lt lu li b">this.props.children</code>)，允许你将组件作为数据传递给其他组件，就像你使用的任何其他道具一样。放在组件开始和结束标签之间的组件树将作为<code class="fe ls lt lu li b">children</code>属性传递给该组件。</p><p id="07a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">儿童道具的简单用法如下:</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="659e" class="lm ln in li b be lo lp l lq lr">const MyDiv = React.createClass({<br/>  render: function() {<br/>    return &lt;div&gt;{this.props.children}&lt;/div&gt;<br/>  }<br/>})<br/><br/>ReactDOM.render(<br/>  &lt;MyDiv&gt;<br/>    &lt;span&gt;{'Hello'}&lt;/span&gt;<br/>    &lt;span&gt;{'World'}&lt;/span&gt;<br/>  &lt;/MyDiv&gt;,<br/>  node<br/>)</span></pre><p id="51b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 10。如何在 React 中写评论？</strong></p><p id="b61d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React/JSX 中的注释类似于 JavaScript 的多行注释，但是用花括号括起来。</p><p id="2994" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单行注释:</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="5796" class="lm ln in li b be lo lp l lq lr">&lt;div&gt;<br/>  {/* Single-line comments(In vanilla JavaScript, the single-line comments are represented by double slash(//)) */}<br/>  {`Welcome ${user}, let's play React`}<br/>&lt;/div&gt;</span></pre><p id="e1c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多行注释:</p><pre class="ld le lf lg gt lh li lj bn lk ll bi"><span id="54fb" class="lm ln in li b be lo lp l lq lr">&lt;div&gt;<br/>  {/* Multi-line comments for more than<br/>   one line */}<br/>  {`Welcome ${user}, let's play React`}<br/>&lt;/div&gt;</span></pre></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="2ff2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我列出了 10 个 ReactJs 的问题，这是这个系列的第二部分。我会分享更多关于这个话题的部分和前端面试的问题。确保:-</p><ul class=""><li id="8fbf" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">给它鼓掌</li><li id="c086" class="kt ku in jx b jy mx kc my kg mz kk na ko nb ks lv kz la lb bi translated">跟着我<a class="nc nd ep" href="https://medium.com/u/8a9ce53808fd?source=post_page-----2430fe2d131a--------------------------------" rel="noopener" target="_blank">莫希特·加格</a>，也可以获得其他部分的通知。</li></ul></div></div>    
</body>
</html>