<html>
<head>
<title>Chapter 3— Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 3 章—功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/chapter-4-functions-d5395fd83786?source=collection_archive---------0-----------------------#2020-05-11">https://blog.devgenius.io/chapter-4-functions-d5395fd83786?source=collection_archive---------0-----------------------#2020-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6a726c2444d7f51e6612386f5cfb2abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJzeX047sv86oaiKQk_Iog.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">切斯文斯— <strong class="bd jz">迪斯尼乐园</strong></figcaption></figure><p id="127e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在你可能出生之前，<a class="ae ky" href="https://www.youtube.com/watch?v=Og847HVwRSI" rel="noopener ugc nofollow" target="_blank">福坦在流行音乐排行榜上称霸了近 30 年。</a>你可以想象从那以后软件的动态发生了多大的变化，但是<strong class="kc io">功能</strong> <strong class="kc io">依然盛行。</strong></p><p id="087a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我们将深入烹饪漂亮，干净的功能！</p><h2 id="725c" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">小——第一条规则</h2><p id="59db" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">你可能被建议保持你的功能不要大于一个屏幕滚动。</p><h2 id="68a7" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">更小——第二条规则</h2><p id="cd91" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">虽然我不能给你一个准确的数字，但 20 行已经足够了。足够了——不应该是 20 行。</p><h2 id="2ccf" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">块和缩进</h2><p id="44eb" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">缩进中的块通常应该是一行。如果你曾经发现自己在<code class="fe lw lx ly lz b">if</code>语句或<code class="fe lw lx ly lz b">for</code>循环之间编写了大量的指令，那么你很有可能将它们放入自己的函数中。</p><p id="cdac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举例来说，看看我们违反了多少原则。有太多的重复，有太多不必要的评论，因为它读起来很混乱(<em class="ma">提示，提示…下一章)</em>)，并且有太多的缩进块发生。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/42e5335a059b12c7145dbc67350b2f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d66W1ODrY9toQCFZe7u-Kw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd jz">不好。</strong></figcaption></figure><h2 id="c833" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">应该做一件事。应该做好。应该只做这件事。</h2><p id="97be" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">听起来很简单，但是<em class="ma">是什么一回事？</em></p><p id="8b72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您想通过向 API 提交表单来提交一个更新的用户名。大致说来，你必须:</p><ol class=""><li id="fc8c" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx ml mm mn mo bi translated">验证输入是字符串</li><li id="bba9" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">获取经过身份验证的用户令牌</li><li id="7d5f" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">用输入字符串数据触发 XHR 请求</li></ol><p id="bc2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是在做一件<em class="ma">事… </em>还是三件事？这将需要一些时间和经验来破译，但一般的经验法则是这样的；我们创建函数来分解更大的代码指令。<strong class="kc io">，</strong>，<em class="ma">然而，如果你能从函数中提取出另一个函数，那么你很有可能应该再写一个函数。</em></p><p id="df72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果你验证的输入是一个字符串<strong class="kc io">并且</strong>有<em class="ma"> x </em>个字符<strong class="kc io">和</strong>验证特殊字符，你应该创建<code class="fe lw lx ly lz b">validateUsernameInput(username)</code>函数并调用它。</p><h2 id="0bdc" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">Switch 语句</h2><p id="0049" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">当涉及到处理函数时，它们是有风险的。如果你和我一样，你应该知道 switch 语句有多棒。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/658f1dd4c91f84a9977fe94a9fd740bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*sIyoZ3rq_mJ4GLQO.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">抽象工厂——漫画由<a class="ae ky" href="https://refactoring.guru/design-patterns/abstract-factory" rel="noopener ugc nofollow" target="_blank"> refactoring.guru </a>提供</figcaption></figure><p id="16a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题来了(据鲍勃大叔说)…他们违反了单一责任原则(SRP)。一个有无限理由改变的<strong class="kc io"> <em class="ma">功能，到底有什么责任感？</em></strong>在 OOP 中，你可以在抽象工厂中使用开关来返回多态对象，但这听起来确实很可怕——不是吗？</p><p id="ff89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我找到在 switch 语句中调用函数的安全而适当的方法时，我会回来的。</p><h2 id="78a4" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">使用描述性名称</h2><p id="453f" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这很重要，所以我就开门见山了:</p><ul class=""><li id="b7a1" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx mv mm mn mo bi translated">使它们成为描述性的<strong class="kc io"/></li><li id="a08c" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx mv mm mn mo bi translated">不要撒谎</li><li id="aeb8" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx mv mm mn mo bi translated">从容做</li></ul><p id="f908" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些要点可以外推到一本自助书籍中，但它们也适用于函数名。寻找一个好名字需要重命名和重构，但这是值得的，因为它巩固了软件的方向和设计。</p><p id="d897" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说起来容易做起来难。说真的。</p><h2 id="c74f" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">一致性</h2><p id="e135" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated"><code class="fe lw lx ly lz b">getStage()</code>、<code class="fe lw lx ly lz b">fetchStage()</code>、<code class="fe lw lx ly lz b">currentStage()</code>！嗯…哪个是最好的名字？！<code class="fe lw lx ly lz b">getStage</code>是类方法…还是会执行 HTTP Get 请求…还是会开始计算整数？从长远来看，尽早拥有这些模式是非常有益的，因为你不必每次都进行第二次猜测。</p><h1 id="911b" class="mw la in bd jz mx my mz ld na nb nc lg nd ne nf lj ng nh ni lm nj nk nl lp nm bi translated">争论</h1><p id="b397" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">函数可以带参数，而且非常强大！</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/cf4bec126f11009e746aad4098513dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naE_rNFo0Los5panq8HaCQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">功能签名+形容词！</figcaption></figure><h2 id="5166" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">二元函数</h2><p id="0d96" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">它总是更容易阅读:</p><pre class="mc md me mf gt no lz np nq aw nr bi"><span id="1df4" class="kz la in lz b gy ns nt l nu nv">// monadic<br/>def add_hours(num_hours)</span></pre><p id="42ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后:</p><pre class="mc md me mf gt no lz np nq aw nr bi"><span id="95f7" class="kz la in lz b gy ns nt l nu nv">// dyadic<br/>def add_hours(unix_time, num_hours)</span></pre><p id="d28a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二元函数仍然非常易读和易懂。当然，第一个是好的，黄油；二元函数只需要多花一秒钟。问题是，<strong class="kc io">其中一个论点</strong>往往会被<em class="ma">忽略。</em>最终，<em class="ma"> </em>开发者将学会有意跳过这一争论，只看<code class="fe lw lx ly lz b">num_hours</code>。</p><blockquote class="nw"><p id="f13b" class="nx ny in bd nz oa ob oc od oe of kx dk translated">"我们忽略的部分是虫子的藏身之处."—马丁(4.42 分)</p></blockquote><p id="e4b6" class="pw-post-body-paragraph ka kb in kc b kd og kf kg kh oh kj kk kl oi kn ko kp oj kr ks kt ok kv kw kx ig bi translated">当你遇到需要使用二元函数的场景时，你的参数应该显得自然；<em class="ma">自然衔接</em>和<em class="ma">自然排序</em>。比如<code class="fe lw lx ly lz b">makeCircle(coordinate, radius)</code>有一个<em class="ma">自然度</em>到<code class="fe lw lx ly lz b">coordinate</code>和<code class="fe lw lx ly lz b">radius</code>，相比之下像<code class="fe lw lx ly lz b">buyGasoline(octane, carTankSize)</code>这样的函数。</p><h2 id="23db" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">三元和多元函数</h2><p id="5fbd" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">此时，将它包装成一个单独的类可能是有意义的。在 MVC 中，你可能想创建一个新的模型来缓解广泛的争论。</p><p id="307b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果可能，在参数中使用对象也可以减少参数数量:</p><p id="e17e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们解析出一些重要的信息，现在有了这些重要的信息，我们想把它放到某个地方！</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们正在做的事情相对简单，但争论使它变得相当模糊。</figcaption></figure><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">编辑:不需要返回` this '</figcaption></figure><h2 id="aadc" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">你不需要标志参数</h2><p id="9b21" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">函数签名中的布尔参数是函数正在做多件事情的标志。</p><p id="4b9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">真的，你应该把它分成两个独立的功能。</p><h2 id="d2da" class="kz la in bd jz lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">没有副作用！没有谎言！</h2><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/bd4a745c90e13ecf33f17c25deb786c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDn2TAw48G0H1_lE6uEing.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">你能发现副作用吗？</figcaption></figure><p id="86c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数<strong class="kc io"> <em class="ma">应该</em> </strong>只是验证密码是否正确。但是由于副作用(第 8 行),每当有人想要验证他们的输入密码时，他们就不必要地创建了一个授权令牌。</p><p id="6241" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它不止做一件事。它在撒谎。因此，有副作用的函数是不干净的。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><p id="b42b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，你可以在《干净代码》的第 4 章中读到更详细的内容，但是这里有一些重要的概念开发者应该记住:</p><p id="2c2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">每个功能一个抽象层次</strong>:基本上，不要混合复杂和低级的抽象。类似于在复杂的计算后加上一个<code class="fe lw lx ly lz b">.toString(2)</code>的东西。</p><p id="de7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">逐步下降规则</strong>:你的代码应该像叙述一样从上到下阅读，或者像你在一层一层的抽象中“走过”代码一样。</p><p id="52b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">偏好异常或返回错误码</strong>:返回自定义错误码时，可能会以<code class="fe lw lx ly lz b">if else hell</code>结束。马丁认为最好直接尝试，抓住<code class="fe lw lx ly lz b">(err)</code>号，然后返回。</p><p id="7acc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们在讨论错误处理，我也认为(几乎)所有的响应都应该在一个单独的函数中处理。你的职能是一回事<strong class="kc io"/>，处理成功的回应和错误是另一回事<strong class="kc io"/>。</p><p id="c6db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上一章的提示:也许你已经看过了《T3》，但它很可能是《T4》。一般来说，像<code class="fe lw lx ly lz b">data</code>或<code class="fe lw lx ly lz b">info</code>这样的词是虚假信息，它们不会引起任何混乱，但<strong class="kc io">也不会增加任何价值。</strong></p></div></div>    
</body>
</html>