<html>
<head>
<title>Data Structures and Algorithms: Common Graph Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法:常见的图形算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structures-and-algorithms-common-graph-algorithms-a51a8025fe3b?source=collection_archive---------12-----------------------#2022-04-13">https://blog.devgenius.io/data-structures-and-algorithms-common-graph-algorithms-a51a8025fe3b?source=collection_archive---------12-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3485" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解这些图形算法可以帮助你通过技术面试</h2></div><p id="3bca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个计算机科学的学生都必须学习数据结构和算法。然而，对于自学成才的开发人员来说，这并不是一个常见的话题。了解你的数据结构和算法对面试准备非常有帮助，甚至可能对你的工作有帮助，这取决于它是什么。</p><p id="3c75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看一些最常见的图算法以及它们是如何工作的。我们不会讨论算法的完整代码实现，而是算法中的伪代码和步骤。将有深入的代码教程附加。我们今天要看的四种图形算法是:</p><ul class=""><li id="8556" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">Dijkstra 算法</li><li id="d8ed" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">弗洛伊德-沃肖尔算法</li><li id="248d" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">普里姆算法</li><li id="5d5e" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">克鲁斯卡尔算法</li></ul><h2 id="4ca2" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">Dijkstra 算法</h2><p id="7c51" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Dijkstra 算法是计算机科学中最著名的最短路径算法之一。找到最短路径需要一个简单的方法。据传，艾德加尔·迪克斯特拉(Edsgar Dijkstra)在与他当时的未婚妻进行咖啡约会时，在一张餐巾纸上想到了这个算法！</p><p id="db55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是 Dijkstra 最短路径算法的伪代码:</p><ol class=""><li id="e3c4" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mn lh li lj bi translated">选择一个开始节点</li><li id="280c" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">跟踪“已访问”的节点</li><li id="0b39" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">检查每个节点，看它是否被访问过，以及它离起始节点有多远</li><li id="2226" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">这样做，直到所有节点都被访问，或者我们发现一个节点不能被访问</li></ol><p id="072f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你遍历了一个图中的所有节点，Dijsktra 的算法就会得到一个从起始节点开始的距离列表。</p><p id="7222" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于<a class="ae mo" href="https://pythonalgos.com/dijkstras-algorithm-in-5-steps-with-python/" rel="noopener ugc nofollow" target="_blank"> Dijkstra 在 Python 中的算法</a>的深度教程。</p><h2 id="f46a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">弗洛伊德-沃肖尔算法</h2><p id="e9bd" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Floyd-Warshall 是另一种最短路径算法。不像 Dijkstra 的算法不是在 Floyd 和 Warshall 约会时在餐巾背面发明的。相反，该算法有一个组合名称，因为罗伯特·弗洛伊德和史蒂芬·沃舍尔在 1962 年。它也与 1956 年发表的克莱尼算法密切相关。</p><p id="e06a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Floyd Warshall 算法是一种动态编程算法，这意味着我们要随着时间的推移来构建它。以下是弗洛伊德·沃肖尔算法的步骤。</p><ol class=""><li id="cbc1" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mn lh li lj bi translated">选择一个起始顶点</li><li id="9cb3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">计算顶点集之间的最短距离</li><li id="8339" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">如果任何计算的距离小于当前记录的距离，则更换当前的距离</li><li id="aa06" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">对每个顶点重复步骤 2 到 3</li></ol><p id="bdf1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 中<a class="ae mo" href="https://pythonalgos.com/graph-algorithms-floyd-warshall-in-python/" rel="noopener ugc nofollow" target="_blank"> Floyd Warshall 算法的深度教程</a>。</p><h2 id="c497" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">普里姆算法</h2><p id="f892" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">与 Dijkstra 或 Floyd-Warshall 的算法不同，Prim 的算法构建了一个最小生成树(MST)。MST 是表示图中节点集之间最短路径的树。让我们看看如何用 Prim 的算法创建一个 MST。</p><ol class=""><li id="b801" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mn lh li lj bi translated">选择一个顶点</li><li id="02b4" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">遍历树，找到距离最近的顶点</li><li id="b569" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">将新顶点添加到最小生成树并更新距离矩阵</li><li id="cb0a" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">重复步骤 2 和 3，直到 MST 完全构建完成</li></ol><p id="c2fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 中<a class="ae mo" href="https://pythonalgos.com/graph-algorithms-prims-algorithm/" rel="noopener ugc nofollow" target="_blank"> Prim 的算法深度教程。</a></p><h2 id="c6a5" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">克鲁斯卡尔算法</h2><p id="8fd8" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">和 Prim 的算法一样，Kruskal 的算法是一种从图中构建最小生成树的方法。Kruskal 算法和 Prim 算法的主要区别在于，当添加到 MST 时，算法寻找什么。Kruskal 的算法从挑选最短的边开始，然后找到最短的连接边。</p><p id="4e2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看克鲁斯卡尔算法的伪代码。</p><ol class=""><li id="756b" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mn lh li lj bi translated">找到开始 MST 的最短边</li><li id="6678" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">查找现有 MST 的最短附着边</li><li id="4e05" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">添加找到的边并更新距离矩阵</li><li id="6e00" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated">重复步骤 2 和 3，直到最小生成树完成</li></ol><p id="990b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 中关于<a class="ae mo" href="https://pythonalgos.com/graph-algorithms-kruskals-algorithm-in-python/" rel="noopener ugc nofollow" target="_blank">克鲁斯卡尔算法的深度教程</a>。</p><h2 id="d850" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">进一步阅读</h2><ul class=""><li id="83a2" class="lb lc iq kh b ki mi kl mj ko mp ks mq kw mr la lg lh li lj bi translated"><a class="ae mo" href="https://pythonalgos.com/nested-lists-in-python/" rel="noopener ugc nofollow" target="_blank">Python 中的嵌套列表</a></li><li id="fa77" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">建立你自己的人工智能文本摘要器</li><li id="0008" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">【2020 年和 2021 年的七项新自然语言处理技术</li><li id="b7cb" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae mo" rel="noopener ugc nofollow" target="_blank" href="/why-programming-is-easy-but-software-engineering-is-hard-90019fd78ed5">为什么编程容易而软件工程难</a></li><li id="25b3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae mo" href="https://pythonalgos.com/create-a-neural-network-from-scratch-in-python-3/" rel="noopener ugc nofollow" target="_blank">用 Python 从头开始编写神经网络代码</a></li></ul><p id="b93c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您觉得这很有帮助，请在 Twitter 或 LinkedIn 上与您的朋友分享！要想无限制地访问 Medium 上的信息宝库，今天就注册成为 Medium 会员吧！更多软件和技术行业的职业故事和技巧，记得关注我，<a class="ae mo" href="https://medium.com/u/1c4e6640433f?source=post_page-----90019fd78ed5-----------------------------------" rel="noopener">唐</a>！</p></div></div>    
</body>
</html>