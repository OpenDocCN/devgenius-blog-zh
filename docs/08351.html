<html>
<head>
<title>Refactoring Nightmares</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构噩梦</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/refactoring-nightmares-d7f4b2511501?source=collection_archive---------11-----------------------#2022-06-07">https://blog.devgenius.io/refactoring-nightmares-d7f4b2511501?source=collection_archive---------11-----------------------#2022-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6ceac72ee5fd29f819e991746ee5e824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kid0Jm-kwmaihHdT.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">早日康复。</figcaption></figure><p id="9988" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你正在开发一个快速增长、永不停止的产品；35 次冲刺和 600 杯咖啡之后，你终于要继续前进了，一个新的工程师介入了，或者你迟早会意识到你不能在保证代码质量的同时满足功能需求。然后，在提出了对重构的需求之后，作为几个特性的阻挡者，终于！这一天，你的工程团队决定将带宽用于重构——听起来很熟悉吧？你并不孤单。</p><h1 id="e559" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何避免重大重构的需要</h1><h1 id="ac96" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不要重建；建造正确的东西。</h1><p id="6de6" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">(1)在业务需求和开发时间之间取得正确的平衡是非常重要的，尤其是在早期的初创企业中，量化遵循最佳实践的需求以编写具有有意义的测试用例的干净代码可能比看起来更难。一种可行的方法是回顾原始故事的修补程序/错误/阻止程序的数量。有一个将代码合并到预生产/生产的流程:</p><ul class=""><li id="bf95" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">设置代码覆盖率阈值，</li><li id="0ae7" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">自动标记拉取/合并请求，而无需审阅注释，或者经典的“LGTM”(对我来说看起来不错)，</li><li id="bc39" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">将生产中的补丁链接到原始故事/PR，</li><li id="29dc" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">“代码所有者”对于某些关键的类/模块，并不是每个人都有权合并对任何文件/模块的更改(这对 monolith 代码库很重要)。</li></ul><p id="5fab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">(2)几乎不要直接在你的 IDE 上开始工作一个特性，</p><ul class=""><li id="dc8a" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">收集需求，</li><li id="14b6" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">开始一个粗略的解决方案文档，</li><li id="8bb2" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">列出不同的组件，</li><li id="85fc" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">指示这些组件如何相互通信，</li><li id="6383" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">考虑抽象的程度和可能的未来用例，</li><li id="ad49" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">决定合同并重新迭代</li></ul><p id="8d2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，是时候进入 IDE，从底层设计开始:接口、实体、dto、请求/响应等，然后是测试用例支持的实现(测试驱动开发)。</p><h1 id="235f" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如果是稳定的产品，就不要碰</h1><p id="5b41" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">恰恰相反！仅仅因为应用程序是稳定的，并且近期内不会有更多的特性出现，并不一定意味着它不会受到影响。当然，这可能不是最高优先级，但是请确保维护该项目并使其保持最新，以免它在稍后阶段影响您:</p><ul class=""><li id="520f" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">升级依赖项，如果不是次要版本，至少是下一个主要版本。</li><li id="4972" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">保持它与代码库/服务的其余部分同等重要，无论是架构、约定还是契约。</li><li id="2e18" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">稳定的服务经常被遗忘或者被认为是理所当然的；编写详细的文档。</li></ul><p id="bd28" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">同样，从业务的角度来看，对一个稳定的产品进行任何更改都没有投资回报，至少在短期内是这样的，但从长远来看，正是这些服务暴露了安全漏洞并存在可伸缩性问题。</p><h1 id="d697" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">重构不是一次性的工作</h1><p id="36f0" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">尽管采用了广泛的解决方案并遵循了所有最佳实践，但产品需求、客户需求和业务目标并不像我们想象的那样可预测，并且可能会随着时间的推移而发生巨大变化。幸运的是，这些变化也不是一夜之间发生的；</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a8fe4e33f710a0bc37d1693fc72df516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zdKmB_SA7b_cgcVH.png"/></div></div></figure><ul class=""><li id="bc21" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">避免大量重构的最好方法是更频繁地进行重构。</li><li id="eeb6" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">当您接触代码库的旧部分时，重新验证现有的底层设计。</li><li id="1ee2" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">暂时的攻击并不太糟糕，但它们最终会成为常态；这些黑客应该是接下来要处理的首要问题。</li><li id="be5d" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">不要担心“哦！对于一个小用例来说，代码太多了”。例如，考虑 4 个转换的 5 个状态的有限状态机，产生一个状态机编排器/引擎类、四个转换类、四个监听器类(发布-订阅)以及用于 API 资源、转换、dto 等的类/函数。众所周知，同样的情况也可以用一堆关于状态的 if-else 条件来描述。</li><li id="ddf8" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">不要羞于使用设计模式；也不要过度使用它。设计模式的最佳网站<a class="ae ms" href="https://refactoring.guru/design-patterns" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns</a></li></ul><p id="f133" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，如果你有一个技术债务下的重构故事，这是一个明确的指标，有些事情是不对的。</p><h1 id="04bb" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">找到将重构的重要性与 ROI 联系起来的方法。</h1><p id="9a45" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">好吧，这是最后一个。如前所述，强调常规重构的重要性并不总是容易的，这可能会让你慢下来。</p><p id="47ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">"<a class="ae ms" href="https://www.linkedin.com/pulse/refactoring-nightmares-nicholas-iannone/" rel="noopener ugc nofollow" target="_blank">这样想吧</a>:你是一个代码政治家。你的利益相关者是你的公民，他们希望你不仅要制定新的法律，还要废除那些不再有人赞同的法律。重构和特性开发一样必要，开发人员倾向于过多地关注添加新的东西。我们可以把时间花在用新玩具、衣服和家具填满房间上，但我们也需要不时打扫房间，扔掉旧东西。”</p><p id="aeb1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">头回“不要重建；构建正确的东西”并提出度量标准来更好地证明重构的必要性。</p><h1 id="cf96" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何重构</h1><h1 id="9ecb" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">重构时暂停新开发</h1><p id="d86b" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">想象一下重构，其他开发人员也在对你所在的类进行修改甚至重构——导致合并冲突的噩梦。所以，事先沟通你计划做的改变，确保分阶段重构，这样就不会在太长时间内成为障碍。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/e06a5be4d0c34aa8a8e9b8d423e2824a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zuLyQZdMpJe4s552.png"/></div></div></figure><h1 id="2b6a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定义重构的范围</h1><p id="f328" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">重构与处理一个特性没有什么不同；开始</p><ul class=""><li id="8b0b" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">收集关于您将要重构的现有代码的上下文，</li><li id="a476" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">确定重构计划的范围，决定要重构的类/函数，</li><li id="5a25" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">一如既往，不要马上开始编码；从低层次的设计开始，想出一个大概的结果——更重要的是，在估计大概的时间时要考虑求解时间，</li><li id="5fb2" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">最后，区分重构任务的优先级，并将其分解成更小的可部署的块，而不是提出一个巨大的拉请求，期望你的同事来审查它。</li></ul><h1 id="0546" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试用例，测试用例，测试用例</h1><p id="4119" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">首先，如果之前的测试用例很少或者没有，就不应该重构。永远记住，如果任何事情都可能出错，它就会出错(墨菲定律)。我是认真的！也许此时重构并不是正确的选择。相反，提高代码覆盖率，记录预期的行为，然后回来重构。如果没有一个可量化的标准来衡量重构的正确性，后果可能是残酷的。如果已经有代码覆盖良好的测试用例，遵循 TDD，添加新的测试用例，并修复旧的测试用例。</p><p id="b064" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">都说了，你的麻烦有多深？从丑陋的遗留代码中走出来是困难的，没有多少人注册。老话“预防胜于治疗”是避免以重构噩梦告终的方法。</p></div></div>    
</body>
</html>