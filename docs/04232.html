<html>
<head>
<title>Step by Step Spring Batch Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分步春批教程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/step-by-step-spring-batch-tutorial-577dbb3d8641?source=collection_archive---------0-----------------------#2021-02-13">https://blog.devgenius.io/step-by-step-spring-batch-tutorial-577dbb3d8641?source=collection_archive---------0-----------------------#2021-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/d73ac239bfcaa5c27809fc2958bff2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ilGP4Y1G63fpI6XGjTHMoQ.png"/></div></figure><p id="77fd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这篇文章中，我想展示如何使用 Spring Batch。这是一个循序渐进的春季批量教程。</p><p id="3c97" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在企业应用程序中，批处理很常见。但随着数据在互联网上变得越来越普遍，我们如何处理这些数据也变得很重要。有多种解决方案可供选择。Apache Storm 或<a class="ae kp" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>帮助处理和转换所需格式的数据。在本帖中，我们将更近距离地观察 Spring Batch。</p><h1 id="2ea4" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是春批？</h1><p id="42b1" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated"><strong class="jt io"> Spring Batch 是一个轻量级框架，旨在方便批处理</strong>。它允许开发人员创建批处理应用程序。反过来，这些批处理应用程序处理传入的数据，并对其进行转换以供将来使用。</p><p id="26b5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用<a class="ae kp" href="https://spring.io/projects/spring-batch" rel="noopener ugc nofollow" target="_blank"> Spring 批处理</a>的另一个很大的优势是它允许高性能地处理这些数据。对于严重依赖数据的应用程序，数据立即可用至关重要。</p><p id="a6ea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Spring Batch 允许开发人员使用基于 POJO 的方法。在这种方法中，开发人员可以将批处理的数据转换成数据模型，以便进一步用于应用程序业务逻辑。</p><p id="f0ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这篇文章中，我将介绍一个例子，在这个例子中，我们将为员工记录批处理一个数据密集型 CSV 文件，并转换、验证该数据以加载到我们的数据库中。</p><h1 id="4c1d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是批处理？</h1><p id="e2d0" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">批处理是一种数据处理模式。它包括消费所有数据、处理数据、转换数据，然后将其发送到另一个数据源。通常，这是通过自动化作业完成的。触发系统或用户触发作业，该作业处理作业定义。作业定义将是关于从其来源消费数据。</p><p id="6b85" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">批处理的主要优点是它可以处理大量的数据。然而，这个操作可以是异步的。大多数应用程序独立于实时用户交互执行批处理。</p><p id="aa2b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我们将了解 Spring Batch 框架及其组成。</p><h1 id="a958" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">Spring 批处理框架</h1><p id="afe8" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">下面的架构展示了 Spring Batch 框架的组件。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9b08ad2a219ab3d50360386b0750ab09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*k6wefCrGinp_9I_x"/></div></figure><p id="5cb0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，批处理涉及到一个作业。用户安排作业在特定时间或基于特定条件运行。这也可能涉及到作业触发器。</p><p id="bd3a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Spring 批处理框架还包括</p><ul class=""><li id="8214" class="ly lz in jt b ju jv jy jz kc ma kg mb kk mc ko md me mf mg bi translated">记录和跟踪</li><li id="7239" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">事务管理</li><li id="cafa" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">作业处理统计</li><li id="ab1f" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">作业重启</li><li id="3228" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">资源管理</li></ul><p id="4b8b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通常，当您配置作业时，它将保存在作业存储库中。<strong class="jt io">作业库</strong>保存所有作业的元数据信息。触发器在预定时间启动这些作业。</p><p id="f6d3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">作业启动器</strong>是在作业的预定时间到达时启动作业或运行作业的界面。</p><p id="47d0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">作业</strong>由作业参数定义。当作业启动时，会为该作业运行一个作业实例。作业实例的每次执行都有作业执行，它跟踪作业的状态。一个作业可以有多个步骤。</p><p id="488d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">步骤</strong>是作业的独立阶段。一个作业可以由多个步骤组成。与作业类似，每个步骤都有执行步骤并跟踪步骤状态的步骤执行。</p><p id="3dde" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">每一步都有一个基本上读取输入数据的<strong class="jt io">项读取器</strong>，一个处理并转换数据的<strong class="jt io">项处理器</strong>，以及一个获取处理后的数据并将其输出的<strong class="jt io">项写入器</strong>。</p><p id="f641" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们看看演示中的所有组件。</p><h1 id="2e8a" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">带示例的分步 Spring 批处理教程</h1><p id="32b2" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">作为演示的一部分，我们将通过 Spring Batch Framework 上传一个 csv 文件。因此，首先，创建 spring 项目并添加以下依赖项:</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="8095" class="mr kr in mn b gy ms mt l mu mv">implementation 'org.springframework.boot:spring-boot-starter-batch'</span></pre><p id="f56c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是我们项目的主要依赖。此外，我们的主要应用程序将如下所示:</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="0385" class="mr kr in mn b gy ms mt l mu mv">package com.betterjavacode.springbatchdemo; </span><span id="42a5" class="mr kr in mn b gy mw mt l mu mv">import org.springframework.boot.SpringApplication; <br/>import org.springframework.boot.autoconfigure.SpringBootApplication;</span><span id="232d" class="mr kr in mn b gy mw mt l mu mv">@SpringBootApplication <br/>public class SpringbatchdemoApplication <br/>{ <br/>   public static void main(String[] args) <br/>   { <br/>      SpringApplication.run(SpringbatchdemoApplication.class, args);<br/>   } <br/>}</span></pre><h1 id="e0a5" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建 DTO 对象</h1><p id="86cc" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">我将通过 CSV 文件上传员工数据，因此我将为员工创建如下 DTO 对象:</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="8120" class="mr kr in mn b gy ms mt l mu mv">package com.betterjavacode.springbatchdemo.dtos; </span><span id="e083" class="mr kr in mn b gy mw mt l mu mv">import com.betterjavacode.springbatchdemo.models.Company; <br/>import com.betterjavacode.springbatchdemo.models.Employee; <br/>import com.betterjavacode.springbatchdemo.repositories.CompanyRepository; import org.springframework.beans.factory.annotation.Autowired; <br/>import java.io.Serializable;</span><span id="9e09" class="mr kr in mn b gy mw mt l mu mv">public class EmployeeDto implements Serializable <br/>{ <br/>   private static final long serialVersionUID = 710566148641281929L; <br/>   <br/>  @Autowired <br/>  public CompanyRepository companyRepository; <br/>  private int employeeId; <br/>  private int companyId; <br/>  private String firstName; <br/>  private String lastName; <br/>  private String email; <br/>  private String jobTitle; <br/>  public EmployeeDto() { } </span><span id="30b8" class="mr kr in mn b gy mw mt l mu mv">  public EmployeeDto(int employeeId, String firstName, String lastName, String email, String jobTitle, int companyId) <br/>  { <br/>    this.employeeId = employeeId; <br/>    this.firstName = firstName; <br/>    this.lastName = lastName; <br/>    this.email = email; <br/>    this.jobTitle = jobTitle; <br/>    this.companyId = companyId; <br/>  } <br/>  <br/>  public Employee employeeDtoToEmployee() <br/>  { <br/>     Employee employee = new Employee(); <br/>     employee.setEmployeeId(this.employeeId); <br/>     employee.setFirstName(this.firstName); <br/>     employee.setLastName(this.lastName); <br/>     employee.setEmail(this.email); <br/>     Company company = companyRepository.findById(this.companyId).get(); <br/>    employee.setCompany(company); <br/>    employee.setJobTitle(this.jobTitle); <br/>    return employee; <br/>  } <br/>  <br/>  public int getEmployeeId () <br/>  {<br/>    return employeeId; <br/>  } </span><span id="c7a2" class="mr kr in mn b gy mw mt l mu mv">  public void setEmployeeId (int employeeId) <br/>  { <br/>    this.employeeId = employeeId; <br/>  }</span><span id="4fdd" class="mr kr in mn b gy mw mt l mu mv">  public int getCompanyId () <br/>  { <br/>    return companyId; <br/>  } </span><span id="4c5f" class="mr kr in mn b gy mw mt l mu mv">  public void setCompanyId (int companyId) <br/>  { <br/>    this.companyId = companyId; <br/>  } <br/>  <br/>  public String getFirstName () <br/>  { <br/>    return firstName; <br/>  } </span><span id="9c4b" class="mr kr in mn b gy mw mt l mu mv">  public void setFirstName (String firstName) <br/>  { <br/>    this.firstName = firstName; <br/>  } </span><span id="dd25" class="mr kr in mn b gy mw mt l mu mv">  public String getLastName () <br/>  { <br/>    return lastName; <br/>  } </span><span id="61f8" class="mr kr in mn b gy mw mt l mu mv">   public void setLastName (String lastName) <br/>   { <br/>     this.lastName = lastName; <br/>   } </span><span id="6d00" class="mr kr in mn b gy mw mt l mu mv">   public String getEmail () <br/>   { <br/>     return email; <br/>   } </span><span id="142b" class="mr kr in mn b gy mw mt l mu mv">   public void setEmail (String email) <br/>   { <br/>     this.email = email; <br/>   } </span><span id="457a" class="mr kr in mn b gy mw mt l mu mv">   public String getJobTitle () <br/>   { <br/>     return jobTitle; <br/>   } <br/>   <br/>   public void setJobTitle (String jobTitle) <br/>   { <br/>     this.jobTitle = jobTitle; <br/>   } <br/>}</span></pre><p id="71f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个 DTO 类也使用一个存储库<code class="fe mx my mz mn b">CompanyRepository</code>来获取一个公司对象并将 DTO 转换成一个数据库对象。</p><h1 id="4c7b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">设置弹簧批次配置</h1><p id="6cd7" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">现在，我们将为我们的作业设置一个批处理配置，它将运行以将 CSV 文件上传到数据库中。我们的类<code class="fe mx my mz mn b">BatchConfig</code>包含一个注释<code class="fe mx my mz mn b">@EnableBatchProcessing</code>。这个注释启用了 Spring 批处理特性，并提供了一个基本配置来在一个<code class="fe mx my mz mn b">@Configuration</code>类中设置批处理作业。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="3803" class="mr kr in mn b gy ms mt l mu mv">@Configuration <br/>@EnableBatchProcessing <br/>public class BatchConfig <br/>{ </span><span id="75a5" class="mr kr in mn b gy mw mt l mu mv">}</span></pre><p id="0d10" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该批处理配置将包括我们作业的定义、作业中涉及的步骤。它还将包括我们希望如何读取我们的文件数据并进一步处理它。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="2b9f" class="mr kr in mn b gy ms mt l mu mv">@Bean <br/>public Job processJob(Step step) <br/>{ <br/>  return jobBuilderFactory.get("processJob") <br/>    .incrementer(new RunIdIncrementer()) <br/>    .listener(listener()) <br/>    .flow(step)<br/>    .end().build(); <br/>} </span><span id="830c" class="mr kr in mn b gy mw mt l mu mv">@Bean <br/>public Step orderStep1(JdbcBatchItemWriter writer) <br/>{ <br/>   return stepBuilderFactory.get("orderStep1").&lt;EmployeeDto, EmployeeDto&gt; chunk(10) <br/>      .reader(flatFileItemReader())<br/>      .processor(employeeItemProcessor()) <br/>      .writer(writer).build(); <br/>}</span></pre><p id="558b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以上豆申报工作<code class="fe mx my mz mn b">processJob</code>。<code class="fe mx my mz mn b">incrementer</code>添加作业参数。<code class="fe mx my mz mn b">listener</code>会倾听工作并处理工作状态。<code class="fe mx my mz mn b">listener</code>的 bean 将处理作业完成或作业失败通知。正如 Spring Batch architecture 中所讨论的，每个作业都包含不止一个步骤。</p><p id="711e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">@Bean</code> for step 使用<code class="fe mx my mz mn b">stepBuilderFactory</code>创建一个步骤。该步骤处理大小为 10 的数据块。它有一个平面文件阅读器<code class="fe mx my mz mn b">flatFileItemReader()</code>。处理器<code class="fe mx my mz mn b">employeeItemReader</code>将处理平面文件项读取器读取的数据。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="d5d1" class="mr kr in mn b gy ms mt l mu mv">@Bean <br/>public FlatFileItemReader flatFileItemReader() <br/>{ <br/>   return new FlatFileItemReaderBuilder() <br/>    .name("flatFileItemReader") <br/>    .resource(new ClassPathResource("input/employeedata.csv")) <br/>    .delimited() <br/>    .names(format) <br/>    .linesToSkip(1) <br/>    .lineMapper(lineMapper()) <br/>    .fieldSetMapper(new BeanWrapperFieldSetMapper(){{ setTargetType(EmployeeDto.class); }}) <br/>    .build(); <br/>} </span><span id="c699" class="mr kr in mn b gy mw mt l mu mv">@Bean <br/>public LineMapper lineMapper() <br/>{ <br/>   final DefaultLineMapper defaultLineMapper = new DefaultLineMapper&lt;&gt;(); <br/>   final DelimitedLineTokenizer delimitedLineTokenizer = new DelimitedLineTokenizer(); <br/>   delimitedLineTokenizer.setDelimiter(","); <br/>   delimitedLineTokenizer.setStrict(false); <br/>   delimitedLineTokenizer.setNames(format); <br/>   defaultLineMapper.setLineTokenizer(delimitedLineTokenizer); <br/>   defaultLineMapper.setFieldSetMapper(employeeDtoFieldSetMapper); <br/>   return defaultLineMapper; <br/>} </span><span id="f989" class="mr kr in mn b gy mw mt l mu mv">@Bean <br/>public EmployeeItemProcessor employeeItemProcessor() <br/>{ <br/>   return new EmployeeItemProcessor(); <br/>} </span><span id="3926" class="mr kr in mn b gy mw mt l mu mv">@Bean <br/>public JobExecutionListener listener() <br/>{ <br/>   return new JobCompletionListener(); <br/>} </span><span id="1376" class="mr kr in mn b gy mw mt l mu mv">@Bean <br/>public JdbcBatchItemWriter writer(final DataSource dataSource) <br/>{ <br/>    return new JdbcBatchItemWriterBuilder() <br/>      .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;&gt;()) <br/>      .sql("INSERT INTO employee(employeeId, firstName, lastName, jobTitle, email, " + "companyId) VALUES(:employeeId, :firstName, :lastName, :jobTitle, :email," + " " + ":companyId)") .dataSource(dataSource) <br/>      .build(); <br/>}</span></pre><p id="0460" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，我们将看一看每一个 beans。</p><p id="423a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">FlatFileItemReader</code>将从平面文件中读取数据。我们使用 FlatFileItemReaderBuilder 来创建类型为<code class="fe mx my mz mn b">EmployeeDto</code>的 FlatFileItemReader。</p><p id="fcf1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">resource</code>表示文件的位置。</p><p id="7ec2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">delimited</code> -这构建了一个分隔符号化器。</p><p id="9396" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">names</code> -将显示文件中字段的顺序。</p><p id="274f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">lineMapper</code>是从文件到域对象映射行的接口。</p><p id="2c36" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">fieldSetMapper</code>将字段集中的数据映射到一个对象。</p><p id="a8c4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">lineMapper</code> bean 需要标记器和 fieldsetmapper。</p><p id="ab0d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">employeeDtoFieldSetMapper</code>是我们在这个类中自动连接的另一个 bean。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="a15a" class="mr kr in mn b gy ms mt l mu mv">package com.betterjavacode.springbatchdemo.configurations.processor;</span><span id="20df" class="mr kr in mn b gy mw mt l mu mv">import com.betterjavacode.springbatchdemo.dtos.EmployeeDto; <br/>import org.springframework.batch.item.file.mapping.FieldSetMapper; import org.springframework.batch.item.file.transform.FieldSet; import org.springframework.stereotype.Component; <br/>import org.springframework.validation.BindException;</span><span id="41c3" class="mr kr in mn b gy mw mt l mu mv">@Component <br/>public class EmployeeDtoFieldSetMapper implements FieldSetMapper <br/>{ <br/>    @Override <br/>    public EmployeeDto mapFieldSet (FieldSet fieldSet) throws BindException <br/>    { <br/>      int employeeId = fieldSet.readInt("employeeId"); <br/>      String firstName = fieldSet.readRawString("firstName"); <br/>      String lastName = fieldSet.readRawString("lastName"); <br/>      String jobTitle = fieldSet.readRawString("jobTitle"); <br/>      String email = fieldSet.readRawString("email"); <br/>      int companyId = fieldSet.readInt("companyId"); <br/>      return new EmployeeDto(employeeId, firstName, lastName, jobTitle, email, companyId); <br/>    } <br/>}</span></pre><p id="9010" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如您所见，这个 FieldSetMapper 将字段映射到单个对象，以创建一个<code class="fe mx my mz mn b">EmployeeDto</code>。</p><p id="ae89" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">EmployeeItemProcessor</code>实现接口<code class="fe mx my mz mn b">ItemProcessor</code>。基本上，在这个类中，我们验证<code class="fe mx my mz mn b">EmployeeDto</code>数据以验证雇员所属的公司是否存在。</p><p id="41ed" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mx my mz mn b">JobCompletionListener</code>检查作业完成状态。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="a0a6" class="mr kr in mn b gy ms mt l mu mv">@Override <br/>public void afterJob(JobExecution jobExecution) <br/>{ <br/>   if (jobExecution.getStatus() == BatchStatus.COMPLETED) <br/>   { // Log statement <br/>     System.out.println("BATCH JOB COMPLETED SUCCESSFULLY"); <br/>   } <br/>}</span></pre><p id="e582" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，我们来看看<code class="fe mx my mz mn b">ItemWriter</code>。这个豆基本用的是<code class="fe mx my mz mn b">JdbcBatchItemWriter</code>。<code class="fe mx my mz mn b">JdbcBatchItemWriter</code>使用<strong class="jt io"> INSERT </strong> sql 语句将处理后的<code class="fe mx my mz mn b">EmployeeDto</code>数据插入到配置好的数据源中。</p><h1 id="2f7b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">配置应用程序属性</h1><p id="dd51" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">在我们运行应用程序来处理文件之前，让我们看一下<code class="fe mx my mz mn b">application.properties</code>。</p><pre class="lu lv lw lx gt mm mn mo mp aw mq bi"><span id="19ac" class="mr kr in mn b gy ms mt l mu mv">spring.datasource.url=jdbc:mysql://127.0.0.1/springbatchdemo?autoReconnect=true&amp;useSSL=false <br/>spring.datasource.username = root spring.datasource.password=******* spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.jpa.show-sql=true <br/>spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect spring.datasource.hikari.connection-test-query=SELECT 1 spring.batch.initialize-schema=ALWAYS</span></pre><p id="e204" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">除了常规的数据源属性，我们还应该了解属性<code class="fe mx my mz mn b">spring.batch.initialize-schema=ALWAYS</code>。如果我们不使用这个属性并启动应用程序，应用程序将会抱怨<code class="fe mx my mz mn b">Table batch_job_instance doesn't exist</code>。</p><p id="e119" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了避免这个错误，我们基本上是告诉在启动时创建批处理作业相关的元数据。该属性将在您的数据库中创建额外的数据库表，如<code class="fe mx my mz mn b">batch_job_execution</code>、<code class="fe mx my mz mn b">batch_job_execution_context</code>、<code class="fe mx my mz mn b">batch_job_execution_params</code>、<code class="fe mx my mz mn b">batch_job_instance</code>等。</p><h1 id="09bf" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">演示</h1><p id="3a1a" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">现在，如果我执行我的 Spring Boot 应用程序，它将运行并执行作业。触发作业有不同的方式。在一个企业应用程序中，你将在某种存储位置(S3 或亚马逊 SNS-SQS)接收一个文件或数据，你将有一个监视这个位置的作业来触发文件加载 Spring 批处理作业。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/fe23304beef9ab4c8664276979a726ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*ObT8aFYTgTB1liW2"/></div></figure><p id="b30d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以在执行中看到一条关于作业完成的消息—“批处理作业成功完成”。如果我们检查我们的数据库表，我们会看到加载的数据。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/f6a0516701e53c121da6296ab400e145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*G5Ho0fjbob6KUejv"/></div></figure><p id="8d3b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你可以从我的<a class="ae kp" href="https://github.com/yogsma/springbatchdemo" rel="noopener ugc nofollow" target="_blank"> github 库</a>下载这个演示的代码。</p><h1 id="111f" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">还有什么？</h1><p id="9536" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">我这里覆盖了一个春批教程，但这还不是全部。Spring Batch 不仅仅是这个介绍性的部分。您可以有不同的输入数据源，也可以使用不同的数据处理规则从一个文件加载到另一个文件。</p><p id="4e2c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">还有一些方法可以自动执行这些作业，并以高效的方式处理大量数据。</p><h1 id="f316" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="c861" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">在这篇文章中，我展示了一步一步的 Spring 批处理教程。有许多方法可以处理批处理作业，但是 Spring Batch 使这变得非常容易。</p><p id="1a4a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在其他新闻中，我最近发布了我的新书——简化 Spring 安全。如果你想了解春天的安全，你可以在这里购买《T4》一书。伴随这本书的还有这篇<a class="ae kp" href="https://betterjavacode.com/spring-boot/top-21-spring-boot-interview-questions" rel="noopener ugc nofollow" target="_blank"> Spring Boot 面试问题</a>的帖子，你将为你的下一次工作面试做好准备。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="1537" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="nh">原载于 2021 年 2 月 13 日 https://betterjavacode.com</em><em class="nh">的</em> <a class="ae kp" href="https://betterjavacode.com/spring-boot/step-by-step-spring-batch-tutorial" rel="noopener ugc nofollow" target="_blank"> <em class="nh">。</em></a></p></div></div>    
</body>
</html>