# 智能重组去神秘化 Jetpack 组合

> 原文：<https://blog.devgenius.io/smart-recomposition-demystified-jetpack-compose-a6e3da767504?source=collection_archive---------6----------------------->

![](img/1ac0458649f0859b6f52dcaf17edea4c.png)

正如你可能知道的，一个可组合的函数是*可重启的*意味着它可以在任何时候被组合运行时执行多次。

但是，为了一个小变化而重新组合整个屏幕对性能没有好处，因为组合框架具有跳过某些可组合组件或其子可组合组件(也称为 S ***集市组合*)的重新组合的机制。**

> 但是它是怎么做到的呢？(一探究竟)

因此，当你编译一个 compose 应用程序时，编译器会寻找所有用 **@Composable** 注释声明的函数，并用它们进行一些转换，意思是可组合的，如下所示

会被转换成类似

> ***呜啊..*** *，冷静下来，我们会更详细地了解*
> 
> **注:**转换后的代码并非在所有情况下都相同，可以更复杂也可以更简单，这取决于编译器是否能推断出一些东西并进行优化

在这里我们可以看到两个额外的参数，一个是`Composer context`另一个是`changed`，它是一个位域，改变的变量告诉我们这个可组合函数的数据是否改变，如果数据改变了，就重新组合，否则就不改变。

被改变的是一个 32 位的位掩码，组合只使用`30`位`2`位代表一个可组合函数的一个参数`30/2 = 15`意味着一个被改变的变量可以代表`15`个参数，如果你的函数有不止`15`个参数，一个被改变的参数可能会被传递`changed2`等等。

假设我们有`0 01 01 11 10 01 11 00 10 10 10 10 10 00 10 10 0`

这里的第一位是符号位 compose 忽略它，最后一位是强制更新位`0`表示不强制重组`1`表示强制重组

所有其他两位组代表该可组合的参数，它们的配置细节如下所示。

**深潜**

在上面的代码中，我们有`$changed and 0b0110 === 0`这里`0b`只是说这是二进制编码的`0`是符号位`11`表示**静态**我们然后`and`它到`$changed`。例如，假设*已更改/变脏*是`0b0011`

`0b0011 and 0b0110 -> 0b00 -> 00 (Uncertain)`

所以上面的表达式可以简化为`if(Uncertain)`,所以为了确定，我们做下面的事情

`$dirty = $dirty or if ($composer.changed(imageResId)) 0b0010 else 0b0100`

因此，如果我们不确定，我们需要通过说`$composer.changed(imageResId)`来询问作曲者，如果为真，那么我们得到`0b0010`，它解析为不同的 else `0b0100`，它解析为相同的 else`0b0100`，然后我们用`$dirty`对其进行`or`。

`so $dirty = 0b0010 or 0b0010 -> 01 -> (Same)`

我们的示例解析为 Same，但它可以是来自(Static /Same/Different)的任何内容，因此在下一步中，我们通过执行以下操作来检查它。

```
$dirty and 0b1011 xor 0b1010 !== 0 || !$composer.skipping
```

这里的`!$composer.skipping`表示运行时无论如何都要重新组合，这在某些情况下可能是真的，我们不在这里讨论这些，我们将关注`$dirty and 0b1011 xor 0b1010 !== 0`

所以我们有`0b0010 and 0b1011 xor 0b1010 -> 0b0010 xor 0b1011 -> 00`，所以条件为真，我们可以跳过重组，好的。

底层实现可能会随着时间的推移而不同，但它们在某种程度上是组合框架决定哪些可组合组件或部分可组合组件需要重新组合的方式。

谢谢