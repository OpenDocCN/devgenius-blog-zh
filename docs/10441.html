<html>
<head>
<title>Longest Increasing Subsequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最长增长子序列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/longest-increasing-subsequence-a87b7ba62d85?source=collection_archive---------17-----------------------#2022-11-01">https://blog.devgenius.io/longest-increasing-subsequence-a87b7ba62d85?source=collection_archive---------17-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="38f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几天前我遇到了这个问题，对于 DMOJ 问题来说，这是一个经典问题。问题的目标是，给定一组数字，找出最长的递增子序列。对于那些不知道的人，可以通过删除元素来形成子序列，但不能交换或替换任何元素。有多种可能的算法可以成功地解决这个问题，但是在给定时间约束的情况下，只有一种算法能够成功。虽然您可能会本能地使用动态编程，但创建一个数组并取最大值，这对于 DMOJ 来说太慢了，分数大约为 80/100。解决这个问题所需的算法实现起来相对简单，但很难理解。解决这个问题的方法包括创建一个列表，如果可能的话，在这个列表中添加内容。但是，如果您试图追加的数字更大，您将创建一个新列表，您将“复制”另一个列表并删除元素，直到该数字可以容纳为止。然后你会得到最大长度列表。让我给你举个例子:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="8300" class="ks kt in ko b gy ku kv l kw kx">[1 5 2 6 4]</span></pre><p id="6465" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从创建一个列表开始，姑且称之为 list1。当我们浏览列表时，我们注意到 5 大于 1，所以我们把它附加到 list1。然而，我们看到 2，2 小于 5，这意味着我们不能将它附加到 list1 中。这意味着我们创建一个名为 list2 的新列表。在这个列表中，我们将包括 1，但不包括 5，因为 5 大于 2，我们希望在这个列表中包括 2。下一个元素是 6，6 可以放在 list1 和 list2 中，所以我们将把它放在两个列表中。这意味着 list1 = [1，5，6]和 list2 = [1，2，6]。接下来我们有 4 个，因为 4 不适合任何一个列表，我们将获取列表 2，复制它并创建列表 3。然后我们删除元素，直到它们少于 4 个，并追加 4。现在我们的列表中没有更多的元素了，所以我们完成了迭代。现在我们必须接受最大长度列表，它是 3。这是预期的输出。</p><p id="5005" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，正如您可能意识到的，这不是一个非常有效的方法。这种方法使用了大量不必要的空间，并且搜索每个列表以确定是否需要包含某个元素的成本很高。谢天谢地，有一种方法可以加速这个过程。这种方法使用了与上面提到的类似的方法，但是它是建立在它的基础上的。这种方法将在列表中标记多个列表，而实际上并不占用空间。让我解释一下。考虑上面给出的例子:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="6987" class="ks kt in ko b gy ku kv l kw kx">[1 5 2 6 4]</span></pre><p id="825a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，我们遍历这个列表，并添加到一个新的列表中，我们称这个列表为 list1。所以，当我们遍历列表时，我们可以从向 list1 追加 1 和 5 开始。棘手的部分来自 2。我们不能用 2 扩展 list1，所以我们在 list1 中标记了一个新列表。我们将通过替换大于 2 的最小元素来做到这一点。在这种情况下，这将是 5。这种替换技术是可行的，因为被替换的元素对我们来说无关紧要。我们只使用现有列表的结束元素来检查它们是否可以扩展，否则就形成新的列表。此外，由于我们已经用一个较小的元素替换了一个较大的元素，这不会影响在获取现有列表的一部分后创建新列表的步骤。让我们在这个例子中继续这个方法。我们当前的列表如下所示:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="db1a" class="ks kt in ko b gy ku kv l kw kx">list1 = [1, 2]</span></pre><p id="63ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来是数字 6。由于 6 大于 2，我们可以扩展列表。这意味着我们的新名单将包括 6 个。但是，最后一个元素是 4。因为 6 是值大于 4 的最小元素，所以我们用 4 代替 6，这就是我们的列表。然而，很快意识到这不是最长的递增子序列列表。这种方法对此没有用，只适合于确定这样一个序列的长度。这给出了长度为 4 的正确答案。</p><p id="6fef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这比动态编程更好的原因是，如果最后一个元素比当前元素大，我们当前应用二分搜索法来替换元素。由于使用的算法，列表将始终保持排序，因此二分搜索法将始终给我们正确的索引。基本上，我们将比较列表的结束元素和迭代中的元素。如果迭代中的元素比它大，我们就扩展列表。否则，我们可以使用二分搜索法找到大于或等于迭代中的当前元素的最小元素，并替换它。</p><p id="27ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在来实现这个方法。</p><p id="4cb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将数组作为 DMOJ 判断的输入。这将看起来像下面这样:</p><figure class="kj kk kl km gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="da1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们将创建一个函数，它将为我们完成算法。如果你不知道，lower_bound 是 C++内置的二分搜索法算法。</p><p id="f57f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是完整的代码:</p><figure class="kj kk kl km gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="6006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这有帮助的话，请留下一个列表，并在下面留下您希望我解决的任何其他编码问题的评论。</p></div></div>    
</body>
</html>