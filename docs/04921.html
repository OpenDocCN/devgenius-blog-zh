<html>
<head>
<title>DIY: ScrollSpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DIY: ScrollSpy</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/diy-scrollspy-4f1c270cafaf?source=collection_archive---------0-----------------------#2021-05-22">https://blog.devgenius.io/diy-scrollspy-4f1c270cafaf?source=collection_archive---------0-----------------------#2021-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a9da" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用反应和交叉点观察器</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ce197d7573ae27e5a9797b5a25bd9927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1suhmrf41opa4TfFMATTQQ.jpeg"/></div></div></figure><p id="e3c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我经常发现，如果没有某种形式的实际应用，软件开发的理论方面对我来说将会迷失。在我职业生涯的早期，我会通过尝试自己建造东西的形式来寻求对事物如何运作的更好理解。这种“自己动手”的态度帮助我培养了充分利用现有库编写代码的能力。我坚信，我们不仅应该努力<code class="fe lk ll lm ln b">know the documentation</code>和<code class="fe lk ll lm ln b">use the tools</code>，还应该能够构建我们希望在项目中使用的东西。</p><p id="6614" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑到这一点，我想我应该开始一个DIY系列，采用一些我们在野外很容易找到的功能，并提供一个易于实现的版本。</p><p id="4800" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文将重点介绍ScrollSpy。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="bc6e" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">什么是ScrollSpy？</h1><p id="c20a" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">很高兴你问了！</p><p id="cbff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个<code class="fe lk ll lm ln b">ScrollSpy</code>只是一些模式，允许你监视滚动事件，并在用户或浏览器滚动页面时做一些事情。这对于创建导航菜单非常方便，每当用户滚动到页面上的一个新部分时，或者当开发人员自动执行一些滚动到这一部分的魔术时，导航菜单会更新以显示哪个项目是活动的。这是一个<code class="fe lk ll lm ln b">ScrollSpy</code>非常常见的用法。事实上，在<a class="ae ms" href="https://getbootstrap.com/docs/5.0/components/scrollspy/" rel="noopener ugc nofollow" target="_blank"> Bootstrap对Scrollspy </a>的实现中可以找到一个流行的例子。如果你想变得有创意，你也可以用它来制作动画部分，惰性加载内容，或者任何你能想到的东西。在谷歌商店页面上可以找到一个使用<code class="fe lk ll lm ln b">ScrollSpy</code>模式制作一些内容动画的极好例子，它是关于<a class="ae ms" href="https://store.google.com/au/product/pixel_buds?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=japac-AU-en-dr-bkws-super-all-buy-e-dr-1008675&amp;utm_content=text-ad-none-none-DEV_c-CRE_460680811804-ADGP_Hybrid+%7C+BKWS+-+EXA+~+Pixel+Buds+~+%5B1:1%5D+~+AU+~+en+~+google+buds-KWID_43700056950091231-kwd-370572617021-userloc_9071405&amp;utm_term=KW_google+buds-ST_google+buds&amp;gclid=CjwKCAjwtJ2FBhAuEiwAIKu19j2P4BXmx1snw9k5cDtLb9uMkiJRYWx5_mfm27G27SQ_H73GUUsRahoCGkYQAvD_BwE&amp;gclsrc=aw.ds&amp;hl=en-GB" rel="noopener ugc nofollow" target="_blank">谷歌像素芽</a>(这不是广告😬！).那一页上有一些精彩的UX，我会让你自己去翻阅，看看我的意思。</p><h1 id="3cc9" class="lv lw in bd lx ly mt ma mb mc mu me mf jt mv ju mh jw mw jx mj jz mx ka ml mm bi translated">创建自己的ScrollSpy</h1><p id="6226" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">有很多方法可以为你的项目创建一个<code class="fe lk ll lm ln b">ScrollSpy</code>模式。我将重点介绍如何结合使用Intersection Observer和React来创建一个简单的导航菜单，当用户滚动页面时，它会更新所选的值。我将假设您了解在项目中设置和使用React的相关知识，但将详细介绍交叉点观察器。</p><h2 id="b00d" class="my lw in bd lx mz na dn mb nb nc dp mf kx nd ne mh lb nf ng mj lf nh ni ml nj bi translated">交叉观察者</h2><p id="5d6c" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">Intersection Observer是一个API，它允许您观察某个元素与其父元素或祖先元素的交集的变化。我们可以使用这个API来检查一个元素是否在视窗中，或者它在页面上相对于其祖先的位置。我们将使用交叉点观察器API作为我们代码的核心部分，来确定与更新我们将要构建的导航菜单相关的<code class="fe lk ll lm ln b">when, what, and how</code>。</p><p id="a9b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您想了解更多关于交叉点观察器的信息，您可以在<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>中找到。</p><p id="d2ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们开始写一些代码。好吗？</p><h2 id="ed4c" class="my lw in bd lx mz na dn mb nb nc dp mf kx nd ne mh lb nf ng mj lf nh ni ml nj bi translated">ScrollSpy代码</h2><p id="eb46" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">首先让我们创建我们的<code class="fe lk ll lm ln b">ScrollSpy</code>组件。在这个组件中，我们有两个关键的功能部分— <code class="fe lk ll lm ln b">isInViewPort</code>和<code class="fe lk ll lm ln b">Intersection Observer</code>。</p><p id="6f2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">isInViewPort</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">isInViewPort函数</figcaption></figure><p id="7d00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">IsInViewPort</code>是一个非常简单的函数，它接收来自<code class="fe lk ll lm ln b">IntersectionObserver</code>的<code class="fe lk ll lm ln b">entry</code>，并使用来自条目<code class="fe lk ll lm ln b">boundingClientRect</code>的属性来计算元素是否仍在视口中。这将有助于我们防止多个菜单项同时被激活。</p><p id="9172" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">Intersection Observer</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">交叉口观察者代码</figcaption></figure><p id="fe52" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们将从DOM中获取我们想要观察的元素，然后对它们进行迭代，为每个元素创建一个<code class="fe lk ll lm ln b">new IntersectionObserver</code>。我们的目标是一个<code class="fe lk ll lm ln b">data-scrollspy</code>属性，但是可以很容易地传入一个选择器来使用。我有目的地这样做是为了将ScrollSpy代码从依赖于被告知<em class="nq">选择什么</em>中抽象出来。它应该知道。继续，我们的<code class="fe lk ll lm ln b">new IntersectionObserver</code>接受回调和一些选择。我们使用的回调函数将对<code class="fe lk ll lm ln b">entries</code>执行<code class="fe lk ll lm ln b">forEach</code>，并将<code class="fe lk ll lm ln b">entry</code>和<code class="fe lk ll lm ln b">isInViewPort</code>结果传递给作为<code class="fe lk ll lm ln b">ScrollSpy</code>组件的属性传递的<code class="fe lk ll lm ln b">handleScroll</code>函数。这些选项会将浏览器设置为视区、视区周围的边距，以及要在其中执行回调的被观察元素的可见性百分比。最后我们用<code class="fe lk ll lm ln b">observer.observe()</code>设置我们想要观察的元素</p><p id="c9b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此时，您的<code class="fe lk ll lm ln b">ScrollSpy</code>组件应该如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">ScrollSpy组件</figcaption></figure><p id="f892" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我已经将它编码为一个返回null的React组件，但是有很多方法可以做到这一点。</p><p id="f5bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nq">更多关于路口观察者回调的信息和选项可以在</em> <a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#creating_an_intersection_observer" rel="noopener ugc nofollow" target="_blank"> <em class="nq">这里找到</em> </a> <em class="nq">。</em></p><p id="7508" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，让我们创建一个将利用我们的<code class="fe lk ll lm ln b">ScrollSpy</code>组件的<code class="fe lk ll lm ln b">NavMenu</code>。</p><p id="1c74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">NavMenu</code>文件由一个效用函数和两个React组件组成:<code class="fe lk ll lm ln b">onScrollUpdate</code>、<code class="fe lk ll lm ln b">NavMenu</code>和<code class="fe lk ll lm ln b">WithNavMenu</code>。</p><p id="ed30" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">onScrollUpdate</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">onScrollUpdate代码</figcaption></figure><p id="be6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">onScrollUpdate</code>(前面提到过)作为<code class="fe lk ll lm ln b">handleScroll</code>道具传入<code class="fe lk ll lm ln b">ScrollSpy</code>。每当观察到的元素之一满足特定条件时，该功能将允许我们更新菜单项的活动状态。在这种情况下，我们希望检查<code class="fe lk ll lm ln b">y</code>值是否小于或等于0，元素是否在视口中。如果这是真的，那么我们将它设置为活动的，否则我们将活动的类从元素中移除，为另一个元素让路。</p><p id="5561" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">NavMenu</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">导航菜单组件</figcaption></figure><p id="6f8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b"> NavMenu</code>组件接收<code class="fe lk ll lm ln b">options</code>并使用它们构建导航菜单。通常情况下，我们会希望使用本地浏览器功能的锚标签，以滚动到页面上的一节。在我们的例子中，我们希望对页面滚动到哪里有更多的控制，以避免任何奇怪的行为。出于这个原因，我们创建了一个<code class="fe lk ll lm ln b">onClick</code>函数，它否定了锚标签的默认行为，并接管了在浏览器中设置散列以及滚动到正确元素的工作。</p><p id="118f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">WithNavMenu</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">带导航菜单的高阶组件</figcaption></figure><p id="483b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">WithNavMenu</code>是一个高阶组件(HOC ),我们将使用它来生成选项数组并呈现我们的<code class="fe lk ll lm ln b">ScrollSpy</code>组件和可观察元素。这个组件接收<code class="fe lk ll lm ln b">children</code>和一个<code class="fe lk ll lm ln b">selector</code>。<code class="fe lk ll lm ln b">selector</code>是我们想要用来构建<code class="fe lk ll lm ln b">NavMenu</code>选项的组件的标识符。当查询DOM中的选择器时，我们映射返回的元素，以有意义的方式形成选项。例如，导航菜单选项中使用的标题是从映射元素<code class="fe lk ll lm ln b">dataset</code>属性中提取的。</p><p id="c779" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">完整的<code class="fe lk ll lm ln b">NavMenu</code>文件应该如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">所有导航菜单代码</figcaption></figure><p id="4c2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们可以像这样实现我们的NavMenu和ScrollSpy:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">NavMenu和ScrollSpy示例实现</figcaption></figure><p id="7e6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们使用<code class="fe lk ll lm ln b">WithNavMenu</code> HOC来包装一组具有id的<code class="fe lk ll lm ln b">section</code>标签，通过<code class="fe lk ll lm ln b">data-nav-title</code>属性设置标题，并通过<code class="fe lk ll lm ln b">data-scrollspy</code>属性将它们自己标记为准备好被我们的<code class="fe lk ll lm ln b">ScrollSpy</code>观察。</p><p id="7f93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也有一些css使这一切看起来很漂亮，但现在我只想关注这一点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">平滑滚动css</figcaption></figure><p id="0317" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段css只是告诉浏览器让用户有流畅的滚动体验。</p><p id="4f50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解决所有这些问题后，您应该有一个这样的页面:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr nl l"/></div></figure><p id="d160" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您点击菜单选项时，一个新的部分被滚动到视窗的顶部，当您滚动与该部分匹配的菜单选项时，该部分被设置为<code class="fe lk ll lm ln b">active</code>。超级爽！</p><p id="46df" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这只是一个ScrollSpy的简单实现。它有更多的功能，你可以用它做更多的事情！</p><p id="004e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nq">查看所有这些代码一起工作</em> <a class="ae ms" href="https://codesandbox.io/s/reverent-surf-nkzzv?" rel="noopener ugc nofollow" target="_blank"> <em class="nq">检查这个代码沙箱！</em> </a> <em class="nq">或者，您可以</em> <a class="ae ms" href="https://gist.github.com/dcayers/771fa5f0c0d14f31ae4a47d36ee7f376" rel="noopener ugc nofollow" target="_blank"> <em class="nq">查看GitHub </em> </a> <em class="nq">上的要点，查看本文中使用的所有代码和片段。</em></p><h2 id="6c6d" class="my lw in bd lx mz na dn mb nb nc dp mf kx nd ne mh lb nf ng mj lf nh ni ml nj bi translated">ScrollSpy库</h2><p id="2311" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">快速的谷歌搜索会为ScrollSpy图书馆带来一些极好的结果。我想到的几个例子是:</p><ul class=""><li id="93a8" class="ns nt in kq b kr ks ku kv kx nu lb nv lf nw lj nx ny nz oa bi translated"><a class="ae ms" href="https://www.npmjs.com/package/react-scroll" rel="noopener ugc nofollow" target="_blank">反应-滚动</a></li><li id="8d29" class="ns nt in kq b kr ob ku oc kx od lb oe lf of lj nx ny nz oa bi translated"><a class="ae ms" href="https://www.npmjs.com/package/vue2-scrollspy" rel="noopener ugc nofollow" target="_blank"> vue2-scrollspy </a></li><li id="50a2" class="ns nt in kq b kr ob ku oc kx od lb oe lf of lj nx ny nz oa bi translated"><a class="ae ms" href="https://www.npmjs.com/package/@thisissoon/angular-scrollspy" rel="noopener ugc nofollow" target="_blank"> angular-scrollspy </a></li><li id="0908" class="ns nt in kq b kr ob ku oc kx od lb oe lf of lj nx ny nz oa bi translated"><a class="ae ms" href="https://getbootstrap.com/docs/5.0/components/scrollspy/" rel="noopener ugc nofollow" target="_blank">自举Scrollspy </a></li></ul><p id="61ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请浏览一下这些代码，如果您还没有的话，请尝试一下！</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="6290" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，这就是我们要说的。希望我已经帮助你获得了一些知识，你也明白了自己动手做东西的重要性。我个人认为，对于处于各个阶段的开发人员来说，这是一个很好的练习，有助于培养您实现外部库使用的能力，而不仅仅是了解文档告诉您的内容。</p><p id="d19f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢你的阅读，我希望你在下一个项目中好运连连！</p></div></div>    
</body>
</html>