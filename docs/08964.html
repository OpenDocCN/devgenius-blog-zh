<html>
<head>
<title>Terraform — State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地形——状态管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/terraform-state-management-85bc622f731c?source=collection_archive---------3-----------------------#2022-07-21">https://blog.devgenius.io/terraform-state-management-85bc622f731c?source=collection_archive---------3-----------------------#2022-07-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="f1f6" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">地形状态管理深度潜水</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/3210753406f124f04e79f2b51e818ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4O43pR_kDB2U0z1uSM5nw.png"/></div></div></figure><p id="d139" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">正如我们在我的上一篇 Terraform 文章中提到的——“terra form Provider”。当我们成功执行一次<code class="fe lp lq lr ls b">terraform apply</code>并创建所需的基础设施时，Terraform 将记住当前状态，并将其与代码描述的所需状态进行比较。第二次申请时，因为当前状态已经与代码描述的状态一致，所以生成一个空的执行计划。</p><h1 id="f9d4" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">初步查看状态文件</h1><p id="b5fb" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">在这里，Terraform 引入了一个独特的概念——状态管理，这是 Ansible 等配置管理工具或自研工具调用 SDK 来操作基础设施所不具备的。</p><p id="f656" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">简而言之，每次在状态文件中执行基础设施更改操作时，Terraform 都会保存状态信息，默认情况下，状态信息存储在当前工作目录<code class="fe lp lq lr ls b">terraform.tfstate</code>中的文件中。例如，我们在代码中声明了一个资源:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="7e13" class="mu lu ir ls b gz mv mw l mx my">resource "aws_vpc" "vpc" {<br/>  cidr_block = "10.0.0.0/16"<br/>}</span></pre><p id="b52f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我们执行<code class="fe lp lq lr ls b">terraform apply</code>之后，我们可以在<code class="fe lp lq lr ls b">terraform.tfstate</code>文件中看到的是:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="3ac8" class="mu lu ir ls b gz mv mw l mx my">{<br/>  "version": 4,<br/>  "terraform_version": "1.2.5",<br/>  "serial": 1,<br/>  "lineage": "5d18f1c2-882d-4cba-de4c-346484457f89",<br/>  "outputs": {},<br/>  "resources": [<br/>    {<br/>      "mode": "managed",<br/>      "type": "aws_vpc",<br/>      "name": "vpc",<br/>      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",<br/>      "instances": [<br/>        {<br/>          "schema_version": 1,<br/>          "attributes": {<br/>            "arn": "arn:aws:ec2:us-east-1:xxxx:vpc/vpc-00ec463310c0e9b8f",<br/>            "assign_generated_ipv6_cidr_block": false,<br/>            "cidr_block": "10.0.0.0/16",<br/>            "default_network_acl_id": "acl-009d4801fe6843b05",<br/>...<br/>            "ipv6_netmask_length": 0,<br/>            "main_route_table_id": "rtb-0977cbecd8dc3c595",<br/>            "owner_id": "xxxx",<br/>            "tags": null,<br/>            "tags_all": {}<br/>          },<br/>          "sensitive_attributes": [],<br/>          "private": "xxxx"<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="bc10" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们之前说过，由于<code class="fe lp lq lr ls b">tfstate</code>文件的存在，<code class="fe lp lq lr ls b">terraform apply</code>在再次立即应用后不会执行任何更改，那么如果我们删除 tfstate 文件，然后再次执行 apply 会发生什么情况呢？我们试试吧！</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="c2ab" class="mu lu ir ls b gz mv mw l mx my">$ rm terraform.tfstate <br/>$ terraform apply</span><span id="80f9" class="mu lu ir ls b gz mz mw l mx my">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the<br/>following symbols:<br/>  + create<br/>Terraform will perform the following actions:</span><span id="9562" class="mu lu ir ls b gz mz mw l mx my"># aws_vpc.vpc will be created<br/>  + resource "aws_vpc" "vpc" {<br/>      + arn                                  = (known after apply)<br/>      + cidr_block                           = "10.0.0.0/16"<br/>      + default_network_acl_id               = (known after apply)<br/>      + default_route_table_id               = (known after apply)<br/>      + default_security_group_id            = (known after apply)<br/>...<br/>aws_vpc.vpc: Creation complete after 1s [id=vpc-01cc3852f83401b80]</span><span id="2267" class="mu lu ir ls b gz mz mw l mx my">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span></pre><p id="75d0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is"> Terraform 无法读取</strong> <code class="fe lp lq lr ls b"><strong class="ku is">tfstate</strong></code> <strong class="ku is">文件，会认为这是我们第一次创建这组资源，所以会再次创建代码中描述的所有资源！</strong></p><blockquote class="na nb nc"><p id="53af" class="ks kt nd ku b kv kw js kx ky kz jv la ne lc ld le nf lg lh li ng lk ll lm ln ik bi translated"><strong class="ku is">更麻烦的是，由于我们上次创建的资源对应的状态信息被我们删除了，所以我们无法再运行</strong> <code class="fe lp lq lr ls b"><strong class="ku is">terraform destroy</strong></code> <strong class="ku is">通过执行来破坏和回收这些资源，实际上造成了资源泄露。所以妥善保存这个状态文件是非常重要的。</strong></p></blockquote><p id="81da" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，如果我们对 Terraform 代码进行一些修改，生成的执行计划将改变状态，那么在实际执行改变之前，Terraform 将把当前的 tfstate 文件复制到路径<code class="fe lp lq lr ls b">terraform.tfstate.backup</code>以防止意外的 tfstate 损坏。</p><p id="da0f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">有一点需要注意的是，在 Terraform 发展的非常早期，HashiCorp 尝试了一种无状态的文件解决方案，即在执行 Terraform 变更计划时，所有涉及的资源都用特定的标签进行标记，在执行下一次变更时，先读取相关的标签。重构状态信息的资源。但是因为不是所有的资源都支持标签，也不是所有的公有云都支持多标签，所以 Terraform 最终决定使用状态文件方案。</p><h1 id="5b74" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">重要状态警报</h1><p id="7236" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">关于 Terraform state 还有一个更重要的事情，每个考虑在生产环境中使用 Terraform 的人都必须<strong class="ku is">极其小心和警惕:Terraform state 文件是明文的，这意味着代码中使用的所有机密信息都将以明文形式保存在 state 文件中。</strong>例如:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="a412" class="mu lu ir ls b gz mv mw l mx my">esource "ucloud_instance" "normal" {<br/>  availability_zone = "cn-sh2-02"<br/>  image_id          = data.ucloud_images.default.images[0].id<br/>  instance_type     = "n-basic-2"<br/>  root_password     = "supersecret1234"<br/>  name              = "tf-example-normal-instance"<br/>  tag               = "tf-example"<br/>  boot_disk_type    = "cloud_ssd"<br/>  security_group = data.ucloud_security_groups.default.security_groups[0].id<br/>  delete_disks_with_instance = true<br/>}</span></pre><p id="5e76" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在上面的代码中，我们将<code class="fe lp lq lr ls b">root_password</code>设置为<code class="fe lp lq lr ls b">supersecret1234</code>，在执行<code class="fe lp lq lr ls b">terraform apply</code>之后，你会在 tfstate 文件中看到如下信息:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="3aa5" class="mu lu ir ls b gz mv mw l mx my">{<br/>      "mode": "managed",<br/>      "type": "ucloud_instance",<br/>      "name": "normal",<br/>      "provider": "provider[\"registry.terraform.io/ucloud/ucloud\"]",<br/>      "instances": [<br/>        {<br/>          "schema_version": 0,<br/>          "attributes": {<br/>            "allow_stopping_for_update": null,<br/>...<br/>            <strong class="ls is">"root_password": "supersecret1234",</strong><br/>            "security_group": "firewall-a0lqq3r3",<br/>..<br/>          ]<br/>        }<br/>      ]<br/>    }</span></pre><p id="4399" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">可以看到<code class="fe lp lq lr ls b">root_password</code>是以明文形式写在 tfstate 文件中的。这是 Terraform 从设计之初就已经确立的，在可预见的未来也不会改善。无论是用明文硬编码，使用参数(变量，我们将在后面的章节中介绍)，还是用一个函数在运行时异想天开地从外界读取，都无法改变这个结果。</p><p id="10e4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">有两种解决方案，一种是使用 Vault 或 AWS Secret Manager 等动态秘密管理工具生成一个临时有效的动态秘密(比如有效期只有 5 分钟，即使被他人读取，秘密也早已过期)；一个是我下面要介绍的——terra form back end。</p><h1 id="8253" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">Terraform 后端</h1><p id="6ee7" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">到目前为止，我们的 tfstate 文件是保存在当前工作目录中的本地文件。如果我们的电脑损坏，文件丢失，那么 tfstate 文件对应的资源将无法管理，导致资源泄露。</p><p id="9147" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">还有，如果我们是一个使用 Terraform 管理一组资源的团队，团队成员如何共享这个状态文件？是否可以将 tfstate 文件签入源代码管理工具以保存它？</p><p id="10ab" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">将 tfstate 文件签入代码管理工具是非常错误的。这就像将数据库签入源代码管理工具。</p><p id="506b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了解决状态文件的存储和共享问题，Terraform 引入了远程状态存储机制，即 Backend。后端是一个抽象的远程存储接口。与提供商一样，后端也支持各种不同的远程存储服务:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nh"><img src="../Images/4055836d36a8960d19406a4c065a60e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6xAwq9M0iGywc9FnmWWxA.png"/></div></div><figcaption class="ni nj gk gi gj nk nl bd b be z dk translated">图片来自<a class="ae lo" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank">https://www.terraform.io/</a></figcaption></figure><p id="a3ea" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">状态锁意味着当对 tfstate 执行更改操作时，可以向状态文件添加一个全局锁，以确保同一时间只能执行一个更改。不同的后端对状态锁的支持不同，实现状态锁的机制也不同。</p><p id="657c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，s3 后端要求用户传入一个 Dynamodb 表来存储锁信息，而 tfstate 文件存储在 s3 桶中。</p><h1 id="946f" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">AWS S3 后端演示</h1><p id="49f9" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">让我们首先创建一个只包含提供者信息的<code class="fe lp lq lr ls b">backend.tf</code>文件:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="80d2" class="mu lu ir ls b gz mv mw l mx my">terraform {<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "~&gt; 4.18.0"<br/>    }<br/>  }<br/>}</span><span id="dd34" class="mu lu ir ls b gz mz mw l mx my">provider "aws" {<br/>  profile = "metaleap"<br/>  region  = "us-east-1"<br/>}</span></pre><p id="06d6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在我们可以开始关注其他的 tf 文件了；这将包含所有适当的资源，以正确、安全地维护我们在<code class="fe lp lq lr ls b">S3</code>中的 Terraform 状态文件。</p><h2 id="2b46" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">KMS 钥匙</h2><p id="8c5c" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">我们需要创建一个 KMS 密钥来加密状态桶。那么让我们定义下面的<code class="fe lp lq lr ls b">kms.tf</code>:文件:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="274d" class="mu lu ir ls b gz mv mw l mx my">resource "aws_kms_key" "terraform-bucket-key" {<br/> description             = "This key is used to encrypt bucket objects"<br/>}</span><span id="0f80" class="mu lu ir ls b gz mz mw l mx my">resource "aws_kms_alias" "key-alias" {<br/> name          = "alias/terraform-bucket-key"<br/> target_key_id = aws_kms_key.terraform-bucket-key.key_id<br/>}</span></pre><h2 id="df44" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">S3 水桶</h2><p id="e467" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">然后我们需要一个 S3 桶来存储状态文件，让我们继续在一个名为<code class="fe lp lq lr ls b">s3.tf</code>的文件中定义以下内容:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="8a0b" class="mu lu ir ls b gz mv mw l mx my">resource "aws_s3_bucket" "terraform-state-bucket" {<br/>  bucket = "my-terraform-state-backup-folder"<br/>}</span><span id="f5f1" class="mu lu ir ls b gz mz mw l mx my">resource "aws_s3_bucket_acl" "bucket_acl" {<br/>  bucket = aws_s3_bucket.terraform-state-bucket.id<br/>  acl    = "private"<br/>}</span><span id="b45f" class="mu lu ir ls b gz mz mw l mx my">resource "aws_s3_bucket_server_side_encryption_configuration" "encryption-example" {<br/>  bucket = aws_s3_bucket.terraform-state-bucket.bucket</span><span id="4f70" class="mu lu ir ls b gz mz mw l mx my">rule {<br/>    apply_server_side_encryption_by_default {<br/>      kms_master_key_id = aws_kms_key.terraform-bucket-key.arn<br/>      sse_algorithm     = "aws:kms"<br/>    }<br/>  }<br/>}</span><span id="2919" class="mu lu ir ls b gz mz mw l mx my">resource "aws_s3_bucket_versioning" "versioning_example" {<br/>  bucket = aws_s3_bucket.terraform-state-bucket.id<br/>  versioning_configuration {<br/>    status = "Enabled"<br/>  }<br/>}</span><span id="b680" class="mu lu ir ls b gz mz mw l mx my">resource "aws_s3_bucket_public_access_block" "block" {<br/>  bucket = aws_s3_bucket.terraform-state-bucket.id</span><span id="44ac" class="mu lu ir ls b gz mz mw l mx my">block_public_acls       = true<br/>  block_public_policy     = true<br/>  ignore_public_acls      = true<br/>  restrict_public_buckets = true<br/>}</span></pre><h2 id="a2c7" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">DynamoDB 表</h2><p id="2be0" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">为了防止两个团队成员同时写入状态文件，我们将实现一个 DynamoDB 表锁，创建一个<code class="fe lp lq lr ls b">dynamodb.tf:</code></p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="7593" class="mu lu ir ls b gz mv mw l mx my">resource "aws_dynamodb_table" "terraform-state" {<br/> name           = "terraform-state"<br/> read_capacity  = 20<br/> write_capacity = 20<br/> hash_key       = "LockID"<br/><br/> attribute {<br/>   name = "LockID"<br/>   type = "S"<br/> }<br/>}</span></pre><h2 id="4faa" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">状态文件版本</h2><p id="c4ce" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">最后一步是在同一个目录下创建一个名为<code class="fe lp lq lr ls b">.terraform-version</code>的文件，在第一行写上<code class="fe lp lq lr ls b">1.0.0</code>，就这样。<code class="fe lp lq lr ls b">tfenv</code>现在将获取该版本，并确保在运行任何 Terraform 命令之前安装该版本。</p><h2 id="1632" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">执行</h2><p id="5401" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">此时，文件夹结构如下所示:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="3a9b" class="mu lu ir ls b gz mv mw l mx my">.<br/>├── backend.tf<br/>├── dynamodb.tf<br/>├── kms.tf<br/>├── main.tf<br/>├── s3.tf</span></pre><p id="21d2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们还没有在<code class="fe lp lq lr ls b">backend.tf</code>中配置任何后端，我们稍后会做。我们来做一个<code class="fe lp lq lr ls b">terraform init</code>:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="fcce" class="mu lu ir ls b gz mv mw l mx my">$ terraform init</span><span id="79cb" class="mu lu ir ls b gz mz mw l mx my">Initializing the backend...</span><span id="6bef" class="mu lu ir ls b gz mz mw l mx my">Initializing provider plugins...<br/>- Reusing previous version of hashicorp/aws from the dependency lock file<br/>- Using previously-installed hashicorp/aws v4.18.0</span></pre><p id="1d4e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后用<code class="fe lp lq lr ls b">terraform apply</code>应用更改:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="a733" class="mu lu ir ls b gz mv mw l mx my">$ terraform apply<br/>...<br/>aws_kms_key.terraform-bucket-key: Creating...<br/>aws_vpc.vpc: Creating...<br/>aws_dynamodb_table.terraform-state: Creating...<br/>aws_s3_bucket.terraform-state-bucket: Creating...<br/>aws_s3_bucket.terraform-state-bucket: Creation complete after 0s ...</span><span id="a9e5" class="mu lu ir ls b gz mz mw l mx my">Apply complete! Resources: 9 added, 0 changed, 0 destroyed.</span></pre><p id="baf3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">到目前为止，一切顺利。我们已经创建了在 AWS S3 存储桶中安全存储 Terraform 状态文件所需的所有必要的底层资源。您将会看到状态文件当前作为<code class="fe lp lq lr ls b">terraform.tfstate</code>存储在本地。</p><h2 id="ccb1" class="mu lu ir bd lv nm nn dn lz no np dp md lb nq nr mf lf ns nt mh lj nu nv mj nw bi translated">配置后端</h2><p id="b56b" class="pw-post-body-paragraph ks kt ir ku b kv ml js kx ky mm jv la lb mn ld le lf mo lh li lj mp ll lm ln ik bi translated">我们必须向我们的<code class="fe lp lq lr ls b">backend.tf</code>文件再添加一个资源，重新运行<code class="fe lp lq lr ls b">terraform init</code>，因此将<code class="fe lp lq lr ls b">backend.tf</code>文件更新为:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="951f" class="mu lu ir ls b gz mv mw l mx my">terraform {<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "~&gt; 4.18.0"<br/>    }<br/>  }<br/>  required_version = "&gt;= 1.0"<br/>  backend "s3" {<br/>    profile        = "metaleap"<br/>    region         = "us-east-1"<br/>    key            = "state/terraform.tfstate"<br/>    encrypt        = true<br/>    bucket         = "my-terraform-state-backup-folder"<br/>    kms_key_id     = "alias/terraform-bucket-key"<br/>    dynamodb_table = "terraform-state"<br/>  }<br/>}</span><span id="41ae" class="mu lu ir ls b gz mz mw l mx my">provider "aws" {<br/>  profile = "metaleap"<br/>  region  = "us-east-1"<br/>}</span></pre><p id="8957" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们初始化后端:</p><pre class="kh ki kj kk gu mq ls mr ms aw mt bi"><span id="ffd7" class="mu lu ir ls b gz mv mw l mx my">$ terraform init</span><span id="2e53" class="mu lu ir ls b gz mz mw l mx my">Initializing the backend...<br/>Do you want to copy existing state to the new backend?<br/>  ...</span><span id="c23f" class="mu lu ir ls b gz mz mw l mx my">Enter a value: yes</span><span id="d78c" class="mu lu ir ls b gz mz mw l mx my">Successfully configured the backend "s3"! Terraform will automatically<br/>use this backend unless the backend configuration changes.</span><span id="fbc5" class="mu lu ir ls b gz mz mw l mx my">Initializing provider plugins...<br/>- Reusing previous version of hashicorp/aws from the dependency lock file<br/>- Using previously-installed hashicorp/aws v4.18.0</span><span id="03b0" class="mu lu ir ls b gz mz mw l mx my">Terraform has been successfully initialized!</span><span id="d94b" class="mu lu ir ls b gz mz mw l mx my">...</span></pre><p id="13e3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在您应该能够看到一个<code class="fe lp lq lr ls b">terraform.tfstate</code>文件被上传到 s3 bucket:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nx"><img src="../Images/69e98c20c76f116b02892b81c232290b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyUgzjvLVGibfBQLqnsd4A.png"/></div></div></figure><p id="04c6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">恭喜你，现在一切正常。现在，您已经在 AWS 中创建了一组功能齐全的资源，来管理带有 DynamoDB 锁保护的安全 S3 存储桶中的状态文件。</p><p id="7f74" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你做了任何代码更改并重新运行<code class="fe lp lq lr ls b">terraform apply</code>命令，一个新版本的<code class="fe lp lq lr ls b">terraform.tfstate</code>文件将在 S3 桶中被创建。例如，我对<code class="fe lp lq lr ls b">main.tf</code>做了一些更新，在<code class="fe lp lq lr ls b">terraform apply</code>重新运行后，我可以看到<code class="fe lp lq lr ls b">terraform.tfstate</code>文件有两个版本:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ny"><img src="../Images/cbfc28b0de6dc0ad03d45cf5d09bd27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMW9NSrW0t5zDDh4e8toUg.png"/></div></div></figure></div></div>    
</body>
</html>