<html>
<head>
<title>The Essential Concepts of High Speed Distributed Database — Cassandra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高速分布式数据库的基本概念— Cassandra</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-essential-concepts-of-high-speed-distributed-database-cassandra-b87267d5f83e?source=collection_archive---------4-----------------------#2022-04-10">https://blog.devgenius.io/the-essential-concepts-of-high-speed-distributed-database-cassandra-b87267d5f83e?source=collection_archive---------4-----------------------#2022-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Cassandra 分区键、簇键、查询设计实用指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc7f41767b1cae7fb755c3e4b720103a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bz-NADbwB1kqcBkI"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">SpaceX 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae kv" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="3223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速响应对成功的在线业务至关重要。如果你的网站超过 1 秒钟才做出回应，你的在线业务可能会受到影响，因为大多数潜在客户没有耐心，只是简单地转向其他网站。尽管有快速的 CPU 和强大的基础设施，系统 I/O(如数据库访问)仍然是大多数系统进程的瓶颈。然而，系统 I/O 是不可避免的，因为大多数业务功能都涉及数据检索和更新。</p><p id="6769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管大多数现代关系数据库都针对性能进行了优化，但要满足不断增长的性能需求仍是一个挑战。如果数据库的性能仍然困扰着您，并且在微调后不能满足需求，那么您的关系数据库可能已经达到了极限。因此，您最好考虑替代选项，例如为高性能而构建的 NoSQL 数据库类型。</p><p id="0f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cassandra 数据库以其卓越的性能而闻名。传统数据库在毫秒内响应数据查询，而 Cassandra 数据库可以达到微秒级的性能，它大约快 10 倍甚至 100 倍。因此，许多科技公司采用 Cassandra 来实现他们的高性能系统。</p><p id="7d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，如果你不完全理解它的用法，一个强大的工具是完全无用的。同样，如果你把 Cassandra 当作一个关系数据库来使用，你的系统不会加快速度，只会有缺点。如果您是 Cassandra 的新手，并且想快速了解一下，您会发现这篇文章很有用，因为它为您提供了从创建表到数据查询的一步步的 Cassandra 实践。您将了解 Cassandra 数据库的数据分区和表设计的概念。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="062e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是 Cassandra 数据库？</h1><p id="ef45" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">十多年前，Cassandra 最初是在脸书为其收件箱搜索功能而建立的。然后它在 2008 年被开源。Cassandra 的基本设计是一个分布式数据库，它将数据表分割成多个分区，并分布在多个节点上。传统数据库主要依靠主节点来处理查询，而 Cassandra 的设计是无主的，允许多个节点并行处理大量查询。这也意味着可以通过向群集中添加节点来实现纵向扩展。</p><p id="72e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们看一个表模式时，它非常类似于关系数据库的表定义。例如，这是电子商务<strong class="ky ir">订单</strong>表的模式:</p><p id="0f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模式语法在很大程度上与列名列表和带有主键的相应数据类型相同</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="44c7" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE IF NOT EXISTS demo.orders (<br/>  customer_id int,<br/>  order_ref text,<br/>  status text,<br/>  total_amount double,<br/>  delivery_date date,<br/>  delivery_timeslot time,<br/>  delivery_address text,<br/>  PRIMARY KEY (customer_id, order_ref)<br/>);</span></pre><p id="9f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">卡珊德拉的查询被称为卡珊德拉查询语言(CQL)。事实上，语法看起来像传统的 SQL。以下是检索订单记录列表的查询:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="47da" class="nb ma iq mx b gy nc nd l ne nf">SELECT customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address FROM orders;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/92232954b76b2c23de024d9bb216ef83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJFzK3bcF3wpab-w7eMvbQ.png"/></div></div></figure><p id="f759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询语法的设计有助于那些熟悉关系数据库的人掌握 Cassandra 的知识。虽然 CQL 类似于 SQL，但 Cassandra 上的查询是基于不同的概念。请记住，记录存储在分布式节点中。这是一种折衷，实现高性能意味着某些查询不应该得到支持。例如，Cassandra 不支持任何需要数据节点间协调的查询，比如连接表。</p><p id="7646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据分布的处理对开发人员来说并不完全透明，Cassandra 允许应用程序开发人员通过表主键定义来控制设置。让我们在接下来的几节中研究一下细节。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4869" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">开始你的第一个卡珊德拉节点</h1><p id="1972" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们从头开始，在您的本地机器上启动您的 Cassandra 节点并进行探索。与其经历复杂的安装步骤，不如在 docker 容器上运行实例。</p><p id="5513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要您的 PC 上安装了 docker，就可以运行以下命令来启动 Cassandra 节点:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="15fd" class="nb ma iq mx b gy nc nd l ne nf">docker run -d --name cassandra -p 9042:9042 cassandra:latest</span></pre><p id="3e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令获取最新 Cassandra 的 docker 图像。截至本文撰写之时，Cassandra 的最新版本是 v 4 . 0 . 3。Docker 公开了端口 9042，以便您可以连接到它来执行查询。</p><p id="78c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cassandra 为您提供了一个名为<strong class="ky ir"> cqlsh </strong>的工具来运行查询。运行这个命令，您将在 Cassandra 容器上启动一个 CQLSH 命令会话:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="500a" class="nb ma iq mx b gy nc nd l ne nf">docker exec -it cassandra cqlsh localhost 9042 --cqlversion='3.4.5'</span></pre><p id="25ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经成功连接到 docker 容器，您将会看到 CQLSH 的这个命令提示符。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b104" class="nb ma iq mx b gy nc nd l ne nf">Connected to Test Cluster at localhost:9042<br/>[cqlsh 6.0.0 | Cassandra 4.0.3 | CQL spec 3.4.5 |Native protocol v5]<br/>Use HELP for help.<br/>cqlsh&gt;</span></pre><p id="90c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行查询<strong class="ky ir"> describe keyspaces </strong>来验证您的 Cassandra 节点是否正在响应您的命令:</p><p id="f440" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该查询将显示 Cassandra 节点上的键空间列表:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="40f6" class="nb ma iq mx b gy nc nd l ne nf">cqlsh&gt; describe keyspaces</span><span id="19fd" class="nb ma iq mx b gy nh nd l ne nf">system       system_distributed  system_traces  system_virtual_schema system_auth  system_schema       system_views</span></pre><p id="97a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！你已经启动并运行了卡珊德拉节点。接下来，让我们探索数据库和表的创建。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eb34" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">keyspace 是数据库吗？</h1><p id="59a6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在关系数据库的世界中，数据库是一个保存大量数据表的容器。但是，在 Cassandra 中没有什么叫做数据库的东西。相反，Cassandra 中的<strong class="ky ir">键空间</strong>类似于关系世界中的数据库。</p><p id="5954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要定义密钥空间，在 CQLSH 上运行以下语句来创建一个名为<strong class="ky ir"> demo </strong>的密钥空间:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="ac41" class="nb ma iq mx b gy nc nd l ne nf">CREATE KEYSPACE IF NOT EXISTS demo<br/>WITH REPLICATION = {'class':'SimpleStrategy','replication_factor':'1'};</span></pre><p id="9a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Keyspace 不仅充当名称空间，还定义数据复制策略。上面的例子使用了带有 1 个复制因子的简单策略，这意味着在键空间中没有数据复制。在生产环境中，<strong class="ky ir">网络拓扑策略</strong>应用于数据中心的复制。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="001a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建表格</h1><p id="da82" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">创建了键空间之后，数据表的创建就简单了。在 CQLSH 上运行这个表创建语句，在 keyspace <strong class="ky ir">演示:</strong>下创建<strong class="ky ir">订单</strong>表</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="edd3" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE IF NOT EXISTS demo.orders (<br/>  customer_id int,<br/>  order_ref text,<br/>  status text,<br/>  total_amount double,<br/>  delivery_date date,<br/>  delivery_timeslot time,<br/>  delivery_address text,<br/>  PRIMARY KEY (customer_id, order_ref)<br/>);</span></pre><p id="8842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cassandra 支持最常见的数据类型，如字符串、整数、双精度、日期和时间。详见<a class="ae kv" href="https://cassandra.apache.org/doc/latest/cassandra/cql/types.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><p id="7032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，使用下面的 insert 语句插入一些示例数据。语法也类似于 SQL。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="24a3" class="nb ma iq mx b gy nc nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(3, 'PW9QBN4S', 'DISPATCHED', 232.00, '2022-02-25', '14:00:00', '203 Johns Harbor, New York');</span><span id="fa33" class="nb ma iq mx b gy nh nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(2, 'RFGBIIHM', 'DISPATCHED', 478.00, '2022-02-10', '09:00:00', '655 Gorczany Plain, Everett');</span><span id="7a1d" class="nb ma iq mx b gy nh nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(2, 'K8V8E0IM', 'SUBMITTED', 203.00, '2022-02-10', '14:00:00', '4329 Grayce Station, Frisco');</span><span id="d48c" class="nb ma iq mx b gy nh nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(1, '75TPT70S', 'DISPATCHED', 246.00, '2022-02-25', '12:00:00', '246 Alessandro Stream, Mount Prospect');</span><span id="6307" class="nb ma iq mx b gy nh nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(1, 'YQPZ6M4V', 'SUBMITTED', 465.00, '2022-02-25', '14:00:00', '309 Reichert Common, Biloxi');</span><span id="076b" class="nb ma iq mx b gy nh nd l ne nf">INSERT INTO demo.orders (customer_id, order_ref, status, total_amount, delivery_date, delivery_timeslot, delivery_address) VALUES<br/>(1, 'CGT97K4Q', 'DISPATCHED', 276.00, '2022-02-10', '09:00:00', '32711 Heaven Mills, Rancho Cucamonga');</span></pre><p id="d0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用下面的 SELECT 语句检查 orders 表上新插入的数据:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0b75" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders;</span></pre><p id="40a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询结果显示订单记录列表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/9f57dff0f0d7afbf4439e3bf0fc98b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVL5D9FIzX5SmxfJ-BRhaw.png"/></div></div></figure><p id="df61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您已经在 Cassandra 节点上创建了样本表。接下来，让我们看看表主键。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3661" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">分区键—确定数据分区</h1><p id="4df0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Cassandra 中的主键显然与关系世界中的主键相同。orders 表中的记录可以由一个组合主键<strong class="ky ir"> customer_id </strong>和<strong class="ky ir"> order_ref </strong>唯一标识</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="ad97" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE customer_id = 1 AND order_ref = ‘75TPT70S’;</span></pre><p id="fbd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的查询通过唯一键检索单个记录:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/0ad2c738a4ff1519fc8251f8f41482ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMqBvIRgPmidxyreNhlkKQ.png"/></div></div></figure><p id="e43f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试按客户 id 进行查询，结果中有 3 条记录。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="aac1" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE customer_id = 1;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/b0d9b1f66f8f0a51f7a39b7ef516a157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrj1668SDtAnKCFjt7PQig.png"/></div></div></figure><p id="40d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按<strong class="ky ir"> order_ref </strong>列查询怎么样？</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6334" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE  order_ref = ‘75TPT70S’;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/1e09156eb8a67df7145cf5d9337b27cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rhojq5fGdTYPK1TECNELUQ.png"/></div></div></figure><p id="a07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哎呀，Cassandra 不允许通过订单参考进行查询。为什么？</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="72bb" class="nb ma iq mx b gy nc nd l ne nf">InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"</span></pre><p id="c58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关系世界中合法的查询语句并不意味着它在 Cassandra 中是允许的。Cassandra 中的查询要求 WHERE 子句中存在所有分区键。</p><p id="972c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分区键是 Cassandra 表模式中的一个关键元素。Cassandra 通过分区键分割表行，分区是分开存储的。orders 表中有 3 个不同的客户 id，表记录存储在 3 个独立的分区中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1f4960659a63bfdf41cd0d00e9233503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*stulS3d4bx9tYEH274u93Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Cassandra 数据分区</figcaption></figure><p id="45f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果 Cassandra 集群由多个节点组成，则分区可以存储在单独的节点上。当执行一个查询时，Cassandra 将首先根据 WHERE 子句中的分区键识别维护目标分区的节点。然后，查询被发送到节点进行处理。</p><p id="b1c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分区键的设计使得基于不同分区键的查询能够并行执行，因为查询由多个节点同时处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ad24f999cd36a888988ddb4be8487968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*DzSznCs9D7ZIH3DxsuffsQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡珊德拉查询</figcaption></figure><p id="fd0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果 Cassandra 收到一个没有指定分区键的查询会发生什么？正如我们在上面通过<strong class="ky ir"> order_ref </strong>字段进行的查询实验一样，它失败了，因为 Cassandra 不知道应该对哪个分区执行查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ef1ec013f0b8c190299df94d72f4f446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*ZWUnGI8o8QXExiq2CuzWNg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由于缺少分区键，查询失败</figcaption></figure><p id="b9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，错误消息建议在查询语句中使用<strong class="ky ir"> ALLOW FILTERING </strong>。它实际上是指示 Cassandra 在每个分区上运行查询。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0cd4" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE  order_ref = ‘75TPT70S’ <br/><strong class="mx ir">ALLOW FILTERING</strong>;</span></pre><p id="6c02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询现在得到了结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/42d7dcb46fd7aacd714785194384b5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXy_LSv-NWq1tscjV02nbw.png"/></div></div></figure><p id="422e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<strong class="ky ir">允许过滤</strong>通常不是一个好主意。扫描所有分区是一个开销很大的过程，如果数据表包含许多带有大量记录行的分区，这将花费很长时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1361216707ad91cc956feed9ea75573a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*S6XEe0G1xFZuEKwrQLfuPA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">允许过滤的查询</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a417" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">多节点集群上的分区分布</h1><h2 id="b960" class="nb ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated"><strong class="ak">设置多节点 Cassandra 集群</strong></h2><p id="38b5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了查看分区键的细节，现在应该运行一个具有多个节点的 Cassandra 集群。同样，在 docker 容器上运行集群是一种轻松加速集群的简单方法。首先，使用以下命令终止现有的 Cassandra docker 容器:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c698" class="nb ma iq mx b gy nc nd l ne nf">docker container rm -f cassandra</span></pre><p id="3880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将这个 docker 撰写定义保存到本地机器上的<strong class="ky ir"><em class="oc">docker-compose . yml</em></strong>中。请注意，您的本地计算机应该至少有 4 GB 的可用内存来运行集群。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fd7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将目录更改为 docker-compose.yml 的文件夹路径，并运行以下命令:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="fc61" class="nb ma iq mx b gy nc nd l ne nf">docker compose up</span></pre><p id="6aa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">docker compose 启动一个由 3 个 Cassandra 节点组成的集群。3 个节点的容器名分别是<strong class="ky ir"> cassandra-1 </strong>、<strong class="ky ir"> cassandra-2 </strong>和<strong class="ky ir"> cassandra-3 </strong>。</p><p id="d61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该容器不在卷上保存任何数据，因此以前的所有表数据都消失了，每次启动时都是一个全新的集群。</p><p id="209f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令连接到<strong class="ky ir"> cassandra-1 </strong>上的命令外壳:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="fd5e" class="nb ma iq mx b gy nc nd l ne nf">docker exec -it cassandra-1 /bin/bash</span></pre><p id="13b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，使用 Cassandra 为管理任务提供的<strong class="ky ir">节点工具</strong>查看集群状态:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="59da" class="nb ma iq mx b gy nc nd l ne nf">nodetool status</span></pre><p id="ef04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果集群启动并成功运行，那么输出应该有 3 个节点:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="2b32" class="nb ma iq mx b gy nc nd l ne nf">root@2c98f5e6a3c1:/# nodetool status</span><span id="65ce" class="nb ma iq mx b gy nh nd l ne nf">Datacenter: datacenter1<br/>=======================<br/>Status=Up/Down<br/>|/ State=Normal/Leaving/Joining/Moving<br/>--  Address     Load       Tokens  Owns (effective)  Host ID                               Rack<br/>UN  <strong class="mx ir">172.19.0.2</strong>  69.05 KiB  16      64.7%             34a4bbf7-0fa0-43f9-98c6-3156fc5269f0  rack1</span><span id="a796" class="nb ma iq mx b gy nh nd l ne nf">UN  <strong class="mx ir">172.19.0.4</strong>  69.04 KiB  16      59.3%             839ac44f-f3a6-4bb8-bc04-5592d1b2af76  rack1</span><span id="2cec" class="nb ma iq mx b gy nh nd l ne nf">UN  <strong class="mx ir">172.19.0.3</strong>  69.04 KiB  16      76.0%             82977a1d-1850-4186-bc7a-0d13b9da2120  rack1</span></pre><h2 id="e042" class="nb ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated"><strong class="ak">如何定位集群中的分区？</strong></h2><p id="591a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">再次运行前面的所有步骤，在新启动的 Cassandra 集群上创建 keyspace、table 并插入样本订单记录。</p><p id="97a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您已经将分区数据分发到了 Cassandra 节点。为了定位客户 id = 1 的分区，<strong class="ky ir"> nodetool </strong>命令告诉您节点的 IP 地址。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="2756" class="nb ma iq mx b gy nc nd l ne nf">root@2c98f5e6a3c1:/# nodetool getendpoints demo orders 1</span><span id="1e6b" class="nb ma iq mx b gy nh nd l ne nf">172.19.0.4</span></pre><p id="0ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，客户 id = 3 的分区数据在另一个节点上</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f745" class="nb ma iq mx b gy nc nd l ne nf">root@2c98f5e6a3c1:/# nodetool getendpoints demo orders 3</span><span id="643e" class="nb ma iq mx b gy nh nd l ne nf">172.19.0.2</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ab39" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">群集键—分区内的唯一标识符</h1><p id="6646" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们再次查看 orders 表定义时，您可能想知道为什么<strong class="ky ir"> order_ref </strong>列在主键下，但它不是分区键。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="82e1" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE IF NOT EXISTS demo.orders (<br/>  customer_id int,<br/>  order_ref text,<br/>  …<br/>  …<br/>  PRIMARY KEY (customer_id, <strong class="mx ir">order_ref</strong>)<br/>);</span></pre><p id="e0c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是另一种类型的主键，称为<strong class="ky ir">群集键</strong>。它唯一地标识一个分区中的一条记录，并定义排序顺序。</p><p id="427a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分区键+簇键形成记录的唯一标识符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/4021542e079a29be69de104d2035888d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sgZkThM7LxIiU_6KlvIkA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用分区键+簇键的查询</figcaption></figure><p id="e431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，下面的查询返回一个具有 customer_id + order_ref 的唯一记录:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1fdf" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE customer_id = 1 AND order_ref = 'CGT97K4Q';</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/e3a9bd29bc7cd8ec1b2861baf21c532b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJ55kuNDUin1W_7GWNuYcw.png"/></div></div></figure><p id="881d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">簇键还定义了分区中记录的自然顺序。如果我们指定记录按<strong class="ky ir"> order_ref </strong>列使用<strong class="ky ir">按降序排序，聚类顺序按</strong>排序，那么查询结果默认为预定义的顺序。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f79b" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE IF NOT EXISTS demo.orders (<br/>  customer_id int,<br/>  order_ref text,<br/>  …<br/>  …<br/>  PRIMARY KEY (customer_id, <strong class="mx ir">order_ref</strong>)<br/>)<br/><strong class="mx ir">WITH CLUSTERING ORDER BY (order_ref DESC);</strong></span></pre><p id="905c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下查询显示记录按<strong class="ky ir"> order_ref </strong>降序排序:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="778a" class="nb ma iq mx b gy nc nd l ne nf">SELECT customer_id, order_ref FROM orders WHERE customer_id = 1;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/73b68c169222128fa16b85108280c805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*jUxtTOm3NRVB9HOymNwcdg.png"/></div></figure><p id="6256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以改变群集键的顺序。例如，下面的查询显示了按 order_ref 升序排序的结果，而不是默认排序。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="aada" class="nb ma iq mx b gy nc nd l ne nf">SELECT customer_id, order_ref FROM orders WHERE customer_id = 1 <strong class="mx ir">ORDER BY order_ref ASC</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/ded879619862864a571c197a6b860fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaQyZLylSQqTV1cA-YhIag.png"/></div></div></figure><p id="d5f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，Cassandra 不允许您按不是集群键的列进行排序。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="ab43" class="nb ma iq mx b gy nc nd l ne nf">SELECT customer_id, order_ref FROM orders WHERE customer_id = 1 <strong class="mx ir">ORDER BY status ASC</strong></span><span id="4daa" class="nb ma iq mx b gy nh nd l ne nf">InvalidRequest: Error from server: code=2200 [Invalid query] message="Order by is currently only supported on the clustered columns of the PRIMARY KEY, got status"</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1495" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">复合键</h1><p id="b781" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">用组合键定义表在关系世界中很常见。同样的道理也适用于卡珊德拉。主键语法支持多个分区键和簇键:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0342" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE &lt;table name&gt; (<br/>  …<br/>  …<br/>  <strong class="mx ir">PRIMARY KEY ((&lt;partition key 1&gt;,&lt;partition key 2&gt;...), <br/>               &lt;cluster key 1&gt;, &lt;cluster key 2&gt;, …)<br/></strong>);</span></pre><p id="52ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该示例将<strong class="ky ir">customer _ id</strong>+<strong class="ky ir">delivery _ date</strong>设置为分区键，集群键为<strong class="ky ir"> order_ref </strong>和<strong class="ky ir"> status </strong>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8b0d" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE IF NOT EXISTS demo.orders (<br/>  customer_id int,<br/>  order_ref text,<br/>  …<br/>  …<br/><strong class="mx ir">  PRIMARY KEY ((customer_id, delivery_date), order_ref, status)</strong><br/>);</span></pre><p id="bfff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了复合分区键，现在您需要在 WHERE 子句中包含客户 id 和交付日期，以便进行数据查询。有趣的是，由于具有相同客户 id 的记录具有不同的交付日期，复合分区键导致创建更多的分区。</p><p id="21dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，开发人员可以通过定义分区键来控制数据表的分区大小。在性能调优方面，控制分区大小的能力至关重要。什么样的分区大小可以实现最佳性能？没有放之四海而皆准的答案，它取决于您的应用程序查询模式和负载测试结果。请注意，分区的硬限制是 20 亿个单元，因此如果数据量急剧增长，您最好重新组织分区。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/c9c08a675380ac991c468c3a0acea130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p443zeFsS5v3RHW1PazL6g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有复合分区键的数据分区</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="57e1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何支持非分区键查询？</h1><p id="ae4c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">除了客户之外，交付团队还需要根据交付日期获得订单列表，以便进行物流安排。假设交付日期不是分区键的一部分，我们如何按特定的交付日期运行查询呢？</p><p id="1d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案选项包括:</p><ul class=""><li id="b7c1" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">辅助索引</li><li id="0c87" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">在交货日期用分区键分隔一个表</li></ul><h2 id="3331" class="nb ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated">辅助索引</h2><p id="c3df" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面的语句在交付日期创建一个辅助索引。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3dda" class="nb ma iq mx b gy nc nd l ne nf">CREATE INDEX demo.orders_by_delivery_date ON demo.orders (delivery_date);</span></pre><p id="589a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建辅助索引后，不管分区键是什么，按传递日期查询都会得到一个记录列表。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="33e7" class="nb ma iq mx b gy nc nd l ne nf">SELECT * FROM demo.orders WHERE delivery_date = ‘2022-02-10’;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/31a6011ceb5e3f8f41fe5fa0ecd9b993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCnGuF2M4udwXPxSM8w8FQ.png"/></div></div></figure><p id="7e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，应该谨慎使用二级索引，二级索引的不当使用可能会对集群的性能产生不利影响。详情请参考<a class="ae kv" href="https://docs.datastax.com/en/cql-oss/3.3/cql/cql_using/useWhenIndex.html" rel="noopener ugc nofollow" target="_blank">何时不使用步进</a>。</p><h2 id="f9c5" class="nb ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated">维护一个单独的表</h2><p id="61c5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">传统关系数据库的数据建模从实体设计开始，然后是规范化，而 Cassandra 的数据模型设计是基于查询的。为了实现高性能，冗余在 NoSQL 世界并不是一个问题。</p><p id="a6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案是维护两个单独的订单记录表，即<strong class="ky ir"> orders_by_customer </strong>和<strong class="ky ir"> orders_by_delivery_date </strong>，分别为客户 id 和交付日期分配分区键。因此，交付团队在<strong class="ky ir"> orders_by_delivery_date </strong>上运行查询，而客户在<strong class="ky ir"> orders_by_customer_id 上检查他们的订单。</strong></p><p id="58c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缺点是每当有新的订单提交或更新时，都要在两个数据表上插入记录。应用程序逻辑负责确保原子性，因为 Cassandra 没有事务会话或表锁定。</p><p id="e252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关数据建模的更多信息，请参考<a class="ae kv" href="https://cassandra.apache.org/doc/latest/cassandra/data_modeling/index.html" rel="noopener ugc nofollow" target="_blank">官方网站</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/f7a70acbe75b64eba0ff18ee9ca01849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*E224jEVNJV9gH3pq9lO_vQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">为不同的查询维护单独的表</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cfa8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的想法</h1><p id="d28a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Cassandra 是一个强大的数据库，它提供了跨多个节点的高性能数据。分区键和簇键的设计提供了一种灵活的方法来控制数据的分区和分布。虽然 Cassandra 查询语言(CQL)类似于 SQL 的语法，但 Cassandra 肯定不是关系数据库。它是为高速运行查询而设计的，假设集群中的所有节点都独立处理请求。实现高性能意味着不能支持某些特性，例如表连接和通过任意数据字段的查询。</p><p id="4d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你来自关系世界，那么关键是首先忘记规范化和关系模型设计的概念。接受查询优先设计的概念，基于查询开始模型设计，并拥有基于查询的数据模型。</p></div></div>    
</body>
</html>