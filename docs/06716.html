<html>
<head>
<title>Introducing hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的提升简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introducing-hoisting-in-javascript-922faf4b37c9?source=collection_archive---------8-----------------------#2022-01-27">https://blog.devgenius.io/introducing-hoisting-in-javascript-922faf4b37c9?source=collection_archive---------8-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bdd3522e5d4721a892ee6494fe208011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isdUoWPG4VvOvydRkK28CQ.jpeg"/></div></div></figure><p id="85a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">介绍吊装</strong></p><p id="875a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们在英语中使用“提升”这个词时，我们描述的是举起或拉起某物的动作。我们可以说一面旗帜被悬挂在建筑物上，或者一辆汽车被吊出了河。</p><p id="4c6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript 中的提升描述了在代码执行之前，变量和函数声明(名称)何时被提升或提升到其局部范围的顶部。实际上没有代码被移动，但这是 JavaScript 编译器读取代码的方式。让我们先看一个基本的例子。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="374a" class="lf lg iq lb b gy lh li l lj lk">console.log(myDog);<br/>var myDog = "Muffin";</span><span id="4047" class="lf lg iq lb b gy ll li l lj lk">//Returns ---&gt; undefined</span></pre><p id="7a7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们首先使用控制台日志来记录我们还没有创建的变量。接下来，我们声明这个名为<em class="lm"> myDog </em>的变量，并将字符串<em class="lm"> Muffin </em>赋值。当代码执行(运行)时，返回<em class="lm">未定义的</em>。</p><p id="8110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提升是我们在运行这段代码时没有得到错误的原因。JavaScript 解释器将变量创建的声明(var myDog)和赋值(= "Muffin)阶段分开。在代码执行之前，声明部分被提升到当前作用域的顶部，并被初始赋值为<em class="lm"> undefined </em>。这意味着<em class="lm"> myDog </em>变量可以在初始化之前使用。</p><h2 id="1b3e" class="lf lg iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">let 和 const 呢？</h2><p id="98bf" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们已经看了一个用<em class="lm"> var </em>声明变量的例子，现在我们来看看用<em class="lm"> let </em>或<em class="lm"> const </em>声明变量会发生什么。当你用<em class="lm"> let </em>或<em class="lm"> const </em>声明一个变量时，变量实际上仍然是被提升的。然而，不同之处在于，当我们使用<em class="lm"> var </em>时，声明最初被赋值为 undefined，直到我们定义的赋值所在的行出现。此时，变量被赋予我们所赋予的值。</p><p id="8618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<em class="lm">让</em>变量最初不赋值。如果我们使用 let 重复上面的例子，我们可以看到一个这样的例子。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a759" class="lf lg iq lb b gy lh li l lj lk">console.log(myDog);<br/>let myDog = "Muffin";</span><span id="d72f" class="lf lg iq lb b gy ll li l lj lk">//Returns ---&gt; Uncaught ReferenceError: myDog is not defined<br/>    at &lt;anonymous&gt;:1:13</span></pre><p id="89e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们控制台记录了<em class="lm"> myDog </em>变量，然后我们声明并给这个变量赋值 string <em class="lm"> Muffin </em>。</p><p id="6e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次，当代码运行时，声明(let myDog)被编译器提升到作用域的顶部，但是变量最初是未初始化的，这与 var 不同，var 最初是用 undefined 初始化的。当代码执行(运行)时，控制台日志发生在我们给变量赋值之前，所以我们得到上面的引用错误。用 const 声明变量也是同样的方式。</p><p id="330d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种情况背后的原因被称为<em class="lm">时间死区</em>。<em class="lm">暂时死区</em>描述了变量不能使用的暂时不活动状态。</p><p id="4a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为 JavaScript 在执行代码之前会编译代码。如果你在超市收银台，你处于一种中间状态，在你整理好所有的杂货后，你可能会在家里准备好空间。但是，你还没有拥有它们，所以在你完成超市的结账阶段之前，你不能实际使用它们。让我们以一些最后的例子来结束。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a9bb06003933ec2752482e646b963dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYFB-6fUH0VFsD76uEA-rg.jpeg"/></div></div></figure><p id="2122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢这篇文章，请随时发表任何意见，问题或反馈，并关注我的更多内容！</p></div></div>    
</body>
</html>