<html>
<head>
<title>What Is Generator in Python and How Does It Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的 Generator 是什么，它是如何工作的？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-generator-in-python-and-how-does-it-work-e6e0588785c3?source=collection_archive---------1-----------------------#2022-04-26">https://blog.devgenius.io/what-is-generator-in-python-and-how-does-it-work-e6e0588785c3?source=collection_archive---------1-----------------------#2022-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/545e5db27afbb2774deededde6a78bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gHPDuNZJ1wTIw3Dy"/></div></div></figure><p id="476a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<strong class="jx io">生成器</strong>是一个公正的函数，<strong class="jx io">返回一个可迭代的对象，我们可以迭代这个对象(一次一个值)</strong>。此外，生成器函数与常规函数有一个主要区别。它有一个<code class="fe kt ku kv kw b">yield</code>语句，而不是常规函数中的<code class="fe kt ku kv kw b">return</code>语句。</p><p id="ef67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要用 Python 构建迭代器，你需要做很多工作。你必须用<code class="fe kt ku kv kw b">__iter__</code>和<code class="fe kt ku kv kw b">__next__</code>魔法方法实现一个类，跟踪内部状态并在没有值返回时抛出<code class="fe kt ku kv kw b">StopIteration</code>。</p><p id="6447" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成器是创建迭代器的一种非常简单的方法，因为生成器会自动完成所有这些步骤。</p><h2 id="496c" class="kx ky in bd kz la lb dn lc ld le dp lf kg lg lh li kk lj lk ll ko lm ln lo lp bi translated"><strong class="ak">内容计划:</strong></h2><ol class=""><li id="50e2" class="lq lr in jx b jy ls kc lt kg lu kk lv ko lw ks lx ly lz ma bi translated"><a class="ae mb" href="#dc2a" rel="noopener ugc nofollow">创建生成器</a></li><li id="a532" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks lx ly lz ma bi translated"><a class="ae mb" href="#c263" rel="noopener ugc nofollow">发电机功能和常规功能的区别</a></li><li id="0626" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks lx ly lz ma bi translated"><a class="ae mb" href="#37c2" rel="noopener ugc nofollow">带回路的发电机</a></li><li id="b252" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks lx ly lz ma bi translated"><a class="ae mb" href="#d92b" rel="noopener ugc nofollow">生成器表达式</a></li><li id="0363" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks lx ly lz ma bi translated"><a class="ae mb" href="#dbf5" rel="noopener ugc nofollow">使用生成器</a> <br/> 5.1 <a class="ae mb" href="#069f" rel="noopener ugc nofollow">易于实现</a> <br/> 5.2 <a class="ae mb" href="#521a" rel="noopener ugc nofollow">内存高效</a> <br/> 5.3 <a class="ae mb" href="#807f" rel="noopener ugc nofollow">表示无限流</a> <br/> 5.4 <a class="ae mb" href="#807f" rel="noopener ugc nofollow">流水线化生成器</a></li><li id="702f" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks lx ly lz ma bi translated"><a class="ae mb" href="#61b2" rel="noopener ugc nofollow">结论</a></li></ol><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/983644260e97e3770520454c31b0e314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MfaaIEh0V6LLN0_X"/></div></div></figure><h1 id="dc2a" class="mm ky in bd kz mn mo mp lc mq mr ms lf mt mu mv li mw mx my ll mz na nb lo nc bi translated">1.创建生成器</h1><p id="56bb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated"><strong class="jx io">一个函数如果包含至少一个</strong> <code class="fe kt ku kv kw b"><strong class="jx io">yield</strong></code> <strong class="jx io">语句</strong>(可能包含几个<code class="fe kt ku kv kw b">yield</code>甚至<code class="fe kt ku kv kw b">return</code>)就成为生成器函数。为了清楚起见，<code class="fe kt ku kv kw b">yield</code>和<code class="fe kt ku kv kw b">return</code>从一个函数返回一些值。所以，你只需要用至少一个<code class="fe kt ku kv kw b">yield</code>来构建函数</p><p id="366b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主要区别在于<code class="fe kt ku kv kw b">return</code>语句完全终止一个函数，而<code class="fe kt ku kv kw b">yield</code>语句暂停一个函数并保存其所有状态，然后在后续调用中继续。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="c263" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">2.生成函数和正则函数的区别</h1><p id="d209" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">让我们来看看生成器函数和常规函数之间的所有差异:</p><ul class=""><li id="eb86" class="lq lr in jx b jy jz kc kd kg ns kk nt ko nu ks nv ly lz ma bi translated">生成器函数包括一个或多个<code class="fe kt ku kv kw b">yield</code>语句。</li><li id="2f68" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">它返回一个迭代器对象，但不立即执行。</li><li id="b33d" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">像<code class="fe kt ku kv kw b">__iter__()</code>和<code class="fe kt ku kv kw b">__next__()</code>这样的方法是自动实现的。这意味着我们可以使用<code class="fe kt ku kv kw b">next()</code>遍历条目。</li><li id="7bfd" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">一旦函数让步，它就被暂停，控制权移交给调用者。</li><li id="7e7a" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">局部变量及其状态在连续调用之间被记忆。</li><li id="6296" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">当一个生成器函数完成时，<code class="fe kt ku kv kw b">StopIteration</code>会在进一步调用时自动产生。</li></ul><p id="cbea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下示例说明了所有这些要点:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="97b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输出:</strong></p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="4e81" class="kx ky in kw b gy oc od l oe of">1 -- This is first<br/>2 -- This is second<br/>3 -- This is third and the last<br/>Traceback (most recent call last):<br/>...<br/>StopIteration</span></pre><p id="0313" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">simple_generator()</code>是一个有几个<code class="fe kt ku kv kw b">yield</code>语句的生成器函数。</p><p id="e496" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">值得注意的一件有趣的事情是，变量<code class="fe kt ku kv kw b">num</code>的值在每次调用之间被记忆。</p><p id="ae77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与常规函数不同，当函数屈服时，局部变量不会被破坏。此外，一个生成器对象只能迭代一次。</p><p id="c1a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要重新开始这个过程，您必须使用类似<code class="fe kt ku kv kw b">gen = simple_generator()</code>的东西创建另一个生成器对象。</p><p id="0beb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后要注意的一点是，你可以直接使用带有<code class="fe kt ku kv kw b">for</code>循环的发生器。</p><p id="2fd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为一个<code class="fe kt ku kv kw b">for</code>循环接受一个迭代器，并使用一个<code class="fe kt ku kv kw b">next()</code>函数对其进行迭代。当<code class="fe kt ku kv kw b">StopIteration</code>上升时自动结束。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="37c2" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">3.带回路的发电机</h1><p id="e338" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">上面的例子毫无意义，我展示它只是为了让你理解发电机的工作过程。</p><p id="aeed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">通常，发生器功能通过具有合适终止条件的回路实现</strong>。</p><p id="7ba1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，让我们来看看下面的例子:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="31a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输出:</strong></p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="811d" class="kx ky in kw b gy oc od l oe of">o<br/>l<br/>l<br/>e<br/>h</span></pre><p id="58cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码使用了一个<code class="fe kt ku kv kw b">range()</code>函数，通过<code class="fe kt ku kv kw b">for</code>循环来反转接收到的字符串。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="d92b" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">4.生成器表达式</h1><p id="2957" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">使用生成器表达式可以很容易地创建简单的生成器。这有助于轻松制造发电机。</p><p id="ebd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似于创建<a class="ae mb" href="https://towardsdev.com/lambda-function-python-e05171925c98" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">匿名函数</strong> </a>的 lambda 函数，生成器表达式创建匿名生成器函数。</p><p id="f5f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成器表达式的语法类似于<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/is-list-comprehension-the-most-effective-way-to-solve-any-tasks-python-b6bb3f5391fa"> <strong class="jx io">列表理解</strong> </a>。但是，方括号被圆括号取代。</p><p id="1d5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">列表理解和生成器表达式之间的主要区别在于,<strong class="jx io">列表理解</strong>产生<strong class="jx io">整个列表</strong>,而<strong class="jx io">生成器</strong>表达式一次产生<strong class="jx io">一个项目</strong>。</p><p id="95b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">他们有一个懒惰的执行(只在需要的时候产生项目)。正因为如此，生成器表达式比等价的列表理解更节省内存。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5840" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输出:</strong></p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="8106" class="kx ky in kw b gy oc od l oe of">[100, 324, 169, 529]<br/>&lt;generator object &lt;genexpr&gt; at 0x7fafb4473bd0&gt;</span></pre><p id="ee49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以从上面看到，生成器表达式没有立即产生所需的结果。相反，它返回一个生成器对象，该对象仅在请求时生成项目。</p><p id="1032" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是如何开始从生成器接收项目:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6d07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您运行上面的代码时，您会得到下面的<strong class="jx io">输出:</strong></p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="e99a" class="kx ky in kw b gy oc od l oe of">100<br/>324<br/>169<br/>529<br/>Traceback (most recent call last):<br/>  <!-- -->...<br/>StopIteration</span></pre><p id="558a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成器表达式可以用作函数参数。这样使用时，圆括号可以去掉。</p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="a4be" class="kx ky in kw b gy oc od l oe of">sum(x**2 for x in list_numbers)<br/>1122</span><span id="a1d9" class="kx ky in kw b gy og od l oe of">max(x**2 for x in list_numbers)<br/>529</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/b5685b10fad5d64b66ffd82e6241156e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kqUKM7onvUFPl1r6"/></div></div></figure><h1 id="dbf5" class="mm ky in bd kz mn mo mp lc mq mr ms lf mt mu mv li mw mx my ll mz na nb lo nc bi translated">5.发电机的使用</h1><p id="36e6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">有几个原因可以解释为什么生成器实现起来很强大。</p><h1 id="069f" class="mm ky in bd kz mn mo mp lc mq mr ms lf mt mu mv li mw mx my ll mz na nb lo nc bi translated">5.1.易于实施</h1><p id="28eb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated"><strong class="jx io">与对应的迭代器类</strong>相比，生成器可以清晰简洁地实现。下面是一个使用迭代器类实现 2 次方序列的例子。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="339f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码又长又混乱。现在，让我们使用一个生成器函数做同样的事情。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6817" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于生成器会自动跟踪细节，所以实现变得简洁、干净得多。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="521a" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">5.2.内存高效</h1><p id="fa7e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">返回序列的常规函数<strong class="jx io">将在返回结果之前在内存</strong>中创建整个序列。如果序列中的项目数量非常大，这就太多了。</p><p id="eba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种序列<strong class="jx io">的<strong class="jx io">生成器</strong>实现是内存友好的，并且是优选的</strong>，因为它一次只产生一个项目。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="807f" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">5.3.表示无限流</h1><p id="c32d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated"><strong class="jx io">生成器是表现无限数据流的优秀媒介。无限流不能存储在内存中，由于生成器一次只能产生一个项目，所以它们可以表示无限的数据流。</strong></p><p id="ee9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的生成器函数可以生成(理论上)所有的偶数。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="552b" class="mm ky in bd kz mn nn mp lc mq no ms lf mt np mv li mw nq my ll mz nr nb lo nc bi translated">5.4.流水线发电机</h1><p id="fd45" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">多个<strong class="jx io">发生器可用于流水线化一系列操作</strong>。有一个例子可以很好地说明这一点。</p><p id="3ce2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您有一个生成斐波纳契数列中的数字的生成器。我们还有另一个平方数的生成器。</p><p id="d63c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想找出斐波纳契数列中数字的平方和，我们可以通过以下方式将生成器函数的输出流水线化在一起。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1eaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p><pre class="mi mj mk ml gt ny kw nz oa aw ob bi"><span id="2d8f" class="kx ky in kw b gy oc od l oe of">1120149658760</span></pre><p id="a44a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种流水线是高效的，易于阅读的，这是一个很好的方法。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/cadcac86b773887ef1d63b3a997e5013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2h0I-k9A2dL82zyP"/></div></div></figure><h1 id="61b2" class="mm ky in bd kz mn mo mp lc mq mr ms lf mt mu mv li mw mx my ll mz na nb lo nc bi translated">6.结论</h1><p id="8460" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">让我们结束这一切。现在你知道了:</p><ul class=""><li id="b2a9" class="lq lr in jx b jy jz kc kd kg ns kk nt ko nu ks nv ly lz ma bi translated">如何用 Python 编写和使用生成器</li><li id="2ecf" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">正则函数和生成函数的区别</li><li id="1d75" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">列表和生成器的区别</li><li id="431d" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">发电机的好处</li><li id="07c9" class="lq lr in jx b jy mc kc md kg me kk mf ko mg ks nv ly lz ma bi translated">在这种情况下，可以使用发电机</li></ul></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="2010" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="oi"> P.S .如果你喜欢这篇文章，</em> <a class="ae mb" href="https://medium.com/@vlad.bashtannyk" rel="noopener"> <em class="oi">关注我</em> </a>，<em class="oi">点几下“拍手”</em> <em class="oi">留下反馈。祝你好运，高效编程！谢谢大家！</em></p><p id="80b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mb" href="https://www.linkedin.com/in/vladyslav-bashtannyk/" rel="noopener ugc nofollow" target="_blank"><em class="oi">LinkedIn</em></a><em class="oi">——</em><a class="ae mb" href="https://twitter.com/VladyslavBasht2" rel="noopener ugc nofollow" target="_blank"><em class="oi">Twitter</em></a></p></div></div>    
</body>
</html>