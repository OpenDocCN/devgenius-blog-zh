<html>
<head>
<title>Build Laravel Application using DDD and CQRS with Ecotone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 DDD 和 CQRS 的生态交错带构建 Laravel 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-laravel-application-using-ddd-and-cqrs-with-ecotone-3e049de10a3a?source=collection_archive---------0-----------------------#2022-04-21">https://blog.devgenius.io/build-laravel-application-using-ddd-and-cqrs-with-ecotone-3e049de10a3a?source=collection_archive---------0-----------------------#2022-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3d505a62cfb2227b972e84214e3e917a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_dbZqHX68pTkHZ77d26Dg.jpeg"/></div></div></figure><div class=""/><p id="8942" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DDD 在 PHP 世界变得越来越受欢迎，有很多关于如何接近它的讨论。<br/>在 Laravel 社区,<a class="ae kt" href="https://twitter.com/PovilasKorop/status/1517034905682812929" rel="noopener ugc nofollow" target="_blank">也获得了发展势头</a>。</p><p id="2b58" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你是否一直想知道如何在 Laravel 中实现它？<br/>在本文中，我将解释 DDD 构建模块的基础知识，以及我们如何在 Laravel 应用程序中使用它们。</p><p id="7193" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不是必需的，但是我鼓励你在开始之前看一下之前关于 CQRS 的博客<a class="ae kt" href="https://blog.ecotone.tech/cqrs-in-php/" rel="noopener ugc nofollow" target="_blank">“用 PHP 走进 CQRS”</a>。</p><h1 id="9ce0" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">雄辩的奥姆和 DDD</h1><p id="420a" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在 DDD，我们使用<em class="lx">领域模型</em>，这不同于<em class="lx">雄辩模型。</em> <br/>领域模型与基础设施和框架相关的实现是干净的，以便对修改和扩展有完全的控制。</p><blockquote class="ly lz ma"><p id="efb1" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">领域模型旨在解决与业务相关的问题，而不是技术问题。得益于此，维护和扩展它们变得更加容易。</p></blockquote><p id="e180" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们决定使用雄辩术并将其与领域模型混合，那么我们就引入了数据库依赖。然而，我们这样做是有原因的，因为我们想获得雄辩的整合带来的好处。</p><blockquote class="ly lz ma"><p id="7da6" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">对抗自己的框架可能会给代码库带来更高的复杂性，并增加可维护性成本。</p></blockquote><p id="4a53" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于构建没有雄辩的领域模型，将会有一个单独的博客文章，在这篇文章中，我们将关注，如果我们决定与雄辩的 ORM 携手共进，我们能实现什么。</p><figure class="me mf mg mh gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/aeafeb6b83ab5e909a70653838d09c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjFMPWP3qzkKvebvp9WSCA.jpeg"/></div></div></figure><h1 id="9c6f" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">聚集</h1><p id="b2d4" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在 DDD，我们建造<code class="fe mi mj mk ml b">Aggregates which are classes rich in behaviour</code>。<br/>以<code class="fe mi mj mk ml b">Article</code>为例，它可能是<code class="fe mi mj mk ml b">published</code>，但首先需要作者指定为<code class="fe mi mj mk ml b">approved</code>。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d328" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能是雄辩的模型，我们将使用<code class="fe mi mj mk ml b">-&gt;save()</code>方法存储在数据库中。<br/>公开集合上的动作(方法)并把它作为修改数据的唯一方式是很重要的。<br/>直接在数据库上调用 insert 和 updates SQLs，可能会引入不正确的数据或绕过我们的约束。</p><blockquote class="ly lz ma"><p id="58ba" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">如果修改给定集合的唯一方法是通过他的公共方法，并且方法在内部保护它自己的状态，那么我们就到了我们的模型总是有效的地方。</p></blockquote><h1 id="4cb7" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">价值对象</h1><p id="7ba0" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">模型的一部分是值对象。VO 是不可变的类。它们是需要验证的给定类型的包装器。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8fe8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果系统中有像电子邮件这样的值对象，那么我们可以传递它并确保它总是有效的。这减少了系统中保护逻辑的数量。</p><h1 id="11ec" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">实现与拉勒韦尔的生态交错</h1><p id="3ee7" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">要使用 Laravel 安装启用生态区:</p><pre class="me mf mg mh gt mo ml mp mq aw mr bi"><span id="1733" class="ms kv iy ml b gy mt mu l mv mw">composer require ecotone/laravel</span></pre><p id="207a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于自动序列化和反序列化:</p><pre class="me mf mg mh gt mo ml mp mq aw mr bi"><span id="c635" class="ms kv iy ml b gy mt mu l mv mw">composer require ecotone/jms-converter</span></pre><h1 id="5a0f" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">雄辩创造新的聚合</h1><p id="35c9" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们将实现<code class="fe mi mj mk ml b">Issue</code>聚合。如果出现系统错误，我们的客户可以报告问题。<br/>先来定义一下<code class="fe mi mj mk ml b">ReportIssue Command</code>。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d1d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了执行<code class="fe mi mj mk ml b">ReportIssue</code>，我们需要调用<code class="fe mi mj mk ml b">Command Bus</code>。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="da6d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么来自<code class="fe mi mj mk ml b">$request-&gt;all()</code>从<code class="fe mi mj mk ml b">HTML Form</code>返回的数据是:</p><pre class="me mf mg mh gt mo ml mp mq aw mr bi"><span id="5b01" class="ms kv iy ml b gy mt mu l mv mw">["email" =&gt; "johnybravo@gmail.com","content" =&gt; "My PC is not working"]</span></pre><p id="68e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk ml b">ReportIssue</code>里面的<code class="fe mi mj mk ml b">Email</code>是值对象类，所以我们需要知道如何从<code class="fe mi mj mk ml b">string</code>转换到<code class="fe mi mj mk ml b">Email</code>类。为了做到这一点，我们将注册<code class="fe mi mj mk ml b">Converter</code>。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="ly lz ma"><p id="2c4d" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">Ecotone JMS 转换器包将处理从数组/ JSON / XML 到 PHP 类的所有反序列化以及其他反序列化。</p></blockquote><p id="648c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们实现我们的雄辩<code class="fe mi mj mk ml b">Issue Aggregate</code>:</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ol class=""><li id="364b" class="mx my iy jx b jy jz kc kd kg mz kk na ko nb ks nc nd ne nf bi translated">我们用<code class="fe mi mj mk ml b">#[Aggregate]</code>标记我们的模型，这样生态交错区可以找到它</li><li id="6157" class="mx my iy jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">我们在<code class="fe mi mj mk ml b">"issue.report"</code>路由键下启用工厂方法。</li><li id="27bc" class="mx my iy jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">因为我们想要发布包含<code class="fe mi mj mk ml b">Id</code>的事件，我们需要将<code class="fe mi mj mk ml b">Issue</code>保存在工厂方法中，所以将分配标识符</li><li id="60f5" class="mx my iy jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">我们用来自<code class="fe mi mj mk ml b">WithAggregateEvents</code> trait 的<code class="fe mi mj mk ml b">recordThat</code>方法发布<code class="fe mi mj mk ml b">IssueWasReported</code>。</li><li id="ef8e" class="mx my iy jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">我们需要公开带有生态区标识符的公共方法<code class="fe mi mj mk ml b">#[AggregateIdentifierMethod("id")]</code></li></ol><p id="0741" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以执行我们的<code class="fe mi mj mk ml b">Controller we have defined previously to send Command and create new Issue</code>。</p><h1 id="3827" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">改变总发行</h1><p id="7b7c" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在，我们可以增加结束问题的可能性。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="ly lz ma"><p id="9972" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">没有为命令处理程序定义命令类，这是因为我们在这里不需要任何数据。当需要时，生态区允许仅通过路由名称无缝路由给定的处理者。</p></blockquote><p id="fe1a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们想执行这个命令处理程序</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bbe9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk ml b">metadata</code>部分是额外的信息，不是命令本身的一部分。<br/>生态区用它来传递周围框架相关的信息。<br/>经过<code class="fe mi mj mk ml b">aggregate.id</code>我们告诉生态区哪个<code class="fe mi mj mk ml b">Issue Aggregate it should execute</code>。</p><blockquote class="ly lz ma"><p id="7478" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">您可以使用元数据来传递您自己的额外细节，您想通过命令传递这些细节，例如<code class="fe mi mj mk ml b">User Id</code>。</p></blockquote><h1 id="bd4f" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">事件处理</h1><p id="d138" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当<code class="fe mi mj mk ml b">Issue</code>聚合被报告时，我们正在发布事件:</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1744" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以注册订户，在报告问题后，订户将向客户发送确认电子邮件。</p><figure class="me mf mg mh gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ec15" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到<code class="fe mi mj mk ml b">subscribe to specific Event we type hint given class as first parameter</code>(就像命令处理程序一样)并用<code class="fe mi mj mk ml b">#[EventHandler]</code>标记方法。</p><h1 id="2819" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="d808" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><code class="fe mi mj mk ml b">Ecotone Framework</code>正在处理胶合代码并提供构建模块，因此我们可以快速可靠地构建应用程序。它以设计这些框架方式与 Laravel 和雄辩集成。<br/>在需要的情况下，您可以使用新功能扩展您的应用程序，如<a class="ae kt" href="https://blog.ecotone.tech/implementing-event-sourcing-php-application-in-15-minutes/" rel="noopener ugc nofollow" target="_blank">事件源</a>和<a class="ae kt" href="https://blog.ecotone.tech/asynchronous-php/" rel="noopener ugc nofollow" target="_blank">异步通信</a>。</p><p id="3cf3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想用<code class="fe mi mj mk ml b">Laravel and Ecotone</code>运行演示应用，你可以在<a class="ae kt" href="https://github.com/ecotoneframework/php-ddd-cqrs-event-sourcing-symfony-laravel-ecotone" rel="noopener ugc nofollow" target="_blank">这个库</a>下找到它。</p></div></div>    
</body>
</html>