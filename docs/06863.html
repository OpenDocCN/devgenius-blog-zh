<html>
<head>
<title>Task Management App with React, Socket.io, and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 React、Socket.io 和 Redis 的任务管理应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/task-management-app-with-react-socket-io-and-redis-ebffc4d0fde6?source=collection_archive---------5-----------------------#2022-02-08">https://blog.devgenius.io/task-management-app-with-react-socket-io-and-redis-ebffc4d0fde6?source=collection_archive---------5-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/274fc4bb98ad53a9c758f8fba6d45b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*JW9lZLN8QSL06UBhZbdhOA.jpeg"/></div></figure><p id="e88a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这篇博客中，我将试着解释我在<strong class="jt io">超级团队</strong>领导的《潜伏者达人》中的一个任务的实现。我非常兴奋地开发这个，直到我意识到最后期限是一天。我来得太晚了。我几乎想过放弃这个机会，但决定用我有限的时间和知识试一试。对我来说，15 天的比赛变成了 24 小时的黑客马拉松。</p><p id="2159" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">实时任务管理应用程序是每个组织维护其工作流程的重要组成部分。每个项目及其团队成员通过任务管理应用程序进行同步。一些著名的有吉拉，阿萨纳。在这里，我试图实现这样一个应用程序的一个非常基本的版本。</p><p id="3871" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将从基础开始，尝试给出实现的概述。这里有一个小视频解释了该应用程序是如何工作的。</p><p id="e8c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kp" href="https://youtu.be/J15uPQTQUf8" rel="noopener ugc nofollow" target="_blank">https://youtu.be/J15uPQTQUf8</a></p><p id="683f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码链接:<a class="ae kp" href="https://github.com/crazylazylife/superteam-task-manager" rel="noopener ugc nofollow" target="_blank">crazylazylife/super team-task-manager</a></p><h2 id="64ac" class="kq kr in bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">先决条件</h2><p id="1c62" class="pw-post-body-paragraph jr js in jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">在我们开始实施之前，应该具备以下先决条件:</p><ol class=""><li id="3026" class="lo lp in jt b ju jv jy jz kc lq kg lr kk ls ko lt lu lv lw bi translated">Node.js、Express、ReactJS、Socket.io 的工作知识</li><li id="860e" class="lo lp in jt b ju lx jy ly kc lz kg ma kk mb ko lt lu lv lw bi translated">关于<a class="ae kp" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>的基本思路</li><li id="f725" class="lo lp in jt b ju lx jy ly kc lz kg ma kk mb ko lt lu lv lw bi translated">在您的系统中预装了<a class="ae kp" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae kp" href="https://redis.io/download" rel="noopener ugc nofollow" target="_blank"> Redis-Server </a>。</li></ol><h2 id="689d" class="kq kr in bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">这一切是如何运作的</h2><p id="d3c3" class="pw-post-body-paragraph jr js in jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">既然你对基础知识很有信心，我们就可以深入了解这个应用了。您可以按照步骤将应用程序安装到您的系统中，并开始在其上进行开发。</p><p id="5c2a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，您可以将存储库分支到您的帐户，并在您的系统中克隆它。如果仔细观察，文件结构分为两部分:</p><ol class=""><li id="001e" class="lo lp in jt b ju jv jy jz kc lq kg lr kk ls ko lt lu lv lw bi translated">后端</li><li id="5e01" class="lo lp in jt b ju lx jy ly kc lz kg ma kk mb ko lt lu lv lw bi translated">前端</li></ol><p id="864f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在我们继续之前，让我们通过在终端中执行<code class="fe mc md me mf b">redis-server</code>命令来启动 Redis 服务器。</p><h2 id="5cd3" class="kq kr in bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">后端</h2><p id="cef1" class="pw-post-body-paragraph jr js in jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">该文件夹包含托管服务器所需的所有文件。要启动服务器，我们需要执行以下命令。</p><p id="e2e0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">cd backend</code> —移动到后端文件夹</p><p id="5d1c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">npm i</code> —安装服务器的所有依赖项</p><p id="a289" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">npm start</code> —启动服务器</p><p id="702c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，定义快递服务器，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3c1e" class="kq kr in mf b gy mo mp l mq mr">// Importing the required dependencies<br/>const app = require("express")();<br/>const http = require("http").createServer(app);</span><span id="b5a4" class="kq kr in mf b gy ms mp l mq mr">// Starting the server at port 4000<br/>http.listen(4000, function (){  <br/>    console.log("listening on port 4000");<br/>});</span></pre><p id="d520" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">服务器启动后，我们现在必须为 socket.io 设置我们的服务器。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="807a" class="kq kr in mf b gy mo mp l mq mr">// Importing the dependencies<br/>const { Socket } = require("socket.io");<br/>const io = require("socket.io")(http,<br/>               {  cors: {    <br/>                           origin: "*",    <br/>                           methods: ["GET", "POST"],  <br/>                  },<br/>                }<br/>           );</span><span id="7c25" class="kq kr in mf b gy ms mp l mq mr">// Initializing the socket io connection<br/>io.on("connection", (socket) =&gt; { <br/>    <br/>    // A sample endpoint for users to login<br/>    socket.on("login", () =&gt; {    <br/>        console.log("new login");<br/>        // Returns list of all workspaces within    <br/>        io.emit("allWorkspaces", getWorkspaces());  <br/>    });   <br/>    <br/>    socket.on("openWorkspace", (workspace) =&gt; {<br/>         console.log(workspace.name);<br/>         // Create a new room with the workspace name<br/>         socket.join(workspace.name);<br/>         // All subsequest emmision happen in the room.<br/>         io.in(workspace.name).emit("allTasks", getTasks(workspace.name));  });   <br/>    <br/>    // Endpoint for adding new Task<br/>    socket.on("addTask", (task) =&gt; {    <br/>        console.log(task);    <br/>        addTask(task);    <br/>        io.in(task.workspaceName).emit("newTask", { task });    <br/>    });</span><span id="924f" class="kq kr in mf b gy ms mp l mq mr">    // Endpoint for adding new Workspace<br/>    socket.on("addWorkspace", (workspace) =&gt; {    <br/>        console.log(getWorkspaces());   <br/>        addWorkspace(workspace);    <br/>        io.emit("newWorkspace", { workspace });    <br/>    });   <br/>    <br/>    socket.on("disconnect", () =&gt; {    <br/>        console.log("User disconnected");  <br/>    });<br/>});</span></pre><p id="6114" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，我们需要实现 redis-client 来将信息存储在数据库中。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7051" class="kq kr in mf b gy mo mp l mq mr">// Importing the dependencies<br/>const redis = require("redis");</span><span id="23ff" class="kq kr in mf b gy ms mp l mq mr">//Connect to redis server running in localhost at port 6379<br/>let redisClient = redis.createClient({});<br/>redisClient.connect();</span><span id="c267" class="kq kr in mf b gy ms mp l mq mr">redisClient.on("connect", () =&gt; {  <br/>    console.log("Redis client Connected");<br/>});</span><span id="49b9" class="kq kr in mf b gy ms mp l mq mr">var workspaceList = [];<br/>var taskList = [];</span><span id="7544" class="kq kr in mf b gy ms mp l mq mr">// Get all the workspace details that are stored in DB<br/>redisClient.get("workspaces", (error, workspaces) =&gt; {  <br/>    if (error) console.log(error);  <br/>    // console.log(workspaces); <br/>    workspaceList = workspaces;<br/>});<br/>setWorkspaces(workspaceList);<br/>console.log("Workspaces updated... ");</span><span id="20fc" class="kq kr in mf b gy ms mp l mq mr">// Get all the task details that are stored in DB<br/>redisClient.get("tasks", (error, tasks) =&gt; { <br/>    if (error) console.log(error);  <br/>    taskList = task;<br/>}); <br/>setTasks(taskList); <br/>console.log("Tasks updated... ");</span><span id="095e" class="kq kr in mf b gy ms mp l mq mr">// To update the data in DB<br/>socket.on("addTask", (task) =&gt; {    <br/>        .<br/>        .<br/>        . <br/>        redisClient.set("tasks", getAllTasks());<br/>});</span><span id="8e66" class="kq kr in mf b gy ms mp l mq mr">socket.on("addWorkspace", (task) =&gt; {    <br/>        .<br/>        .<br/>        . <br/>        redisClient.set("workspaces", getWorkspaces());<br/>});</span></pre><p id="5dad" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有几个类似<code class="fe mc md me mf b">getAllTasks()</code>或者<code class="fe mc md me mf b">getWorkspaces()</code>的功能。这些是分别在<code class="fe mc md me mf b">tasks.js</code>和<code class="fe mc md me mf b">workspace.js</code>文件中定义的自解释函数。</p><h2 id="46da" class="kq kr in bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">前端</h2><p id="74a4" class="pw-post-body-paragraph jr js in jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">保存应用程序客户端开发代码的前端文件夹是使用<code class="fe mc md me mf b">create-react-app</code>创建的。它遵循 ReactJS 项目的基本结构。应用程序的所有基本组件都在<code class="fe mc md me mf b">src</code>文件夹中定义。</p><p id="9feb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要启动前端，请执行以下命令，</p><p id="623a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">cd frontend</code> —移动到前端文件夹</p><p id="f773" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">npm i</code> —安装依赖项</p><p id="ef04" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b">npm start</code> —启动应用程序</p><p id="5bd6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，打开你最喜欢的浏览器，访问<code class="fe mc md me mf b">http://localhost:3000</code></p><p id="14b1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码非常简单，分为多个部分。下图简要说明了这些部分是如何划分的，</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/1a624e8fc26f2b2cec06dc0cd8f37ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4pohk2olRWw9LMrNdL7Bw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">用户访问网站后进入的主页。</figcaption></figure><p id="17e4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此页面包含用户可用的所有工作区的列表。<strong class="jt io">注意:这个实现还不处理用户认证。</strong></p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/0e2a1e34d7a70075ac0cd7c8dcd23228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrtxWCOY70_33VVYUv0FtQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">与牛顿项目相关的任务列表</figcaption></figure><p id="84c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此页面包含与从上一页面选择的特定工作区相对应的任务列表。</p><p id="1f63" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nd"><img src="../Images/c830ecad52fdaa826bf0ff9046704cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Blcpe0-WfRWft_N8qeiDRA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">创建新任务的弹出表单</figcaption></figure><p id="fdde" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">每当我们点击<strong class="jt io">添加新任务</strong>或<strong class="jt io">添加新工作区</strong>按钮时，我们会呈现一个弹出的空表单，要求我们填写必要的细节。下面是模式实现的示例代码，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="fd40" class="kq kr in mf b gy mo mp l mq mr"><strong class="mf io">// Located in frontend/src/components/Tasks.js</strong></span><span id="e646" class="kq kr in mf b gy ms mp l mq mr">// Importing dependencies<br/>import { Modal } from "react-responsive-modal";</span><span id="9d04" class="kq kr in mf b gy ms mp l mq mr">const [open, setOpen] = useState(false);  <br/>const onOpenModal = () =&gt; setOpen(true);  <br/>const onCloseModal = () =&gt; setOpen(false);</span><span id="b88f" class="kq kr in mf b gy ms mp l mq mr">&lt;Modal open={open} onClose={onCloseModal} center&gt;<br/>    &lt;div className="modal-body"&gt;<br/>        &lt;h2&gt;Create New Task&lt;/h2&gt;<br/>        &lt;form className="contact-form" noValidate="noValidate"&gt;<br/>            &lt;div className="form-group"&gt;<br/>              &lt;input<br/>                className="form-control"<br/>                type="text"<br/>                name="name"<br/>                id="name"<br/>                placeholder="Task Name"<br/>                required=""<br/>              /&gt;<br/>            &lt;/div&gt;<br/>            &lt;div className="form-group"&gt;<br/>              &lt;textarea<br/>                className="form-control"<br/>                name="desc"<br/>                id="desc"<br/>                placeholder="Task Details"<br/>                required=""<br/>              /&gt;<br/>            &lt;/div&gt;<br/>            &lt;input<br/>              className="new-btn"<br/>              id="add_task"<br/>              type="button"<br/>              value="Add Task"<br/>              onClick={addNewTask}<br/>            /&gt;<br/>        &lt;/form&gt;<br/>    &lt;div&gt;<br/>&lt;/Modal&gt;</span></pre><p id="ea35" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们也来看看 socket.io-client 实现。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="50a4" class="kq kr in mf b gy mo mp l mq mr"><strong class="mf io">// Located in frontend/src/components/Body.js</strong></span><span id="44b3" class="kq kr in mf b gy ms mp l mq mr">// Importing dependencies<br/>import io from "socket.io-client";</span><span id="ce5e" class="kq kr in mf b gy ms mp l mq mr">const socket = io.connect("http://localhost:4000");</span></pre><p id="2974" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，我们将这个 socket 对象作为道具传递给它的子组件，用于所有的服务器交互。</p><p id="e694" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">比方说，我们必须持续监听正在创建的新工作空间。我们在一个 useEffect 钩子中定义了必要条件，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d18e" class="kq kr in mf b gy mo mp l mq mr"><strong class="mf io">// Located in frontend/src/components/Workspaces.js</strong></span><span id="039d" class="kq kr in mf b gy ms mp l mq mr">useEffect(() =&gt; {    <br/>    const wplistener = ({ workspace }) =&gt; {      <br/>        setWorkspaceList((oldList) =&gt; [...oldList, workspace]);    <br/>    };    <br/>    // Listening at the endpoint for new broadcasts from the server<br/>    props.socket.on("newWorkspace", wplistener);<br/>    // Clean the listener to avoid duplicates<br/>    return () =&gt; props.socket.off("newWorkspace", wplistener); <br/>}, []);</span></pre><h2 id="6b86" class="kq kr in bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">结论</h2><p id="fc28" class="pw-post-body-paragraph jr js in jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">总的来说，上述应用程序的实现非常简单，并且在某种程度上是不完整的，具有巨大的特性和功能空间。我试图在很短的时间内尽可能多地实施。</p><p id="b213" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">尽管这个项目在很大程度上是不完整的，但我能从中学到很多东西。我希望继续进一步迭代实现，并更新代码和博客。但如果有任何错误，请随时在这里或在存储库问题上发表您的疑问，或在 himadri.tito13@gmail.com 给我发邮件。我会尽最大努力解决你可能面临的任何问题。</p></div></div>    
</body>
</html>