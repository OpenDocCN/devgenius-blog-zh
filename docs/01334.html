<html>
<head>
<title>Leetcode Problem: Merge-K-Sorted Lists using MinPQ (Ruby)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 问题:使用 MinPQ (Ruby)合并 K 排序列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-problem-merge-k-sorted-lists-using-minpq-ruby-a63c4f325796?source=collection_archive---------18-----------------------#2020-06-30">https://blog.devgenius.io/leetcode-problem-merge-k-sorted-lists-using-minpq-ruby-a63c4f325796?source=collection_archive---------18-----------------------#2020-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c66ed56895420ad1f15ac845b01a84cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBWo_GWrG58h28kDHwnBfg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">LeetCode！:0</figcaption></figure><div class=""/><p id="4d3f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">！！！在阅读之前，请确保您了解基本的排序算法，如插入排序、合并排序和优先级队列数据结构。我强烈建议，如果你不熟悉基本算法和数据结构，在解决 Leetcode 问题之前，先熟悉所有的基本算法和数据结构。如果没有算法和数据结构的基础知识，就很难跟上解决方案的解释并实现除暴力之外的解决方案，这是低效的。</em></p><p id="f07b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">我强烈推荐罗伯特·塞奇威克的《算法》第四版。</em></p><h2 id="7bb1" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">那么首先是什么问题呢？</h2><p id="3fe5" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated">这个问题是 Leetcode 上非常流行的“硬”级问题。查看问题<a class="ae lw" href="https://leetcode.com/problems/merge-k-sorted-lists/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="50c2" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">合并 k 个排序链表:</strong> <br/>合并 k 个排序链表，作为一个排序链表返回。分析并描述其复杂性。</p><p id="b16b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例:<br/>输入:<br/><br/>1-&gt;4-&gt;5、<br/> 1 - &gt; 3 - &gt; 4、<br/>2-&gt;6<br/><br/>输出:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6。</p><p id="7e53" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们现在可以把链表看作数组，以消除处理节点的复杂性。</p><p id="af62" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">看待这个问题的一种方式是把它看做一个合并排序问题，或者“实现合并排序”问题</strong>。在合并排序中，从最小的子数组开始，我们递归排序，直到整个数组都被排序。这被称为“分治”算法。</p><p id="c20c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看看这个 mergesort 的痕迹。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lx"><img src="../Images/a1813967805bf5bc1f4cdd6a87404ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*cAl647oZwGamDX0gVPHHJA.png"/></div></div></figure><p id="fa3a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以将相同的算法应用于 k 链表。递归排序两个列表，直到我们得到一个组合结果。我们的问题与 mergesort 的唯一不同之处是我们从 k 个排序的子数组开始，而不是给出一个完整的未排序的数组。</p><p id="94e3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们使用分治合并算法，我们将得到 O(N log k)的运行时间。(合并排序的正常运行时间为 O(N log N)。然而，在这个问题中，我们从 k 个排序的子数组开始，所以我们必须对每个值进行排序的比较次数是 log k，而不是 log N。)</p><p id="252b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一种看问题的方法是同时合并所有子阵列。当我们合并<em class="kx">两个</em>子数组时，我们比较两个子数组的下一个元素，并将较小的一个插入我们的结果中。我们重复这个过程，直到整个数组合并。</p><p id="38d7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">合并两个排序的子数组的轨迹:“例如 M R”和“A C E R T”。左半部分显示合并结果的轨迹，右半部分显示我们为每个“合并”比较的值的轨迹。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/810ba293b8cd5e05bcf20d3ec522ef8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*XI4qwcomTA-JnnAztjNwVQ.png"/></div></figure><p id="abbe" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">找到两个值之间的最小值是一个简单的比较操作，但是我们需要同时合并 k 个列表。<strong class="kb jd">如何从 k 个数值中快速找到最小值？</strong>这样做的一个方法是保存一个有序的列表数组。</p><p id="f901" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">即<br/>用例子:<br/><br/>1-&gt;4-&gt;5、<br/> 4 - &gt; 5 - &gt; 7、<br/> 2 - &gt; 6 <br/></p><p id="4c68" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">链表排序数组:[1，2，4] <br/>删除第一个节点，并添加到 ans <br/>结果:1 <br/>添加被删除节点的 next 并重新排序(节点 1 - &gt; 4 的 next 为 4，add 4)</p><p id="aeb8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">链表的排序数组:[2，4，4] <br/>删除第一个节点，并添加到 ans <br/>结果:1 - &gt; 2 <br/>添加被删除节点的下一个并重新排序</p><p id="12e3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">排序后的数组:[4，4，6] <br/>删除第一个节点，并添加到 ans <br/>结果:1- &gt; 2 - &gt; 4 <br/>添加被删除节点的下一个并重新排序</p><p id="ad8a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">重复直到排序后的数组为空…</p><p id="79f7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用链表的排序数组是可行的，但是为每个节点移除/插入保持数组排序将花费 O(k)的运行时间(使用插入排序来排序部分排序的数组)。<strong class="kb jd">如果我们使用优先级队列，我们可以减少寻找下一个最小值并将下一个节点插入 O(log k)的运行时间。</strong></p><h2 id="c776" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">优先级队列/二进制堆</h2><p id="879b" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated">优先级队列或二进制堆看起来像这样…</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div class="gh gi md"><img src="../Images/f6a34001d38f2cb0ee40d4cede8fe1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*Ds3bcQDyi0A2Z9rp6pe6Kg.png"/></div></figure><p id="e1ee" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">二叉堆是满足堆性质的二叉树:父代小于或等于其子代；子代大于或等于其父代。<strong class="kb jd">最小二进制堆的根总是所有值中的最小值。</strong></strong></p><p id="e167" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们不会过多地讨论二进制堆，但是这里有一些基本的东西:二进制堆中的值保存在从索引 1 开始的数组中。节点的子节点的索引是 2*i &amp; 2*i+1。<br/> <strong class="kb jd">要添加一个节点，</strong>我们添加到数组的末尾，并沿着树向上“游”节点，直到满足堆属性。<br/> <strong class="kb jd">为了去掉最小值，</strong>我们用堆中的最后一个元素交换最小值(索引 1)。然后，我们弹出最小值。最后，我们通过向下移动交换的元素来满足堆属性，直到满足堆属性。<em class="kx">如果你不熟悉二进制堆，你应该看一下</em><a class="ae lw" href="https://www.brianstorti.com/implementing-a-priority-queue-in-ruby/" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://www . brianstorti . com/implementing-a-priority-queue-in-ruby/</em></a><em class="kx">了解数据结构的完整描述和实现。</em></p><p id="4489" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">在优先级队列中，删除最小值和插入新值都有 log X 的运行时间，其中 X 是节点总数。</strong>因此，如果我们使用优先级队列而不是排序数组，我们可以将每个节点移除/插入-下一个/重新排序的运行时间减少到 O(log k)。对每个节点执行这个过程将得到 O(N log k)的总运行时间。</p><p id="07fa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我们将要讨论的解决方案！</p><h2 id="d7b8" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">使用最低优先级队列的解决方案:</h2><p id="da31" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated">首先，这是我们的 minPQ。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5c37" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">注意:我硬编码了 PQ 来接受节点作为元素。它将使用 node.value 在两个节点之间进行比较。</em></p><p id="80a8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在在我们的 merge_k_lists 方法中:<br/>首先，我们创建一个 min PQ 并将每个列表插入其中。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9d85" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">记住，输入“列表”基本上是每个列表头的数组。所以如果我们有名单…</p><p id="20e7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">【<br/> 1 - &gt; 4 - &gt; 5、<br/> 1 - &gt; 3 - &gt; 4、<br/> 2 - &gt; 6 <br/>。</p><p id="97ab" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">…我们插入到 PQ 中的节点列表实际上只包括[1，1，2]。</p><h2 id="1d71" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">无需额外内存即可创建新的合并列表:</h2><p id="1add" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated">通过跟踪我们添加的前一个节点，我们可以在不使用额外内存的情况下创建一个新的链表(我们还需要跟踪头部，以便在创建完新的链表后返回头部)。)</p><p id="93c2" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于我们添加的第一个节点，设置初始 head 和 prev:<br/>head = first _ node _ to _ be _ added<br/>prev = first _ node _ to _ be _ added</p><p id="4734" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于我们要添加的每个节点:<br/>prev . next = next _ node _ to _ be _ added<br/>prev = next _ node _ to _ be _ added</p><p id="d5f3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单！</p><p id="c1c3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好了，现在我们有了一个带有链表的 min PQ，并且知道了如何创建一个新的链表，我们可以实现我们的解决方案了。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8797" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，<strong class="kb jd">我们设置磁头和初始 prev </strong>:我们从 PQ 中弹出(删除 min)并将其设置为磁头和 prev。如果删除的节点有一个. next，我们将下一个节点添加到 PQ。<em class="kx">注意:如果 m.pop 永远为零，这意味着我们的 PQ 是空的。</em></p><p id="23fa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦我们设置了 head 和 prev，<strong class="kb jd">我们重复地将下一个最小值添加到我们的链表中，直到我们的 PQ 为空</strong>:获取下一个最小值，将其添加到我们的 linked_list 中。如果。下一个节点不为空。在 pq 旁边。重复一遍。</p><p id="7023" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦 PQ 为空，我们将有一个完全排序的列表，并且<strong class="kb jd">我们可以返回头(我们的列表)。</strong></p><h2 id="58be" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">我们算法的分析:</h2><p id="9370" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated"><strong class="kb jd">时间复杂度为 O(N log k) </strong>，其中 N 是总节点数，k 是列表数。对于每一个最小的 pop 和它的下一个插入，运行时间是 O(log k)。我们有 N 个节点要插入，这样我们的总运行时间为 O(N log k)。</p><p id="0496" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">空间复杂度将是 O(k)，即优先级队列所需的空间。我们的 PQ 的大小与输入中链表的数量成正比。我们正在创建我们的结果，所以我们不需要额外的空间来创建和返回一个新的列表。</p><h2 id="87c2" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">在检查中</h2><p id="afd6" class="pw-post-body-paragraph jz ka jc kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ig bi translated">我们在这里实现的解决方案非常类似于合并排序的内部过程(合并两个排序的子数组)。然而，这里我们同时合并 k 个数组，所以我们需要实现一个优先级队列来有效地从 k 个不同的值中找到最小值。</p><p id="dd31" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们也可以使用 mergesort 使用的同样的分治算法来解决这个问题。组合并合并两个子数组，直到整个数组排序完毕。这也将给我们一个 O(N log k)的运行时间。</p><p id="ea47" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是一个比较两种不同解决方案的轨迹的例子。</p><p id="8d69" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">分而治之貌似:<br/> </strong>输入:【<br/> 1 - &gt; 2 - &gt; 4、<br/> 1 - &gt; 4 - &gt; 6、<br/> 2 - &gt; 3 - &gt; 5、<br/> 2 - &gt; 6 - &gt; 7 <br/> ]</p><p id="8594" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">1 -&gt; 2 -&gt; 4 <br/> 1 - &gt; 4 - &gt; 6 <br/>合并:1-&gt;1-&gt;2-&gt;4-&gt;4-&gt;6。</p><p id="4676" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">2-&gt; 3-&gt; 5<br/>2-&gt;6-&gt;7<br/>合并:2-&gt;2-&gt;3-&gt;5-&gt;6-&gt;7。</p><p id="346c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">合并两者合并:<br/>1-&gt;1-&gt;2-&gt;2-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6-&gt;6-&gt;7。</p><p id="3c9f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">使用一个 min PQ 看起来像:</strong> <br/>输入:【<br/> 1 - &gt; 2 - &gt; 4、<br/> 1 - &gt; 4 - &gt; 6、<br/> 2 - &gt; 3 - &gt; 5、<br/> 2 - &gt; 6 - &gt; 7 <br/></p><p id="ea5f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Min PQ 包含[1，1，2，2](使用上面的顺序—未排序的顺序)<br/>移除 Min 并添加到列表<br/>我们的链表:<br/> 1</p><p id="03dc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Min PQ 包含[2，1，2，2] <br/>移除 Min 并添加到列表<br/>我们的链表:<br/> 1 - &gt; 1</p><p id="3233" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Min PQ 包含[2，4，2，2] <br/>移除 Min 并添加到列表<br/>我们的链表:<br/> 1 - &gt; 1 - &gt; 2</p><p id="e1c9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">等等..直到 min PQ 为空。</p><p id="6b41" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢阅读，我希望你发现这是有帮助的！</p></div></div>    
</body>
</html>