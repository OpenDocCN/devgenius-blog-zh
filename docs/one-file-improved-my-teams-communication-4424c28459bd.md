# 一个文件改善了我的团队的沟通

> 原文：<https://blog.devgenius.io/one-file-improved-my-teams-communication-4424c28459bd?source=collection_archive---------9----------------------->

![](img/dba12cb827f6090ab5d465f809f07e40.png)

照片由[photo-nic.co.uk NIC](https://unsplash.com/@chiro?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/focus?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

沟通很难。我们都知道。

当我们使用对不同的人可能有不同含义的术语或短语时，交流变得更加困难。每当两个或更多的人试图沟通，每个人都把自己的解释带到桌面上，这就变得复杂了。这一点在时间安排或“新”/“旧”方面尤其明显

让我用一个对话的例子来说明:

*在一个周日的早上…*

詹妮弗:“嘿！下周一起吃午饭好吗？”萨曼莎:“当然可以！我明天有空！”詹妮弗:“明天不行——我是说下周，不是这周……”

虽然上面的对话不是真的，但我相信你也遇到过类似的情况。你和一个朋友或同事对“下周”相对于今天有不同的定义。

几年前，我在软件领域发现了一个类似的问题。我们的团队在会议上浪费时间和精力，试图确定一些事情的相对定义。这导致了沮丧和困惑，迫使我们的团队在几乎每天的 Scrum 会议上讨论这个话题！可悲的是，到了第二天，我们又不得不回到谈判桌前，进行同样的对话，再次解释同样的事情。

出了什么问题？版本！

今天，我想和你分享更多关于这个问题以及如何保持一个——是的，一个！—我们软件存储库中的文件可以帮助您的团队解决这个问题。

*快速提示:术语发布、版本和部署在软件中容易混淆。为了简单起见，在本文中，当我只谈论发布软件版本时，我指的是为软件项目创建一个孤立的“时间点”。这通常是作为礼物标签或下载的工件(或两者)来完成的。我是* ***而不是*** *谈论向客户发布版本。这是非常不同的，它有自己的一系列挑战，我们今天不会讨论。*

# 问题是

几年前我就注意到了这个问题。我们的团队试图整理出我们软件下一版本的特性。我们知道这项工作即将完成，我们想告诉我们的产品负责人在即将到来的版本中将会有什么。

但是后来我们发现了一个漏洞。一个我们需要解决的问题。我们需要尽快推出一个修补程序。我们工作得很快，在新版本发布的一天内就解决了这个问题。

但是有一个微妙的问题。

在创建新版本 so 时，我们对下一个版本**的定义发生了变化！我们的团队只将版本称为“下一个”版本或“上一个”版本。或者在某些情况下是“下一个”🙃**

我们遭受这些的原因是我们的版本不是*可预测的*。我们无法告诉你下一个版本会是什么，即使我们已经完成了下一个版本中我们想要的所有工作！我们使用 git 提交散列和 CI 管道运行的日期的组合作为版本。这意味着我们必须等到 CI 管道创建了版本之后才能知道它实际上是什么。

# 可预测的版本

第一个问题很容易解决:使用可预测的版本。但是你是怎么做到的呢？

有许多方法可以实现这一点。[语义版本](https://semver.org/)是最常见的，但是甚至“year.release.patch”格式的命名版本也可以使用。关键是你知道下一个计划的版本应该是什么。

为什么这有帮助？因为现在，你不再使用“在下一个版本中…”这样的短语，而是开始使用“在 2.3.0 版本中…”虽然这看起来无关紧要，但事实是它将从根本上改变你的沟通。当你有一个具体的名称或标签时，谈论起来就简单多了。

另一个例子可能是你的大家庭。我没有一个非常大的大家庭，但是我可以告诉你，用我叔叔的名字来称呼他比用“我妈妈的双胞胎兄弟”更容易。甚至用“大叔”这个标签更有用。另一个可能是表亲。表哥乔比“我父亲的兄弟的第一个儿子”更容易被提及

# 下一个问题

在发布了可预测的版本号之后，总会有另一个问题:每个版本有什么变化？

在我看来，这个问题有点复杂。团队可以使用许多不同的工具和系统来捕获软件版本的内容。几乎每一个软件跟踪软件系统(如吉拉、ServiceNow、Asana)都有某种方法来跟踪版本的概念；Wiki 可用于获取版本和发布说明；甚至 Google Sheets 都可以用。

然而，我的团队发现**这些解决方案都不起作用**。

为什么？因为那里都是眼不见心不烦。即使我们都同意每当我们完成一个项目的时候，我们都应该写发布说明，但是我们从来不记得这样做。无论我们做了什么，我们仍然疯狂地寻找一个版本中完成的所有项目，并在我们实际发布该版本之前发布发布说明。我们不可避免地会错过笔记中的某个特性或 bug，这给使用我们软件的管理层和其他团队造成了混乱。

# 解决办法？

我们保留了一个变更日志。就是这样。

我们创建了一个新文件(字面意思是 CHANGELOG.md ),然后确保它用有意义的变更的摘要进行了更新。我们甚至构建了一个简单的 GitHub 动作，名为[changelog enforcer](https://github.com/dangoslen/changelog-enforcer)，以保证我们在进行过程中更新文件。然后，我们使用这个文件来生成发布说明，当我们准备好发布一个版本时，我们会将发布说明放入 GitHub 版本中。

结果呢？我们的团队可以具体地谈论我们正在创建的版本以及该版本中将包含哪些项目。当该版本发布时，我们只是发布了该版本的 GitHub 发布链接，以及来自 changelog 的发行说明驱动器！👏

我们的团队经历了更好的沟通、更快的会议和更好的文档！我们为我们的开发团队去掉了“另一件要做的事情”,因为这是开发工作的自然部分。👏 👏

在存储库中保存一个文件能解决所有问题吗？没有。差远了！

但是——如果保持一个变更日志有助于解决一些问题，那么也许你可以花精力解决其他问题。如果你决定尝试这种方法，这里有一些工具可能会有所帮助！

*   [Changelog Enforcer](https://github.com/dangoslen/changelog-enforcer)
*   [**Changelog 阅读器**](https://github.com/mindsers/changelog-reader-action)
*   [**KeepAChangelog**](https://keepachangelog.com/)

编码快乐！

*原发布于*[*https://dango slen . me*](https://dangoslen.me/blog/how-keeping-one-file-improved-my-teams-communication/)*。*