<html>
<head>
<title>TypeScript Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-best-practices-e658600e9d9?source=collection_archive---------1-----------------------#2020-09-25">https://blog.devgenius.io/typescript-best-practices-e658600e9d9?source=collection_archive---------1-----------------------#2020-09-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d8994ba69f414eb4e8b924c4d30b7d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3BlGIviD5_Zlq3-jRaDKg.jpeg"/></div></div></figure><p id="2f02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使代码易于阅读和维护，您应该遵循一些最佳实践。</p><p id="ae85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将谈论一些你应该遵循的最佳实践，以使每个人的生活更轻松。</p><h1 id="33a5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">将函数重载组合在一起</h1><p id="3621" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你可以重载函数。</p><p id="cef3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着一个函数可以有多个函数签名，TypeScript可以检查这些签名。</p><p id="dbe7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让您的生活更轻松，您应该将它们分组在一起，以便于阅读:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6652" class="mf ku in mb b gy mg mh l mi mj">function foo(a: string, b: string): string;<br/><br/>function foo(a: number, b: number): number;<br/><br/>function foo(a: any, b: any): any {<br/>  console.log(a, b);<br/>}</span></pre><h1 id="ff2d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对类成员排序</h1><p id="9082" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以考虑对类成员进行排序，以使成员更容易阅读。</p><p id="36ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过访问修饰符、字母顺序等对它们进行排序。</p><p id="d156" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">坚持一个就好。</p><p id="8c8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，不要写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="42bd" class="mf ku in mb b gy mg mh l mi mj">class Employee {<br/>  private id: string;<br/>  private empCode: number;<br/>  private empName: string;<br/>}</span></pre><p id="558d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ea88" class="mf ku in mb b gy mg mh l mi mj">class Employee {<br/>  private empCode: number;<br/>  private empName: string;<br/>  private id: string;<br/>}</span></pre><p id="b374" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按字母顺序排列。</p><h1 id="a061" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">不要对名称空间使用module关键字</h1><p id="5860" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果您声明了名称空间，那么您应该使用<code class="fe mk ml mm mb b">namespace</code>关键字。</p><p id="e087" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而不是写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="10da" class="mf ku in mb b gy mg mh l mi mj">module Math {<br/>  function add(a: number, b: number): number {<br/>    return a + b;<br/>  }<br/>}</span></pre><p id="e1b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7c71" class="mf ku in mb b gy mg mh l mi mj">namespace Math {<br/>  function add(a: number, b: number): number {<br/>    return a + b;<br/>  }<br/>}</span></pre><p id="a641" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，您就不会将您所拥有的与ES模块混淆。</p><h1 id="3162" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">类成员的可见性声明</h1><p id="f64f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了利用TypeScript的访问控制功能，可以添加可见性声明或类成员。</p><p id="d078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0a98" class="mf ku in mb b gy mg mh l mi mj">class Employee {<br/>  private getSalary(): number {<br/>    return 90000;<br/>  }<br/>}</span></pre><p id="6b38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您添加了<code class="fe mk ml mm mb b">private</code>访问修饰符，这样<code class="fe mk ml mm mb b">getSalary</code>只能被类中的其他方法调用。</p><p id="5a3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一个<code class="fe mk ml mm mb b">public</code>修饰符使成员对外部代码可用。</p><p id="705b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">protected</code>使成员对子类和当前类可用。</p><p id="c70f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">public</code>是默认值。</p><p id="101e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以对实例变量执行相同的操作:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6b1f" class="mf ku in mb b gy mg mh l mi mj">class Employee {<br/>  private empCode: number;<br/>}</span></pre><h1 id="fc28" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">消除任何类型的使用</h1><p id="c09b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以在代码中取消使用<code class="fe mk ml mm mb b">any</code>类型，以利用TypeScript的类型检查功能。</p><p id="0460" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要比静态类型更灵活的东西，有很多方法可以定义它们。</p><p id="e5c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用文本类型将值限制为某些文本。</p><p id="829b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有联合类型可以让您检查多种类型的成员。</p><p id="a82f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">交集类型确保变量具有两种类型的成员。</p><p id="62fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">索引签名允许您检查动态属性。</p><p id="2157" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多方法可以避免<code class="fe mk ml mm mb b">any</code>。</p><p id="f961" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，不要写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e1a4" class="mf ku in mb b gy mg mh l mi mj">let bar: any;</span></pre><p id="51f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="30fc" class="mf ku in mb b gy mg mh l mi mj">let foo: string;</span></pre><h1 id="575d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">没有空界面</h1><p id="eb9a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你的代码中不应该有空的接口，因为它们是无用的。</p><p id="12c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以与其写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1169" class="mf ku in mb b gy mg mh l mi mj">interface I {}</span></pre><p id="b49f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e096" class="mf ku in mb b gy mg mh l mi mj">interface I {<br/>  bar: number;<br/>}</span></pre><h1 id="9236" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">没有for-in循环</h1><p id="fc20" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">for-in循环是遗留的JavaScript语法，现在有了更好的替代方法。</p><p id="f457" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很糟糕，因为您需要使用<code class="fe mk ml mm mb b">hasOwnProperty</code>来检查非继承属性。</p><p id="e735" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更好的选择包括<code class="fe mk ml mm mb b">Object.keys</code>来获得对象的非继承键。</p><p id="9185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">Object.values</code>获取数值，<code class="fe mk ml mm mb b">Object.entries</code>获取所有条目。</p><p id="d85d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以与其写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f09a" class="mf ku in mb b gy mg mh l mi mj">for (const key in obj) {<br/>  if (obj.hasOwnProperty(key)) {<br/>    console.log(obj[key]);<br/>  }<br/>}</span></pre><p id="d271" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7daf" class="mf ku in mb b gy mg mh l mi mj">for (const key in Oject.keys(obj)) {<br/>  console.log(obj[key]);<br/>}</span></pre><h1 id="660b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">没有进口副作用</h1><p id="45c4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><code class="fe mk ml mm mb b">import</code>应该用于导入模块成员和使用它们。</p><p id="8308" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果它们产生副作用，那就不好了，因为很难对代码进行静态分析。</p><p id="6df3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以与其写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="abf5" class="mf ku in mb b gy mg mh l mi mj">import 'foo';</span></pre><p id="abf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c271" class="mf ku in mb b gy mg mh l mi mj">import { bar } from 'foo';</span></pre><p id="c691" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些例外可能是用Webpack作为模块导入CSS。</p><p id="debd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以你仍然可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9dd7" class="mf ku in mb b gy mg mh l mi mj">import 'styles.css';</span></pre><h1 id="ca40" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">没有带有文字值的变量或参数的显式类型声明</h1><p id="033f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于用数字、字符串或布尔值赋值的变量或参数，使用类型声明是多余的。</p><p id="5d81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript可以在没有显式类型的情况下检查这些。</p><p id="0083" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，与其写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b07c" class="mf ku in mb b gy mg mh l mi mj">const foo: number = 10;</span></pre><p id="a698" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f270" class="mf ku in mb b gy mg mh l mi mj">const foo = 10;</span></pre><h1 id="d08a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="65c2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">把东西放在一起便于阅读。</p><p id="cbc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可见性修饰符是一种有用的类型脚本功能。</p><p id="685e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">any</code>类型可以用很多东西代替。</p><p id="40d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe mk ml mm mb b">namespace</code>来声明名称空间代码。</p><p id="41d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天到此为止！</p><p id="2951" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，敬请关注！</p></div></div>    
</body>
</html>