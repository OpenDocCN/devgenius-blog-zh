<html>
<head>
<title>Smart Recomposition Demystified Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能重组去神秘化 Jetpack 组合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/smart-recomposition-demystified-jetpack-compose-a6e3da767504?source=collection_archive---------6-----------------------#2022-06-13">https://blog.devgenius.io/smart-recomposition-demystified-jetpack-compose-a6e3da767504?source=collection_archive---------6-----------------------#2022-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1ac0458649f0859b6f52dcaf17edea4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n35ZJbzGF1KVN8lhLR4eBg.png"/></div></div></figure><p id="9d0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你可能知道的，一个可组合的函数是<em class="kt">可重启的</em>意味着它可以在任何时候被组合运行时执行多次。</p><p id="4324" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，为了一个小变化而重新组合整个屏幕对性能没有好处，因为组合框架具有跳过某些可组合组件或其子可组合组件(也称为 S <strong class="jx io"> <em class="kt">集市组合</em>)的重新组合的机制。</strong></p><blockquote class="ku kv kw"><p id="d329" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">但是它是怎么做到的呢？(一探究竟)</p></blockquote><p id="832a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当你编译一个 compose 应用程序时，编译器会寻找所有用<strong class="jx io"> @Composable </strong>注释声明的函数，并用它们进行一些转换，意思是可组合的，如下所示</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="e26a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">会被转换成类似</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="le lf l"/></div></figure><blockquote class="ku kv kw"><p id="b9fe" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">呜啊..</em> </strong> <em class="in">，冷静下来，我们会更详细地了解</em></p><p id="7c1c" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">注:</strong>转换后的代码并非在所有情况下都相同，可以更复杂也可以更简单，这取决于编译器是否能推断出一些东西并进行优化</p></blockquote><p id="0440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里我们可以看到两个额外的参数，一个是<code class="fe lg lh li lj b">Composer context</code>另一个是<code class="fe lg lh li lj b">changed</code>，它是一个位域，改变的变量告诉我们这个可组合函数的数据是否改变，如果数据改变了，就重新组合，否则就不改变。</p><p id="b66c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">被改变的是一个 32 位的位掩码，组合只使用<code class="fe lg lh li lj b">30</code>位<code class="fe lg lh li lj b">2</code>位代表一个可组合函数的一个参数<code class="fe lg lh li lj b">30/2 = 15</code>意味着一个被改变的变量可以代表<code class="fe lg lh li lj b">15</code>个参数，如果你的函数有不止<code class="fe lg lh li lj b">15</code>个参数，一个被改变的参数可能会被传递<code class="fe lg lh li lj b">changed2</code>等等。</p><p id="9ee1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有<code class="fe lg lh li lj b">0 01 01 11 10 01 11 00 10 10 10 10 10 00 10 10 0</code></p><p id="3aae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的第一位是符号位 compose 忽略它，最后一位是强制更新位<code class="fe lg lh li lj b">0</code>表示不强制重组<code class="fe lg lh li lj b">1</code>表示强制重组</p><p id="1df6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有其他两位组代表该可组合的参数，它们的配置细节如下所示。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="85ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">深潜</strong></p><p id="1fac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们有<code class="fe lg lh li lj b">$changed and 0b0110 === 0</code>这里<code class="fe lg lh li lj b">0b</code>只是说这是二进制编码的<code class="fe lg lh li lj b">0</code>是符号位<code class="fe lg lh li lj b">11</code>表示<strong class="jx io">静态</strong>我们然后<code class="fe lg lh li lj b">and</code>它到<code class="fe lg lh li lj b">$changed</code>。例如，假设<em class="kt">已更改/变脏</em>是<code class="fe lg lh li lj b">0b0011</code></p><p id="131a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lg lh li lj b">0b0011 and 0b0110 -&gt; 0b00 -&gt; 00 (Uncertain)</code></p><p id="13b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以上面的表达式可以简化为<code class="fe lg lh li lj b">if(Uncertain)</code>,所以为了确定，我们做下面的事情</p><p id="78c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lg lh li lj b">$dirty = $dirty or if ($composer.changed(imageResId)) 0b0010 else 0b0100</code></p><p id="cc81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果我们不确定，我们需要通过说<code class="fe lg lh li lj b">$composer.changed(imageResId)</code>来询问作曲者，如果为真，那么我们得到<code class="fe lg lh li lj b">0b0010</code>，它解析为不同的 else <code class="fe lg lh li lj b">0b0100</code>，它解析为相同的 else<code class="fe lg lh li lj b">0b0100</code>，然后我们用<code class="fe lg lh li lj b">$dirty</code>对其进行<code class="fe lg lh li lj b">or</code>。</p><p id="bf27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lg lh li lj b">so $dirty = 0b0010 or 0b0010 -&gt; 01 -&gt; (Same)</code></p><p id="3c0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的示例解析为 Same，但它可以是来自(Static /Same/Different)的任何内容，因此在下一步中，我们通过执行以下操作来检查它。</p><pre class="la lb lc ld gt lk lj ll lm aw ln bi"><span id="beca" class="lo lp in lj b gy lq lr l ls lt">$dirty and 0b1011 xor 0b1010 !== 0 || !$composer.skipping</span></pre><p id="6946" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<code class="fe lg lh li lj b">!$composer.skipping</code>表示运行时无论如何都要重新组合，这在某些情况下可能是真的，我们不在这里讨论这些，我们将关注<code class="fe lg lh li lj b">$dirty and 0b1011 xor 0b1010 !== 0</code></p><p id="40ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们有<code class="fe lg lh li lj b">0b0010 and 0b1011 xor 0b1010 -&gt; 0b0010 xor 0b1011 -&gt; 00</code>，所以条件为真，我们可以跳过重组，好的。</p><p id="b5a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">底层实现可能会随着时间的推移而不同，但它们在某种程度上是组合框架决定哪些可组合组件或部分可组合组件需要重新组合的方式。</p><p id="1d7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢</p></div></div>    
</body>
</html>