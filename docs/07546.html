<html>
<head>
<title>Template pattern for encapsulating algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">封装算法的模板模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/template-pattern-for-encapsulating-algorithms-kotlin-3ded81377fc5?source=collection_archive---------10-----------------------#2022-04-04">https://blog.devgenius.io/template-pattern-for-encapsulating-algorithms-kotlin-3ded81377fc5?source=collection_archive---------10-----------------------#2022-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6bed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di"> N </span>冰再次见到你，花样磨床👋这是我在“设计模式”系列中的第八篇文章。请务必消化所有以前的文章，因为其中包含了大量的信息👀：</p><ul class=""><li id="9b64" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="bd91" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="bca3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="4071" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li><li id="e941" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">单例模式:<a class="ae la" href="/dev-genius/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/singleton-pattern-for-one-of-a-class-objects-Java-a63c 774 d9d 4</a></li><li id="8b25" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">命令模式:<a class="ae la" href="/dev-genius/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/command-pattern-for-encapsulated-invocation-kot Lin-4338 EB 23 D2 ca</a></li><li id="2448" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">适配器和外观模式:<a class="ae la" href="https://medium.com/dev-genius/adapter-facade-pattern-for-perfect-adapting-kotlin-ccbc8f8cfcd6" rel="noopener">https://medium . com/dev-genius/adapter-Facade-pattern-for-perfect-adapting-kot Lin-ccbc 8 f 8 cfcd 6</a></li></ul><p id="4f3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要感谢<a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----3ded81377fc5--------------------------------" rel="noopener" target="_blank">奥赖利媒体</a>的精彩著作，因为它将复杂的东西分解成易于管理的部分:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="6333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="105c" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="4a57" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题</li><li id="4fa0" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">要遵循的设计原则</li><li id="915b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码</li><li id="4474" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外第一部分</li><li id="70a9" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外第二部分</li><li id="763b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="0984" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">模板模式</h1><h2 id="3ca3" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">介绍</h2><p id="883e" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">正如你可能从文章标题中猜到的，这个模式将被用来封装算法。<strong class="jm io">等等……</strong>✋它类似于另一种模式，之前已经介绍过，名为<strong class="jm io">战略模式</strong>。有什么区别？请耐心等待，直到我将逐步浏览的<em class="ne">额外部分</em>。</p><p id="e748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您所看到的，当您已经研究了大量的模式时，您开始在它们的行为中找到相似之处&amp;可以发现不同之处。此外，随着你对面向对象设计越来越有信心，下一个模式会更容易掌握🏋️‍♀️</p><h2 id="5fcc" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">问题</h2><p id="4858" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">让我们假设您需要为某个咖啡馆构建一个系统，那里的两种主要饮料是茶和咖啡。您将使用各自的方法记下两个类:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ff58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你开始发现一些东西，interesting🧐:，有些方法在他们做事的方式上非常相似。在上面的代码中<code class="fe nm nn no np b">boilWater()</code> &amp; <code class="fe nm nn no np b">pourInCup()</code>彼此很相像。</p><blockquote class="nq nr ns"><p id="1a47" class="jk jl ne jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">不要看这里相似的命名，想象一下这些方法包含的<strong class="jm io">相似行为</strong>的想法</p></blockquote><p id="62d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您从我以前的文章中汲取了面向对象的知识(我希望您已经通读了它们！👺)，为下一个重新设计:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f2cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我们创建了一个抽象类，它有<code class="fe nm nn no np b">abstract fun prepareRecipe()</code>。</p><ol class=""><li id="bc8c" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">它由每个子类实现。</li><li id="2204" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">此外，我们将两个相似的方法(在内部做事情的方式上相似)放在<code class="fe nm nn no np b">abstract</code>类中，以减少代码重复。</li><li id="ae9c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">并且<code class="fe nm nn no np b">abstract</code>该方法在每个子类中用另外两个方法实现(每个子类中的数量可能不同)</li><li id="7cda" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">我们调用每个孩子<code class="fe nm nn no np b">prepareRecipe()</code>，它利用了来自<code class="fe nm nn no np b">abstract class</code>的相似方法和来自自己类的独特方法(比如<code class="fe nm nn no np b">addLemon()</code>)</li></ol><p id="cb29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好点了吗？-&gt;是的！我们能做得更好吗？-&gt;是的！🙌</p><p id="6d90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果我们翻转图片呢？我们有做类似事情的孩子，但是这些事情的内容不同。为什么不减少代码重复甚至 more❓</p><p id="3458" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">步骤:</p><ol class=""><li id="3710" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">将<code class="fe nm nn no np b">prepareRecipe()</code>放在<code class="fe nm nn no np b">abstract class</code> &amp;中，使其成为最终状态，以防止任何孩子<strong class="jm io">覆盖</strong>它</li><li id="7762" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">在<code class="fe nm nn no np b">abstract class</code> &amp; <strong class="jm io">中保留类似的子方法，在 Java 中将它们标记为 final</strong>| |在 Kotlin 中什么都不做(大多数情况下，你不希望子方法覆盖它们)</li><li id="676e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">同样在<code class="fe nm nn no np b">abstract class</code>中编写不同的方法，但是使用<code class="fe nm nn no np b">abstract</code>字</li><li id="7680" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">覆盖子元素中的那些<code class="fe nm nn no np b">abstract</code>方法。<br/> PS:别忘了<code class="fe nm nn no np b">extend</code>母 class❗️</li></ol><ul class=""><li id="c68b" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">我们为不同的方法起了一个名字，这个名字描述了它们做事情的整体方式。就像，<code class="fe nm nn no np b">addLemon()</code> &amp; <code class="fe nm nn no np b">addSugarAndMilk()</code>就会有类似<code class="fe nm nn no np b">addCondiment()</code>的东西。我希望你抓住了要点👌</li></ul><p id="8a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们转到设计原则，然后我将对流程进行详细分析🌊</p><h2 id="c8b3" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">要遵循的设计原则</h2><ol class=""><li id="f7ae" class="kr ks in jm b jn mz jr na jv nx jz ny kd nz kh nw kx ky kz bi translated"><strong class="jm io">好莱坞原则</strong> ✨:不要打电话给我们，我们会打电话给你</li></ol><p id="b57c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，这意味着什么呢？我是 bonkers⁉️吗实际上，不是…</p><p id="42ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">more➰准备好了吗？</p><p id="0fca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nm nn no np b">=&gt;</code>它防止我们陷入所谓的“依赖腐烂”。这是什么意思？</p><p id="4991" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">高层组件(我们的<code class="fe nm nn no np b">abstract class</code>)依赖于低层组件(子组件:<code class="fe nm nn no np b">Tea &amp; Coffee</code>)。然后，这些低级组件在某种程度上又依赖于高级组件，on…➿➿➿也是如此</p><p id="5eae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你声称:“我不相信你，证明一下！!"👿我们走吧:</p><p id="1bdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看最后一段代码(在解释正确的设计之前)</p><ol class=""><li id="e897" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">低级组件覆盖<code class="fe nm nn no np b">prepareRecipe()</code>方法= &gt;高级组件依赖低级</li><li id="4939" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">在<strong class="jm io">被覆盖的方法内</strong>子调用一些来自高层组件的方法= &gt;低层组件依赖高层</li></ol><p id="fff2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我现在证明给你看了吗？🤯</p><p id="162d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更正确的做法是让<strong class="jm io">高层组件</strong>调用所有<strong class="jm io">低层组件</strong>，即父组件控制显示/调用子组件(随便你怎么命名)。</p><p id="b2de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们继续进行代码演练，在这里我将给出一个详细的运行过程，并演示这个原则的实际应用🔥</p><h2 id="b007" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">最终解决方案代码</h2><p id="2526" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">访问我的回购看看所有的 code☄️:</p><div class="oa ob gp gr oc od"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/8_TemplatePattern" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/8 _ template pattern at main…</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">Kotlin + Medium 文章中的设计模式。通过以下方式为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or os od"/></div></div></a></div><p id="11f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">行こう！</p><ol class=""><li id="b383" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated"><code class="fe nm nn no np b">main.kt</code>是我们实例化两个子类的文件:<code class="fe nm nn no np b">Tea</code> &amp; <code class="fe nm nn no np b">Coffee</code></li><li id="8f36" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe nm nn no np b">HighLevelComponent.kt</code>我们的高级组件是前面提到的吗？</li><li id="597c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe nm nn no np b">LowLevelComponentOne.kt</code> &amp; <code class="fe nm nn no np b">LowLevelComponentTwo.kt</code>都是我们的低级组件</li></ol><p id="4774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">So⚙️:</p><ol class=""><li id="d567" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">我们创建了两个子类，它们是主类的子类</li><li id="51a7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">然后我们从上面调用<code class="fe nm nn no np b">mainMethod()</code>也就是我们的<code class="fe nm nn no np b">createRecipe()</code></li></ol><p id="6ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">‼️ <strong class="jm io">迂回:</strong> ‼️当我们触发这个方法的时候，它会转到父节点。然后父类按顺序调用方法:没有<code class="fe nm nn no np b">abstract</code>的方法来自父类，有<code class="fe nm nn no np b">abstract</code>的方法来自子类，<strong class="jm io">是子类覆盖的</strong>。</p><ul class=""><li id="20d2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">在 Java 中，你需要在这个主方法附近写<code class="fe nm nn no np b">final</code>。在 Kotlin 中，方法已经是最终的了，因此不要写任何东西</li><li id="9e04" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">可以看到，<em class="ne">高层组件</em>调用<em class="ne">低层组件</em>，即父组件的方法触发子组件所需的方法。所以，孩子依赖于<em class="ne">高层组件</em>。他们被称为</li></ul><blockquote class="nq nr ns"><p id="1456" class="jk jl ne jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">高级组件将算法保存在整个动作集的<strong class="jm io">主方法</strong>中</p></blockquote><p id="54e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果，又一次😪，<em class="ne">高层次的</em> <em class="ne">组件</em>运行这个节目，我们已经将<strong class="jm io">代码重复</strong>减少到最小。其他方法可以很容易地挂钩👍</p><h2 id="5f89" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">额外第一部分</h2><p id="4c48" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">说到钩子…🔧</p><p id="3441" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想给孩子们额外的功能呢？例如:</p><ul class=""><li id="a5c5" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">允许他们根据用例定义或不定义方法？</li></ul><p id="4eb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有答案-&gt; <strong class="jm io">勾</strong>🤟</p><p id="348b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是钩子？-&gt;父类中有默认实现的方法，例如<code class="fe nm nn no np b">return true</code>，或者根本没有实现。</p><ul class=""><li id="69dd" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">Java 中一般不标注为<code class="fe nm nn no np b">final</code>，但 Kotlin 中需要标注<code class="fe nm nn no np b">open</code></li><li id="4711" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">子类可以自由地实现它或者保持原样</li><li id="1c9d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">要使用<strong class="jm io">钩子</strong> - &gt;在子类中覆盖它</li></ul><p id="4e99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的 my repo 中，导航到<code class="fe nm nn no np b">HighLevelComponent.kt</code>，其中<code class="fe nm nn no np b">thirdMethod()</code>是一个<strong class="jm io">钩子</strong>的例子。<code class="fe nm nn no np b">LowLevelComponentOne</code>定义了钩子，但<code class="fe nm nn no np b">LowLevelComponentTwo</code>保持原样。</p><h2 id="ad4b" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">额外第二部分</h2><p id="1ff3" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">正如我在开始时所承诺的，我将明确区分<strong class="jm io">策略</strong> &amp; <strong class="jm io">模板</strong>模式。</p><p id="1d5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种模式在外观上有些相似，但让我们在它们之间画一条独特的线:</p><ol class=""><li id="f6ae" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated"><strong class="jm io">模板</strong>定义了一个算法，其步骤有时会被子代覆盖。<strong class="jm io">策略</strong>定义了一系列可互换的算法(通过<strong class="jm io">对象组合</strong>完成)</li></ol><p id="d001" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道知道，很抽象😵看看我的文章<strong class="jm io">战略模式</strong>(如果你还没有😬):<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></p><p id="88db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">代码演练</strong>中，你可以看到我们的子类<code class="fe nm nn no np b">King</code>或<code class="fe nm nn no np b">Queen</code>与父类<code class="fe nm nn no np b">Character</code>有关系。但是每个孩子都有自己的算法来用武器完成一系列想要的动作。通过<strong class="jm io">对象组合</strong>完成。</p><p id="25b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，孩子们主宰着表演，而<code class="fe nm nn no np b"> abstract class</code>给出了一个总体结构，仅此而已。</p><p id="5261" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，<strong class="jm io">模板模式</strong>比<strong class="jm io">策略</strong>更加依赖，因为孩子在<strong class="jm io">策略</strong>下，他们更加自由。</p><blockquote class="nq nr ns"><p id="d5eb" class="jk jl ne jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">因此，T 模式使用继承(IS-A)，而 S 模式利用组合(HAS-A)</p></blockquote><h2 id="691f" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">图画🤩</h2><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><div class="gh gi ot"><img src="../Images/0915dbcbdaf566992b9e75c8936a8d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3twYckKuLM9eFkcwvasEA.jpeg"/></div></div></figure><p id="90fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像往常一样，我在白板上涂鸦来吸收整体设计🤯在中间你可以看到<em class="ne">高级组件</em>，而在左边&amp;到右边<em class="ne">低级组件</em>。</p><ul class=""><li id="8d40" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">此外，我已经展示了与<strong class="jm io">挂钩</strong>的区别</li></ul><h2 id="93d3" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">结尾部分</h2><blockquote class="nq nr ns"><p id="b50f" class="jk jl ne jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">模板模式的学术定义:在方法中保留算法的框架，允许子类自己定义特定的步骤。尽管子类可以重新定义算法中的某些步骤，但它们不能改变主结构</p></blockquote><p id="b869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我相信这篇文章与前一篇相比要轻松一些🤕同样，如果你没有得到什么，就在评论里留言吧！</p><p id="8ebd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="129c" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="dead" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="84c1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:<a class="ae la" href="https://leetcode.com/SleeplessChallenger/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/SleeplessChallenger/</a></li><li id="7720" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>