<html>
<head>
<title>Object-Oriented vs Functional Programming with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象与使用类型脚本的函数式编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-vs-functional-programming-with-typescript-6b2243bb8c4b?source=collection_archive---------0-----------------------#2020-10-20">https://blog.devgenius.io/object-oriented-vs-functional-programming-with-typescript-6b2243bb8c4b?source=collection_archive---------0-----------------------#2020-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/28159a3b01e4dce16e2fd357a92eee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rh5T6BnPa6KkncF5UtibQ.png"/></div></div></figure><p id="e974" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面向对象还是函数式编程？</p><p id="8cfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面向对象vs函数式编程怎么样？<br/>如果你认为面向对象更好，那你就完全错了:)<br/>如果你认为函数式编程，那你就大错特错了；)</p><p id="34d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个层面上讨论编程范式就像讨论艺术一样。<br/>解决一个问题总有不止一种方法，尤其是在Javascript中，讨论这些事情很好，但没有绝对的答案。</p><p id="ef94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你做的每一个决定都会有一个取舍。<br/>让我们先来看看一些函数式的类型脚本代码。</p><h1 id="df7d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">纯函数</h1><p id="4b95" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函数式编程中最重要的概念是纯函数的概念。这意味着函数的输出应该只依赖于它的输入。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="760f" class="mf ku in mb b gy mg mh l mi mj">let num = 123;<br/>function toString(val) {<br/>    return val.toString();<br/>}</span></pre><p id="8f79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个名为<code class="fe mk ml mm mb b">toString()</code>的函数，它接受一个值作为参数，然后返回一个字符串格式的值。我们可以通过直接改变数字变量来使这个函数不纯。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8d35" class="mf ku in mb b gy mg mh l mi mj">let num = 123;<br/>function toString(val) {<br/>    num = val;<br/>    ...<br/>}</span></pre><p id="b22b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将被认为是一个副作用，功能代码应该不会产生副作用。此外，他们不应该依赖任何外部价值来产生一个返回值。纯函数更容易测试，也更容易推理，因为您不必考虑函数本身之外发生的任何事情。</p><h1 id="9c5e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">不可变数据</h1><p id="b4f1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函数式编程的另一个核心原则是不可变数据。功能代码是无状态的，这意味着当数据被创建时，它永远不会改变。例如，我们有:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="17f1" class="mf ku in mb b gy mg mh l mi mj">const data = [1,2,3,4,5,6];</span></pre><p id="2a21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在Javascript中通过在这个数字数组上使用<code class="fe mk ml mm mb b">Object.freeze</code>来模拟这一点。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5750" class="mf ku in mb b gy mg mh l mi mj">const data = Object.freeze([1,2,3,4,5]);</span></pre><p id="6fcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以绕过这一点，但它阻止我们做像数组推送这样的事情，而这在函数式程序中是做不到的。所以很明显，如果我们有一个动态的软件应用程序，我们的数据必须以某种方式改变，所以你会经常把函数作为参数传递给其他函数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0259" class="mf ku in mb b gy mg mh l mi mj">const addEmoji = (val) =&gt; toString(val) + ' 😃';</span></pre><p id="2a5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们有一个典型的一阶函数，它接受一个值，然后返回一个不同的值。在这种情况下，只需将表情符号附加到字符串上。</p><p id="21f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">高阶函数要么接受一个函数作为参数，要么自己返回一个函数。Javascript有一些非常好的内置高阶数组函数，比如map。因此，我们可以不使用for循环，而是将我们的函数传递给map，它将对数组中的每个元素运行add emoji函数并转换值。这给了我们一个非常简洁优雅的方法来转换数组中的值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f310" class="mf ku in mb b gy mg mh l mi mj">const emojiData = data.map(addEmoji);<br/>console.log(emojiData);  // ['1 😃', '2 😃', '3 😃', '4 😃', '5 😃']</span></pre><p id="8d74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以做的另一件很酷的事情是创建返回函数的函数。当您想从一些基本功能开始，然后用一些动态数据扩展它时，这非常有用。</p><p id="8cd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设我们正在构建一个天气应用程序，我们需要添加带有特定表情符号的字符串。我们将从一个名为<code class="fe mk ml mm mb b">appendEmoji</code>的基本函数开始，然后用它来组成更复杂的函数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6d18" class="mf ku in mb b gy mg mh l mi mj">const appendEmoji = (fixed) =&gt; (dynamic) =&gt; fixed + dynamic;</span></pre><p id="8616" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在这种情况下，内部函数接受两个参数并将它们相加。我们可以利用这一点来创建更多指向特定表情符号的专门功能。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0e63" class="mf ku in mb b gy mg mh l mi mj">const rain = appendEmoji('🌧️');<br/>const sun = appendEmoji('️🌞');</span><span id="334c" class="mf ku in mb b gy mn mh l mi mj">console.log(rain(' today'))  // ️🌧️ ️️today<br/>console.log(sun(' tomorrow'))  // ️🌞 tomorrow</span></pre><p id="e3ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们有一个rain函数和一个sun函数，然后我们可以用我们想要附加表情符号的字符串调用这个函数。最终的结果是一些简洁易读的代码，它们不依赖于任何共享状态，共享状态会使测试变得困难。对于函数式编程来说，这是最基本的，当你有异步数据和副作用之类的东西时，事情会变得有趣得多。</p><p id="f269" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在让我们继续，并将其与面向对象编程进行比较。</p><p id="6989" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要做的第一件事是定义一个类，它本身并不做任何事情，而是作为实例化对象的蓝图，因此这个表情类的实例将是一个具有图标属性的对象。那么构造函数方法是特殊的，因为它在对象被实例化时运行一次。它会将一个参数传递给带有实际表情图标的构造函数，然后我们会将该参数设置为该对象的属性。像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="996f" class="mf ku in mb b gy mg mh l mi mj">class Emoji {<br/>    icon: string;<br/>    <br/>    constructor(icon) {<br/>        this.icon = icon;<br/>    }<br/>}</span><span id="6e0a" class="mf ku in mb b gy mn mh l mi mj">const sun = new Emoji('️🌞')</span><span id="91b6" class="mf ku in mb b gy mn mh l mi mj">console.log(sun) // Emoji { icon: '️🌞' }</span></pre><p id="adf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表情符号类的工作方式类似于一个函数，但是我们在它前面使用了新的关键字。正如你所看到的，当我们这样做时，它创建了一个具有sun图标属性的表情符号对象。在typescript中有一种更简单的方法，因为我们有公共和私有成员的概念。因此，如果我们在构造函数中的参数前面使用public关键字，typescript将自动知道将它设置为每个对象的公共属性。当您将属性或方法声明为public时，这意味着它对该类本身和该类的任何实例都是可用的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="718e" class="mf ku in mb b gy mg mh l mi mj">class Emoji {<br/>    constructor(public icon) {}<br/>}</span></pre><p id="601f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能是一件好事，也可能是一件坏事。例如，我们可以通过改变图标对象的值来改变图标。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="391a" class="mf ku in mb b gy mg mh l mi mj">const sun = new Emoji('️🌞')<br/>sun.icon = '🌧️'<br/>console.log(sun) // Emoji { icon: '🌧️' }</span></pre><p id="bdaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一方面，这非常方便，但另一方面，如果有大量代码这样做，就很难跟踪，也很难有效地测试。</p><p id="a909" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Typescript还为我们提供了一些工具来改善我们在编写面向对象代码时的语气。例如，我们可以将成员标记为私有，这样它们只能在这个类定义中使用。这意味着我们可以将公共API从这个类的内部逻辑中分离出来。例如，如果我们想使这个图标值可变，我们可以使它私有，我们将定义一个getter，这样用户可以读取值，但不能改变值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c254" class="mf ku in mb b gy mg mh l mi mj">class Emoji {<br/>    constructor(private _icon) {}</span><span id="2480" class="mf ku in mb b gy mn mh l mi mj">    get icon() {<br/>        return this._icon;<br/>    }<br/>}</span></pre><p id="bb54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里要指出的另一件重要的事情是，类实例可以有自己的内部状态。让我们想象一下，我们有一个按钮，用户可以切换表情符号，并在不同的状态之间来回切换。这是实现面向对象编程的一件非常简单的事情。</p><p id="dad2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将向这个类添加另一个私有属性previous，然后使用一个getter来检索该值，然后我们将定义一个change方法，该方法将改变这个实例上的实际图标值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6421" class="mf ku in mb b gy mg mh l mi mj">class Emoji {</span><span id="0417" class="mf ku in mb b gy mn mh l mi mj">    private _prev;</span><span id="6073" class="mf ku in mb b gy mn mh l mi mj">    constructor(private _icon) {}</span><span id="bc32" class="mf ku in mb b gy mn mh l mi mj">    get icon() {<br/>        return this._icon;<br/>    }</span><span id="21d2" class="mf ku in mb b gy mn mh l mi mj">    get prev() {<br/>        return this._prev;<br/>    }</span><span id="eac1" class="mf ku in mb b gy mn mh l mi mj">    change(val) {<br/>        this._prev = this._icon;<br/>    }<br/>}</span></pre><p id="ec8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当这种情况发生时，我们将首先将先前的值更改为当前图标，然后将当前图标更新为新值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="33ac" class="mf ku in mb b gy mg mh l mi mj">const emoji = new Emoji('️🌞')</span><span id="a78f" class="mf ku in mb b gy mn mh l mi mj">console.log(emoji.icon, emoji.prev) // ️🌞 undefined</span></pre><p id="171d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一个控制台日志中，我们得到了太阳图标和未定义的和</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9b41" class="mf ku in mb b gy mg mh l mi mj">emoji.change('🌧️');<br/>emoji.change('🌪️');</span><span id="cca8" class="mf ku in mb b gy mn mh l mi mj">console.log(emoji.icon, emoji.prev) // '🌪️', '🌧️'</span></pre><p id="208a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们像上面一样改变状态几次，你可以看到这个类实例的内部值已经改变了。</p><h1 id="10e0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">静态方法</h1><p id="b9e5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以对类做的另一件很酷的事情是定义静态方法。</p><p id="9a4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">方法的独特之处在于它在类本身上，而不是在类的实例上。所以我们将在这里定义一个静态方法，它本身实际上是一个纯函数，它的工作只是简单地给输入参数加一。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3c46" class="mf ku in mb b gy mg mh l mi mj">class Emoji {<br/>    static addOneTo(val) {<br/>        return 1 + val;<br/>    }<br/>}</span></pre><p id="f88a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以使用Emoji类作为名称空间来运行这个函数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="023a" class="mf ku in mb b gy mg mh l mi mj">Emoji.addOneTo(3);</span></pre><p id="8af4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们要换个话题，谈谈代码重用的组合和继承。这是一个人们倾向于获得非常强烈的意见的领域，而组成的实际定义往往有点令人费解。让我们来看一个继承的例子。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6fa1" class="mf ku in mb b gy mg mh l mi mj">class Human {</span><span id="1ba8" class="mf ku in mb b gy mn mh l mi mj">    constructor(public name) {}</span><span id="d554" class="mf ku in mb b gy mn mh l mi mj">    sayHi() {<br/>        return `Hello, ${this.name}`;<br/>    }<br/>}</span><span id="08f5" class="mf ku in mb b gy mn mh l mi mj">const patrick = new Human('Patrick Mullot')</span><span id="56a6" class="mf ku in mb b gy mn mh l mi mj">console.log(patrick.sayHi()); // Hello, Patrick Mullot</span></pre><p id="a060" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们的程序中有很多其他的对象，它们是相似的，但是基于它们的设计用途，实现了稍微不同的特性。例如，在一个电子游戏中，你可能有一个人类角色，然后是一个超级人类角色，拥有人类所有的能力，但有一些额外的东西。<br/>在typescript中，我们可以简单地从human类继承所有功能，就像这样说<code class="fe mk ml mm mb b">SuperHuman extends human</code>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b8b1" class="mf ku in mb b gy mg mh l mi mj">class SuperHuman extends Human {<br/>    <br/>    heroName;</span><span id="8c74" class="mf ku in mb b gy mn mh l mi mj">    constructor(name) {<br/>        super(name);<br/>    }<br/>}</span></pre><p id="1705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们调用<code class="fe mk ml mm mb b">super</code>，它将执行父类的构造函数中的代码，在我们的例子中，它只是初始化这个name属性。</p><p id="0306" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们可以继续定义一个叫做<code class="fe mk ml mm mb b">superpower()</code>的额外方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2f30" class="mf ku in mb b gy mg mh l mi mj">class SuperHuman extends Human {<br/>    <br/>    heroName;</span><span id="5986" class="mf ku in mb b gy mn mh l mi mj">    constructor(name) {<br/>        super(name);<br/>        this.heroName = `HERO ${name}`;</span><span id="6122" class="mf ku in mb b gy mn mh l mi mj">    superpower() {<br/>        return `${this.heroName} pops treys 🔥🔥🔥`<br/>    }<br/>}</span><span id="351e" class="mf ku in mb b gy mn mh l mi mj">const steph = new SuperHuman('Steph Curry');</span><span id="7976" class="mf ku in mb b gy mn mh l mi mj">console.log(steph.superpower()) // HERO Steph Curry pops treys 🔥🔥🔥</span></pre><p id="3686" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，<code class="fe mk ml mm mb b">SuperHuman</code>仍然可以调用父类中定义的所有方法。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="adee" class="mf ku in mb b gy mg mh l mi mj">console.log(steph.sayHi()) // Hello, Steph Curry</span></pre><p id="af0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在正确的情况下继承是很好的，但是你要避免创建真正深度嵌套的类，因为当中间某处出错时，调试变得非常困难。作为一种选择，我们可以使用组合，实际上有多种不同的方式可以应用这种模式。另一种方法是将对象连接在一起。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4503" class="mf ku in mb b gy mg mh l mi mj">const hasName = (name) =&gt; {<br/>    return { name }<br/>}</span><span id="337d" class="mf ku in mb b gy mn mh l mi mj">const canSayHi = (name) =&gt; {<br/>    return {<br/>        sayHi: () =&gt; `Hello, ${name}`<br/>    }<br/>}</span></pre><p id="ae49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的想法是将您的属性或行为解耦到返回对象的对象或函数中。然后，我们可以将所有这些对象合并成一个最终的函数，完成我们需要它做的所有事情。这通常被称为mixin模式，它只是某种类型的多重继承。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1e75" class="mf ku in mb b gy mg mh l mi mj">const Person = function(name) {<br/>    return {<br/>        ...hasName(name),<br/>        ...canSayHi(name)<br/>    }<br/>}</span><span id="44a9" class="mf ku in mb b gy mn mh l mi mj">const person = Person('Jeff')<br/>console.log(person.sayHi()) // Hello, Jeff</span></pre><p id="d80a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种mixin模式可能非常强大，但是在目前的形式下，我们失去了基于类的面向对象编程的所有人机工程学。这可能是一件好事或坏事，取决于你问谁，但是typescript实际上给了我们在基于类的格式中使用mixins的灵活性。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fd18" class="mf ku in mb b gy mg mh l mi mj">class CanSayHi {<br/>    name;</span><span id="2f18" class="mf ku in mb b gy mn mh l mi mj">    sayHi() {<br/>        return `Hello, ${this.name}`;<br/>    }<br/>}</span><span id="49f9" class="mf ku in mb b gy mn mh l mi mj">class HasSuperPower {<br/>    heroName;<br/>    <br/>    superpower() {<br/>        return `${this.heroName} 🔥🔥🔥`;<br/>    }<br/>}</span><span id="9fe5" class="mf ku in mb b gy mn mh l mi mj">class SuperHero implements CanSayHi, HasSuperPower {<br/>    <br/>    heroName;</span><span id="7d45" class="mf ku in mb b gy mn mh l mi mj">    constructor(public name) {<br/>        this.heroName = `SUPER ${name}`;<br/>    }<br/>   <br/>    sayHi: () =&gt; string;<br/>    superpower: () =&gt; string;<br/>}</span></pre><p id="67e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们没有扩展类，而是实现了多个类。当你实现一个东西时，你只关心它的接口，而不是它的底层代码。我们在最开始定义的apply mixins函数将实际获取这些接口并将它们的代码应用到这个类中。最后一步是调用apply mixins函数，将基类作为第一个参数，将混合类作为第二个参数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cfaa" class="mf ku in mb b gy mg mh l mi mj">applyMixins(SuperHero, [CanSayHi, HasSuperPower]);</span><span id="74ed" class="mf ku in mb b gy mn mh l mi mj">const ts = new SuperHero('TypeScript')</span><span id="e05d" class="mf ku in mb b gy mn mh l mi mj">console.log(ts.superpower()) // SUPER TypeScript 🔥🔥🔥</span></pre><p id="e4f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在终于可以回答问题了！</p><p id="fd29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你的答案是什么？</p><h1 id="1d6f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="e9b4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">总是由程序员或开发人员来选择正确的编程语言概念，使他们的开发更高效、更容易。:)</p></div></div>    
</body>
</html>