<html>
<head>
<title>Getting started with documents and indexes on Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elasticsearch 文档和索引入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/handling-documents-and-indexes-on-elasticsearch-dd2690775d4f?source=collection_archive---------16-----------------------#2022-08-24">https://blog.devgenius.io/handling-documents-and-indexes-on-elasticsearch-dd2690775d4f?source=collection_archive---------16-----------------------#2022-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ce34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇文章中，我们已经看到了如何在你的 PC 上本地安装 Elasticsearch 和 Kibana <a class="ae ki" href="https://medium.com/@mhdabdel151/elasticsearch-and-kibana-on-windows-lets-get-started-ff005f1fe2fc" rel="noopener">或者使用</a><a class="ae ki" href="https://medium.com/@mhdabdel151/run-elasticsearch-and-kibana-as-docker-containers-c5f5f5460afd" rel="noopener"> Docker 容器</a>。今天我们将运行我们的第一个<strong class="jm io">查询</strong>并引入<strong class="jm io">索引</strong>。</p><p id="c39c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦启动，你可以在所谓的<strong class="jm io">开发工具</strong>界面上与 Elasticsearch 互动，这是一个直接向 Elasticsearch 发送请求的控制台。我建议您在阅读本文时运行查询，以熟悉 Elasticsearch。所以从 Kibana 打开开发工具控制台。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/0047b126fd8844787a0d87bb17472bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLJ-p7cZHPIPRa604U9E_A.png"/></div></div></figure><p id="6a8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在向您展示如何使用 Elasticsearch 之前，让我们看看数据是什么样子的。<br/> <strong class="jm io">文档</strong>用于存储数据。文档是一个带有键和值的 JSON 对象。例如:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="6fc1" class="la lb in kw b gy lc ld l le lf">{<br/>  "name": "Jane Doe",<br/>  "gender": "female"<br/>}</span></pre><p id="7a4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要发送它，我们可以使用 Elasticsearch 提供的<a class="ae ki" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank">REST API</a>。这里我们想要保存文档，所以我们使用<strong class="jm io"> PUT </strong>，然后我们指定<em class="lg">端点</em>。端点是将存储数据的索引的名称。例如这里我们选择'<em class="lg">汽车'</em>作为索引。我们还必须指定它是一个文档，并给它一个<em class="lg"> id </em>。发送后，<strong class="jm io"> </strong>下面的请求将要求将新创建的文档添加到弹性搜索中，在<em class="lg">汽车</em>索引中使用<em class="lg"> id </em> ' <em class="lg"> 1 </em>'。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="7be5" class="la lb in kw b gy lc ld l le lf">PUT cars/_doc/1<br/>{<br/>  "brand": "Volkswagen",<br/>  "owner": "Lewandowski",<br/>  "color": "black"<br/>}</span></pre><p id="f26a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为回答，Elasticsearch 通知我们，该文档已被添加到指定的索引中，其版本为<strong class="jm io"> <em class="lg">【版本 1】</em></strong>，因为我们刚刚创建了该文档，并且<strong class="jm io"> <em class="lg">结果</em> </strong>字段将通知我们刚刚执行的操作，此处为<em class="lg">创建</em>。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="3f2b" class="la lb in kw b gy lc ld l le lf">{<br/>  "_index": "cars",<br/>  "_id": "1",<br/>  "_version": 1,<br/>  "result": "created",<br/>  "_shards": {<br/>    "total": 2,<br/>    "successful": 1,<br/>    "failed": 0<br/>  },<br/>  "_seq_no": 0,<br/>  "_primary_term": 1<br/>}</span></pre><p id="4aee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果我们仅仅通过改变汽车的<em class="lg">品牌</em>来重新启动相同的查询，我们得到如下响应:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="6126" class="la lb in kw b gy lc ld l le lf">{<br/>  "_index": "cars",<br/>  "_id": "1",<br/>  "_version": 2,<br/>  "result": "updated",<br/>  "_shards": {<br/>    "total": 2,<br/>    "successful": 1,<br/>    "failed": 0<br/>  },<br/>  "_seq_no": 1,<br/>  "_primary_term": 1<br/>}</span></pre><p id="9c1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的操作成功执行，我们注意到字段<strong class="jm io"> <em class="lg">结果</em> </strong>告诉我们执行的操作是<em class="lg">更新</em>，版本<strong class="jm io"><em class="lg"/></strong>已经更改为<strong class="jm io"> <em class="lg"> 2 </em> </strong>，因为这是对该文档进行的第二次操作。我们可以通过使用<strong class="jm io"> GET </strong>后跟<em class="lg"> index </em>，然后是<em class="lg"> _doc </em>来检索这个文档，以表明我们想要检索一个文档，最后是它的<em class="lg"> id </em>。请求如下:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="f2f2" class="la lb in kw b gy lc ld l le lf">GET cars/_doc/1</span></pre><p id="8698" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为回报，我们得到:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="d40a" class="la lb in kw b gy lc ld l le lf">{<br/>  "_index": "cars",<br/>  "_id": "1",<br/>  "_version": 2,<br/>  "_seq_no": 1,<br/>  "_primary_term": 1,<br/>  "found": true,<br/>  "_source": {<br/>    "brand": "Maserati",<br/>    "owner": "Lewandowski",<br/>    "color": "black"<br/>  }<br/>}</span></pre><p id="4e37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lg"> true </em>上的<strong class="jm io"> <em class="lg"> found </em> </strong>字段告诉我们已经找到了该文档，并且<strong class="jm io"> <em class="lg"> _source </em> </strong>正好包含我们的文档。</p><p id="a628" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在添加和检索文档之后，还可以修改文档的单个字段，例如它的所有者。上面使用的<strong class="jm io"> PUT </strong>请求允许我们更改品牌，但是我们必须再次提供其他属性，否则它们将被删除。我们能做的是使用<strong class="jm io"> <em class="lg"> _update </em> </strong>端点并指定文档的<strong class="jm io"> <em class="lg"> id </em> </strong>的<strong class="jm io"> POST </strong>请求。<br/>操作如下所示:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="0089" class="la lb in kw b gy lc ld l le lf">POST cars/_update/1<br/>{<br/>  "doc": {<br/>    "owner": "Ronaldo"<br/>  }<br/>}</span></pre><p id="62e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过对文档执行一个<strong class="jm io"> GET </strong>操作，您可以验证 owner 属性是否已经更新，其他属性是否仍然存在并且没有更改。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="edd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来谈谈 Elasticsearch 中的<strong class="jm io">索引</strong>。索引有两个概念需要牢记:<strong class="jm io"> <em class="lg">数据分布</em> </strong>和<strong class="jm io"> <em class="lg">数据模式存储</em> </strong>。</p><h2 id="4a8d" class="la lb in bd lo lp lq dn lr ls lt dp lu jv lv lw lx jz ly lz ma kd mb mc md me bi translated">数据模式存储</h2><p id="29c9" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">有些人可能认为 Elasticsearch 是<em class="lg">无模式的</em>，因为我们从一开始就没有指定模式，但事实并非如此。在每次文档索引时，会自动生成一个模式，可以使用<strong class="jm io"> <em class="lg"> _mapping </em> </strong>端点来检索该模式。例如，我们的汽车指数:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="f3f6" class="la lb in kw b gy lc ld l le lf">GET cars/_mapping</span></pre><p id="aff9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为回应，我们得到我们的模式:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="31c5" class="la lb in kw b gy lc ld l le lf">{<br/>  "cars": {<br/>    "mappings": {<br/>      "properties": {<br/>        "brand": {<br/>          "type": "text",<br/>          "fields": {<br/>            "keyword": {<br/>              "type": "keyword",<br/>              "ignore_above": 256<br/>            }<br/>          }<br/>        },<br/>        "color": {<br/>          "type": "text",<br/>          "fields": {<br/>            "keyword": {<br/>              "type": "keyword",<br/>              "ignore_above": 256<br/>            }<br/>          }<br/>        },<br/>        "owner": {<br/>          "type": "text",<br/>          "fields": {<br/>            "keyword": {<br/>              "type": "keyword",<br/>              "ignore_above": 256<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h2 id="6fcc" class="la lb in bd lo lp lq dn lr ls lt dp lu jv lv lw lx jz ly lz ma kd mb mc md me bi translated">数据分布</h2><p id="e761" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">让我们检查一下集群，看看我们有多少个 Elasticsearch 节点:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="9ec9" class="la lb in kw b gy lc ld l le lf">GET _cat/nodes</span><span id="7a01" class="la lb in kw b gy mk ld l le lf">// response<br/>127.0.0.1 52 87 5    cdfhilrmtsz * DESKTOP-8LF96VK</span></pre><p id="4375" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，目前只有一台机器在运行 Elasticsearch。Elasticsearch 将在创建索引时生成所谓的“<strong class="jm io"> <em class="lg">”碎片</em></strong>“<em class="lg">”(参见将分发数据的块)</em>，以便传播数据。默认情况下，每个节点只创建一个<em class="lg">(该参数可以更改)</em>。其优势在于，我们可以创建这些碎片的精确副本，称为<strong class="jm io"> <em class="lg">副本</em> </strong>，并且我们必须确保这些副本不在相同的节点上，因此如果一个节点崩溃，由于已经制作了副本，我们总是可以恢复数据。为了获得我们的索引的<em class="lg">设置</em>，我们可以:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="1bf7" class="la lb in kw b gy lc ld l le lf">GET cars/_settings</span><span id="7cd7" class="la lb in kw b gy mk ld l le lf">// output<br/>{<br/>  "cars": {<br/>    "settings": {<br/>      "index": {<br/>        "routing": {<br/>          "allocation": {<br/>            "include": {<br/>              "_tier_preference": "data_content"<br/>            }<br/>          }<br/>        },<br/>        "number_of_shards": "1",<br/>        "provided_name": "cars",<br/>        "creation_date": "1661376650544",<br/>        "number_of_replicas": "1",<br/>        "uuid": "l1hnyMG-RVe7B1F_qxzEsA",<br/>        "version": {<br/>          "created": "8030399"<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2cb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到我们的索引有一个碎片和一个副本。现在让我们通过运行以下命令来删除我们的索引:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="f497" class="la lb in kw b gy lc ld l le lf">DELETE cars</span></pre><p id="0fb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并通过指定例如设置(如碎片数量和副本数量以及映射<em class="lg"/>)来重新创建一个新的</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="dbd5" class="la lb in kw b gy lc ld l le lf">PUT cars<br/>{<br/>  "settings": {<br/>    "number_of_shards": 2,<br/>    "number_of_replicas": 1<br/>  },<br/>  "mappings": {<br/>    "properties": {<br/>      "brand": {<br/>        "type": "text"<br/>      },<br/>      "owner": {<br/>        "type": "text"<br/>      },<br/>      "color": {<br/>        "type": "text"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="8eb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们得到了确认，作为一个回答，告诉我们一切进展顺利。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="27c6" class="la lb in kw b gy lc ld l le lf">{<br/>  "acknowledged": true,<br/>  "shards_acknowledged": true,<br/>  "index": "cars"<br/>}</span></pre><p id="9717" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以检查<em class="lg">映射</em>和<em class="lg">设置</em>以查看您的参数是否已被考虑在内。</p><p id="9295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天就到这里，请随意查看官方文档了解更多细节。感谢您的阅读，如果您对本文有任何问题或评论，请在下面留下您的评论。</p><p id="f5e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们下次再见，看更多的帖子。</p><p id="c2e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阿卜杜尔-巴吉</p></div></div>    
</body>
</html>