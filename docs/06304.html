<html>
<head>
<title>How to use Redis Pub/Sub in your Python Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python应用程序中使用Redis发布/订阅</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-redis-pub-sub-in-your-python-application-b6d5e11fc8de?source=collection_archive---------0-----------------------#2021-12-29">https://blog.devgenius.io/how-to-use-redis-pub-sub-in-your-python-application-b6d5e11fc8de?source=collection_archive---------0-----------------------#2021-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/becb8c0ae259ae02d940109ffdbf25b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qX8HRe_3_0tM61zkXVXJ6Q.jpeg"/></div></div></figure><p id="97be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis因其在主数据库前充当缓存层的能力而广为人知。然而，Redis提供的远不止这些。在我看来，Redis最好的特性之一是它的发布/订阅功能。在这篇文章中，我将解释:</p><ul class=""><li id="6d93" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">什么是</strong></li><li id="012f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">什么时候使用它是个好主意</strong></li><li id="d88d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">如何用Redis和Python实现发布/订阅</strong></li></ul></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="29b8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">什么是Pub/Sub？</h1><p id="20f1" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">发布/订阅是发布者/订阅者的简称。它是软件开发中的一种模式，用于通过消息传递在服务之间进行异步通信。一个或多个服务充当<em class="mu">发布者</em>，一个或多个服务是<em class="mu">订阅者</em>。发布者向中介发送消息，在Redis的情况下，中介被称为<em class="mu">通道</em>。订阅特定频道的订户将实时接收这些消息，而无需轮询这些频道。</p><p id="a2e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有使用消息队列的经验，如<em class="mu"> RabbitMQ </em>或<em class="mu"> AWS SQS </em>，这可能听起来有点熟悉，除了消息队列和发布/订阅系统之间有一些基本的区别。</p><p id="9f8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，消息队列是基于拉的，而发布/订阅是基于推的。这意味着当使用消息队列时，订户(或消费者)需要轮询消息队列，而在发布/订阅中，订户获得推送通知，这意味着不需要轮询。</p><p id="958a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个显著的区别是，消息队列通常意味着只有一个消费者将接收和处理消息，而在发布/订阅中，成千上万的订阅者可以同时接收相同的消息。</p><p id="ddfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据您的用例，您将使用消息队列或发布/订阅，甚至有这样的情况，您可能有一个发布/订阅系统，其中订阅者是消息队列(也称为<a class="ae mv" href="https://www.pubnub.com/learn/glossary/what-is-fan-out-software/" rel="noopener ugc nofollow" target="_blank">扇出</a>)。</p><p id="5276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了Redis，一些流行的pub/sub工具还有<strong class="ka ir"> AWS SNS </strong>、<strong class="ka ir"> GCP Pub/Sub </strong>和<strong class="ka ir">阿帕奇卡夫卡</strong>。</p><h1 id="4d15" class="lr ls iq bd lt lu mw lw lx ly mx ma mb mc my me mf mg mz mi mj mk na mm mn mo bi translated">什么时候使用发布/订阅是个好主意</h1><p id="592c" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">一个很好的使用案例是处理来自数据流的数据，比如股票市场数据或体育比赛实况。假设您有一项服务，可以从成千上万只股票的数据流中实时接收股票价格更新，您需要分析科技股、媒体公司股和金融机构股的变化。让一个服务过滤并发布这些股票数据到不同的渠道(科技、媒体和金融)是有意义的，作为订阅者，每个渠道有3个不同的服务来做进一步的计算。这将是<em class="mu">松散耦合</em>和<em class="mu">单一责任</em>原则的一个很好的例子。</p><p id="2a5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个用例是向成百上千的用户发送通知。假设您有两个叫做电子邮件和短信的渠道，并且每个渠道都有两项服务。每当邮件发布到电子邮件通道时，订阅该邮件的电子邮件服务就会向该电子邮件列表中的所有成员发送一封电子邮件。</p><p id="2142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，分布式日志记录也是另一个非常流行的用例。如果您想将应用程序中发生的不同事件发送到不同的服务进行进一步分析，pub/sub无疑是一种方法。<a class="ae mv" href="https://www.gartner.com/en/information-technology/glossary/clickstream-analysis" rel="noopener ugc nofollow" target="_blank"> <em class="mu">点击流分析</em> </a>无疑是一个很好的例子。</p><h1 id="6aa6" class="lr ls iq bd lt lu mw lw lx ly mx ma mb mc my me mf mg mz mi mj mk na mm mn mo bi translated">如何用Redis和Python实现Pub/Sub</h1><p id="eace" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">现在，让我们最后看看一些代码。在这个相对基本的例子中，我将展示一个服务如何将它从推特流中收集的数据发布到两个不同的渠道，分别叫做<em class="mu">用户名</em>和<em class="mu">标签。</em>进入频道的数据是从从流中收集的每条推文中提取的，代表推文作者的用户名和标签(如果他们在推文中使用标签的话)。</p><p id="c4ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在用户端，有两个服务订阅其中一个频道，提取数据，然后使用这些数据生成一个记分牌，显示哪些用户最活跃，哪些用户最受欢迎。美丽的部分是这些记分板也保存在Redis中，通过使用<a class="ae mv" href="https://www.tutorialspoint.com/redis/redis_sorted_sets.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">排序集</strong> </a>，这是实时记分板的理想选择。这样，我们将Redis用作数据存储和发布/子系统，从而减少了架构中的组件数量。</p><p id="33b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我在代码示例中提供的url只是一个占位符，但是您实际上可以通过连接到<a class="ae mv" href="https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data" rel="noopener ugc nofollow" target="_blank"> Twitter API </a>来完全实现它。你所需要的只是一个API密匙，他们通常会在相当短的时间内提供。如果你的机器上还没有安装Redis，你可以在这里免费下载<a class="ae mv" href="https://redis.io/download" rel="noopener ugc nofollow" target="_blank"/>，但是我建议你在<a class="ae mv" href="https://hub.docker.com/_/redis" rel="noopener ugc nofollow" target="_blank"> Docker </a>上运行它，如果你的系统上有Docker的话。如果没有，也可以在这里免费下载<a class="ae mv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="989a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是发布者服务的代码:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="df43" class="nk ls iq ng b gy nl nm l nn no">import json<br/>import requests<br/>import redis</span><span id="cdc9" class="nk ls iq ng b gy np nm l nn no">URL = 'http://thestream.com' # not a real url obviously</span><span id="ea91" class="nk ls iq ng b gy np nm l nn no">red = redis.StrictRedis('localhost', 6379, charset="utf-8", decode_responses=True)<br/></span><span id="ac07" class="nk ls iq ng b gy np nm l nn no">def stream():</span><span id="18ff" class="nk ls iq ng b gy np nm l nn no">    s = requests.Session()</span><span id="19b0" class="nk ls iq ng b gy np nm l nn no">    r = s.get(URL, stream=True)</span><span id="8888" class="nk ls iq ng b gy np nm l nn no">    for line in r.iter_lines():</span><span id="918f" class="nk ls iq ng b gy np nm l nn no">        if line:</span><span id="2595" class="nk ls iq ng b gy np nm l nn no">        tweet_content = json.loads(line)</span><span id="1001" class="nk ls iq ng b gy np nm l nn no">        username = tweet_content.get('username')</span><span id="641e" class="nk ls iq ng b gy np nm l nn no">        hashtags = tweet_content.get('hashtags')</span><span id="5cf2" class="nk ls iq ng b gy np nm l nn no">        red.publish('usernames', username)</span><span id="f5f4" class="nk ls iq ng b gy np nm l nn no">        red.publish('hashtags', hashtags)</span><span id="1e1c" class="nk ls iq ng b gy np nm l nn no">if __name__ == "__main__":</span><span id="13dd" class="nk ls iq ng b gy np nm l nn no">    while True:</span><span id="d186" class="nk ls iq ng b gy np nm l nn no">        stream()</span></pre><p id="4b6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们使用<a class="ae mv" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">请求</strong> </a>库连接到HTTP流，并使用<a class="ae mv" href="https://github.com/redis/redis-py" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">redis</strong></a><strong class="ka ir">-py</strong>库作为Redis的驱动程序。值得注意的一点是，您不需要在发布到它之前创建一个通道，因为如果它还不存在，Redis会创建它。</p><p id="5292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看订阅者的代码:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a7d5" class="nk ls iq ng b gy nl nm l nn no">import redis</span><span id="f8fc" class="nk ls iq ng b gy np nm l nn no">red = redis.StrictRedis('localhost', 6379, charset="utf-8", decode_responses=True)</span><span id="9816" class="nk ls iq ng b gy np nm l nn no">def user_counter():</span><span id="7a52" class="nk ls iq ng b gy np nm l nn no">    sub = red.pubsub()</span><span id="54ef" class="nk ls iq ng b gy np nm l nn no">    sub.subscribe('usernames')</span><span id="61ce" class="nk ls iq ng b gy np nm l nn no">    for message in sub.listen():</span><span id="3533" class="nk ls iq ng b gy np nm l nn no">    if message is not None and isinstance(message, dict):</span><span id="f3f1" class="nk ls iq ng b gy np nm l nn no">    username = message.get('data')</span><span id="048d" class="nk ls iq ng b gy np nm l nn no">    red.zincrby('username_scoreboard', 1, username)</span><span id="dd1b" class="nk ls iq ng b gy np nm l nn no">while True:</span><span id="60f3" class="nk ls iq ng b gy np nm l nn no">  user_counter()</span></pre><p id="a7a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们使用同一个redis-py库，并调用<em class="mu"> pubsub() </em>和<em class="mu"> subscribe() </em>方法来通知redis这是一个订阅者。<em class="mu"> listen() </em>方法使订户能够实时接收消息。</p><p id="23be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，不需要创建之前的<em class="mu"> username_scoreboard </em>排序集，因为如果它不存在，Redis会自动创建它。</p><p id="5dc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，为了使最终用户能够通过一些HTTP端点接收这些结果，我们可以添加一个Flask API服务器，它将发送前十个最流行的标签和最活跃的用户:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="d124" class="nk ls iq ng b gy nl nm l nn no">from flask import Flask, jsonify, make_response, render_template</span><span id="4730" class="nk ls iq ng b gy np nm l nn no">app = Flask(__name__)</span><span id="b94f" class="nk ls iq ng b gy np nm l nn no">redis = redis.StrictRedis('localhost', 6379, charset="utf-8", decode_responses=True)<br/></span><span id="5583" class="nk ls iq ng b gy np nm l nn no">@api.app.route("/usernames", methods=['GET'])</span><span id="063f" class="nk ls iq ng b gy np nm l nn no">def get_usernames():</span><span id="cdb6" class="nk ls iq ng b gy np nm l nn no">    results = redis.zrevrange('username_scoreboard', 0, 10,   withscores=True)</span><span id="57ec" class="nk ls iq ng b gy np nm l nn no">    results_json = [{x[0]: x[1] for x in results}]</span><span id="8af2" class="nk ls iq ng b gy np nm l nn no">    return make_response(jsonify({'results': results_json}), 200)</span><span id="6f5f" class="nk ls iq ng b gy np nm l nn no">@app.route("/hashtags", methods=['GET'])</span><span id="2bc4" class="nk ls iq ng b gy np nm l nn no">def get_hashtags():</span><span id="0cd8" class="nk ls iq ng b gy np nm l nn no">    results = redis.zrevrange('hashtags_scoreboard', 0, 10, withscores=True)</span><span id="c4e0" class="nk ls iq ng b gy np nm l nn no">    results_json = [{x[0]: x[1] for x in results}]</span><span id="f640" class="nk ls iq ng b gy np nm l nn no">    return make_response(jsonify({'results': results_json}), 200)<br/></span><span id="915f" class="nk ls iq ng b gy np nm l nn no">if __name__ == '__main__':</span><span id="2448" class="nk ls iq ng b gy np nm l nn no">    app.run(host='0.0.0.0')</span></pre><p id="9dfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您过去曾经使用过Flask，这可能看起来非常熟悉。如果没有，我建议熟悉它，因为它绝对是有史以来最简单的web框架之一。一个好的起点是它的官方文档。</p><p id="3b8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mu"> redis.zrevrange() </em>方法用于以相反的顺序获取排序集的结果，因为默认情况下它以升序排序。<em class="mu"> 0 </em>和<em class="mu"> 10 </em>参数指定我们只想要前10名的结果，而<em class="mu"> withscores=True </em>参数指定我们还想要将实际分数与领先者一起发送。在下一行中，我们只是将它转换成JSON序列化可以接受的格式，因为这是一个REST API。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="06a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们有它。一种简单的方法来创建一组微服务，这些微服务从Twitter接收实时数据，将数据异步交付给分析数据的服务，并将其存储在实时记分牌中，最终用户可以通过Flask API服务器访问该记分牌。为了使这成为生产就绪，我们需要为每个服务添加其他功能，如日志记录、异常处理、测试、环境变量和docker文件。但是，这可能会将这篇文章引向十个不同的方向，所以我将省略这些细节。</p><p id="1846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文到此为止。如果你喜欢，请尽情鼓掌:)</p><p id="c14c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我错过了什么，或者有什么不清楚的地方，请留下评论。</p><p id="b1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>