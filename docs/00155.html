<html>
<head>
<title>Why We Use Dependency Injection In Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们在 Android 中使用依赖注入</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-we-use-dependency-injection-in-android-588f9450a46a?source=collection_archive---------0-----------------------#2020-04-07">https://blog.devgenius.io/why-we-use-dependency-injection-in-android-588f9450a46a?source=collection_archive---------0-----------------------#2020-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/228275b6bcc7589eb3eea239df2c23a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pb5DEknrbXblFC8bNrEFIQ.png"/></div></div></figure><p id="612f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一名软件开发人员，我们在日常生活中会多次遇到<a class="ae kt" href="https://developer.android.com/training/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>这个术语。不管你使用哪种技术，但是你必须在你的项目中实现依赖注入。它将帮助您编写具有以下优点的代码。</p><ul class=""><li id="f61c" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">代码的可重用性</li><li id="9c33" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">易于重构</li><li id="238f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">易于测试</li><li id="1bca" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">让你的架构松散耦合</li></ul><p id="6b88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们深入挖掘依赖注入，理解它如何给<a class="ae kt" href="https://www.solutionanalysts.com/mobile-app-development/" rel="noopener ugc nofollow" target="_blank">移动应用开发公司</a>和企业家带来如此多的好处。</p><p id="aa1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们打破单词依赖注入，尝试理解单词的意思。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/cb8e4a4df18ba1d9520a0d13a7ae2f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*I6eSbTfPiK7Yk1KnVw3GtQ.gif"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae kt" href="https://tenor.com/view/tslaq-tesla-inc-demo-throw-tesla-truck-gif-15623553" rel="noopener ugc nofollow" target="_blank"> src </a></figcaption></figure><ol class=""><li id="0b93" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks lr la lb lc bi translated">一个<strong class="jx io">依赖关系</strong>是一个将被一个依赖关系即类使用的对象。</li><li id="13a4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks lr la lb lc bi translated"><strong class="jx io">注入</strong>是一种将依赖性传递给依赖者的技术，也就是将对象传递给想要使用它的类。</li></ol><p id="1d35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此<a class="ae kt" href="https://developer.android.com/training/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是一种使依赖(即类独立于其依赖)的技术。在本文中，我们主要关注 Android 平台。我们举一个实时的例子，了解一下整个概念。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/06f46a53b5edca06802fbe73c6593d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*rfglt-Xezx4C_qqQ4aVy5Q.gif"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae kt" href="https://tenor.com/view/let-me-give-you-ascenario-example-sample-acase-movie-reviews-gif-15040443" rel="noopener ugc nofollow" target="_blank"> src </a></figcaption></figure><p id="e3b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们创建一个名为<strong class="jx io"> Car </strong>的类。在这种情况下，我们需要一个<strong class="jx io">引擎</strong>类和<strong class="jx io">转向</strong>类的对象。让我们首先以传统的方式实现这个场景，不使用依赖注入。</p><p id="5c02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不使用依赖注入</p><p id="69de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码没有遵循依赖注入的原则，原因如下:</p><ol class=""><li id="c189" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks lr la lb lc bi translated">在这里<strong class="jx io">车</strong>级建造自己的引擎和启动物体。我们的代码是紧密耦合的。因此，如果我们想将<strong class="jx io">转向</strong>类型从普通转向改为动力转向，您必须创建两种类型的<strong class="jx io">汽车</strong>。</li><li id="d58a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks lr la lb lc bi translated">对<strong class="jx io">转向</strong>和<strong class="jx io">发动机</strong>的硬性依赖使得测试更加困难，因为<strong class="jx io">车</strong>使用的是<strong class="jx io">发动机</strong>和<strong class="jx io">转向</strong>的真实实例，因此无法对<a class="ae kt" href="https://developer.android.com/training/testing/unit-testing" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"/></a>进行单元测试，因为它使用的是<strong class="jx io">发动机</strong>和<strong class="jx io">转向</strong>的真实对象，我们无法在不同情况下修改测试对象。</li><li id="3177" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks lr la lb lc bi translated">维护这种类型的代码并不是一件容易的事情，因为没有子类或替代实现可以容易地使用。</li></ol><p id="d135" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有两种方法来解决这个问题。在这两种方法中，我们都试图使我们的代码松散耦合。为此，我们将从<strong class="jx io">汽车</strong>类中移除<strong class="jx io">引擎</strong>和<strong class="jx io">转向</strong>类的依赖性。为了实现这一点，让我们来看看以下方法:</p><ol class=""><li id="c938" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks lr la lb lc bi translated"><strong class="jx io">构造函数注入</strong></li></ol><p id="efef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们通过<strong class="jx io">构造器</strong>传递依赖关系，因此<strong class="jx io">我们的</strong>汽车对象不依赖于<strong class="jx io">引擎</strong>或<strong class="jx io">启动</strong>。</p><p id="b35f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx io">构造函数注入</strong>依赖注入</p><p id="eeaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">现场注入(或设定器注入)</strong></p><p id="e69a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Android 中，我们有一些由系统实例化的 Android 框架类，比如 activity 或 fragment，所以构造函数注入是不可能的。所以我们在<strong class="jx io"> </strong>中使用<strong class="jx io">字段注入</strong>，在类创建后实例化依赖关系。</p><p id="77a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx io">字段注入</strong>依赖注入</p><p id="2e5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以看到这段代码更容易维护，耦合更松散。这称为<em class="ls">手动依赖注入</em>，或<em class="ls">手动依赖注入。</em></p><p id="b907" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这个小例子。真正的汽车依赖于许多其他类，如床单，形状，窗户等等。如果我们试图手动拟合所有这些类的依赖关系，这将是一项更加繁琐的工作，你将面临以下问题。</p><ol class=""><li id="f469" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks lr la lb lc bi translated">在现实世界的应用程序中，获取所有的依赖项并正确地连接它们需要大量的工作和大量的样板代码。</li><li id="0ec9" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks lr la lb lc bi translated">如果你想在顶层创建一个对象，你必须提供对底层类的所有依赖。</li><li id="4933" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks lr la lb lc bi translated">在某些情况下，我们无法在将依赖关系传递给需要这些依赖关系的目标类之前构造依赖关系。例如，如果您使用惰性初始化，那么您需要管理自定义容器，这些容器在内存中维护您的依赖项的生存期。</li></ol><p id="a293" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决所有这些问题，我们有几个库可以帮助我们解决上述所有问题。</p><ol class=""><li id="e60f" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks lr la lb lc bi translated"><a class="ae kt" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank">匕首</a></li></ol><p id="0d0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这适用于 java 和<a class="ae kt" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> kotlin </a>两者。</p><p id="e104" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<a class="ae kt" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank">锦鲤</a></p><p id="021c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 Kotlin 的特殊设计，仅适用于<a class="ae kt" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> kotlin </a>的支架。</p><p id="d596" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一篇文章中，我们将深入 Dagger 和 Koin，通过在代码中实现来弄脏我们的手。我们还会发现两个库的优缺点。</p><p id="a042" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇博客到此为止，我们已经了解了什么是依赖注入，为什么我们需要依赖注入以及依赖注入的类型。谢谢你抽出时间。</p><p id="07ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐阅读:)</p></div></div>    
</body>
</html>