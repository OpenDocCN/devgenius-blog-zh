<html>
<head>
<title>JavaScript: A Quick Reference to Object Instantiation Patterns For New Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:面向新开发人员的对象实例化模式快速参考</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-a-quick-reference-to-object-instantiation-patterns-for-new-developers-304f806a9b82?source=collection_archive---------10-----------------------#2020-07-16">https://blog.devgenius.io/javascript-a-quick-reference-to-object-instantiation-patterns-for-new-developers-304f806a9b82?source=collection_archive---------10-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dba92944cf1a73a4bb122be8122c17b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SOYShAScInPr7PxV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@frantic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·科特利亚斯基</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ce81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在面向对象编程(<a class="ae kc" href="https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html#:~:text=Object%2Doriented%20programming%20(OOP),applied%20to%20the%20data%20structure." rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> OOP </strong> </a>)中，有不同的模式来实例化(这意味着“创建新的实例”)对象。我喜欢把它想象成一个制造对象的工厂或系统，这些对象存储了数据并提供了功能。没有一个正确的实例化模式可以适用于所有场景。每种实例化模式都有自己的优点和缺点，这将允许您确定哪种模式会产生更好的解决方案。JS实例化模式有:</p><ul class=""><li id="48e7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">功能的</li><li id="ee8d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">功能共享</li><li id="de6e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">原型</li><li id="32e3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">伪古典的</li><li id="1115" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">ES6级</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="4a10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中一个流行的约定是构造函数的第一个字母要大写。</p><h1 id="e6ed" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">功能性</strong></h1><p id="c2b9" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">构造函数创建一个对象，向该对象添加属性和方法，并返回新创建的对象。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">好处:</strong>写起来简单。<strong class="kf ir"> </strong>容易理解和遵循。</p><p id="6018" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">缺点:</strong>如果要创建大量(比如说100万)对象。每个对象都有冗余的函数定义。内存低效。</p><p id="8a8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们怎样才能让这些实例不重复方法或属性呢？</p><h1 id="05df" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">功能共享</h1><p id="bb45" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">实例可以通过使用单独的对象存储属性和方法来共享方法和属性。_.<a class="ae kc" href="https://underscorejs.org/#extend" rel="noopener ugc nofollow" target="_blank">扩展</a>用共享方法扩展构造器对象以避免重复。<code class="fe nf ng nh ni b">this</code>关键字用于引用创建的对象。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">好处:</strong>提高记忆效率。删除重复的函数定义，干。</p><p id="23a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">缺点:</strong>容易出错。如果在创建实例后修改了共享方法，新实例和旧实例将具有不同的共享方法。</p><p id="a18f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何才能避免引用不同的方法？</p><h1 id="c0f2" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">原型</h1><p id="a905" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Object.create() 方法创建一个新对象，并通过原型链继承传入的对象参数。如果在对象中没有找到方法，它将向上委托原型链，直到找到目标方法。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">好处:</strong>提高记忆效率。删除重复的函数定义，干。降低出错风险。</p><p id="d2ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">缺点:</strong>这与其说是缺点，不如说是不便，因为每个构造函数都有一行用于创建和返回一个对象。</p><p id="38c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何清理这些并隐藏那两行代码(上面例子中的第2行和第5行),这样我们就不用一直输入了？</p><h1 id="fa00" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">伪古典的</h1><p id="dddb" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当在创建实例时使用<code class="fe nf ng nh ni b">new</code>关键字时，将创建并返回一个具有原型继承的对象。我猜这就是所谓的<a class="ae kc" href="https://en.wikipedia.org/wiki/Syntactic_sugar#:~:text=In%20computer%20science%2C%20syntactic%20sugar,style%20that%20some%20may%20prefer." rel="noopener ugc nofollow" target="_blank">句法糖</a>！</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">好处:</strong>句法上比较甜。如果你删除了上面所有的评论，看看它有多简洁和“甜蜜”。</p><p id="7b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">缺点:</strong>如果<code class="fe nf ng nh ni b">new</code>关键字丢失或遗忘，可能会导致bug！可能很难理解引擎盖下发生了什么。</p><p id="97d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个语法上“甜蜜”的版本怎么样？</p><h1 id="1ef1" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">ES6级</h1><p id="5e0e" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这里也必须使用<code class="fe nf ng nh ni b">new</code>关键字。另外，还有其他关键字，如<code class="fe nf ng nh ni b">class</code>和<code class="fe nf ng nh ni b">constructor</code>。注意没有使用关键字<code class="fe nf ng nh ni b">function</code>，函数是用它们的标签、括号和花括号定义的。只不过是用原型继承创建对象的语法糖。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">好处:</strong>句法上甜。实例化的最新方法。</p><p id="82d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缺点:模糊你对正在发生的事情的理解。从技术上讲，JavaScript没有其他语言中的“类”基于类的OOP。JavaScript使用原型链来模仿类。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="4318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是黑客反应堆的第二周，我还有34周的时间。我想还有很多东西要学！</p></div></div>    
</body>
</html>