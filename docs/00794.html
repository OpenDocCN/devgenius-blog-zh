<html>
<head>
<title>Reducing Temporal Coupling in Our Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少代码中的时间耦合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reducing-temporal-coupling-in-our-code-2fdd48e76410?source=collection_archive---------33-----------------------#2020-06-16">https://blog.devgenius.io/reducing-temporal-coupling-in-our-code-2fdd48e76410?source=collection_archive---------33-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c5ae31769944e20571ca51a0d46742fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OyOUshP2XU6G02YK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@alexiby?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex Iby </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间通常是软件架构中被忽略东西。我们唯一关心的是我们的日程安排。</p><p id="2b20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在我们自己的代码中，我们也要关心时间。我们必须关心并发性和排序。</p><p id="9d99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何减少代码中的时间耦合。</p><h1 id="2968" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">允许并发</h1><p id="1181" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须在代码中考虑到并发性。这样，如果没有必要，我们就不必强迫一个过程在另一个过程之前运行。</p><p id="3f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这通过允许不相互依赖的事情并发运行来提高性能，节省每个人的时间。</p><h1 id="a87b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工作流程</h1><p id="595d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须分析我们程序的工作流，看看哪些部分在排序方面可以相互解耦。</p><p id="3b8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们发出 HTTP 请求来获取不相关的数据，那么我们可以通过让它们并行运行来分离这些工作流。</p><p id="2cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果他们不必以串行方式运行，那么串行运行和浪费时间是没有意义的。</p><p id="9deb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果不相关的数据来自不同的来源，不需要编写下面的代码来获得这两个数据:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a22" class="mn lc iq mj b gy mo mp l mq mr">async () =&gt; {<br/>  const michael = await fetch('https://api.agify.io?name=michael')<br/>  const joe = await fetch('https://api.agify.io?name=joe')<br/>}</span></pre><p id="e565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改为编写以下代码来并行获取它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="49c8" class="mn lc iq mj b gy mo mp l mq mr">async () =&gt; {<br/>  const responses = await Promise.all([<br/>    fetch('https://api.agify.io?name=michael'),<br/>    fetch('https://api.agify.io?name=joe')<br/>  ])<br/>}</span></pre><p id="5b6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到第一个片段的运行时间比第二个长得多。</p><p id="e2f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们允许它们并发运行，那么我们就可以确保这一个请求不会被不必要的延迟，因为一开始它们是不相关的，所以它们可以并发运行。</p><h1 id="0afb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并行设计</h1><p id="bda6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">线性代码导致编程草率。对于并发性，我们必须考虑基于时间的依赖性。</p><p id="a545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须确保一种资源在另一种资源之前可用。若要调用对象，我们必须确保状态是我们想要的，然后才能调用下一个过程，该过程取决于上一个过程产生的值。</p><p id="0079" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们必须确保检查有效值，如果它们不存在，就等待它们。</p><p id="406e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同语言获取相关数据的方式不同。例如，在 JavaScript 中，我们通过使用 promises 来确保在调用下一个异步进程之前获得来自异步进程的依赖数据。</p><p id="b4d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了承诺，我们可以将它们链接起来，这样在运行下一个承诺之前，我们可以确保上一个承诺返回我们想要的值。</p><p id="5aba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下 JavaScript 代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d689" class="mn lc iq mj b gy mo mp l mq mr">const foo = async () =&gt; {<br/>  const res = await fetch('https://yesno.wtf/api')<br/>  const {<br/>    answer<br/>  } = res.json();<br/>  if (answer === 'yes') {<br/>    const res = await fetch('https://api.agify.io?name=joe')<br/>    const result = res.json();<br/>    console.log(result)<br/>  }<br/>}</span></pre><p id="79b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在调用下一个 API 获取更多数据之前，我们确保从响应体获得了属性<code class="fe ms mt mu mj b">answer</code>，并且它的值是<code class="fe ms mt mu mj b">'yes'</code>。</p><p id="20a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们在 JavaScript 中经常遇到的事情，所以在我们做任何事情之前，都必须检查 promise 代码是否符合我们的要求。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/f84cf2700ebb651a8d50e6422c76ac12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3C0n2z5h1TRW7tbj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡莉·雷·霍布斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a3bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">部署</h1><p id="c34e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以灵活部署我们的应用程序。我们可以一次部署整个系统，也可以只部署其中的一部分。</p><p id="6eb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将它们划分成更小的服务，那么我们就不必每次对系统的某个部分做一些小的改变就部署整个系统。</p><p id="2b55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它们解耦可以让我们同时部署不同的部分，而不是一次性部署所有的部分。</p><p id="256a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向非并发系统添加并发性要困难得多，所以我们在设计系统时必须考虑到这一点。</p><h1 id="655f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6055" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">允许并发是我们在设计系统时必须考虑的事情。</p><p id="7796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望不相关的东西串行运行，这样它们就不会不必要地耦合在一起，并且通过不必等待他们不必等待的东西来节省用户的时间。</p><p id="5074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并发也适用于部署。如果我们将我们的系统划分成更小的服务，那么我们只需要在需要部署的时候部署那部分服务。</p><p id="5b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比每次我们有一个小的变化就部署整个系统要好得多。</p></div></div>    
</body>
</html>