<html>
<head>
<title>Simple App Loading View using SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SwiftUI 的简单应用加载视图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simple-app-loading-view-239807a9db1e?source=collection_archive---------1-----------------------#2020-05-31">https://blog.devgenius.io/simple-app-loading-view-239807a9db1e?source=collection_archive---------1-----------------------#2020-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fba1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让-马克·布里安内</h2></div><p id="3b25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个初始的应用程序加载屏幕可能是开发 iOS 应用程序时没有考虑太多的问题。今天我们将快速看一下如何创建一个相对简单优雅的加载屏幕。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/821970eb9f5483dd6984dff5796f4e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/1*8hy3XHYLIOQNN70xmNYEkA.gif"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">装载视图示例</figcaption></figure><blockquote class="ln lo lp"><p id="8600" class="kf kg lq kh b ki kj jr kk kl km ju kn lr kp kq kr ls kt ku kv lt kx ky kz la ij bi translated">我们想看你的作品！如果你已经用这个教程制作了一些东西，请给我们发图片！在推特<a class="ae lu" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank"> @TrailingClosure </a>上找到我们，或者发邮件到<a class="ae lu" href="mailto:howdy@trailingclosure.com" rel="noopener ugc nofollow" target="_blank">howdy@TrailingClosure.com</a>联系我们</p></blockquote><p id="8984" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程分为两部分:</p><ul class=""><li id="c065" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">创建<code class="fe me mf mg mh b">ScaledMaskModifier</code></li><li id="5a21" class="lv lw iq kh b ki mi kl mj ko mk ks ml kw mm la ma mb mc md bi translated">创建<code class="fe me mf mg mh b">LoadingView</code></li></ul><h2 id="cdb7" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">创造了<code class="fe me mf mg mh b">ScaledMaskModifier</code></h2><p id="ab43" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">我们的<code class="fe me mf mg mh b">ScaledMaskModifier</code>将用于动画显示我们的装载视图。它将一个<code class="fe me mf mg mh b">Mask</code>作为输入，该输入将随着时间的推移按比例放大，以显示加载视图。见下文一瞥。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/bf26f035b4f5cd2e4f79d9ac3b62f411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*tTQNlTYKtLESNtuJ.gif"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><code class="fe me mf mg mh b">ScaledMaskModifier</code>使用<code class="fe me mf mg mh b">Circle</code>作为遮罩</figcaption></figure><p id="fe2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，创建一个名为<code class="fe me mf mg mh b">ScaledMaskModifier</code>的新<code class="fe me mf mg mh b">ViewModifier</code>。我们将向该类添加两个变量:</p><ol class=""><li id="9501" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated"><code class="fe me mf mg mh b">mask</code>——前面描述的面具。它将随着时间的推移而增长，以显示底层的加载视图。</li><li id="12ec" class="lv lw iq kh b ki mi kl mj ko mk ks ml kw mm la nm mb mc md bi translated"><code class="fe me mf mg mh b">progress</code> -跟踪我们在动画中所处位置的值。</li></ol><p id="29a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是目前为止该结构的模板:</p><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="8596" class="mn mo iq mh b gy nr ns l nt nu">import SwiftUI<br/><br/>struct ScaledMaskModifier&lt;Mask: View&gt;: ViewModifier {<br/>    <br/>    var mask: Mask<br/>    var progress: CGFloat<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>    }<br/><br/>}</span></pre><p id="9105" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要计算遮罩的高度和宽度，然后将其应用到我们的内容中。棘手的是，我们要确保遮罩的形状会增长到内容的最大尺寸。这类似于我们如何在<code class="fe me mf mg mh b">Image</code>上使用<code class="fe me mf mg mh b">scaleToFill()</code>。</p><ol class=""><li id="dab7" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">创建一个名为<code class="fe me mf mg mh b">calculateSize(geometry: GeometryProxy)</code>的函数。这将返回<code class="fe me mf mg mh b">mask</code>的最大尺寸(在动画结束时)。它将判断内容的宽度或高度是否更大，并将其作为大小返回。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="663e" class="mn mo iq mh b gy nr ns l nt nu">// Calculate Max Size of Mask<br/>func calculateSize(geometry: GeometryProxy) -&gt; CGFloat {<br/>    if geometry.size.width &gt; geometry.size.height {<br/>        return geometry.size.width<br/>    }<br/>    return geometry.size.height<br/>}</span></pre><ol class=""><li id="8ac1" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">将<code class="fe me mf mg mh b">mask</code>应用于我们的内容，同时使用<code class="fe me mf mg mh b">calculateSize(geometry:)</code>和<code class="fe me mf mg mh b">progress</code>随着时间的推移缩放蒙版大小。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="1e78" class="mn mo iq mh b gy nr ns l nt nu">import SwiftUI<br/><br/>struct ScaledMaskModifier&lt;Mask: View&gt;: ViewModifier {<br/>    <br/>    var mask: Mask<br/>    var progress: CGFloat<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .mask(GeometryReader(content: { geometry in<br/>                self.mask.frame(width: self.calculateSize(geometry: geometry) * self.progress,<br/>                                height: self.calculateSize(geometry: geometry) * self.progress,<br/>                                alignment: .center)<br/>            }))<br/>    }<br/>    <br/>    // Calculate Max Size of Mask<br/>    func calculateSize(geometry: GeometryProxy) -&gt; CGFloat {<br/>        if geometry.size.width &gt; geometry.size.height {<br/>            return geometry.size.width<br/>        }<br/>        return geometry.size.height<br/>    }<br/><br/>}</span></pre><h2 id="2750" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">创建<code class="fe me mf mg mh b">LoadingView</code></h2><p id="0f2c" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">接下来，我们将通过创建<code class="fe me mf mg mh b">LoadingView</code>来让<code class="fe me mf mg mh b">ScaledMaskModifier</code>工作。在<code class="fe me mf mg mh b">LoadingView</code>里面也是我们处理动画的地方。</p><ol class=""><li id="e163" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">创建一个新的<code class="fe me mf mg mh b">View</code>，并将其命名为<code class="fe me mf mg mh b">LoadingView</code>。在里面你需要定义 3 个变量:一个用于<code class="fe me mf mg mh b">LoadingView</code>的内容，一个用于动画的进度，另一个用于 Y 偏移(弹跳动画)。下面是一个例子。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="b3bc" class="mn mo iq mh b gy nr ns l nt nu">import SwiftUI<br/><br/>struct LoadingView&lt;Content: View&gt;: View {<br/><br/>    var content: Content<br/>    @Binding var progress: CGFloat<br/>    @State var logoOffset: CGFloat = 0 //Animation Y Offset<br/>    <br/>    var body: some View {<br/>        content<br/>    }<br/>}</span></pre><ol class=""><li id="7f10" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">接下来，我们需要对内容应用<code class="fe me mf mg mh b">ScaledMaskModifier</code>。这里我们使用了一个<code class="fe me mf mg mh b">Circle</code>作为遮罩，但是实际上你可以使用任何<code class="fe me mf mg mh b">Shape</code>或者<code class="fe me mf mg mh b">View</code>比如<code class="fe me mf mg mh b">Rectangle</code>或者任何其他定制的 SwiftUI <code class="fe me mf mg mh b">View</code>。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="3984" class="mn mo iq mh b gy nr ns l nt nu">var body: some View {<br/>    content<br/>        .modifier(ScaledMaskModifier(mask: Circle(), progress: progress))<br/>}</span></pre><ol class=""><li id="4b7a" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">另外<code class="fe me mf mg mh b">ScaledMaskModifier</code>我们会让<code class="fe me mf mg mh b">content</code>上下弹跳。为了做到这一点，我们将动画它的 y 偏移。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="52af" class="mn mo iq mh b gy nr ns l nt nu">var body: some View {<br/>    content<br/>        .modifier(ScaledMaskModifier(mask: Circle(), progress: progress))<br/>        .offset(x: 0, y: logoOffset)<br/>}</span></pre><ol class=""><li id="c58b" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la nm mb mc md bi translated">是时候添加动画了。这里我们将制作<code class="fe me mf mg mh b">content</code>从<code class="fe me mf mg mh b">0</code>到<code class="fe me mf mg mh b">1</code>的进度变化动画，同时上下弹跳。</li></ol><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="e77d" class="mn mo iq mh b gy nr ns l nt nu">import SwiftUI<br/><br/>struct LoadingView&lt;Content: View&gt;: View {<br/><br/>    var content: Content<br/>    @Binding var progress: Double<br/>    @State var logoOffset: CGFloat = 0 //Animation Y Offset<br/>    <br/>    var body: some View {<br/>        content<br/>            .modifier(ScaledMaskModifier(mask: Circle(), progress: progress))<br/>            .offset(x: 0, y: logoOffset)<br/>            .onAppear {<br/>                withAnimation(Animation.easeInOut(duration: 1)) {<br/>                    self.progress = 1.0<br/>                }<br/>                withAnimation(Animation.easeInOut(duration: 0.4).repeatForever(autoreverses: true)) {<br/>                    self.logoOffset = 10<br/>                }<br/>            }<br/>    }<br/>}</span></pre><h2 id="6f88" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">创造一个例子</h2><p id="0fc8" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">现在我们将在一个例子中测试我们的<code class="fe me mf mg mh b">LoadingView</code>。见下文:</p><p id="ff14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们创建了一个假的<code class="fe me mf mg mh b">HomeView</code>,一旦加载完成就会显示出来。正如你所看到的，我们使用变量<code class="fe me mf mg mh b">doneLoading</code>来决定在屏幕上呈现哪个 vie。</p><p id="4be7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe me mf mg mh b">LoadingView</code>,我已经传入了一个<code class="fe me mf mg mh b">Image</code>,它将被用作加载屏幕的<code class="fe me mf mg mh b">content</code>。</p><p id="f68c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如果你对我为什么使用<code class="fe me mf mg mh b">onAppear()</code>函数感到好奇，那么我可以模拟为你的应用加载数据的异步特性。</p><pre class="lc ld le lf gt nn mh no np aw nq bi"><span id="7af9" class="mn mo iq mh b gy nr ns l nt nu">import SwiftUI<br/><br/>struct ContentView: View {<br/><br/>    @State var progress: CGFloat = 0<br/>    @State var doneLoading: Bool = false<br/>    <br/>    var body: some View {<br/>        ZStack {<br/>            if doneLoading {<br/>                HomeView()<br/>                    .transition(AnyTransition.opacity.animation(.easeInOut(duration: 1.0)))<br/>            } else {<br/>                LoadingView(content: Image("PathMaskLogo-Dark")<br/>                                        .resizable()<br/>                                        .scaledToFit()<br/>                                        .padding(.horizontal, 50),<br/>                            progress: $progress)<br/>                    // Added to simulate asynchronous data loading<br/>                    .onAppear {<br/>                        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {<br/>                            withAnimation {<br/>                                self.progress = 0<br/>                            }<br/>                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {<br/>                                withAnimation {<br/>                                    self.doneLoading = true<br/>                                }<br/>                                <br/>                            }<br/>                        }<br/>                    }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/4ba0785cb165e81f720a5f2fc0266dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/0*zQoATIrXCvwOyLQt.gif"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">示例使用</figcaption></figure><h2 id="58d7" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">支持未来像这样的教程！</h2><p id="c35b" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">请考虑使用此<a class="ae lu" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">链接</a>进行订阅。如果你没有在 TrailingClosure.com<a class="ae lu" href="https://trailingclosure.com/" rel="noopener ugc nofollow" target="_blank">看到这篇文章，请随时来看看我们！</a></p><p id="bc91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想看你的作品！如果你已经用这个教程制作了一些东西，请给我们发图片！在推特<a class="ae lu" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank"> @TrailingClosure </a>上找到我们，或者发邮件到<a class="ae lu" href="mailto:howdy@trailingclosure.com" rel="noopener ugc nofollow" target="_blank">howdy@TrailingClosure.com</a>联系我们</p></div></div>    
</body>
</html>