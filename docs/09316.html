<html>
<head>
<title>SQL Practice questions — #3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 练习题— #3</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-practice-questions-3-9fd3d6e56058?source=collection_archive---------1-----------------------#2022-08-14">https://blog.devgenius.io/sql-practice-questions-3-9fd3d6e56058?source=collection_archive---------1-----------------------#2022-08-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4267" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SQL 练习题的第三部分</p><p id="ca31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击此处查看<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-1-800ed65d99b2">第一部</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-2-f1116b1f5402">第二部</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-4-e24a6bdb32d4">第四部</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-5-456cfb41757a">第五部</a></p><h1 id="5eb2" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 1</h1><p id="b112" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">一家公司想雇佣新员工。公司的工资预算是<code class="fe lm ln lo lp b">$70000</code>。公司的招聘标准是:</p><ol class=""><li id="93aa" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated">继续雇佣薪水最低的毕业生，直到你不能再雇佣更多的毕业生。</li><li id="eed9" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">用剩下的预算雇佣工资最低的大三学生。</li><li id="3693" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated">继续雇佣薪水最低的初级员工，直到你不能雇佣更多的初级员工。</li></ol><p id="8039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写一个 SQL 查询来查找在上述标准下雇佣的高年级学生和低年级学生的 id。返回<strong class="jm io">任意顺序</strong>的结果表。</p><p id="5268" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例:</strong></p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="379c" class="mm kk in lp b gy mn mo l mp mq"><strong class="lp io">Input:</strong><br/>Candidates table:<br/>+-------------+------------+--------+<br/>| employee_id | experience | salary |<br/>+-------------+------------+--------+<br/>| 1           | Junior     | 10000  |<br/>| 9           | Junior     | 15000  |<br/>| 2           | Senior     | 20000  |<br/>| 11          | Senior     | 16000  |<br/>| 13          | Senior     | 50000  |<br/>| 4           | Junior     | 40000  |<br/>+-------------+------------+--------+<br/><strong class="lp io">Output:</strong> <br/>+-------------+<br/>| employee_id |<br/>+-------------+<br/>| 11          |<br/>| 2           |<br/>| 1           |<br/>| 9           |<br/>+-------------+</span></pre><p id="96c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:从问题中可以明显看出，我们希望首先雇佣高年级学生，所以我们得到了所有我们能雇佣的高年级学生，然后用剩余的预算雇佣低年级学生，直到我们完全耗尽预算。我们将使用 CTE 来存储雇佣的高年级学生，然后使用它来雇佣低年级学生。</p><pre class="me mf mg mh gt mi lp mr bn ms mt bi"><span id="a932" class="mu kk in lp b be mv mw l mx mq">with seniorhired as<br/>(<br/>  select * <br/>   from <br/>     (  <br/>       select employee_id, sum(salary) over(order by salary ) as run_sum<br/>       from candidates <br/>       where experience ='Senior'<br/>     ) y <br/>  where run_sum&lt;=70000<br/>),<br/>juniorhired as<br/>(<br/>  select employee_id<br/>  from<br/>      (  select employee_id, sum(salary) over(order by salary) run_sum<br/>         from candidates <br/>         where experience ='Junior'<br/>      ) z <br/>  where run_sum&lt;(select ifnull(70000-max(run_sum), 70000) from seniorhired )<br/>)<br/>select employee_id from seniorhired<br/>union all<br/>select employee_id from juniorhired</span></pre><h2 id="43c8" class="mm kk in bd kl my mz dn kp na nb dp kt jv nc nd kx jz ne nf lb kd ng nh lf ni bi translated">非递归解</h2><pre class="me mf mg mh gt mi lp mr bn ms mt bi"><span id="f0bd" class="mu kk in lp b be mv mw l mx mq">WITH CTE AS (<br/>    SELECT <br/>        employee_id, <br/>        experience, <br/>        SUM(salary) OVER(PARTITION BY experience ORDER BY salary, employee_id ASC) AS run_sum<br/>    FROM Candidates<br/>)<br/>      <br/>SELECT <br/>    employee_id<br/>FROM CTE <br/>WHERE experience = 'Senior' AND run_sum &lt;= 70000<br/>UNION<br/>SELECT <br/>    employee_id<br/>FROM CTE <br/>WHERE experience = 'Junior' AND RN &lt; (SELECT 70000 - IFNULL(MAX(RN),0) FROM CTE WHERE experience = 'Senior' AND run_sum &lt;= 70000)</span></pre><h1 id="5e56" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 2</h1><p id="67d2" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">给定一个包含不同科目学生分数的表，反转该表，使每一行包含不同列中的每个科目的学生及其分数。</p><p id="1579" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例:</strong></p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="512b" class="mm kk in lp b gy mn mo l mp mq"><strong class="lp io">student_marks Table</strong><br/>+-------------+------------+--------+<br/>| student_id  | subject    | marks  |<br/>+-------------+------------+--------+<br/>| 1001        | English    | 88     |<br/>| 1001        | Science    | 90     |<br/>| 1001        | Maths      | 85     |<br/>| 1002        | English    | 70     |<br/>| 1002        | Science    | 80     |<br/>| 1002        | Maths      | 83     |<br/>+-------------+------------+--------+<br/><strong class="lp io">Output</strong>:<br/>+-------------+----------+---------+-------+<br/>| student_id  | English  | Science | Maths |<br/>+-------------+----------+---------+-------+<br/>| 1001        | 88       | 90      | 85    |<br/>| 1002        | 70       | 80      | 83    |<br/>+-------------+----------+---------+-------+</span></pre><p id="f3b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:由于 MySQL 没有 PIVOT，我们可以利用 CASE 语句来查找所需的表。我们为每个主题创建列，如果列名与主题匹配，则选择标记值，否则我们赋零。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="f1f1" class="mm kk in lp b gy mn mo l mp mq">+-------------+----------+---------+-------+<br/>| student_id  | English  | Science | Maths |<br/>+-------------+----------+---------+-------+<br/>| 1001        | 88       | 0       | 0     |<br/>| 1001        | 0        | 90      | 0     |<br/>| 1001        | 0        | 0       | 85    |<br/>| 1002        | 70       | 0       | 0     |<br/>| 1002        | 0        | 80      | 0     |<br/>| 1002        | 0        | 0       | 83    |<br/>+-------------+----------+---------+-------+</span></pre><p id="eeed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个中间结果将具有与输入相同的行，我们对每个 student_id 的行进行分组和组合。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="b074" class="mm kk in lp b gy mn mo l mp mq">SELECT student_id,<br/> max(CASE WHEN subject='English' THEN marks else 0) as English,<br/>    max(CASE WHEN subject='Science' THEN marks else 0) as Science,<br/>    max(CASE WHEN subject='Maths' THEN marks else 0) as Maths<br/>FROM student_marks <br/>GROUP BY student_id</span></pre><h1 id="8cec" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 3</h1><p id="747e" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">编写一个 SQL 查询来报告购买了产品<strong class="jm io"> "A "和" B" </strong>但没有购买产品<strong class="jm io"> "C" </strong>的客户的 customer_id 和 customer_name，因为我们想推荐他们购买该产品。返回由<code class="fe lm ln lo lp b">customer_id</code>命令的结果表<strong class="jm io">。</strong></p><p id="153a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="8e72" class="mm kk in lp b gy mn mo l mp mq"><strong class="lp io">Input:</strong> <br/>Customers table:<br/>+-------------+---------------+<br/>| customer_id | customer_name |<br/>+-------------+---------------+<br/>| 1           | Daniel        |<br/>| 2           | Diana         |<br/>| 3           | Elizabeth     |<br/>| 4           | Jhon          |<br/>+-------------+---------------+<br/>Orders table:<br/>+------------+--------------+---------------+<br/>| order_id   | customer_id  | product_name  |<br/>+------------+--------------+---------------+<br/>| 10         |     1        |     A         |<br/>| 20         |     1        |     B         |<br/>| 30         |     1        |     D         |<br/>| 40         |     1        |     C         |<br/>| 50         |     2        |     A         |<br/>| 60         |     3        |     A         |<br/>| 70         |     3        |     B         |<br/>| 80         |     3        |     D         |<br/>| 90         |     4        |     C         |<br/>+------------+--------------+---------------+<br/><strong class="lp io">Output:</strong> <br/>+-------------+---------------+<br/>| customer_id | customer_name |<br/>+-------------+---------------+<br/>| 3           | Elizabeth     |<br/>+-------------+---------------+</span></pre><p id="c7c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:简单的方法是创建三个不同的 CTE，每个都将产品 A、B 和 C 作为采购，然后使用 IN 和 NOT IN 应用过滤器。但是这将需要 3 次表扫描(分别针对 A、B 和 C)。我们可以通过使用<strong class="jm io"> group_concat </strong>来一次性完成。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="e6ef" class="mm kk in lp b gy mn mo l mp mq">+---------------+----------------+---------------+<br/>| customer_id   | customer_name  | product_name  |<br/>+---------------+----------------+---------------+<br/>| 1             | Daniel         | A,B,C,D       |<br/>| 2             | Diana          | A             |<br/>| 3             | Elizabeth      | A,B,D         |<br/>| 4             | Jhon           | C             |<br/>+---------------+----------------+---------------+</span></pre><p id="5462" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们有了上面的结果，我们只需要找到模式<strong class="jm io"> %A，B% </strong>而不是<strong class="jm io"> %A，B，C% </strong>。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="9fc2" class="mm kk in lp b gy mn mo l mp mq">with cte as (<br/>    select o.customer_id , c.customer_name, <br/>        group_concat(o.product_name order by o.product_name) as purchases<br/>    from Orders o left join Customers c<br/>    on o.customer_id = c.customer_id<br/>    group by o.customer_id<br/>)<br/>select customer_id , customer_name from cte<br/>where purchases like '%A,B%' and purchases not like '%A,B,C%'</span></pre><p id="5acb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"> <code class="fe lm ln lo lp b"><strong class="jm io">group_concat</strong></code>函数中的<strong class="jm io"> Order by 子句并不重要，因为它确保了产品模式的顺序。如果我们不使用 order by，那么 where 子句将被修改如下</strong></p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="7d4a" class="mm kk in lp b gy mn mo l mp mq">WHERE <!-- -->purchases<!-- --> LIKE '%A%'<br/>AND <!-- -->purchases<!-- --> LIKE '%B%'<br/>AND <!-- -->purchases<!-- --> NOT LIKE '%C%'</span></pre><h1 id="10e3" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 4</h1><p id="936c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">一家银行希望绘制一张图表，显示银行访问者在一次访问中完成的交易数量，以及在一次访问中完成该交易数量的相应访问者数量。</p><p id="65e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写一个 SQL 查询来查找有多少用户访问了银行但没有进行任何交易，有多少用户访问了银行并进行一次交易，等等。</p><p id="87ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果表将包含两列:</p><ul class=""><li id="83ae" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh nj lw lx ly bi translated"><code class="fe lm ln lo lp b">transactions_count</code>即一次访问中完成的交易数量。</li><li id="eec4" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh nj lw lx ly bi translated"><code class="fe lm ln lo lp b">visits_count</code>这是在一次银行访问中做了<code class="fe lm ln lo lp b">transactions_count</code>的相应用户数。</li></ul><p id="e8f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lm ln lo lp b">transactions_count</code>应该取一个或多个用户从<code class="fe lm ln lo lp b">0</code>到<code class="fe lm ln lo lp b">max(transactions_count)</code>的所有值。返回按<code class="fe lm ln lo lp b">transactions_count</code>排序的结果表。</p><p id="8e07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例:</strong></p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="a394" class="mm kk in lp b gy mn mo l mp mq"><strong class="lp io">Input:</strong> <br/>Visits table:<br/>+---------+------------+<br/>| user_id | visit_date |<br/>+---------+------------+<br/>| 1       | 2020-01-01 |<br/>| 2       | 2020-01-02 |<br/>| 12      | 2020-01-01 |<br/>| 19      | 2020-01-03 |<br/>| 1       | 2020-01-02 |<br/>| 2       | 2020-01-03 |<br/>| 1       | 2020-01-04 |<br/>| 7       | 2020-01-11 |<br/>| 9       | 2020-01-25 |<br/>| 8       | 2020-01-28 |<br/>+---------+------------+<br/>Transactions table:<br/>+---------+------------------+--------+<br/>| user_id | transaction_date | amount |<br/>+---------+------------------+--------+<br/>| 1       | 2020-01-02       | 120    |<br/>| 2       | 2020-01-03       | 22     |<br/>| 7       | 2020-01-11       | 232    |<br/>| 1       | 2020-01-04       | 7      |<br/>| 9       | 2020-01-25       | 33     |<br/>| 9       | 2020-01-25       | 66     |<br/>| 8       | 2020-01-28       | 1      |<br/>| 9       | 2020-01-25       | 99     |<br/>+---------+------------------+--------+<br/><strong class="lp io">Output:</strong> <br/>+--------------------+--------------+<br/>| transactions_count | visits_count |<br/>+--------------------+--------------+<br/>| 0                  | 4            |<br/>| 1                  | 5            |<br/>| 2                  | 0            |<br/>| 3                  | 1            |<br/>+--------------------+--------------+</span></pre><p id="a17d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:为了找到想要的结果，我们首先需要找到每个用户和访问日期完成了多少交易。我们需要使用左/右连接，因为我们可能会在没有访问的情况下发生事务。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="cc1e" class="mm kk in lp b gy mn mo l mp mq">+---------+------------------+-------+<br/>| user_id | visit_date       | trans |<br/>+---------+------------------+-------+<br/>| 1       | 2020-01-01       | 0     |<br/>| 1       | 2020-01-02       | 1     |<br/>| 1       | 2020-01-04       | 1     |<br/>| 2       | 2020-01-02       | 0     |<br/>| 2       | 2020-01-03       | 1     |<br/>| 7       | 2020-01-11       | 1     |<br/>| 8       | 2020-01-28       | 1     |<br/>| 9       | 2020-01-25       | 3     |<br/>| 12      | 2020-01-01       | 0     |<br/>| 19      | 2020-01-03       | 0     |<br/>+---------+------------------+-------+</span></pre><p id="0d1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们有了每个用户每天的事务计数，我们就可以用它来找出这些事务需要多少次访问。第一个 CTE 只是生成从 0 到 max 发生的事务数。</p><pre class="me mf mg mh gt mi lp mj mk aw ml bi"><span id="04b3" class="mm kk in lp b gy mn mo l mp mq">WITH trans_count as (<br/>    SELECT row_number() over () as rn<br/>    FROM transactions <br/>    UNION<br/>    SELECT 0<br/>),<br/>t as (<br/>    SELECT coalesce(count(t.amount), 0) as trans<br/>    FROM visits v LEFT JOIN transactions t <br/>    ON v.user_id = t.user_id <br/>       AND v.visit_date = t.transaction_date<br/>    GROUP BY v.user_id, v.visit_date<br/>),</span><span id="f1ab" class="mm kk in lp b gy nk mo l mp mq">SELECT rn as transactions_count, coalesce(sum(rn = trans), 0) as visits_count<br/>FROM t RIGHT JOIN trans_count ON trans = rn<br/>WHERE rn &lt;= (SELECT max(trans) FROM t)<br/>GROUP by rn<br/>ORDER by transactions_count</span></pre><p id="91ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询愉快！！！</p></div></div>    
</body>
</html>