# TDD 不是学来的，是练来的

> 原文：<https://blog.devgenius.io/tdd-is-not-learned-it-is-practiced-e2b9a92eeb8b?source=collection_archive---------1----------------------->

TDD(测试驱动开发)是四个步骤(第一步是思考)，但是这些步骤被认为遵循“使它工作，使它正确，使它快速”的方法。这是一种将设计推迟到最后负责的时刻的方法，测试允许重构，并且测试总是在 TDD 中进行。但是为了有效地完成这些步骤，我们必须停止做一些我们被教导要做的事情。

![](img/088d8076de76c86841b4419db96ceb73.png)

[Pixabay](https://pixabay.com/es/photos/censura-limitaciones-610101/)

[TDD](https://en.wikipedia.org/wiki/Test-driven_development) 看似简单的事情，实际上它是一个 4 步的过程:

*   想
*   创建一个失败的测试
*   用尽可能少的代码通过测试
*   重构

一次又一次地重复这一点，问题是在我的情况下，这违背了我所学的一切。
在我学习的这些年里，我一直被教导要遵循一个过程，这个过程通常意味着在某件事情上非常努力地思考，直到你找到解决方案。在头脑中建立一个模型，帮助你解决问题。我并不是在抱怨这种方法，学校的重点通常是教你一些非常具体的东西来传递一些预先存在的知识。所以他们给你一些工具，通过足够的思考，你能够解决问题(几个小时或者几天，不超过几周)。在这个尺度上，模型是有效的，小问题可以在做某件事之前深入思考，但在大问题上，就不是深入思考的问题了。你需要另一件东西，你需要实验。

当我试图将这个模型应用于大问题时，我需要大量的认知负荷，而且我通常没有所有的信息，我必须发现它。
因此，在这种巨大不确定性的背景下，试图解决我脑海中的问题非常困难。
这是不是意味着我们无法解决大问题，不，不是这样的，但有时候用实验代替深度思考会有效得多。
[在科学上，你称这个为科学方法，编码时你可以称这个为 TDD。](/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157)

## 为什么要做 TDD？

首先，在进行 TDD 之前，我通常在我的代码写完之后写测试，我也学习了模拟，也许我在 TDD 上的学习更难，因为我以前的知识适应了我以前的工作方式。
当我开始做 TDD 时，我认为这是创建覆盖我的代码的测试的好方法，做 TDD 时我确信这将会发生。

但是当我开始的时候，我意识到对我来说创建一个失败的测试是非常困难的，那有什么意义呢？。

*   确信我们正在发展我们的系统，一个通过的测试意味着我们没有增加任何新的价值，这是以前实现的。
*   意识到你做了一个 [YAGNI](https://es.wikipedia.org/wiki/YAGNI) ，你在过去解决了一个你没有的问题(学会如何关注更小的问题)。

我怎么能想象在不考虑如何工作的情况下，如何编写一个关于**如何**工作的测试呢？。这是我首先想到的事情之一，我学会了忘记它是如何工作的，我的测试需要验证我想要创建的东西的输出，并根据输入验证结果，仅此而已。

带有红色代码的 IDE 很烦人，告诉我这个类还不存在。我觉得 IDE 在催促我在完成测试之前创建代码。我学会了抵制这种感觉，在某个时候，我意识到我可以使用 IDE 来创建代码，创建样板文件来拥有一个具有特定签名的类或方法，只需编写如何在我的测试中使用它。
因此，我的 IDE 中的红色代码被转换成我可以用 IDE 创建的东西的信号，我学会了很多快捷方式来更快地完成这项工作，我赢得了编写代码的时间。

为了避免创建大的测试，我使用了我的 mocks 知识，所以在最开始我认为做 TDD 你需要写[单元测试](/unit-tests-c70618dc1e25?sk=de16c7a7bec6fa068728441e55365c97)。在我看来，我写 Java 时的单元是类，所以如果每个类与其他类交互，它们都是用单元测试和模拟创建的。但是 POJO 呢，为什么要测试 getters 和 setters，他们超级简单为什么要在那里做 TDD，那我就没有在那里做 TDD。

在某种程度上，我意识到用这种方法我又在思考大问题，我试图在没有证据的情况下创造一个大的设计(深度思考)，后来我用 TDD 创造了这个小作品。
但是使用这种方法，我并没有发现太多东西，事实上，除了我的第一个目标之外，这与我以前所做的并没有太大的不同——始终进行覆盖重要代码的测试。
我试图做 **TDD inside out** ，但是我不太擅长通过它来展现设计。

这种方法的另一个问题是模仿的影响，我意识到这么多的模仿很难重构。如果不是我所有的测试都通过了，而是我的代码在生产中出了问题，那么改变一个行为使用的类意味着改变模拟并记住它。我的测试很脆弱，因为我大量使用了模拟。但是我也花了很多时间重构东西，并且不得不在以后处理不可能的合并，因为其他人和我在同一个代码库中工作。我明白了时间很重要(痛苦的经历)。

所以我开始玩在几分钟内完成 TDD 循环的游戏，如果我做不到，我会删除所有代码，并再次强迫自己一小步一小步地思考，以便及时完成循环。有时我无法减少时间。所以为了提高，我在[重构实践和原则](/software-design-principles-ccc3913bfd56?sk=072f3a4d996bfd3106e1583f8f667fa8)中花了很多精力:

*   GOF 设计图案
*   掌握设计模式
*   马丁·福勒的《重构》一书
*   更大的

## 设计决策

我认为这是我做 TDD 的第二个阶段，我开始在我创造的设计中思考解决我的问题。

重构是一个问题，因为过度使用了模仿。但是我想重构，因为我的设计对我的问题来说不够好。
然后一个想法出现在我的脑海中，为什么不用集成测试来测试所有的东西(为什么不用 TDD 来测试集成)，这样我就不需要去研究类的细节，而且我可以在中间进行重构。

我尝试了，我意识到我对所有的集成测试都有很坏的影响，TDD 的反馈循环非常慢，我必须在检查我的功能工作之前完成几乎所有的事情。此外，我的测试非常慢，我不得不等待几分钟，而不是几秒钟。
因为共享资源的缘故，一些测试不时失败，他们很古怪。
由于反馈回路缓慢，我[批量修改](/batching-1e23cc939710?sk=e4244dcaaa7cdd2ea676f07c6f0314d3)。
这和滥用 E2E 测试的效果一样，请不要做 E2E 测试。

现在，我能够更快地重构，并使用重构来改进我的设计，但就复杂性而言，我不得不为此付出很多。使用 db 进行复杂的测试设置，并通过纯文本(jsons、xmls 等)与我的代码对话。
在我正在学习如何在室外做 **TDD。**

## 六角形建筑

与此同时，我学习了六边形建筑，一些事情开始浮现在我的脑海里。
也许集成测试对于与我的基础设施非常耦合的代码是好的，而单元测试对于测试纯行为是好的。所以我可以在两边都使用 TDD，但不混合它们之间的逻辑，所以在这些层的边界使用 doubles，并允许在中间进行重构。

单元测试的单元是行为(六角形架构中的用例)。将通过集成测试来测试端口的实现，以检查我是否正确地使用了库框架来连接到我的 DB、rest 端点等。

做 TDD，我能够发现纯粹的行为，并在边界中使用 doubles 来发现什么是域，什么是基础设施。我的一个朋友告诉我，事实上，你可以从基础架构中的一切开始，并在对你来说更清楚的时候(当你意识到边界在那里的时候)，尝试强调将东西移动到域中。

我在考虑实现[永远绿色](/being-always-green-ea1a072c87f3?sk=fdbc6ba8f0849599d5c46bb133362701)的想法。如果我能让我的代码一直工作，为什么我还需要分支。我学会了 [CI/CD](https://javi-kata.medium.com/ci-cd-for-dummies-b45ed917f9dc?sk=28eede1d5fec71121eea4954583130e9) 和[基于主干的开发](https://trunkbaseddevelopment.com/)，感谢 TDD 让我学会了小步骤和频繁的安全变更，所以很自然地朝那个方向前进。

在这个阶段，我有一个预定义的架构可以在我的服务中使用，这个分层的架构帮助我在我的行为中间进行重构，并定义层之间的边界。我能够在两方面(基础设施和领域)使用 TDD，我的反馈循环很快，但是我也有一个问题。有时候六边形架构看起来有些过头了，我在领域部分的测试非常简单，一个合作者就是一个仓库，一个从数据库到另一个类的翻译。

## 这是不是工程过度？

如果我在做 TDD 的时候试图找到正确的设计怎么办？TDD 的第三步说“写最少的代码”，第四步重构。在重构时，如果我可以使用来自我的测试的信号来决定我是否需要把事情分成不同的类，那会怎么样？。
也许总是用六边形架构不太好，每个问题都不一样。我开始了[进化设计](/evolutionary-design-cfb1795e8f81?sk=b32e3f4396a3576ea88726d8ce8fc73b)的道路。

然后像“看情况”这样的事情总是在我的脑海里，事情没有错也没有好。当我在不同的选项之间做决定时，我试着在权衡中思考，如果我没有足够的信息，我试着不应用想法(**最后负责的时刻**)。如果你从 TDD 的角度考虑:

*   当您需要通过测试时，您在最后负责任的时刻编写代码。
*   你在工作的最后负责任的时刻改进你的设计。

现在我觉得我进入了一个新的阶段，不确定这是不是最后一个，但是我觉得现在我可以用 TDD 来学习了。我尝试创建一些假设，并通过测试和学习来验证它们，而不是花几个小时阅读库的文档。
让我们看看接下来会发生什么！！