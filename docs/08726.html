<html>
<head>
<title>Understanding Perceptron as Logical Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将感知器理解为逻辑运算符</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-perceptrons-as-logical-operators-553a254b80d5?source=collection_archive---------12-----------------------#2022-07-05">https://blog.devgenius.io/understanding-perceptrons-as-logical-operators-553a254b80d5?source=collection_archive---------12-----------------------#2022-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/b4b7023807007f3b0263bcd0e3c2b2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*wvZ_nAvV-UCGWPbUGo6PkA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">神经网络</figcaption></figure><p id="c5f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们深入了解其工作原理之前，让我们先简单介绍一下。</p><p id="13aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感知器是一种神经网络单元，它映射其输入“x ”,然后乘以权重“w ”,然后生成并输出值 f(x)。也就是说，它接受实值输入的向量，计算它们的线性组合，如果结果大于阈值，则输出 1，否则输出 0！如果你需要更多关于感知机的理解，请浏览<a class="ae ku" href="https://towardsdatascience.com/https-medium-com-francesco-cicala-whats-whys-and-hows-of-perceptron-f87c66f512c5" rel="noopener" target="_blank">感知机:什么，为什么和如何</a></p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/26133097afc14f98e52dcfc0526bd700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*H8SFCNbDE4SItY7rNkBFnA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">单层感知器</figcaption></figure><p id="f983" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理解感知器算法的技巧:</p><ol class=""><li id="cef5" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">从随机权重开始<em class="kt"> w1，w2，…..，wn </em></li><li id="f38e" class="la lb in jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">对于每一个误分类点(<em class="kt"> x1，x2，…，xn</em>)；如果预测=目标，那么什么也不做，否则你更新权重！</li><li id="9fd7" class="la lb in jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">如果预测=！目标，那么权重应该被更新为<em class="kt">Wi</em>=<em class="kt">Wi</em>+/—<em class="kt">αXi</em>，这取决于<em class="kt"> α </em>是<em class="kt">学习率</em>的情况</li></ol><p id="3424" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">和运算符</strong></p><p id="a331" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只有当两个输入都为真时，才会返回<em class="kt">真</em>，否则输出将始终为假，即如果任何一个输入为<em class="kt">假。</em>让我们来理解一个感知器是如何实现这个逻辑运算符的功能的。我将通过将其命名为一个<em class="kt">实例来解释每一行中发生的事情。这意味着在下面的与门中，有 4 个实例。</em></p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/50f4dc09e83b41ecb84e3a7e7cc61fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*ZuI2LG0ma1RkpXHwbni_FQ.png"/></div></div></figure><p id="f3d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与上图相关联的这个等式将是:<br/>ŷ=θ(<em class="kt">w1 * x1+w2 * x2+b</em>)。现在让我们抛开这个等式，把它算出来！在上面的 AND 运算符中，让我们取下列任意参数:</p><p id="12e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">A = X1，B = X2，w1 = 1.3，w2 = 0.6，学习率(<em class="kt"> α) = </em> 0.5，阈值= 1</p><ol class=""><li id="86e4" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">实例 a: A = 0，B = 0，目标输出= 0</li></ol><p id="f2a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> wi.xi = </em> 0 * 1.3 + 0 * 0.6 = 0，<em class="kt"> </em>即预测的<em class="kt"> </em>输出<em class="kt"> </em>不大于阈值(1)，所以输出= 0。在这种情况下，目标输出和预测输出是相同的。</p><p id="c2d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.实例 b: A = 0，B = 1，目标输出= 0</p><p id="aeec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> wi.xi = </em> 0 * 1.3 + 1 * 0.6 = 0.6 并且由于这个预测输出不大于阈值，所以输出= 0。在这种情况下，目标输出和预测输出是相同的。</p><p id="33f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.实例 c: A = 1，B = 0，目标输出= 0</p><p id="2f65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> wi.xi </em> = 1 * 1.3 + 0 * 0.6 = 1.3 并且由于这个预测值大于阈值，所以输出= 1。</p><p id="567f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题来了，这个实例的预测输出是 1，而目标输出是 0，这意味着权重需要调整。</p><p id="3fb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="kt">wi = wi</em>+<em class="kt">α(t</em>—<em class="kt">o)Xi</em></strong></p><p id="374f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中<em class="kt"> wi </em> =被调整的权重，t =目标输出，o =预测输出，<em class="kt"> α </em> =学习率，<em class="kt"> xi </em> =该实例的相应输入。使用该等式，新的权重计算如下:</p><p id="0dff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">w1 = 1.3+0.5(01)1 = 0.8</p><p id="4f77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">w2 = 0.6+0.5(01)0 = 0.6</p><blockquote class="lt lu lv"><p id="9f8d" class="jv jw kt jx b jy jz ka kb kc kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">现在我们有了新的修改后的权重，我们需要从第一个实例开始计算，以确保这个新的权重能够正确地对它们进行分类。</em>T9】</strong></p></blockquote><p id="6b5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">修改后的参数如下:</p><p id="f6c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">w1 = 0.8，w2 = 0.6，学习率= 0.5，阈值= 1</p><p id="aad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">a) A = 0，B = 0，目标输出= 0</p><p id="3f51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> wi.xi = </em> 0 * 0.8+ 0 * 0.6= 0，<em class="kt"> </em>即预测的<em class="kt"/><em class="kt"/>输出不大于阈值(1)，所以输出= 0。在这种情况下，目标输出和预测输出是相同的。</p><p id="e369" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b) A = 0，B = 1，目标输出= 0</p><p id="61be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> wi.xi = </em> 0 * 0.8+ 1 * 0.6 = 0.6 并且由于这个预测输出不大于阈值，所以输出= 0。在这种情况下，目标输出和预测输出是相同的。</p><p id="667a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">c) A = 1，B = 0，目标输出= 0</p><p id="8a80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">wi . Xi =</em>1 *<em class="kt"/>0.8+0 * 0.6 = 0.8，由于这个预测输出不大于阈值，所以输出= 0。在这种情况下，目标输出和预测输出是相同的，不再需要修改。</p><p id="38ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">d) A = 1，B = 1，目标输出= 1</p><p id="2898" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">wi . Xi =</em>1 *<em class="kt"/>0.8+1 * 0.6 = 1.4 并且由于该预测输出大于阈值，所以输出= 1，这类似于目标输出。</p><p id="1890" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们很高兴我们的感知器已经正确地预测了 AND 逻辑运算符的所有输出。因此，这些是感知器算法中与门的最终参数。请注意，我们故意忽略了偏差，这是为了清晰起见。实际上，一旦权重更新，偏差也会类似地更新。我希望这能让你明白感知机的逻辑。同样的方法可以用来理解或门。让我知道你的想法。</p></div></div>    
</body>
</html>