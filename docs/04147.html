<html>
<head>
<title>React Native + Redux + Redux-Saga as application architecture.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native + Redux + Redux-Saga 作为应用架构。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-native-redux-redux-saga-as-application-architecture-9c78af25fe63?source=collection_archive---------0-----------------------#2021-02-01">https://blog.devgenius.io/react-native-redux-redux-saga-as-application-architecture-9c78af25fe63?source=collection_archive---------0-----------------------#2021-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f589" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我合作过的 Redux 和 Redux-Saga 的一些实用方面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8777f333bd77aa7658e5fcd39baf9822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MnACrccEz1wnNIOtfqXxA.png"/></div></div></figure><p id="cae5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自从 React v16.8.0 以来，许多钩子变得可用。它简化了生活。</p><p id="60b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">钩子让你不用类就可以使用更多的 React 特性。钩子为您已经知道的 React 概念提供了一个更直接的 API:props、state、context、refs(通过 id 引用访问对象)和 lifecycle。</p><p id="5f47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一、需要实施的实际任务:将 Google map 集成到 React 原生应用中。让我们看看 Android 部分。iOS 部分缺失，无法制作紧凑的文章。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/db0195ef786f1826643aec9f7ec44632.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*IrEywq2I58Tw53oQi3bGCQ.png"/></div></figure><p id="4348" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">0.在 Intellij IDEA 或 Visual Studio 代码中创建新的 React 本机项目</p><ol class=""><li id="5ede" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">在计算机上安装<strong class="jm io"> npm </strong>或<strong class="jm io">纱线</strong>并运行以下命令</li></ol><p id="253c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> npm 安装—保存 react-native-maps </strong></p><p id="89de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">或纱线添加反应-原生-贴图</strong></p><p id="a418" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.对于 Android 版本，我们需要向 Android.manifest 添加 meta 标签</p><p id="3bcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">&lt;uses-permission android:name=”android.permission.ACCESS_COARSE_LOCATION” /&gt;<br/> &lt;uses-permission android:name=”android.permission.ACCESS_FINE_LOCATION” /&gt;</code></p><p id="24bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">&lt;meta-data<br/> android:name=”com.google.android.geo.API_KEY”<br/> android:value=”Google Api key”/&gt;</code></p><p id="45ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.另外，需要在 Activity java 文件中正确处理 android 权限。</p><p id="1d77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.当新的 npm 库添加到项目中时，它也需要在/android/文件夹中运行一些干净的命令。在控制台中运行:</p><p id="ceea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">梯度清理<br/> npm 启动— —重置缓存</strong></p><p id="304d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.我们必须使用 Axios 库的标准方式下载远程存储的数据。此外，让我们实现一个简单的循环周期，它将以 1 分钟为间隔进行更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="efc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.上面的代码非常简单:它将实现逻辑和视图混合在一起。让我们在<strong class="jm io"> Redux </strong>和<strong class="jm io"> Redux-Saga </strong>的帮助下将它们分割出来。</p><p id="1934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我更愿意把<strong class="jm io"> Redux-Saga </strong>看作一个独立的线程，在后台模式下运行异步场景，并将结果返回给组件视图。</p><p id="8333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redux 看起来像是一种 MVC 方法。组件是一个视图 UI，动作是一个控制器，Reducer 是一个模型(保持当前状态)，Redux-Saga 是一个后台服务。Store 就像一个状态容器，它聚集了所有的 reducers。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/01f4f31db33d48cb91080adbde452803.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*KPC02VARKM9HoaJ8iKI_wA.png"/></div></figure><p id="a883" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redux 它只是一个支持异步方法的状态容器。当一个动作发生时，在 reducer 被调用并刷新状态后，对象发送到存储。</p><p id="290a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在异步方法的情况下，Redux 使用中间件 Redux-Saga 层。它在动作之后，但在调用 reducer 之前运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/4faf2ef917d07a82414ed5063a257f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*pRT75xzVKR_1HhQU90unbA.png"/></div></figure><p id="8b03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.在 main.js 文件中使用 applyMiddleware 函数将<code class="fe le lf lg lh b">Root Saga</code>从 saga.js 插入到 store 中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="7ba3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8.首先，我们必须定义根。将我们的发电机组合在一起(传奇故事):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="f4a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Saga 实现为控制异步副作用的中间件。</p><p id="e803" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redux-saga 在<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"> ES6 发电机</a>的帮助下完成。生成器是可以在必要时暂停或恢复的功能。生成器将执行代码，直到它发现<strong class="jm io">产生</strong>关键字。</p><p id="9bfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，如果您需要在外部发生某些事情(超时发生或用户操作)时取消传奇，那么使用<strong class="jm io"> yield race </strong>关键字是有意义的。</p><p id="7a8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> yield put </strong>关键字告诉 Redux-Saga 应该调度该操作。</p><p id="e285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> yield take </strong>关键字导致 Redux-Saga 阻塞，直到指定的动作被分派。请注意，这不会阻止您的 UI 或页面上的任何其他处理。</p><p id="e23b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">9.现在我们定义无限循环来不时地下载数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3ef7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">10.是时候用<strong class="jm io"> Redux </strong>工作了。</p><p id="2928" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我们的商店将由类型、动作、减速器和可能的选择器组成。</strong></p><p id="d158" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们定义稍后将使用的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="92b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">11.动作是一个包含信息负载的对象。</p><p id="0175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">动作是 Redux 存储更新的唯一信息来源。它们是 Redux 应用程序中唯一触发更改的东西，它们包含应用程序存储更改的有效负载。Reducers 根据<strong class="jm io">动作的值更新存储。键入</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="cba8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">12.Reducer 是一个纯粹的函数，它将应用程序和动作的状态作为参数，并返回一个新的状态。但是不改变先前的状态。</p><blockquote class="ln lo lp"><p id="ffb2" class="jk jl lq jm b jn jo jp jq jr js jt ju lr jw jx jy ls ka kb kc lt ke kf kg kh ig bi translated">纯函数是没有任何副作用的函数，如果传入相同的参数，将返回相同的结果。</p></blockquote><p id="1d5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在缺省状态或 null 的情况下，Reducer 需要应用程序的初始状态。</p><p id="f22e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们通过 GET_SUCCESS 类型定义了聚集这个调用的 reducer 部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="56cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">13.Redux-Saga 引用了我们的存储，它调用 get state，将状态传递给我们的选择器。现在是时候编写一个 React 组件来获取数据并在地图上显示标记了。我们的任务已经完成了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="ba23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">14.减速器的附加物。如果是大的实现逻辑，我们可以把它移到<strong class="jm io">选择器</strong>中。这使得我们的缩减器小巧易读。假设我们需要过滤一些数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/8b940a65cf13c175e32fa80694f2505e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Dpw_4-ufpoWLQivfroB3qw.png"/></div></figure><p id="58a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二。其他想法。</strong>某些物体的行为在反应原生。</p><ol class=""><li id="8890" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">React 中的 Singleton:有时只运行一次函数非常有用:</li></ol><p id="bff1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">const useSingleton = (initializer) =&gt; {<br/> React.useState(initializer);<br/>}<br/>const MyFunctionalComponent = () =&gt; {<br/> useSingleton(() =&gt; {<br/> // run only once<br/> });<br/>}</code></p><p id="b8ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.FC -功能组件</p><p id="1403" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">FC 是无状态组件，没有组件生命周期。因此你不能指定一个<code class="fe le lf lg lh b">constructor</code>。</p><p id="4701" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你必须扩展<code class="fe le lf lg lh b">React.Component</code>来创建一个有状态的组件，然后这个组件需要一个构造器，你就可以使用<code class="fe le lf lg lh b">state</code>。</p><p id="4e5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">无状态:</strong></p><pre class="kj kk kl km gt lv lh lw lx aw ly bi"><span id="f0bc" class="lz ma in lh b gy mb mc l md me">import React from 'react'</span><span id="6697" class="lz ma in lh b gy mf mc l md me">const StatelessObject = ({title}) =&gt; (<br/>  &lt;div&gt;{`${title}`}&lt;/div&gt;<br/>);<br/>const [value, setValue] = useState(props.value || 0);</span></pre><p id="19b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io"> useEffect </strong>在 FC 中模拟构造函数。</p><p id="b103" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">useEffect(() =&gt; {<br/> // call some useful functions<br/>}, []);</code></p><p id="354c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> useEffect </strong> hook 将旧的 React 生命周期方法 componentDidMount、componentDidUpdate 和 componentWillUnmount 组合在一起。</p><p id="09af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.如果变量被改变了，如何通知组件？</p><p id="75fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">const myList: MyDataSource[] = [];<br/>useEffect(() =&gt; {<br/> console.log(‘value has been changed’);<br/> if (myList?.data) treatData(myList.data);<br/>}, [<strong class="jm io">myList</strong>]); //it is a way to use it to only re-run if variable changes</code></p><p id="3419" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">小心使用不依赖数组的效果。默认情况下，useEffect 总是在 render 运行后运行。这意味着如果你没有包含一个依赖数组，并且使用 useEffect，你可能会陷入一个无限循环。至少使用空数组[]。</p><p id="a0cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时候，数组数据并不总是更新的，我们可以用这个技巧:</p><p id="fb28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了使用 useEffect()的第二个参数数组中的数据，我们还可以使用[JSON.stringify(data)]:</p><p id="d5e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe le lf lg lh b">useEffect(() =&gt; {<br/> console.log(‘value has been changed’);<br/>}, [JSON.stringify(data)]); // Changes will be caught :) !</code></p><p id="b057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.处理地图标记行为的棘手部分。标记状态可以是活动的或不活动的。让我们改变颜色来区分点击地图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="c24f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="6761" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React Native 提供了另一个机会来创建移动应用程序，而不是使用 Flutter、Ionic、Android Java/Kotlin 或 iOS Swift。Redux 将逻辑拆分为类型、动作、缩减器和选择器，使代码更清晰，更易于单元测试。Redux-Saga 将实现逻辑作为后台进程运行。</p><div class="mg mh gp gr mi mj"><a href="https://reactnative.dev/docs/getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">介绍反应自然</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">欢迎来到 React Native 之旅的起点！如果您正在寻找环境设置说明，他们已经…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">反应性发展</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx ks mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a href="https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">基础知识，第 3 部分:状态、动作和缩减器</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">在第 2 部分:Redux 概念和数据流中，我们看到了 Redux 如何帮助我们构建可维护的应用程序</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">redux.js.org</p></div></div><div class="ms l"><div class="my l mu mv mw ms mx ks mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a href="https://redux-saga.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd io gy z fp mo fr fs mp fu fw im bi translated">读我</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">redux-saga 是一个旨在使应用程序副作用(即异步的东西，如数据获取和…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">redux-saga.js.org</p></div></div></div></a></div></div></div>    
</body>
</html>