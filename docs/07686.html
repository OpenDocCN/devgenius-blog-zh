<html>
<head>
<title>Introduction to Docker — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 简介—第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-docker-part-1-7646c995282c?source=collection_archive---------3-----------------------#2022-04-15">https://blog.devgenius.io/introduction-to-docker-part-1-7646c995282c?source=collection_archive---------3-----------------------#2022-04-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="31b1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果你曾经面临“它在我的机器上工作的问题”, Docker 可能是解决方案。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7873bba2c664c6c29532d4691a17cde8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-N1-m2-F7l3rAzMMOS5SA.png"/></div></div></figure><h1 id="3ab7" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="c8a1" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Docker 是一个容器化平台，用于构建基于容器的应用程序和服务。总而言之，容器包含一个应用程序及其所有的依赖项，可以在不同的用户、位置和系统之间轻松共享。</p><h1 id="acd3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">容器与虚拟机</h1><p id="6a42" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">通常使用虚拟机的人可能会问自己，如果他们也可以使用虚拟机，为什么还要使用 Docker 和容器化。下图显示了主要区别。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/bf30efebc840a942927b8f5335ecb65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1vyqnqod6jasiAsyTt3Yw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">容器与虚拟机</figcaption></figure><p id="5367" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">系统的基础始终是基础设施，如 PC 或服务器。容器和虚拟机的主要区别在于操作系统。虚拟机总是有自己的操作系统，称为客户操作系统。一个虚拟机管理程序可以管理多个使用不同操作系统的虚拟机。在集装箱化的情况下，需要一个集装箱引擎(如码头引擎)。容器总是与运行容器引擎的系统共享操作系统。所以叫共享 OS。此外，必须指出的是，单个虚拟机可以用于不同的服务，如数据库、web 服务和邮件服务器，而容器应该只用于单个服务。对于虚拟机示例，需要三个容器，一个用于数据库，一个用于 web 服务，一个用于邮件服务器。</p><p id="f668" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">总而言之，与虚拟机相比，Docker 的主要优势是:</p><ul class=""><li id="7540" class="mm mn in li b lj mh lm mi lp mo lt mp lx mq mb mr ms mt mu bi translated"><strong class="li io">更快的启动:</strong>不需要启动任何操作系统</li><li id="c55d" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb mr ms mt mu bi translated"><strong class="li io">隔离:</strong>每个服务都被隔离在自己的容器中，有自己的依赖关系</li><li id="9075" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb mr ms mt mu bi translated"><strong class="li io">可移植性:</strong>一旦服务被容器化，容器就可以很容易地转移到不同的基础设施或其他人的系统上</li></ul><h1 id="0bb5" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">Docker 的组件</h1><p id="1579" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">本文的下一部分将给出 Docker 提供的不同组件的一些见解。</p><h2 id="2fdb" class="na kp in bd kq nb nc dn ku nd ne dp ky lp nf ng la lt nh ni lc lx nj nk le nl bi translated">码头引擎</h2><p id="d8a5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">每一种集装箱化技术都需要一个集装箱引擎。容器引擎是一个软件，用于管理容器、接受用户输入和处理图像或其他容器化对象。容器引擎的一个例子是<strong class="li io"> Docker 引擎</strong>。它由三部分组成:</p><ul class=""><li id="46dc" class="mm mn in li b lj mh lm mi lp mo lt mp lx mq mb mr ms mt mu bi translated"><strong class="li io"> Docker 守护进程</strong> <code class="fe nm nn no np b">dockerd</code>:管理图像和容器等对象</li><li id="64b1" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb mr ms mt mu bi translated"><strong class="li io"> Docker API </strong>:用于与<code class="fe nm nn no np b">dockerd</code>通信的 RESTful API</li><li id="7531" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb mr ms mt mu bi translated">Docker CLI:Docker 的命令行界面</li></ul><p id="4c03" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">关于 Docker 引擎的安装细节:<a class="ae nq" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">安装 Docker 引擎</a></p><h2 id="c042" class="na kp in bd kq nb nc dn ku nd ne dp ky lp nf ng la lt nh ni lc lx nj nk le nl bi translated">Docker 图像</h2><p id="e43d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">图像被用作启动容器的蓝图。它知道启动容器所需的一切，所需的源文件，以及其他一切。基本上，有两种方法可以获得所需的图像:</p><ul class=""><li id="f400" class="mm mn in li b lj mh lm mi lp mo lt mp lx mq mb mr ms mt mu bi translated">公共 Docker 图像</li><li id="a646" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb mr ms mt mu bi translated">创建个人文档</li></ul><h2 id="a1b7" class="na kp in bd kq nb nc dn ku nd ne dp ky lp nf ng la lt nh ni lc lx nj nk le nl bi translated">Dockerfile 文件</h2><p id="1778" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">要创建个人图像来归档您自己的应用程序，可以使用归档文件。Dockerfile 是一个基于文本的文件，用于定义用户在命令行上调用的命令来构建图像，这将在后面描述。以下示例显示了如何将 NodeJS-application 容器化。关键字<code class="fe nm nn no np b">FROM</code>定义了我们图像的基础图像。在这种情况下，基础映像是<code class="fe nm nn no np b">node:16</code>，它提供了容器化 NodeJS-app 所需的一切。例如，基础映像也可以是在容器中运行 MySQL 数据库的<code class="fe nm nn no np b">mysql</code>。<a class="ae nq" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>提供了大量图像，可以直接使用，也可以用作 Docker 文件中的基础图像。在定义基础图像之后，执行以下步骤:</p><ol class=""><li id="6bb8" class="mm mn in li b lj mh lm mi lp mo lt mp lx mq mb nr ms mt mu bi translated">创建目录<code class="fe nm nn no np b">/app</code>并定义为工作目录</li><li id="cdac" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb nr ms mt mu bi translated"><code class="fe nm nn no np b">COPY</code>的本地文件<code class="fe nm nn no np b">package.json</code>到当前工作目录的容器中</li><li id="8820" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb nr ms mt mu bi translated">安装<code class="fe nm nn no np b">package.json</code>中定义的 npm 包</li><li id="682c" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb nr ms mt mu bi translated"><code class="fe nm nn no np b">COPY</code>将所需的源文件复制到当前工作目录</li><li id="77ba" class="mm mn in li b lj mv lm mw lp mx lt my lx mz mb nr ms mt mu bi translated"><code class="fe nm nn no np b">CMD</code>定义容器启动时执行的命令</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6365" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">从 Dockerfile 文件生成图像的过程称为构建。命令<code class="fe nm nn no np b">docker build -t &lt;Tag&gt; .</code>将构建 Dockerfile 文件。标志<code class="fe nm nn no np b">-t</code>用于标记图像，它基本上是给 Dockerfile 一个名称。末尾的<code class="fe nm nn no np b">.</code>定义了 Dockerfile 的路径，在本例中是当前目录。</p><p id="8af1" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">更多可以在 docker 文件中使用的命令以及关于它们的描述可以在<a class="ae nq" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">docker 文件参考</a>中找到。</p><h2 id="da75" class="na kp in bd kq nb nc dn ku nd ne dp ky lp nf ng la lt nh ni lc lx nj nk le nl bi translated">。dockerignore</h2><p id="779d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">文件<code class="fe nm nn no np b">.dockerignore</code>可用于在构建过程中忽略文件。如果你想忽略你的<code class="fe nm nn no np b">node_modules</code>或类似的，这可能是需要的。因此，需要一个名为<code class="fe nm nn no np b">.dockerignore</code>的文件，其中包含应该忽略的文件。下面的例子将忽略目录<code class="fe nm nn no np b">.git</code>和<code class="fe nm nn no np b">node_modules</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5d4e" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">关于语法的细节可以在这里找到:<a class="ae nq" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">。dockerignore 文件</a></p><h2 id="773b" class="na kp in bd kq nb nc dn ku nd ne dp ky lp nf ng la lt nh ni lc lx nj nk le nl bi translated">登记处</h2><p id="a38a" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Docker 中的注册表用于存储、管理和提供图像。公共注册中心的一个例子是已经提到的<a class="ae nq" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>。Google 也提供了他们自己的容器注册表:<a class="ae nq" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">Google-Container-Registry</a>。当已经使用 Gitlab 进行版本控制时，它也可以用作容器注册表，因为它提供了这个特性。除了公共注册中心，还可以部署个人注册中心。这可以通过使用 Docker 直接提供的 image <a class="ae nq" href="https://hub.docker.com/_/registry" rel="noopener ugc nofollow" target="_blank">注册表</a>来完成。</p><h1 id="4301" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">图像分层</h1><p id="6da2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Docker 图像构建在所谓的层中。docker 文件中的每一行都指向一层，而每一层只包含对前一层的更改。这样做的好处是，只有 docker 文件中真正有变化的命令才需要重新构建。对于我们的 NodeJS-app 来说，这意味着源代码的改变只会影响第二条<code class="fe nm nn no np b">COPY</code>指令。所有其他步骤都将被缓存。</p><p id="274d" class="pw-post-body-paragraph lg lh in li b lj mh jo ll lm mi jr lo lp mj lr ls lt mk lv lw lx ml lz ma mb ig bi translated">可以使用命令<code class="fe nm nn no np b">docker history &lt;Name&gt;</code>分析图像。对于前面描述的 NodeJS-image，输出如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><blockquote class="nu nv nw"><p id="3c63" class="lg lh nx li b lj mh jo ll lm mi jr lo ny mj lr ls nz mk lv lw oa ml lz ma mb ig bi translated">查看该系列的第 2 部分:</p></blockquote><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-docker-part-2-73b36d0722e0"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd io gy z fp oj fr fs ok fu fw im bi translated">Docker 简介—第 2 部分</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">如果你曾经面临“它在我的机器上工作的问题”, Docker 可能是解决方案。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">blog.devgenius.io</p></div></div><div class="on l"><div class="oo l op oq or on os km oe"/></div></div></a></div></div></div>    
</body>
</html>