<html>
<head>
<title>Exploring Yew, the rust-based frontend framework as a Vue Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为 Vue 开发者探索基于 rust 的前端框架 Yew</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/exploring-yew-the-rust-based-frontend-framework-as-a-vue-developer-36051a4f8bbb?source=collection_archive---------1-----------------------#2022-09-27">https://blog.devgenius.io/exploring-yew-the-rust-based-frontend-framework-as-a-vue-developer-36051a4f8bbb?source=collection_archive---------1-----------------------#2022-09-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/22e5d533f2c01ec0dc825d8c95d966ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wyy0obSt2c_Nu2JdwFpsjA.png"/></div></div></figure><p id="47bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WebAssembly，俗称 WASM，彻底改变了 web 应用程序的构建方式。它允许开发者使用他们最喜欢的编程语言来构建网络应用。</p><p id="4e1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这些可能性，开发人员在构建前端应用程序时就不用承担学习基于 JavaScript 的框架的负担了。他们可以利用自己喜欢的编程语言特性，如静态类型、模式匹配、内存安全等，来构建前端应用程序。</p><p id="f246" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Yew 是一个基于 Rust 的现代框架，用于使用 WebAssembly 构建前端应用程序。</p><p id="55b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本帖中，作为一名 Vue 开发者，我们将学习如何使用来自<a class="ae kt" href="https://dummyjson.com/" rel="noopener ugc nofollow" target="_blank"> DummyJSON </a>和 Yew 的开放 API 数据构建一个 web 应用程序。<br/> GitHub 资源库可以在<a class="ae kt" href="https://github.com/Mr-Malomz/yew-starter" rel="noopener ugc nofollow" target="_blank">这里找到</a>。</p><h1 id="d431" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Vue 和紫杉的相似之处</h1><p id="75cb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">以下是这两种技术之间的相似之处:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">类似</figcaption></figure><h1 id="685e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">先决条件</h1><p id="02e9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">要完全掌握本教程中介绍的概念，需要满足以下要求:</p><ul class=""><li id="eb94" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">对 Vue 的基本了解</li><li id="39e2" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">对铁锈的基本认识</li><li id="215b" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">生锈<a class="ae kt" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">安装</a></li></ul><h1 id="0965" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开发环境设置</h1><p id="a0bd" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，我们需要确保我们的机器上安装了最新版本的 Rust。我们可以通过运行以下命令升级到稳定版本:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="b4fd" class="na kv in mw b gy nb nc l nd ne">rustup update</span></pre><p id="08ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要安装一个 WASM 目标，这是一个帮助我们将 Rust 源代码编译成基于浏览器的 WebAssembly 并使其在 web 浏览器上运行的工具。我们可以通过运行以下命令来安装它:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="20e5" class="na kv in mw b gy nb nc l nd ne">rustup target add wasm32-unknown-unknown</span></pre><p id="3ee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们需要安装 Trunk，这是一个用于管理和打包 WebAssembly 应用程序的工具。我们可以通过运行下面的命令来做到这一点:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="d034" class="na kv in mw b gy nb nc l nd ne">cargo install trunk</span></pre><h1 id="79ae" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">入门指南</h1><p id="8894" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行以下命令:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="f49b" class="na kv in mw b gy nb nc l nd ne">cargo new yew-starter &amp;&amp; cd yew-starter</span></pre><p id="38d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令创建一个名为<code class="fe nf ng nh mw b">yew-starter</code>的 Rust 项目，并导航到项目目录。</p><p id="2181" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">cargo</code>是 Rust 的包经理。它的工作方式类似于 Vue 生态系统中的<code class="fe nf ng nh mw b">npm</code>。</p><p id="8839" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行该命令时，<code class="fe nf ng nh mw b">cargo</code>将生成一个包含基本文件的项目目录，如下所示:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1d7c178c6ef59996a03d2e98f74c0ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/0*RwhFtBZEdWgdvv9I.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">项目结构</figcaption></figure><p id="0406" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">main.rs</code>是我们应用程序的入口点。</p><p id="1124" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">Cargo.toml</code>是清单文件，用于指定项目元数据，如包、版本等。它的工作方式类似于 Vue 应用程序中的<code class="fe nf ng nh mw b">package.json</code>。</p><p id="d549" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们通过修改<code class="fe nf ng nh mw b">Cargo.toml</code>文件的<code class="fe nf ng nh mw b">[dependencies]</code>部分来安装所需的依赖项，如下所示:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="c786" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">yew = “0.19”</code>是一个基于 Rust 的前端框架</p><p id="20e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">serde = “1.0.136”</code>是一个序列化和反序列化 Rust 数据结构的框架。例如，将 Rust 结构转换为 JSON。</p><p id="85f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">gloo-net= “0.2”</code>是一个 HTTP 请求库。它的工作原理类似于 Vue 生态系统中的 axios。</p><p id="0df4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">wasm-bindgen-futures = “0.4”</code>是一个基于 Rust 的库，通过在 Rust 异步编程(futures)和 JavaScript <code class="fe nf ng nh mw b">Promises</code>之间架起桥梁，在 Yew 中执行异步编程。基本上，它有助于利用 Rust 中基于<code class="fe nf ng nh mw b">Promise</code>的 web APIs。</p><p id="3668" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要运行下面的命令来安装依赖项:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="9925" class="na kv in mw b gy nb nc l nd ne">cargo build</span></pre><h1 id="89f3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">应用程序入口点</h1><p id="e29d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">安装了项目依赖项后，我们需要修改 src 文件夹中的<code class="fe nf ng nh mw b">main.rs</code>文件，如下所示:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="306f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哎呀！在上面的代码片段中，看起来发生了很多事情。让我们把它分解一下。</p><p id="0d8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">use yew::prelude::*</code>:通过指定<code class="fe nf ng nh mw b">*</code>导入所需的<code class="fe nf ng nh mw b">yew</code>依赖项及其关联项</p><p id="2fee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">#[function_component(App)]</code>:将<code class="fe nf ng nh mw b">app</code>功能声明为功能组件，名称为<code class="fe nf ng nh mw b">App</code>。这里使用的语法称为 Rust 宏；宏是编写其他代码的代码。</p><p id="7fa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">fn app() -&gt; Html {…..}</code>:使用<code class="fe nf ng nh mw b">html!</code>宏创建<code class="fe nf ng nh mw b">Yew for Vue developers</code>标记。宏的工作方式类似于 Vue 中的<code class="fe nf ng nh mw b">template</code>语法。</p><p id="c033" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nf ng nh mw b">yew::start_app::&lt;App&gt;()</code>:通过将 App 组件挂载到文档主体来启动 Yew 应用程序。其工作原理类似于 Vue 中的<code class="fe nf ng nh mw b">createApp(App).mount()</code>功能。</p><p id="14fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> HTML 渲染</strong></p><p id="e954" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与 Vue 渲染到 DOM 的方式类似，同样的原理也适用于紫杉。接下来，我们需要在项目的根目录下创建一个支持引导 CDN 的<code class="fe nf ng nh mw b">index.html</code>文件，并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8775a740b5268c904466bb268a40e8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/0*15TSIvYzaDM099R_.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">更新的项目结构</figcaption></figure><p id="53b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们可以通过在终端中运行以下命令来启动开发服务器，从而测试我们的应用程序:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="ea93" class="na kv in mw b gy nb nc l nd ne">trunk serve --open</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/4bfab452d1461ba0767e1e2822e49ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rs1pQNg-i0h0wXOv.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">工作应用</figcaption></figure><h1 id="7d7d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用紫杉构建一个真正的应用程序</h1><p id="0ecd" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在我们已经很好地掌握了 Yew 是如何工作的，我们可以继续构建一个集成了<a class="ae kt" href="https://dummyjson.com/" rel="noopener ugc nofollow" target="_blank"> DummyJSON </a>的用户 API 的应用程序。</p><p id="9aa6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">模块系统在 Rust<br/>Vue</strong>中，组件构成了一个应用程序的构建模块。在我们的应用中，我们将使用 Rust 模块系统来构建我们的应用。</p><p id="523b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我们需要导航到<code class="fe nf ng nh mw b">src</code>文件夹，并创建<code class="fe nf ng nh mw b">component</code>和<code class="fe nf ng nh mw b">model</code>文件夹及其对应的<code class="fe nf ng nh mw b">mod.rs</code>文件来管理可见性。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ecc7f839d7fd6160e9e2b8c953adbe53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*IUhKbTFimKwGstZ3.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">更新的文件夹结构</figcaption></figure><p id="1b91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要使用模块中的代码，我们需要将它们声明为一个模块，并导入到<code class="fe nf ng nh mw b">main.rs</code>文件中，如下所示:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="4074" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成后，我们需要创建模型来表示从 API 返回的响应。为此，我们需要导航到<code class="fe nf ng nh mw b">models</code>文件夹，在这里，创建一个<code class="fe nf ng nh mw b">user.rs</code>文件并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="0cd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="acda" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">导入所需的依赖项</li><li id="51cc" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">使用<code class="fe nf ng nh mw b">derive</code>宏生成对格式化输出和反序列化数据结构的实现支持。<code class="fe nf ng nh mw b">#[serde(rename_all = “camelCase”)]</code>宏将 snake case 属性转换为 camel case(API 返回 camel case 中的数据)</li><li id="08f4" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">用 API 嵌套响应所需的必需属性创建一个<code class="fe nf ng nh mw b">User</code>结构</li><li id="a738" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">创建具有<code class="fe nf ng nh mw b">users</code>属性的<code class="fe nf ng nh mw b">Users</code>结构；<code class="fe nf ng nh mw b">User</code>结构的数组类型。Rust 中的动态数组表示为一个向量</li></ul><p id="a431" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DummyJSON 的 API 响应示例如下:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="0273" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">PS</strong>:<em class="nm"/><code class="fe nf ng nh mw b"><em class="nm">pub</em></code><em class="nm">修饰符使结构及其属性成为公共的，可以从其他文件/模块中访问。</em></p><p id="e6e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们必须将<code class="fe nf ng nh mw b">user.rs</code>文件注册为<code class="fe nf ng nh mw b">models</code>模块的一部分。为此，打开<code class="fe nf ng nh mw b">models</code>文件夹中的<code class="fe nf ng nh mw b">mod.rs</code>并添加以下代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="7450" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">创建组件</strong></p><p id="3cf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模型完全建立后，我们就可以开始创建我们的应用程序构建块了。</p><p id="35db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要导航到 components 文件夹，创建一个<code class="fe nf ng nh mw b">header.rs</code>文件，并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="fa6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段创建了一个 Header 组件来表示我们的应用程序头。</p><p id="5004" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其次，我们需要在同一个<code class="fe nf ng nh mw b">components</code>文件夹中创建一个<code class="fe nf ng nh mw b">loader.rs</code>文件，并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="248c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们的应用程序加载时，上面的代码片段创建了一个表示 UI 的 Loader 组件。</p><p id="3a70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三，我们需要在同一个<code class="fe nf ng nh mw b">components</code>文件夹中创建一个<code class="fe nf ng nh mw b">message.rs</code>文件，并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="5b1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="0bde" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">导入所需的依赖项</li><li id="2774" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">创建一个具有<code class="fe nf ng nh mw b">text</code>和<code class="fe nf ng nh mw b">css_class</code>属性的<code class="fe nf ng nh mw b">MessageProp</code>结构来表示组件属性。<code class="fe nf ng nh mw b">#[derive(Properties, PartialEq)]</code>宏将结构标记为类似于 Vue 应用程序的组件属性</li><li id="3335" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">析构这些属性，将它们用作 CSS 类，并在标记中显示文本</li></ul><p id="9301" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第四，我们需要在同一个<code class="fe nf ng nh mw b">components</code>文件夹中创建一个<code class="fe nf ng nh mw b">card.rs</code>文件，并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="9ef3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="d019" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">导入我们之前创建的<code class="fe nf ng nh mw b">yew</code>依赖项和<code class="fe nf ng nh mw b">User</code>模型</li><li id="0ffc" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">创建一个具有<code class="fe nf ng nh mw b">user</code>属性的<code class="fe nf ng nh mw b">CardProps</code>组件属性</li><li id="efb2" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">析构属性以在用户界面中显示用户信息</li></ul><p id="c80a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们必须将新创建的组件注册为<code class="fe nf ng nh mw b">components</code>模块的一部分。为此，打开 components 文件夹中的<code class="fe nf ng nh mw b">mod.rs</code>并添加下面的代码片段:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="1eb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">将所有这些放在一起<br/> </strong>创建好应用程序组件后，我们可以通过修改如下所示的<code class="fe nf ng nh mw b">main.rs</code>文件，开始使用它们来构建我们的应用程序:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="nj mc l"/></div></figure><p id="bf6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="9d41" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">导入所需的依赖项</li><li id="3861" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><strong class="jx io">第 13–14 行</strong>:使用<code class="fe nf ng nh mw b">use_state</code>钩子(类似于 Vue 中的<code class="fe nf ng nh mw b">data</code>函数)并指定<code class="fe nf ng nh mw b">None</code>为初始值，创建一个<code class="fe nf ng nh mw b">users</code>和<code class="fe nf ng nh mw b">error</code>应用状态。<code class="fe nf ng nh mw b">UseStateHandle</code>结构用于指定状态类型，而<code class="fe nf ng nh mw b">Option</code>枚举表示可选值</li><li id="a788" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><strong class="jx io">第 18–19 行</strong>:创建当前范围内安全使用的状态副本</li><li id="5435" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><strong class="jx io">第 21–42 行</strong>:使用类似于 Vue 中<code class="fe nf ng nh mw b">created</code>钩子的<code class="fe nf ng nh mw b">use_effect_with_deps</code>钩子来执行一个副作用，与<code class="fe nf ng nh mw b">wasm_bindgen_futures</code>和<code class="fe nf ng nh mw b">gloo_net</code>的<code class="fe nf ng nh mw b">Request::get</code>函数异步地从<a class="ae kt" href="https://dummyjson.com/" rel="noopener ugc nofollow" target="_blank"> DummyJSON </a> API 获取数据。我们还使用<code class="fe nf ng nh mw b">match</code>控制流来匹配通过相应地更新状态而返回的 JSON 响应</li><li id="b7b2" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><strong class="jx io">第 44–66 行</strong>:创建一个<code class="fe nf ng nh mw b">user_list_logic</code>变量，通过使用<code class="fe nf ng nh mw b">match</code>控制流来抽象我们的应用程序逻辑，通过执行以下操作来匹配模式:<br/>——映射<code class="fe nf ng nh mw b">users</code>列表，并在 API 返回适当的数据<br/>时将单个的<code class="fe nf ng nh mw b">user</code>传递给<code class="fe nf ng nh mw b">Card</code>组件——使用<code class="fe nf ng nh mw b">Message</code>和<code class="fe nf ng nh mw b">Loader</code>组件分别匹配错误和加载状态</li><li id="3b72" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><strong class="jx io">第 68–73 行</strong>:用<code class="fe nf ng nh mw b">Header</code>组件和<code class="fe nf ng nh mw b">user_list_logic</code>抽象更新标记</li></ul><p id="d5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成后，我们可以使用下面的命令重新启动开发服务器:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="9b19" class="na kv in mw b gy nb nc l nd ne">trunk serve --open</span></pre><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/c711f4910fc5867e9f6775bc0b9b7acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*ByGJsKskn-zyTb2l.gif"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">工作演示</figcaption></figure><h1 id="bea9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="b53f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这篇文章讨论了如何使用来自 DummyJSON 和 Yew 的开放 API 数据创建一个 web 应用程序。</p><p id="70c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些资源可能会有所帮助:</p><ul class=""><li id="f24b" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated"><a class="ae kt" href="https://yew.rs/docs/getting-started/introduction" rel="noopener ugc nofollow" target="_blank">红豆杉文献</a></li><li id="b9ab" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><a class="ae kt" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">官方锈书</a></li><li id="bf9c" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated"><a class="ae kt" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank">网络组装技术</a></li></ul></div></div>    
</body>
</html>