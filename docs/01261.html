<html>
<head>
<title>Useful JavaScript Tips — Closures and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的 JavaScript 技巧——闭包和数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/useful-javascript-tips-closures-and-arrays-43ef5d8e2a78?source=collection_archive---------23-----------------------#2020-06-28">https://blog.devgenius.io/useful-javascript-tips-closures-and-arrays-43ef5d8e2a78?source=collection_archive---------23-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65bfe39158ce28d2de78ffad33a6bc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*832_Xk0W_TtH79yD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@leorivas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">利奥·里瓦斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a188" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写 JavaScript 代码。</p><h1 id="52fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在数组上循环</h1><p id="d7d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript 提供了许多数组方法，我们可以用它们以简洁的方式处理数组。</p><h2 id="0818" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">while 循环</h2><p id="d200" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe mq mr ms mt b">while</code>循环来遍历数组。</p><p id="4114" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="d3e2" class="me lc iq mt b gy nc nd l ne nf">let index = 0;<br/>const arr = [1,2,3];</span><span id="56c3" class="me lc iq mt b gy ng nd l ne nf">while (index &lt; arr.length) {<br/>  console.log(arr[index]);<br/>  index++;<br/>}</span></pre><p id="9b29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在每个迭代器上更新<code class="fe mq mr ms mt b">index</code>来访问<code class="fe mq mr ms mt b">arr</code>中的对象。</p><h2 id="6109" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">经典 for 循环</h2><p id="f404" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">还有经典的 for 循环，用于迭代数组中的显式项。</p><p id="7c90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它通过在 loo 的第一行设置初始条件、结束条件和数组索引更新语句来工作。</p><p id="42b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="e9ee" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>for (let index = 0; index &lt; arr.length; index++) {<br/>  console.log(arr[index]);<br/>}</span></pre><h2 id="90c9" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">为每一个</h2><p id="75e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe mq mr ms mt b">forEach</code>方法遍历数组条目。</p><p id="a328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个回调，我们可以在每个条目上运行代码。</p><p id="1890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="0ec1" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/><br/>arr.forEach((val, index, array) =&gt; {<br/>  console.log(index, array, val);<br/>});</span></pre><p id="65f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mq mr ms mt b">arr</code>，我们称之为<code class="fe mq mr ms mt b">forEach</code>。</p><p id="b5dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe mq mr ms mt b">val</code>得到数组条目，用<code class="fe mq mr ms mt b">index</code>得到条目的索引，用<code class="fe mq mr ms mt b">array</code>得到数组本身。</p><h2 id="c05d" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">地图</h2><p id="60d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们将数组条目从一个映射到另一个。</p><p id="597a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="285b" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>const cube = x =&gt; x ** 3;<br/>const cubes = arr.map(cube);</span></pre><p id="9b59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mq mr ms mt b">cube</code>函数，我们将它作为<code class="fe mq mr ms mt b">map</code>函数的回调函数传入。</p><p id="446a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">x</code>有数组条目的值。</p><p id="2f57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">cubes</code>有一个新数组，每个条目都是<code class="fe mq mr ms mt b">arr</code>的立方。</p><h2 id="a462" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">减少</h2><p id="cc47" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mq mr ms mt b">reduce</code>方法让 is 将条目组合成一个值。</p><p id="416d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="507c" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>const sum = (total, y) =&gt; total + y;<br/>const sum = arr.reduce(sum, 0);</span></pre><p id="3b1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mq mr ms mt b">arr</code>,我们通过传入<code class="fe mq mr ms mt b">sum</code>函数作为其回调函数来调用<code class="fe mq mr ms mt b">reduce</code>。</p><p id="ca12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是到目前为止的累计总数，第二个参数是添加到<code class="fe mq mr ms mt b">total</code>中的条目。</p><p id="ad3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">reduce</code>的第二个参数是初始值。</p><p id="703e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条目的组合是从左到右完成的。</p><p id="94d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一种<code class="fe mq mr ms mt b">reduceRight</code>方法，从右到左组合条目。</p><h2 id="2b3d" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">过滤器</h2><p id="80b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mq mr ms mt b">filter</code>方法返回一个满足回调条件的数组。</p><p id="0232" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="6a71" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>const isEven = x =&gt; x % 2 === 0;<br/>const evenArr = arr.filter(isEven);</span></pre><p id="bf9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mq mr ms mt b">isEven</code>，它是一个检查数组条目<code class="fe mq mr ms mt b">x</code>是否能被 2 整除的函数。</p><p id="3985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe mq mr ms mt b">arr</code>上调用<code class="fe mq mr ms mt b">filter</code>，同时传递<code class="fe mq mr ms mt b">isEven</code>。</p><p id="3e5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe mq mr ms mt b">evenArr</code>应该拥有<code class="fe mq mr ms mt b">arr</code>中的所有偶数条目。</p><h2 id="6895" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">每个</h2><p id="b63f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mq mr ms mt b">every</code>方法检查数组中的每个条目是否满足给定的条件。</p><p id="5e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="e893" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>const under10 = x =&gt; x &lt; 10;<br/>const allUnder10 = arr.every(under10);</span></pre><p id="c22c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mq mr ms mt b">under10</code>，它检查每个条目是否都在 10 岁以下。</p><p id="801a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">x</code>是数组条目。</p><p id="9fe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe mq mr ms mt b">under10</code>作为回调来调用<code class="fe mq mr ms mt b">every</code>。</p><p id="b6b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">allUnder10</code>应为<code class="fe mq mr ms mt b">true</code>，因为<code class="fe mq mr ms mt b">arr</code>中的所有条目都小于 10。</p><h2 id="54b6" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">一些</h2><p id="7c2a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mq mr ms mt b">some</code>检查数组中的一个或多个元素是否与给定条件匹配。</p><p id="457b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="961f" class="me lc iq mt b gy nc nd l ne nf">const arr = [1,2,3];<br/>const under10 = x =&gt; x &lt; 10;<br/>const someUnder10 = arr.some(under10);</span></pre><p id="d260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe mq mr ms mt b">someUnder10</code>应该是<code class="fe mq mr ms mt b">true</code>，因为<code class="fe mq mr ms mt b">arr</code>中至少有一个条目小于 10。</p><h1 id="f39b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="ba4c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过运行以下命令在循环中创建一个封闭的作用域:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="464d" class="me lc iq mt b gy nc nd l ne nf">for (let i = 0; i &lt; 3; i++) {<br/>  funcs[i] = ((value) =&gt; {<br/>    console.log(value);<br/>  })(i);<br/>}</span></pre><p id="e025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，当我们调用<code class="fe mq mr ms mt b">funcs</code>中的函数时，我们得到循环的索引变量的值。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/c951243fb1cd14c83b36ef1cd14f35f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e1OmXYf6EqR7yYGi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@azganmjeshtri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兹甘·米耶什特里</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="71ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2bad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用数组方法来节省遍历条目和做我们想做的事情的努力。</p><p id="54c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该将代码包装在 IIFEs 中，用循环的索引变量值创建一个闭包。</p></div></div>    
</body>
</html>