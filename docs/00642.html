<html>
<head>
<title>Logistic Regression from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始的逻辑回归</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/step-by-step-implementation-of-logistic-regression-on-gender-voice-classifcation-dataset-from-535671cb281c?source=collection_archive---------6-----------------------#2020-06-13">https://blog.devgenius.io/step-by-step-implementation-of-logistic-regression-on-gender-voice-classifcation-dataset-from-535671cb281c?source=collection_archive---------6-----------------------#2020-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="e93e" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">使用numpy和pandas实现性别语音分类数据集。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/1eb7c78fa4b54044f2eb8217b190ea06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9PzwZTplFb6WMxRC"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lc" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><blockquote class="jk jl jm"><p id="2040" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">N <!-- -->注:这篇文章没有解释逻辑回归是如何工作的，但是清楚地解释了它的从头实现。文章末尾提供了源代码。</p></blockquote><blockquote class="ld"><p id="4430" class="le lf in bd lg lh li lj lk ll lm kl dk translated">"在所有的不眠之夜和对大脑有害的上瘾中，我来写下我的第一篇文章."迪加拉·安。</p></blockquote><h2 id="64a4" class="ln lo in bd lp lq lr dn ls lt lu dp lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">内容:</h2><ol class=""><li id="7c34" class="mj mk in jq b jr ml jv mm lw mn ma mo me mp kl mq mr ms mt bi translated">本教程的目标</li><li id="9ee3" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">了解数据集</li><li id="6577" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">准备数据集</li><li id="2b61" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">分割数据集</li><li id="b986" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">定义函数</li><li id="672b" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">标准化特征</li><li id="c8d4" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">准备梯度下降</li><li id="64a8" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">检查测试数据集的准确性</li></ol><blockquote class="jk jl jm"><p id="2a52" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在开始之前，我不希望你被写的大量代码或理论弄得不知所措。只是坐下来，放松，耐心地阅读。</p></blockquote><h1 id="8f0e" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated"><strong class="ak"> <em class="nq"> 1。本教程的目标</em> </strong></h1><p id="eab6" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">我们将根据一个人的声音对其性别进行分类。我们要用到的数据集可以从这里下载，<a class="ae lc" href="https://www.kaggle.com/primaryobjects/voicegender" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/primaryobjects/voicegender</a></p><h1 id="0d45" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated">2.了解数据测试</h1><p id="d898" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">该数据集包括3，168个记录的声音样本，从男性和女性说话者那里收集。总共有21列，20个特征和1个标记男性和女性的目标列。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/49e9fe2d7311090880accba76499c9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3ONzH9imRoYmtdhcyA0WQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">具有3168行、21列的数据集</figcaption></figure><blockquote class="jk jl jm"><p id="8cb6" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们现在不会详细讨论每个特性，那最终会让你更害怕。如果你想知道更多关于每个特性的信息，请点击上面的链接。</p></blockquote><h1 id="80c9" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated">3.准备数据集</h1><blockquote class="jk jl jm"><p id="65b5" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">注意:这段代码是用Google colab写的。(建议查看者也这样做)</p><p id="c622" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们现在正在经历预处理步骤，如果你已经知道如何做或者觉得无聊，就直接跳到实现。(即)D <strong class="jq io">定义功能</strong></p></blockquote><p id="1267" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">我们将从<strong class="jq io">导入库</strong>开始，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="ff0f" class="ln lo in nw b gy oa ob l oc od">import numpy as np</span><span id="8542" class="ln lo in nw b gy oe ob l oc od">import pandas as pd</span><span id="e241" class="ln lo in nw b gy oe ob l oc od">import matplotlib.pyplot as plt</span><span id="ad46" class="ln lo in nw b gy oe ob l oc od">import random</span></pre><p id="f71c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated"><strong class="jq io">从</strong>、<a class="ae lc" href="https://www.kaggle.com/primaryobjects/voicegender" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/primaryobjects/voicegender</a>下载数据集</p><p id="c21e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">(确保您已登录您的kaggle帐户进行下载)</p><p id="6470" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">将下载一个zip文件，将您的zip文件上传到colab。你可以分两步完成，</p><p id="a3a6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">1)手动使用colab中的上传选项</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bb04835a900b23434037497842b702db.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*vTz9idb8CQOhZguIiEXNAg.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">colab内部的上传选项</figcaption></figure><p id="e6ac" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">2)使用代码</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="022d" class="ln lo in nw b gy oa ob l oc od">from google.colab import files</span><span id="e37c" class="ln lo in nw b gy oe ob l oc od">up = files.upload()</span></pre><p id="11af" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在，上传你的压缩文件。</p><p id="348b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">上传后，使用命令解压文件，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="91e7" class="ln lo in nw b gy oa ob l oc od">!unzip voicegender.zip</span></pre><p id="f170" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在我们用熊猫来读取数据集，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="2277" class="ln lo in nw b gy oa ob l oc od">data = pd.read_csv('voice.csv')</span></pre><h2 id="4344" class="ln lo in bd lp lq og dn ls lt oh dp lv lw oi ly lz ma oj mc md me ok mg mh mi bi translated"><strong class="ak">编码</strong></h2><p id="7412" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">现在我们将标签的列编码为0(女性)和1(男性)。</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="7dce" class="ln lo in nw b gy oa ob l oc od">data['label'] = data['label'].replace(['male','female'],[1,0])</span></pre><blockquote class="jk jl jm"><p id="1c3b" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">现在，只需输入代码<strong class="jq io"> print(data) </strong>来检查数据值是否已被编码</p><p id="ee45" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io">注意</strong>:该数据集中没有损坏或丢失的值。如果您还想检查，可以通过运行<strong class="jq io"> data.isnull()来完成。sum() </strong></p></blockquote><h2 id="3064" class="ln lo in bd lp lq og dn ls lt oh dp lv lw oi ly lz ma oj mc md me ok mg mh mi bi translated">洗牌</h2><p id="ead4" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">现在，当您可视化数据集时，您可以看到，在“标签”列中，所有值都按<strong class="jq io">降序排列</strong>。(这在训练过程中不会产生太大影响，但我们很快就会分割我们的数据集，因此会产生问题)</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ol"><img src="../Images/89b625c8c832772f2445d78944818e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*BIbp-m7HT2dGUKZq5k3TvQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">未起泡的标签</figcaption></figure><p id="7ef8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">因此，我们将使用pandas dataframe的<strong class="jq io"> sample </strong>函数<strong class="jq io">重排</strong>我们的行。</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="8576" class="ln lo in nw b gy oa ob l oc od">data = data.sample(frac=1).reset_index(drop=True)</span></pre><blockquote class="jk jl jm"><p id="3f53" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">到目前为止，您已经成功准备了数据集。希望到目前为止还不算太无聊。你看到的任何疑惑或技术术语，都写在评论里，我会马上帮你。让我们继续前进吧！！！！</p></blockquote><blockquote class="ld"><p id="a0d0" class="le lf in bd lg lh li lj lk ll lm kl dk translated">再坚持一会儿，我们将分两步开始真正的实现。非常重要的是，我们应该涵盖这些步骤，以保持我们的实现干净，没有任何错误。</p></blockquote><h1 id="30ef" class="mz lo in bd lp na nb nc ls nd ne nf lv ng om ni lz nj on nl md nm oo no mh np bi translated">4.分割数据集</h1><p id="bbe3" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">现在我们要分割数据集，</p><p id="1c01" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated"><em class="jp"> 80%的数据用于训练</em></p><p id="4306" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated"><em class="jp"> 20%的数据用于测试</em></p><blockquote class="jk jl jm"><p id="0215" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">！！！！！！！！！！！！！！！！！！！！！<strong class="jq io">术语预警</strong>！！！！！！！！！！！！！！！！！！！！！</p><p id="a3bb" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io">为什么分裂？！</strong></p><p id="78ac" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在建立任何模型之前，分割数据集是必要的，因为它为我们提供了关于我们的模型在它从未训练过的数据上表现如何的信息。</p><p id="1815" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">例子:一名学生在准备他的数学考试。他在数学考试中的表现取决于他对数学考试的准备程度。这里的训练数据是他的准备，测试数据是他考试当天的试卷。</p></blockquote><p id="b170" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">我们将使用下面的代码分割数据，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="c676" class="ln lo in nw b gy oa ob l oc od">train_data = data.iloc[:2534]</span><span id="f806" class="ln lo in nw b gy oe ob l oc od">test_data = data.iloc[2534:]</span></pre><blockquote class="jk jl jm"><p id="dde7" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">为什么<strong class="jq io"> 2534 </strong>？！</p><p id="7f3f" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">数据中共有3168行，</p><p id="2c45" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们已经决定，我们的训练集将采用80%的数据，而测试集将采用20%。所以3168乘以80%的时候。(即)<strong class="jq io"> 3168 * (80/100) = 2534 </strong></p></blockquote><h2 id="3ddf" class="ln lo in bd lp lq og dn ls lt oh dp lv lw oi ly lz ma oj mc md me ok mg mh mi bi translated"><strong class="ak">特性和目标</strong></h2><p id="ce51" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">现在我们将为训练集和测试集创建目标和特征变量。</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="c902" class="ln lo in nw b gy oa ob l oc od">x_train = train_data.drop(['label'],axis=1)<br/>y_train = train_data['label']</span><span id="521e" class="ln lo in nw b gy oe ob l oc od">x_test = test_data.drop(['label'],axis=1)<br/>y_test = test_data['label']</span></pre><blockquote class="jk jl jm"><p id="9755" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">注意:<strong class="jq io"> axis = 1 </strong>掉列，<strong class="jq io"> axis = 0 </strong>掉行(相信我，一开始我对此很困惑)</p></blockquote><p id="d84a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在让我们通过运行来检查<strong class="jq io"> x_train </strong>中每一列的<strong class="jq io"> dtypes </strong>(数据类型),</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="32bf" class="ln lo in nw b gy oa ob l oc od">x_train.dtypes</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e9eb666592290e4315c1e66dd4a50438.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*uW8tO-R2DxNKB8fCfrnjcw.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">x_train.dtypes</figcaption></figure><p id="52e0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">你会看到所有的都是浮动的。现在我们将检查<strong class="jq io"> y_train，</strong>的数据类型</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="2428" class="ln lo in nw b gy oa ob l oc od">y_train.dtypes</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/651d724e06bc239ab6d4ee5e2461bc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*Hf0Mu6kLfWJPu5NeuaelWg.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">y_train的数据类型</figcaption></figure><p id="0e05" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">你会看到<strong class="jq io"> y_train </strong>是在<strong class="jq io">【int 64】</strong>dtype中，我们将把这个dtype转换成“<strong class="jq io"> float64 </strong>”以避免将来出现任何错误。(最好所有列都是相同的数据类型)</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="0d6f" class="ln lo in nw b gy oa ob l oc od">y_train = y_train.astype('float64')<br/>y_test= y_test.astype('float64')</span></pre><p id="b65a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated"><strong class="jq io"> Numpy数组</strong></p><p id="bc7f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">让我们将我们的目标和特征变量转换成numpy数组，因为这将使我们更容易进行矩阵运算。</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="c8b8" class="ln lo in nw b gy oa ob l oc od">x_train = np.asarray(x_train)<br/>y_train = np.asarray(y_train)</span><span id="e254" class="ln lo in nw b gy oe ob l oc od">x_test = np.asarray(x_test)<br/>y_test = np.asarray(y_test)</span></pre><blockquote class="ld"><p id="c28b" class="le lf in bd lg lh li lj lk ll lm kl dk translated"><strong class="ak">好吧……..我们完了！！！！！</strong></p><p id="f8ec" class="le lf in bd lg lh or os ot ou ov kl dk translated">我们现在可以完全专注于实施。我真的很高兴你能坚持到这里。芝士蛋糕。！！！！！！！</p></blockquote><h1 id="8a1b" class="mz lo in bd lp na nb nc ls nd ne nf lv ng om ni lz nj on nl md nm oo no mh np bi translated">5)定义功能</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ow"><img src="../Images/6a52e1a5bfb858405e365e1f2123fb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WK3hRCmpIkB3gHCLSHU7sg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">逻辑回归的简单思维导图|作者</figcaption></figure><blockquote class="jk jl jm"><p id="66f9" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">注意:这里的权重和偏差用<strong class="jq io"> m和c </strong>表示，与大多数地方不同，这里用<strong class="jq io"> w和b </strong>表示</p></blockquote><p id="3bc6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">让我们从定义一个函数开始，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="16a4" class="ln lo in nw b gy oa ob l oc od">def line(m,x,c):<br/>    return np.dot(m,x.T)+c</span></pre><p id="74ca" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在为sigmoid假设函数定义一个函数，</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/1348f6ff9e8b2767aa61e2eca57f882d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*gYWHxLLcLkFuxrWylVY7BQ.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">sigmoid函数公式</figcaption></figure><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="68d0" class="ln lo in nw b gy oa ob l oc od">def sigmoid(m,x,c):<br/>    p = line(m,x,c)<br/>    nr = 1<br/>    dr = 1+np.exp(-(p))</span><span id="81e4" class="ln lo in nw b gy oe ob l oc od">    return nr/dr</span></pre><p id="08a5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">定义成本函数，</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7021786f782b9e700375b169177fce03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*vrvwn_w-y9j8Upu4m91bgg.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">LCE丹特交叉熵损失函数。Ya是实际值，Yp是预测值</figcaption></figure><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="c191" class="ln lo in nw b gy oa ob l oc od">def cost(m,x,c,y):<br/>    p = sigmoid(m,x,c)<br/>    d = 0.00999</span><span id="a171" class="ln lo in nw b gy oe ob l oc od">    return np.mean(-(y*np.log(p+d)+(1-y)*np.log(1-p+d)))</span></pre><blockquote class="jk jl jm"><p id="3fd9" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们在上面的log(p) 中添加了<strong class="jq io"> d，因为当预测值p为<strong class="jq io"> 0 </strong>时，那么<strong class="jq io"> log(0) </strong>往往会变成<strong class="jq io">未定义的</strong>，所以为了避免这种情况，我们添加了一个小值d(这样它永远不会变成0)。</strong></p></blockquote><p id="d30d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">定义关于m的梯度(导数),</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="6bcb" class="ln lo in nw b gy oa ob l oc od">def grad_m(m,x,c,y):<br/>    p = sigmoid(m,x,c)</span><span id="334e" class="ln lo in nw b gy oe ob l oc od">    return np.mean((p - y).T*x,axis=0)</span></pre><blockquote class="jk jl jm"><p id="0d6a" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你对检查m和c的导数是如何得到的感兴趣，你可以检查这个pdf并向下滚动到第17页，<a class="ae lc" href="https://web.stanford.edu/~jurafsky/slp3/5.pdf" rel="noopener ugc nofollow" target="_blank">https://web.stanford.edu/~jurafsky/slp3/5.pdf</a></p></blockquote><p id="92b1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在定义相对于c的梯度(导数)，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="0352" class="ln lo in nw b gy oa ob l oc od">def grad_c(m,x,c,y):<br/>    p = sigmoid(m,x,c)</span><span id="04e9" class="ln lo in nw b gy oe ob l oc od">    return np.mean(p - y)</span></pre><blockquote class="ld"><p id="a532" class="le lf in bd lg lh li lj lk ll lm kl dk translated">好吧，我已经看到你昏昏欲睡，你的头在旋转，你的思想在偏离…你该休息一下了，以后再继续。或者如果你感觉良好，那么继续……</p></blockquote><p id="1d2e" class="pw-post-body-paragraph jn jo in jq b jr oz jt ju jv pa jx jy lw pb kb kc ma pc kf kg me pd kj kk kl ig bi translated">我们还会定义一个准确度函数来看看我们的预测有多准确，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="88a1" class="ln lo in nw b gy oa ob l oc od">def accuracy(m,x,c,y):<br/>    y_pred=sigmoid(m,x,c)<br/>    ### As y_pred in our case can be any value between 0 to 1<br/>    ### We're equating them when y_pred &gt;= 0.5 to '1' and y_pred &lt; 0.5 to '0'<br/>    y_pred[y_pred&gt;=0.5]=1<br/>    y_pred[y_pred&lt;0.5]=0<br/>    correct=len(y_pred[y_pred==y])</span><span id="54dd" class="ln lo in nw b gy oe ob l oc od">    return (correct/len(y.T))*100</span></pre><p id="5ac0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">这个准确度函数是正确预测值与实际值总数的比率乘以100，因此你会得到一个数值准确度的分数。</p><blockquote class="jk jl jm"><p id="e070" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你不理解上面的函数，没关系，这只是为了发现你的预测有多准确。你可以用它来解决将来的分类问题。</p></blockquote><h1 id="feb2" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated">6)归一化特征</h1><p id="f727" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">归一化特征非常重要，因为这些值非常大，当您以<strong class="jq io">0–1</strong>的间隔获得这些值时，训练将变得容易，离群值大多会被忽略。</p><p id="2059" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">归一化可以用多种方式进行，我们将使用，<strong class="jq io">最小-最大归一化，</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/81533f68919d0c8496cf14e1845d886d.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*oqx7ZDHDBxtQNCF_8bzAjw.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">最小最大归一化公式</figcaption></figure><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="4f6e" class="ln lo in nw b gy oa ob l oc od">def dataset_minmax(dataset):<br/>    minmax = list()<br/>    for i in range(len(dataset[0])):<br/>        col_values = [row[i] for row in dataset]<br/>        value_min = min(col_values)<br/>        value_max = max(col_values)<br/>        minmax.append([value_min, value_max])<br/>    return minmax</span><span id="2026" class="ln lo in nw b gy oe ob l oc od"># Rescale dataset columns to the range 0-1<br/>def normalize_dataset(dataset, minmax):<br/>    for row in dataset:<br/>        for i in range(len(row)):<br/>            row[i] = (row[i] - minmax[i][0]) / (minmax[i][1] - minmax[i][0])</span></pre><blockquote class="jk jl jm"><p id="e400" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">资料来源:machinelearningmastery.com</p></blockquote><p id="aad3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">上面的代码采用了两个函数，其中，<strong class="jq io">第一个函数返回每个特征列的最小值和最大值</strong>，而<strong class="jq io">第二个函数对所有特征列应用最小最大归一化。</strong></p><blockquote class="ld"><p id="c71c" class="le lf in bd lg lh or os ot ou ov kl dk translated">完全没关系，如果你不理解上面的功能，它们真的不重要。如果你知道如何应用最小最大，那么你可以自己做，或者你可以直接使用上面的函数，如果你已经有了最小最大如何工作的直觉。</p></blockquote><p id="ac45" class="pw-post-body-paragraph jn jo in jq b jr oz jt ju jv pa jx jy lw pb kb kc ma pc kf kg me pd kj kk kl ig bi translated">现在让我们对训练和测试特性都应用标准化，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="59c2" class="ln lo in nw b gy oa ob l oc od"># Applying normalization on training features<br/>x_train_min_max = x_train.copy()<br/>normalize_dataset(x_train_min_max,dataset_minmax(x_train_min_max))</span><span id="60e9" class="ln lo in nw b gy oe ob l oc od"># Applying normalization on testing features<br/>x_test_min_max = x_test.copy()<br/>normalize_dataset(x_test_min_max,dataset_minmax(x_test_min_max))</span></pre><h1 id="4d27" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated">7)准备梯度下降</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi pf"><img src="../Images/68bb72ee2b6f462e9de0c8ea0eda7ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uOMIL7VxXX0ROq6SJgUf4A.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">启动梯度下降引擎的时间…..(嘟嘟嘟嘟……)</figcaption></figure><p id="cd4c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">现在让我们用<strong class="jq io"> 9步进行梯度下降(LOL，这很简单)</strong>，</p><ol class=""><li id="b21e" class="mj mk in jq b jr js jv jw lw pg ma ph me pi kl mq mr ms mt bi translated">为记录所有错误的<strong class="jq io">初始化一个空数组</strong></li><li id="8592" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">初始化<strong class="jq io">随机m和c值</strong></li><li id="599a" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">初始化一个<strong class="jq io">学习率</strong>值5</li><li id="7275" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">用<strong class="jq io"> 300个周期初始化一个循环</strong></li><li id="c0b5" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated"><strong class="jq io">用梯度(导数)减去m和c值，更新m和c值</strong></li><li id="0ff7" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated"><strong class="jq io">将</strong>成本值追加到空的<strong class="jq io">错误数组</strong></li><li id="7138" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">还算出了<strong class="jq io">的准确度</strong></li><li id="235c" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated"><strong class="jq io">将<strong class="jq io">误差值</strong>和精度值</strong>打印到控制台</li><li id="5af1" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">将误差图可视化</li></ol><blockquote class="jk jl jm"><p id="8fbe" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">注意:上述所有步骤在下面的代码中都用数字注释掉了</p></blockquote><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="7d48" class="ln lo in nw b gy oa ob l oc od">from IPython.display import clear_output<br/># Run all the below code, without the above line, you'll see the difference it makes(Nothing important to explain about it)</span><span id="16eb" class="ln lo in nw b gy oe ob l oc od"># 1)<br/>error = []</span><span id="6ffe" class="ln lo in nw b gy oe ob l oc od"># 2)<br/>m = np.random.randn(1,20)<br/>c = random.random()</span><span id="e266" class="ln lo in nw b gy oe ob l oc od"># 3)<br/>lr = 5</span><span id="30a0" class="ln lo in nw b gy oe ob l oc od"># 4)<br/>for i in range(300):</span><span id="b082" class="ln lo in nw b gy oe ob l oc od">    # 5)<br/>    m = m - lr*grad_m(m,x_train_min_max,c,y_train)<br/>    c = c - lr*grad_c(m,x_train_min_max,c,y_train)</span><span id="04e7" class="ln lo in nw b gy oe ob l oc od">    # 6)<br/>    error.append(cost(m,x_train_min_max,c,y_train))</span><span id="ff25" class="ln lo in nw b gy oe ob l oc od">    clear_output(True)</span><span id="33b2" class="ln lo in nw b gy oe ob l oc od">    # 7)<br/>    print("i : ",i)</span><span id="dfac" class="ln lo in nw b gy oe ob l oc od">    print("Error : ",cost(m,x_train_min_max,c,y_train))</span><span id="2108" class="ln lo in nw b gy oe ob l oc od">    # 8)<br/>    print("Accuracy : ",accuracy(m,x_train_min_max,c,y_train))<br/></span><span id="8952" class="ln lo in nw b gy oe ob l oc od"># 9)<br/>plt.plot(error)<br/>plt.show()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/20e0e0065bb182b5898ca62e031c5468.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*XLYoucHJVD4v64ELNFIEsA.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">错误图表|按作者</figcaption></figure><p id="fc23" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">正如你在上面看到的,<strong class="jq io">成本降低了</strong>,我们达到了<strong class="jq io"> 96的精确度。49661 . 68868688661</strong></p><p id="6c3d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">好了，现在让我们检查一下我们的模型在它从未见过的数据(测试集)上的表现。</p><p id="edfe" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">(搞笑结局GIF在此)</p><h1 id="1cea" class="mz lo in bd lp na nb nc ls nd ne nf lv ng nh ni lz nj nk nl md nm nn no mh np bi translated">8)检查测试数据集的准确性</h1><p id="8f99" class="pw-post-body-paragraph jn jo in jq b jr ml jt ju jv mm jx jy lw nr kb kc ma ns kf kg me nt kj kk kl ig bi translated">我们可以使用我们的精度函数在测试集上检查我们的模型的精度，</p><pre class="kn ko kp kq gt nv nw nx ny aw nz bi"><span id="c3c0" class="ln lo in nw b gy oa ob l oc od">accuracy(m,x_test_min_max,c,y_test)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/8c1500fe155f310f5b9dbd4918166b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*c56Rnr82eOMptiDrAE7KZw.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">输出</figcaption></figure><p id="ddf4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">你可以看到我们的模型在测试集上表现得非常好，这太棒了！！！！！！</p><p id="c876" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">总之，我们在训练集和测试集上都取得了97%的准确率，</p><ol class=""><li id="6a9b" class="mj mk in jq b jr js jv jw lw pg ma ph me pi kl mq mr ms mt bi translated">一千个时代</li><li id="be66" class="mj mk in jq b jr mu jv mv lw mw ma mx me my kl mq mr ms mt bi translated">最小-最大归一化特征</li></ol></div><div class="ab cl pl pm hr pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="ig ih ii ij ik"><blockquote class="ld"><p id="8cc8" class="le lf in bd lg lh or os ot ou ov kl dk translated">太好了，你成功地走到了最后。</p></blockquote><figure class="pt pu pv pw px kr gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/d5dec7abd4727d3c245adb97024d3efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*PNvEUFIPboaE4nj63PmHXA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">我在这里看到你感觉就像</figcaption></figure><p id="e24e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">好吧，这是我的第一篇文章，希望你喜欢，我会在未来的某个时候用UI 制作一个实时<strong class="jq io">性别声音分类器。如果你跟着我，我会让你保持更新！</strong></p><p id="06a7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated">如果你有任何疑问，请在下面的评论中告诉我。</p><p id="50ce" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy lw ka kb kc ma ke kf kg me ki kj kk kl ig bi translated"><strong class="jq io">源代码</strong>:<a class="ae lc" href="https://github.com/AdityaNikhil/Logistic-Regression/blob/master/Logistic_Regression_Gender_voice_Classification_Dataset.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/AdityaNikhil/Logistic-Regression/blob/master/Logistic _ Regression _ Gender _ voice _ class ification _ dataset . ipynb</a></p><blockquote class="ld"><p id="078e" class="le lf in bd lg lh or os ot ou ov kl dk translated">谢谢大家！！！</p></blockquote></div></div>    
</body>
</html>