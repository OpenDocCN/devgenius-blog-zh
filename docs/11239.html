<html>
<head>
<title>Zero copy cloning in Snowflake.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雪花中的零拷贝克隆。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/zero-copy-cloning-in-snowflake-46b90a7e9d7a?source=collection_archive---------4-----------------------#2022-12-27">https://blog.devgenius.io/zero-copy-cloning-in-snowflake-46b90a7e9d7a?source=collection_archive---------4-----------------------#2022-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a6b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Snowflake 的另一个很酷的特性使它不同于市场上的其他数据库。如果您计划在您的组织中建立雪花，那么考虑零拷贝克隆可以帮助您优化数据存储，也有助于节省一些资金。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/23bedc1b941b24c5fa0ce1207613d642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tP5vmAZ9zYcRljyY7qQ3wA.png"/></div></div></figure><p id="d95d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将看到零拷贝克隆，以及如何以及在哪里使用雪花的这一古老特性。</p><h2 id="f8ba" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">什么是数据克隆？</h2><p id="4fda" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">雪花数据克隆类似于一般的克隆词，即创建一个对象副本。</p><blockquote class="lv lw lx"><p id="ab15" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">根据 snowflake 的文档:- <br/> Snowflake 的零拷贝克隆特性提供了一种便捷的方法，可以快速获取任何表、模式或数据库的“快照”，并创建该对象的派生副本，该副本最初共享底层存储。这对于创建不产生任何额外成本的即时备份非常有用(直到对克隆对象进行更改)</p></blockquote><p id="84c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们可以在一个表、方案和数据库上创建任意数量的副本，而无需在雪花中花费额外的存储成本，直到可以对原始对象或克隆对象进行更改。</p><p id="3af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更改由 CDP(连续数据保护)处理。克隆对象和原始对象之间的共享公共数据指向相同的微分区，但是更改的数据存储在进行更改的各个表的专有微分区中。</p><p id="4c3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们将只为在进行更改的各个表的新分区中存储更改的存储额外付费。</p><h2 id="5ec1" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">零拷贝克隆雪花可以克隆哪些对象？</h2><p id="d067" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">因为克隆完全是关于数据存储的，所以存放数据的东西也有助于数据克隆。以下是在编写本文时所有可克隆对象的列表。最新列表可以在雪花的克隆文档中找到:</p><ul class=""><li id="2b4a" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">数据存储对象如</strong>:</li><li id="d7e9" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">数据库</li><li id="7eb2" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">计划</li><li id="5cae" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">桌子</li><li id="7155" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">流</li><li id="16d3" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">数据配置对象</strong>:</li><li id="4a49" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">阶段</li><li id="3278" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">文件格式</li><li id="eb41" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">顺序</li></ul><h2 id="ca5c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">如何在零拷贝克隆雪花中克隆一个对象？</h2><p id="2a4f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在零拷贝克隆雪花中克隆对象只需一条 SQL 语句:</p><pre class="km kn ko kp gt mq mr ms bn mt mu bi"><span id="6362" class="mv ky iq mr b be mw mx l my mz">CREATE &lt;object_type&gt; &lt;object_name&gt;<br/>CLONE &lt;source_object_name&gt;</span></pre><p id="161b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该语句将克隆一个现有对象以生成一个新对象。以上是声明的浓缩版；完整的语法如下所示:</p><pre class="km kn ko kp gt mq mr ms bn mt mu bi"><span id="c9c5" class="mv ky iq mr b be mw mx l my mz">CREATE [ OR REPLACE ] { DATABASE | SCHEMA | TABLE | STREAM | STAGE | FILE FORMAT | SEQUENCE | TASK } [ IF NOT EXISTS ] &lt;object_name&gt;<br/>CLONE &lt;source_object_name&gt;</span></pre><p id="b803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要担心上面的语法；我们将很快看到一个克隆表的例子，以帮助您更好地理解这个概念。</p><h2 id="c8d6" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">用一个例子理解克隆。</h2><p id="122b" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在雪花图中创建一个包含 100000 行的数据库、模式和表，如下所示</p><pre class="km kn ko kp gt mq mr ms bn mt mu bi"><span id="ae3c" class="mv ky iq mr b be mw mx l my mz">CREATE OR REPLACE DATABASE PROD_DB;<br/>CREATE OR REPLACE SCHEMA PROD_DB.RAW;<br/>CREATE OR REPLACE TABLE PROD_DB.RAW.TEST<br/>(NAME VARCHAR,<br/> ID1 NUMBER,<br/> ID2 NUMBER,<br/> ID3 NUMBER<br/>);<br/><br/>INSERT INTO PROD_DB.RAW.TEST<br/>SELECT <br/>'Khush' AS NAME,<br/>seq4()  AS ID1,<br/>uniform(1, 10, random(12)) AS ID2,<br/>uniform(1, 40, random(12)) AS ID3<br/>FROM <br/>table(generator(rowcount =&gt; 100000))<br/>ORDER BY seq4();<br/><br/>SELECT COUNT(*) FROM PROD_DB.RAW.TEST;</span></pre><p id="24bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe na nb nc mr b">PROD_DB.RAW.TEST</code>的克隆作为<code class="fe na nb nc mr b">PROD_DB.RAW.TEST_CLONE</code>。</p><pre class="km kn ko kp gt mq mr ms bn mt mu bi"><span id="7705" class="mv ky iq mr b be mw mx l my mz">CREATE TABLE PROD_DB.RAW.TEST_CLONE <br/>CLONE PROD_DB.RAW.TEST;<br/><br/>SELECT COUNT(*) FROM PROD_DB.RAW.TEST_CLONE;</span></pre><p id="dbbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到,<code class="fe na nb nc mr b">PROD_DB.RAW.TEST_CLONE</code>的计数也是 100000，这意味着我们已经成功地创建了<code class="fe na nb nc mr b">PROD_DB.RAW.TEST</code>表的副本，但是在后台，这两个表正在访问相同的存储，因为原始表和克隆表中的数据是相同的。</p><p id="8c60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于表级存储的详细信息，我们可以查询名为<code class="fe na nb nc mr b"><a class="ae nd" href="https://docs.snowflake.com/en/sql-reference/info-schema/table_storage_metrics.html" rel="noopener ugc nofollow" target="_blank">TABLE_STORAGE_METRICS</a></code>的信息模式视图。<br/>要查询该视图，您必须使用帐户管理员角色。该视图对其他角色可见，并且可以被查询，但是查询不会返回任何行。</p><pre class="km kn ko kp gt mq mr ms bn mt mu bi"><span id="9d68" class="mv ky iq mr b be mw mx l my mz">USE ROLE ACCOUNTADMIN;<br/>SELECT TABLE_NAME,<br/>       ID,<br/>       CLONE_GROUP_ID,<br/>       ACTIVE_BYTES,<br/>       TIME_TRAVEL_BYTES,<br/>       FAILSAFE_BYTES,<br/>       RETAINED_FOR_CLONE_BYTES<br/>FROM PROD_DB.INFORMATION_SCHEMA.TABLE_STORAGE_METRICS<br/>WHERE TABLE_CATALOG = 'PROD_DB'<br/>AND TABLE_SCHEMA = 'RAW'<br/>AND TABLE_DROPPED IS NULL<br/>AND CATALOG_DROPPED IS NULL<br/>AND TABLE_NAME IN ('TEST', 'TEST_CLONE');</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/bee449df5aee7ae80d363b5166c8a323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y92ON6nLY8qiFqZSh3q8lg.png"/></div></div></figure><p id="46eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从结果中可以看出，<code class="fe na nb nc mr b">TEST_CLONE</code>表是通过克隆<code class="fe na nb nc mr b">TEST</code>表创建的，这就是为什么两个表的<code class="fe na nb nc mr b"> CLONE_GROUP_ID</code>与<code class="fe na nb nc mr b">TEST</code>表的表 id 相同。</p><p id="109d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为 Snowflake 的克隆在克隆后执行 DML 语句之前不会占用额外的存储空间，所以值<code class="fe na nb nc mr b">ACTIVE_BYTES</code>表示数据的实际存储空间只对<code class="fe na nb nc mr b">TEST</code>表可用。</p><h2 id="cd14" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">零拷贝克隆的使用案例</h2><ol class=""><li id="8a3f" class="mc md iq jp b jq lq ju lr jy nf kc ng kg nh kk ni mi mj mk bi translated">在组织中创造各种各样的环境。开发人员经常抱怨没有一个与生产相似的开发数据库。零拷贝克隆可以在不增加额外成本的情况下解决这个问题。</li><li id="73d2" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk ni mi mj mk bi translated">快速备份表、模式和数据库。</li><li id="4633" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk ni mi mj mk bi translated">在不建立新环境和不将源对象置于风险中的情况下，测试预期的修改/开发。</li><li id="3f39" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk ni mi mj mk bi translated">完成使用其源项目的一次性任务。</li></ol><p id="c300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ly">总结:</em> </strong>在本文中，我们已经看到了零拷贝是如何工作的，以及它的用例。因为克隆整个数据库进行测试非常简单，所以您可以轻松地积累数百 TB 的冗余存储。</p><p id="6094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你认为这篇文章信息丰富，对你正在寻找的东西有所帮助，那么请鼓掌并关注我的媒体账户(<br/><a class="ae nd" href="https://datageeks.medium.com/" rel="noopener">datageeks.medium.com</a>)。如果有任何关于这个话题的问题，欢迎在 datageeks.connect@gmail.com 写评论或发邮件给我。注册成为会员(【https://datageeks.medium.com/membership】)后，你可以阅读每一篇故事，并在媒体上帮助作者。</p></div></div>    
</body>
</html>