<html>
<head>
<title>How to Improve Stability of Your SpringBoot App Using Retry?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用重试来提高 SpringBoot 应用程序的稳定性？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-improve-stability-of-your-springboot-app-using-retry-ddb0c8999c48?source=collection_archive---------0-----------------------#2021-11-19">https://blog.devgenius.io/how-to-improve-stability-of-your-springboot-app-using-retry-ddb0c8999c48?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f033" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">启用自我恢复逻辑以及使用自动化测试来验证逻辑的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4329647518bbdba467bf6bc8565fc842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y2f-Nie4MfWooBeQ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e1fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">零错误率的计算机系统几乎是不可能的。对于任务关键型系统，如金融系统，0.01%错误率的负载测试结果被认为是令人满意的结果。为了实现具有最小错误率的系统，自恢复机制是最重要的。一种常见的错误处理方法是重新运行操作。</p><p id="2b90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面让我们来看一个简单的产品报价系统，它从客户 API 中检索客户资料以进行评估和定价。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/54fdd2665e94d16c68bd0ed9bbe1cd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*nIL4gGKaNHm6bUfplsBb6Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">报价服务</figcaption></figure><p id="2fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果客户 API 返回错误 500 服务器错误，会发生什么？该服务将无法生成报价。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/6292ec18a719962488caf7166db0b39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPEhTSyoBvmR-fl7WAEjfQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">当客户 API 返回错误时，报价服务失败</figcaption></figure><p id="9f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的方法是通过重试客户配置文件检索来恢复，而不是返回服务器错误。产品报价服务不受客户 API 间歇性错误的影响。这种设计对于依赖外部 API 的系统至关重要。外部系统不知何故脱离了我们的控制，这种自我恢复机制保持了系统的稳定性并改善了用户体验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/1661cc78b8531ca147ba5cf650861d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*ZUYxhkuAdJc6DI3LzXrkvw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">与带有重试机制的客户 API 集成</figcaption></figure><p id="e8de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然可以使用简单的 for 循环以简单的方式实现重试，但 Spring framework 为开发人员提供了一种方便的方式来轻松启用重试功能。在本文中，我将介绍几个用例，并向您展示如何构建重试逻辑。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c40a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">弹簧重试</h1><p id="d305" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">重试功能是 Spring 批处理模块的一部分。从 2.2.0 开始，这个功能被从 Spring Batch 中抽出来，作为一个单独的模块来维护。要在 Spring 应用程序中启用这个特性，请将这个依赖项包含到 maven pom.xml 中。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d67e" class="ne md iq na b gy nf ng l nh ni">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;<br/>  &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="15c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该库没有自动配置，因此注释<code class="fe nj nk nl na b"><strong class="ky ir">@EnableRetry</strong></code>应该添加到 SpringBoot 应用程序或带有<code class="fe nj nk nl na b"><strong class="ky ir">@Configuration</strong></code>注释的类中，以便启用重试功能。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="2b14" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">声明式方法—构建重试逻辑的快速简单的方法</h1><p id="cc0d" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">对于上面的产品报价服务，将<code class="fe nj nk nl na b"><strong class="ky ir">@Retryable</strong></code>注释标记到用于客户资料检索的方法调用中。</p><p id="0583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码指定了以下设置:</p><ul class=""><li id="9bea" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">最多 3 次重试</li><li id="a906" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">带乘数的每次重试之间 0.5 秒-3 秒范围内的随机间隔</li><li id="3eb0" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">仅对 RuntimeException 触发重试，这意味着对于其他异常，如客户端错误或验证拒绝，系统会立即抛出异常。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0cce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无需编码，注释就能神奇地工作。最初，系统逻辑调用客户 API 客户机上的方法来检索客户简档，而无需重试注释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5e50f3c8812ba4cfd8f3a806b10efbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*hs2aHGwNnfNK2_uZIH4f1A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">客户 API 客户端的报价逻辑</figcaption></figure><p id="0027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用注释后，Spring framework 在运行时引入了一个代理，它用重试逻辑处理客户 API 客户机上的方法调用。因为代理是在系统启动时创建的，所以它对产品报价逻辑是完全透明的，因此不需要修改代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/dee146fe96b6c73a596ba64ab9e16e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*owGaP_UDB8S6cNuv9XEsLg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Spring Framework 为重试创建的代理</figcaption></figure><p id="3880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些参数也可以由系统属性指定。然而，如果您想要更动态的东西，这种方法可能不适合您。例如，除非为每个产品类型指定了单独的方法调用，否则批注不支持基于产品类型的不同重试设置。</p><p id="f338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，使用命令式风格可以实现这种具有动态重试设置的系统要求。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="261c" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">命令式方法—支持动态重试策略</h1><p id="2dbb" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">Spring framework 为命令式方法提供了一个实用程序类<strong class="ky ir"> RetryTemplate </strong>。这是一种“侵入式”方法，涉及程序代码的更改，以便系统逻辑利用<strong class="ky ir"> RetryTemplate </strong>进行客户档案检索。下图显示了它类似于声明性方法中的代理，但是，它不是在运行时创建的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/195822f3802123f7a7d365c609621eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*Itrw1DvNddhUVzK9F6lo3w.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">retry 模板</figcaption></figure><p id="40d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码根据产品类型应用不同的重试策略。这显然是使用<strong class="ky ir"> RetryTemplate </strong>的优势，因为它允许作为系统逻辑的一部分定制重试策略的灵活性。</p><p id="3452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个示例代码使用声明性方法实现了与上一个类似的重试逻辑。它展示了基于产品代码确定最大尝试次数的逻辑的灵活性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="6176" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">重试数据插入/更新</h1><p id="7bad" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">重试不仅适用于数据查询。它可以应用于其他过程，例如用于数据插入/更新的 I/O 操作。想象一下，一个消耗资源并涉及许多步骤的系统进程，您肯定不希望该进程仅仅因为在进程结束时没有将结果存储到数据库中而崩溃。对于系统来说，偶尔在 I/O 操作中遇到错误并不罕见，例如，由于并发访问，可能会出现记录锁定。当系统再次重试时，I/O 操作将成功完成。</p><p id="1d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，运算应该是幂等的。换句话说，当操作被多次执行时，结果应该是不变的。例如，如果操作执行多次，只有一条新记录插入数据库，而不是重复的记录。</p><p id="b7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果记录的主键是由 MySQL 基于自动增量代理 id 生成的，那么每次应用程序逻辑保存报价记录时，都会创建一条新记录。因此，将重试创建重复的记录。</p><p id="2282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，应用程序代码应该准备主键，而不是依赖于 MySQL 中的序列号，以便实现等幂数据插入。报价的样本数据模型表明报价代码是记录 id。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6d34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序逻辑为报价代码分配唯一的 UUID</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3bcc" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">为重试逻辑构建自动化测试</h1><p id="2fb4" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">对重试逻辑的验证并不容易。大多数情况下，很难模拟外部服务和数据库中的错误。另一种方法是使用 Mockito 模拟错误案例。下面是示例单元测试代码，用于验证报价库中的<code class="fe nj nk nl na b">save()</code>方法。</p><h2 id="4c61" class="ne md iq bd me of og dn mi oh oi dp mm lf oj ok mo lj ol om mq ln on oo ms op bi translated"><strong class="ak">场景 1 —所有尝试失败</strong></h2><p id="ad45" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">模拟重试失败的场景很简单，您可以将模拟 bean 配置为在涉及目标方法时总是抛出异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="108d" class="ne md iq bd me of og dn mi oh oi dp mm lf oj ok mo lj ol om mq ln on oo ms op bi translated"><strong class="ak">场景 2——前两次尝试失败，第三次尝试成功</strong></h2><p id="4758" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">更复杂的情况是前两次尝试失败，然后第三次成功。这个示例代码模拟了前两次调用 quotation repository <code class="fe nj nk nl na b">save()</code>方法时的异常错误，并在第三次尝试时返回 quotation 对象。Mockito 是模拟连续函数调用的方便工具。您可以简单地按顺序链接模拟设置方法— <code class="fe nj nk nl na b">thenThrow()</code>和<code class="fe nj nk nl na b">thenAnswer()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="13e9" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">最后的想法</h1><p id="c7d7" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">重试 I/O 操作的逻辑是一个微小的程序变化，但这种机制会产生巨大的差异，因为它提高了系统的稳定性并降低了错误率。Spring 框架提供了一种方便的方式来启用这种机制。如果您只是想要简单的东西，那么使用 Spring <code class="fe nj nk nl na b">@Retryable</code>注释是最好的，因为它可以神奇地启用逻辑，而无需修改任何代码逻辑。然而，如果你需要一些动态的东西，这个框架允许使用<code class="fe nj nk nl na b">RetryTemplate</code>定制重试逻辑的灵活性。</p><h1 id="b1b4" class="mc md iq bd me mf oq mh mi mj or ml mm jw os jx mo jz ot ka mq kc ou kd ms mt bi translated">GitHub 知识库</h1><p id="d7db" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">请参考这个 GitHub 库，获取完整的应用程序代码，包括重试逻辑和自动化测试用例</p><div class="ov ow gp gr ox oy"><a href="https://github.com/gavinklfong/spring-retry-demo" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">GitHub-gavinklfong/Spring-Retry-Demo:Spring 重试功能的演示</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">这个存储库包含报价 API 的示例实现和自动化测试用例。的目的是…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kp oy"/></div></div></a></div></div></div>    
</body>
</html>