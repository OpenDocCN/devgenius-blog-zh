<html>
<head>
<title>Fetch newly created data from MongoDB — Talend (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 MongoDB-Talend 获取新创建的数据(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/fetch-latest-data-from-mongodb-talend-1f21ba7b98b5?source=collection_archive---------2-----------------------#2022-09-11">https://blog.devgenius.io/fetch-latest-data-from-mongodb-talend-1f21ba7b98b5?source=collection_archive---------2-----------------------#2022-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f2cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题:</strong>如果您正常设计一个 ETL 作业，那么在每次作业运行时，它都会从源数据库中提取<strong class="jm io">所有</strong>数据并加载到目标数据库中。这将导致数据不一致，重复&amp;在作业运行中消耗大量时间。</p><p id="42df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">需求:</strong>我们的需求是，在每次 ETL 作业运行时，它应该提取源数据库中新创建的、以前从未加载到目标数据库中的行。</p><p id="1ae1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解决方案:</strong></p><p id="51bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个有效的解决方案是从目标数据库(在我们的例子中是 MySQL)加载最后一行的时间戳。</p><p id="fe5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ii) </strong>然后将这个时间戳存储到 Talend job 中的 globalMap 中。</p><p id="836b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iii) </strong>然后查询源数据库，返回在这个时间戳之后创建的行。</p><h2 id="1090" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">看看我们将如何实现它..</h2><p id="180a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我写这篇文章来解释一步一步的过程，有效地实现这一目的。</p><h2 id="fd77" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">工具:</strong></h2><p id="58ec" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><strong class="jm io">I)Talend Open Studio for Big Data 8.0:-</strong>设计 ETL 作业。</p><p id="371f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ii) MongoDB :- </strong>我们将从中提取数据的源数据库。</p><p id="0f98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">iii) MySQL 8.0 :- 目标数据库加载数据。</p><p id="5555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iv) MySQL 工作台:- </strong>与 MySQL 服务器进行图形化交互。</p><p id="3654" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">v) MongoDB Compass :- 与 MongoDB 服务器进行图形化交互。</p><p id="1c14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> vi) Docker :- </strong>运行 MySQL 和 MongoDB 的容器。</p><h2 id="c403" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">步骤 1:环境设置</strong></h2><p id="7d64" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我已经通过运行以下命令启动了 MongoDB 的容器:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="13c7" class="ki kj in ll b gy lp lq l lr ls">docker run -d -p 27017:27017 --name test-mongo mongo:latest</span></pre><p id="234d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ii) </strong>我已经创建了一个<strong class="jm io"> docker-compose.yml </strong>文件来运行 MySQL 8.0 容器。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="e261" class="ki kj in ll b gy lp lq l lr ls">version: '3.3'</span><span id="3ab1" class="ki kj in ll b gy lt lq l lr ls">services:<br/>  db:<br/>    image: mysql:8.0<br/>    restart: always<br/>    environment:<br/>      MYSQL_DATABASE: 'university_db'<br/>      MYSQL_USER: 'rao'<br/>      MYSQL_PASSWORD: 'root'<br/>      MYSQL_ROOT_PASSWORD: 'root'<br/>    ports:<br/>      - '3306:3306'<br/>    expose:<br/>      - '3306' <br/>    volumes:<br/>      - my-db:/var/lib/mysql<br/>volumes:<br/>  my-db:</span></pre><p id="bdc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在这个文件的目录下运行下面的命令。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="6aae" class="ki kj in ll b gy lp lq l lr ls">docker-compose up -d</span></pre><p id="08f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iii) </strong>使用以下命令验证容器是否启动并运行</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="aa96" class="ki kj in ll b gy lp lq l lr ls">docker ps</span></pre><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/be4034089a10b653b7a87eccda045838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fzKElaWjtImaZX5U_hz5g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><strong class="bd kk">端子输出。</strong></figcaption></figure><p id="0fee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iv)下载&amp;设置以下</strong></p><p id="7036" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">a)。<a class="ae mg" href="https://downloads.mongodb.com/compass/mongodb-compass-1.33.0-darwin-x64.dmg" rel="noopener ugc nofollow" target="_blank"> MongoDB 罗盘</a></p><p id="5853" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">b)。<a class="ae mg" href="https://sourceforge.net/projects/talend-bigdata/files/latest/download" rel="noopener ugc nofollow" target="_blank"> Talend OS 大数据</a></p><p id="2f77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c)。<a class="ae mg" href="https://dev.mysql.com/downloads/workbench/" rel="noopener ugc nofollow" target="_blank"> MySQL 工作台。</a></p><h2 id="7ac4" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">第 2 步:将数据插入 MongoDB。</h2><p id="279f" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我在数据库“大学”中创建了一个“雇员”集合，并在其中插入了一些记录。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mh"><img src="../Images/b9a32d388ed8ac5ebe5f5052abc67c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naCrVYLILZjdlwSX8OXuTw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">来自 MongoDB Compass 的数据视图。</figcaption></figure><h2 id="d2a6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">第三步:在 MySQL 数据库中创建表格</strong></h2><p id="1e48" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我在 MySQL 数据库中创建了一个 employees 表。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mi"><img src="../Images/f86c66b19ec7bc3f068baeefbbc4fdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZdWJiuuYHxKvui05JzUPw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">员工表描述</figcaption></figure><h2 id="df3b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">步骤 4:设计 ETL 作业</h2><p id="2f27" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><strong class="jm io"> i) </strong>添加<strong class="jm io"> tDBInput — MySQL </strong>，我们将从这里获取最后创建的行的时间戳。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mj"><img src="../Images/6e030db19e2acf6a40725151275c9a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAJ20fk4smpw-BO5Rp9CFg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">大学 _ 员工工作(快照 1)</figcaption></figure><p id="cc27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询:</strong></p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="3854" class="ki kj in ll b gy lp lq l lr ls">"SELECT COALESCE(MAX(timestamp), '1900-01-01 00:00:00.000') AS timestamp FROM employees"</span></pre><p id="4879" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解释:</strong>这个查询将获取表中最后一行的时间戳。在第一次运行中，当我们的表没有数据/行时，查询将返回默认值，即 1900–01–01 00:00:00.000</p><p id="8f4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ii)从模式中删除除时间戳以外的字段:</strong></p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3c19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iii) </strong>使用<strong class="jm io"> tJavaRow </strong>将时间戳值存储在<strong class="jm io"> globalMap 中。</strong></p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mm"><img src="../Images/41cf88ec715438faf8b410ad5f73b5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvSf5wtViUQ4YiN0su1kHg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">大学 _ 员工工作(快照 2)</figcaption></figure><p id="c7e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iv) </strong>在 tJavaRow 中只添加这一行。这将把时间戳存储在一个带有可变关键字“records _ last _ sync _ timestamp”&amp;字符串值“2022–09–11t 13:10:44.634 z”的映射中。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="9ded" class="ki kj in ll b gy lp lq l lr ls">globalMap.put("records_last_sync_timestamp", <strong class="ll io">new</strong> StringBuilder().append(input_row.timestamp).append("Z").toString().replace(" ", "T"));</span></pre><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mn"><img src="../Images/8321174aa8e4b7ffce2fb52456da0459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y70yRGsvLE4N_T8oBxYtXQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">大学 _ 员工工作(快照 3)</figcaption></figure><h2 id="c592" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">重点:</strong></h2><p id="c3ef" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><strong class="jm io">表中:</strong></p><p id="4d8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">时间戳格式:</strong> YYYY-MM-DD hh:mm:ss。选征兵役制（SelectiveServiceSystem）</p><p id="8458" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据类型:</strong>日期时间(3)</p><p id="ad5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在 tJavaRow : </strong></p><p id="3302" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">时间戳格式:</strong>对于 global map " YYYY-MM-DD ' t ' hh:MM:ss。SSS'Z ' "</p><p id="def0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据类型:</strong>字符串</p><p id="b7bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> v) </strong>为 employees 集合添加<strong class="jm io"> tMongoDBInput </strong>，并将以下查询放入查询部分</p><p id="cac4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> MongoDB 查询:</strong></p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="a2a4" class="ki kj in ll b gy lp lq l lr ls">"{'timestamp': {$gt: {$date: '"+globalMap.get("records_last_sync_timestamp")+"'}}}"</span></pre><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mo"><img src="../Images/da83583e8290ff1fddedfb12bbe05d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVr-HpFmarEMOvfUe6Z7Ag.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">大学 _ 员工工作(快照 4)</figcaption></figure><p id="4337" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> vi) </strong>添加一个<strong class="jm io"> tMap </strong>，它执行简单的数据映射，并将名字&amp;姓氏作为雇员的名字连接起来，以存储到目标数据库中。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mp"><img src="../Images/265156107fb4ae482ab37f1e64e53659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zi9UGmRHfyLX-dw2qZGu4g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">作业中的 tMap</figcaption></figure><p id="dae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> vii) </strong>添加<strong class="jm io"> tLogRow </strong>在控制台上打印，用于记录目的。</p><p id="3e15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> viii) </strong>添加<strong class="jm io"> tDBOutput-MySQL </strong>来存储数据。</p><p id="b7de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你的工作看起来像</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mq"><img src="../Images/d926cd6d8c1aaaaf0ba3354bb7384515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJLmKoiGpKP5YAQJhOPPkw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">大学 _ 员工工作(快照 5)</figcaption></figure><h2 id="1685" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">让我们现在测试:</h2><p id="1f67" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><strong class="jm io"> i) </strong>第一次运行时，它从 mongoDB 中提取所有 4 行，因为之前没有任何行被加载到 MySQL 中。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mr"><img src="../Images/3e37860c7440789cb2c75e93f0ffebf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5vH4WcF3Z9hl5U6MuUBEA.png"/></div></div></figure><p id="21cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">来自 MySQL Workbench 的<strong class="jm io">ii)</strong>—我们将验证数据在 data time“2022–09–12 07:01:24.231”之前是否已加载</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ms"><img src="../Images/434d5a3875bd12c8893fa70e93f4991b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jx8NGGal7bvrXt9hLHoUTg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">来自雇员表的数据检查。</figcaption></figure><p id="da4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iii) </strong>现在，如果我们重新运行该作业，它不会加载任何新行，因为没有数据被创建到源数据库中，该数据库是在上次同步时间戳<strong class="jm io">之后创建的，即</strong>2022–09–12 07:01:24.231。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mt"><img src="../Images/c13a519b835385a50e33716bb5660ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dqmNMYl3PJQz8xg56g8Zw.png"/></div></div></figure><p id="da6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> iv) </strong>让我们在 MongoDB 中添加一个新文档。(如下)</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/e52b0f70bbca3ce58b0722af4f302b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOFR6WwjwvddXPdOY7UI9A.png"/></div></div></figure><p id="8395" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> v) </strong>重新运行作业。现在您可以看到，只有新创建的数据是从源数据库加载的。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mv"><img src="../Images/eb4c6261dcb39d9b1575a52f77809436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bBZvm25lHNGQS6BeXhR5Q.png"/></div></div></figure><p id="0957" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> vi)从 MySQL Workbench 进行验证:</strong>新记录被插入到这个。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mw"><img src="../Images/992787084c0e0e57b737a124f952a971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyZ11tVENAi9fLn8f8CE8w.png"/></div></div></figure><p id="1a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论:</strong></p><p id="bb02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，使用这种方法，我们已经了解了如何从 MongoDB 中只提取新创建的行。我们没有必要在工作设计中提到任何时间限制。这是处理这个问题的通用方法。</p><p id="313c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">工作项目 Github 链接:</strong>【https://github.com/raowaqasakram/etl-learning T2】</p></div></div>    
</body>
</html>