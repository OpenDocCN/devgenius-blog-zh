<html>
<head>
<title>Single Responsibility Principle within the React ecosystem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 生态系统中的单一责任原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/single-responsibility-principle-within-the-react-ecosystem-155650ab7a00?source=collection_archive---------6-----------------------#2022-05-09">https://blog.devgenius.io/single-responsibility-principle-within-the-react-ecosystem-155650ab7a00?source=collection_archive---------6-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/852e6670a35832504f37ff37bc70c5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*KUjro0G-igf6P3lvlcDrTQ.png"/></div></figure><p id="7c71" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你读过任何讨论软件工程的书，你可能听说过<a class="ae kp" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则。其中，S 是我最喜欢的，我认为它是 React 应用程序中最实用的。</p><p id="2bcc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">今天，我们将讨论单一责任原则(SRP)以及如何确保我们的应用程序遵守软件开发中最重要的规则之一。</p><h1 id="8fae" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">什么是 SRP？</strong></h1><blockquote class="lo lp lq"><p id="bfb8" class="jr js lr jt b ju jv jw jx jy jz ka kb ls kd ke kf lt kh ki kj lu kl km kn ko ig bi translated">一个类应该有且只有一个改变的理由，这意味着一个类应该只有一个作业。</p></blockquote><p id="47d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本质上，这是一个很简单的道理。您创建的每个类、函数和组件都应该有非常明确的目的。通过让你的应用程序中的每一个功能负责<strong class="jt io">一件事</strong>并且只负责一件事，这使得你的系统的维护变得极其容易。在 React 应用程序中，这可以以几种方式应用:</p><ol class=""><li id="5bc7" class="lv lw in jt b ju jv jy jz kc lx kg ly kk lz ko ma mb mc md bi translated">当给定页面模板/模块/组件的需求发生变化时，我们的变化集的表面区域可能会非常小。如果我们构建的应用程序将许多功能融合在一起，我们最终会有许多副作用动摇我们应用程序的基础，并迫使我们改变系统的许多部分。</li><li id="93a3" class="lv lw in jt b ju me jy mf kc mg kg mh kk mi ko ma mb mc md bi translated">当功能/组件独立构建时，我们可以很容易地将它们组合在一起，创造新的体验。重用显然成为了系统的一部分。</li><li id="4b06" class="lv lw in jt b ju me jy mf kc mg kg mh kk mi ko ma mb mc md bi translated">编写测试非常容易，因为每个函数实际上只做一件事。测试一个行为，你就可以开始了！</li></ol><p id="9b0f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这太棒了！但是这个话题被谈论的如此之多是有原因的。你得到那些公关评论是有原因的，比如“我们能把这个弄干吗？”以及“我感觉我们开始把一些话题混为一谈了”。</p><p id="b59e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">很难确保你构建的特性符合 SRP 。在这篇文章中，我想告诉你如何遵循 SRP 来设计 Web 应用程序。</p><h1 id="4162" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">为什么违反 SRP 不好？</strong></h1><p id="7da9" class="pw-post-body-paragraph jr js in jt b ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko ig bi translated">想象一下，在一个世界中，您构建一个单片组件，其中每个实现细节都紧密耦合，以 Allbirds Top Navigation 为例:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/dbc9a4f53c77ed860bb414430eb55014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeuPp8iEJWL7HI0aJTaSPA.png"/></div></div></figure><p id="aec6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">假设每个功能都存在于同一个组件中。这意味着，如果购物车的实现细节发生变化，我们需要对这个整体组件进行修改。甚至在不知道的情况下，我们的更改可能会对导航的其他部分产生意想不到的副作用。</p><p id="2b55" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是一个问题，因为需求在软件中经常变化。当一个需求变更需要改变多个东西时，维护的复杂性会大大增加。如果我们让每个组件只负责一件事情，那么它们应该只在责任需要扩展或者需要改变的时候才改变。其他都不行。维护变得微不足道，而不是一个冗长的噩梦，吞噬你的整个冲刺。</p><p id="1e2e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们谈谈如何将这个大模块分成更合理的模块。</p><h1 id="aea9" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">实施 Allbirds Top Navigation 的 SRP</strong></h1><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/dbc9a4f53c77ed860bb414430eb55014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeuPp8iEJWL7HI0aJTaSPA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">全鸟顶级导航</figcaption></figure><p id="8660" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">标题</strong></p><p id="ba85" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它呈现出一些按钮，这些按钮或者给你一个下拉导航，或者把你导航到一个页面。它还呈现出购物车图标，打开购物车。</p><p id="fc15" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里的每个按钮都应该是它自己的组件，因为它们各自做自己的事情。<strong class="jt io">男式/女式</strong>按钮使子导航下拉。点击购物车时会打开购物车抽屉。这些是非常不同的功能，可以是它们自己单独的实现。</p><p id="2509" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">页眉本身只关心将自己固定在网页的顶部，并呈现出一组按钮/链接。这些按钮/链接的作用与标题无关。因此，这些按钮的任何功能都应该从标题的实现中删除。</p><p id="c047" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">推车</strong></p><p id="6ad3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如上所述，实际的购物车图标应该与导航的实现完全分离。它的所有功能和用户界面可以完全独立于应用程序。然后，我们可以在导航标题中呈现购物车图标。这些解耦意味着当购物车中的功能改变时，导航中的任何内容都不必改变。</p><p id="0060" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">值得注意的是，购物车本身就包含了大量的功能。这几乎太多了。但是仅仅在那一部分中就有大量的条目需要被划分到它们自己的类中。</p><p id="b059" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">下拉/子导航</strong></p><p id="0086" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简单地说，这只是一个呈现几个不同列表的 div。它的实现可以归结为这一点。它不应该关心标题交互是如何显示给用户的。更确切地说，这个组件只想呈现一个适当分组的孩子列表。</p><p id="41be" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">把所有东西绑在一起</strong></p><p id="8af8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过在顶部导航中清晰地划分每个 UI/功能的职责，我们创建了一个易于维护的核心应用程序。易于维护的原因是，当我们需要对顶部导航的任何部分进行更改时，每个组件都有非常明确的职责，因此每个组件都有<strong class="jt io">非常明确的更改理由。</strong></p><p id="559b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们需要改变下拉菜单的动画？进入下拉组件。</p><p id="88e5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">给购物车加油的 API 改变了？我们可以瞄准这辆车。</p><p id="b74f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们决定重构 nav 中的各种状态。我们可以只查看 nav 中相应组件的状态层。</p><p id="cfe8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过非常清晰地划分出什么组件拥有什么，我们<strong class="jt io">极大地</strong> <strong class="jt io">减少了当需求/功能/用户界面改变时变更的冲击半径。</strong></p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nb"><img src="../Images/627617cd78a2045ccc0bdd1f6abd2cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJDbESZfUMEaZjhIQS7FGQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">通过有意识地让哪个组件处理给定的职责，我们大大提高了应用程序的可维护性。</figcaption></figure><h1 id="be4b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">识别和调解违反简化程序的战略</strong></h1><p id="1bb0" class="pw-post-body-paragraph jr js in jt b ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko ig bi translated">编写代码并思考你所做的每一个设计选择似乎很容易。但是通常当你处于实现的杂草中时，你可能会犯错误，并在一个函数/类中加入比你想象的更多的职责。在 React 的世界里，我认为有一些很好的警告信号，表明你正在构建功能过多的组件/函数。</p><p id="ab9f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">道具太多</strong></p><p id="f6ad" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在《干净的代码》中，作者指出一个函数的参数越多，你的函数就越有可能做不止一件事。虽然我不认为这直接适用于 React 组件领域，但我认为这里的见解非常有帮助。</p><p id="f06a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对我来说，4 个或更多的道具是当我退一步问，“这个组件到底想做什么”。考虑一下组件本身的意图以及哪些功能/用户界面可以被剥离到它自己的组件中。</p><p id="394f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">这个组件可以用孩子吗？</strong></p><p id="32e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我早年经常犯的一个错误是没有利用儿童道具。这个道具的美妙之处在于，你可以确保父母对孩子没有意见或控制权。这在责任之间划出了一条极其明显的界限。如果您正在构建一个更“容器”的组件，请始终考虑是否可以使用子组件来构建它的实现，而不是按照规则来呈现该组件包含的任何内容。</p><p id="c964" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">复杂单元测试</strong></p><p id="6c19" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果为你的组件编写测试真的很难。这是一个非常明显的重构迹象。</p><p id="8322" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">每个人都讨厌编写测试，那么为什么不通过简化你的组件和其中的功能来让你自己变得更容易，让它们更容易编写呢！</p><p id="a770" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这种实践的美妙之处还在于，它确保了您正在编写的实际代码也是单独负责的。然而，确保您的代码本身是单独负责的本身就是一个主题，我将留待下次讨论。</p><h1 id="87ab" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">结论</strong></h1><p id="0f0b" class="pw-post-body-paragraph jr js in jt b ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko ig bi translated">单一责任原则是确保软件优化维护的一个重要概念。如果您可以构建一个复杂的应用程序，其中每个 UI/功能都有不同的职责，那么到时候您将能够轻松地更改和/或扩展这段代码。爆炸半径保持较小，您的团队将更有效率。</p><p id="754e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个话题总的来说是由业内资深人士详细讨论的，我强烈推荐进一步阅读。它将彻底改变你对代码的看法。我保证。</p><p id="aebd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">补充阅读:</strong></p><p id="477b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kp" href="https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052/ref=sr_1_1?keywords=pragmatic+programmer&amp;qid=1652140289&amp;s=books&amp;sprefix=prag%2Cstripbooks%2C195&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank">务实的程序员</a></p><p id="65f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kp" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?crid=2Z6TX66LB7EJY&amp;keywords=clean+code&amp;qid=1652140127&amp;s=books&amp;sprefix=clean+co%2Cstripbooks%2C200&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank">清洁码</a></p></div></div>    
</body>
</html>