<html>
<head>
<title>Visualizing Route Polyline Using Folium and HERE API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Folium 和 HERE API 可视化路线折线</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-route-polyline-using-folium-and-here-api-256fcf46ef9c?source=collection_archive---------7-----------------------#2022-08-17">https://blog.devgenius.io/creating-route-polyline-using-folium-and-here-api-256fcf46ef9c?source=collection_archive---------7-----------------------#2022-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="31d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写这篇文章的时候，我正打算为我的万隆之行做一个行程计划。我列出了几个我想去的地方。然而，我对我应该租一辆摩托车还是坐一辆<em class="ki"> ojol </em>(在线出租车)感到困惑。因此，我计算了从我的酒店到这些地方的路线距离。此外，如果我能把路线可视化就更好了，这样我就能瞥一眼它们，并确定我是否能让它更有效率。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/d1001ef52beeb2058f240f8316ff6801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ubmF58_6JlBT1ghQ"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安妮·斯普拉特</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5af1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在用 Google Colab 处理之前，我把所有的数据都放在 Google Sheets 中，使用下面的代码，但是你可以访问这里的<a class="ae kz" href="https://morioh.com/p/5edaf66e9e33" rel="noopener ugc nofollow" target="_blank">来查看完整的教程</a>。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="fe54" class="lf lg in lb b gy lh li l lj lk">from google.colab import auth<br/>auth.authenticate_user()</span><span id="355c" class="lf lg in lb b gy ll li l lj lk">import gspread<br/>from google.auth import default<br/>creds, _ = default()</span><span id="a9d6" class="lf lg in lb b gy ll li l lj lk">gc = gspread.authorize(creds)<br/>worksheet = gc.open('<strong class="lb io">&lt;GSHEET FILENAME&gt;</strong>').worksheet('<strong class="lb io">&lt;SHEET NAME&gt;</strong>')</span><span id="9f4d" class="lf lg in lb b gy ll li l lj lk"><em class="ki"># get_all_values gives a list of rows.</em><br/>rows = worksheet.get_all_values()</span><span id="09f1" class="lf lg in lb b gy ll li l lj lk"><em class="ki"># Convert to a DataFrame and render.</em><br/>import pandas as pd<br/>df_source = pd.DataFrame.from_records(rows[1:], columns=rows[0])<br/>df_source.head()</span></pre><p id="ca1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">出于模拟目的，我们将“ITB(万隆技术研究所)”作为我们的原点(ITB 位于-6.8918336，107.6103212)。然后我们将参观万隆的 5 个受欢迎的地方。数据如下所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/34058158e3fca93f22905df03df5482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*PUjbZPb-6t50ZAEXZoNA0w.png"/></div></figure><p id="f942" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们需要从<a class="ae kz" href="https://developer.here.com/" rel="noopener ugc nofollow" target="_blank">这里的开发者</a>那里获取 API 密匙。我们为什么用这里？因为它免费且易于使用，数量有限:</p><ol class=""><li id="b125" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated"><em class="ki">此处地理编码 API </em>:每月最多免费 3000 次通话。</li><li id="a2d1" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><em class="ki"> HERE Routing API </em>:每月最多可免费拨打 5000 个电话(针对小型摩托车/2W)或 30000 个电话(针对汽车/4W)。</li></ol><p id="fdf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以点击这里的<a class="ae kz" href="https://developer.here.com/documentation/identity-access-management/dev_guide/topics/dev-apikey.html" rel="noopener ugc nofollow" target="_blank">完整教程</a>来获取你的 API 密匙。或者，只需<a class="ae kz" href="https://platform.here.com/admin/apps" rel="noopener ugc nofollow" target="_blank">在您注册/登录后访问此链接</a>，点击“注册新应用”并注册，然后点击“API 密钥(第 0 个，共 2 个)”选项卡，最后点击“创建 API 密钥”。复制你得到的 API 密匙，我们准备在我们的模拟中使用它。</p><h2 id="7b61" class="lf lg in bd mb mc md dn me mf mg dp mh jv mi mj mk jz ml mm mn kd mo mp mq mr bi translated">使用此处的地理编码 API 将地名(或地址)转换为 Latlong</h2><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ms"><img src="../Images/116bf8e7d7c3ba8db12b9007e8796036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Av4HFMJZ8RbGzEv2xzo7DA.png"/></div></div></figure><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="2a04" class="lf lg in lb b gy lh li l lj lk">import requests, json</span><span id="d325" class="lf lg in lb b gy ll li l lj lk">apikey = '<strong class="lb io">&lt;YOUR-API-KEY-HERE&gt;</strong>'<br/>url = 'https://discover.search.hereapi.com/v1/discover'<br/>headers = {'Content-Type': 'application/json'}</span><span id="a17f" class="lf lg in lb b gy ll li l lj lk">origin_point = '-6.8918336,107.6103212' #write latlong without space<br/>latlong_destination = []</span><span id="286d" class="lf lg in lb b gy ll li l lj lk">for i, data in df_source.iterrows():<br/>  # your place name is defined below<br/>  place_name = data.destination_place</span><span id="2fd2" class="lf lg in lb b gy ll li l lj lk">  my_params = {'at':origin_point,<br/>               'limit':1,<br/>               'apikey':apikey,<br/>               'q':place_name}<br/>  r = requests.get(url, params=my_params ,headers=headers)<br/>  output = json.loads(r.text)<br/>  latlong_dict = output['items'][0]['position']<br/>  latlong = ','.join(map(str, latlong_dict.values()))<br/>  latlong_destination += [latlong]</span></pre><p id="e096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面代码的输出是我们的目的地的列表，如下所示。接下来，我们将创建从起点到每个目的地的路线。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="cf7f" class="lf lg in lb b gy lh li l lj lk">['-6.8868,107.58127',  '-6.95907,107.64829',  '-6.88506,107.61356',  '-6.90843,107.62006',  '-6.9179,107.60918']</span></pre><p id="9c90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>这个 API 的局限性，它不如 Google Geocoding API 高级。查询时必须给出详细的地名或更好地使用地址细节。如果你的目的地不多，我建议你用谷歌地图手动搜索 latlong。根据上面的输出，我们在第二个索引上有 1 个错误的 latlong(应该是-6.8891834，107.5959322)。</p><h2 id="5d35" class="lf lg in bd mb mc md dn me mf mg dp mh jv mi mj mk jz ml mm mn kd mo mp mq mr bi translated">使用 HERE 路由 API 进行路由数据检索</h2><p id="a774" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">我们将在这一步使用<code class="fe my mz na lb b">flexpolyline</code>,因为从这里得到的折线结果仍然是编码的。然而<code class="fe my mz na lb b">polyline</code>并没有默认安装在我们的 Colab 系统上，所以我们必须先用<code class="fe my mz na lb b">!pip install flexpolyline</code>安装它。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="5e59" class="lf lg in lb b gy lh li l lj lk">import flexpolyline as fp</span><span id="d092" class="lf lg in lb b gy ll li l lj lk">apikey='<strong class="lb io">&lt;YOUR-API-KEY-HERE&gt;</strong>'<br/>url = 'https://router.hereapi.com/v8/routes'<br/>headers = {'Content-Type': 'application/json'}</span><span id="a87e" class="lf lg in lb b gy ll li l lj lk">origin_point = '-6.8918336,107.6103212'<br/>distance_result = []<br/>route_result = []</span><span id="bd65" class="lf lg in lb b gy ll li l lj lk">for destination_point in latlong_destination:<br/>  my_params = {'origin':origin_point,<br/>               'destination':destination_point,<br/>               'apikey':apikey,<br/>               # change the transportMode below as your needs<br/>               'transportMode':'scooter',<br/>               'return':'summary,polyline,elevation'}</span><span id="bc90" class="lf lg in lb b gy ll li l lj lk">  r = requests.get(url, params=my_params ,headers=headers)<br/>  output = json.loads(r.text)<br/>  polyline = output["routes"][0]['sections'][0]['polyline']<br/>  length = output["routes"][0]['sections'][0]['summary']['length']<br/>  # Decode the polyline result to latlong tuple<br/>  poly_decode = fp.dict_decode(polyline)<br/>  latlong_tuple = [(el['lat'], el['lng']) for el in poly_decode]<br/>  # Collect the result (distance and route)<br/>  distance_result += [length]<br/>  route_result += [latlong_tuple]</span></pre><p id="f9e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出将是用于路由可视化的 ori-dest 距离列表和 latlong 元组列表。因此，我们可以移动到我们的最后一步，这是可视化我们的路线。</p><h2 id="2074" class="lf lg in bd mb mc md dn me mf mg dp mh jv mi mj mk jz ml mm mn kd mo mp mq mr bi translated"><strong class="ak">路线折线可视化使用</strong></h2><p id="504e" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">在下面的代码中，我们定义了<code class="fe my mz na lb b">random_color()</code>函数来为每条路线赋予随机颜色。如果需要，您可以指定自己的颜色。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="e7ed" class="lf lg in lb b gy lh li l lj lk">import folium<br/>import random</span><span id="9f3f" class="lf lg in lb b gy ll li l lj lk">def random_color():<br/>  color = "#%06x" % random.randint(0, 0xFFFFFF)<br/>  return color</span><span id="1ed8" class="lf lg in lb b gy ll li l lj lk"># Load map using your origin latlong<br/>my_map = folium.Map(location=[-6.8918336,107.6103212],<br/>                    zoom_start=14,<br/>                    tiles='OpenStreetMap')</span><span id="3eca" class="lf lg in lb b gy ll li l lj lk">for i in range(len(df_source)):<br/>  folium.PolyLine(route_result[i],<br/>                  tooltip=f"{df_source.destination_place.iloc[i]} - {distance_result[i]}",<br/>                  color=random_color(),<br/>                  weight=6).add_to(my_map)</span><span id="4bde" class="lf lg in lb b gy ll li l lj lk">my_map</span></pre><p id="2406" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出如下所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nb"><img src="../Images/3d8ca541004129cf601f2921d03f8679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SOs-e_fPae4kR_RzP16rA.png"/></div></div></figure><h2 id="3c8f" class="lf lg in bd mb mc md dn me mf mg dp mh jv mi mj mk jz ml mm mn kd mo mp mq mr bi translated">进一步发展和建议</h2><p id="63ed" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">我们上面的代码仍然需要进一步开发，所以我们可以有更多的功能，特别是如果你想使用它们的任何生产目的。以下是我的建议:</p><ol class=""><li id="805b" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">在调用 API url 时使用“try-catch ”,这样无论何时发生错误，我们都可以跳过它。</li><li id="f184" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">使用聚类方法将所有附近的点分组到一个聚类中。因为我们没有必要一直从原点出发。我们可以从一个目的地移动到另一个目的地。</li></ol><p id="e097" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">干杯！</p></div></div>    
</body>
</html>