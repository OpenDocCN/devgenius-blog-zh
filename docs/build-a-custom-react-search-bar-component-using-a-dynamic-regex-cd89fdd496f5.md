# 使用动态正则表达式构建自定义 React 搜索栏组件

> 原文：<https://blog.devgenius.io/build-a-custom-react-search-bar-component-using-a-dynamic-regex-cd89fdd496f5?source=collection_archive---------0----------------------->

![](img/94b7f6704279f2657a5df82ba57c75b7.png)

最近，我一直在使用 React Hooks 为我妈妈今年的圣诞礼物构建一个渐进式 web 应用程序；这是她的烹饪书和食谱的数字化版本，都在一个地方。

她有多少食谱，这让我想到，如果她想找到一个食谱，简单地按字母顺序排列可能不会像我希望的那样直观。

这启发我创建了一个搜索栏，当用户输入时，而不是点击按钮时，它会过滤食谱搜索结果。

下面，看看我们努力实现的最终目标。希望很明显这是**只是一个模板**，并且有**个假配方**——我妈妈没有一个叫做“奇怪的东西”的配方！。

请注意，它只显示菜肴名称中带有当前值(键入的字符)的菜肴

在这篇文章中，我们将讨论我是如何制作搜索栏，并在应用程序中实现它的。

这包括几个部分，我将逐一介绍这些主题:

1.  创建 SearchBar 组件
2.  在我们的应用程序组件中使用钩子包含必要的状态(作为道具传递给 SearchBar 组件)
3.  创建一个动态正则表达式，使用搜索栏输入的状态来匹配每个配方。
4.  使用一个 React 钩子(`useEffect`)，调用一个 helper 函数，使用 regex 过滤输入状态每次变化的结果。

如果你想亲自看看这个项目，我在这里链接了 Github 库[。此外，我的方法只是制作这种东西的一种方法，我确信还有许多其他的可能性，而且很多可能是更好的方法。现在，让我们开始第一步吧！](https://github.com/tfunk2/the-real-kates-kitchen)

# SearchBar 组件

如果您正在阅读这篇文章，希望您熟悉如何创建自己的 React 组件，所以我就不赘述了。

我创建这个组件只是为了成为一个`<div>`容器，它包含了`<input>`(搜索栏本身)和“X”`<button>`，后者清除输入中的文本字段。

让我们来看看我以当前形式制作的整个组件:

让我们按照重要的路线来划分:

**4** :从道具中析构一些我们需要的变量，分别是`query`、`setQuery`、`activePage` ( `activePage`只是用来改变我们`<input>`中作为占位符的文字)。我们还没有在`App`组件中为它创建状态，但是我们知道为了创建一个受控的表单，我们需要一个从状态中获取值的输入。于是我把那个状态命名为`query`，设置`query`状态的函数就是`setQuery`。

**5–7**:辅助函数，用于处理第**24–28**行中的“X”按钮的逻辑。当“X”按钮被点击时，我们将调用我们从 props 中析构的`setQuery`函数，并将状态重置回空字符串。实际上，我们正在将`query`重置回它的原始状态(我们将在下一节中查看该状态并作为道具传递)。

**15** :如上所述`<input>`的`value`支柱需要设置到`query`的状态。

**22** :在每次更改时(每个输入的字符)，我们用`setQuery`功能将`query`的状态设置为文本字段中输入的内容。

下一步是实际创建我们期望作为道具的状态。

# 创造状态&作为道具传递

我们知道 SearchBar 组件需要一些不同于 App 组件的东西作为道具，我决定把我所有的状态都放在 App 组件中。这就是我们接下来要做的。下面是使用 React 钩子创建的状态，具体是这里的`useState`:

```
const [activePage, setActivePage] = useState("main");const [query, setQuery] = useState("");
```

就像我前面提到的，我只是使用了`activePage`状态来改变占位符中的文本，并不是搜索栏功能的一部分。

上面也提到了，我把`query`的原始状态设置为空字符串。

现在我们已经创建了状态和一个改变状态的函数(`setQuery`)，我们可以将它作为一个道具传递给 SearchBar 组件:

```
<SearchBar
  *query*={query}
  *setQuery*={setQuery}
  *activePage*={activePage}
/>
```

就像我们的 SearchBar 组件连接到我们的 App 组件一样，它会随着用户的输入而改变查询的状态。

我们还将为我创建的名为`MainDishes`的不同组件创建一个状态。这个组件保存所有的主菜菜谱和必要的函数，以便在`query`状态改变时过滤菜谱。我们将在接下来的几节中讨论这一点。

# 动态正则表达式

我们将使用这个正则表达式来确定这道菜是否应该从结果中过滤掉。为了使正则表达式是动态的，需要根据变化的变量来创建它。

***我们想要的* :** 如果用户键入“Blu”，正则表达式应该是`/Blu/`，同样，对于其他查询，如果他们键入“abc”，正则表达式应该是`/abc/`。

我们可以通过使用`new RegExp`语法创建一个这样的正则表达式。

```
let mainDishesRegex = new RegExp(*query*, "i")
```

为了分解它，我们创建了一个新的正则表达式，第一个参数是在正斜杠之间的内容，后面的参数是我们想要的标志。

所以在`mainDishesRegex`中，无论用户键入什么(`query`)都在正斜杠之间，我使用的唯一标志是`i`标志，这使得正则表达式不区分大小写。

现在我们准备使用这个正则表达式来过滤结果，在本例中，显示的是哪些食谱。

# 过滤功能和使用效果

最后一步是创建助手函数，该函数将根据配方名称以及`mainDishesRegex`是否匹配该名称来过滤配方。

首先让我们来看看我一直在处理的数据:

一组对象，每一个都是伪造的配方

现在我们已经将所有的菜肴放在一个数组中，让我们在这个组件(`MainDishes`)中创建一些状态，它将保存应该显示的所有菜肴。这个状态保存了一个过滤后的盘子的数组，我将其命名为`mainRecipesShown`:

```
const [mainRecipesShown, setMainRecipesShown] =
  useState([...recipes])
```

我将初始状态设置为一个填充了`recipes`数组内容的数组，因此所有的菜肴都将显示为开始。

然后，每次`query`的状态改变时(每次输入一个字符时)，我们需要调用一个函数来过滤这个数组。这是使用另一个钩子`useEffect`的好时机，它允许我们在某些状态改变时执行代码，在本例中是`query`:

```
useEffect(() => {
  filterDishes()
}, [*query*])
```

这表示，当`query`改变时，调用`filterDishes`，我们接下来会看到:

```
const filterDishes = () => {
  if(*query*.length > 0) {
    let newDishes = [...recipes].filter(*dish* =>
      mainDishesRegex.test(*dish*.name))
    setMainRecipesShown(newDishes)
  } else if (*query*.length === 0) {
    setMainRecipesShown([...recipes])
  }
}
```

`filterDishes`首先查看`query`的`length`，如果长度大于 0，则取`recipes`数组的一个副本，根据表达式`mainDishesRegex.test(*dish*.name)`是否返回`true`或`false`进行过滤。

这个表达式根据我们的动态正则表达式测试每个菜名，如果输入文本字段的字符串在菜名中的某个位置，表达式返回`true`，如果不是，则返回 `false`，有效地过滤掉不匹配的内容。然后我们简单地将`mainRecipesShown`设置为过滤结果的新数组

但是，如果`query`的`length`正好为 0，这是`query`的原始状态，那么只需将`mainRecipesShown`的状态重置为数组`recipes`的副本即可。

最后，我们将所有的部分放在一起，每次用户键入一个字符，这个过滤函数将把`mainRecipesShown`设置为适当的配方数组，我们可以自由地使用该数组中找到的所有配方创建元素。

# 结论

这样一个简单的搜索栏是添加一个特性的简单方法，该特性可以让用户更快地找到特定的数据，从而改善整体用户体验。

我又一次学到了一些关于正则表达式的新东西，以及它们是多么有用的一个工具；我希望这篇文章也能帮助你学到一些东西，或者启发你制作一个自己的反应式搜索栏！

一如既往，感谢阅读，祝黑客快乐！