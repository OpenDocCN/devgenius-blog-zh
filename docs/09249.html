<html>
<head>
<title>Recursive CTE — Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归 CTE——去神秘化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/recursive-cte-demystified-6adc0021813f?source=collection_archive---------5-----------------------#2022-08-09">https://blog.devgenius.io/recursive-cte-demystified-6adc0021813f?source=collection_archive---------5-----------------------#2022-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3b2aca5701db84d39b093ebfc3eda82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O7VNtg__LIHgU8QjcR-Rg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@tine999?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂内·伊万尼奇</a>在<a class="ae ja" href="https://unsplash.com/@tine999?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="b568" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">递归解决 SQL 问题</p><h1 id="c59e" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">CTE</h1><p id="bcda" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">公用表表达式(CTE)是一个临时结果集，可以被紧跟在 CTE 后面的 DML 语句引用。</p><p id="9de9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CTE 的语法如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e6a0" class="mk kz jd mg b gy ml mm l mn mo">WITH <br/>  cte AS ( SELECT a, b FROM table1 )<br/>SELECT * FROM cte</span></pre><p id="dd7c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以创建多个 cte 并一起使用:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="682f" class="mk kz jd mg b gy ml mm l mn mo">WITH<br/>  cte1 AS (SELECT a, b FROM table1),<br/>  cte2 AS (SELECT c, d FROM table2)<br/>SELECT b, d FROM cte1 INNER JOIN cte2<br/>WHERE cte1.a = cte2.c;</span></pre><p id="e031" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在一个基表上创建了 CTE，那么在 CTE 上的任何更新或删除都会传播到该基表。如果 CTE 是从多个表中创建的，并且只对一个基表进行了更新，它仍会将更改传播到基表，但结果可能不稳定。每个 CTE 的作用域都存在于定义它的语句中。</p><p id="e86a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，CTE、子查询和临时表具有相似的性能。从可读性来看，人们可能更喜欢其中的一个。但是 CTE 在子查询 1 上有两个闪光点。因为 CTE 是它们自己的查询，所以它们可以被重用并避免冗余。2.CTE 可以递归使用。</p><h2 id="17f2" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">递归复习器</h2><p id="bada" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">递归解决方案必须具有以下属性</p><ul class=""><li id="7b0f" class="na nb jd kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated"><strong class="kc je">基础案例</strong>，其中递归软件系统达到定义的解决方案状态</li><li id="1070" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">以某种方式(通常通过减少输入空间)在有限的步骤中将递归程序移向基本情况</li></ul><h2 id="5144" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">递归 CTE</h2><p id="4151" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">一个<strong class="kc je">递归 CTE </strong>是一个子查询，它使用自己的名字来引用自己。</p><p id="4d60" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建递归 CTE 的语法如下</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9fd9" class="mk kz jd mg b gy ml mm l mn mo">WITH <strong class="mg je">RECURSIVE</strong> cte AS <br/>    (<br/>        SELECT query (Non recursive or base query)<br/>        UNION (separtor [multiset operators])<br/>        SELECT query (recursive query using cte with termination condition)<br/>    )<br/>SELECT * FROM cte</span></pre><p id="a1c1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查询的流程有以下步骤:</p><ul class=""><li id="34a7" class="na nb jd kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">首先，执行基本查询以形成基本结果集(R0)，并将该结果用于下一次迭代。</li><li id="3753" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">第二，使用前一次迭代的输入结果集执行递归成员，并返回一个子结果集(Ri ),直到满足终止条件。当前一个结果是一个空表时，终止条件到达。递归查询不引用自身，它只引用前一个结果，当前一个结果是一个空表时，递归停止。</li></ul><figure class="mb mc md me gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi no"><img src="../Images/9315afa0b292f2e4ae6c858188f0cffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rF0ROcV1_PpJuFbxpTJfg.png"/></div></div></figure><ul class=""><li id="2312" class="na nb jd kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">第三，使用<code class="fe np nq nr mg b">UNION</code>操作符组合所有结果集 R0，R1，… Rn 以产生最终结果集。</li></ul><figure class="mb mc md me gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/92d2af6cf28966cece7c29d4c422c7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PJPDlqJZneUTEYaxRxzHg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">递归 CTE 流程图</figcaption></figure><h2 id="112d" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">要记住的要点</h2><ul class=""><li id="6305" class="na nb jd kc b kd lw kh lx kl nt kp nu kt nv kx nf ng nh ni bi translated">递归查询只能在它的<code class="fe np nq nr mg b">FROM</code>子句中引用一次 CTE 名称，而不能在任何子查询中引用。</li><li id="328a" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">递归查询不能有聚合函数</li><li id="ae75" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">如果期望的结果集包含重复项，那么我们需要使用<code class="fe np nq nr mg b">UNION ALL</code>作为多重集操作符。</li><li id="9afa" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">递归查询必须包括终止条件</li><li id="ff21" class="na nb jd kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">确保递归深度在通过设置此变量<code class="fe np nq nr mg b">cte-max-recursion-depth</code>定义的系统限制范围内</li></ul><h1 id="554c" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">例子</h1><h2 id="5f81" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">生成从 1 到 n 的数字。</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ce0d" class="mk kz jd mg b gy ml mm l mn mo">WITH RECURSIVE cte AS <br/>    (<br/>        SELECT 1  as n <br/>        UNION ALL   <br/>        SELECT n + 1  FROM cte WHERE n &lt; 5 <br/>    )<br/>SELECT * FROM cte;</span></pre><h2 id="a13e" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">生成斐波那契数列</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="87bc" class="mk kz jd mg b gy ml mm l mn mo">WITH RECURSIVE fibonacci AS<br/>(<br/>  SELECT 1 as n, 0 as fib_n, 1 as next_fib_n<br/>  UNION ALL<br/>  SELECT n + 1, next_fib_n, fib_n + next_fib_n FROM fibonacci WHERE n &lt; 10<br/>)<br/>SELECT * FROM fibonacci;</span></pre><p id="3bf0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似地，我们也可以生成阶乘</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="aa15" class="mk kz jd mg b gy ml mm l mn mo">WITH RECURSIVE factorial AS<br/>(<br/>  SELECT 1 as n, 1 as fact<br/>  UNION ALL<br/>  SELECT n + 1, (n+1)*fact, <br/>  FROM factorial WHERE n &lt; 5<br/>)<br/>SELECT * FROM factorial;</span></pre><h2 id="2436" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">在单独的行中打印给定单词的每个字符。</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1850" class="mk kz jd mg b gy ml mm l mn mo">SET <a class="ae ja" href="http://twitter.com/changes" rel="noopener ugc nofollow" target="_blank">@changes</a> = 'CHANGES';<br/>WITH RECURSIVE cte  AS (<br/>  SELECT 1 AS rownum<br/>  UNION ALL<br/>  SELECT rownum + 1 FROM cte WHERE rownum &lt; LENGTH(<a class="ae ja" href="http://twitter.com/changes" rel="noopener ugc nofollow" target="_blank">@changes</a>)<br/>)<br/>SELECT<br/>SUBSTRING(<a class="ae ja" href="http://twitter.com/changes" rel="noopener ugc nofollow" target="_blank">@changes</a>, rownum, 1) AS print_down<br/>FROM cte;</span></pre><h2 id="ae13" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">树遍历</h2><p id="31a6" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">给定一个表<code class="fe np nq nr mg b">bst</code>，它有两列<code class="fe np nq nr mg b">node</code>和<code class="fe np nq nr mg b">parent</code>，给出了二叉查找树中一个节点的值和它们各自的父值。写 SQL <strong class="kc je"> </strong>到<strong class="kc je"> </strong>找到给定<code class="fe np nq nr mg b">bst</code>中所有节点的路径。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="26e7" class="mk kz jd mg b gy ml mm l mn mo">WITH RECURSIVE<br/>cte ( node, path )<br/>AS<br/>( SELECT node, cast ( 1 as char(30) )  <br/>          FROM bst WHERE parent IS NULL<br/>  UNION ALL<br/>  SELECT bst.node,  CONCAT ( cte.path, '--&gt;', bst.node ) <br/>         FROM cte JOIN bst ON cte.node = bst.parent<br/>)<br/>SELECT * FROM cte ORDER BY node;</span></pre><h2 id="0dff" class="mk kz jd bd la mp mq dn le mr ms dp li kl mt mu lm kp mv mw lq kt mx my lu mz bi translated">取消给定数据的分组</h2><p id="d7fa" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为下面的输入表编写一个查询来生成给定的输出表。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="20a0" class="mk kz jd mg b gy ml mm l mn mo"><strong class="mg je">Input Table</strong><br/>+----+----------+------------+<br/>| id | Customer | VisitCount |<br/>+----+----------+------------+<br/>| 1  | Abbot    | 4          |<br/>| 2  | Doris    | 1          |<br/>| 3  | Emerson  | 2          |<br/>+----+----------+------------+</span><span id="5345" class="mk kz jd mg b gy nw mm l mn mo"><strong class="mg je">Output Table:<br/></strong>+----+----------+<br/>| id | Customer |<br/>+----+----------+<br/>| 1  | Abbot    |<br/>| 1  | Abbot    |<br/>| 1  | Abbot    |<br/>| 1  | Abbot    |<br/>| 2  | Doris    |<br/>| 3  | Emerson  |<br/>| 3  | Emerson  |<br/>+----+----------+</span></pre><p id="5f99" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决办法</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c620" class="mk kz jd mg b gy ml mm l mn mo">with data as (<br/>  SELECT 1 as id, 'Abbot' as Customer, 4 as VisitCount<br/>  UNION ALL<br/>  SELECT 2, 'Doris', 1<br/>  UNION ALL<br/>  SELECT 3, 'Emerson', 2<br/>), cte as<br/>    (<br/>      SELECT id, Customer, VisitCount<br/>      FROM data<br/>      UNION ALL<br/>      SELECT cte.id, cte.Customer, cte.VisitCount - 1<br/>      FROM cte <br/>      INNER JOIN data d ON d.Customer = cte.Customer and d.id = cte.id<br/>      WHE cte.VisitCount &gt; 1<br/>    )<br/>SELECT id, Customer<br/>FROM cte<br/>ORDER BY 1</span></pre><p id="8c1d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在上面的例子中看到的，递归 cte 可以用于层次结构或树结构数据的序列生成和遍历。</p><p id="99fc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">快乐递归！！</p></div></div>    
</body>
</html>