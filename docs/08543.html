<html>
<head>
<title>How to: mod in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何:在 Rust 中修改</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-mod-in-rust-b2da3e1ff0f2?source=collection_archive---------4-----------------------#2022-06-23">https://blog.devgenius.io/how-to-mod-in-rust-b2da3e1ff0f2?source=collection_archive---------4-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码库的组织是一个项目中不被注意的英雄之一。当它好的时候，你通常感觉不到，但是一旦你进入一个代码组织得很差的开发中… <strong class="jp ir">你会在你自身最深处注意到它</strong>。</p><p id="598d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将谈一谈<strong class="jp ir"> Rust 模块</strong>以及如何使用它们将我们的代码库分成不同的、易于导航的文件夹和文件。不，抱歉，这不是关于如何为游戏《Garry 的锈》的 Mod 创建者<em class="kl">创建 mod-救命，我不能停止说 Mod-。</em></p><h1 id="676b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">老兵</h1><p id="c658" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们都喜欢我们的项目被分成独立的、有意义的文件，以及直观地组织在文件夹中，并带有相关的组件。Rust 允许我们轻松地为自己定义模块。每个文件中的代码都被打包到一个与文件同名的模块中，我们可以在我们的<code class="fe lp lq lr ls b">main.rs</code>中用<code class="fe lp lq lr ls b">mod &lt;file&gt;</code>来声明它。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/edaad86ae571fa7e7be9738a5313cef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25sVg4Bt4js8DKGM4bFNPw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">通过声明 foo 模块，我们现在可以访问它的所有公共成员</figcaption></figure><p id="e4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，<strong class="jp ir">但是</strong> <strong class="jp ir">文件夹呢？没有一个具有相当规模的项目可以不将相关代码存储在文件夹中而得到管理，但是如果我们创建一个<code class="fe lp lq lr ls b">bar</code>文件夹并用<code class="fe lp lq lr ls b">mod bar</code>声明它就不行了，对吧？不，对于 Rust，我们过去需要更多的 mod - <em class="kl">帮助- </em>，我们需要<code class="fe lp lq lr ls b">mod.rs</code>。</strong></p><h2 id="f15d" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">优秀的老式汽车</h2><p id="4cb6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">任何带有<code class="fe lp lq lr ls b">mod.rs</code>文件的文件夹都会被转换成一个模块。在该文件中，我们可以添加我们希望在模块的第一级中可用的任何代码。例如，如果我们制作了<code class="fe lp lq lr ls b">foo/mod.rs</code>并在内部复制了相同的<code class="fe lp lq lr ls b">bar</code>函数，上面例子中的<code class="fe lp lq lr ls b">main.rs</code>仍然可以工作。</p><p id="633e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们希望文件夹包含更多的文件，对吗？是的，<strong class="jp ir">我们做</strong>，mod 文件将允许我们声明它们，因为它知道这些文件的存在。我们只需要将<code class="fe lp lq lr ls b">mod &lt;file&gt;</code>添加到 mod.rs 中，该文件的公共成员将对模块中的其他组件可用，如果它们被加上了<code class="fe lp lq lr ls b">pub</code>，任何可以访问该 mod 的文件也将能够查看这些成员</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">main.rs 和的内容。/calc/</figcaption></figure><h1 id="4ba9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">新人</h1><p id="01d0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们已经看到了过去我们是如何构建所有 Rust 项目的，但是我们都知道有很多同名的文件是多么令人沮丧- <em class="kl">是的，我说的是你，</em> <code class="fe lp lq lr ls b"><em class="kl">index.js</em></code> -对吧？想要通过搜索轻松地导航到文件，以错误的文件结束，或者让 IDE 选项卡填充完整的路径名，以区分所有相似的文件。</p><p id="7d67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么<a class="ae mx" href="https://github.com/rust-lang/rfcs/blob/master/text/2126-path-clarity.md" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这个 RFC </strong> </a>出现了，以及它如何最终提供了一种在项目中声明文件夹模块的新方法。怎么会？简单，像这样:</p><pre class="lu lv lw lx gt my ls mz na aw nb bi"><span id="7bb6" class="mj kn iq ls b gy nc nd l ne nf">./foo/mod.rs -&gt; ./foo.rs</span></pre><h2 id="54bb" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">崭新的<module>。同悦</module></h2><p id="be84" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">2018 年版<strong class="jp ir">增加的新方式就是这样。一个具有相同名称和相同文件夹级别的文件将像我们在其中有一个<code class="fe lp lq lr ls b">mod.rs</code>一样工作。有道理对吧？第一个例子展示了<code class="fe lp lq lr ls b">foo.rs</code>和<code class="fe lp lq lr ls b">mod foo</code>如何足以创建模块<code class="fe lp lq lr ls b">foo</code>，因此额外的文件夹应该只是向该模块添加内容。</strong></p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">与相同的文件。/calc/mod.rs 但这次只是 calc.rs</figcaption></figure><p id="1f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，这两种类型是互斥的，如果您试图同时使用这两种类型，编译器会对您大喊大叫。<strong class="jp ir">那家伙给你的选项是更简洁而不是相反</strong>，保存在 mod<em class="kl">——这肯定是像正文里的第 27 个“mod”什么的——</em>。</p><pre class="lu lv lw lx gt my ls mz na aw nb bi"><span id="40e0" class="mj kn iq ls b gy nc nd l ne nf">error[E0761]: file for module `calc` found at both "src/calc.rs" and "src/calc/mod.rs"<br/> --&gt; src/main.rs:1:1<br/>  |<br/>1 | mod calc;<br/>  | ^^^^^^^^^<br/>  |<br/>  = help: delete or rename one of them to remove the ambiguity</span></pre><h1 id="e74c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">哪一个</h1><p id="1d99" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">好了，我们已经看到了 Rust 提供的两种方式，那么让我们来看看两者的相同优点和缺点:</p><ul class=""><li id="cb0d" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">&lt;module&gt;.rs</code>可以从任何单个文件构建。将文件转换成<code class="fe lp lq lr ls b">mod.rs</code>模块需要重构。</li><li id="6b3f" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">mod.rs</code>更含。所有的代码都在一个文件夹里。</li><li id="bd99" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">&lt;module&gt;.rs</code>降低噪音，没有几十个<code class="fe lp lq lr ls b">mod.rs</code>档。</li><li id="1cc2" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">mod.rs</code>名称更能描述文件的通常内容。</li><li id="2c57" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">&lt;module&gt;.rs</code>当它也包含模块根级代码时效果更好。</li><li id="dcb4" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe lp lq lr ls b">mod.rs</code>与它的对应物相比，看到它为它所公开的接口写满了数百行文档，伤害会小一些。</li></ul><h2 id="769a" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">所以…</h2><p id="3c96" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">哪一个？</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/cca59de726eac01fa791f87033a406b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*D14erHb35qxKPvAA.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">黄金国是梦工厂的杰作之一，我爱这两个呆子</figcaption></figure><p id="6ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你劫持我通过所有这些职位，不回答我应该使用哪一个？是的，是的，我做到了。我的意思是，如果我们有两种选择，我认为我们能做的最好的事情就是用我们认为最适合每种情况的方法。</p><p id="9061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何时候我发现自己想要做一个<code class="fe lp lq lr ls b">foo/foo.rs</code>而没有编译器对我大喊大叫？<code class="fe lp lq lr ls b">&lt;module&gt;.rs</code>。这个<code class="fe lp lq lr ls b">/enemy</code>只是包含了一个游戏过多的敌人吗？<code class="fe lp lq lr ls b">mod.rs</code>因为它让我想起了<code class="fe lp lq lr ls b">index.js</code>。但是所有这些敌人都实现了<code class="fe lp lq lr ls b">Enemy</code>特性吗？然后我觉得含有那种特质的<code class="fe lp lq lr ls b">enemy.rs</code>比较好。他们也实现<code class="fe lp lq lr ls b">Spawnable</code>吗？他妈的，让我们回到<code class="fe lp lq lr ls b">mod.rs</code>这样它就可以容纳两者，而不用用名字遮蔽另一个。感谢上帝这是灵活的。</p><p id="f721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看到了吗？<strong class="jp ir">两者都好</strong>。请不要把它们混在一起。</p><h1 id="fa83" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">奖金</h1><p id="9bf8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">作为一个小小的奖励，记住<code class="fe lp lq lr ls b">pub use</code>是存在的，它可以帮助你声明和隐藏模块，同时你可以公开它的成员。这有助于基于位于模块根的代码做出决策。你可以像这样暴露它，并且仍然把它分开。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">切断这种重复的路径感觉很好</figcaption></figure><h1 id="e3c6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">奖金 2</h1><p id="26db" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">下面的 Reddit 帖子包含了一个关于这个主题的很好的讨论，以及一个展示不同之处的漂亮图片。去看看。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nv mw l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">关于 Rust 中模块层次结构的 Reddit 讨论</figcaption></figure><p id="137c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，回购中有完整的源代码:</p><div class="nw nx gp gr ny nz"><a href="https://github.com/kriogenia/medium/tree/main/modules" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">中等/主要克里金属的模块/中等</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">存放我的媒体帖子中使用的示例的存储库</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on md nz"/></div></div></a></div></div></div>    
</body>
</html>