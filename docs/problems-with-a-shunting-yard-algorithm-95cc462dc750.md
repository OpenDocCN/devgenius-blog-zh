# 调车场算法的问题

> 原文：<https://blog.devgenius.io/problems-with-a-shunting-yard-algorithm-95cc462dc750?source=collection_archive---------9----------------------->

![](img/aaef5cb1fccdabfbd164eb5377c8bfe8.png)

我已经用 java 成功实现了一个调车场算法。该算法本身很简单，但我有符号化的麻烦。目前，除了一件事之外，这个算法适用于我想要的所有东西。我如何区分减法(-)和负数(-)呢

比如 4–3 是减法，但-4+3 是负数

我现在知道如何找出何时应该是负数，何时应该是负号，但是算法应该放在哪里，因为如果你把它作为一个函数，它并不总是有效

3 + 4 * 2 / -( 1 − 5 ) ^ 2 ^ 3

当 1–5 变成-4 时，它会在平方和立方之前变成 4

就像 3+4 * 2/cos(15)^ 2 ^ 3 一样，你需要在平方和立方之前取余弦值

但是在真正的数学中，你不会用 a——因为你实际上说的是 3+4 * 2/-((15)^ 2 ^ 3)才能得到正确的值。

**——————**答案

这听起来像是在做一个 lex-then-parse 风格的解析器，在 lexer 中需要一个简单的状态机来为一元和二进制减号获取单独的标记。(在 PEG 解析器中，这不是你需要担心的事情。)

在 JavaCC，你会有一个`DEFAULT`州，在那里你会认为`-`人物是`UNARY_MINUS`。当您对一个主表达式的结尾进行标记化时(根据您给出的例子，可以是一个结束参数，也可以是一个整数)，那么您将切换到`INFIX`状态，在这里`-`将被认为是`INFIX_MINUS`。一旦遇到任何中缀运算符，就会返回到`DEFAULT`状态。

如果你自己卷，可能会简单一点。看看这个 [Python 代码](http://en.literateprograms.org/Shunting_yard_algorithm_%28Python%29#Operators)的聪明做法。基本上，当你遇到一个`-`的时候，你只是检查一下前面的 token 是不是中缀运算符。该示例使用字符串`"-u"`来表示一元减号标记，这便于非正式的标记化。据我所知，Python 示例确实无法处理`-`跟在开放 paren 后面或者出现在输入开始处的情况。那些也应该被认为是一元的。

为了在调车场算法本身中正确处理一元减号，它需要比任何中缀运算符具有更高的优先级，并且需要标记为右关联。(确保您处理了右结合性。您可能已经忽略了它，因为您的其余操作符是左关联的。)这在 Python 代码中已经足够清楚了(尽管我会使用某种结构而不是两个独立的映射)。

到了求值的时候，您需要稍微不同地处理一元运算符，因为您只需要从堆栈中弹出一个数字，而不是两个。取决于您的实现看起来像什么，可能更容易的是浏览列表并用`[-1, "*"]`替换每一次出现的`"-u"`。

如果你能理解 Python，你应该能在我链接的例子中看到我所说的一切。我发现代码比其他人提到的 C 版本更容易阅读。另外，如果你好奇的话，我曾经写过一篇关于在 Ruby 中使用调车场[的文章，但是我把一元操作符作为一个独立的非终结符来处理，所以没有显示出来。](http://austintaylor.org/blog/2010/07/25/treetop-operator-precedence/)