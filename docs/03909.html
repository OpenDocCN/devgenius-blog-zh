<html>
<head>
<title>Angular2 Typescript makes our life more intriguing.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular2打字稿让我们的生活更耐人寻味。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular2-typescript-makes-our-life-more-intriguing-82729afd9d30?source=collection_archive---------5-----------------------#2021-01-01">https://blog.devgenius.io/angular2-typescript-makes-our-life-more-intriguing-82729afd9d30?source=collection_archive---------5-----------------------#2021-01-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9cdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular CLI 11的一些实用想法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c6aee1609408ec2ef4b805557e0e130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-A6JodFepiObNIhr6SU38w.png"/></div></div></figure><p id="bc11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开发过程不能没有前端运行。这里我结合自己日常的前端开发工作，把一些有角度的循环往复的东西组合在一起。</p><p id="5917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一.皮棉库</strong></p><p id="3f76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lint的严格规则帮助我们避免了空的和未定义的错误，这非常好。但是Lint可能非常烦人，并且某些类型的错误会不时地重复出现，从而停止编译过程。举个例子，最讨厌的:</p><p id="ec10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">a.禁止连续的空行</p><p id="41c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">b.不能使用双大括号。“应该是”</p><p id="95a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c.缺少分号</p><p id="e975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时很容易忘记在函数式编程中添加半列</p><p id="5ccf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">d.“rxjs”的多个导入可以合并为一个。</p><p id="f955" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">import {Subscription} from ‘rxjs’;<br/> import {fromEvent} from ‘rxjs’;</code></p><p id="08d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><br/>应该是:<code class="fe ku kv kw kx b">import {fromEvent, Subscription} from ‘rxjs’;</code></p><p id="5ae5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">e.参数中冒号后应有一个空格</p><p id="f357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">f.指定的进口必须按字母顺序排列。</p><p id="0823" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">import {AfterViewInit, Component, ElementRef, OnDestroy, OnInit, ViewChild} from ‘<a class="ae ky" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;</code></p><p id="a6a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">g.超过最大行长度160</p><p id="d50b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以同样的方式等等…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/95647c4fb86afe33bbc691ed36294789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Ywi2dYmPzIWjeG6X2bwvRA.jpeg"/></div></figure><p id="6cb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二。接下来，我收集了一些我在开发过程中经常遇到的代码。逻辑简单易懂。</p><ol class=""><li id="f29f" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated"><strong class="jm io">任何</strong></li></ol><p id="c23a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java使用<strong class="jm io"> Object </strong>关键字作为其他类型的根，Angular在这种情况下与Kotlin相似，使用<strong class="jm io"> Any </strong>关键字:</p><p id="c3de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">const myVariable: any = [];</code></p><p id="3334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.如何用Typescript合并两个对象数组？用<strong class="jm io">spread</strong>operator很容易:this.results = [ …this.results，…data . results]；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="4ec5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.模板分析错误:无法绑定到“ngModel”，因为它不是“input”的已知属性。</p><p id="bac3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需添加<strong class="jm io">表单模块</strong>即可显示此类搜索表单<br/>T5】</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="c767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.数组在另一个数组内，使用<code class="fe ku kv kw kx b">some </code>运算符过滤它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="9262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.输入表单字段的Karma Jasmine单元测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="f929" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.父组件和子组件之间的数据交互:@Output允许子组件向父组件发送数据。</p><p id="c728" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://angular.io/guide/component-interaction" rel="noopener ugc nofollow" target="_blank">此处为官方文档</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="c2bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">@Input()允许父组件更新子组件中的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e514" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.使用Rx.js作为组件之间的通信。</p><p id="6eef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用旧的预备编程，你可以得到模块化或性能。通过功能性Rx编程，您可以两者兼得。当我在RxJava中使用反应式方法时，我很喜欢，在JavaScript中看到它也很好。</p><p id="1956" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于3 'O '原则的Rx:可观察的—操作者—观察者。</p><p id="d082" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们创建一个可观察的，并订阅一个可观察的流。中间层操作员处理数据(映射、过滤..).</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="73a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8.但是我们也可以在Rx.js中使用管道。自定义管道仅在数据发生变化时调用其转换方法。<strong class="jm io"> catchError </strong>和<strong class="jm io"> finalize </strong>方法对于处理状态非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="86e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">9.在ngOnDestroy()方法中订阅和取消订阅服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d74f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">10.导航到页面</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="a577" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者我们也可以以更全面的方式导航:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="155e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">11.表单中禁用的字段。无法在服务器上发布。<br/>有时UI表单中的字段应该是可见的，但对于编辑是禁用的:<br/> <code class="fe ku kv kw kx b">&lt;input type=”text” id=”createdBy” name=”createdBy” value=”Olmer” DISABLED /&gt;</code> <br/>要在表单中推送该值，请在POST请求之前将其状态更改为“启用”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="78f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">12.构造器vs ngOnInit和整个生命周期</p><p id="3134" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构造函数允许我们进行依赖注入(通过实例服务)</p><p id="6218" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当输入或输出绑定值改变时调用ngOnChanges<br/>第一次ngOnChanges后调用ngOnInit。用于方法调用一次。</p><p id="286a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从组件的<ng-content>元素作为子元素传递的内容。<br/> <code class="fe ku kv kw kx b"><a class="ae ky" href="http://twitter.com/ViewChild" rel="noopener ugc nofollow" target="_blank">@ViewChild</a>('objContent') objContent: ElementRef;</code></ng-content></p><p id="6f37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ngAfterContentInit，ngafterviewit-视图在内容之后初始化，可以在ngafterviewit中使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/ff1c6527977760d05bd284d6ac636fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IyuwqxvZeWNaO3rzLkTstA.png"/></div></figure><p id="3e94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">13.作为类的全局变量。</p><p id="2990" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需创建一个简单的服务模型ReportTypeParamsModel，使其成为<a class="ae ky" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank"> @Injectable </a>并添加到模块的‘Providers’中。这些数据将被全球访问。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="c7e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">14.私有成员变量“store”永远不会被重新分配；标记为“<code class="fe ku kv kw kx b">readonly</code>”。</p><p id="ab99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将function属性设为<code class="fe ku kv kw kx b">readonly </code>是一个很好的做法，因为您可能不想再次重新分配实例。</p><p id="116d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">private readonly unsubscribe = new Subject();</code></p><p id="95e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">readonly: <br/>允许在用于属性的构造函数<br/>中赋值，以防止重新赋值</p><p id="8398" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">const: <br/>用于变量，像<code class="fe ku kv kw kx b">const var: string;</code> <br/>也不能重新分配</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="7097" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">15.用html模板绑定静态变量。</p><p id="6017" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不能直接静态变量。但是我们可以参考一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="4b97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">16.Typescript中的枚举非常容易预测</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/5e882de99e1ebfa5fe7af42d0e74dfee.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*W42PCpyQclPi3SfOGzrXnw.png"/></div></figure><p id="e8c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="cc5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">充满障碍、规则和条件的打字稿。由于我的工作，我收集细节只是为了获得更多的知识。所有这些算法都在我目前的项目中发挥作用。</p></div></div>    
</body>
</html>