<html>
<head>
<title>Node.js Tips — Testing Events, Env Variables, and Editing Mongoose Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—测试事件、环境变量和编辑 Mongoose 对象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-testing-events-env-variables-and-editing-mongoose-objects-c8aff25aebaf?source=collection_archive---------26-----------------------#2020-07-19">https://blog.devgenius.io/node-js-tips-testing-events-env-variables-and-editing-mongoose-objects-c8aff25aebaf?source=collection_archive---------26-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a0bd33c949cf90d42c315fe40ae6451e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AQ3xQF6PtS1ZjbOW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Andriyko Podilnyk 在 Unsplash 上的照片</figcaption></figure><p id="07da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="c803" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何将图像从 URL 加载到 Node.js 中的缓冲区</h1><p id="37fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以请求图像。</p><p id="a640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">Buffer.from</code>方法将其加载到一个缓冲区中。</p><p id="4556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c196" class="mq lc iq mh b gy mr ms l mt mu">const response = await axios.get(url,  { responseType: 'arraybuffer' })<br/>const buffer = Buffer.from(response.data, "utf-8")</span></pre><p id="8516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用 Axios HTTP 客户端发出一个 GET 请求。</p><p id="5bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们传入图像的 URL，并将响应的<code class="fe me mf mg mh b">responseType</code>设置为<code class="fe me mf mg mh b">'arraybuffer'</code>。</p><p id="f24d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">'utf-8'</code>编码将<code class="fe me mf mg mh b">response.data</code>传递给<code class="fe me mf mg mh b">Buffer.from</code>方法。</p><p id="e7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将数据保存到缓冲区。</p><h1 id="506d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 dotenv 加载环境变量</h1><p id="a43a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用 dotenv 库加载环境变量。</p><p id="5bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7d16" class="mq lc iq mh b gy mr ms l mt mu">const path = require('path')<br/>require('dotenv').config({ path: path.resolve(__dirname, '../.env') })</span></pre><p id="32ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要<code class="fe me mf mg mh b">dotenv</code>库。</p><p id="7e83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">config</code>方法来设置<code class="fe me mf mg mh b">.env</code>文件的路径。</p><p id="5f7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定从当前目录向上移动一级来找到<code class="fe me mf mg mh b">.env</code>文件。</p><h1 id="a546" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从 Node.js 中的文本文件同步读取行</h1><p id="5cc8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">readFileSync</code>方法同步读取一个文本文件。</p><p id="255d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，m 我们可以写成:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="029c" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const lines = fs.readFileSync(filename, 'utf-8')<br/>  .split('\n')<br/>  .filter(Boolean);</span></pre><p id="6d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">readFileSync</code>来读取文本文件的内容。</p><p id="6a3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">split</code>通过换行符拆分字符串。</p><p id="d001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">Boolean</code>调用<code class="fe me mf mg mh b">filter</code>来删除任何包含空字符串的行。</p><p id="67f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为空字符串是假的。</p><p id="6df8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">Boolean</code>会把它们转换成 false。</p><h1 id="2d58" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 Node.js 从 URL 解析文件名</h1><p id="41fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要从 URL 获取文件名，我们可以使用<code class="fe me mf mg mh b">url</code>和<code class="fe me mf mg mh b">path</code>模块。</p><p id="40c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2657" class="mq lc iq mh b gy mr ms l mt mu">const url = require("url");<br/>const path = require("path");<br/>const parsed = url.parse("http://example.com:8080/test/foo.txt/?q=100");<br/>console.log(path.basename(parsed.pathname));</span></pre><p id="ea2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">url.parse</code>将 URL 解析成各个部分。</p><p id="7518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">basename</code>来获取查询字符串之前的 URL 的最后一部分，也就是<code class="fe me mf mg mh b">'foo.txt'</code>。</p><h1 id="8237" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过节点提取发送 Cookies</h1><p id="b61a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过设置<code class="fe me mf mg mh b">cookie</code>头来发送带有节点获取的 cookies。</p><p id="c9f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="713c" class="mq lc iq mh b gy mr ms l mt mu">fetch('/some/url', {<br/>  headers: {<br/>    accept: '*/*',<br/>    cookie: 'accessToken=1234; userId=1234',<br/>  },<br/>  method: 'GET',<br/>});</span></pre><p id="21e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用库中的<code class="fe me mf mg mh b">fetch</code>函数。</p><p id="626b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">cookie 设置在第二个参数的<code class="fe me mf mg mh b">headers</code>属性中。</p><p id="ab71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">cookie</code>地产有饼干。</p><h1 id="cead" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向从 Mongoose 返回的对象添加属性</h1><p id="3d34" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想给从 Mongoose 中检索到的对象添加属性，我们可以使用<code class="fe me mf mg mh b">lean</code>方法，也可以对返回的文档调用<code class="fe me mf mg mh b">toObject</code>。</p><p id="9fc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9450" class="mq lc iq mh b gy mr ms l mt mu">Item.findById(id).lean().exec((err, doc) =&gt; {<br/>  //...<br/>});</span></pre><p id="b35c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以给<code class="fe me mf mg mh b">doc</code>添加属性，因为它是一个普通的对象。</p><p id="bd08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dd46" class="mq lc iq mh b gy mr ms l mt mu">Item.findById(id).exec((err, doc) =&gt; {<br/>  const obj = doc.toObject();<br/>  //...<br/>});</span></pre><p id="1c4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在回调中，我们调用<code class="fe me mf mg mh b">doc.toObject()</code>从文档中返回一个普通对象。</p><p id="4d73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们就可以随心所欲地操纵<code class="fe me mf mg mh b">obj</code>了。</p><h1 id="184f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何用 Sinon 测试 Node.js 事件发射器</h1><p id="8f00" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以利用西农的间谍来测试事件发射器。</p><p id="6cb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="26a4" class="mq lc iq mh b gy mr ms l mt mu">const sinon = require('sinon');<br/>const EventEmitter = require('events').EventEmitter;</span><span id="1483" class="mq lc iq mh b gy mv ms l mt mu">describe('EventEmitter', function() {<br/>  describe('#emit()', function() {<br/>    it('should invoke the callback', () =&gt; {<br/>      const spy = sinon.spy();<br/>      const emitter = new EventEmitter();<br/>      emitter.on('foo', spy);<br/>      emitter.emit('foo');<br/>      spy.called.should.equal.true;<br/>    })</span><span id="7bd9" class="mq lc iq mh b gy mv ms l mt mu">    it('should pass arguments to the callbacks', () =&gt; {<br/>      const spy = sinon.spy();<br/>      const emitter = new EventEmitter();<br/>      emitter.on('foo', spy);<br/>      emitter.emit('foo', 'bar', 'baz');<br/>      sinon.assert.calledOnce(spy);<br/>      sinon.assert.calledWith(spy, 'bar', 'baz');<br/>    })<br/>  })<br/>})</span></pre><p id="637b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">spy</code>作为事件处理函数传入。</p><p id="1a9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以检查<code class="fe me mf mg mh b">spy</code>是否被调用。</p><p id="b179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，则发出事件。</p><p id="5cba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则就不是了。</p><p id="c52e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">calledWith</code>来检查参数是否被<code class="fe me mf mg mh b">emit</code>调用。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/02123763334c3c1296c0296254d9e0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*15AhP0DNwvCnN8ru"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@arielacosta?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ariel Acosta </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f167" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3cfd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将图像作为数组缓冲区加载，然后保存到节点缓冲区。</p><p id="03ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dotenv 库可用于在节点应用程序中加载环境变量。</p><p id="5be0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想向从 Mongoose 检索的文档添加属性，我们可以使用<code class="fe me mf mg mh b">lean</code>或调用<code class="fe me mf mg mh b">toObject</code>方法。</p><p id="ef7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们甚至可以用间谍测试发射器事件。</p></div></div>    
</body>
</html>