<html>
<head>
<title>You should be aware of this if you are still using Stack Class in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果您仍然在 Java 中使用 Stack 类，您应该意识到这一点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/you-should-be-aware-of-this-if-you-are-still-using-stack-class-in-java-87716280b788?source=collection_archive---------8-----------------------#2022-06-25">https://blog.devgenius.io/you-should-be-aware-of-this-if-you-are-still-using-stack-class-in-java-87716280b788?source=collection_archive---------8-----------------------#2022-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0d86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">栈是一种非常常见和有用的数据结构，在处理许多问题时非常方便。</p><p id="4f30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将讨论在 Java 中使用 Stack 类的利与弊，并探索是否有任何替代方法来克服 Stack 类的缺点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c6180fcb8ef38c1e563014d390005da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J-SOOxE84A2K15xo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">布鲁克·拉克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="492d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">首先让我们复习一下什么是栈？</h1><p id="8550" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在计算机科学中，栈是一种抽象的数据类型，作为元素的集合。它支持两种主要操作:<strong class="jm io">推</strong>和<strong class="jm io">弹出</strong>。<strong class="jm io">推送</strong>是指在顶部添加一个元素，而<strong class="jm io">弹出</strong>是指从顶部移除一个元素。</p><p id="5543" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种从顶部添加和删除元素的原则也被称为<strong class="jm io"> LIFO(后进先出)</strong></p><h1 id="0871" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">首先，让我们来看看堆栈类的缺点</h1><h2 id="6bbd" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">1.Stack 是一个类，而不是像任何其他通用数据结构那样的接口</h2><blockquote class="mo mp mq"><p id="489b" class="jk jl mr jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">接口数据结构好处是一个类可以实现多个接口，但不能继承多个类。</p></blockquote><p id="e3e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果你想建立一个自定义的堆栈类，如果你已经扩展了一些父类，那么你不能扩展堆栈类。</p><p id="cab8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，从面向对象设计的角度来看，接口数据结构提供了更多的灵活性。</p><h2 id="de08" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">2.堆栈类扩展了向量类</h2><p id="80f7" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">是的，我也很震惊。</p><p id="6f82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理想情况下，堆栈类应该只支持像 push()、pop()、peek()和 empty()这样的操作。但是由于 Stack 是<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Vector </strong> </a>的子类，它也有能力<strong class="jm io">访问</strong>，<strong class="jm io">插入</strong>，<strong class="jm io">移除</strong>一个元素的索引。(你可以在这里查看它支持的所有方法<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html" rel="noopener ugc nofollow" target="_blank">)</a></p><p id="7dac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这基本上打破了后进先出的定义。</p><p id="f7e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这个代码块工作正常。它打印出 12 张。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5af0" class="mc la in mw b gy na nb l nc nd">import java.util.Stack;</span><span id="c8e9" class="mc la in mw b gy ne nb l nc nd">public class StackDemo {<br/>    public static void main(String[] args) {<br/>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><span id="68a4" class="mc la in mw b gy ne nb l nc nd">        stack.add(0, 10);<br/>        stack.push(12);</span><span id="0c16" class="mc la in mw b gy ne nb l nc nd">        System.out.println(stack.get(1));<br/>    }<br/>}</span></pre><h2 id="d028" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">3.现在，让我们来谈谈迭代</h2><p id="72f7" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">回想一下，在本文的开始，我们讨论了堆栈数据结构遵循 LIFO 原则(这意味着后进先出)。</p><p id="c4af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们正在迭代堆栈对象，我们会期望它是从顶部<strong class="jm io">到底部</strong>(就像一个堆叠板的权利)，但它不是。</p><p id="40df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过一个例子来理解这一点。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="23ca" class="mc la in mw b gy na nb l nc nd">import java.util.Stack;</span><span id="dbea" class="mc la in mw b gy ne nb l nc nd">public class StackDemo {<br/>    public static void main(String[] args) {<br/>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><span id="9d19" class="mc la in mw b gy ne nb l nc nd">        stack.push(1);<br/>        stack.push(2);<br/>        stack.push(3);</span><span id="3d60" class="mc la in mw b gy ne nb l nc nd">        for (int item: stack) {<br/>            System.out.println(item);<br/>        }<br/>    }<br/>}</span></pre><p id="4e9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个代码块的输出是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b910555015586629956d91d3043aa46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:212/format:webp/1*guZJUPyYcGPrAoa3t0NQYQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">上述代码块的输出。</figcaption></figure><p id="b78f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是根据后进先出原则，应该是 3，2，1 对。</p><h1 id="8ed1" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">怎样才能克服这些缺点？</h1><p id="6b5f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">有一个叫做<strong class="jm io"> Deque </strong>的接口可以克服上面提到的大部分缺点。让我们详细地看一下例子。</p><h2 id="8aca" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">1.首先，它是一个接口</h2><p id="63df" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">dequee 是一个接口，所以我们可以灵活地创建自定义堆栈类，它可以<strong class="jm io">继承</strong>其他类，<strong class="jm io">实现</strong>其他接口，在此基础上<strong class="jm io">也可以实现 dequee 接口</strong>。</p><h2 id="0992" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">2.不允许通过索引访问、插入和删除元素</h2><p id="a4e1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Deque 不允许通过索引来访问、插入和删除元素。但是由于它是一个<strong class="jm io">双端队列</strong>，它支持从两端插入和移除。</p><p id="501d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以即使 Deque 不遵循 LIFO 原则，但它显然比 Stack 类好，Stack 类允许基于索引的插入/移除。</p><h2 id="3848" class="mc la in bd lb md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">3.在迭代中遵循后进先出顺序</h2><p id="1559" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当我们迭代一个 Deque 实例时，它从顶部<strong class="jm io">到底部</strong>迭代，正如从堆栈数据结构中所期望的。</p><p id="0b13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过一个例子来理解这一点。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6fec" class="mc la in mw b gy na nb l nc nd">import java.util.ArrayDeque;<br/>import java.util.Deque;</span><span id="75a1" class="mc la in mw b gy ne nb l nc nd">public class StackDemo {<br/>    public static void main(String[] args) {<br/>        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><span id="476a" class="mc la in mw b gy ne nb l nc nd">        stack.push(1);<br/>        stack.push(2);<br/>        stack.push(3);</span><span id="7a70" class="mc la in mw b gy ne nb l nc nd">        for (int item: stack) {<br/>            System.out.println(item);<br/>        }<br/>    }<br/>}</span></pre><p id="da24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个代码块的输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8e4749c52f85b3ab38b1d7117b1982cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*BVraNKRoicupxFwDtzrUPg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">上述代码块的输出</figcaption></figure><p id="cc92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所见，它从上到下。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="813c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">总的来说，我们可以看到，使用 Deque 来实现堆栈数据结构更有意义。</strong></p><p id="40a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是有一个警告。让我们谈谈那个。</p><h1 id="907d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">多线程</h1><p id="ca44" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">由于堆栈类是 Vector 的子类，而 Vector 类是同步的<strong class="jm io">因此甚至堆栈类也是同步的。</strong></p><p id="798c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，Deque 接口不是线程安全的。</p><p id="feed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果线程安全是一个问题，我们应该坚持使用堆栈类，因为它仍然有一些我们现在知道的警告。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="fb71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我强烈建议您阅读上述主题的 Java 文档。</p><ol class=""><li id="2212" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/stack . html</a></li><li id="4ec0" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/vector . html</a></li><li id="f619" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/deque . html</a></li><li id="41ca" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/array deque . html</a></li></ol></div></div>    
</body>
</html>