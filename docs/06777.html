<html>
<head>
<title>Part #2: How to read WASM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分:如何阅读 WASM</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/part-2-how-to-read-wasm-1f7e34e70f59?source=collection_archive---------10-----------------------#2022-02-02">https://blog.devgenius.io/part-2-how-to-read-wasm-1f7e34e70f59?source=collection_archive---------10-----------------------#2022-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6408" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">也许还能写出来。</h2></div><p id="fb34" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我本系列的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/part-1-how-to-read-wasm-b29de01d39e7">上一篇文章</a>中，我们简要地查看了<a class="ae ky" href="https://webassembly.github.io/spec/core/binary/index.html" rel="noopener ugc nofollow" target="_blank"> WebAssembly 的二进制格式</a>的逐字节分解。有了这些知识，让我们看看 WebAssembly 的文本格式。这将被捕获到一个扩展名为. wat 的可读文件中。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/ea90a2255a5a4bb9c6fbbf3269fb00e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbpKZdP-lElmjo4XNBNg-Q.jpeg"/></div></div></figure><h1 id="ab89" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><strong class="ak">模块</strong></h1><p id="a7e7" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">与二进制格式一样，文本格式的基本(也是最简单的)单元也是一个模块。一个空的(并且非常有效)。wat 文件如下所示。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mi"><img src="../Images/bfebbd4798e106710e24e5631e9f9565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VF_68QWY5fAKvJI0sV6E7A.png"/></div></div></figure><p id="8e1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这并没有做很多事情…除了声明一个模块。</p><p id="f107" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是……从上一篇文章中我们已经知道，WebAssembly 模块是一个很大的 S 表达式。概括地说，S 表达式基本上是一种将数据表示为嵌套树的方法。事实上，上面的模块声明只是一个独立的根。随着程序复杂性的增加，会添加各种带有属性的子节点，有效地将所有函数(和数据)分组到根节点下。</p><p id="0589" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面提供了我刚才提到的内容的图片描述。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/5654cd174a522b097155ef389c5fd90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*hQURpaSCUKWtbP5wmim6ZA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">信用:<a class="ae ky" href="https://en.wikipedia.org/wiki/S-expression" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/S-expression</a></figcaption></figure><p id="fb5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这给我们带来了一个问题，</p><blockquote class="mo"><p id="5430" class="mp mq in bd mr ms mt mu mv mw mx kx dk translated">WebAssembly 中的函数是什么样的？</p></blockquote><p id="f4f0" class="pw-post-body-paragraph kc kd in ke b kf my jo kh ki mz jr kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">答案是，</p><p id="9e02" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b"><strong class="ke io">( func &lt;signature&gt; &lt;locals&gt; &lt;body&gt; )</strong></code></p><p id="b223" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然是写成 S 表达式，我敢肯定第一眼看上去很异类。然而，在分解上面的伪代码结构时，我们<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format" rel="noopener ugc nofollow" target="_blank">看到</a></p><ol class=""><li id="c50b" class="nh ni in ke b kf kg ki kj kl nj kp nk kt nl kx nm nn no np bi translated">签名对应于函数作为输入和作为值返回的内容</li><li id="b7f4" class="nh ni in ke b kf nq ki nr kl ns kp nt kt nu kx nm nn no np bi translated">局部变量类似于 JavaScript 变量，但是声明了显式的类型</li><li id="fd94" class="nh ni in ke b kf nq ki nr kl ns kp nt kt nu kx nm nn no np bi translated">主体由低级指令列表组成</li></ol><p id="fa2b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在我们写第一个函数体之前。瓦特，我们需要谈谈一件小事:堆垛机。</p><h1 id="ef66" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">堆垛机</h1><p id="faee" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果你访问<a class="ae ky" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank">webassembly.org</a>(或者甚至是<a class="ae ky" href="https://en.wikipedia.org/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank">维基百科关于 WebAssembly </a>的页面)，你注意到的第一件事就是提到了基于堆栈的虚拟机。在基于堆栈的虚拟机中，值从&amp;弹出，结果被推入堆栈。它的对应物是一个基于寄存器的机器，其中指定了特定的区域来存储值。</p><p id="b6d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么这对我们的讨论很重要？WASM 执行是以堆栈机器的形式定义的。这意味着当一个 WASM 函数被调用时，你从一个空栈开始，这个空栈逐渐被填满&amp;随着主体部分中指令的执行而变空。</p><p id="b6a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有呢？<a class="ae ky" href="https://webassembly.github.io/spec/core/valid/index.html" rel="noopener ugc nofollow" target="_blank"> WebAssembly 验证规则</a>确保了如果我们定义了一个特定类型的返回值，比如 i32，那么堆栈最后必须与该类型完全匹配。如果没有返回类型，堆栈必须为空。</p><p id="b18b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，让我们继续编写我们的第一个 WASM 程序吧！</p><h1 id="db50" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">我们的第一个 WASM 项目</h1><p id="9109" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在前一篇文章中，我们看了一个返回数字 42 的程序(同时也是我们的 Hello，World)。接下来是一个稍微复杂(但仍然非常基本)的程序，我们将两个数相加并返回一个结果。</p><pre class="la lb lc ld gt nv ng nw nx aw ny bi"><span id="5819" class="nz lm in ng b gy oa ob l oc od"><strong class="ng io">(module<br/>  (func (export "add_basic")(param $num1 i32) (param $num2 i32) (res i32)<br/>    local.get $num1<br/>    local.get $num2<br/>    i32.add))</strong></span></pre><p id="f38f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于有效指令代码的完整列表，您可以查看 WebAssembly 的<a class="ae ky" href="https://webassembly.github.io/spec/core/exec/index.html" rel="noopener ugc nofollow" target="_blank">语义词汇表。</a></p><h1 id="316e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">下一步是什么？</h1><p id="dc68" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">既然我们已经学会了如何编写一个基本的？wat 程序，在下一部分中，我们将看看 WebAssembly 中的内存管理。对于精通使用像<a class="ae ky" href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>这样的内存管理技术的语言的开发人员来说，这是一个经常令人困惑的方面，我们将探索各种场景&amp;尝试理解其内部机制。</p><p id="0242" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要了解我最新的科技恶作剧，请关注我的推特<a class="ae ky" href="https://twitter.com/Divya_Mohan02" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="oe"/></strong></a><strong class="ke io"><em class="oe"/></strong><em class="oe">和</em><a class="ae ky" href="https://www.linkedin.com/in/divya-mohan0209/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="oe">LinkedIn</em></strong></a><em class="oe">。我还写每周简讯，</em><strong class="ke io"><em class="oe"/></strong><a class="ae ky" href="https://www.getrevue.co/profile/divyamohan" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="oe">周五四</em> </strong> </a> <em class="oe">，在那里我把科技世界里发生的所有有趣的事情都作为一个亮点滔滔不绝地报道出来。如果你觉得这是你的拿手好戏，请考虑订阅</em></p></div></div>    
</body>
</html>