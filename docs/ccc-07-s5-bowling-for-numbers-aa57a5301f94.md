# CCC '07 S5 —数字保龄球

> 原文：<https://blog.devgenius.io/ccc-07-s5-bowling-for-numbers-aa57a5301f94?source=collection_archive---------11----------------------->

今天，我在准备今年二月的 CCC 考试时遇到了这个问题。对我来说，这显然是一个动态规划问题。基本上，给定宽度、保龄球数量和瓶数，你必须找出如何最大化击倒瓶的价值。在他们的样本输入中，宽度为 3，有 2 个保龄球和 9 个球瓶。下面是它们的样子:

```
2, 8, 5, 1, 9, 6, 9, 3, 2
```

在这个示例中，很明显，给定两个可以击倒 3 个瓶的保龄球，您可以通过击倒第二个瓶(8)来最大化您的得分，这导致您得到 15 分(8+2+5)。接下来，你可以击倒第六个球瓶(6)，这样你的分数就是 24 (9+6+9)。现在让我们开始编写解决方案。

首先，我们得到了一些测试用例。然后，对于每个测试案例，我们给出 3 个数字，n，k，w，其中 n 是保龄球瓶的数量，k 是保龄球的数量，w 是一个保龄球可以打翻的瓶的数量。下面是获得所有这些输入的 c++代码:

我们现在有了一个包含所有大头针的向量。我在数组开头附加一个零的原因可以用一个反问句来回答:当你击倒第一个球瓶时会发生什么？

下一步将采用动态编程方法。我们要做一个 2D 数组，包含我们可以击倒的瓶子的数量。这个数组的大小是 n*k。基本上，我们要遍历所有的保龄球。然后，我们将开始记录击倒“w”保龄球瓶所能获得的分数。然后，我们要将 2D 数组中的当前位置设置为我们可以获得的最大分数，它可以是:我们可以获得的当前分数+少一个球和落后 w 个球的分数，或者是以前的分数。让我解释一下。

当你有一个保龄球，瓶的排列如下:0，2，8，5，1，9，6，9，3，2，0，很明显你可以得到最高 24 分。你可以通过循环数组找到答案。当你小于每个保龄球瓶+1 的宽度时，你只需要增加你的 sum 变量，否则如果你大于宽度，你要做的是减去当前的-w 瓶，然后加上当前的瓶。让我解释一下。当您在以下数组中循环时，其中每个保龄球的宽度为 3，并且您有一个保龄球，每个位置将为您提供以下分数:

(0+2)、(0+2+8)、(2+8+5)、(8+5+1)、(5+1+9)、(1+9+6)、(9+6+9)、(6+9+3)、(9+3+2)、(3+2+0)或:

2, 10, 15, 14, 15, 16, 24, 18, 14, 5.

0, 2, 10, 15, 15, 15, 16, 24, 24, 24.

现在我们需要弄清楚当我们加入第二个保龄球时会发生什么。像 DP 数组中的前一行一样，对于前 w 个元素，我们只能取当前的分数。这是因为我们还没有找到足够的空间来扔第二个球。然而，一旦我们达到 w+1，我们可以要么采取以前的分数(一个球的最大值)，要么我们可以添加一个球，然后添加当前分数+从 w+1 个球之前获得的分数。让我们开始填充 DP 数组。这是我们目前第一行的内容。

```
[0, 2, 10, 15, 15, 15, 16, 24, 24, 24]
```

那么下一行中的下一个 w+1 元素将是相同的(因为我们还没有足够的空间来放置第二个球)

```
[0, 2, 10, 15, 15, 15, 16, 24, 24, 24],
[0, 2, 10, 15 .....]
```

现在我们有了足够的空间(球瓶之间的距离),我们可以选择投第二个球。这意味着在这个位置，我们可以选择在第一个球瓶(给我们 2 分)和第四个球瓶(给我们 14 分)投掷第一个球，总得分为 16 分，或者我们可以选择投掷一个球，最高得分为 15 分。由于 14+2 > 15，DP[1][4] = 16。使用 DP[i][j] = max(DP[i-1][j-w]+cur，DP[i][j-1])的概念，我们可以填充数组的其余部分，如下所示:

```
[0, 2, 10, 15, 15, 15, 16, 24, 24, 24],
[0, 2, 10, 15, 16, 25, 31, 39, 39, 39]
```

然后我们只想取在 DP[k][N]处呈现给我们的数字，或者数组末尾最多保龄球的位置。以下是完整的代码:

如果有帮助的话，留个赞。