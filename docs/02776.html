<html>
<head>
<title>Understanding React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解反应</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-react-469e1ac3127d?source=collection_archive---------4-----------------------#2020-08-29">https://blog.devgenius.io/understanding-react-469e1ac3127d?source=collection_archive---------4-----------------------#2020-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0111" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">请阅读这篇简明扼要的文章，它将引导您了解React Js的最基本和最重要的概念</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/84f9bf8cb2d9cecd4a3a306058594662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-25Fn6F9JcM9_7YrfvBlOQ.png"/></div></div></figure><h1 id="1d3e" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">从背景细节开始</h1><p id="4ba8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React是一个JavaScript库，旨在简化可视化界面的开发。它由脸书开发，于2013年向全世界发布，驱动着世界上一些最广泛使用的代码，为许多软件公司提供支持。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="331a" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated">一个巨大的误解</h1><p id="c3a4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io"> React是一个JavaScript“库”</strong>。它不完全是一个“框架”。这并不是一个完整的解决方案，你经常需要使用更多的库来形成任何解决方案。React不对任何解决方案中的其他部分做任何假设。</p><p id="975a" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">框架服务于一个伟大的目的，特别是对于年轻的团队和创业公司。当使用一个框架时，许多聪明的设计决策已经为您做出，这为您提供了一条清晰的道路来专注于编写好的应用程序级逻辑。然而，框架也有一些缺点。对于在大型代码库上工作的有经验的开发人员来说，这些缺点有时是一个障碍。</p><p id="7e51" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">框架并不灵活，尽管有些人声称是灵活的。一个框架通常希望你用一种特定的方式来编码所有的东西。如果你试图偏离这种方式，框架通常会反对你这样做。框架通常也很大，功能丰富。如果您只需要使用其中的一小部分，无论如何您都必须包含整个内容。诚然，这一点今天正在改变，但仍不理想。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="d4af" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated">让我们从基础开始</h1><h1 id="6a8f" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">片段</strong></h1><p id="47c7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">对于<strong class="li io"> VS Code </strong>用户，这里有一些有用的片段:</p><p id="f60d" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">扩展名</strong>:<em class="mt">ES7 React/Redux/graph QL/React-Native片段</em></p><ul class=""><li id="d4bc" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">rce -&gt;创建基于类的组件</li><li id="ac86" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">rfce -&gt;创建功能组件</li><li id="a912" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">rconst -&gt;为类创建构造函数</li></ul><blockquote class="ni nj nk"><p id="5518" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated">还有很多其他的扩展，这是最常用的一个。</p></blockquote><h1 id="1f0a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">生命周期方法</strong></h1><h2 id="37de" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">增加</h2><p id="52e2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当组件的实例被创建或插入到DOM中时</p><ul class=""><li id="863d" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">构造器</li><li id="e959" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">静态getDerivedStateFromProps</li><li id="c93d" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">提供；给予</li><li id="4f34" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">组件安装</li></ul><h2 id="26ca" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">升级</h2><p id="83d4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当一个组件由于其属性或状态的改变而被重新渲染时。</p><ul class=""><li id="1fbe" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">静态shouldComponentUpdate</li><li id="c244" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">shouldComponentMount</li><li id="a287" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">提供；给予</li><li id="31a6" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">getSnapBeforeUpdate</li><li id="9d8c" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">componentDidUpdate</li></ul><h2 id="85f5" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">卸载</h2><p id="cb46" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当组件从DOM中移除时</p><ul class=""><li id="39c1" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">组件将卸载</li></ul><h2 id="1de5" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">错误处理</h2><p id="81af" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当渲染期间、生命周期方法中或子组件的构造函数中出现错误时</p><ul class=""><li id="13b9" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">静态getDerivedStateFromError</li><li id="e26c" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">componentDidCatch</li></ul><h1 id="d03e" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">碎片</em></h1><p id="8bd8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React中的一个常见模式是一个组件返回多个元素。片段允许您对一个子列表进行分组，而无需向DO添加额外的节点</p><h1 id="135d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">纯组分</em></h1><p id="5db4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">纯组件只在道具和状态比较浅的情况下重新渲染类组件。这导致了性能的提高。它只适用于基于类的组件。</p><h1 id="de33" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">备忘录</em></h1><p id="a805" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">它是高阶分量。纯组件之于基于类的组件，备忘录之于功能组件</p><h1 id="0bb1" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">参考文献</em></h1><p id="5e18" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Refs使得在React中访问DOM节点成为可能。有两种有效的方法:-</p><ul class=""><li id="21b7" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">React.createRef()方法</li><li id="6170" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">回调方法。</li></ul><p id="b788" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">Refs可以与函数组件和类组件一起使用。引用也可以从父组件传递到子组件。</p><p id="c417" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">转发引用</strong>:引用也可以使用<strong class="li io">forward Ref(<em class="mt">native component</em>，<em class="mt"> ref </em> ) </strong>方法从父组件转发到本地输入组件。基本上，子组件从父组件接收ref，并将其附加到本地输入元素。</p><h1 id="c6e9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">门户网站</em></h1><p id="faab" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><em class="mt"> React门户提供了一种将子组件呈现到DOM节点的方法，该节点存在于父组件的Dom层次结构之外</em>。它提供了打破DOM树的能力。它使用一个函数<strong class="li io"><em class="mt">react DOM . create portal(JSX，id)。门户</em> </strong>表现得像个做出反应的孩子。我们需要门户来处理父子CSS</p><h1 id="335d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">误差边界</em></h1><p id="610d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><em class="mt">错误边界是React组件，它捕捉子组件树中的JavaScript错误，记录这些错误，并显示回退UI </em>实现生命周期方法<em class="mt">getderivedstatefromrerror</em>和<em class="mt"> componentDidCatch </em>之一或两者的类组件成为错误边界。</p><p id="35de" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">getderivedstatefromrerror:这是一个静态方法，用于在抛出错误后呈现回退UI。<br/> <strong class="li io"> componentDidCatch </strong>:这是一个用来记录错误信息的方法。</p><p id="74d2" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">错误边界在生命周期方法和它们下面的整个树的构造函数中的呈现期间捕捉错误，但是，它们不捕捉事件处理程序内部的错误</p><h1 id="420a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">高阶组件—特设</em></h1><p id="8045" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><em class="mt">一种模式，其中函数将组件作为参数，并返回新的增强组件</em>。它共享组件中的公共属性，而不必重复代码。</p><p id="b4c6" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">const new component = higherOrderComponent(original component)<br/>非技术示例:const iron man = with suit(TonyStark)</strong></p><p id="acf5" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">这是一个很好的小模式，可以用来在React组件之间共享公共功能。</p><h1 id="1828" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">渲染道具</em></h1><p id="22c7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">术语“渲染道具”指的是一种使用<strong class="li io">道具(其值为函数</strong>)在React组件之间共享代码的技术。</p><h1 id="d6a3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><em class="oa">反应上下文</em></h1><p id="63a0" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">上下文提供了一种通过组件树传递数据的方法，而不必在每个级别手动向下传递支柱。<br/>主要包括三个步骤:</p><ul class=""><li id="0b92" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated"><strong class="li io">创建上下文</strong> —使用createContext()方法，并导出提供程序和使用者组件。</li><li id="17f7" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated"><strong class="li io">提供上下文值</strong> —在顶级，包括提供者组件并使用值属性传递该值。</li><li id="50cf" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated"><strong class="li io">使用上下文值</strong> —使用消费者组件并作为子代传递函数</li></ul></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="8ff1" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated">一头扎进胡克斯</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/60d547d355419db662741fc37368e407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3d0jsQppieVP5XL6KGK6YA.png"/></div></div></figure><p id="5783" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io"> <em class="mt"> Hooks是React 16.8中的一个新特性，它允许您使用reactor特性，而不必编写类</em> </strong> <em class="mt">。从概念上讲，React组件始终更接近函数。Hooks支持函数，但不牺牲reactor的实用精神。Hooks提供了对命令式退出孵化的访问，并且不需要您学习复杂的函数式或反应式编程技术。</em></p><h1 id="bcd5" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">为什么是Hooks？</h1><p id="01a4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io">问题-1 </strong></p><ul class=""><li id="b116" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">了解<strong class="li io"> <em class="mt">这个</em> </strong>关键字在JavaScript中是如何工作的</li><li id="1e8e" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">请记住在Components类中绑定事件处理程序</li><li id="d658" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">类不能很好地缩小，使得热重载非常不可靠。</li></ul><p id="7c6f" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">问题-2 </strong></p><ul class=""><li id="36ef" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">没有特定的方法来重用有状态compomnent Logic</li><li id="a3c3" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">HOC和render prop模式确实解决了这个问题，但它使代码更难遵循。</li><li id="41be" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">有必要以更好的方式共享状态逻辑</li></ul><p id="2391" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">问题-3 </strong></p><ul class=""><li id="e2af" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated">为复杂场景创建组件时，相关代码不会组织在一个地方</li></ul></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="1477" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated"><strong class="ak">挂钩规则</strong></h1><blockquote class="ni nj nk"><p id="ba36" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated">处理挂钩时要记住的几点</p></blockquote><ul class=""><li id="b887" class="mu mv in li b lj mo lm mp lp mw lt mx lx my mb mz na nb nc bi translated"><strong class="li io">只调用顶层的挂钩</strong>。不要在循环、条件或嵌套函数内部调用挂钩。</li><li id="94a9" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated"><strong class="li io">仅从React函数</strong>调用挂钩。不要在任何常规的JavaScript函数内部调用挂钩。</li></ul><h1 id="0ae8" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">挂钩类型</h1><h2 id="f616" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">1 — useState</h2><ul class=""><li id="5d44" class="mu mv in li b lj lk lm ln lp oc lt od lx oe mb mz na nb nc bi translated">使用状态挂钩可以在功能组件中添加状态</li><li id="e3bc" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">在类中，状态始终是对象</li><li id="6f0d" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">使用useState挂钩，状态不必是对象</li><li id="b4da" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated">新状态取决于以前的状态值</li></ul><h2 id="9f3a" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _ useEffect</h2><p id="de92" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">“效果挂钩”允许您在“功能组件”中执行副作用</p><p id="dc3e" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">它是<strong class="li io"> <em class="mt">组件安装</em></strong><strong class="li io"><em class="mt">组件更新</em> </strong>和<strong class="li io"> <em class="mt">组件将卸载</em> </strong>的紧密替代品</p><h2 id="2e24" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _ useContext</h2><p id="33ec" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">上下文提供了一种通过组件树传递数据的方法，而不必在每个级别手动向下传递支柱</p><h2 id="a2dc" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _ useReducer</h2><p id="682b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这是一个用于国家管理的挂钩。这是useState的一个替代项。这是一个比useState更原始的挂钩。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7eefdbb7e0409e4a82d35ec8ec462360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*3WQWUMCxYPrxGO4zL75J0A.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/4b7f3840e3a91d321f8ab95d6165aa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFnDQVQfJ5pMCX_ytCsC2w.png"/></div></div></figure><h2 id="718d" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _ useCallback</h2><p id="1889" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Is是一个挂钩，它将返回回调函数的记忆版本，该版本仅在依赖项之一发生更改时发生更改。</p><p id="66c0" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">当传递回调来优化依赖引用相等的子组件以防止不必要的重新呈现时，这很有用。</p><p id="98bf" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><em class="mt"> {引用相等检查函数是否相等。} </em></p><h2 id="df74" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _使用备忘录</h2><p id="5cbe" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">您可以依赖useMemo作为性能优化，而不是作为语义保证。将来，React可能会选择“忘记”一些先前存储的值，并在下次渲染时重新计算它们，例如，为屏幕外组件释放内存。</p><blockquote class="ni nj nk"><p id="3c9a" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated">【useCallback和useMemo的区别</p></blockquote><p id="ca36" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><em class="mt"> useCallback缓存提供的函数实例本身，而useMemo调用提供的函数并捕捉其结果。因此，如果你需要缓存一个函数，使用useCallback钩子；如果你需要缓存一个函数的结果，使用useMemo钩子。</em></p><h2 id="a26b" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">&gt; _ useRef</h2><p id="df78" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">通常用于聚焦输入字段。总的来说，它可以用来创建一个通用容器，该容器可以保存一个类似于类组件的实例属性的可变值。<br/>该通用容器在其存储的数据改变时不会导致重新呈现。<br/>同时，在其他状态变量导致该组件重新呈现后，它还会记住存储的数据。</p><h2 id="20c4" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated"><em class="oa">以上挂钩在大多数情况下都会用到，除此之外还有三个挂钩:- </em></h2><ul class=""><li id="20d5" class="mu mv in li b lj lk lm ln lp oc lt od lx oe mb mz na nb nc bi translated"><strong class="li io"> <em class="mt">使用ImperitiveHandle </em> </strong></li><li id="b28c" class="mu mv in li b lj nd lm ne lp nf lt ng lx nh mb mz na nb nc bi translated"><strong class="li io">T17】useLayoutEffectT19】</strong></li></ul><blockquote class="ni nj nk"><p id="8aa2" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated"><strong class="li io"><em class="in">useDebugValue</em></strong></p></blockquote></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="f3a3" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated">额外主题—数据提取</h1><p id="c438" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Axios是一个基于HTTP服务的轻量级HTTP客户端，类似于本地JavaScript Fetch API。Axios是基于承诺的，这使您能够利用JavaScript的异步并等待更可读的异步代码。</p><pre class="kd ke kf kg gt oh oi oj ok aw ol bi"><span id="fee2" class="no kp in oi b gy om on l oo op">npm install axios</span></pre><p id="6acf" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">使用Axios和useEffect在React中获取数据</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="59df" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated"><strong class="li io">使用Axios和useReducer在React中获取数据</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="a717" class="ko kp in bd kq kr mj kt ku kv mk kx ky jt ml ju la jw mm jx lc jz mn ka le lf bi translated">结论</h1><p id="b57e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">本文应该已经很好地向您介绍了React Js的关键概念。还有很多需要学习和改进的地方，但是我希望你现在能够自信地钻研和使用react yourself。</p><p id="76fe" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">如果你在某个时候感到困惑，需要一个路线图来学习React，那么你可以参考下面提到的文章。</p><div class="os ot gp gr ou ov"><a href="https://codeburst.io/a-practical-road-map-for-react-development-aad87afdd5d0" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd io gy z fp pa fr fs pb fu fw im bi translated">React开发的实用路线图</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">在这篇简短扼要的文章中，我将指导你完成学习反应和成为…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">codeburst.io</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj km ov"/></div></div></a></div><p id="1592" class="pw-post-body-paragraph lg lh in li b lj mo jo ll lm mp jr lo lp mq lr ls lt mr lv lw lx ms lz ma mb ig bi translated">如果还有什么不清楚的地方，或者您希望在本文或后续文章中看到什么，请告诉我。如果你想讨论什么，请随时联系我。如果您能发送您的反馈和建议，我将非常高兴。</p><blockquote class="ni nj nk"><p id="49fd" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated">非常感谢你一直读到最后。如果您需要任何帮助，可以联系我:</p><p id="026c" class="lg lh mt li b lj mo jo ll lm mp jr lo nl mq lr ls nm mr lv lw nn ms lz ma mb ig bi translated">web:<a class="ae pk" href="https://portfolio.abhisheksrivastava.me/" rel="noopener ugc nofollow" target="_blank">https://portfolio.abhisheksrivastava.me/</a><br/>insta gram:<a class="ae pk" href="https://www.instagram.com/theprogrammedenthusiast/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/theprogrammedenthusiast/</a><br/>LinkedIn:<a class="ae pk" href="https://www.linkedin.com/in/abhishek-srivastava-49482a190/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/abhishek-srivastava-49482a190/</a><br/>Github:<a class="ae pk" href="https://github.com/abhishek2x" rel="noopener ugc nofollow" target="_blank">https://github.com/abhishek2x</a><br/>邮箱:abhisheksrivastavabbn@gmail.com</p></blockquote><div class="os ot gp gr ou ov"><a href="https://github.com/abhishek2x" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd io gy z fp pa fr fs pb fu fw im bi translated">abhishek2x -概述</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">关于ME I我天生就是一个企业家，也是一个充满激情的开发者，一个技术爱好者，开源贡献者，技术…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj km ov"/></div></div></a></div></div></div>    
</body>
</html>