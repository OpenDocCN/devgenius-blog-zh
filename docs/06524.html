<html>
<head>
<title>Kubernetes — Deploying A Docker Image To A Local Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes —将Docker映像部署到本地集群</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kubernetes-deploying-a-docker-image-to-a-local-cluster-31b46934cd71?source=collection_archive---------4-----------------------#2022-01-14">https://blog.devgenius.io/kubernetes-deploying-a-docker-image-to-a-local-cluster-31b46934cd71?source=collection_archive---------4-----------------------#2022-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4ef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我想向您展示如何从您的计算机直接将<strong class="jm io"><em class="ki"/></strong><strong class="jm io"><em class="ki">docker镜像</em> </strong>部署到<strong class="jm io"> <em class="ki">本地Kubernetes集群</em> </strong>。这将极大地增加你的编码信心。所以抓住你喜欢的零食，保持节奏！</p><h2 id="edb5" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">设置环境</h2><p id="144d" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">我们需要<a class="ae lh" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">Docker</em></strong></a><strong class="jm io"><em class="ki"/></strong>将我们的应用程序打包到一个容器中，并在K8s集群上运行。</p><p id="be56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要开始设置本地K8s集群，我们可以使用<a class="ae lh" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">Minikube</em></strong></a>，这是一个轻量级K8s实现，它在我们的本地机器上创建一个VM，并部署一个只包含一个节点的简单集群。</p><p id="e901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Minikube是你工具包中的一个很好的工具。它适用于所有操作系统，Minikube CLI提供基本的有用操作，包括启动、停止、删除集群或检查状态。</p><p id="4a6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装Docker和Minikube之后，您就可以开始了。</p><h2 id="3cad" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">设置本地集群</h2><p id="821a" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">让我们进入正题，用下面的命令启动<strong class="jm io"> <em class="ki"> 2个节点</em> </strong>:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a2d4" class="kj kk in ln b gy lr ls l lt lu">minikube start --nodes=2</span></pre><p id="e7f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这需要一些时间。你会看到它<strong class="jm io"> <em class="ki">拉一个基础镜像</em> </strong>并配置其他操作。以下内容将作为成功消息显示在末尾:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="b9d9" class="kj kk in ln b gy lr ls l lt lu">Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></pre><p id="5fac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用以下命令检查<strong class="jm io"> <em class="ki"> minikube状态</em> </strong>:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="afa4" class="kj kk in ln b gy lr ls l lt lu">minikube status</span></pre><p id="96bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们会看到这样的情况:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5174" class="kj kk in ln b gy lr ls l lt lu">minikube<br/>type: Control Plane<br/>host: Running<br/>kubelet: Running<br/>apiserver: Running<br/>kubeconfig: Configured</span><span id="a3eb" class="kj kk in ln b gy lv ls l lt lu">minikube-m02<br/>type: Worker<br/>host: Running<br/>kubelet: Running</span></pre><p id="91be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个，minikube，是<em class="ki">控制平面</em> — <strong class="jm io"> <em class="ki">主节点</em> </strong>，它支持主机、kubelet API和Kube配置。第二个是<strong class="jm io"> <em class="ki">职工节点</em> </strong>。</p><p id="33d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们通过检查<strong class="jm io"> <em class="ki"> docker流程</em> </strong></p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a906" class="kj kk in ln b gy lr ls l lt lu">docker ps</span></pre><p id="2d12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将看到我们有两个容器<strong class="jm io"><em class="ki"/></strong>——一个用于主节点，一个用于工作者节点:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6453" class="kj kk in ln b gy lr ls l lt lu">CONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                                                                                                                  NAMES<br/>9db0a1b4ceab   gcr.io/k8s-minikube/kicbase:v0.0.28   "/usr/local/bin/entr…"   2 minutes ago   Up 2 minutes   127.0.0.1:64998-&gt;22/tcp, 127.0.0.1:64994-&gt;2376/tcp, 127.0.0.1:64996-&gt;5000/tcp, 127.0.0.1:64997-&gt;8443/tcp, 127.0.0.1:64995-&gt;32443/tcp   minikube-m02<br/>4a010f289ac7   gcr.io/k8s-minikube/kicbase:v0.0.28   "/usr/local/bin/entr…"   4 minutes ago   Up 4 minutes   127.0.0.1:64967-&gt;22/tcp, 127.0.0.1:64968-&gt;2376/tcp, 127.0.0.1:64965-&gt;5000/tcp, 127.0.0.1:64966-&gt;8443/tcp, 127.0.0.1:64964-&gt;32443/tcp   minikube</span></pre><h2 id="4036" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">与集群交互</h2><p id="586b" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">当涉及到从本地机器与集群交互时，Kubernetes命令行工具<strong class="jm io"> <em class="ki"> kubectl </em> </strong>将会派上用场。它使用K8s API与集群进行交互。我们可以利用它来部署应用程序、检查和更改资源、调试和查看日志，等等。</p><p id="fd6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果要<strong class="jm io"> <em class="ki">与集群</em> </strong>交互，请键入:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="f707" class="kj kk in ln b gy lr ls l lt lu">kubectl get nodes</span></pre><p id="4f61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会看到我们有<strong class="jm io"> <em class="ki">两个节点</em> </strong>:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="cf4f" class="kj kk in ln b gy lr ls l lt lu">NAME           STATUS   ROLES                  AGE   VERSION<br/>minikube       Ready    control-plane,master   28m   v1.22.3<br/>minikube-m02   Ready    &lt;none&gt;                 27m   v1.22.3</span></pre><h2 id="7c7b" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">创建Kubernetes部署配置</h2><p id="c7f8" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">因此，我们已经有一个Kubernetes集群在运行。最重要的是，我们现在可以部署我们的容器化应用程序。为此，我们需要创建一个<strong class="jm io"> <em class="ki"> Kubernetes部署</em> </strong>配置，告诉K8s如何生成和更新应用程序实例。一旦我们创建了集群，K8s控制平面将安排该部署中包含的应用程序实例在集群中的特定节点上运行。</p><p id="ee75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">部署可以增加副本单元的数量，允许新代码的受控发布，或者在必要时回滚到以前的部署版本。<strong class="jm io"> <em class="ki">部署控制器</em> </strong>持续监控创建的实例，如果一个实例关闭或被破坏，它将被集群中另一个节点上的另一个实例替换。这解决了机器故障或维护的问题。</p><p id="a863" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用您选择的任何编辑器来创建部署。为此我将使用<strong class="jm io"> <em class="ki"> Visual Studio代码</em> </strong>。您可以轻松地设置它，然后安装<strong class="jm io"> <em class="ki"> Kubernetes扩展</em> </strong>，它将在为Kubernetes创建部署时提供自动完成功能。</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lw"><img src="../Images/90145d96c4a3435ca77eb77190410638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKdQQfyeUHrgKIsE773HvA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">Visual Studio代码的Kubernetes扩展</figcaption></figure><p id="52fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续在文件系统中的某个地方创建<strong class="jm io"><em class="ki">deployment . yml</em></strong>。接下来，我们将设置一个基本配置。键入“dep”并让它自动完成:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mi"><img src="../Images/dce348a19ee2597c78fe068c080a563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jew6prQg9xkewXQ_OKiMGQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">部署. yml文件</figcaption></figure><p id="5b9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它看起来会像这样:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mj"><img src="../Images/a241b4c5c56c73f747c5357b05385085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJiljrwiVgbz43n10CK4IA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">Kubernetes部署配置</figcaption></figure><p id="6c7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将插入副本数量的配置，修改内存规格、容器端口，并用我的Docker注册表中的公共映像替换该映像—<strong class="jm io"><em class="ki">anitalakhadze/spring _ hello _ world</em></strong>:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mk"><img src="../Images/e5f2ddab925c955874a588704325556c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHBQHlwsFVx9oKbfVvrM0A.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">修改Kubernetes部署</figcaption></figure><p id="f119" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们要做的是创建一个<strong class="jm io"> <em class="ki">服务</em> </strong>，它将允许我们访问pod。您可以将此服务视为负载平衡器。不要忘记三个破折号并键入“serv”:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ml"><img src="../Images/829e3e3260a533119e03bacd94dc1dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsD-E90UT8IOFtZAIrNHpA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">Kubernetes服务配置</figcaption></figure><p id="35c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将如下所示:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/33d3153b4eaf2484c0caa5c1fbdba2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*mUKVwbgSfVLBF_iBZxCVYQ.png"/></div></figure><p id="fe37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8080端口是容器将要监听的端口，80是服务的端口。因此，这个选择器“myapp”将匹配在其模板元数据标签中具有相同名称的pod。</p><p id="72d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，最后一件事是稍微更改一下规范，在两个节点上公开随机端口。</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mn"><img src="../Images/7e7d7a10ca45944f898b1db056a7ea86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FKLNa6zF_ZUtru8-_85CQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">暴露两个节点上的随机端口</figcaption></figure><p id="1a26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里  阅读更多关于Kubernetes <a class="ae lh" href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">的组网模式。</em></strong></a></p><h2 id="2f73" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">应用Kubernetes部署</h2><p id="2e93" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">现在，让我们看看集群中所有可用的pod(所有名称空间中的所有pod):</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6f6e" class="kj kk in ln b gy lr ls l lt lu">kubectl get pods -A</span></pre><p id="9da9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将看到控制面板由以下部分组成:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="7cf3" class="kj kk in ln b gy lr ls l lt lu">NAMESPACE     NAME                               READY   STATUS    RESTARTS        AGE<br/>kube-system   coredns-78fcd69978-cdxkm           1/1     Running   1 (16m ago)     7d16h<br/>kube-system   etcd-minikube                      1/1     Running   1 (16m ago)     7d16h<br/>kube-system   kindnet-4n24p                      1/1     Running   28 (16m ago)    7d16h<br/>kube-system   kindnet-6q689                      1/1     Running   206 (16m ago)   7d16h<br/>kube-system   kube-apiserver-minikube            1/1     Running   1 (16m ago)     7d16h<br/>kube-system   kube-controller-manager-minikube   1/1     Running   1 (16m ago)     7d16h<br/>kube-system   kube-proxy-4lvh2                   1/1     Running   1 (16m ago)     7d16h<br/>kube-system   kube-proxy-mbpj2                   1/1     Running   1 (16m ago)     7d16h<br/>kube-system   kube-scheduler-minikube            1/1     Running   1 (16m ago)     7d16h<br/>kube-system   storage-provisioner                1/1     Running   2 (7m57s ago)   7d16h</span></pre><p id="6b77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你跑了</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="f26c" class="kj kk in ln b gy lr ls l lt lu">kubectl get pods</span></pre><p id="7c74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将收到以下消息:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="b53b" class="kj kk in ln b gy lr ls l lt lu">No resources found in default namespace.</span></pre><p id="181f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为尽管我们已经创建了部署配置，但是我们还没有应用它。要应用我们的deployment.yml配置，我们必须提供以下命令:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8cb6" class="kj kk in ln b gy lr ls l lt lu">kubectl apply -f deployment.yml</span></pre><p id="a037" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们用上面的命令应用部署时，K8s创建了一个Pod来托管我们的应用程序实例。之后，您将看到以下消息:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="0c83" class="kj kk in ln b gy lr ls l lt lu">deployment.apps/myapp created<br/>service/myapp created</span></pre><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mo"><img src="../Images/72954aa59fc4f5dd82c91612eee05e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEc1YFaJ4PS0rdOJplC49Q.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">图片来自<a class="ae lh" href="https://d33wubrfki0l68.cloudfront.net/8700a7f5f0008913aa6c25a1b26c08461e4947c7/cfc2c/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>教程</figcaption></figure><p id="1569" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您再次检查pod，这次您将看到两个正在运行的pod:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="1801" class="kj kk in ln b gy lr ls l lt lu">NAME                    READY   STATUS    RESTARTS   AGE<br/>myapp-8d8d79856-ml2jh   1/1     Running   0          3m5s<br/>myapp-8d8d79856-vx7gs   1/1     Running   0          2m15s</span></pre><h2 id="055e" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">访问我们的应用程序</h2><p id="15a6" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">为了访问我们的应用程序，让我们键入:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="612d" class="kj kk in ln b gy lr ls l lt lu">kubectl get svc</span></pre><p id="2f79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将看到，我们有一个NodePort类型的服务myapp，它将随机分配的端口转发到80，80将根据我们在文件中编写的规范，将请求转发到我们的容器的端口8080。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="26b2" class="kj kk in ln b gy lr ls l lt lu">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE<br/>kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        4m2s<br/>myapp        NodePort    10.96.114.46   &lt;none&gt;        80:30676/TCP   7s</span></pre><p id="137c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要访问该服务，我们键入:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="947a" class="kj kk in ln b gy lr ls l lt lu">minikube service myapp</span></pre><p id="0d22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">稍等片刻，它将打开一个包含您的应用程序的web浏览器窗口:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mp"><img src="../Images/c4ccb9d8346f3f834b5e31e480b64d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sorFJQfTnuB_L3t6PH1zw.png"/></div></div></figure><p id="e7e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在终端中查看详细信息:</p><figure class="li lj lk ll gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mq"><img src="../Images/ab2f12dc009432eb327b1a8668da74a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpmNAGOe8quHUa7Mke-o4w.png"/></div></div></figure></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="1c10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！我们已经在本地Kubernetes集群上启动并运行了我们的Spring Boot应用程序。多酷啊。</p><p id="79c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对<strong class="jm io"><em class="ki"/></strong>Kubernetes的核心基础设施感兴趣，可以看看我之前的文章<a class="ae lh" href="https://medium.com/@atala15/kubernetes-an-overview-6b800672a893" rel="noopener"> <strong class="jm io"> <em class="ki">这里</em> </strong> </a>。</p><p id="8b89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果你有兴趣阅读更多关于<strong class="jm io"> <em class="ki">云原生开发</em> </strong>和从<strong class="jm io"> <em class="ki">谷歌云平台</em> </strong>在Kubernetes上部署一个容器化的应用程序，你可以继续阅读我的另一篇文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-creating-and-deploying-a-containerized-app-c991448f1ba8"> <strong class="jm io"> <em class="ki">这里</em> </strong> </a> <strong class="jm io"> <em class="ki">。</em>T29】</strong></p><p id="0427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要错过未来的博客，了解更多关于Kubernetes和其他有趣的东西。敬请期待！</p></div></div>    
</body>
</html>