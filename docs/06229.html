<html>
<head>
<title>SpringBoot: Fuzzy Match With Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SpringBoot:与Postgres模糊匹配</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/springboot-fuzzy-match-with-postgres-8eb6bfd17b58?source=collection_archive---------1-----------------------#2021-12-23">https://blog.devgenius.io/springboot-fuzzy-match-with-postgres-8eb6bfd17b58?source=collection_archive---------1-----------------------#2021-12-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在今天的文章中，我将讨论如何使用Postgres的模糊匹配支持，以便使用REST API进行部分搜索。</p><p id="af97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">免责声明:本文的目的是给你一个使用模糊匹配的实际例子，而不是详细解释所有的概念。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/d7adfe69eb6a8fcf6a0031d65159a452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zkTTM1XFb6G2YJdS"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄粘土堤</a>上<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></figcaption></figure></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="d2b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始之前，你可以在这里找到完整的<a class="ae kz" href="https://github.com/georgeberar/medium/tree/main/fuzzy-match-postgresql" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">代码</strong> </a>。</p><h1 id="1c31" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">背景</h1><p id="cdc8" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">星期天晚上，你想看一部朋友推荐的电影，但你不记得电影的全名，只记得它与“蝙蝠”有关。因此，你打开IMDB或烂番茄，在搜索输入中键入“bat ”,你会看到一个已经出现的电影列表，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/460561b6c43d5dd9a515ff9260564b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Kxwh5-mcG0Q1G1QEyqdVSw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">在烂番茄搜索“bat”的示例</figcaption></figure><p id="c2f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你知道了！你要找的电影:《蝙蝠侠》。搜索输入背后发生的事情被称为模糊匹配，它是许多搜索引擎框架的基石。</p><p id="53de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是什么是模糊匹配呢？</p><blockquote class="ml mm mn"><p id="7af5" class="jk jl ki jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">这是一种识别文本、字符串或条目中两个近似相似但不完全相同的元素的技术。</p></blockquote><p id="f553" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你仔细观察，你会看到其他电影也因为这种“近似”的匹配而出现(如《受虐者》或《蝙蝠》)。键入更多的字符会给我们带来更准确的结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/070b4599d24d8dacdbbb222763c5f5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*MsBhT7r46klzFTRm_Jhgiw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">在烂番茄搜索“蝙蝠侠”的例子</figcaption></figure><h1 id="c6a2" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">问题是</h1><p id="5b79" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">假设我们构建了一个TODO API(使用Postgres数据库)来管理日常任务，并且我们有一些持久化的TODO:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ms"><img src="../Images/0a00f60042ba55db148a294bf4b3ef5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TERaJoVhmZNEEoJzhiAxUA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">待办事项示例</figcaption></figure><p id="bc6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">注意:第二个TODO记录在“title”中有一个错别字(Klean而不是Clean)，但我是故意这样做的，稍后我们会看到原因。</em></p><p id="e3ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们希望我们的API提供一个端点，允许用户根据他们的头衔搜索TODOs。使用JPA，我们可以利用众所周知的<code class="fe mt mu mv mw b">LIKE</code>语法在数据库中实现简单快速的搜索:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用LIKE“% %”方法搜索TODO的JPA存储库</figcaption></figure><p id="bebb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这类似于SQL语句:<code class="fe mt mu mv mw b">SELECT * FROM t_todo WHERE title LIKE '%partialTitle%'</code>。</p><p id="7b88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Postman中使用“Eat”作为搜索字符串进行请求，得到了预期的输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1e874232ad41613a96810cfabe1fb972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*BaWLCQSyBMTFxQN3xvFhZw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用“吃”搜索待办事项</figcaption></figure><p id="6da9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看当我们尝试使用“Clean”进行搜索时会发生什么:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi na"><img src="../Images/2f7bc5991f00bb4864dd2c0219eddc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*BUXIxUNJMY_LxOo6iBO0Iw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用“清理”搜索待办事项</figcaption></figure><p id="2fb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，它把<em class="ki">清理门户</em> TODO还给我，并按预期工作，对吗？嗯……不尽然。想象一下，当你没有足够注意创建一个新的TODO，并且你打错了一个错别字，<em class="ki"> Klean </em>而不是<em class="ki"> Clean。</em>对于我们来说，取回<em class="ki"> Klean Car </em> TODO也是有意义的，因为唯一的错误字符是‘K’而不是‘C ’,并且搜索字符串的其余部分匹配。那为什么不工作呢？让我们看看，当我们做同样的请求，但他使用“Klean”而不是“Clean”时会发生什么:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bed5d0430edf918e17ae748d542313cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*DuE6e1mqCYFzKpeoPdhhpQ.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用“Klean”搜索待办事项</figcaption></figure><p id="12bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们得到的仅仅是包含错别字的TODO，而我们又一次期望两个都有。</p><p id="f312" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实是，<code class="fe mt mu mv mw b">LIKE</code>语法对精确匹配有效，但在处理错别字时却完全失败了。即使只有一个字符不同，其余的都相同，对于<code class="fe mt mu mv mw b">LIKE</code>来说，这也是一个不匹配。在现实生活中，这是一个问题，因为这是一个众所周知的事实——人们经常会打错字；我们不能指望我们的用户每次都记得他们打错了字或给出了准确的搜索字符串，以便提供有意义的回应。</p><h1 id="1cf2" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">解决方案</h1><p id="e62a" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">模糊匹配！这是一个非常明显的答案，我同意:)但是让我们看看如何使用Postgres通过两个简单的步骤来实现它。</p><h2 id="059d" class="nc li in bd lj nd ne dn ln nf ng dp lr jv nh ni lv jz nj nk lz kd nl nm md nn bi translated">第一步。pg_trgm</h2><p id="90f7" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Postgres提供了一个名为<code class="fe mt mu mv mw b">pg_trgm</code>的模块，它提供了不同的函数来处理三元模型匹配。三元模型是从字符串中提取的一组三个连续的字符。基于此，我们可以通过计算两个字符串共享的三元模型的数量来衡量它们的相似性，并估计它们在0到1之间的相似程度。例如，字符串“hello”将由以下三元组表示:</p><ul class=""><li id="c25d" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh nt nu nv nw bi translated">" h "，" he "，" hel "，" ell "，" llo "，" lo "</li></ul><p id="cc60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使用这个模块，我们需要使用下面的语句来启用它:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">启用PostgreSQL的三元模型模块支持</figcaption></figure><h2 id="9605" class="nc li in bd lj nd ne dn ln nf ng dp lr jv nh ni lv jz nj nk lz kd nl nm md nn bi translated">第二步。JPA查询</h2><p id="d667" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">接下来，我们使用<code class="fe mt mu mv mw b">%</code>操作符来比较数组的元素，这样我们就可以匹配标题的任何部分:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用%运算符的示例SQL查询</figcaption></figure><p id="50ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该查询使用Postgres的<code class="fe mt mu mv mw b">STRING_TO_ARRAY</code>函数将TODO的标题分割成单独字符串的数组。</p><p id="d0a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调整JPA的原生查询会给我们带来:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1d8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以正确地通过部分标题搜索待办事项了。以下是一些工作示例:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b2770f65c1d45a86da1414a4837cf1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*-Yw1JDmq1UfzTe12MPs0FQ.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">“后”值的模糊匹配</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi na"><img src="../Images/60e030ad4f1149b381dbd6d42d9051c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*zC05qI7TndaLv3yFlN3zTg.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">“干净”值的模糊匹配</figcaption></figure><p id="a2ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，对于“干净的”搜索字符串，我们现在得到了它们。尝试使用“Klean”会给我们同样的结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ffa94f9d1957b72f37cb79d0185b448f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*gRnRuPtaDPOA2ym4ghOeoQ.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">“Klean”值的模糊匹配</figcaption></figure><p id="534e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有一件事……<code class="fe mt mu mv mw b">%</code>操作符使用默认的相似性阈值0.3，但是如果我们需要调整它(例如0.5)，我们可以使用<code class="fe mt mu mv mw b">SIMILARITY</code>函数:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用相似性函数的示例SQL查询</figcaption></figure><p id="d027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！</p><h1 id="7210" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="e73b" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">请始终记住，这种方法可能适合也可能不适合您的项目环境或需求，我不能说没有其他方法可以做得不同或更好。我真的希望你喜欢它，并从中获得乐趣。</p><p id="4a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意安全，记住你可以在这里 找到<a class="ae kz" href="https://github.com/georgeberar/medium/tree/main/fuzzy-match-postgresql" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">代码！</strong></a></p></div></div>    
</body>
</html>