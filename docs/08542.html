<html>
<head>
<title>Kotlin Coroutines - Job and Timeout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 协同程序-作业和超时</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-coroutines-job-and-timeout-d7b8c5416d69?source=collection_archive---------3-----------------------#2022-06-23">https://blog.devgenius.io/kotlin-coroutines-job-and-timeout-d7b8c5416d69?source=collection_archive---------3-----------------------#2022-06-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="1d35" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">你有工作要及时完成！</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7376945190384b8448555018a3a9a38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FCbT38XGvhXetgq-.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://allf1.in/the-dominance-of-hamilton-bad-for-the-sport/" rel="noopener ugc nofollow" target="_blank">https://all f1 . in/the-dominance-of-Hamilton-bad-for-the-sport/</a></figcaption></figure><p id="c589" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">协程是在 Android 应用程序开发和 Ktor 中执行后台进程的现代方式。在这个协程系列的一篇文章中，我们试图理解协程的基础知识。如果你还没看过，看看这里的<a class="ae lc" href="https://saurabhpant.medium.com/kotlin-coroutines-what-why-how-99529c951a2e" rel="noopener"/>。</p><p id="b112" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在本文中，我们将对这个问题有一些基本的理解:</p><ul class=""><li id="777d" class="lg lh in jq b jr js jv jw ld li le lj lf lk kl ll lm ln lo bi translated">为什么要控制协程的生命周期？</li><li id="2530" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">控制协程生命周期的方法？</li></ul><blockquote class="jk jl jm"><p id="c611" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你还没有选择它们，是时候开始了。</p></blockquote></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="9d1d" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">为什么要控制协程的生命周期？</h1><p id="e14f" class="pw-post-body-paragraph jn jo in jq b jr mz jt ju jv na jx jy ld nb kb kc le nc kf kg lf nd kj kk kl ig bi translated">考虑这样一个场景，我们为某个进程启动了一个协程，但是用户离开了屏幕，该进程不再需要。在这种情况下，我们的协程将一直运行，直到它完成。</p><p id="07b3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">另一个场景可能是，我们的最大执行时间限制是 3 秒，但该过程花费了更长时间，我们的过程目的现在是无效的。</p><p id="3659" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">还有一个可能是，一些计算正在无限期地进行，我们需要出于任何原因退出。</p><p id="6801" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在所有上述和更多类似的场景中，我们需要某种机制来控制我们的协同程序继续运行。不这样做可能会泄漏我们的资源，或者会导致我们的应用程序崩溃或不稳定。</p><p id="d019" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这就引出了我们的下一个问题。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="2fd1" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">控制协程生命周期的方法？</h1><h2 id="1a33" class="ne mc in bd md nf ng dn mh nh ni dp ml ld nj nk mp le nl nm mt lf nn no mx np bi translated">使用工单</h2><p id="6d42" class="pw-post-body-paragraph jn jo in jq b jr mz jt ju jv na jx jy ld nb kb kc le nc kf kg lf nd kj kk kl ig bi translated">我们知道协程是使用协程构建器启动的。协程生成器返回给我们一个作业对象。该作业对象的类型为<strong class="jq io"> <em class="jp">作业</em> </strong>，可用于取消协程。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7240" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如上所示，使用 job 对象，我们取消了作业，然后等待它完成。运行上面的代码将导致</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2be2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我们启动了一项工作，将 0.5 秒的延迟重复了 1000 次。该作业与其父协程同时启动，父协程延迟 2 秒，然后取消该作业。事件是这样发生的:</p><ul class=""><li id="a176" class="lg lh in jq b jr js jv jw ld li le lj lf lk kl ll lm ln lo bi translated"><em class="jp">首先启动 runBlocking】</em></li><li id="6de2" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated"><em class="jp">然后与父代码</em>同时启动发射模块</li><li id="978a" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated"><em class="jp">父代码等待了 2 秒，同时作业执行了 4 次 0 到 3 </em></li><li id="abda" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated"><em class="jp">父作业取消了作业，等待它安全完成并退出</em></li><li id="b83e" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated"><em class="jp">工作取消</em></li><li id="0b91" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated"><em class="jp">返回主线程</em></li></ul><p id="0f84" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这就是我们如何使用作业对象控制协程执行的。</p><h2 id="a20a" class="ne mc in bd md nf ng dn mh nh ni dp ml ld nj nk mp le nl nm mt lf nn no mx np bi translated">使用合作抵消</h2><p id="dbb8" class="pw-post-body-paragraph jn jo in jq b jr mz jt ju jv na jx jy ld nb kb kc le nc kf kg lf nd kj kk kl ig bi translated">取消协程应该是合作的，这意味着任何挂起的计算都应该检查协程在执行时是否被取消。如果一个协程正在计算并且没有被取消检查，那么它不能被取消。让我们举一个例子如下</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cdc6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">运行这个作业并取消它不会停止我们的协程，因为它不会检查调用它的协程是否被取消。它会继续运行。</p><p id="4298" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">要解决这个问题，我们需要通过检查协程的取消状态来确保每个计算都是可取消的，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8d3e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">现在，我们添加了一个由协程作用域本身提供的<strong class="jq io"> <em class="jp"> isActive </em> </strong>标志。一旦作业被取消，该标志将停止执行。</p><p id="da66" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在某些情况下，如果作业被取消，我们需要执行一些步骤，我们可以在<strong class="jq io"> <em class="jp"> finally {} </em> </strong>块中执行这些步骤，因为被取消的作业会抛出<strong class="jq io"><em class="jp">cancellation exception</em></strong>异常，这是协程程序中的预期行为。这就是为什么我们这里不需要抓块。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="bc01" class="ne mc in bd md nf ng dn mh nh ni dp ml ld nj nk mp le nl nm mt lf nn no mx np bi translated">使用超时</h2><p id="5737" class="pw-post-body-paragraph jn jo in jq b jr mz jt ju jv na jx jy ld nb kb kc le nc kf kg lf nd kj kk kl ig bi translated">我们可能需要取消一个作业，因为它超过了时间限制。协程提供了 withTimeout 函数，它为我们做了完全相同的事情。超过时限抛出<strong class="jq io"> <em class="jp">超时取消异常</em> </strong>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cc6c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果不需要异常，那么使用函数<strong class="jq io"><em class="jp">with time out or Null</em></strong>，超时返回 null。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="3bd5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">Bamn！我们现在知道如何管理我们的协程执行，并更好地控制我们的后台任务。实现代码并进行试验，以便更好地理解。</p><p id="0b39" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">目前就这些了！敬请期待！</p><p id="4458" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在 medium(如果内容对你有帮助)或<a class="ae lc" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> github </a>上关注我，并订阅电子邮件以同步了解更多关于 Android 的有趣话题。</p><p id="f761" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">直到下一次…</p><p id="40b7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">干杯！</p></div></div>    
</body>
</html>