<html>
<head>
<title>Bellman-Ford Algorithm Visually Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贝尔曼-福特算法直观解释</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bellman-ford-algorithm-visually-explained-e940b6edb00a?source=collection_archive---------4-----------------------#2020-07-08">https://blog.devgenius.io/bellman-ford-algorithm-visually-explained-e940b6edb00a?source=collection_archive---------4-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/860e9fc51dbfed1fddbbc5968079f020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jjTXDpSpsRxhq9ZZlgAuw.jpeg"/></div></div></figure><p id="5d55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">贝尔曼-福特算法寻找从源顶点到有向图中每个顶点的最短路径。与Dijkstra的算法不同，Bellman-Ford可以有负边缘。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/35f9182d305883a82703efd02f586049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*hIHfYw9ODlandwsKsQAiHA.png"/></div></figure><p id="617c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，所有出站边都按字母顺序记录在一个表中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/c6a30667af98fea938b95e7637ad7567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4gufnvc7lqr9myfZmKy9A.png"/></div></div></figure><p id="083f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像Dijkstra的算法一样，创建一个记录到每个顶点的距离和每个顶点的前身的表。除了源顶点之外，每个顶点的距离都被初始化为无穷大。距离用变量d表示，前任用变量π表示。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/acf9c9d3cf64595825388e32168b77f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8f3qg6DkcR5E77FvBRDaQ.png"/></div></div></figure><p id="d55a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">贝尔曼-福特算法将遍历每条边。因为有9条边，所以最多有9次迭代。在每次迭代过程中，放松特定的边。在第一次迭代中，从A到顶点C的代价是-3。从源到A的当前距离是无穷大。当-3加到无穷大时，结果是无穷大，所以C的值保持无穷大。类似地，从A到E，成本是2，然而，由于到A的距离是无穷大，E的值保持无穷大。看看边B-F，C-B，C-H，F-G，G-B和H-D，我们可以看到它们都产生相同的结果，无穷大。最后一条边S-A产生了不同的结果。边S-A的权重是5。目前到S的距离是0，所以S到A的距离是0 + 5 = 5。A的前任设置为s，第一次迭代后，贝尔曼-福特找到了从s到A的路径。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/a8d1cf7fe294a9eb44f5c9a87885fb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JnLnzty08Qx_Cjqy7LsLA.png"/></div></div></figure><p id="e5c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为所有的边都被放松了，贝尔曼-福特开始第二次迭代。尽管每条边都是松弛的，但唯一重要的边是来自S和A的边，因为到这些顶点的距离是已知的。到所有其他顶点的距离是无穷大。查看包含边的表，我们从放松边A-C开始。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/96fe211fe01e167896cab741fa6aee98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbrXURHrbm_bVYOO5Tr0Lg.png"/></div></div></figure><p id="c7c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边A-C的权重是-3。通过边S-A到顶点A的当前距离是5，所以到顶点C的距离是5 + (-3) = 2。C的前身是A，边A-E的权重是2。通过边S-A到E的距离是5+2 = 7。E的前身更新为a。边B-F还不能放松。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/76e10043a95304ff19d106efccee247f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUP-17Okg90chDKPWJM7wg.png"/></div></div></figure><p id="8487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边C-B可以放松，因为我们知道到C的距离。到B的距离是<br/> 2 + 7 = 9，顶点B的前身是C。边C-H可以放松，因为我们知道到C的距离。到H的距离是2 + (-3) = -1，顶点H的前身是顶点C</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/b9bea5cb05f6bf6f6e256b830fe1b7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vLWZvgEyeW-Y21rfSO02Q.png"/></div></div></figure><p id="ba03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘F-G还不能放松。边缘G-B不能放松。边H-D可以放松，因为我们知道到顶点H的距离是-1。到顶点D的距离是-1 + 1 = 0，到顶点D的前任是顶点h。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/f2089086155792697fb43ba223275f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6olEB-yPQOpxBHqTxnAbA.png"/></div></div></figure><p id="98f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从边S-A到A的距离已经是5，因此不需要更新。这结束了迭代2。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/971d272db9e5c5ce4fd22973af466b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*Zd_46fwbNII3fzqn3XKNLw.png"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/a75859f54e016c2eb90db029008286aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QO2CrP9sbH0G4GgY2uwMtw.png"/></div></div></figure><p id="e6ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第三次迭代中，贝尔曼-福特算法再次检查所有的边。边A-C和A-E产生相同的结果。边缘B-F现在可以放松了。到B的距离是9，所以到顶点F的距离是9 + (-5) = 4。F的前身是b。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/66cdb87aabe6f5c18b29b5c11e43a4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxglC4WVKT813TZ1kpRDgA.png"/></div></div></figure><p id="4858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边C-B和C-H产生相同的结果，因此表保持不变。边缘F-G现在可以放松了。到顶点F的距离是4，所以到顶点G的距离是4 + 2 = 6。G的前身是f。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/ab6758a05feaa060aed835caf960d743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2KeYenPTEGqWmQ7LwRFOw.png"/></div></div></figure><p id="0a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘G-B现在可以放松了。到顶点G的距离是6，所以到B的距离是6 + 4 = 10。因为通过边C-B可以用更短的距离到达顶点B，所以表保持不变。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/fdb46c80671e078de8c1e6fb2158e016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*sPDk3Twul8vJPvs4NJDTHA.png"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/17f6801c68984f668213ac47a920621f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6p6wD_D1AIAa3kKqZ-vxw.png"/></div></div></figure><p id="3251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第四次迭代中，检查所有的边。该算法发现没有变化，因此该算法在第四次迭代时结束。</p><p id="29ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这个图有一个负循环，在迭代重复n-1次后，理论上贝尔曼-福特算法应该已经找到了到所有顶点的最短路径。在第n次迭代期间，其中n代表顶点的数量，如果存在负循环，到至少一个顶点的距离将改变。让我们看一个简单的例子。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/ddd3966eb5261bfb79891ebfbed72199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*ndaHI5jM8dGh0tnDSQ27-Q.png"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/77bf976972453a4822d8c17027baffcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raWpu_2XI2fjRGblgb6ITg.png"/></div></div></figure><p id="6ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建具有距离和前辈的表。顶点A、B和c的距离被初始化为无穷大。到S的距离为0。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/e5afad4653ef817e2b31ae0f85f91bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QB1PYfmXtofX0dPbUATAA.png"/></div></div></figure><p id="40e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看第一条边，A-B还不能放松，边B-C和边C-A也不能放松，边S-A可以放松。到S的距离是0，所以到A的距离是0 + 3 = 3。A的前身是s。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/9b0e3b1587b3db728345233ac24fd560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKN6G9Vhr9TWyVT_YqLpRA.png"/></div></div></figure><p id="fd4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Edge S-B也可以放宽。到顶点B的距离是0 + 6 = 6。顶点B的前身是s。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/6b82c414db8e07fdea29ec13ed6de79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pImaaCZqMU4n4H8OW4blg.png"/></div></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/e882193902f57d12b8c66b914f16f56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*mZBTfj5-7552TRPpyeBXog.png"/></div></figure><p id="fef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一次迭代完成。在第二次迭代中，再次检查所有的边。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/f25a8fd32b74cdf47d78e3e1f7e873b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzscJE8TRgwbpe8J0WcX4A.png"/></div></div></figure><p id="6aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘A-B可以在第二次迭代中放松。到A的距离是3，所以到顶点B的距离是3 + 5 = 8。因为到B的距离已经小于新值，所以保留B的值。6 + 2 = 8可以达到边B-C。顶点C的前身是顶点b。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/c855940482eaeaad7336eb61497a173b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5kShQ5iuWlnZMJ3KSSp4g.png"/></div></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/a604e88ea5e2ca752caa70b6b7837ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*6Td0nqw3Z38lsVOx_mWMhg.png"/></div></figure><p id="b9f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来检查边C-A。到C的距离是8个单位，所以到A的过孔边缘B-C的距离是8 + (-10) = -2。因为到通孔边缘C-A的距离小于到通孔S-A的距离，所以到A的距离被更新。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/30cf4ba687beeb3fea8d1ed9a30e5d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhIRZUGxNQEVw_EL-ROtFQ.png"/></div></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/78a25015770b221a75e9f484431e7a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*eX6-OtSGK_yCZBmpT8JdbQ.png"/></div></figure><p id="eb48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边S-A和S-B不会产生更好的结果，因此第二次迭代完成。第三次迭代开始。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/2d5d5142b45b5502a650f321a3d6ce66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yp3I12FvIN3_XPjZTJQyyw.png"/></div></div></figure><p id="0265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘A-B是放松的。到A的距离目前是-2，因此通过边A-B到B的距离是-2 + 5 = 3。由于通过A-B到B的距离小于到S-B的距离，因此距离更新为3。顶点B的前身更新为顶点a。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/4ce747095262ac7f6dd5d33541d73561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vOW8zyLi5DnBtB3B4wn-w.png"/></div></div></figure><p id="dbd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来放松边缘B-C。当前到B的距离是3，所以到C的距离是<br/> 3 + 2 = 5。到C的距离更新为5。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/f9c1506bb352ce54354bdd000b7fa942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwhEseIdIm5u0GSSEUCPvQ.png"/></div></div></figure><p id="e9ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘C-A是放松的。到C的距离是5 + (-10) = -5。到顶点A的距离更新为-5个单位。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/07333144b423746fefc15e2bcec6cc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKk4iCyfmVs_DfIZna7HuQ.png"/></div></div></figure><p id="e53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边S-A和S-B不会产生更好的结果。此时，应该已经找到了所有最短路径。如果我们检查另一个迭代，应该没有变化。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/a604b3c794b95b88397d6afaad5ac30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNRt5LgZHFhdqtGUttHB7g.png"/></div></div></figure><p id="8db6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边缘A-B是放松的。到A的距离是-5，所以到B的距离是-5 + 5 = 0。到B的距离更新为0。因为值在第n次迭代时改变，所以值也将在第n+1次迭代时改变；价值观将继续无限变化。如果我们仔细观察这个图，我们可以看到A-B-C产生了一个负值:5 + 2 + (-10) = -3。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="0e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢你所读的，看看我的书，<a class="ae mh" href="https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=1586643862" rel="noopener ugc nofollow" target="_blank"><em class="mg"/></a><em class="mg">算法的说明性介绍。</em></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d3a9f579317fbdafd4992518ca12a4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kap_LFm1TfgmPU3W.jpeg"/></div></div></figure><p id="16a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dino Cajic目前是<a class="ae mh" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae mh" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae mh" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae mh" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank"> Everest BioTech </a>、<a class="ae mh" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank"> Nordic MUbio </a>和<a class="ae mh" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT负责人。他还是我的自动系统公司的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="bf62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae mh" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae mh" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae mh" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="fad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读Dino Cajic(以及Medium上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。 </p></div></div>    
</body>
</html>