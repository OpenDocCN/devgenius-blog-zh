<html>
<head>
<title>Learn Golang by building a fintech banking app — Lesson3: User registration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建金融科技银行应用了解 Golang 第 3 课:用户注册</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-golang-by-building-a-fintech-banking-app-lesson3-user-registration-2c2dd0621228?source=collection_archive---------25-----------------------#2020-06-02">https://blog.devgenius.io/learn-golang-by-building-a-fintech-banking-app-lesson3-user-registration-2c2dd0621228?source=collection_archive---------25-----------------------#2020-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93b8700ac5bc70133b392f946c25af8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rovx2ZHPTc12C8xz69FQUg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-3-user-registration" rel="noopener ugc nofollow" target="_blank"> Golang 球场</a></figcaption></figure><p id="df0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文原载:<a class="ae kc" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-3-user-registration" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/golang-course-with-building-a-fin tech-banking-app-lesson-3-user-registration</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d94d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">介绍</h1><p id="ea63" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在 Golang 课程的第三课中，我将向您展示如何在 Golang 中创建用户注册。</p><p id="6d65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Golang 课程的上一课中，我们学习了如何在 Golang 中创建 REST API 以及如何创建用户登录。</p><p id="1bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">网址:</strong> <br/> <a class="ae kc" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-2-login-and-rest-api/%E2%80%A8" rel="noopener ugc nofollow" target="_blank"> Golang 课程，构建金融科技银行应用——第二课:登录和休息 API </a></p><p id="a87e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Angular 课程中，我的朋友 Anna 向您展示了如何在 angular 9 中构建登录。</p><p id="bdc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">此处 URL:</strong><br/><a class="ae kc" href="https://www.blog.duomly.com/angular-course-building-a-banking-application-with-tailwind-css-lesson-2-login-form/" rel="noopener ugc nofollow" target="_blank">Angular Course 用 Tailwind CSS 构建银行应用—第二课:登录表单</a></p><p id="1a2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在今天的课程中，我们可以进入下一步。<br/>那是用户注册，但不是唯一。</p><p id="2a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的项目越来越大，所以我们也需要一些重构。<br/>我们需要确保通过我们的 API 发送的数据是正确的，所以我们需要创建一个验证功能。</p><p id="f666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始吧！</p><p id="cffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢视频，这是 youtube 的版本:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Golang 课程第 3 课</figcaption></figure><h1 id="8d59" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">重构 prepareToken</h1><p id="c191" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们需要做的第一步是一些重构。<br/>第一步，我们将切断所有与 token 相关的逻辑，并为此创建新的函数。</p><p id="131f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从 users/users.go 文件中的函数 Login 获取与令牌相关的逻辑。<br/>并把它放在同一个文件中名为“prepareToken”的新函数中。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="4de8" class="nb lj iq mx b gy nc nd l ne nf">func prepareToken(user *interfaces.User) string {<br/>    tokenContent := jwt.MapClaims{<br/>        "user_id": user.ID,<br/>        "expiry": time.Now().Add(time.Minute * 60).Unix(),<br/>    }<br/>    jwtToken := jwt.NewWithClaims(jwt.GetSigningMethod("HS256"), tokenContent)<br/>    token, err := jwtToken.SignedString([]byte("TokenPassword"))<br/>    helpers.HandleErr(err)</span><span id="bf0b" class="nb lj iq mx b gy ng nd l ne nf">    return token<br/>}</span></pre><h1 id="074f" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">重构 prepareResponse</h1><p id="7237" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">下一步和上一步类似。<br/>但是在第二步中，我们应该从登录中获取所有与响应相关的逻辑。</p><p id="4c16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这种逻辑，我们应该创建一个名为“prepareResponse”的函数。<br/>让我们将所有登录转移到“prepareResponse”函数中。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="5030" class="nb lj iq mx b gy nc nd l ne nf">func prepareResponse(user *interfaces.User, accounts []interfaces.ResponseAccount) map[string]interface{} {<br/>    responseUser := &amp;interfaces.ResponseUser{<br/>        ID: user.ID,<br/>        Username: user.Username,<br/>        Email: user.Email,<br/>        Accounts: accounts,<br/>    }</span><span id="a571" class="nb lj iq mx b gy ng nd l ne nf">    var token = prepareToken(user);<br/>    var response = map[string]interface{}{"message": "all is fine"}<br/>    response["jwt"] = token<br/>    response["data"] = responseUser</span><span id="4015" class="nb lj iq mx b gy ng nd l ne nf">    return response<br/>}</span></pre><h1 id="c7d5" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">重构登录</h1><p id="dbf3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们的登录现在已被清除，但缺少变量。</p><p id="9369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该修复它，并将之前创建的函数赋给名为“response”的变量。</p><p id="b964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要将变量“user”和“accounts”作为该函数的参数进行传递。</p><p id="f77a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下面的例子。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="d7e9" class="nb lj iq mx b gy nc nd l ne nf">func Login(username string, pass string) map[string]interface{} {<br/>    // Connect DB<br/>    db := helpers.ConnectDB()<br/>    user := &amp;interfaces.User{}<br/>    if db.Where("username = ? ", username).First(&amp;user).RecordNotFound() {<br/>        return map[string]interface{}{"message": "User not found"}<br/>    }<br/>    // Verify password<br/>    passErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(pass))</span><span id="ff79" class="nb lj iq mx b gy ng nd l ne nf">    if passErr == bcrypt.ErrMismatchedHashAndPassword &amp;&amp; passErr != nil {<br/>        return map[string]interface{}{"message": "Wrong password"}<br/>    }<br/>    // Find accounts for the user<br/>    accounts := []interfaces.ResponseAccount{}<br/>    db.Table("accounts").Select("id, name, balance").Where("user_id = ? ", user.ID).Scan(&amp;accounts)</span><span id="ffe1" class="nb lj iq mx b gy ng nd l ne nf">    defer db.Close()</span><span id="ba65" class="nb lj iq mx b gy ng nd l ne nf">    var response = prepareResponse(user, accounts);</span><span id="c9c5" class="nb lj iq mx b gy ng nd l ne nf">    return response<br/>}</span></pre><h1 id="f9a3" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建一个注册函数</h1><p id="90ca" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">太好了，重构完成了！</p><p id="d90e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以进入注册功能。</p><p id="9d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同一个文件中，我们应该创建一个名为“Register”的函数。</p><p id="46be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数应该将用户名、电子邮件和 pass 作为参数，所有参数都是“string”类型。</p><p id="2a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数“Register”应该返回与“Login”函数相同类型的响应。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="462b" class="nb lj iq mx b gy nc nd l ne nf">func Register(username string, email string, pass string) map[string]interface{} {</span><span id="e429" class="nb lj iq mx b gy ng nd l ne nf">}</span></pre><h1 id="9543" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建验证界面</h1><p id="e186" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在我们继续寄存器的逻辑之前，我们应该创建验证。这将确保我们发送的所有变量都是我们计划好的。</p><p id="0009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证的第一步是为此创建一个接口。</p><p id="0a22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进入接口/接口。开始。</p><p id="4952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们用两个属性创建一个名为“Validation”的结构。</p><p id="6b2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个是“值”，第二个是“有效”，都是字符串。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="0f82" class="nb lj iq mx b gy nc nd l ne nf">type Validation struct {<br/>    Value string<br/>    Valid string<br/>}</span></pre><h1 id="0484" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建验证逻辑</h1><p id="7533" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在，我们可以创建一些验证逻辑。</p><p id="e08b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该做的第一步是创建两个正则表达式来验证我们的变量是否正确。</p><p id="e9fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个应该验证我们是否只传递字母或数字。</p><p id="b7b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个应该验证我们的变量是否符合电子邮件模式。</p><p id="142c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个 switch-case 语句，并验证用户名和电子邮件是否通过了 regexp。</p><p id="918c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是验证我们的密码是否至少有 5 个字符长。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="1216" class="nb lj iq mx b gy nc nd l ne nf">func Validation(values []interfaces.Validation) bool{<br/>    username := regexp.MustCompile(`^([A-Za-z0-9]{5,})+$`)<br/>    email := regexp.MustCompile(`^[A-Za-z0-9]+[@]+[A-Za-z0-9]+[.]+[A-Za-z]+$`)</span><span id="6be0" class="nb lj iq mx b gy ng nd l ne nf">    for i := 0; i &lt; len(values); i++ {<br/>        switch values[i].Valid {<br/>            case "username":<br/>                if !username.MatchString(values[i].Value) {<br/>                    return false<br/>                }<br/>            case "email":<br/>                if !email.MatchString(values[i].Value) {<br/>                    return false<br/>                }<br/>            case "password":<br/>                if len(values[i].Value) &lt; 5 {<br/>                    return false<br/>                }<br/>        }<br/>    }<br/>    return true<br/>}</span></pre><h1 id="ada0" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">向登录添加验证</h1><p id="65e0" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">完成验证后，我们可以将该逻辑添加到登录中。</p><p id="06af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在“Valid”函数中，我们应该传递所有需要检查的变量。</p><p id="a610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记“有效”密钥的名称。</p><p id="511c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该添加一个 if-else 语句，并在 if-else 通过时放置“Login”的逻辑。<br/>如果不是，我们应该返回一个状态为“无效值<br/>”的消息。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="1331" class="nb lj iq mx b gy nc nd l ne nf">func Login(username string, pass string) map[string]interface{} {<br/>    // Add validation to login<br/>    valid := helpers.Validation(<br/>        []interfaces.Validation{<br/>            {Value: username, Valid: "username"},<br/>            {Value: pass, Valid: "password"},<br/>        })<br/>    if valid {<br/>        // Connect DB<br/>        db := helpers.ConnectDB()<br/>        user := &amp;interfaces.User{}<br/>        if db.Where("username = ? ", username).First(&amp;user).RecordNotFound() {<br/>            return map[string]interface{}{"message": "User not found"}<br/>        }<br/>        // Verify password<br/>        passErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(pass))</span><span id="4e1d" class="nb lj iq mx b gy ng nd l ne nf">        if passErr == bcrypt.ErrMismatchedHashAndPassword &amp;&amp; passErr != nil {<br/>            return map[string]interface{}{"message": "Wrong password"}<br/>        }<br/>        // Find accounts for the user<br/>        accounts := []interfaces.ResponseAccount{}<br/>        db.Table("accounts").Select("id, name, balance").Where("user_id = ? ", user.ID).Scan(&amp;accounts)</span><span id="a2c2" class="nb lj iq mx b gy ng nd l ne nf">        defer db.Close()</span><span id="fb3c" class="nb lj iq mx b gy ng nd l ne nf">        var response = prepareResponse(user, accounts);</span><span id="cba0" class="nb lj iq mx b gy ng nd l ne nf">        return response<br/>    } else {<br/>        return map[string]interface{}{"message": "not valid values"}<br/>    }<br/>}</span></pre><h1 id="db99" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">向注册添加验证</h1><p id="a833" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这一步和上一步很像。</p><p id="233a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切正常，我们可以开始寄存器逻辑。如果没有，返回与“登录”中相同的消息。</p><p id="5e29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个小小的区别就是多加了一个变量“email”。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="06d2" class="nb lj iq mx b gy nc nd l ne nf">func Register(username string, email string, pass string) map[string]interface{} {<br/>    // Add validation to registration<br/>    valid := helpers.Validation(<br/>        []interfaces.Validation{<br/>            {Value: username, Valid: "username"},<br/>            {Value: email, Valid: "email"},<br/>            {Value: pass, Valid: "password"},<br/>        })<br/>    if valid {</span><span id="bf40" class="nb lj iq mx b gy ng nd l ne nf">    } else {<br/>        return map[string]interface{}{"message": "not valid values"}<br/>    }</span><span id="f3ee" class="nb lj iq mx b gy ng nd l ne nf">}</span></pre><h1 id="4cdb" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">寄存器的数据库连接</h1><p id="d255" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在我们可以进入数据库连接。</p><p id="33ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们之前已经做过几次了，所以你可以复制/粘贴这段代码。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="7437" class="nb lj iq mx b gy nc nd l ne nf">db := helpers.ConnectDB()</span></pre><h1 id="178e" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建用户和帐户</h1><p id="e5bc" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们也创造了这个功能。</p><p id="69c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以查看迁移/迁移。进入创建帐户。</p><p id="9fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以复制该代码或从头开始编写。</p><p id="b082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您复制代码，您将需要更改一些值。</p><p id="03b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下面的例子。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="36ef" class="nb lj iq mx b gy nc nd l ne nf">generatedPassword := helpers.HashAndSalt([]byte(pass))<br/>user := &amp;interfaces.User{Username: username, Email: email, Password: generatedPassword}<br/>db.Create(&amp;user)</span><span id="34d0" class="nb lj iq mx b gy ng nd l ne nf">account := &amp;interfaces.Account{Type: "Daily Account", Name: string(username + "'s" + " account"), Balance: 0, UserID: user.ID}<br/>db.Create(&amp;account)</span><span id="3da8" class="nb lj iq mx b gy ng nd l ne nf">defer db.Close()</span></pre><h1 id="e474" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">准备响应和令牌</h1><p id="3efc" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">响应和令牌将非常类似于来自“登录”的逻辑。</p><p id="71d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你只需要将“prepareResponse”函数添加到名为“Response”的变量中。</p><p id="f538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，“response”应该在 if 的末尾，在“Register”函数中。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="aa97" class="nb lj iq mx b gy nc nd l ne nf">accounts := []interfaces.ResponseAccount{}<br/>respAccount := interfaces.ResponseAccount{ID: account.ID, Name: account.Name, Balance: int(account.Balance)}<br/>accounts = append(accounts, respAccount)<br/>var response = prepareResponse(user, accounts)</span><span id="4a5a" class="nb lj iq mx b gy ng nd l ne nf">return response</span></pre><h1 id="7408" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建注册接口</h1><p id="a203" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">恭喜你！</p><p id="1f14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“寄存器”功能的逻辑准备就绪。现在您可以进入 API 的逻辑了。</p><p id="71df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要进入“api/api.go”文件。</p><p id="d38e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们应该创建一个名为“注册”的界面，并在那里定义“用户名”、“电子邮件”和“密码”。<br/>我们应该把所有的道具都定义为“串”。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="f4db" class="nb lj iq mx b gy nc nd l ne nf">type Register struct {<br/>    Username string<br/>    Email string<br/>    Password string<br/>}</span></pre><h1 id="ebec" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">在 API 中创建一个注册函数</h1><p id="6ff6" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在创建 API 的下一步，我们应该创建一个名为“register”的函数。</p><p id="8a41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数应该采用与函数“逻辑”相同的参数。<br/>你可以复制名为“逻辑”的整个功能，只需修改几个地方。</p><p id="8b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会有同样的读本。</p><p id="39ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，该函数应该从用户那里调用“注册”。</p><p id="d017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为最后一步，我们的“注册”逻辑应该准备响应并处理错误。</p><p id="9b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下面的例子。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="a237" class="nb lj iq mx b gy nc nd l ne nf">func register(w http.ResponseWriter, r *http.Request) {<br/>    // Read body<br/>    body, err := ioutil.ReadAll(r.Body)<br/>    helpers.HandleErr(err)<br/>    // Handle registration<br/>    var formattedBody Register<br/>    err = json.Unmarshal(body, &amp;formattedBody)<br/>    helpers.HandleErr(err)<br/>    register := users.Register(formattedBody.Username, formattedBody.Email, formattedBody.Password)<br/>    // Prepare response<br/>    if register["message"] == "all is fine" {<br/>        resp := register<br/>        json.NewEncoder(w).Encode(resp)<br/>        // Handle error in else<br/>    } else {<br/>        resp := ErrResponse{Message: "Wrong username or password"}<br/>        json.NewEncoder(w).Encode(resp)<br/>    }<br/>}</span></pre><h1 id="e270" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">创建 API 端点</h1><p id="5746" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">太好了！</p><p id="769e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是最后一步。</p><p id="81d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们只需要创建一行代码来处理“/register”端点。</p><p id="4d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在名为“StartApi”的函数中为该路由添加带有“HandleFunc”的行。</p><p id="901b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以用“/login”看看我们是怎么做到的。</p><pre class="ml mm mn mo gt mw mx my mz aw na bi"><span id="482b" class="nb lj iq mx b gy nc nd l ne nf">func StartApi() {<br/>    router := mux.NewRouter()<br/>    router.HandleFunc("/login", login).Methods("POST")<br/>    router.HandleFunc("/register", register).Methods("POST")<br/>    fmt.Println("App is working on port :8888")<br/>    log.Fatal(http.ListenAndServe(":8888", router))</span><span id="cfe8" class="nb lj iq mx b gy ng nd l ne nf">}</span></pre><h1 id="f3fa" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">结论</h1><p id="89df" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">祝贺您，您的项目现在已经用户注册和验证！<br/> <br/>你可以从课程开始连接它与前端:<br/> <br/>通过构建 fintech 银行 app <br/> <br/>学习 Angular 9 与 Tailwind CSS 如果你想将代码与我所做的进行比较这里是 URL:<br/><br/><a class="ae kc" href="https://github.com/Duomly/go-bank-backend/tree/Golang-course-Lesson-3" rel="noopener ugc nofollow" target="_blank">https://github . com/Duomly/go-bank-back end/tree/Golang-course-Lesson-3</a><br/><br/>本课的分支名为“Golang-course-Lesson-3”。<br/> <br/>下节课再见，我们将重点关注用户资料，并开始构建资金转账。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/da0dbcf44b16aceb7cca413a6d9a5ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJmZtnXM9S7lwHQJTEQngg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">在线编程课程</a></figcaption></figure><p id="fa46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，<br/>来自 Duomly 的 Radek</p></div></div>    
</body>
</html>