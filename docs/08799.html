<html>
<head>
<title>Kubernetes Deployments: 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 部署:101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kubernetes-deployments-101-46ec865de12d?source=collection_archive---------14-----------------------#2022-07-11">https://blog.devgenius.io/kubernetes-deployments-101-46ec865de12d?source=collection_archive---------14-----------------------#2022-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为它涉及到理解<strong class="jm io"> Kubernetes 编排平台</strong>中的不同部署类型以及它们根据业务应用需求的用法。</p><p id="0775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="49c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-replication-101-d148514598a7"> <strong class="jm io">数据库复制 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-sharding-101-4ef36046c29c"> <strong class="jm io">数据库分片 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-strategy-101-3bc974d2a6cd"> <strong class="jm io">缓存策略 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-pattern-101-be2d7fdb656"><strong class="jm io">断路器 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"> <strong class="jm io">异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计</strong></a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/475ba61e81fafd02ac61e8a662bdc50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giUi26P2Ay6wg2Vf6AId0Q.png"/></div></div></figure><h1 id="63dd" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> Kubernetes 部署对象</strong></h1><p id="cd83" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><strong class="jm io"> Kubernetes 部署对象</strong>是一个清单文件<strong class="jm io"> </strong>，用于自动化 pods 实例的端到端生命周期管理。它的主要目标是减少聚合到包含基本信息的单个定义中的多个命令的开销，这些基本信息包括使用的<em class="ki"> </em> <strong class="jm io"> <em class="ki">容器图像、pod 的数量以及更新它们的方式</em> </strong> <em class="ki">。</em></p><p id="205c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然<strong class="jm io">副本集</strong>直接<strong class="jm io"> </strong>与 pods 交互，但是使用部署对象可以通过内部管理多个<strong class="jm io">副本集</strong>来帮助部署新版本的 pods。这些对象主要用于<strong class="jm io">同构部署</strong>，即所有 pod 都是相似的，没有任何数据存储在永久存储器上。因此，它们是托管无状态微服务的基本块。</p><h2 id="53ca" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">示例应用程序</h2><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="593b" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">清单定义</h2><ol class=""><li id="d7fc" class="mn mo in jm b jn lu jr lv jv mp jz mq kd mr kh ms mt mu mv bi translated"><strong class="jm io"> <em class="ki">容器</em> </strong>段命名为<em class="ki">sample-app</em><strong class="jm io"><em class="ki"/></strong>并从 dockerhub 位置<strong class="jm io"><em class="ki">Amit 894/sample-app-1:1 . 0 . 0</em></strong>拉取图像</li><li id="9f04" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">规范中的<strong class="jm io"> <em class="ki">选择器</em> </strong>寻找标签匹配为<strong class="jm io"><em class="ki">sample-app</em></strong><em class="ki">的应用。</em></li><li id="0bcd" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><em class="ki">规格</em>中的<strong class="jm io"> <em class="ki">副本</em> </strong>创建一个吊舱副本。</li><li id="631d" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><strong class="jm io"> <em class="ki">种类</em> </strong> <em class="ki"> </em>用于指定对象类型为<strong class="jm io"><em class="ki"/></strong>。</li></ol><h2 id="cbfa" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">命令</h2><p id="cf27" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">可以使用以下命令部署上面的示例部署</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="3ef0" class="lz kx in nc b gy ng nh l ni nj">kubectl apply -f sample-deployment.yml</span></pre><p id="66a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以使用以下命令检查部署状态</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="ec99" class="lz kx in nc b gy ng nh l ni nj">kubectl get deployments</span></pre><h1 id="cc21" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Kubernetes StatefulSets 对象</h1><p id="1a4a" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">有状态集合对象有一个类似的清单文件来管理容器、窗格和图像位置。然而，它们支持部署的基本单元本质上是<strong class="jm io">异构的</strong>的用例，即在固定的有序集合中管理 pod。</p><p id="74cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，它们用于部署在<strong class="jm io"> pod 边界</strong>内的持久位置维护状态的应用程序。k8 上的<strong class="jm io"> Redis、Kafka </strong>等应用程序利用有状态集来确保在 pod 扩大/缩小事件中的数据弹性。</p><h2 id="89ae" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">示例应用程序</h2><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="e58b" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">清单定义</h2><ol class=""><li id="6525" class="mn mo in jm b jn lu jr lv jv mp jz mq kd mr kh ms mt mu mv bi translated"><em class="ki">容器</em>部分命名为<em class="ki">sample-app</em><strong class="jm io"><em class="ki"/></strong>并从 dockerhub 位置<em class="ki">Amit 894/sample-app-1:1 . 0 . 0</em>提取图像</li><li id="77b0" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">规范中的<em class="ki">选择器</em>寻找带有匹配标签的应用程序作为<em class="ki">样本应用程序。</em></li><li id="bc48" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><em class="ki">规格</em>中的<em class="ki">复制品</em>创建了<em class="ki">样本 app </em> <strong class="jm io">的 3 个有序组。</strong></li><li id="83b1" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">服务<em class="ki">示例服务</em>用于控制带有标签的匹配 pod 的整体状态集。</li><li id="5262" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><em class="ki">种类</em>用于将对象类型指定为<em class="ki"> StatefulSet。</em></li><li id="4d59" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><em class="ki"> volumeClaimTemplate </em>用于定义存储数据的永久位置。</li></ol><h2 id="d1db" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">命令</h2><p id="7d9f" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">可以使用以下命令部署上面的示例部署</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="6ce5" class="lz kx in nc b gy ng nh l ni nj">kubectl apply -f sample-replica-set.yml</span></pre><p id="b7b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以使用下面的命令检查副本集的状态</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="1163" class="lz kx in nc b gy ng nh l ni nj">kubectl get rs</span></pre><h1 id="03e9" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">部署与</strong>有状态集</h1><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nk"><img src="../Images/cc8d702fab9db82801cf13eb0e807244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGT-Gcp-d5iKJJSrMECeMQ.png"/></div></div></figure><h1 id="b363" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="9f73" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">Kubernetes 主要用于在<strong class="jm io"> VCore </strong>和<strong class="jm io">内存</strong>大小方面运行轻量级 pod 的用例，以帮助根据自动扩展规则和配置动态扩展资源。因此，部署对象构成了最终客户的大部分自动化配置管道。然而，最近在部署拓扑中使用<strong class="jm io"> StatefulSets </strong>已经成为一种不断发展的模式，以支持生产中的<strong class="jm io">数据库、缓存集群和消息代理</strong>的有状态情况。</p><p id="a0ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>