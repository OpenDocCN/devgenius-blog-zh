<html>
<head>
<title>Flask Blog tutorial with Hexagonal Architecture(part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">六边形架构的 Flask 博客教程(第 3 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-3-9a265f0c4b95?source=collection_archive---------8-----------------------#2022-10-13">https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-3-9a265f0c4b95?source=collection_archive---------8-----------------------#2022-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5688fb3df07e18fc85641b31358a5003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebUHgG6JwawEifXlARgfzg.png"/></div></div></figure><p id="1b41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图片来自:<a class="ae kt" href="http://thinkmicroservices.com/blog/2019/hexagonal-architecture.html" rel="noopener ugc nofollow" target="_blank">http://thinkmicroservices . com/blog/2019/hexagon-architecture . html</a></p><p id="8e5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ShahriyarR/hexagonal-flask-blog-tutorial" rel="noopener ugc nofollow" target="_blank">该项目的 GitHub 回购</a></p><p id="c4ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa" rel="noopener">第一部分</a>中，我们已经推出了使用六角形架构重写原始<a class="ae kt" href="https://flask.palletsprojects.com/en/2.2.x/tutorial/" rel="noopener ugc nofollow" target="_blank"> Flask 博客教程</a>的想法和初始代码库。构建了端口和域模型</p><p id="a9f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/flask-blog-tutorial-with-hexagonal-architecture-part-2-8930ca009c27">第二部分</a>中，我们已经实现了适配器，Flask app 端点已经准备就绪。</p><p id="d5a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第三部分，也是最后一部分，我们将使用依赖注入容器将每个部分连接在一起，启动我们的应用程序。</p><h1 id="1b78" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用户容器</h1><p id="35b4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们将有一个 post 和用户容器，分别命名为<code class="fe lx ly lz ma b">src/main/user_containers.py</code>和<code class="fe lx ly lz ma b">src/main/post_containers.py</code>。</p><p id="6e57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看<code class="fe lx ly lz ma b">src/main/user_containers.py</code>有什么:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fbbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们引入了<code class="fe lx ly lz ma b">db_conn</code>作为一个“虚拟”依赖，它将被主容器中的实际实现所取代。</p><blockquote class="mh mi mj"><p id="d4ea" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b"><em class="in">src/main/containers.py</em></code>T27 这是主容器</p></blockquote><p id="9859" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们记得<code class="fe lx ly lz ma b">UserRepostory</code>接受实际的数据库连接作为依赖关系:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="adc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe lx ly lz ma b">UserContainer</code>中，我们正在初始化<code class="fe lx ly lz ma b">UserRepository</code>，将<code class="fe lx ly lz ma b">db_conn</code>作为“虚拟”依赖注入:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8575" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要创建带有用户存储库的<code class="fe lx ly lz ma b">UserService</code>实例，因为这是我们服务的依赖项:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8256" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次注意，用户服务不依赖于具体的<code class="fe lx ly lz ma b">UserRepository</code>，而是依赖于<code class="fe lx ly lz ma b">RepositoryInterface</code>，这是一个明显的依赖倒置原则。</p><p id="a515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的<code class="fe lx ly lz ma b">UserContainer</code>中，由于我们已经创建了<code class="fe lx ly lz ma b">user_repository</code>作为<code class="fe lx ly lz ma b">UserRepository</code>(它是一个<code class="fe lx ly lz ma b">RepositoryInterface</code>)的提供者，这意味着，我们可以将它注入到<code class="fe lx ly lz ma b">UserService</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="317f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">后集装箱</h1><p id="4913" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在我们来看看<code class="fe lx ly lz ma b">src/main/post_containers.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3a7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">思路同上，我们首先创建<code class="fe lx ly lz ma b">db_conn</code>“虚拟”依赖，然后用这个<code class="fe lx ly lz ma b">db_conn</code>初始化<code class="fe lx ly lz ma b">PostRepository</code>。</p><p id="b728" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，从<code class="fe lx ly lz ma b">PostService</code>创建<code class="fe lx ly lz ma b">post_service</code>提供者，并将<code class="fe lx ly lz ma b">post_repository</code>作为依赖项传递给<code class="fe lx ly lz ma b">PostService</code>。</p><h1 id="bb45" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">主容器</h1><p id="7918" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">主依赖注入器容器位于<code class="fe lx ly lz ma b">src/main/containers.py</code>:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="60b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一行<code class="fe lx ly lz ma b">containers.WiringConfiguration</code>请看这里:<a class="ae kt" href="https://python-dependency-injector.ets-labs.org/wiring.html#wiring-configuration" rel="noopener ugc nofollow" target="_blank">布线配置</a></p><blockquote class="mh mi mj"><p id="8552" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">我们一会儿将探讨它，现在请阅读文档。</p></blockquote><p id="3415" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意<code class="fe lx ly lz ma b">db_connection = get_db()</code>，如果您还记得在<code class="fe lx ly lz ma b">UserContainer</code>和<code class="fe lx ly lz ma b">PostContainer</code>中，我们将<code class="fe lx ly lz ma b">db_conn</code>定义为一个“虚拟”依赖。但是现在，我们有了具体的、真正的 DB 连接，我们已经将它注入到容器中。</p><p id="9987" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果，我们有了<code class="fe lx ly lz ma b">user_package</code>和<code class="fe lx ly lz ma b">blog_package</code>，它们存储了各自初始化的真实依赖关系。</p><h1 id="ded1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">烧瓶中的 PoC 终点:</h1><p id="9b72" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">回到<code class="fe lx ly lz ma b">register</code>终点(<code class="fe lx ly lz ma b">src/adapters/app/blueprints/auth.py</code>):</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d1aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意它是如何从主容器中注入的:<code class="fe lx ly lz ma b">Container.user_package.user_service</code>。这个实际的注射发生了。</p><h1 id="48ee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Flask create_app 工厂中的 PoC</h1><p id="1db2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在我们已经初始化 Flask 应用程序的<code class="fe lx ly lz ma b">src/adapters/app/application.py</code>中，有一个代码部分:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="340e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是初始化的主容器，它会自动将我们的烧瓶蓝图与 DI 容器连接在一起。</p><p id="f8f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经提供了蓝图的路径。</p><h1 id="cf3d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">运行应用程序</h1><p id="112d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">剩余步骤:</p><ul class=""><li id="4ea2" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">初始化数据库</li></ul><p id="18c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">flask --app src.adapters.app.application init-db</code></p><p id="cbbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">已初始化数据库。</p><ul class=""><li id="b24b" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">启动开发服务:</li></ul><p id="dd1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">flask --app src.adapters.app.application --debug run</code></p><pre class="mb mc md me gt mx ma my mz aw na bi"><span id="defe" class="nb kv in ma b gy nc nd l ne nf">* Serving Flask app 'src.adapters.app.application'<br/> * Debug mode: on<br/>WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.<br/> * Running on http://127.0.0.1:5000<br/>Press CTRL+C to quit</span></pre><p id="132a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这对我们来说是一次真正的旅程，让我们总结一下迄今为止我们所取得的成就:</p><ul class=""><li id="9ae6" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">我们已经实现了简单的六角形架构的博客 web 应用程序。</li><li id="03f7" class="mo mp in jx b jy ng kc nh kg ni kk nj ko nk ks mt mu mv mw bi translated">我们已经分离了应用程序的几乎每一部分。</li><li id="8daa" class="mo mp in jx b jy ng kc nh kg ni kk nj ko nk ks mt mu mv mw bi translated">从现在起，您可以自由地将 Flask 更改为瓶子或金字塔:只需更改 DI 容器连接并创建端点。</li><li id="c0ef" class="mo mp in jx b jy ng kc nh kg ni kk nj ko nk ks mt mu mv mw bi translated">从现在开始，很容易从 SQLite 切换到 PG 或 MySQL:只需实现 MySQL 或 PG 存储库，并在相关的地方注入它们。</li></ul></div></div>    
</body>
</html>