<html>
<head>
<title>Implementing Room Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施房间数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-room-database-bc9e4deb6600?source=collection_archive---------3-----------------------#2022-08-31">https://blog.devgenius.io/implementing-room-database-bc9e4deb6600?source=collection_archive---------3-----------------------#2022-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9de7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安卓| JAVA</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1910fcf75a634f8afdb5f400b46e44f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eQjIXWCD_rXb52rsISwRRA.gif"/></div></div></figure><p id="73fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">房间数据库是一个持久性库。</p><p id="092d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据持久化:- </strong>指应用程序从非易失性存储系统中持久化和检索信息。</p><p id="7a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">房间数据库是一种使用 SQL lite 的流畅方式，它更简单，减少了样板文件。room persistence 库在 SQL lite 上提供了一个抽象层，允许流畅的数据库访问，同时利用 SQL lite 的全部功能。</p><ul class=""><li id="cc8f" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">SQL 查询的编译时验证。</li><li id="852a" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">说服注释最大限度地减少重复和容易出错的样板代码。</li><li id="fa02" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">简化的数据库迁移路径。</li></ul><p id="5bfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="li">我已经用房间数据库创建了一个 TODO 应用程序。请查看视频，找到下面的 Github 链接。</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lj lk l"/></div></figure><h2 id="54d7" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">1.设置</h2><p id="cba6" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">要设置房间数据库，请将以下依赖项添加到 app.gradle 并同步项目</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0bf8" class="ll lm in mk b gy mo mp l mq mr"><em class="li">//Room Database<br/></em>implementation "androidx.room:room-runtime:2.2.5"<br/>annotationProcessor "androidx.room:room-compiler:2.2.5"</span></pre><h2 id="5ac6" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">2.正在创建数据库</h2><p id="a479" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们从创建 AppDatabase 类开始。这个类需要扩展房间数据库类。扩展后，我们将看到 3 个函数被这个房间数据库类覆盖。这个类是房间的主要类。</p><p id="3cb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须添加一个名为@database 的注释来保存模型类的版本和导出方案。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="19eb" class="ll lm in mk b gy mo mp l mq mr">@Database(entities = {Task.class}, version = 1, exportSchema = false)<br/>public  abstract class AppDatabase extends RoomDatabase {<br/><br/>    public abstract OnDataBaseAction dataBaseAction();<br/>    private static volatile AppDatabase <em class="li">appDatabase</em>;<br/><br/>    @NonNull<br/>    @Override<br/>    protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration config) {<br/>        return null;<br/>    }<br/><br/>    @NonNull<br/>    @Override<br/>    protected InvalidationTracker createInvalidationTracker() {<br/>        return null;<br/>    }<br/><br/>    @Override<br/>    public void clearAllTables() {<br/><br/>    }<br/>}</span></pre><p id="b76c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一个类是数据库客户机，它将是执行所有操作的访问点，如插入、删除、选择、创建、更新等。这个类的构造函数将初始化房间数据库，我们需要在这里添加数据库名称。我的数据库的名称是“task.db”。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0a65" class="ll lm in mk b gy mo mp l mq mr">public class DatabaseClient {<br/>    private Context mCtx;<br/>    private static DatabaseClient <em class="li">mInstance</em>;<br/><br/>    <em class="li">//our app database object<br/>    </em>private AppDatabase appDatabase;<br/><br/>    private DatabaseClient(Context mCtx) {<br/>        this.mCtx = mCtx;<br/>        appDatabase = Room.<em class="li">databaseBuilder</em>(mCtx, AppDatabase.class, "Task.db")<br/>                .fallbackToDestructiveMigration()<br/>                .build();<br/>    }<br/><br/>    public static synchronized DatabaseClient getInstance(Context mCtx) {<br/>        if (<em class="li">mInstance </em>== null) {<br/>            <em class="li">mInstance </em>= new DatabaseClient(mCtx);<br/>        }<br/>        return <em class="li">mInstance</em>;<br/>    }<br/><br/>    public AppDatabase getAppDatabase() {<br/>        return appDatabase;<br/>    }<br/>}</span></pre><h2 id="f746" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">3.数据访问对象</h2><p id="9fd2" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这是一个用@Dao 注释的接口。这包含了执行操作和与表交互的所有功能。一些基本操作有<strong class="jm io">选择、插入、删除、更新</strong>等。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4f48" class="ll lm in mk b gy mo mp l mq mr">@Dao<br/>public interface OnDataBaseAction {<br/><br/>    @Query("SELECT * FROM Task")<br/>    List&lt;Task&gt; getAllTasksList();<br/><br/>    @Query("DELETE FROM Task")<br/>    void truncateTheList();<br/><br/>    @Insert<br/>    void insertDataIntoTaskList(Task task);<br/><br/>    @Query("DELETE FROM Task WHERE taskId = :taskId")<br/>    void deleteTaskFromId(int taskId);<br/><br/>    @Query("SELECT * FROM Task WHERE taskId = :taskId")<br/>    Task selectDataFromAnId(int taskId);<br/><br/>    @Query("UPDATE Task SET taskTitle = :taskTitle, taskDescription = :taskDescription, date = :taskDate, " +<br/>            "lastAlarm = :taskTime, event = :taskEvent WHERE taskId = :taskId")<br/>    void updateAnExistingRow(int taskId, String taskTitle, String taskDescription , String taskDate, String taskTime,<br/>                            String taskEvent);<br/><br/>}</span></pre><h2 id="8703" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">4.数据实体</h2><p id="900f" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我有一个名为 Task 的实体，它基本上是我数据库中的表。这里，我的应用程序中只有一个表，根据我的要求，我必须有多个与一个相关的功能，所以一个对我来说就足够了。您可以根据您的要求添加尽可能多的表。实体必须实现 serializable，此模型中声明的所有其他变量都将是表的列。</p><p id="e289" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要声明主键，我们需要用@Primarykey 对其进行注释，该值可以自动生成，也可以添加我给定的主键的唯一值，自动生成为 true，这样一旦可以通过注释声明列，任务 id 就会自动创建<strong class="jm io"><em class="li">@ column info(name = { column _ name })</em></strong>添加 getter&amp;setter 将帮助我们设置和检索数据。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="7a38" class="ll lm in mk b gy mo mp l mq mr">@Entity<br/>public class Task implements Serializable {<br/><br/>    @PrimaryKey(autoGenerate = true)<br/>    int taskId;<br/>    @ColumnInfo(name = "taskTitle")<br/>    String taskTitle;<br/>    @ColumnInfo(name = "date")<br/>    String date;<br/>    @ColumnInfo(name = "taskDescription")<br/>    String taskDescrption;<br/>    @ColumnInfo(name = "isComplete")<br/>    boolean isComplete;<br/>    @ColumnInfo(name = "firstAlarmTime")<br/>    String firstAlarmTime;<br/>    @ColumnInfo(name = "secondAlarmTime")<br/>    String secondAlarmTime;<br/>    @ColumnInfo(name = "lastAlarm")<br/>    String lastAlarm;<br/>    @ColumnInfo(name = "event")<br/>    String event;<br/><br/>    public Task() {<br/><br/>    }<br/>}</span></pre><h2 id="b4b7" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">5.将数据插入表中</h2><p id="b6e8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们将使用 AsyncTask 作为 3 部分前，背景和后。对于 pre，也许我们可以添加一个进度条，并将其隐藏在帖子中，直到操作完成。主要部分将发生在 dolnBackground 函数中把所有的数据添加到模型类中并把它保存在数据库中。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="fedc" class="ll lm in mk b gy mo mp l mq mr">private void createTask() {<br/>    class saveTaskInBackend extends AsyncTask&lt;Void, Void, Void&gt; {<br/>        @SuppressLint("WrongThread")<br/>        @Override<br/>        protected Void doInBackground(Void... voids) {<br/>            Task createTask = new Task();<br/>            createTask.setTaskTitle(addTaskTitle.getText().toString());<br/>            createTask.setTaskDescrption(addTaskDescription.getText().toString());<br/>            createTask.setDate(taskDate.getText().toString());<br/>            createTask.setLastAlarm(taskTime.getText().toString());<br/>            createTask.setEvent(taskEvent.getText().toString());<br/>                DatabaseClient.<em class="li">getInstance</em>(getActivity()).getAppDatabase()<br/>                        .dataBaseAction()<br/>                        .insertDataIntoTaskList(createTask);<br/><br/>            return null;<br/>        }<br/><br/>        @Override<br/>        protected void onPostExecute(Void aVoid) {<br/>            super.onPostExecute(aVoid);<br/>            if (Build.VERSION.<em class="li">SDK_INT </em>&gt;= Build.VERSION_CODES.<em class="li">M</em>) {<br/>                createAnAlarm();<br/>            }<br/>            setRefreshListener.refresh();<br/>            Toast.<em class="li">makeText</em>(getActivity(), "Your event is been added", Toast.<em class="li">LENGTH_SHORT</em>).show();<br/>            dismiss();<br/><br/>        }<br/>    }<br/>    saveTaskInBackend st = new saveTaskInBackend();<br/>    st.execute();<br/>}</span></pre><h2 id="e8ee" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">6.更新表中的数据。</h2><p id="bc54" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">要更新表中的数据，我们需要获取主键，并使用主键的值找到列并更新其现有值。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f6f5" class="ll lm in mk b gy mo mp l mq mr">DatabaseClient.<em class="li">getInstance</em>(getActivity()).getAppDatabase()<br/>                        .dataBaseAction()<br/>                        .updateAnExistingRow(taskId, addTaskTitle.getText().toString(),<br/>                                addTaskDescription.getText().toString(),<br/>                                taskDate.getText().toString(),<br/>                                taskTime.getText().toString(),<br/>                                taskEvent.getText().toString());</span></pre><p id="618a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询:- </strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e942" class="ll lm in mk b gy mo mp l mq mr">@Query("UPDATE Task SET taskTitle = :taskTitle, taskDescription = :taskDescription, date = :taskDate, " +<br/>        "lastAlarm = :taskTime, event = :taskEvent WHERE taskId = :taskId")</span></pre><h2 id="daf5" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">7.从表中获取数据</h2><p id="51ab" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">一个非常常见的操作是获取表格并在屏幕上显示它，为此我们通常使用查询，如<strong class="jm io"> <em class="li"> SELECT * FROM Task </em> </strong>或<strong class="jm io"><em class="li">SELECT * FROM taskId =:taskId</em></strong>此查询将被添加到我们将调用的函数中，并将数据添加到 arraylist 中并显示数据。在我的例子中，我使用 recyclerView 来显示数据。</p><p id="e09c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询:- </strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="6446" class="ll lm in mk b gy mo mp l mq mr">@Query("SELECT * FROM Task WHERE taskId = :taskId")<br/>Task selectDataFromAnId(int taskId);</span><span id="c166" class="ll lm in mk b gy ms mp l mq mr">@Query("SELECT * FROM Task")<br/>List&lt;Task&gt; getAllTasksList();</span></pre><p id="b261" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码:- </strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c70f" class="ll lm in mk b gy mo mp l mq mr">private void getSavedTasks() {<br/><br/>    class GetSavedTasks extends AsyncTask&lt;Void, Void, List&lt;Task&gt;&gt; {<br/>        @Override<br/>        protected List&lt;Task&gt; doInBackground(Void... voids) {<br/>            tasks = DatabaseClient<br/>                    .<em class="li">getInstance</em>(getApplicationContext())<br/>                    .getAppDatabase()<br/>                    .dataBaseAction()<br/>                    .getAllTasksList();<br/>            return tasks;<br/>        }<br/><br/>        @Override<br/>        protected void onPostExecute(List&lt;Task&gt; tasks) {<br/>            super.onPostExecute(tasks);<br/>            noDataImage.setVisibility(tasks.isEmpty() ? View.<em class="li">VISIBLE </em>: View.<em class="li">GONE</em>);<br/>            setUpAdapter();<br/>        }<br/>    }<br/><br/>    GetSavedTasks savedTasks = new GetSavedTasks();<br/>    savedTasks.execute();<br/>}</span></pre><h2 id="8e4c" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">8.从表中删除列。</h2><p id="39cc" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个操作可以删除一列或删除整个表。</p><p id="cd03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询:- </strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="7678" class="ll lm in mk b gy mo mp l mq mr">@Query("DELETE FROM Task")<br/>void truncateTheList();</span><span id="ee3c" class="ll lm in mk b gy ms mp l mq mr">@Query("DELETE FROM Task WHERE taskId = :taskId")<br/>void deleteTaskFromId(int taskId);</span></pre><p id="6acd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码:- </strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="9938" class="ll lm in mk b gy mo mp l mq mr">private void deleteTaskFromId(int taskId, int position) {<br/>    class GetSavedTasks extends AsyncTask&lt;Void, Void, List&lt;Task&gt;&gt; {<br/>        @Override<br/>        protected List&lt;Task&gt; doInBackground(Void... voids) {<br/>            DatabaseClient.<em class="li">getInstance</em>(context)<br/>                    .getAppDatabase()<br/>                    .dataBaseAction()<br/>                    .deleteTaskFromId(taskId);<br/><br/>            return taskList;<br/>        }<br/><br/>        @Override<br/>        protected void onPostExecute(List&lt;Task&gt; tasks) {<br/>            super.onPostExecute(tasks);<br/>            removeAtPosition(position);<br/>            setRefreshListener.refresh();<br/>        }<br/>    }<br/>    GetSavedTasks savedTasks = new GetSavedTasks();<br/>    savedTasks.execute();<br/>}</span></pre><h2 id="1acd" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">房间数据库就这些。我正在下面添加 Github 链接。</h2><p id="4dd4" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated"><a class="ae mt" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbE81YkVqT1hZZXpKNWt1MUJXcTlXcVlSZk51Z3xBQ3Jtc0ttME9RWFhyV210M3loNm12UklMdTRSS1ZucWFzU0Z5TTdkamFVclFFRHVsbU1ZdTRsN0kwcjVkUzN1TDZCMGtpaGhNZWlrVG9PY1pxYm8yX0JsTi01MGs4WUNVTm0zRXZoMEJheHFLRUFjZW1USkxEcw&amp;q=https%3A%2F%2Fgithub.com%2FSha489%2Ftodo-list&amp;v=_qmU3tUQTBk" rel="noopener ugc nofollow" target="_blank">https://github.com/Sha489/todo-list</a></p><h2 id="da23" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">谢谢大家！</h2></div></div>    
</body>
</html>