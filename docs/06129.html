<html>
<head>
<title>Streaks in Pandas Time-Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫时间序列中的条纹</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/streaks-in-pandas-time-series-c63fe62aa771?source=collection_archive---------4-----------------------#2021-12-15">https://blog.devgenius.io/streaks-in-pandas-time-series-c63fe62aa771?source=collection_archive---------4-----------------------#2021-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在时间序列数据中寻找增长条纹</h2></div><p id="9031" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在金融时间序列数据中寻找增长或下降的痕迹。我们的数据集将是雅虎财经上的苹果股票价格。我们将使用<strong class="kh ir">熊猫</strong>和<strong class="kh ir">金融</strong>图书馆。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a6c5" class="lk ll iq lg b gy lm ln l lo lp">import pandas as pd<br/>import yfinance as yf</span><span id="3723" class="lk ll iq lg b gy lq ln l lo lp">df = yf.download("AAPL", period="60D", interval="15m")</span></pre><figure class="lb lc ld le gt ls gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/a98726555dc54b4b242593e66ab86461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*QN15e6QuNmx_F28R0viQoA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">来自雅虎财经熊猫数据框架的数据</figcaption></figure><p id="bffb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据框是一个时间序列，如果你想了解更多关于如何在熊猫身上处理它们，你可以阅读<a class="ae lz" href="https://medium.com/p/abc84d957650" rel="noopener">我的文章</a>。</p><h2 id="0a8e" class="lk ll iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">在雅虎财经时间序列中寻找条纹</h2><p id="d98a" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们将寻找股票价格增长的迹象。我们将比较时间序列中15分钟间隔的开盘价。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5a99" class="lk ll iq lg b gy lm ln l lo lp">df["growing"] = df[“Open”].gt(df[“Open”].shift())</span></pre><p id="3606" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将当前行与前一行进行比较。澄清一下，<strong class="kh ir"> shift() </strong>函数将值向前推一个周期。</p><figure class="lb lc ld le gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi lr"><img src="../Images/9670fe7b8b03863b02e5493f30c52d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*LlBI_AdwUc0qa_vDrKQgTQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">时间序列中的增长和衰退条纹</figcaption></figure><h2 id="d326" class="lk ll iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated"><strong class="ak">为条纹分配id</strong></h2><p id="e75d" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">要对上涨或下跌的条纹进行分组，我们必须首先确定每条条纹的起点。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a796" class="lk ll iq lg b gy lm ln l lo lp">df["streak_start"] = (df["growing"]<br/>                     .ne(df["growing"].shift()))</span></pre><p id="a413" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当前行和前一行之间的不相等表示新一轮的开始。也就是说，前一行中的下降和当前行中的增长(反之亦然)指示了连胜的开始。</p><figure class="lb lc ld le gt ls gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d7f562c7a85edd1ce90e1e139e80bc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*DE_U6Iyq0ekrPQa_KcH-yA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">增长或衰退的开始</figcaption></figure><p id="cc23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用streak_start列上的<strong class="kh ir"> cumsum() </strong>为单独的条纹分配增量id。我们还使用<strong class="kh ir"> cumcount() </strong>递增计数条纹的长度。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7274" class="lk ll iq lg b gy lm ln l lo lp">df[“streak_no”] = df[“streak_start”].cumsum()<br/>df[“streak_count”] = df.groupby(“streak_no”).cumcount().add(1)</span></pre><figure class="lb lc ld le gt ls gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9f265d0b08220597dacaa6d56f0be96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*Q8wD0FKeUJ8h1pTm6ENZsA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">时间序列中的条纹现在已经编号</figcaption></figure><h2 id="b1d8" class="lk ll iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">寻找时间序列中最长的条纹</h2><p id="9c60" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们想找到时间序列中最长的一串。我们使用<strong class="kh ir"> idxmax() </strong>函数来查找属性“streak_count”中最大值的索引。为了获得所有的例子，我们需要选择最大值索引以上的行。我们使用<strong class="kh ir"> tail() </strong>函数将它们限制到最大条纹的长度。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="69a0" class="lk ll iq lg b gy lm ln l lo lp">idx_max = df[“streak_count”].idxmax()<br/>max_streak_length = df.loc[idx_max, “streak_count”]<br/>df.loc[:idx_max, :].tail(max_streak_length)</span></pre><figure class="lb lc ld le gt ls gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8ed5b4ed49041821558117af2ded8fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*dihbsCsDvE4hVfYr9SOYnQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">最长的连胜纪录</figcaption></figure><p id="16d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的数据集中，最长的条纹是一个连续9个负区间的下降条纹。</p><h2 id="fedd" class="lk ll iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">总结条纹</h2><p id="eca2" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">假设我们想要所有条纹的摘要。我们根据“streak_no”列对数据帧进行分组，然后运行聚合函数，这将为我们提供连续数据的起点和终点。此外，我们还将使用一个自定义函数来计算股票的增长，我们根据条纹的大小对其进行排序。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ae87" class="lk ll iq lg b gy lm ln l lo lp">df.reset_index().loc[:, [“Datetime”, “Open”,”streak_no”]]\<br/>  .groupby(“streak_no”)\<br/>  .agg(<br/>    start = pd.NamedAgg(column=”Datetime”, aggfunc=”first”),<br/>    end = pd.NamedAgg(column=”Datetime”, aggfunc=”last”),<br/>    growth = pd.NamedAgg(<br/>             column=”Open”, <br/>             aggfunc=(lambda x: (x.iloc[-1]-x.iloc[0])/x.iloc[0])),<br/>    size = pd.NamedAgg(column=”Open”, aggfunc=”size”),<br/>).sort_values(by=”size”, ascending=False)</span></pre><figure class="lb lc ld le gt ls gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/343492dac9bf396bcb111c770625ee87.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*zwHK05I8GWfRRp9R18mxLQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">条纹摘要，按长度排序</figcaption></figure><h2 id="9540" class="lk ll iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">熊猫时间序列条纹综述</h2><p id="a6cb" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">计算条纹在时间序列数据中非常有用。在未来，我将写一篇关于如何使用这些类型的属性作为技术指标的教程。我的GitHub账户上有一个笔记本，里面有全部代码。</p><p id="2ade" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>