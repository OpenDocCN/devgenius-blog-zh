<html>
<head>
<title>How To Test a NodeJS Module using Mocha and Assert</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Mocha 和 Assert 测试 NodeJS 模块</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-test-a-nodejs-module-using-mocha-and-assert-c66c1c2e2a99?source=collection_archive---------12-----------------------#2022-03-14">https://blog.devgenius.io/how-to-test-a-nodejs-module-using-mocha-and-assert-c66c1c2e2a99?source=collection_archive---------12-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">软件测试是软件开发和质量保证不可或缺的一部分。测试可以帮助我们写出更好更高质量的代码，尽早发现歧义，抓住回归，自信地重构，并且在享受一杯咖啡的时候部署到生产<strong class="jm io"> ☕ </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7fb086f6e4a5e030ecb69db4a1037e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*4nVUlNIoCYYdg8iF"/></div></figure><p id="89da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要一个结构化的测试，用测试用例来验证我们的应用程序的不同行为。Mocha 是一个 JavaScript 框架，它组织我们的测试用例并为我们运行它们。尽管 Mocha 不会验证我们的测试行为，但我们将利用 Nodejs <code class="fe kq kr ks kt b">assert</code>库来验证我们的测试行为。</p><p id="c14a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">NodeJS 是建立在 Chrome 的 V8 引擎上的运行时环境，它使我们能够在 web 浏览器之外编写和运行 JavaScript。Node.js 使用事件驱动的非阻塞 I/O 模型，这使得它轻量级且高效，非常适合跨分布式设备运行的数据密集型实时应用程序。</p><p id="26c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">NodeJS 模块是具有特定功能的代码块，可以基于它们各自的功能与外部应用程序一起使用。NodeJS 模块的核心思想是封装性、可重用性和模块化。模块可以分为三个部分，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><ul class=""><li id="e3ee" class="kw kx in jm b jn jo jr js jv ky jz kz kd la kh lb lc ld le bi translated">本地模块:这些是我们可以在应用程序中本地创建的模块，并且可以在应用程序中重用。</li><li id="44b5" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh lb lc ld le bi translated">第三方模块:这些是由外部资源提供的模块，而不是我们的本地应用程序和 NodeJS 核心模块。Mocha 是一个第三方模块，我们必须从外部安装。</li></ul><h1 id="5eff" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">先决条件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/3397b3d42a8aae2d931a2a82ed4b955c.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/0*VrYcOJmfIltHhk_c"/></div></figure><h1 id="4ae2" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">核心 NodeJS 模块的示例用例</h1><p id="b44a" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">我们将编写一个名为<code class="fe kq kr ks kt b">core_modules.js</code>的简单 NodeJS 应用程序，它利用内置模块<code class="fe kq kr ks kt b">path</code>来打印我们程序的扩展类型<code class="fe kq kr ks kt b">.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="e476" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">path.extname</code>函数接受一个字符串参数(path)并返回路径中文件的扩展名。当我们在终端中运行命令<code class="fe kq kr ks kt b">node core_modules.js</code>来运行这段代码时。<code class="fe kq kr ks kt b">process.argv</code>是一个数组，其中的第二个元素(index <code class="fe kq kr ks kt b">1</code>)是我们正在运行的 JavaScript 文件的路径。</p><p id="8ce0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行上面的代码，我们应该得到结果:<code class="fe kq kr ks kt b">.js</code>。</p><p id="01e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将编写一个模拟学生管理应用程序的 NodeJS 模块。这个模块将能够存储学生名单，添加新的学生名单，获得学生名单和学生成绩之间的范围 0 至 100。</p><p id="d9f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具备上述先决条件后，我们将创建一个新文件夹并初始化我们的应用程序环境。在我们的终端中，我们将通过运行命令创建一个新文件夹</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="51ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过运行以下命令，将我们终端的当前工作目录更改为<code class="fe kq kr ks kt b">students-manager</code>文件夹</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="da61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将初始化<a class="ae mo" href="https://docs.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>，这是必需的，因为我们将通过 npm 安装 Mocha。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="cd52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">-y</code>选项允许 npm 使用默认选项启动我们的项目:</p><p id="2d76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将创建一个<code class="fe kq kr ks kt b">index.js</code>文件，在这里我们可以开始编写 NodeJS 模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="674e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们用一个构造函数创建了一个类，该构造函数将一个字符串数组(学生姓名)作为参数，并将每个数组项转换为一个具有<code class="fe kq kr ks kt b">id</code>、<code class="fe kq kr ks kt b">name</code>和<code class="fe kq kr ks kt b">performance</code>属性的对象。<code class="fe kq kr ks kt b">#students</code>是类的私有属性，只能在内部访问。</p><p id="6069" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">generateId</code>是一个帮助函数，它将<code class="fe kq kr ks kt b">counter</code>变量加 1，并返回<code class="fe kq kr ks kt b">counter</code>的当前值。返回值将用于为每个创建的学生生成唯一的<code class="fe kq kr ks kt b">id</code>。</p><p id="c9d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">generateId</code>和<code class="fe kq kr ks kt b">counter</code>代表模块的一个特性，即封装。封装帮助我们隐藏实现并暴露功能。真实世界的场景是车辆如何工作，我们中的许多人并不真正知道发动机和齿轮系统是如何工作的，我们接触到的是主要驾驶的汽车的功能。</p><p id="813a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个名为的方法，将学生添加到学生列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="1b6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">add()</code>方法获取一个字符串(学生姓名)并创建一个对象，该字符串作为<code class="fe kq kr ks kt b">name</code>属性，学生成绩设置为<code class="fe kq kr ks kt b">null</code></p><p id="aee1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们想要添加一批学生姓名，使用同一个函数添加单个姓名或多个姓名参数是有意义的，因此我们将重写<code class="fe kq kr ks kt b">add()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="5c76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将包含一个名为<code class="fe kq kr ks kt b">getStudent()</code>的方法，该方法返回学生及其详细信息的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="60c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据<code class="fe kq kr ks kt b">studentIdOrName</code>是否作为参数传递，<code class="fe kq kr ks kt b">getStudent()</code>方法以两种方式工作。<code class="fe kq kr ks kt b">studentIdOrName</code>可以是学生的 id(数字)，也可以是学生的名字(字符串)。</p><p id="ab71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果找到学生的<code class="fe kq kr ks kt b">id</code>或<code class="fe kq kr ks kt b">name</code>，该方法只返回一个学生，否则它只返回整个学生列表。</p><p id="2b66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用的是数组方法<code class="fe kq kr ks kt b">filter()</code>。<code class="fe kq kr ks kt b">filter()</code>遍历数组中的每一项，并通过我们传递给它的回调函数来访问该项。如果回调返回 true，<code class="fe kq kr ks kt b">filter()</code>将在结果中包含该项。</p><p id="eda8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个能够给学生评分的方法，该函数将采用两个参数，一个用于学生 id，另一个用于学生的分数，该分数应该是一个介于<strong class="jm io"> 0 </strong>和<strong class="jm io"> 100 </strong>之间的数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="200d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的<code class="fe kq kr ks kt b">score()</code>方法检查<code class="fe kq kr ks kt b">performance</code>是否在<strong class="jm io"> 0 - 100 </strong>的范围内，如果参数小于<strong class="jm io"> 0 </strong>或大于<strong class="jm io"> 100 </strong>，我们将抛出一个错误。该方法检查学生列表，找到与方法的第一个参数中提供的<code class="fe kq kr ks kt b">id</code>相似的学生。</p><p id="1e0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，<code class="fe kq kr ks kt b">index.js</code>文件还不是一个模块，所以我们需要导出它，使它可以在我们的本地应用程序中重用，并测试它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="0f51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">NodeJS 对模块使用 CommonJS 约定，因此我们现在已经导出了模块，并准备好在本地应用程序中使用。</p><p id="6088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦完成，我们的<code class="fe kq kr ks kt b">index.js</code>应该类似于这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="f46b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将手动使用我们的项目，看看它是如何工作的。</p><p id="1e07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在我们的<strong class="jm io"> students-manager </strong>文件夹的根目录下创建一个<code class="fe kq kr ks kt b">demo.js</code>文件，并通过调用<code class="fe kq kr ks kt b">require</code>函数来使用该模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="fb17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们通过调用<code class="fe kq kr ks kt b">node demo.js</code>来运行这个应用程序时，我们可以看到结果验证了模块如预期的那样工作。</p><p id="151b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是结果截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/8aa9ab2a3f2647ea82d3587301398830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ho1nDUDwHxOMECJK"/></div></div></figure><p id="c334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记得当我们谈到 NodeJS 模块时，我们谈到了不同类型的模块，<code class="fe kq kr ks kt b">assert</code>是内置模块，而 mocha 是外部模块，因此我们必须使用<a class="ae mo" href="https://docs.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>将其安装到我们的项目中。</p><p id="aff7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的终端中，确保我们仍然在<code class="fe kq kr ks kt b">students-manager</code>目录中，我们将通过运行以下命令来安装 mocha:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="29a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">--save-dev</code>标志将 mocha 作为开发依赖项保存在我们的 NodeJS 中，因为我们只想在开发阶段编写测试，而不想将它们包含在生产部署中。</p><p id="1fc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建我们的测试文件，名为<code class="fe kq kr ks kt b">index.test.js</code>，包括我们的本地<code class="fe kq kr ks kt b">StudentManager</code>模块和当前工作目录中的<code class="fe kq kr ks kt b">asset</code>模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="2b78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Mocha 帮助我们组织和运行测试。测试结构通常如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="8a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kq kr ks kt b">it</code>函数包含我们的测试代码。这是我们使用断言模块来测试<code class="fe kq kr ks kt b">StudentManagement</code>模块的地方。</p><p id="af50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于 Mocha 来说,<code class="fe kq kr ks kt b">describe</code>函数并不是运行我们的测试所必需的，但是它有助于对我们的测试进行分组并轻松地管理它们。</p><p id="e66c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们定义我们的测试用例，并编写这些测试用例的实现。</p><h1 id="6034" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">测试案例</h1><ul class=""><li id="7697" class="kw kx in jm b jn mj jr mk jv mu jz mv kd mw kh lb lc ld le bi translated">用三个名字初始化我们的模块:Abel，Ben 和 Cain</li><li id="bf97" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh lb lc ld le bi translated">确认该模块共有三名学生</li><li id="2153" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh lb lc ld le bi translated">添加两个新学生，并确认学生人数增加到 5 人</li><li id="6f0e" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh lb lc ld le bi translated">给 Abel 打 50 分，并确认该分数包含在 Abel 绩效指标中</li><li id="2194" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh lb lc ld le bi translated">给 Ben 打 120 分，确认模块抛出错误</li></ul><h1 id="fcf0" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">测试实现</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><h1 id="cd5d" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">代码走查</h1><ol class=""><li id="3a29" class="kw kx in jm b jn mj jr mk jv mu jz mv kd mw kh mx lc ld le bi translated"><code class="fe kq kr ks kt b">describe()</code>:我们之前提到的这个函数用于对我们的测试进行分组，并向测试添加一个描述。因为我们将测试添加到了这个块中，所以<code class="fe kq kr ks kt b">before()</code>方法是一个在第一个测试开始之前运行的钩子。在这个块中定义了一个<code class="fe kq kr ks kt b">testClass</code>,使它对我们所有的测试都是全局可用的。</li><li id="3ce8" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh mx lc ld le bi translated"><code class="fe kq kr ks kt b">assert.equal()</code>检查两个变量是否相等，它使用<code class="fe kq kr ks kt b">==</code>运算符。与<code class="fe kq kr ks kt b">assert.strictEqual()</code>不同，这种类型的等式检查试图将不同类型的变量转换为相同的时间。<code class="fe kq kr ks kt b">assert.strictEqual()</code>使用了<code class="fe kq kr ks kt b">===</code>操作符。</li><li id="5aea" class="kw kx in jm b jn lf jr lg jv lh jz li kd lj kh mx lc ld le bi translated"><code class="fe kq kr ks kt b">assert.deepEqual()</code>用于检查对象的相等性，比较对象的可枚举属性</li></ol><p id="052f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了运行我们的测试，我们将使用<strong class="jm io"> Mocha </strong>，在我们的终端中，在当前工作目录<code class="fe kq kr ks kt b">students-manager</code>的根目录下运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="2b1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是 npm 有一个特性，我们可以定义不同的命令集，并使它们简单和共享。这些命令位于我们的<code class="fe kq kr ks kt b">package.json</code>文件的<code class="fe kq kr ks kt b">scripts</code>部分。</p><p id="a264" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们运行<code class="fe kq kr ks kt b">npm init -y</code>时，npm 为我们创建了一个<code class="fe kq kr ks kt b">package.json</code>文件，当我们安装 Mocha 时，npm 更新了这个文件以便与安装的依赖项一起使用。</p><p id="3202" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建我们的脚本，名为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="3ab3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们的 final <code class="fe kq kr ks kt b">package.json</code>应该类似于这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="44b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们通过运行终端来开始我们的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="f6a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在终端中测试的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi my"><img src="../Images/318faf21776a7e134d0d39d3f1e2661d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Bx2mm-Ax6-h8pke"/></div></div></figure><p id="a52c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们介绍了 NodeJS 模块，如何在我们的应用程序中要求模块，以及如何创建我们的模块。我们创建了一个模拟学生管理应用程序的 NodeJS，并用 Mocha 和 assert 编写了基于该模块所公开的功能的测试，以验证我们的测试，并享受了一杯咖啡</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7569e5eacec149f332e248e63fb2f5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*0FZ-FpXa-KVQri2c"/></div></figure><p id="321a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Mocha 是一个功能丰富的 JavaScript 测试框架，运行在<a class="ae mo" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>和浏览器中，使异步测试<em class="na">变得简单</em>和<em class="na">有趣</em>。Mocha 测试连续运行，允许灵活和准确的报告，同时将未捕获的异常映射到正确的测试用例。</p><p id="3489" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过为后续的 NodeJS 模块编写测试来挑战自己。</p><p id="8360" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要深入了解摩卡，可以查看<a class="ae mo" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">官方摩卡文档</a>。为了继续学习 NodeJS 模块，您可以查看关于模块的<a class="ae mo" href="https://nodejs.org/api/modules.html" rel="noopener ugc nofollow" target="_blank"> NodeJS 文档</a></p><p id="00ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢读这篇文章，你可以考虑<a class="ae mo" href="https://www.buymeacoffee.com/kayode" rel="noopener ugc nofollow" target="_blank">请我喝杯咖啡</a></p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="45fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="na">最初发布于</em><a class="ae mo" href="https://blog.z4ff.dev" rel="noopener ugc nofollow" target="_blank"><em class="na">blog . z4ff . dev</em></a></p></div></div>    
</body>
</html>