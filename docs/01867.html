<html>
<head>
<title>Optimizing your React application (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化 React 应用程序(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimizing-your-react-application-part-1-fb1a9398cc30?source=collection_archive---------18-----------------------#2020-07-13">https://blog.devgenius.io/optimizing-your-react-application-part-1-fb1a9398cc30?source=collection_archive---------18-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/57d3d79eeab0c0833ef6524d0cd085e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3yXxepxRwFEhU_1Y2a3gA.jpeg"/></div></div></figure><p id="62cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您创建了一个令人惊叹的网站，添加了精美的动画，并确保您的应用程序免受任何可能的攻击。但是等等，在你称你的网站完整之前，问问你自己这个非常重要的问题，<strong class="jx io">你优化它了吗？</strong></p><blockquote class="kt ku kv"><p id="a24e" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">“哇！！React 开箱速度如此之快，我为什么还要费心呢？”</p><p id="d471" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">"我肯定花了 15 分钟思考优化，这算吗？"</p><p id="a6b7" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">“我的应用程序如我所愿地工作，我的工作完成了。”</p></blockquote><p id="5773" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我被告知要让我的应用程序更有性能时，我经常这么说，但现在我已经意识到，一个经过良好优化的应用程序可以决定一个<strong class="jx io">优秀的 web 应用程序</strong>和一个<strong class="jx io">优秀的 web 应用程序</strong>。现在，让我们快速了解一下如何提供最佳用户体验。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="651e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">优化可能意味着各种各样的事情，这取决于您正在构建的内容，但是这里我们关注以下内容</p><ul class=""><li id="808e" class="lh li in jx b jy jz kc kd kg lj kk lk ko ll ks lm ln lo lp bi translated">页面加载 :-你的页面加载需要多长时间？用户必须花很长时间才能看到弹出的第一个屏幕吗？</li><li id="0ede" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">资源利用</strong> :-您对客户端浏览器资源的利用情况如何？</li><li id="6f3e" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">缓存</strong></li></ul><p id="56c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一部分，我们将关注更快的页面加载。</p><h1 id="d8a4" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">更快…更快的页面加载</h1><p id="b0b1" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">很简单，如果你让你的用户等很长时间，他们可能不会再回来。你甚至想使用一个让你等 10 秒钟才显示第一页的网站吗？</p><blockquote class="my"><p id="817a" class="mz na in bd nb nc nd ne nf ng nh ks dk translated">目标是为 90%的用户在 1.5 秒内加载你的第一页。</p></blockquote><p id="45cb" class="pw-post-body-paragraph jv jw in jx b jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated">重要的是要注意，你的大多数用户可能没有使用非常快速的互联网，他们的体验将与你的大不相同，因为你将在一台拥有惊人互联网的伟大机器上开发它。加快页面加载的步骤非常简单明了</p><ul class=""><li id="f46a" class="lh li in jx b jy jz kc kd kg lj kk lk ko ll ks lm ln lo lp bi translated">javascript 文件越大，下载的时间就越长。所以我们需要把它变小。</li><li id="4bd8" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">妥善处理图像</strong>。将图像调整到合适的大小。我们不想下载 1080 X 1080 的图像来加载到 50 X 50 的框架中。</li><li id="b6eb" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated">如果您需要进行网络调用以获取一些数据来显示您的第一个页面，<strong class="jx io">将其与闪屏/欢迎屏幕</strong>交换，并在后台加载所需的数据，然后转换到主屏幕。用户更喜欢一个好的欢迎屏幕，而不是看到一个 5 秒钟后就填满的空白页面。</li></ul><h1 id="6d49" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">分割 Javascript 文件</h1><p id="d056" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">如果您已经使用了"<strong class="jx io">create</strong>-<strong class="jx io">react</strong>-<strong class="jx io">app "</strong>来设置您的应用程序，或者如果您是喜欢冒险的类型，并且已经决定使用<strong class="jx io"> Webpack </strong>、<strong class="jx io"> Rollup </strong>或任何其他变体从头开始配置您的捆绑包，那么您可能已经生成了一个简洁的小型 javascript 文件。是时候更进一步，让这个缩小的文件变得更小了！😜</p><h2 id="156a" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">介绍代码分割和延迟加载</h2><blockquote class="kt ku kv"><p id="6b82" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">“代码拆分永远改变了我的生活，我的网站每天有 5 个用户，在我花了 3 个小时拆分我的 javascript 后，我的活跃用户增加到了 1000”——张诗钟，一个卖糖网站的老板。</p></blockquote><p id="d313" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">代码拆分</strong> :-让我们将缩小后的 javascript 文件拆分成多个更小的文件，这样就不会一次全部下载到客户端。</p><p id="55b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">惰性加载</strong> :-我们将只下载显示用户所在页面所必需的东西。如果用户在登录页面上，我们不需要下载用户资料页面。</p><p id="dfbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">受够了什么，让我们进入如何！！</strong></p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h2 id="4457" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">步骤 1:分析您的 javascript 包</h2><p id="05c9" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">我们需要<strong class="jx io">看看</strong>当你构建你的应用时捆绑框架(Webpack，Rollup)到底创建了什么，我用过的最好的捆绑可视化工具是:-</p><ul class=""><li id="b5f5" class="lh li in jx b jy jz kc kd kg lj kk lk ko ll ks lm ln lo lp bi translated"><strong class="jx io">网络包</strong>:-<a class="ae nz" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/webpack-bundle-analyzer</a></li><li id="6757" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">上卷</strong>:-<a class="ae nz" href="https://www.npmjs.com/package/rollup-plugin-visualizer" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/rollup-plugin-visualizer</a></li></ul><p id="fded" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照说明设置 bundle analyzer，运行命令后，您应该能够在浏览器中看到类似下面的内容。</p><figure class="ob oc od oe gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/b57679320f46c044c98ddd91d8e33605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tPm4sMSQa4BMmorXXNDBA.png"/></div></div></figure><p id="8d44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您已经可视化了您的包，您将不得不瞄准最大的盒子并钻取它们，将它们分成更小的块。</p><p id="90e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上图是一个拆分良好的应用程序的例子，整个应用程序的大小是<strong class="jx io"> 3.84MB </strong>，它被拆分成几个更小的块，其中最大的块是<strong class="jx io"> 647kb </strong>。</p><h2 id="d127" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">第二步:弄清楚要分割什么</h2><p id="3bec" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">虽然一开始很难确定要拆分什么，但是你可以从<strong class="jx io">拆分应用程序的不同页面</strong>开始。</p><p id="f8f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个例子，我们假设你有三个页面，<strong class="jx io">一个登录页面</strong>，<strong class="jx io">一个个人资料页面，</strong>和<strong class="jx io">主页</strong>。现在，当用户登陆您的网站时，您应该显示登录页面，并在认证后，将用户重定向到个人资料页面。因此，如果用户只在登陆你的网站时看到登录页面，我们<strong class="jx io">不需要</strong>来下载个人资料和主页的资产(javascript、图片等)。这就是基于页面或路线的拆分。</p><p id="87ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种分割方法是考虑页面加载时屏幕上可见的所有内容<strong class="jx io">和从该页面中分离出剩余的内容</strong>。例如，如果我有几个当用户执行一个动作时打开的对话框，我可以把它们从代码中分离出来，因为它们只在用户执行动作时需要。</p><h2 id="d872" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">第三步:把它分开</h2><p id="264c" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">我们将使用<strong class="jx io"> React.lazy </strong>和<strong class="jx io"> React。暂停</strong>执行基于路线的代码拆分。</p><figure class="ob oc od oe gt jo"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4f7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个简单的组件，使用<a class="ae nz" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> react-router-dom </a>设置了 3 条路由，它将基于当前路由加载 Home、Login 和 Profile。如果您没有根据路由对代码进行分割，那么这就是您的代码最初的样子。</p><figure class="ob oc od oe gt jo"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="78b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经成功地实现了基于路由的代码拆分。👏</p><ul class=""><li id="ad53" class="lh li in jx b jy jz kc kd kg lj kk lk ko ll ks lm ln lo lp bi translated">长相怪异的<strong class="jx io">进口("。/profile") </strong>陈述:-整个魔术在这里发生。当捆绑工具(如 Webpack)遇到导入语句或动态导入时，它会自动将代码拆分成不同的捆绑包。所以基本上现在我已经创建了 3 个额外的<strong class="jx io">块</strong>(Home、Login 和 Profile)，最小化了将阻塞页面加载的主 javascript 文件的大小。动态导入语句返回一个用下载的文件解析的承诺。点击此处了解更多信息。</li><li id="080d" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">lazy()</strong>:-lazy 方法或<a class="ae nz" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> React.lazy() </a>允许我们延迟加载任何组件，这意味着如果用户在登录页面上，我们将<strong class="jx io">而不是</strong>下载 Home 包或 Profile 包。</li><li id="c180" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io">做出反应。悬疑</strong> :-反应。暂停或暂停组件负责加载已经下载的懒惰组件。在上面的场景中，用户登录后，他将被重定向到主屏幕，然后 React 将检测到需要下载主块，并开始下载。那么，在请求的数据块完全下载完之前会发生什么呢？悬念组件需要一个名为<strong class="jx io"> fallback，</strong>的道具，在这里你可以传递另一个组件或字符串，这个 fallback 组件会显示在屏幕上，直到所请求的块被完全下载。</li><li id="de6f" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><strong class="jx io"> webpackChunkName </strong> ":-该注释通知 Webpack 用指定的字符串命名包，否则，Webpack 将随机命名，这将使我们在使用 bundle visualizer 时更难分析。</li></ul><p id="00fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用回退道具，您可以使用圆形微调器、框架页面等在页面之间切换，以确保流畅的体验。</p><p id="410b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">查看它的运行情况:-</p><figure class="ob oc od oe gt jo"><div class="bz fp l di"><div class="oh og l"/></div></figure><p id="b74a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，只有当您第一次单击 Profile 选项卡或 Login 选项卡时，才会显示文本<strong class="jx io">“LOADING”</strong>。这是因为下载完块后，下次需要这些组件时，它们将被重用。</p><p id="46ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以对非路由/页面做同样的事情。</p><figure class="ob oc od oe gt jo"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2d27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们用 lazy 包装对话框，因为它只有在按钮被点击时才会显示。因为按钮组件在页面加载过程中是可见的，所以我们导入它通常不像对话框那样。</p><h1 id="33d1" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">处理图像</h1><blockquote class="kt ku kv"><p id="4fd4" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">“人们过去常常抱怨突然出现的图像让我的网站变得紧张不安。我修好了它，现在每个人都很开心”——Twinkle，天文学博客 Little Wonder 的联合创始人</p></blockquote><p id="8d87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图像不是渲染阻塞资源，不像 javascript，即使所有的图像都没有下载，页面也会加载，一旦完成，它们就会显示在页面上。然而，看到页面上的空白随着时间的推移慢慢填满并不是一种很好的体验。</p><h2 id="0b3f" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">使用正确的图像格式</h2><p id="f346" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">你需要做的第一件事是通过使用合适的格式来减小图像的尺寸。jpeg ，。<strong class="jx io"> png </strong> …)。并非所有的格式都是一样的，有些格式比另一些格式占用更大的空间，而另一些格式质量更好。你需要找出哪一个最适合你的网站。</p><p id="89c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击阅读更多关于各种网络图像格式的信息<a class="ae nz" href="https://themeisle.com/blog/best-image-format/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="c432" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">压缩图像</h2><p id="fba8" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">接下来，我们将尝试在不损失丝毫质量的情况下缩小图像的尺寸。尝试对您的图像进行无损压缩。有几种工具可以帮助压缩图像。我个人比较喜欢的一个在线工具是<a class="ae nz" href="https://compressor.io/" rel="noopener ugc nofollow" target="_blank"> Compressor.io </a>。只需上传图像，压缩，并下载和使用压缩版本。</p><h2 id="a7b3" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">调整图像大小</h2><p id="1c43" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">根据您希望在网站上显示图像的框架来调整图像的大小。当你想展示它的 100 X 100 版本时，不要使用高分辨率的大图。</p><h2 id="9524" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">渐进式加载图像</h2><p id="f6a0" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">这是我最喜欢的展示图像的方式。渐进式加载指的是先下载图像的模糊版本，一旦准备好，就用高分辨率版本替换它。</p><p id="577b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">https://www.npmjs.com/package/react-progressive-image 的<a class="ae nz" href="https://www.npmjs.com/package/react-progressive-image" rel="noopener ugc nofollow" target="_blank">是一个很好的图书馆，可以很好地处理这个问题。</a></p><p id="c433" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">参见下面的渐进图像:</p><figure class="ob oc od oe gt jo"><div class="bz fp l di"><div class="oh og l"/></div></figure><h2 id="0510" class="nn lw in bd lx no np dn mb nq nr dp mf kg ns nt mj kk nu nv mn ko nw nx mr ny bi translated">最后的结果</h2><p id="ab65" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">完成所有更改后，是时候看看您的应用程序是否有所改进了。我使用以下工具来确定我的网站性能:-</p><ul class=""><li id="f343" class="lh li in jx b jy jz kc kd kg lj kk lk ko ll ks lm ln lo lp bi translated">【https://developers.google.com/speed/pagespeed/insights/ T4】</li><li id="df17" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><a class="ae nz" href="https://www.webpagetest.org/" rel="noopener ugc nofollow" target="_blank">https://www.webpagetest.org/</a></li><li id="9bcf" class="lh li in jx b jy lq kc lr kg ls kk lt ko lu ks lm ln lo lp bi translated"><a class="ae nz" href="https://gtmetrix.com/" rel="noopener ugc nofollow" target="_blank">https://gtmetrix.com/</a></li></ul><p id="a2f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用上述资源，通过模拟不同的网络速度来衡量您的网站性能。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="c23b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是本系列的第一部分。在下一部分中，我们将进一步了解<strong class="jx io">如何分析 React 应用程序</strong>并通过<strong class="jx io">优化组件的渲染</strong>来提高性能。</p></div></div>    
</body>
</html>