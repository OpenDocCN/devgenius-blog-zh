<html>
<head>
<title>Ruby: Tips on working with Functions, Recursions, Scope, and Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby:使用函数、递归、作用域和块的技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-tips-on-working-with-functions-recursions-scope-and-blocks-dda3a6e86967?source=collection_archive---------2-----------------------#2020-08-20">https://blog.devgenius.io/ruby-tips-on-working-with-functions-recursions-scope-and-blocks-dda3a6e86967?source=collection_archive---------2-----------------------#2020-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/b09e7c7946ffb0d1c7509d854b65415d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DENauUixUf2DS-VfgKCXlA.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk">1337</figcaption></figure><div class=""/><div class=""><h2 id="69a2" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">只是一些在Ruby函数和块中使用变量引用的提示和指针。</h2></div><h2 id="f8c8" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">背景</h2><p id="3cf3" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">我一直在为技术面试学习:在Leetcode上做一堆问题，每当我需要对DFS或任何其他问题使用递归时，我真的很困惑，遇到了很多错误。</p><p id="6ac2" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">更具体地说，当我需要将变量传入递归函数并更新某种类型的<code class="fe mk ml mm mn b">counter</code>变量时。</p><p id="db95" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">如果你们一直在练习Leetcode，我相信你们已经看到了一个问题:<a class="ae mo" href="https://leetcode.com/problemset/all/?search=number%20of%20islands" rel="noopener ugc nofollow" target="_blank">岛屿数量问题</a>。比方说，除了记录岛屿的数量之外，我还想记录有多少陆地。所以每当我遇到一个‘1’，我需要在递归时增加一个计数器。</p><p id="841e" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">每当我试图传入一个“计数器”变量并在我的递归中更新计数器变量时，它都不会得到我想要的更新。在我的函数中修改它之后，计数器保持了我最初设置的变量。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f410" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">所以，在这篇文章中，我想回顾一下我在RUBY中处理变量、作用域和递归之后的发现，以及任何其他关于递归和搜索算法的通用技巧。</p><h2 id="6b85" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">按值传递</h2><p id="c3f2" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">首先，上面的例子不起作用，因为<strong class="lo jc"> Ruby是一种通过值传递的语言。</strong></p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c87d" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">当我们<code class="fe mk ml mm mn b">puts x</code>调用我们的方法后，我们仍然得到0，因为函数定义内的<code class="fe mk ml mm mn b">b</code>没有引用函数外的变量<code class="fe mk ml mm mn b">x</code>。<code class="fe mk ml mm mn b">b</code>实际上只是指向同一个值的完全不同的变量。</p><p id="02a4" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">当我们用<code class="fe mk ml mm mn b">x</code>调用函数时会发生什么:</p><ol class=""><li id="1f18" class="mv mw jb lo b lp mf ls mg kz mx ld my lh mz me na nb nc nd bi translated">该函数创建一个名为<code class="fe mk ml mm mn b">b</code>的局部变量，并将其设置为等于传入的值。('指针<code class="fe mk ml mm mn b">b</code>指向int 0的内存位置')。</li><li id="94d4" class="mv mw jb lo b lp ne ls nf kz ng ld nh lh ni me na nb nc nd bi translated">然后，它将局部变量<code class="fe mk ml mm mn b">b</code>设置为2。(' Point <code class="fe mk ml mm mn b">b</code>指向int 2的新内存位置')。</li></ol><p id="50bc" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">因此，函数没有改变后，位置<code class="fe mk ml mm mn b">x</code>仍然指向0。您可以使用<strong class="lo jc"> object_id检查变量指向的对象。我建议你试验一下object _ ids，看看变量赋值是如何工作的。</strong></p><h2 id="c094" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">修改函数中的数组</h2><p id="fa21" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">我们可以在函数内部修改外部变量的一种方法是传入一个数组(和一个散列)。执行数组修改，如<code class="fe mk ml mm mn b">push</code>、<code class="fe mk ml mm mn b">pop</code>和<code class="fe mk ml mm mn b">shift</code>、<strong class="lo jc">会改变对象内存位置</strong>中的数组。然而，赋予一个新值是将变量指向内存中的一个新对象。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d7fd" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">因此，无论出于什么原因，你需要在递归时跟踪一些答案列表，你可以只传入一个数组并修改它。</p><h2 id="6ac1" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们能不能只修改函数中的外部变量而不传入变量？</h2><p id="e431" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">不，我们不能。(我应该说‘不，我们不能用经典的Ruby函数定义<em class="nj">’，我们稍后会谈到这一点。)</em></p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f70c" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated"><strong class="lo jc"> Ruby函数定义创建自己不同的作用域。</strong>因此它们被称为<strong class="lo jc">范围门</strong>。他们不能访问在函数外声明的变量。</p><h2 id="94a8" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">那么，我们如何在Ruby函数中不断修改计数器变量呢？</h2><p id="018d" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">第一种方法是使用全局变量(使用键<code class="fe mk ml mm mn b">$</code>创建的全局变量)，但是使用全局变量通常不被认可，所以我们将讨论其他方法。</p><h2 id="0ba2" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">阻碍</h2><p id="aff6" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">我们可以用积木。块是我们以后可以调用的代码块(它们本质上是函数，但属性略有不同)。它们通常被传递给类似于<code class="fe mk ml mm mn b">array.map</code>中的函数。</p><p id="2451" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated"><code class="fe mk ml mm mn b">[1, 2, 3].map {|x| x+1}</code></p><p id="72e8" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">你可以阅读更多关于块如何工作和块的细节，但重要的是<strong class="lo jc">块有闭包</strong>，这意味着当块稍后被调用时，它们可以引用在与块定义相同的作用域中定义的变量和方法。</p><p id="d08f" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">更简单地说，块可以使用在块外部定义的变量和方法。</p><p id="8efc" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">我们可以用两种不同的方式定义块:</p><ol class=""><li id="ed87" class="mv mw jb lo b lp mf ls mg kz mx ld my lh mz me na nb nc nd bi translated"><strong class="lo jc">λs</strong>和<strong class="lo jc">过程</strong></li></ol><p id="cba1" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">当我第一次开始使用递归时，我使用lambdas和procs，因为我在使用普通的Ruby函数时遇到了很多问题。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ecf6" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">Lambdas和procs只是我们可以存储在变量中的Ruby块。我们可以使用关键字<code class="fe mk ml mm mn b">lambda</code>或<code class="fe mk ml mm mn b">proc</code>来定义它们。稍后我们可以使用<code class="fe mk ml mm mn b">lambda_name.call(any_args)</code>或<code class="fe mk ml mm mn b">proc_name.call(any_args)</code>调用<code class="fe mk ml mm mn b">lambda</code>或<code class="fe mk ml mm mn b">proc</code>。</p><p id="c908" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">你可以在这里阅读更多关于lambdas和procs <a class="ae mo" href="https://www.rubyguides.com/2016/02/ruby-procs-and-lambdas/#:~:text=Lambdas%20are%20defined%20with%20%2D%3E%20%7B%7D%20and%20procs%20with%20Proc.&amp;text=Procs%20return%20from%20the%20current,lambdas%20will%20raise%20an%20exception." rel="noopener ugc nofollow" target="_blank">的内容，但重要的是<strong class="lo jc"> lambdas和procs是块，因此有闭包</strong>。</a></p><p id="8504" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">如果你打算使用lambdas和procs，你应该知道procs和lambdas是如何处理返回语句的。</p><p id="4cfe" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">Proc 'returns '将从调用Proc的方法中返回。而兰姆达斯只从兰姆达斯本身返回。</p><p id="6f6e" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">procs的一个用例是，如果你递归遍历一个结构，当你找到目标时，你想从外部函数返回值。如果你想让你的程序块像普通函数一样返回，就使用lambdas。</p><h2 id="a709" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">定义方法</h2><p id="153d" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">2.您也可以通过使用<strong class="lo jc"> define_method使用一个块来创建一个方法。</strong>该功能将会关闭。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f38" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">现在，我们知道我们可以使用块来增加一个方法或代码块中的外部变量。</p><h2 id="ac15" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">递增计数器的其他方法:</h2><h2 id="fef9" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">只需在需要DFS时使用堆栈</h2><p id="de91" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">不使用递归块或方法，我们可以只使用堆栈，不用担心变量范围。</p><p id="7199" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">这要多做一点工作，因为你必须显式地使用一个堆栈，而不是仅仅使用一个隐式的递归，但老实说，它可以让你不用处理递归中的变量引用。</p><p id="418e" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">另外，栈在算法中很常见，为什么不熟悉一下栈呢？</p><p id="e111" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">最重要的是，如果您需要实现BFS，可以非常容易地将使用堆栈的DFS切换到使用队列的BFS。</p><p id="0b00" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated"><em class="nj">这是一个旁注，因为这适用于队列，但是Ruby数组可以作为</em> <strong class="lo jc"> <em class="nj">队列</em> </strong> <em class="nj">工作。其他语言需要为它们的队列使用名为“deques”的结构，否则在数组的开头插入和删除一个值将花费O(N)时间，但是Ruby数组作为deques工作得非常好。ruby数组的Push、pop、shift和unshift都有O(1)时间摊销。看看这个</em> <a class="ae mo" href="https://stackoverflow.com/questions/8353026/what-is-the-run-time-of-shift-unshift-in-a-ruby-array" rel="noopener ugc nofollow" target="_blank"> <em class="nj">堆栈溢出问题。</em> </a></p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="eec0" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们如何使用堆栈跟踪DFS中的深度？</h2><p id="ccd6" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu kz lv lw lx ld ly lz ma lh mb mc md me ij bi translated">最后一点是肯定的，使用堆栈跟踪DFS中的<em class="nj">计数器</em>很容易，但是我们如何跟踪<em class="nj">深度</em>？深度不同于计数器，因为计数器只对每次迭代进行计数，而深度会跟踪您搜索了多少层节点才能到达某个点。</p><p id="99a8" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">这可能很重要，因为一些算法问题要求返回路径的深度或“长度”。例如，当你设计一个嵌套数组时，你需要返回一个目标值的深度。</p><p id="f280" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">将遇到的每个节点存储在深度为的数组中:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="765d" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">从堆栈中移除的每个节点将知道到该节点的路径的当前深度或“长度”。它的任何一个孩子都应该用curr_depth + 1插入堆栈。</p><h2 id="a920" class="kq kr jb bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">从这篇文章中学到什么…</h2><ul class=""><li id="f529" class="mv mw jb lo b lp lq ls lt kz nk ld nl lh nm me nn nb nc nd bi translated">Ruby函数定义创建了自己的作用域。当使用经典的Ruby函数定义时，即(<code class="fe mk ml mm mn b">def function_name … end</code>)，不能引用或修改外部变量。但是，您可以传入一个数组，并在函数中修改该数组，因为数组修改会改变内存中的数组。</li><li id="9134" class="mv mw jb lo b lp ne ls nf kz ng ld nh lh ni me nn nb nc nd bi translated">接下来，如果可以的话，使用栈进行DFSing。使用变量更容易。这会让你更熟悉算法中常见的堆栈。您还可以轻松地从带堆栈的DFS切换到带队列的BFS。</li><li id="ef9c" class="mv mw jb lo b lp ne ls nf kz ng ld nh lh ni me nn nb nc nd bi translated">最后，如果您仍然需要使用递归，请使用lambdas、procs或define_method。它们有闭包，可以引用外部变量。</li></ul><p id="e492" class="pw-post-body-paragraph lm ln jb lo b lp mf kc lr ls mg kf lu kz mh lw lx ld mi lz ma lh mj mc md me ij bi translated">好吧，我希望你觉得这有帮助。我不是真正的专家，我只是分享一些我在解决Leetcode问题时学到的东西。祝你面试好运。</p></div></div>    
</body>
</html>