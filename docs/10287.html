<html>
<head>
<title>Algorithm — Contribution Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法—贡献模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/algorithm-contribution-pattern-c9c52fcdd8e9?source=collection_archive---------2-----------------------#2022-10-21">https://blog.devgenius.io/algorithm-contribution-pattern-c9c52fcdd8e9?source=collection_archive---------2-----------------------#2022-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c24f0bac2186d1c752c9b7daec314d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*absINye8IFyFznd6Hta84g.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">图片来源 VectorStock.com</figcaption></figure><div class=""/><p id="0b2c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">子阵列或子矩阵结果的累加</p><p id="6a5e" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">组合模式是我们必须从子数组和子矩阵中积累结果的问题。在这种模式中，我们不是生成所有的子数组或子矩阵，而是计算一个元素作为可能的候选元素在子数组或子矩阵中出现的次数。让我们用一些例子来理解这一点。</p><h1 id="24c4" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">字符串的总吸引力</h1><p id="4abc" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">字符串的<strong class="kb jd">吸引力</strong>是在字符串中找到的<strong class="kb jd">不同</strong>字符的数量。比如<code class="fe ma mb mc md b">"abbca"</code>的诉求是<code class="fe ma mb mc md b">3</code>，因为它有<code class="fe ma mb mc md b">3</code>鲜明的人物:<code class="fe ma mb mc md b">'a'</code>、<code class="fe ma mb mc md b">'b'</code>、<code class="fe ma mb mc md b">'c'</code>。给定一个字符串<code class="fe ma mb mc md b">s</code>，返回其所有子字符串的总吸引力。</p><h2 id="8b70" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">方法</strong></h2><p id="66f2" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在一个子串中，多个相同的字符只能得到一分。<br/>所以我们需要找到所有子串，统计每个字符的权重。如果一个字符出现不止一次，那么它的权重只有一。对于那些我们有重复字符的情况，我们可以认为第一个出现的得到要点。对于每个字符<code class="fe ma mb mc md b">s[i]</code>，子串必须在<code class="fe ma mb mc md b">s[i]</code>之前开始以包含<code class="fe ma mb mc md b">s[i] </code>，并且需要在<code class="fe ma mb mc md b">s[i]</code>的<code class="fe ma mb mc md b">last</code>出现之后结束，否则最后出现的字符<code class="fe ma mb mc md b">s[i]</code>将得到分数。总共有<code class="fe ma mb mc md b">i - last[s[i]]</code>可能的开始位置、<br/>和<code class="fe ma mb mc md b">n - i</code>可能的结束位置，所以<code class="fe ma mb mc md b">s[i]</code>可以贡献<code class="fe ma mb mc md b">(i - last[s[i]]) * (n - i)</code>点。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/d56cc5f77bd35e844bffed79cada0e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsmlmC5q_RnEc1xhp1GGXw.png"/></div></div></figure><h2 id="05dc" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">代码实现</strong></h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="6d37" class="me ky jc md b gy mz na l nb nc">def appealSum(s):<br/>    from collections import defaultdict<br/>    last_seen = defaultdict(lambda: -1)<br/>    res, n = 0, len(s)<br/>    for idx, char in enumerate(s):<br/>        res += (idx - last_seen[char]) * (n - idx)<br/>        last_seen[char] = idx<br/>    return res</span><span id="9290" class="me ky jc md b gy nd na l nb nc">print(appealSum("abbca"))</span></pre><h1 id="e807" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">统计给定字符串的所有子字符串的唯一字符</strong></h1><p id="c653" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">让我们定义一个函数<code class="fe ma mb mc md b">countUniqueChars(s)</code>，它返回<code class="fe ma mb mc md b">s</code>上唯一字符的数量。例如，如果<code class="fe ma mb mc md b">s = "LEETCODE"</code>叫<code class="fe ma mb mc md b">countUniqueChars(s)</code>，那么<code class="fe ma mb mc md b">"L"</code>、<code class="fe ma mb mc md b">"T"</code>、<code class="fe ma mb mc md b">"C"</code>、<code class="fe ma mb mc md b">"O"</code>、<code class="fe ma mb mc md b">"D"</code>在<code class="fe ma mb mc md b">s</code>中只出现一次，所以<code class="fe ma mb mc md b">countUniqueChars(s) = 5</code>是唯一的字符。给定一个字符串<code class="fe ma mb mc md b">s</code>，返回<code class="fe ma mb mc md b">countUniqueChars(t)</code>的和，其中<code class="fe ma mb mc md b">t</code>是<code class="fe ma mb mc md b">s</code>的子串。测试用例的生成使得答案符合 32 位整数。</p><p id="2cc4" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，有些子字符串可以重复，因此在这种情况下，您还必须计算重复的子字符串。</p><h2 id="4470" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">接近</strong></h2><p id="b2ec" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">与上一个问题类似，我们可以计算 S 中的每个字符，有多少个子串是唯一字符，而不是计算所有唯一字符和所有可能的子串。对于每一个 char，我们都进行计数并不断添加到 res 中，它将成为我们的答案。当我们看到一个字符被重复时，我们会找到该字符在子串中唯一的子串的数量，但它不再是<code class="fe ma mb mc md b">last_occurence -second_last_occurence</code>。我们还需要添加新添加的人物<code class="fe ma mb mc md b">current_idx — last_occurence</code>。</p><h2 id="37d5" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">代码实现</strong></h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="6eae" class="me ky jc md b gy mz na l nb nc">def uniqueLetterString(s):<br/>    index_map = {c: [-1, -1] for c in s}<br/>    res = 0<br/>    current = 0<br/>    for idx, char in enumerate(s):<br/>        second_last_occurence, last_occurence = index_map[char]<br/>        num_removed = last_occurence - second_last_occurence<br/>        num_added = idx - last_occurence<br/>        index_map[char] = [last_occurence, idx]<br/>        <br/>        current += num_added - num_removed<br/>        res += current<br/>    return res<br/>    <br/>print(uniqueLetterString("LEETCODE"))</span></pre><h1 id="fa62" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有效子阵列的数量</h1><p id="6dbc" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">给定一个整数数组<code class="fe ma mb mc md b">nums</code>，返回<em class="ne">非空</em> <strong class="kb jd"> <em class="ne">子数组</em> </strong> <em class="ne">的个数，子数组最左边的元素不大于子数组</em>中的其他元素。</p><h2 id="7350" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated">方法</h2><p id="4eae" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">我们需要找到第一个元素最小的所有子数组。换句话说，我们需要为每个元素找到下一个更小的元素。直到该索引(下一个更小的元素)为止，所有子阵列将具有作为最小值的数目，因此所有这样的贡献将被计数。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6450b0341d4de3251ca120286d2f792d.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*cECOuDEeAIo1CIdlgmJF4g.png"/></div></figure><p id="2b74" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了找到下一个最小的元素，我们使用<a class="ae ng" rel="noopener ugc nofollow" target="_blank" href="/monotonic-stack-algorithm-pattern-7bfac59157c2">单调堆栈</a>。</p><h2 id="bd4a" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated">代码实现</h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="fb10" class="me ky jc md b gy mz na l nb nc">def validSubarrays(nums):<br/>    stack = []<br/>    next_smaller = [len(nums)] * len(nums)<br/>    for i, v in enumerate(nums):<br/>        while stack and stack[-1][1] &gt; v:<br/>            next_smaller[stack.pop()[0]] = i<br/>        stack.append([i, v])<br/>    return sum([v - i for i, v in enumerate(next_smaller)])</span></pre><h1 id="62b9" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">子阵列最小值之和</h1><p id="7bb5" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">给定一个整数数组 arr，求<code class="fe ma mb mc md b">min(b)</code>的和，其中<code class="fe ma mb mc md b">b</code>覆盖<code class="fe ma mb mc md b">arr</code>的每个(相邻)子数组。由于答案可能较大，返回答案<strong class="kb jd">模</strong> <code class="fe ma mb mc md b">10^9 + 7</code>。</p><h2 id="c0bd" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">接近</strong></h2><p id="0eaa" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在这个问题中，我们需要找出有多少个子数组包含这个数，并且这个数是最小的。为了找到它，我们从索引开始，向数组的左边移动，直到找到第一个值小于当前 num 的索引。这决定了在 num 最小的地方有多少个可行的左子阵列。类似地，我们可以通过移动到索引的右侧并找到第一个较小的数字来计算可行的右侧子数组的数量。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/41b8d92cdd7e8ce65e350b419d895800.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*VhxSfq926J9O3G_YQ4Q2jQ.png"/></div></figure><h2 id="246c" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated">代码实现</h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="3ba1" class="me ky jc md b gy mz na l nb nc">def sumSubarrayMins(nums):<br/>    n = len(nums)<br/>    nums.append(0)<br/>    res = 0<br/>    mod = 1000000007<br/>    stack = [-1]<br/>    <br/>    for i, num in enumerate(nums):<br/>        while stack and nums[stack[-1]] &gt; num:<br/>            idx = stack.pop()<br/>            res += nums[idx] * (i - idx) * (idx - stack[-1])<br/>            <br/>        stack.append(i)<br/>        <br/>    return res % (mod)</span><span id="d044" class="me ky jc md b gy nd na l nb nc">print(sumSubarrayMins([3,1,2,4]))</span></pre><h1 id="ff97" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">子阵列范围之和</h1><p id="76be" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">给你一个整数数组<code class="fe ma mb mc md b">nums</code>。<code class="fe ma mb mc md b">nums</code>子阵列的<strong class="kb jd">范围</strong>是子阵列中最大和最小元素之间的差值。返回所有<em class="ne"/><code class="fe ma mb mc md b">nums</code><em class="ne">子数组范围的<em class="ne"/><strong class="kb jd"><em class="ne">之和。</em></strong></em></p><h2 id="6639" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">接近</strong></h2><p id="6c5d" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">类似于上一个问题，我们计算一个单元对一个子阵列的最小元素有多少次贡献。此外，我们将细胞贡献的次数计算为子阵列的最大值。因为我们需要每个数组中最大值和最小值之间的差值，所以我们减去所有最小值的贡献，然后加上所有最大值的贡献。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ni"><img src="../Images/e0971b4a63694ce71215af24a3393744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0qcoWHVHwhfZUj7LeOXpg.png"/></div></div></figure><h2 id="31d0" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated">代码实现</h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="31ce" class="me ky jc md b gy mz na l nb nc">def subArrayRanges(nums):<br/>    res = 0<br/>    inf = float('inf')<br/>    A = [-inf] + nums + [-inf]<br/>    s = []<br/>    for i, x in enumerate(A):<br/>        while s and A[s[-1]] &gt; x:<br/>            j = s.pop()<br/>            k = s[-1]<br/>            res -= A[j] * (i - j) * (j - k)<br/>        s.append(i)<br/>        <br/>    A = [inf] + nums + [inf]<br/>    s = []<br/>    for i, x in enumerate(A):<br/>        while s and A[s[-1]] &lt; x:<br/>            j = s.pop()<br/>            k = s[-1]<br/>            res += A[j] * (i - j) * (j - k)<br/>        s.append(i)<br/>    return res</span><span id="6650" class="me ky jc md b gy nd na l nb nc">print(subArrayRanges([1,2,3]))</span></pre><h1 id="bd7d" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">所有子矩阵之和</h1><p id="7845" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">给定一个 2D 矩阵<strong class="kb jd"> A </strong>的维数<strong class="kb jd"> N*N </strong>，我们需要返回所有可能的子矩阵之和。</p><h2 id="9dcb" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated"><strong class="ak">接近</strong></h2><p id="4245" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">如果我们生成所有的子矩阵，它将给出 n⁴.的时间复杂度如果我们计算一个单元在所有子矩阵中出现的次数，我们可以减少，我们可以找到它在总和中的贡献。我们采取如下图所示的方法。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nj"><img src="../Images/01c4e735a9c611aae406acccdfcb4c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhIio3VS8NonxK2L0QBWzw.png"/></div></div></figure><h2 id="5239" class="me ky jc bd kz mf mg dn ld mh mi dp lh kk mj mk ll ko ml mm lp ks mn mo lt mp bi translated">代码实现</h2><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="dcb3" class="me ky jc md b gy mz na l nb nc">def subMatricesSum(A):<br/>    m, n = len(A), len(A[0])<br/>    res = 0<br/>    for i in range(m):<br/>        for j in range(n):<br/>            res += A[i][j]*(i+1)*(j+1)*(m-i)*(n-j)<br/>    return res</span><span id="19f5" class="me ky jc md b gy nd na l nb nc">print(subMatricesSum([ [1, 1], [1, 1]]))</span></pre><p id="7f50" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你觉得这有用，请鼓掌！！</p></div></div>    
</body>
</html>