<html>
<head>
<title>Introducing BIGKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BIGKit 简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introducing-bigkit-95dc874ee689?source=collection_archive---------21-----------------------#2020-07-08">https://blog.devgenius.io/introducing-bigkit-95dc874ee689?source=collection_archive---------21-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/eb4abea5ab9efd2e9b40bc33017cecfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_n92mquhg3_DofH20z6O4A.jpeg"/></div></div></figure><div class=""/><p id="f75d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">BIGKit 是一个诞生于挫折的工具。作为一名软件工程师，我花了太多的时间编写数据访问代码、管理 GUI、验证逻辑、序列化和编组代码等。有清晰的模式不断重复出现，但不知何故，每一次似乎都以独特的方式显现，有足够的分歧，所有以前的进步都不可转移。</p><p id="cf42" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我个人的观点是，这些问题中有许多是由于可用的工具被定义在太低的抽象层次上。许多这些常见的问题需要访问复杂的库和框架，允许足够的控制成为可能，因此随之而来的是复杂性。</p><p id="b118" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多现有的高级工具在 CMS/页面生成器和真正的手工开发的应用程序之间架起了一座桥梁，这些工具似乎在某种程度上妥协了。这里很大一部分问题是我们经常从页面编辑器的基础开始，许多更高级的功能，虽然可能，但不被认为是一等公民。</p><h1 id="3aa4" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">那么，什么是 BIGKit？</h1><p id="d332" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Bigkit 建立在<a class="ae lw" href="https://dotnet.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> dotnet core </a>、<a class="ae lw" href="https://safe-stack.github.io/" rel="noopener ugc nofollow" target="_blank"> S.A.F.E </a>栈和<a class="ae lw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>之上，试图在以发布为中心的 CMS 和真正的应用程序开发之间架起一座桥梁。它是从头开始构建的，包含了像我这样固执己见的软件工程师对系统构建者的一些核心原则:</p><ul class=""><li id="a566" class="lx ly iy jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">一个可视化组件和页面生成器(这里没有什么新东西)</li><li id="3ec5" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">组件和组合是一级概念。组成的单元(节点)应该是简单的，只做一件事。</li><li id="5814" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">到处都是分层作用域的类型</li><li id="ad8c" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">尽可能进行类型推断</li><li id="5630" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">能够在任何地方编写和运行代码，而不需要处理文件、构建管道、绑定器、在边界之间编组类型等。代码应该是类型安全的，并允许对 api 的类型化访问，以防止整类令人沮丧的运行时错误。代码应该是一等公民，而不是事后添加的东西。</li><li id="f627" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">双向数据绑定和更改跟踪</li><li id="facc" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">默认情况下，一切都是被动的，甚至数据访问代码也是如此</li><li id="d0de" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">用户和用户权限是第一类概念</li><li id="b4bb" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">功能原理:不变性，单向流动，表达式无处不在，反应性。</li><li id="0809" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">通过拥有某种一流的集成重新投影引擎，不必牺牲未来读取性能的横向扩展潜力。我应该不需要参与 Kafka、消息总线、actors 或任何其他基于事件引擎的核心服务器，只需要能够保持两个读取重投影同步。</li><li id="da18" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">从这一点来看，开箱即用的事件，至少在字段更新增量级别允许审计和数据时间旅行。这当然也可以用于重新投影。</li><li id="6077" class="lx ly iy jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">一般来说，平凡的可重复任务应该大大减少，或者如果可能的话:不存在，允许开发人员将精力集中在真正的系统或领域问题上，而不是整天推动像素。</li></ul><h1 id="c6bf" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">页面生成器</h1><p id="4300" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">页面是一种视觉化的终端用户体验，所以从视觉上解决这个问题是有意义的。不必求助于代码来制作页面，可以缩短迭代周期，并允许您立即看到任何更改将如何影响最终结果。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ml"><img src="../Images/a6a15c25451990aa594393a2b921da3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hTiUJkFTsClJirWdi6B3Og.gif"/></div></div></figure><p id="7a7c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任何 BIGKit 应用程序一般都从页面开始。每个页面由排列在树中的多个节点组成。有许多可用的节点类型，有些只是可视化的(比如文本或网格容器)，有些允许复杂的数据检索。每个节点都有许多可以配置的属性，这些属性将改变相关节点的行为。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/2921c0c437dc8e05ae7b785589818963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*71PQOSvxFuRWIeu69ViZgw.gif"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">网格节点构建在 CSSGrid 之上，允许细粒度的布局控制</figcaption></figure><p id="697f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">能够快速看到应用程序如何响应编辑是很重要的，不幸的是，WYSIWYG 编辑器只能带你到这里。它毕竟是页面的概念表示，所以存在无法可视化的运行时构造。</p><p id="6d7e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在运行模式下，应用程序从编辑器订阅更改，从而允许您将更改推入正在执行的预览。这相当于 React 或 Angular 开发人员所说的<a class="ae lw" href="https://webpack.js.org/guides/hot-module-replacement/" rel="noopener ugc nofollow" target="_blank"> HMR </a>(热模块替换)。这既可以在内嵌预览中工作，也可以跨选项卡工作。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/ecd0933fbe3d9241af9bfc98c3559901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ujMguIW6bvnndIXo13EhRA.gif"/></div></div></figure><p id="8bb7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，许多页面可以通过导航快速串在一起，进入用户的旅程。因为所有页面实际上都是数据，所以我们可以很容易地开始理解我们的页面在实际系统中是如何组合在一起的(而不是一些必须单独管理的过时文档)。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mv"><img src="../Images/720a2d97f0b2047cb14f3f10c3f7f123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fj_YxN6yg6ckSWCTrRK7Hg.gif"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来自我们 Headroom 客户端的旅行地图示例。通过遍历所有导航节点，我们可以了解您的应用程序是如何组合在一起的</figcaption></figure><h1 id="2727" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">成分</h1><p id="21ec" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">相同的 WYSIWYG 编辑器在组件模式中做了一些修改，这是一种构造可重用构建块(如页面布局或菜单栏)的方法。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mw"><img src="../Images/da2936a80dbb2fc00591874e5ea6be93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_UVuBjCWovO8vLH3GzufKw.gif"/></div></div></figure><p id="2f2c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">目前组件有一些限制，比如不能使用示波器，但目的是及时解除这个限制。</em></p><p id="4c39" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像页面一样，组件可以接受参数。这些参数可以是原语，也可以是复杂的对象图，可以绑定到整个组件。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/751d29986e1718aa6edbfcfac4162843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cwKnXXs5oPoOQy9oXqnkJg.gif"/></div></div></figure><p id="566f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件还可以包含一个或多个呈现占位符，允许您定义区域来呈现相关组件的子组件。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mz"><img src="../Images/7b26d869b3e56d6b0c1d6b6dece5cf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HHJ85XlozbTeitZfhuhrHQ.gif"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">我们的页面组件有 3 个占位符，允许在组件主体的特定点注入子树。</figcaption></figure><h1 id="8d90" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">探索性测试</h1><p id="92d6" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">尽管我们还没有进行低层次测试的方法，但是很多 UI 工作通常会从更具探索性的方法中受益。为了促进这一点，并在某种程度上受<a class="ae lw" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a>的启发，我们有了运行案例的概念。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi na"><img src="../Images/ea6a7c3723666c665bf121ca007a06db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yeUZurAldCnWdOQitqAYCw.gif"/></div></div></figure><p id="1873" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行案例允许您定义一个案例列表，每个案例都允许对组件或页面的输入参数进行显式配置。然后就可以点击并快速评估各种场景，查看页面/组件的行为。我们目前确实对运行情况下的用户模拟提供了有限的支持，但是在这方面还有很大的扩展潜力。这方面的一些例子包括模仿数据、创建可自动验证的预期等。</p><h1 id="cf3a" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">到处都是类型</h1><p id="cefc" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">“类型”这个词对于开发世界中的许多人来说可能意味着许多事情。我想特别指出的是，这里我们指的是数据的“形状”。当您定义任何数据构造时，它会被赋予一个基于系统期望的数据形状的类型。当类型在表达式中被使用并被传递到应用程序的不同部分时，该类型信息也被传递。这使我们能够推断在应用程序的任何一点上我们可以预期什么样的数据。我们可以验证这一点——例如，传递给实体范围的 id 实际上是一个 id，而不是一个购物清单。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d8bf0e072c2c8580429a6878f04950dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/1*6X-3GHI9LZnG6pewGwzT3Q.gif"/></div></figure><p id="c979" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类型还允许我们更好地理解数据是如何被使用的，从而打开了一扇门，让我们可以根据绑定的字段来隐式地计算出实体上应该加载哪些字段，以及其他令人兴奋的事情。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/8bb6d6301de8a01aec6d287ef7ac9378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hSbfQJ9VamzjFlK1F1bCGA.gif"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">这里，分配给查询的列选择器是由子树中引用该实体的任何表达式推断出来的。</figcaption></figure><p id="6d49" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管对于类型的绝对值仍有一些争论，但普遍认为类型能够防止所有类型的错误。也有<a class="ae lw" href="https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/" rel="noopener ugc nofollow" target="_blank">的经验证据</a>来支持这一点。</p><p id="4e66" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用类型的部分痛苦在于实现这一点需要额外的仪式。在 Leansquad，我们所有的核心产品都使用 F#,而<a class="ae lw" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system" rel="noopener ugc nofollow" target="_blank"> Hindley Milner </a>类型系统可能是如何正确进行<a class="ae lw" href="https://fsharpforfunandprofit.com/posts/type-inference/" rel="noopener ugc nofollow" target="_blank">类型推理</a>的主要例子。BIGKit 使用一个更简单的类型推断算法，该算法只支持出站类型推断，但是这对于我们特定的单向流情况来说已经足够了。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/334923ffcc9bf5e37a19fed01fbe7fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/1*q8-HV9gRXG1vzAp6xbSKdA.gif"/></div></figure><p id="26f7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">也有可能在真实的类型脚本表达式之间桥接这些类型，反之亦然。我们将在后面的文章中讨论这方面的细节。</em></p><h1 id="dfa1" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部署和开发运维</h1><p id="332b" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">虽然这仍处于初级阶段，但我们目前可以将整个应用程序部署在某种类似于其他内容发布平台的一键发布的地方。在此基础上，我们正在开发工具，如页面级日志和分析，以帮助管理您部署的应用程序。</p><p id="b61e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里还有很多工作要做，但是绝对可以节省成本，因为不必管理复杂的构建和部署管道。</p><h1 id="5371" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="76bd" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">感谢您加入我们对 BIGKit 现状的旋风之旅的第一部分。下一次，我们将深入探讨一些更高级的概念，比如输入、处理持久数据、反应性、代码集成等等。加入是在未来几周，我们将进入更多的细节。</p><p id="9253" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们欢迎您来查看我们的<a class="ae lw" href="https://documentation.leansquad.co.uk/demo/hello-world" rel="noopener ugc nofollow" target="_blank">样品</a>，<a class="ae lw" href="https://www.leansquad.co.uk/" rel="noopener ugc nofollow" target="_blank">创建一个免费账户</a>，并给我们您的<a class="ae lw" href="https://request-features.leansquad.co.uk/" rel="noopener ugc nofollow" target="_blank">反馈</a>！</p><p id="bb2e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们认为，确保软件兑现承诺的最快方法是狗粮。我们的 <a class="ae lw" href="https://leansquad.co.uk" rel="noopener ugc nofollow" target="_blank"> <em class="mx">主站点</em> </a> <em class="mx">，</em> <a class="ae lw" href="https://documentation.leansquad.co.uk/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">文档站点</em> </a> <em class="mx">，</em> <a class="ae lw" href="https://request-features.leansquad.co.uk/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">功能请求站点</em> </a> <em class="mx">，以及我们客户的站点</em><a class="ae lw" href="https://www.headroomtherapy.com/" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a><em class="mx">都是完全使用 BIGKit 构建的。</em></p></div></div>    
</body>
</html>