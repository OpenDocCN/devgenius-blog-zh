<html>
<head>
<title>Building an API with Golang in 2020 — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年用Golang构建API第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-an-api-with-golang-in-2020-part-2-ed9f70d46ff3?source=collection_archive---------1-----------------------#2020-08-05">https://blog.devgenius.io/building-an-api-with-golang-in-2020-part-2-ed9f70d46ff3?source=collection_archive---------1-----------------------#2020-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/63a153dfff7e88cf413b149edb2c3e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9prSTTihyJAZuxL5DmfkNw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@adelis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adel </a>在<a class="ae ja" href="https://unsplash.com/s/photos/climbing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="13fd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照<a class="ae ja" href="https://medium.com/@felipecaputo/building-an-api-with-golang-in-2020-part-1-bfe61ac8ae8" rel="noopener">上一篇</a>的想法，我们将得到我们已经开始的项目，现在将添加一个数据库连接和一个用户CRUD API。这真的很简单，只需要简单的验证和简单的错误处理，但我认为它会让你了解如何隔离模块和文件，以及如何处理HTTP和数据库操作，从环境变量中读取配置，并且我们还将使用一个<code class="fe ky kz la lb b">docker-compose</code>来提供我们的数据库服务。我们开始吧！</p><h2 id="6e61" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">我们的第一个产品包—配置</h2><p id="c1fb" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">我们的应用程序已经有了一个包，正如我们在<code class="fe ky kz la lb b">main.go</code>文件中声明的<code class="fe ky kz la lb b">package main</code>。Golang将程序和库组织成包，按照惯例，它们被声明为与包含<code class="fe ky kz la lb b">.go</code>文件的文件夹同名。我们的主包是一个<a class="ae ja" href="https://blog.learngoprogramming.com/special-packages-and-directories-in-go-1d6295690a6b" rel="noopener ugc nofollow" target="_blank">特殊包</a>，它代表任何Go应用程序的入口包，现在我们将创建另一个包，也是一个名为<code class="fe ky kz la lb b">internal</code>的特殊包，为此，我们将在应用程序的根文件夹中创建一个名为<code class="fe ky kz la lb b">internal</code>的文件夹。</p><p id="7ea6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个内部包是特殊的，因为它只对创建它的同一根包可见。我们将把它作为我们第一个名为<code class="fe ky kz la lb b">config</code>的内部包的容器，在这个文件夹中，我们将创建我们的文件<code class="fe ky kz la lb b">config.go</code>,之后，我们的项目将看起来像这样:</p><figure class="mb mc md me gt ip gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/4bbf93cef855464462875bad597f6080.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*v7YXRMNnL28oKRlw4My7bQ.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">包装当前结构</figcaption></figure><p id="a44c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个文件将包含我们的应用程序配置。基于<a class="ae ja" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">12因子</a>，配置应该从环境中读取，为了做到这一点，我们将创建一个<code class="fe ky kz la lb b">struct</code>，它相当于大多数语言中的<code class="fe ky kz la lb b">class</code>。我们的<code class="fe ky kz la lb b">Config</code>将有字段来公开我们的ConnectionString以及我们的应用程序运行的环境。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5218" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一行中，我们定义了我们的包，将其命名为config。在第3行中，我们导入了名为<code class="fe ky kz la lb b">os</code>的标准包，我们将使用它从OS环境变量中读取配置。</p><p id="a4d8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从第5行到第8行，我们声明了我们的<code class="fe ky kz la lb b">Config</code>结构。我们用ts首字母大写<a class="ae ja" href="https://medium.com/better-programming/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841" rel="noopener"> (Pascal Case </a>)来写，因为在Go中，大写的实体在包外是公有的，小写的是私有的。我们现在将在其中定义两个字段，<code class="fe ky kz la lb b">Environment</code>将是我们的应用程序运行环境(<code class="fe ky kz la lb b">local, test or production</code>)和<code class="fe ky kz la lb b">ConnectionString</code>将有我们的数据库连接字符串。这两个字段也被声明为大写，以便在<code class="fe ky kz la lb b">config</code>包之外可见。</p><p id="4126" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从第10行到第16行，我们创建了一个名为<code class="fe ky kz la lb b">getConfigValue</code>的函数，允许我们从环境中读取值，但是如果配置不存在，就返回一个默认值。我们使用<code class="fe ky kz la lb b">os</code>包的函数<code class="fe ky kz la lb b">LookupEnv</code>，它接受一个参数并返回两个值。参数是环境变量名，它返回变量值作为第一个结果，以及一个<code class="fe ky kz la lb b">boolean</code>值，当找到变量时该值为真。当找到变量时，我们返回变量值，如果没有找到，我们返回默认值received value。</p><h2 id="8d83" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">创建我们的第一个构造函数</h2><p id="4455" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">既然我们已经定义了如何读取配置值，我们需要用值来公开我们的<code class="fe ky kz la lb b">Config</code>结构。为此，在第18行和第23行之间，我们为<code class="fe ky kz la lb b">Config</code>结构创建了我们的<code class="fe ky kz la lb b">constructor</code>。在Go中，构造函数不是<code class="fe ky kz la lb b">struct</code>级别的方法，它们通常是<code class="fe ky kz la lb b">package</code>级别的函数，按照惯例，以前缀<strong class="kc je"> New </strong>命名，后跟结构名，在我们的例子中是返回结构实例的<code class="fe ky kz la lb b">NewConfig</code>。在这个构造函数中，我们初始化每个配置字段，从环境变量中读取，并为一个<code class="fe ky kz la lb b">localhost</code> MySQL数据库和<code class="fe ky kz la lb b">local</code>环境定义默认值。</p><h2 id="49e4" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">数据库包</h2><p id="3930" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">在完成我们的配置包之后，让我们创建第二个内部包，它将是包含有<code class="fe ky kz la lb b">db.go</code>文件的<code class="fe ky kz la lb b">database</code>包。我们将做一些与上面的配置文件类似的事情，但是我们不需要创建一个结构，因为<code class="fe ky kz la lb b">sqlx</code>包已经有了一个我们将要创建的<code class="fe ky kz la lb b">DB</code>接口，我们将只创建一个<code class="fe ky kz la lb b">constructor</code>，它将接收一个<code class="fe ky kz la lb b">Config struct</code>作为参数来配置一个连接，正如我们在下面的代码中看到的。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7f19" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像我们创建配置包时一样，我们将包名定义为<code class="fe ky kz la lb b">database</code>，并进行所需的导入。在这个示例中，我们将导入我们的<code class="fe ky kz la lb b">config</code>包、我们将用来连接数据库的<a class="ae ja" href="https://godoc.org/github.com/jmoiron/sqlx" rel="noopener ugc nofollow" target="_blank"> sqlx包</a>，以及MySQL驱动程序。</p><p id="9f0f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是<strong class="kc je"> <em class="mh">我们对MySQL驱动包使用了一个别名</em> </strong> ( <code class="fe ky kz la lb b">_</code>)，因为在Go中，如果我们不使用导入的包，它会显示一个编译错误，而使用<code class="fe ky kz la lb b">_</code>作为别名，我们是在告诉编译器忽略给定的导入。我们需要将它导入到默认的<code class="fe ky kz la lb b">database</code>包中，以增加对MySQL的支持。</p><p id="228f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用sqlx包，它具有与默认的<code class="fe ky kz la lb b">database/sql</code>相同的方法，但是实现了一些其他的方法，使得使用structs编写map查询和更新比默认的包方法更容易，稍后我们将对此进行更深入的讨论。</p><p id="0780" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次的<code class="fe ky kz la lb b">constructor</code>被称为<code class="fe ky kz la lb b">NewDB</code>，它有一个我们最近创建的<code class="fe ky kz la lb b">Config</code>结构类型的参数。您还可以注意到，在第29行调用的方法<code class="fe ky kz la lb b">Open,</code>中，我们将<code class="fe ky kz la lb b">driverName</code>(“MySQL”)作为第一个参数传递，将来自接收到的配置的<code class="fe ky kz la lb b">ConnectionString</code>作为第二个参数传递。这个方法返回一个表示数据库连接池的接口，所以我们不需要实现任何东西来处理并发使用。</p><h2 id="3fa4" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">我们的第一个域级包——用户</h2><p id="35e2" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">现在我们已经有了一个数据库连接，我们将开始我们的第一个名为<code class="fe ky kz la lb b">user</code>的域包，在这里我们将处理所有的用户结构和方法。第一步是代表我们的实体。包中的文件名对于编译器来说无关紧要，所以文件名对于我们和同一个项目中的开发人员来说很重要。例如，我们可以将所有代码放入一个文件中，但是这使得阅读和理解项目变得更加困难。我们将创建的第一个文件是如下所示的<code class="fe ky kz la lb b">user/entity.go</code>。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2d19" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将我们的包命名为<code class="fe ky kz la lb b">user</code>，并将导入一个名为<code class="fe ky kz la lb b">validator</code>的包来帮助我们以一种更简单的方式验证我们的输入。之后，创建了带有一些基本字段的<code class="fe ky kz la lb b">User</code>结构，只是为了展示使用<code class="fe ky kz la lb b">chi.</code>的简单CRUD操作的功能</p><h2 id="3024" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">向我们的结构添加验证</h2><p id="e0dc" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">出现在每个字段类型前面的字符串是<code class="fe ky kz la lb b">tags.</code>标签，用于添加结构字段的反射信息(<a class="ae ja" href="https://medium.com/golangspec/tags-in-golang-3e5db0b8ef3e" rel="noopener">更多信息在此</a>)，我们使用的是JSON、数据库字段和验证。</p><p id="a828" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://github.com/go-playground/validator/" rel="noopener ugc nofollow" target="_blank">验证器包</a>使用<code class="fe ky kz la lb b">validate</code>标签来显示哪些字段应该被验证，以及它们的验证规则。在第9行，当我们定义<code class="fe ky kz la lb b">min=3</code>时，我们说字段的最小长度是3，当字段是一个数字时，它验证值而不是长度。在第13行声明的函数<code class="fe ky kz la lb b">Validate</code>中，我们使用验证器包的一个实例来验证作为参数传递的结构，如果验证失败，则返回一个<code class="fe ky kz la lb b">error</code>。</p><h2 id="1e59" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">创建存储库</h2><p id="b6e2" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">现在我们已经有了我们的<code class="fe ky kz la lb b">User</code>实体，让我们创建我们的存储库，以允许我们从数据库中持久化和读取数据。为此，我们将创建我们的<code class="fe ky kz la lb b">user/repository.go</code></p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8e72" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次有很多进口货，但我们还是分部分来看一下吧。首先，我们声明我们的<code class="fe ky kz la lb b">UserRepository</code>结构，这次只有一个小写的字段<code class="fe ky kz la lb b">db</code>,因为我们不需要在我们的包之外公开它。</p><p id="53a4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们将使用需要在数据库上运行的SQL命令声明一些常量，以便为用户实体提供CRUD操作。第一个方法是<code class="fe ky kz la lb b">CreateUser</code>，它接收一个<code class="fe ky kz la lb b">User</code>结构作为参数，并向用户返回一个指针(返回插入的id)和一个错误，以防我们无法创建用户。这是我们拥有的最大的方法，所以让我们进入它，以便更好地理解它。</p><p id="3c85" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你还不习惯Go如何知道哪些方法来自包，哪些方法与结构相关，只要注意在<code class="fe ky kz la lb b">func</code>保留关键字之后，如果我们打开一个括号并创建一个类型的参数，就像在<code class="fe ky kz la lb b">func (u *UserRepository) CreateUser</code>中一样，方法被<em class="mh">附加</em>到那个结构，成为它的成员，而不是包。</p><h2 id="eee3" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">插入用户</h2><p id="94a5" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">首先，我们将为我们的用户生成<code class="fe ky kz la lb b">uuid</code>。UUID对于主键来说非常有用，并且更适合暴露给外部URL，而不是序列号。之后，我们将使用<code class="fe ky kz la lb b">bcrypt</code>包<code class="fe ky kz la lb b">hashAndSalt</code>密码。这在存储密码时非常重要，因为我们应该<a class="ae ja" href="https://security.stackexchange.com/questions/120540/why-shouldnt-i-store-passwords-in-plaintext" rel="noopener ugc nofollow" target="_blank">不要存储纯文本密码</a>并且使用SHA或MD5不够安全，因为它可以与其他散列文本相比较。</p><p id="f870" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">bcrypto</code>方法放入一个随机的salt，并使用它对文本进行加密，这样就可以评估密码是否正确，只有正确的密码和存储的salt，才能为存储的敏感数据提供额外的安全层。</p><p id="3e7c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在验证了<code class="fe ky kz la lb b">hashAndSalt</code>是否没有返回错误之后，我们只需要运行我们对数据库的插入。为此，我们使用名为<code class="fe ky kz la lb b">NamedExec</code>的<code class="fe ky kz la lb b">sqlx</code>方法，这是一个简单的数据库执行，但它从命令中解析我们的参数列表，并将它们映射到我们在第二个参数中传递的结构字段，以一种我们不需要使用位置参数的方式，并将许多参数传递给exec。</p><p id="e93a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个错误验证和<em class="mh"> voilà </em>我们在数据库上有一个函数user insertion，只返回插入的用户id和<code class="fe ky kz la lb b">nil</code>来表明没有错误发生。现在我们已经有一个用户进入数据库，让我们看看如何读取它。</p><h2 id="bd71" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">从数据库中检索用户</h2><p id="5ff4" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">为了从数据库中读取用户，我们将再次利用<code class="fe ky kz la lb b">sqlx</code>包的helper方法，在本例中是请求三个参数的<code class="fe ky kz la lb b">db.Get</code>方法。第一个是指向目标结构的指针，它将被反射映射，第二个是我们想要运行的查询，第三个是选择查询中的位置参数<code class="fe ky kz la lb b">?</code>。</p><p id="73b9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">Get</code>方法失败时会返回一个错误，所以我们不需要在这里添加很多错误处理，只需要返回我们之前定义的用户struct，以及方法正确执行的情况下，在错误对象上失败时会出现的错误<code class="fe ky kz la lb b">nil</code>，就像我们的方法一样。</p><h2 id="7695" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">更新用户</h2><p id="b62a" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">现在，为了更新用户，我们将设置一些规则，因为我们不希望我们的update user方法更新id、密码或将用户设置为admin，为了保证这一点，我们的更新将仅用于更新<code class="fe ky kz la lb b">email</code>和<code class="fe ky kz la lb b">name</code>字段。</p><p id="f19b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要做到这一点，我们的update SQL命令没有命令中的字段，我们实现了一个小写的名为<code class="fe ky kz la lb b">updateUser</code>的<a class="ae ja" href="https://gobyexample.com/variadic-functions" rel="noopener ugc nofollow" target="_blank">变量方法</a>，以避免暴露在包之外，它接收一个用户结构，包含我们要更新的数据，以及变量参数，即任意数量的参数，它将作为一个片被接收，这使得它更容易被调用，而无需开发人员启动一个片作为参数传递，正如我们在第67行中看到的。现在我们只需要在我们的公共<code class="fe ky kz la lb b">Update</code>方法中调用内部<code class="fe ky kz la lb b">updateUser</code>。</p><h2 id="fb1c" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">删除用户</h2><p id="8c16" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">为了完成我们的CRUD操作，我们已经有了<strong class="kc je">C</strong>create、<strong class="kc je"> R </strong> ead和<strong class="kc je"> U </strong> pdate，现在我们将实现删除操作。由于删除是一个简单的操作，我们将只运行SQL命令，并在发生错误时返回错误。</p><h2 id="2ba3" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">公开端点</h2><p id="a8e7" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">既然我们已经在存储库中实现了所有的CRUD操作，那么我们需要做的就是公开<code class="fe ky kz la lb b">/user</code>端点，为此，让我们创建一个名为<code class="fe ky kz la lb b">user/routes.go</code>的新文件，就像下面这个一样。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7441" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们已经花了很多时间讨论打包和导入，所以从现在开始，在下一篇文章中，我将直接讨论实现，除非在打包或导入部分有一些特殊的内容。</p><h2 id="617a" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">创建UserHandler</h2><p id="72ff" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">为了使我们的依赖项管理更容易，让我们创建一个名为<code class="fe ky kz la lb b">userHandler</code>的结构，如第13行所示，将它用作我们的渲染、数据库和存储库的容器，并创建它的构造器(第19行),它将只接收数据库，我们将使用这个数据库创建存储库。</p><p id="6596" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是，我们没有在包外公开我们的<code class="fe ky kz la lb b">userHandler</code>及其构造函数，因为它们都是小写的，但是我们公开了将在给定路由器中注册路由的<code class="fe ky kz la lb b">RegisterRoutes</code>方法，将端点注册封装在包内。</p><p id="79a6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这篇文章比我预期的要大得多，所以我会讲得快一点。我们公开了四个端点，每个基于REST HTTP动词的CRUD操作一个，我们现在不公开用户列表的GET。为此，我们在第99行创建了一个路由组<code class="fe ky kz la lb b">/user</code>，并在第二个参数中传递一个函数，该函数接收一个与该组相关的路由器。在这个函数中，我们将每个处理函数与其端点相关联。</p><p id="c437" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要说明的一点是，我们在路由定义中使用了一个<code class="fe ky kz la lb b">{id}</code>，这是我们将在使用<code class="fe ky kz la lb b">chi.URLParam(r, "id")</code>的方法中检索的参数的名称，当没有找到时，返回给定参数的值或一个空字符串。</p><p id="3a1b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了读取<code class="fe ky kz la lb b">createUser</code>和<code class="fe ky kz la lb b">updateUser</code>中的数据，我们创建了一个名为<code class="fe ky kz la lb b">getUserFromRequest</code>的方法，它使用<code class="fe ky kz la lb b">json.Decoder</code> struct从请求体中读取数据，并使用<code class="fe ky kz la lb b">Decode</code>方法解析为<code class="fe ky kz la lb b">User</code>变量。</p><p id="82eb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了返回错误，我使用了<code class="fe ky kz la lb b">http.Error</code>方法，为了简单起见，我现在以纯文本的形式返回错误(我们稍后会改进它)。</p><h2 id="47cc" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">在我们的应用程序中注册处理程序(即将结束)</h2><p id="2020" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">我知道这篇文章真的很大，但我们现在就快成功了。在第1部分的最后，我们已经有了一个带有工作http监听器的<code class="fe ky kz la lb b">main.go</code>文件。现在我们只需要更新它，如下所示。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0839" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了突出显示这些变化，我们在第16行添加了一个来自<code class="fe ky kz la lb b">chi</code>的中间件，只是为了让一个日志记录器输出接收到的请求和响应所花费的时间，并且在第27行添加了调用<code class="fe ky kz la lb b">user.RegisterRoutes</code>来注册我们所有的用户处理程序。</p><h2 id="a390" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">(最后)运行我们的应用程序</h2><p id="2efb" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">现在，假设您有一个正在运行或正在docker中运行的localhost MySQL实例，并且端口映射到localhost，您只需要运行<code class="fe ky kz la lb b">go run *.go</code>就可以看到奇迹发生了。使用您最喜欢的请求客户端发出一些请求，您将在控制台中看到chi中间件的<code class="fe ky kz la lb b">Logger</code>打印这些请求:</p><figure class="mb mc md me gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/d473992a57cea2606bd2bb5816e6ba0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vuRlvgaMSdq9ytl2uEbwA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">控制台输出</figcaption></figure><h2 id="83e5" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">结论</h2><p id="60ed" class="pw-post-body-paragraph ka kb jd kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">这就是全部，我知道它比预期的要长，但我希望我清楚地说明了每一部分是如何做的，为什么要这样做。在下一篇文章中，我将像现在一样测试我们的API。如果你遇到任何麻烦，<a class="ae ja" href="https://github.com/felipecaputo/go-voting-api/tree/part-2" rel="noopener ugc nofollow" target="_blank">这篇文章的所有源代码都可以在这里找到</a>。</p><p id="89e4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我也非常感谢我的同事们<a class="mj mk ep" href="https://medium.com/u/b26c2029e1d2?source=post_page-----ed9f70d46ff3--------------------------------" rel="noopener" target="_blank">埃里克·奥利维拉、</a> <a class="mj mk ep" href="https://medium.com/u/8a8cbb9714ee?source=post_page-----ed9f70d46ff3--------------------------------" rel="noopener" target="_blank">尼科拉斯·科斯塔、</a> <a class="mj mk ep" href="https://medium.com/u/17539b9f3131?source=post_page-----ed9f70d46ff3--------------------------------" rel="noopener" target="_blank">朱奥·米格尔·诺罗尼亚</a>e·迭戈·阿尔维斯对我的评论和反馈。</p><p id="bc5d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢这篇文章，并希望得到你对这篇文章或这个系列的反馈。下篇文章再见。</p></div></div>    
</body>
</html>