<html>
<head>
<title>Node.js Tips — Timestamp, Cookies, Send File Responses and Fetch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—时间戳、Cookies、发送文件响应和获取</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-timestamp-cookies-send-file-responses-and-fetch-575c38039dba?source=collection_archive---------18-----------------------#2020-07-11">https://blog.devgenius.io/node-js-tips-timestamp-cookies-send-file-responses-and-fetch-575c38039dba?source=collection_archive---------18-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2cac4a1d20482f51e400f8c5393c9d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nOsocBACEux4u5aX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@parsingeye?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">解析眼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="68db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="280b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复“ReferenceError: fetch未定义”错误</h1><p id="0880" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">节点中未实现Fetch API。</p><p id="7d63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想使用它，我们可以使用节点获取库。</p><p id="5abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4829" class="mn lc iq mj b gy mo mp l mq mr">npm i node-fetch --save</span></pre><p id="4e29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4ac9" class="mn lc iq mj b gy mo mp l mq mr">const fetch = require("node-fetch");</span></pre><p id="a895" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有<code class="fe ms mt mu mj b">cross-fetch</code>图书馆。</p><p id="852c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5184" class="mn lc iq mj b gy mo mp l mq mr">npm install --save cross-fetch</span></pre><p id="6d5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="16c3" class="mn lc iq mj b gy mo mp l mq mr">import fetch from 'cross-fetch';</span><span id="9eb3" class="mn lc iq mj b gy mv mp l mq mr">fetch('https//example.com')<br/>  .then(res =&gt; {<br/>    if (res.status &gt;= 400) {<br/>      throw new Error("error");<br/>    }<br/>  })</span></pre><h1 id="9584" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免在Node.js中长时间嵌套异步函数</h1><p id="1093" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将嵌套的异步函数重写为多个函数来重新组织它。</p><p id="fb52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8a05" class="mn lc iq mj b gy mo mp l mq mr">http.createServer((req, res) =&gt; {<br/>  getSomeData(client, (someData) =&gt; {<br/>    getMoreData(client, function(moreData) =&gt; {<br/>         //<br/>      });<br/>   });<br/>});</span></pre><p id="22d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a99e" class="mn lc iq mj b gy mo mp l mq mr">const moreDataParser = (moreData) =&gt; {<br/>   // date parsing logic<br/>};</span><span id="88de" class="mn lc iq mj b gy mv mp l mq mr">const dataParser = (data) =&gt; {<br/>  getMoreData(client, moreDataParser);<br/>};</span><span id="c0b9" class="mn lc iq mj b gy mv mp l mq mr">const callback = (req, res) =&gt; {  <br/>  getSomeData(client, dataParser);<br/>};</span><span id="39b8" class="mn lc iq mj b gy mv mp l mq mr">http.createServer(callback);</span></pre><p id="6457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将匿名函数移到它们自己的命名函数中，这样我们就可以一个一个地调用它们。</p><h1 id="42c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">的使用”。/bin/www "在Express 4.x中</h1><p id="1446" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">./bin/www</code>是以快递app为入口点的文件。</p><p id="a466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在启动脚本中，我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b51" class="mn lc iq mj b gy mo mp l mq mr">"scripts": {<br/>  "start": "node ./bin/www",<br/>}</span></pre><p id="8c10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动应用程序。</p><h1 id="f1f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js HTTP Server获取和设置单个Cookie</h1><p id="7159" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用<code class="fe ms mt mu mj b">http</code>模块创建一个服务器，我们可以通过分割字符串来解析cookie。</p><p id="53db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6447" class="mn lc iq mj b gy mo mp l mq mr">const http = require('http');</span><span id="8de3" class="mn lc iq mj b gy mv mp l mq mr">const parseCookies = (cookieStr) =&gt; {<br/>  const list = {};<br/>  const cookies = cookieStr &amp;&amp; cookieStr.split(';');<br/>  for (const cookie of cookies) {<br/>    const [key, value] = cookie.split('=');<br/>    list[key.trim()] = decodeURI(value);<br/>  });<br/>  return list;<br/>}</span><span id="b3aa" class="mn lc iq mj b gy mv mp l mq mr">http.createServer((request, response) =&gt; {<br/>  const cookies = parseCookies(request.headers.cookie);<br/>  //...<br/>}).listen(8888);</span></pre><p id="f95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">request.headers.cookie</code>得到cookie字符串。</p><p id="811b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它传递给<code class="fe ms mt mu mj b">parseCookie</code>函数。</p><p id="d4bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用分号分隔cookie字符串。</p><p id="1cf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们循环遍历它们，通过<code class="fe ms mt mu mj b">=</code>符号来分割部分。</p><p id="a6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左边是键，右边是值。</p><p id="0422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要设置cookie，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="76bd" class="mn lc iq mj b gy mo mp l mq mr">const http = require('http');</span><span id="8515" class="mn lc iq mj b gy mv mp l mq mr">http.createServer((request, response) =&gt; {<br/>  <!-- --> response.writeHead(200, {<br/>    'Set-Cookie': 'foo=bar',<br/>    'Content-Type': 'text/plain'<br/>  });<br/>  response.end('hello\n');<br/>}).listen(8888);</span></pre><p id="addd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">writeHead</code>来设置标题。</p><p id="3d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">'Set-Cookie'</code>设置响应cookie。</p><p id="8c1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">'Content-Type'</code>设置响应的内容类型。</p><p id="698f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe ms mt mu mj b">response.end</code>返回响应体。</p><h1 id="4bca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express req对象获取请求路径</h1><p id="d452" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe ms mt mu mj b">req.originalUrl</code>属性来获取Express <code class="fe ms mt mu mj b">req</code>对象的请求路径。</p><h1 id="5b4a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">递归复制文件夹</h1><p id="c47a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">node-fs-extra</code>包递归复制一个文件夹。</p><p id="36ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的<code class="fe ms mt mu mj b">copy</code>方法让我们递归地进行复制。</p><p id="b7d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aea8" class="mn lc iq mj b gy mo mp l mq mr">fs.copy('/tmp/oldDir', '/tmp/newDir', (err) =&gt; {<br/>  if (err) {<br/>    console.error(err);<br/>  } else {<br/>    console.log("success");<br/>  }<br/>});</span></pre><p id="7559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参数是旧的目录路径。</p><p id="2d7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是新的目录路径。</p><p id="cdfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是复制操作结束时运行的回调。</p><p id="313a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">err</code>有错误。</p><h1 id="6b3b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Moment.js返回当前时间戳</h1><p id="2d48" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一些方法返回Moment.js中的当前时间戳。</p><p id="812b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b6f7" class="mn lc iq mj b gy mo mp l mq mr">const timestamp = moment();</span></pre><p id="6feb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2dcf" class="mn lc iq mj b gy mo mp l mq mr">const timestamp = moment().format();</span></pre><p id="1d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="03b2" class="mn lc iq mj b gy mo mp l mq mr">const timestamp = moment().unix();</span></pre><p id="871c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2803" class="mn lc iq mj b gy mo mp l mq mr">const timestamp = <!-- -->moment().valueOf();</span></pre><p id="39a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来获取时间戳。</p><p id="b35f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将它转换成一个<code class="fe ms mt mu mj b">Date</code>实例并调用<code class="fe ms mt mu mj b">getTime</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7c3a" class="mn lc iq mj b gy mo mp l mq mr">const timestamp = moment().toDate().getTime();</span></pre><h1 id="6637" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复“TypeError:路径必须是绝对路径或指定res.sendFile的根目录”错误</h1><p id="7d58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们传递一个绝对路径到<code class="fe ms mt mu mj b">res.sendFile</code>，这个错误可以被修复。</p><p id="9b66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="150c" class="mn lc iq mj b gy mo mp l mq mr">res.sendFile('index.html', { root: __dirname });</span></pre><p id="ba31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3bd6" class="mn lc iq mj b gy mo mp l mq mr">const path = require('path');<br/>res.sendFile(path.join(__dirname, '/index.html'));</span></pre><p id="352c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们都会得到<code class="fe ms mt mu mj b">res.sendFile</code>所需要的绝对路径。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4449e21aa475df6760e73daadc0df54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JH2bt4cSXpkv9iY3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@redcharlie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> redcharlie </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4cc0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5795" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用<code class="fe ms mt mu mj b">http</code>创建我们的服务器，我们必须手动解析cookies。</p><p id="f810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点的标准库不包含获取API。</p><p id="7cf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">res.sendFile</code>只走绝对路径。</p><p id="989c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将嵌套回调重新组织到它们自己的函数中来重写它们。</p><p id="7a66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Moment用几个函数返回当前时间戳。</p></div></div>    
</body>
</html>