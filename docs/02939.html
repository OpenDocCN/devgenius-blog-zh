<html>
<head>
<title>JavaScript Asynchronous Operation — Read File Directory with Callback or Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript异步操作—使用回调或承诺读取文件目录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-asynchronous-operation-read-file-directory-with-callback-or-promises-9d74a236a928?source=collection_archive---------3-----------------------#2020-09-14">https://blog.devgenius.io/javascript-asynchronous-operation-read-file-directory-with-callback-or-promises-9d74a236a928?source=collection_archive---------3-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d4f54863f01549b5f719be52ada9a598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TRWc0saJY2LMbjwi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="79cb" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">异步操作——我们为什么要关心？</strong></h1><p id="1128" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JavaScript是一种同步、阻塞、单线程的语言。同步单线程意味着JavaScript等待任务完成，然后才能继续下一个任务。然而，如果每个任务都需要很长时间，那么异步JavaScript会让它变得更快！可以有独立的线程同时启动任务，而不是预先等待任务继续执行。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/b74763a2e0b97c93085ae89957d87296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YjH0YEvGBxhdOHb3FRfqQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="http://www.phpmind.com/blog/2017/05/synchronous-and-asynchronous/" rel="noopener ugc nofollow" target="_blank">http://www . phpmind . com/blog/2017/05/synchronous-and-asynchronous/</a></figcaption></figure><p id="19c9" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">在计算机编程世界中，同步和异步可能仍然被认为是人类时间中的“快”。但是，让我们设想一个场景，如果发送了一个读取整个文件数据库的请求，而其中的文件非常大，因此需要很长时间来读取。与其等待，不如我们同时开始读取目录中的其他文件。这是异步JavaScript。</p><h1 id="7811" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">异步操作—代码风格</h1><p id="7f20" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在JavaScript中，函数是一等公民。这意味着函数可以像其他类型的值一样对待。函数可以作为参数传递给其他函数，作为值从其他函数返回，并存储在变量中。</p><p id="8fff" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">异步操作被放入在主线程完成处理后运行的事件队列中，这样它们就不会停止后续JavaScript的运行。</p><p id="fd01" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">JavaScript使用两个主要的异步概念来利用函数一等公民:</p><ol class=""><li id="61c7" class="mj mk iq ld b le me li mf lm ml lq mm lu mn ly mo mp mq mr bi translated">异步回调</li><li id="a339" class="mj mk iq ld b le ms li mt lm mu lq mv lu mw ly mo mp mq mr bi translated">承诺</li></ol><p id="c97a" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">对于其他示例，帮助您进一步巩固对这两个概念的理解。</p><div class="mx my gp gr mz na"><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">异步JavaScript简介</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">在这篇文章中，我们简要回顾了与同步JavaScript相关的问题，并先看一看一些…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">developer.mozilla.org</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jw na"/></div></div></a></div><div class="mx my gp gr mz na"><a href="https://scotch.io/courses/10-need-to-know-javascript-concepts/callbacks-promises-and-async" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">回调、承诺和异步</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">JavaScript中的同步操作需要让操作的每一步都等待前一步执行…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">scotch.io</p></div></div><div class="nj l"><div class="np l nl nm nn nj no jw na"/></div></div></a></div><p id="4138" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">让我们考虑一个对服务器的AJAX(异步JavaScript和XML)请求。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/460041eb515226ad3429082df1366dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*i64GjRzGshRhSMUynG56EQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="http://www.phpmind.com/blog/2017/05/synchronous-and-asynchronous/" rel="noopener ugc nofollow" target="_blank">http://www . phpmind . com/blog/2017/05/synchronous-and-asynchronous/</a></figcaption></figure><p id="06bf" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">用户单击浏览器，这导致向服务器发送HTTP请求以读取整个目录，这可能需要一些时间。不是让浏览器停止运行任何其他函数并等待响应，而是设置另一个函数来等待该响应并在收到响应时做出反应。</p><p id="3c66" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">让我们看看如何编写这些异步操作。</p><h1 id="2f30" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">异步回调</strong></h1><p id="b959" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">并非所有回调都是异步的。在这个上下文中使用<code class="fe nr ns nt nu b">.map()</code>的回调没有被延迟。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="f0b3" class="nz ke iq nu b gy oa ob l oc od">[1,2,3].map((i) =&gt; i + 5)</span></pre><p id="af20" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">另一方面，等待用户点击以调用功能。等待回调在特定时间执行。这个回调(第二个参数)是一个异步回调。一旦事件监听器(' click ')被听到，回调将执行。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="a8d1" class="nz ke iq nu b gy oa ob l oc od">$('#btn').on('click', () =&gt;<br/>  console.log('Callbacks are everywhere')<br/>)</span></pre><p id="5ce1" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">已发送GET请求来读取整个目录。让我们阅读所有文件。现在，我们将只读取文件名(由于额外的复杂性，不读取文件内容)并返回数据。回调使用一种叫做<a class="ae kc" href="https://medium.com/@b.essiambre/continuation-passing-style-patterns-for-javascript-5528449d3070#:~:text=Continuation%20Passing%20Style%20basically%20means,the%20last%20parameter%20of%20functions." rel="noopener">延续传递风格</a>的模式。还要注意，我们遵循nodejs社区采用的<a class="ae kc" href="https://hashnode.com/post/whats-an-error-first-callback-in-nodejs-ciibz8ehi00lwj3xt257d72rt" rel="noopener ugc nofollow" target="_blank">错误优先回调</a>模式。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="96ed" class="nz ke iq nu b gy oa ob l oc od">const fs = require('fs');<br/>const path = require('path');</span><span id="2f8e" class="nz ke iq nu b gy oe ob l oc od">exports.readAll = (callback) =&gt; {<br/>  var data = [];<br/>  fs.readdir(`${exports.dataDir}`, (err, files) =&gt; {<br/>    if (err) {<br/>      throw 'error reading dir';<br/>    } else {<br/>      files.forEach((file) =&gt; {<br/>        id = file.slice(0, 5);<br/>        data.push({ id: id, text: id });<br/>      });<br/>      callback(null, data);<br/>    }<br/>  });<br/>};</span><span id="f461" class="nz ke iq nu b gy oe ob l oc od">exports.readOne = (id, callback) =&gt; { <br/>  fs.readFile(`${exports.dataDir}/${id}.txt`, 'utf8', <br/>  (err, text) =&gt; {<br/>    if (err) {<br/>      callback(new Error(`No item with id: ${id}`));<br/>    } else {<br/>      callback(null, { id, text });<br/>    }<br/>  });<br/>};</span></pre><p id="d49c" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">不幸的是，如果我们添加更多的回调层，这导致嵌套回调中的嵌套回调，我们就进入了“回调地狱”的世界。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/546fc3637bcc77948011b90f4ecaa6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9g_kSHGR6SJ2E3g5OS10Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://medium.com/@js_tut/the-great-escape-from-callback-hell-3006fa2c82e" rel="noopener">https://medium . com/@ js _ tut/the-great-escape-from-callback-hell-3006 fa 2c 82e</a></figcaption></figure><p id="4e2c" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">帮助我们解决“回调地狱”的一个常见方法是很好地模块化我们的代码。这有助于提高“回调地狱”的可读性，但是要跟踪正在发生的事情仍然非常困难。</p><h1 id="c203" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">承诺</strong></h1><p id="1030" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Promises是异步代码的新风格，专门用于处理异步操作。如果回应是真实的，许诺将执行你的请求。如果没有，承诺就不会。承诺有三种状态:</p><ul class=""><li id="1063" class="mj mk iq ld b le me li mf lm ml lq mm lu mn ly og mp mq mr bi translated"><strong class="ld ir">待定</strong> —操作(请求)开始前承诺的初始状态</li><li id="62a7" class="mj mk iq ld b le ms li mt lm mu lq mv lu mw ly og mp mq mr bi translated"><strong class="ld ir">完成</strong> —操作(请求)完成</li><li id="52de" class="mj mk iq ld b le ms li mt lm mu lq mv lu mw ly og mp mq mr bi translated"><strong class="ld ir">拒绝</strong> —操作(请求)未完成，出现错误</li></ul><p id="5f4e" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">构建承诺使用了<code class="fe nr ns nt nu b">new</code>关键字，创建了一个<code class="fe nr ns nt nu b">Promise</code>的<code class="fe nr ns nt nu b">new</code>实例。Promise构造函数接受一个单参数(回调)函数，该函数将<code class="fe nr ns nt nu b">resolve</code>和<code class="fe nr ns nt nu b">reject</code>作为其参数。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="848e" class="nz ke iq nu b gy oa ob l oc od">const promise = new Promise(function(resolve, reject) {<br/>  // promise description<br/>})</span></pre><p id="0609" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated"><code class="fe nr ns nt nu b">resolve</code>允许我们更新承诺兑现的状态。</p><p id="edd4" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated"><code class="fe nr ns nt nu b">reject</code>允许我们将承诺的状态更新为已拒绝。</p><p id="22ae" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">promise是一个普通的JavaScript对象，有可以调用的<code class="fe nr ns nt nu b">.then</code>和<code class="fe nr ns nt nu b">.catch</code>方法。如果承诺兑现，传入<code class="fe nr ns nt nu b">.then</code>的函数将被调用。否则，如果承诺被拒绝(异步请求失败)，传递给<code class="fe nr ns nt nu b">.catch </code>的函数将被调用。</p><h1 id="0f74" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">连锁承诺</h1><p id="bc22" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe nr ns nt nu b">.then</code>和<code class="fe nr ns nt nu b">.catch</code>将返回一个允许我们链接承诺的新承诺。这是对我们“回调地狱”场景的改进。我们可以更有顺序地思考。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="32e6" class="nz ke iq nu b gy oa ob l oc od">function getPromise () {<br/>  return new Promise((resolve) =&gt; {<br/>    setTimeout(resolve, 2000)<br/>  })<br/>}<br/><br/>function logA () {<br/>  console.log('A')<br/>}<br/><br/>function logB () {<br/>  console.log('B')<br/>}<br/><br/>function logCAndThrow () {<br/>  console.log('C')<br/><br/>  throw new Error()<br/>}<br/><br/>function catchError () {<br/>  console.log('Error!')<br/>}<br/><br/>getPromise()<br/>  .then(logA) // A<br/>  .then(logB) // B<br/>  .then(logCAndThrow) // C<br/>  .catch(catchError) // Error!</span></pre><h1 id="28d5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">许诺和承诺。所有</h1><p id="efed" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">允诺是一种简单的转变。本质上，这是一个函数的转换，它有一个错误优先的回调风格，并返回它作为一个承诺。具有正确格式的基于回调的函数和库可以被“预先声明”。参见节点的<code class="fe nr ns nt nu b">fs</code>模块中的异步<code class="fe nr ns nt nu b">readFile</code>示例。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="ad34" class="nz ke iq nu b gy oa ob l oc od">var readFile = Promise.promisify(require("fs").readFile);<br/><br/>readFile("myfile.js", "utf8").then(function(contents) {<br/>    return eval(contents);<br/>}).then(function(result) {<br/>    console.log("The result of evaluating myfile.js", result);<br/>}).catch(function(e) {<br/>    console.log("Error reading file", e);<br/>});</span></pre><p id="b4cc" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">用<code class="fe nr ns nt nu b">.promisifyAll</code>转换整个对象将保证整个对象遍历对象的属性，并在对象及其原型链上创建每个函数的异步等价物。原始方法不会被覆盖，但新的承诺方法将带有后缀<code class="fe nr ns nt nu b">Async</code>。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="bfd8" class="nz ke iq nu b gy oa ob l oc od">var fs = Promise.promisifyAll(require("fs"));<br/><br/>fs.readFileAsync("myfile.js", "utf8").then(function(contents) {<br/>    console.log(contents);<br/>}).catch(function(e) {<br/>    console.log("Error reading file", e);<br/>});</span></pre><p id="1dea" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">使用<code class="fe nr ns nt nu b">Promise.all()</code>,我们可以在一个数组(一个iterable)中聚集一组承诺作为输入，并返回一个解析为结果数组的单个<code class="fe nr ns nt nu b">Promise</code>。</p><ul class=""><li id="d4d2" class="mj mk iq ld b le me li mf lm ml lq mm lu mn ly og mp mq mr bi translated">当每个输入承诺都已解决时解决</li><li id="149d" class="mj mk iq ld b le ms li mt lm mu lq mv lu mw ly og mp mq mr bi translated">拒绝任何已拒绝的输入承诺</li></ul><p id="43d0" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">此方法对于聚合多个承诺的结果非常有用，并在多个异步任务相互依赖才能成功完成时使用。</p><p id="a034" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">现在我们知道了所有关于承诺的知识，让我们用承诺异步操作来阅读我们的目录。</p><pre class="ma mb mc md gt nv nu nw nx aw ny bi"><span id="4f63" class="nz ke iq nu b gy oa ob l oc od">const fs = require('fs');<br/>const path = require('path');<br/>const Promise = require('bluebird');<br/>const fsAsync = Promise.promisifyAll(fs);</span><span id="75c9" class="nz ke iq nu b gy oe ob l oc od">exports.readOne = (id, callback) =&gt; {<br/>  return fsAsync<br/>    .readFileAsync(`${exports.dataDir}/${id}.txt`, 'utf8')<br/>    .then((text) =&gt; callback(null, { id, text }))<br/>    .catch((err) =&gt; callback(new Error(`No item with id: ${id}`)))<br/>};</span><span id="f426" class="nz ke iq nu b gy oe ob l oc od">exports.readAll = (callback) =&gt; {<br/>  var readFileAsync = Promise.promisify(exports.readOne);<br/>  var promises = [];<br/>  return fsAsync<br/>    .readdirAsync(`${exports.dataDir}`).then((files) =&gt; {<br/>      _.each(files, (file) =&gt; {<br/>        var id = file.slice(0, 5);<br/>        promises.push(readFileAsync(id));<br/>      });<br/>      Promise.all(promises)<br/>        .then((promise) =&gt; callback(null, promise))<br/>        .catch((err) =&gt; callback(<br/>          new Error('error reading directory'))<br/>        );<br/>  });<br/>};</span></pre><p id="db76" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">有了承诺，我们现在可以使用<code class="fe nr ns nt nu b">Promise.all()</code>异步读取目录中每个文件的内容。当我们读这个动作时，每个文件现在都被作为一个promise读取，并被推入promise数组。如果成功读取了所有文件，服务器中RESTful路由(Read all route)中的回调将会运行。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="9be2" class="pw-post-body-paragraph lb lc iq ld b le me lg lh li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly ij bi translated">异步操作非常强大。这将由我们根据手头的任务来决定是同步还是异步运行代码。如果一项操作像浏览数据库一样耗时，那么让另一个线程异步完成这项任务可能会更好。</p></div></div>    
</body>
</html>