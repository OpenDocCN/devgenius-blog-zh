<html>
<head>
<title>Concept of modules in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中模块的概念</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concept-of-modules-in-python-4b6ee3f6a030?source=collection_archive---------3-----------------------#2022-04-03">https://blog.devgenius.io/concept-of-modules-in-python-4b6ee3f6a030?source=collection_archive---------3-----------------------#2022-04-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3e08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解释了 python 模块如何工作，并创建了您的自定义模块</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="0c28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道，从计算机科学的角度来看，如果代码没有增长，这意味着它可能完全无法使用。一个真正想要的和可用的代码根据用户和市场需求不断增长。pythons 中有数百万个已开发的库，其中多个库的用途相同，只是功能和易用性有所不同。如果你的代码不能满足用户的需求，它将会被遗忘并被其他代码所取代。所以代码增强很重要。</p><p id="9cda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们也知道代码越大，问题就越大。维护大型代码并从一大段代码中跟踪 bug 是很困难的。在这种情况下，您可能希望将代码分成几百个片段，而这些片段可能会由数百名开发人员来处理。但是由这些开发者来更新同一个文件会很头疼。如果你真的想成功，你必须将任务划分给开发者，并将所有的任务整合成一个整体。将一个任务分解成几个更小的任务叫做<strong class="jm io">分解。</strong></p><p id="aeb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你如何将一个软件分成独立但相互协作的部分？这就是问题。<strong class="jm io">模块</strong>就是答案。</p><p id="0cc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个 python 模块中有两个人完全参与，一个是<strong class="jm io">模块用户</strong>(他将使用现有的模块)和第二个<strong class="jm io">模块供应商</strong>(他们想要创建自己的新模块供个人使用或公共使用)。其实 python 为我们提供了大量的内置模块，你可以像对待一本书一样对待它们，查看它们<a class="ae kp" href="https://docs.python.org/3/library/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">这里</strong> </a>。</p><h1 id="ad63" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">模块导入</h1><p id="420e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">要使一个模块可用，必须使用<strong class="jm io"> import </strong>关键字导入该模块。它将允许您将模块导入到 Python 脚本中</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5d64" class="mc kr in ly b gy md me l mf mg">import math<br/>import os<br/>     OR<br/>import math,os</span></pre><p id="54c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在继续之前，让我们讨论一下<strong class="jm io">名称空间。</strong>一个<strong class="jm io">名称空间</strong>是一个空间，其中存在一些名称，这些名称彼此不冲突，即它们是唯一的。</p><p id="470d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果指定名称<strong class="jm io">的模块存在并且可以访问</strong>(一个模块实际上是一个<strong class="jm io"> Python 源文件</strong>)，Python 会导入它的内容，也就是说<strong class="jm io">模块中定义的所有名称都变成已知的</strong>，但是它们不会进入你的代码的名称空间。现在如何限定一个模块的实体名？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4149" class="mc kr in ly b gy md me l mf mg">module_name.name_of_entity<br/>eg-<br/>math.pi<br/>math.sin</span></pre><p id="c1b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以这样限定一个实体-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="605f" class="mc kr in ly b gy md me l mf mg">from math import pi<br/>or <br/>from math import pi,sin<br/>or <br/>from math import *</span></pre><p id="20b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">星号(*)表示从给定模块导入所有实体。但是这样使用是不安全的，因为如果你不知道一个模块的所有实体，它可能会产生名称冲突。如果你想用你自己的名字命名一个实体，你可以使用别名。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="60af" class="mc kr in ly b gy md me l mf mg">import module as alias<br/>eg-<br/>import panda as pd</span></pre><p id="149b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意-成功执行别名导入后，原始模块名称变得不可访问。</p><p id="f281" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想检查一个模块的所有实体，你可以使用<strong class="jm io"> dir() </strong>函数。是啊！你没听错，这不同于我们的 Linux/Unix <strong class="jm io"> dir </strong>命令。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/f62d853d45138e926a5d4ce097bd139d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IljkcxeF3e9Od6w7zCerHA.png"/></div></div></figure><p id="4add" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">模块是一种装满函数的容器，</strong>我们可以添加任意多的函数，但要确保模块中的函数用于特定的领域或用途。为此，我们可以为不同的目的创建多个模块并将它们组合在一起，我们可以将这样一组模块称为一个包。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b041b886b9a3cf670980d89954d305d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*M0M1vrUsZUbg9O83zxQFmg.png"/></div></figure><h1 id="9e0d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">自定义模块</h1><p id="4878" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">让我们进入正题，创建我们的自定义模块。创建两个文件 module.py 和 main.py。确保两个文件都位于<strong class="jm io">相同的文件夹</strong>中。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e57f71c866f8e3bd63f58ced16ba5711.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*tMoJ3bDVQT1lBySXenS3Jw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">包含 main.py 和 module.py 的文件夹</figcaption></figure><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/0bb5d1c5f600cfa15f66a1ccc8803086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*XJzN7XNkJIOxYXfVIakYBw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">module.py，目前为空</figcaption></figure><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/85faae285b73fd55e4be65bd8f7ec892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zw7nB5uSqK5G_V7wu-hQ_Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">main.py，我们导入了空模块</figcaption></figure><p id="42e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们运行 main.py，看看有什么变化。你看到什么变化了吗？没什么啊！！看到你的文件夹，会有一个新创建的文件夹<strong class="jm io"> __pycache__ </strong>。如果打开它，您将看到一个名为 module.cpython-xy.pyc 的文件，其中<strong class="jm io"> xy </strong>是您的 python 版本，文件名是您的模块名。<strong class="jm io"> cpython </strong>表示哪个 python 实现创建了文件，<strong class="jm io"> pyc </strong>表示<strong class="jm io"> <em class="mx"> python 并编译。</em> </strong></p><p id="bbc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你打开这个文件，你将无法阅读里面的内容。这对于人类来说毫无用处，但该文件仅供 python 使用。当 Python 第一次导入一个模块时，它<strong class="jm io">将其内容翻译成某种编译过的形状</strong>。</p><p id="a197" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该文件不包含机器码——它是内部 Python <strong class="jm io">半编译代码</strong>，准备由 Python 的解释器执行。因为这样的文件不需要纯源文件所需要的大量检查，所以执行开始得更快，运行得也更快。</p><p id="75ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Python 能够检查模块的源文件是否已经被修改(在这种情况下，<strong class="jm io"> pyc </strong>文件将被重建)或者没有被修改(当<strong class="jm io"> pyc </strong>文件可能被立即运行时)。由于这个过程是完全自动和透明的，你不必记住它。</p><p id="1b5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在我们的<strong class="jm io"> module.py. </strong>中打印一些东西</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi my"><img src="../Images/314de6fb41ccaf83c6ab8f4dd9096f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoIrTDu2OqUcVvn0kMmFxA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">在 module.py 中添加了打印，并且在运行 main.py 时会重新加载 module.py</figcaption></figure><p id="0c25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:<strong class="jm io">初始化只发生一次</strong>，当第一次导入发生时，因此模块完成的赋值不会不必要地重复。</p><p id="3345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Python 可以做得更多。它还创建了一个名为<code class="fe mz na nb ly b">__name__</code>的变量。</p><p id="8ac5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，每个源文件使用它自己的、独立的变量版本——它不在模块之间共享。</p><ul class=""><li id="f21d" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated">当你直接运行一个文件时，它的<code class="fe mz na nb ly b">__name__</code>变量被设置为<code class="fe mz na nb ly b">__main__</code>；</li><li id="0b18" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">当一个文件作为一个模块导入时，它的<code class="fe mz na nb ly b">__name__</code>变量被设置为文件名(不包括。py)</li><li id="7b54" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">我们可以使用这个 __name__ 变量来运行一个模块的测试用例，让我们探索更多。</li></ul><p id="71f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">In module.py</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c3b2" class="mc kr in ly b gy md me l mf mg">def merge_sort(arr):<br/>    if len(arr) &gt; 1:<br/>        r = len(arr) // 2<br/>        L = arr[:r]<br/>        M = arr[r:]<br/>        merge_sort(L)<br/>        merge_sort(M)<br/><br/>        i=j=k=0<br/>        while i &lt; len(L) and j &lt; len(M):<br/>            if L[i] &lt; M[j]:<br/>                arr[k] = L[i]<br/>                k += 1<br/>                i += 1<br/>            else:<br/>                arr[k] = M[j]<br/>                k += 1<br/>                j += 1<br/><br/>        while i &lt; len(L):<br/>            arr[k] = L[i]<br/>            k += 1<br/>            i += 1<br/>        while j &lt; len(M):<br/>            arr[k] = M[j]<br/>            k += 1<br/>            j += 1<br/><br/><br/>if __name__ == "__main__":<br/>    print("This is module file: Running test cases for the module")<br/>    sample_data = [1,3,2,4,6,5,0]<br/>    merge_sort(sample_data)<br/>    print(sample_data)</span></pre><p id="f344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">In main.py</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d9c6" class="mc kr in ly b gy md me l mf mg">import module<br/><br/>arr = [10,5,3,7,8,2,3]<br/><br/>module.merge_sort(arr)<br/>print(arr)</span></pre><p id="96a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经在 module.py 中实现了合并排序，但是你注意到我已经使用了<strong class="jm io"> __name__ </strong>来测试我的模块了吗？</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nq"><img src="../Images/cdea17361e2954ddd31f839994287661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dejGwZHcIsBK26AwG3HaCQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">main.py 和 module.py 的输出</figcaption></figure><p id="5927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们深入一点，文件结构是这样的—</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/33d1195c19bebd6360c54d621603c8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*pkDrFM5HUCCgpZb2GXj07Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">新文件结构</figcaption></figure><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/eb3e221b3c9ccc35c53a29cbe0d83087.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*bPxSpX72B7Bh0Ff6zHsg2A.png"/></div></figure><p id="41e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我们可以使用<strong class="jm io"> Python 的 sys </strong>模块，它有一个<strong class="jm io">路径</strong> <strong class="jm io">方法</strong>。In main.py</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f3aa" class="mc kr in ly b gy md me l mf mg">from sys import path<br/>path.append('/home/Desktop/Programming/modules/')<br/>import module<br/><br/>arr = [10,5,3,7,8,2,3]<br/><br/>module.merge_sort(arr)<br/>print(arr)</span></pre><p id="ff3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变量名为<code class="fe mz na nb ly b">path</code>，可以通过名为<code class="fe mz na nb ly b">sys</code>的模块访问</p><p id="a169" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您使用的是 Window，那么路径格式是不同的，请在这里查看路径概念<a class="ae kp" href="https://docs.python.org/3/library/sys.html?highlight=sys#module-sys" rel="noopener ugc nofollow" target="_blank"/>。但是请注意，我使用了<strong class="jm io"> <em class="mx"> path.append()，</em> </strong>只是将路径附加到模块 dir。但是我们也可以使用<strong class="jm io"><em class="mx"/></strong>插入()<strong class="jm io"> <em class="mx">的方法。</em> </strong></p><p id="b734" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们再创建一个文件<strong class="jm io">modules/insertion _ sort . py</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="449c" class="mc kr in ly b gy md me l mf mg">def insertion_sort(arr):<br/>    <em class="mx">"""<br/>    </em><strong class="ly io"><em class="mx">:param</em></strong><em class="mx"> arr: <br/>    </em><strong class="ly io"><em class="mx">:type</em></strong><em class="mx"> arr: <br/>    </em><strong class="ly io"><em class="mx">:return</em></strong><em class="mx">: <br/>    </em><strong class="ly io"><em class="mx">:rtype</em></strong><em class="mx">: <br/>    """<br/><br/>    </em>for index in range(1,len(arr)):<br/>        element = arr[index]<br/>        prev_index = index - 1<br/><br/>        while prev_index &gt;= 0 and arr[prev_index] &gt; element:<br/>            arr[prev_index+1] = arr[prev_index]<br/>            prev_index -= 1<br/><br/>        arr[prev_index+1] = element</span></pre><p id="705c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在<strong class="jm io">模块/module.py </strong>中的变化</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5326" class="mc kr in ly b gy md me l mf mg">import insertion_sort<br/><br/><br/>def merge_sort(arr):<br/>    <em class="mx">"""<br/>    <br/>    </em><strong class="ly io"><em class="mx">:param</em></strong><em class="mx"> arr: <br/>    </em><strong class="ly io"><em class="mx">:type</em></strong><em class="mx"> arr: <br/>    </em><strong class="ly io"><em class="mx">:return</em></strong><em class="mx">: <br/>    </em><strong class="ly io"><em class="mx">:rtype</em></strong><em class="mx">: <br/>    """<br/>    </em>if len(arr) &gt; 1:<br/>        r = len(arr) // 2<br/>        L = arr[:r]<br/>        M = arr[r:]<br/>        merge_sort(L)<br/>        merge_sort(M)<br/><br/>        i=j=k=0<br/>        while i &lt; len(L) and j &lt; len(M):<br/>            if L[i] &lt; M[j]:<br/>                arr[k] = L[i]<br/>                k += 1<br/>                i += 1<br/>            else:<br/>                arr[k] = M[j]<br/>                k += 1<br/>                j += 1<br/><br/>        while i &lt; len(L):<br/>            arr[k] = L[i]<br/>            k += 1<br/>            i += 1<br/>        while j &lt; len(M):<br/>            arr[k] = M[j]<br/>            k += 1<br/>            j += 1<br/><br/><br/>if __name__ == "__main__":<br/>    print("This is modules file: Running test cases for the modules's functions Merge Sort")<br/>    sample_data = [1,3,2,4,6,5,0]<br/>    merge_sort(sample_data)<br/>    print(sample_data,"--- OK")<br/><br/>    print("This is modules file: Running test cases for the modules's functions Insertion Sort")<br/>    new_sample_data = [1, 3, 2, 4, 6, 5, 0]<br/>    insertion_sort.insertion_sort(new_sample_data)<br/>    print(new_sample_data,"--- OK")</span></pre><p id="bcde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">和 main/main.py 中的变化</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6059" class="mc kr in ly b gy md me l mf mg">from sys import path<br/>path.append('/home/vvdn/Desktop/Programming/modules/')<br/>import module<br/><br/>arr = [10,5,3,7,8,2,3]<br/>module.merge_sort(arr)<br/>print(arr)<br/><br/>arr2 = [4,6,1,2,5,3]<br/>module.insertion_sort.insertion_sort(arr2)<br/>print(arr2)</span></pre><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nt"><img src="../Images/0517d1c8eb629f3aa017b6d26ae6562b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVaW2TXTY0izbtHS_XFa4g.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">输出</figcaption></figure><p id="9bda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您注意到了吗，我们可以将其他自定义和内置模块导入到其他模块文件中，并轻松使用它们。</p><p id="90b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我希望你能够创建自己的自定义模块，并在你的项目中使用它们。如果项目功能增加，将它们转换成 M 个<strong class="jm io">模块</strong>，如果模块增加，将它们转换成<strong class="jm io">包</strong>，这样你的代码将变得简单并可重用。</p><p id="c1e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">谢谢！</strong>对于阅读，希望会有帮助。</p></div></div>    
</body>
</html>