<html>
<head>
<title>Seasoned Java Developers Should Know These 5 Practices to Improve Parallel Stream Execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的 Java 开发人员应该知道这 5 种提高并行流执行的实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/seasoned-java-developers-should-know-these-5-practices-to-improve-parallel-stream-execution-602cc50c9aca?source=collection_archive---------7-----------------------#2022-07-27">https://blog.devgenius.io/seasoned-java-developers-should-know-these-5-practices-to-improve-parallel-stream-execution-602cc50c9aca?source=collection_archive---------7-----------------------#2022-07-27</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="79f7" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">并行流比串行流慢的 5 个原因</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/c5be11b95b487d2a17d152032683ece6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KHH-0y6NBq71Td2B.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae ks" href="https://www.pexels.com/photo/woman-in-black-blazer-holding-white-tablet-computer-7567605/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="8c16" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp"> Java 开发者在没有更深知识的情况下，使用流和并行流。</em>T19】</strong></p><p id="5cf2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">优秀的 Java 开发人员明白喷洒<code class="fe lq lr ls lt b">parallel</code>不会提高执行效率。有时串行执行比并行执行更快。即便如此，大多数人还是忽视了这个事实。并且不考虑需要什么来获得更好的结果。</p><p id="ff8c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">让我们看看流与并行流的 5 种做法及其对性能的影响。</em></p><h1 id="bf85" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">1.<code class="fe lq lr ls lt b">forEach</code>是否比其他可迭代选项执行得更快？</h1><p id="d1e6" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">执行时间取决于 for 循环中完成的操作。尽管如此，我们可以看到，对于更多的元素，循环策略确实很重要。</p><p id="41f6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们将比较以下循环:</p><ul class=""><li id="4aab" class="mr ms ir kv b kw kx kz la lc mt lg mu lk mv lo mw mx my mz bi translated"><code class="fe lq lr ls lt b">forCounter</code>——带计数器的普通老式循环</li><li id="c207" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated"><code class="fe lq lr ls lt b">forEach</code> -以无序的方式改进</li><li id="e474" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated"><code class="fe lq lr ls lt b">iterableForEach</code> - <code class="fe lq lr ls lt b">forEach</code>在 iterable 上，在这个例子中，它是一个数组列表</li><li id="8a94" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated"><code class="fe lq lr ls lt b">iteratorStream</code> - <code class="fe lq lr ls lt b">forEach</code>在流上完成</li></ul><p id="6139" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这些基准测试的代码来自<a class="ae ks" href="https://stackoverflow.com/a/41823317/5999670" rel="noopener ugc nofollow" target="_blank">这就是答案</a>，尽管我添加了 JMH 来改善结果。</p><p id="33f5" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这两个操作在吞吐量和平均时间上没有区别。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nf"><img src="../Images/e9d97a74c05f693a55819b974fdd535a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OmBlKNhkgzsG8WVsNyMHw.png"/></div></div></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nk"><img src="../Images/4a08ff232f4bd8e30125e4c895fe3fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlgKDGp9C78z0_Bmk67zkw.png"/></div></div></figure><p id="3847" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">为什么不并行列出或可迭代的流程元素？他们会违反最小惊讶原则。你不会期望<code class="fe lq lr ls lt b">forEach</code>是平行的，这样做会让你大吃一惊。所以才有具体的并行方法。</em></p><p id="0b6a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里我们可以看到数组有一个特定的并行排序方法:<code class="fe lq lr ls lt b"><a class="ae ks" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html#parallelSort(T%5B%5D,java.util.Comparator)" rel="noopener ugc nofollow" target="_blank">parallelSort</a></code>。但是对于<code class="fe lq lr ls lt b">ArrayList</code>或<code class="fe lq lr ls lt b">CopyOnWriteArrayList</code>我们没有具体的<em class="lp">‘并行’</em>方法。</p><p id="b188" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们可以在 <code class="fe lq lr ls lt b"><a class="ae ks" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html#forEachKey(long,java.util.function.Consumer)" rel="noopener ugc nofollow" target="_blank">ConcurrentHashMap</a></code>中<a class="ae ks" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html#forEachKey(long,java.util.function.Consumer)" rel="noopener ugc nofollow" target="_blank">看到一个更好的例子，还有方法<code class="fe lq lr ls lt b">forEachKey</code>。并行化参数在那里，所以这个方法将并行执行。</a></p><p id="6003" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们尝试遍历流和列表。流应该表现得更好，因为它们是无序的，而列表是有序的。<em class="lp">流可以从并行化中获益，但是让我们看看在什么情况下。</em></p><h1 id="d346" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">2.<code class="fe lq lr ls lt b">limit</code>会影响并行执行的性能吗？</h1><p id="63c9" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">让我们看看下面的例子。两者相似，但有一些关键的区别。</p><p id="4c8c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">第一个是第二个基准上的<code class="fe lq lr ls lt b">rangeClosed</code>。封闭范围的流有助于并行化。<strong class="kv is"> <em class="lp">流很容易分裂，因为大小是已知的。</em>T19】</strong></p><p id="6875" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">“因为提供了流的开始和结束值，所以我们可以轻松地将流分割成子流。”</em> <a class="ae ks" href="https://blogs.oracle.com/javamagazine/post/java-parallel-streams-performance-benchmark" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="dcb7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">第二个是<code class="fe lq lr ls lt b">limit()</code>。</p><p id="7da7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp"/><code class="fe lq lr ls lt b"><em class="lp">limit()</em></code><em class="lp">操作也是有状态的。这使得将值拆分成子流的过程对于并行流来说效率低下。— </em> <a class="ae ks" href="https://blogs.oracle.com/javamagazine/post/java-parallel-streams-performance-benchmark" rel="noopener ugc nofollow" target="_blank">来源</a></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="3a4c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这是两种情况下的结果。对于更大的流，<code class="fe lq lr ls lt b">rangeClosed</code>的性能优于<code class="fe lq lr ls lt b">limit</code>。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nn"><img src="../Images/741aef0df7963455225d8d0a78cea399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNG-5KI0GdFmiFnVeXDMmA.png"/></div></div></figure><h1 id="e529" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">3.<code class="fe lq lr ls lt b">forEach</code>与<code class="fe lq lr ls lt b">reduce</code>操作相比如何？</h1><p id="34c2" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">如果我们用<code class="fe lq lr ls lt b">forEach</code>来还原呢？</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="ab35" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">没有区别，因为<code class="fe lq lr ls lt b">forEach</code>是一个<em class="lp">无序</em>操作。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nn"><img src="../Images/a8e206e8dabcc8e478ed83acd4ba91d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvyP-KWZb31c-CcE_7uEUw.png"/></div></div></figure><h1 id="9a2d" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">4.forEachOrdered 如何影响性能？</h1><p id="0cad" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">并行执行取决于顺序。那么，我们可以用一个有序选项来超越性能吗？</em> </strong></p><p id="aa38" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp"/><code class="fe lq lr ls lt b"><em class="lp">forEach()</em></code><em class="lp">端子操作忽略相遇顺序。但是</em> <code class="fe lq lr ls lt b"><em class="lp">forEachOrdered()</em></code> <em class="lp">终端操作保留了顺序”— </em> <a class="ae ks" href="https://blogs.oracle.com/javamagazine/post/java-parallel-streams-performance-benchmark" rel="noopener ugc nofollow" target="_blank">来源</a></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="4ade" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因为有了<code class="fe lq lr ls lt b">forEachOrdered</code>，并行性能受到了影响。<em class="lp">结论:强制执行某个遭遇战顺序，会有性能命中。</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nn"><img src="../Images/ac208e6634fdb0bd6bc64a2b9aeb74d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NyPwRsrwtM0AgHVRnAByw.png"/></div></div></figure><h1 id="80ef" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">5.<code class="fe lq lr ls lt b">unordered</code> <code class="fe lq lr ls lt b">stream</code>能提升性能吗？</h1><p id="b379" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated"><em class="lp">如果指定</em> <code class="fe lq lr ls lt b"><em class="lp">stream</em></code> <em class="lp">为无序流，是否可以提高约简？</em></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="dc03" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们比较一下有显式<code class="fe lq lr ls lt b">unordered</code>(第二个基准)和没有显式无序(第一个基准)的那个。我们可以看到有一个微不足道的区别。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nn"><img src="../Images/741aef0df7963455225d8d0a78cea399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNG-5KI0GdFmiFnVeXDMmA.png"/></div></div></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nn"><img src="../Images/57530572dc4944d17cd9271f712c52af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFN3rxXIGaE2YDFRi7BNGA.png"/></div></div></figure><p id="92cf" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp"/><code class="fe lq lr ls lt b"><em class="lp">unordered</em></code><em class="lp">为什么不提升性能？</em></p><p id="e500" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lq lr ls lt b">reduce</code>操作<a class="ae ks" href="https://stackoverflow.com/a/45516389" rel="noopener ugc nofollow" target="_blank">不关心</a> <code class="fe lq lr ls lt b"><a class="ae ks" href="https://stackoverflow.com/a/45516389" rel="noopener ugc nofollow" target="_blank">unordered</a></code>，因为<code class="fe lq lr ls lt b"><a class="ae ks" href="https://stackoverflow.com/questions/49520234/does-reduction-on-an-ordered-stream-reduce-in-order" rel="noopener ugc nofollow" target="_blank">reduce</a></code> <a class="ae ks" href="https://stackoverflow.com/questions/49520234/does-reduction-on-an-ordered-stream-reduce-in-order" rel="noopener ugc nofollow" target="_blank">按顺序</a>处理元素。遭遇顺序本身并不是为<code class="fe lq lr ls lt b">reduce</code>硬连线的，排序取决于<a class="ae ks" href="https://stackoverflow.com/a/61330219" rel="noopener ugc nofollow" target="_blank">底层的分隔符</a>。所以<em class="lp">如果你放<code class="fe lq lr ls lt b">unordered</code>就没有洗牌</em>，因为那本身就是开销。</p><p id="6678" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这意味着在这种情况下没有改善。增加<code class="fe lq lr ls lt b">unordered</code>不会让<em class="lp">自动增加</em>更多的好处。性能取决于中间和终端操作。</p><p id="ccb0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">分流器对平行流的良好结果很重要。Eclipse Collections 的唐纳德几年前在他的 FastList 系列中看到了这一点。他开始着手解决这个问题。</em></p><p id="06b8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">要点是默认的拆分器 IteratorSpliterator 导致了并行执行的性能下降。他和其他开发人员为随机存取集合提出了新的<code class="fe lq lr ls lt b">RandomAccessSpliterator</code>。并添加了基准来证明他的观点。</p><p id="ee76" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以在 Donald 的帖子上查看这方面的基准。<br/> <a class="ae ks" href="https://donraab.medium.com/traveling-the-road-from-idea-all-the-way-to-openjdk-fc7ae04371a5#:~:text=Java%208.%20IteratorSpliterator-,was,-woefully%20suboptimal%20for" rel="noopener">旅行之路从 Idea 一直到 OpenJDK | Medium </a></p><p id="4e5a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">保罗<a class="ae ks" href="https://bugs.openjdk.org/browse/JDK-8158365" rel="noopener ugc nofollow" target="_blank">继续创造</a>的<code class="fe lq lr ls lt b">RandomAccessSpliterator</code>。在这一改变之前，并行执行比串行执行差。</p><p id="69b6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">今天，这个分裂器改善了随机存取结构的并行执行。</p><p id="3c06" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><a class="ae ks" href="http://cr.openjdk.java.net/~psandoz/jdk9/JDK-8158365-list-spliterator-rnd-access/webrev/src/java.base/share/classes/java/util/List.java.udiff.html" rel="noopener ugc nofollow" target="_blank">JDK Udiff src/Java . base/share/classes/Java/util/list . Java</a></p><p id="2f55" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><a class="ae ks" href="http://cr.openjdk.java.net/~psandoz/jdk9/JDK-8158365-list-spliterator-rnd-access/webrev/src/java.base/share/classes/java/util/AbstractList.java.udiff.html" rel="noopener ugc nofollow" target="_blank">JDK Udiff src/Java . base/share/classes/Java/util/abstract list . Java</a></p><h1 id="c6a4" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">并行操作有什么好的经验法则？</h1><ul class=""><li id="2a95" class="mr ms ir kv b kw mm kz mn lc no lg np lk nq lo mw mx my mz bi translated">对于计算密集型操作—首选小型流。</li><li id="6bf8" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated">对于计算不太密集的情况，更喜欢较大的流。</li></ul><p id="063e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我想从约书亚的演讲中举一个关于这种行为的例子。第一个示例挂起，而另一个示例完成。对于计算密集型操作，最好使用小型流。约书亚使用梅森素数作为一种计算密集型运算。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="f8e4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以在使用并行之前，要确定并行化是否有帮助。<a class="ae ks" href="https://developer.ibm.com/articles/j-java-streams-5-brian-goetz/#thenqmodel" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> NQ </em>模型</a>很好地评估了并行化是否有帮助。</p></div></div>    
</body>
</html>