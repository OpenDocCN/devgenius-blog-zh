<html>
<head>
<title>Object-Oriented JavaScript — Observers and Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的 JavaScript——观察者和测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-observers-and-tests-6a441706cb46?source=collection_archive---------6-----------------------#2020-11-29">https://blog.devgenius.io/object-oriented-javascript-observers-and-tests-6a441706cb46?source=collection_archive---------6-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98b1bf0d2a8f946696ee1de4265b0ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kR01DfqJfjov2Ddh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@aarsoph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kristijan Arsov </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些基本的设计模式和测试。</p><h1 id="ec64" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">观察者模式</h1><p id="dc55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">观察者模式是我们通过订阅一个对象来观察来自一个源的变化，并在发生变化时将变化发布给订阅的观察者。</p><p id="5813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个对象，通过编写以下代码来获取观察器并向它们发布更改:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7648" class="mn lc iq mj b gy mo mp l mq mr">const observer = {<br/>  subscribers: [],<br/>  addSubscriber(callback) {<br/>    if (typeof callback === "function") {<br/>      this.subscribers.push(callback);<br/>    }<br/>  },</span><span id="4f1c" class="mn lc iq mj b gy ms mp l mq mr">  removeSubscriber(callback) {<br/>    const index = this.subscribers.findIndex(s =&gt; s === callback);<br/>    this.subscribes.splice(index, 1);<br/>  },</span><span id="e71c" class="mn lc iq mj b gy ms mp l mq mr">  publish(obj) {<br/>    for (const sub of this.subscribers) {<br/>      if (typeof sub === 'function') {<br/>        sub(obj);<br/>      }<br/>    }<br/>  },<br/>};</span></pre><p id="25a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个接受回调的<code class="fe mt mu mv mj b">observer</code>对象。</p><p id="7784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">callback</code>是我们添加到<code class="fe mt mu mv mj b">subscribers</code>数组中的函数。</p><p id="71f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们有<code class="fe mt mu mv mj b">removeSubscriber</code>数组来移除回调。</p><p id="1810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">publish</code>获取一个包含要发布的内容的对象，并回调<code class="fe mt mu mv mj b">this.subscribers</code>数组中的回调函数来发布更改。</p><p id="1c56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e2ee" class="mn lc iq mj b gy mo mp l mq mr">const callback = (e) =&gt; console.log(e);<br/>const callback2 = (e) =&gt; console.log(2, e);<br/>observer.addSubscriber(callback);<br/>observer.addSubscriber(callback2);<br/>observer.publish('foo')</span></pre><p id="7ccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了 2 个回调，并用<code class="fe mt mu mv mj b">addSubscriber</code>方法将它们添加到<code class="fe mt mu mv mj b">subscribers</code>数组中。</p><p id="ecc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe mt mu mv mj b">publish</code>来调用回调，回调记录了更改。</p><p id="7e6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该看到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5c09" class="mn lc iq mj b gy mo mp l mq mr">foo<br/>2 "foo"</span></pre><p id="bc62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在控制台日志中。</p><p id="3727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察者模式很好，因为回调和<code class="fe mt mu mv mj b">observer</code>对象之间没有太多的耦合。</p><p id="2abf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当有一些信息要发送给他们时，我们就调用回调函数。</p><p id="c1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调对<code class="fe mt mu mv mj b">observer</code>一无所知。</p><h1 id="2912" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试</h1><p id="6c16" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">测试是编写 JavaScript 应用程序的重要部分。</p><p id="f000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写自动运行的测试来使我们的生活变得更容易。</p><p id="afba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有足够的测试是一个坏主意。</p><p id="df72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过测试，我们确保现有代码的行为符合我们的规范。</p><p id="ce4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何新的代码变化都不会破坏我们的规范所定义的现有行为。</p><p id="a0bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了测试，我们不必亲自动手测试所有的东西。</p><p id="f642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当我们重构时，我们不必自己再次检查所有的东西。</p><p id="b2f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的改变使测试失败，那么我们知道有问题。</p><h1 id="d187" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单元测试</h1><p id="07ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">单元测试是我们最擅长的。</p><p id="b350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们很矮，跑得很快。</p><p id="1774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们在给定一些输入的情况下测试输出。</p><p id="6395" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们应该是自解释的、可维护的和可读的。</p><p id="791a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们在任何顺序下都应该以相同的方式工作。</p><h1 id="db37" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试驱动开发</h1><p id="bf93" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">测试驱动开发最近被大量使用，</p><p id="b123" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法工作流从编写一些失败的测试开始。</p><p id="395f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们编写代码使测试通过。</p><p id="e970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们再次运行测试，看看他们是否通过。</p><p id="f0f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们重构代码，确保我们的测试仍然通过。</p><h1 id="875b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">行为驱动发展</h1><p id="ece9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">行为驱动开发是一种方法，在这种方法中，我们创建测试来测试代码的行为。</p><p id="522a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一些输入进行测试，并检查输出。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9f753e6b7bf3965d5674a2c8f6506f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4FxRkskhxdsMPfaT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@craftedbygc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">绿色变色龙</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="0460" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fcf3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建单元测试来测试我们的代码。</p><p id="0f70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，观察者模式允许我们创建松散耦合的代码，从观察者到另一个对象进行通信。</p></div></div>    
</body>
</html>