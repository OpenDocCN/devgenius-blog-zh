<html>
<head>
<title>Password Hashing With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行密码散列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/password-hashing-with-python-f3148692e8b9?source=collection_archive---------0-----------------------#2021-09-11">https://blog.devgenius.io/password-hashing-with-python-f3148692e8b9?source=collection_archive---------0-----------------------#2021-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="317c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">即使用户密码被破解，也要保证其安全。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d70085c1f4493b309ddf49b20ac3c862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zz0ztGgICt0z192EqInOWg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由来自<a class="ae kv" href="https://www.pexels.com/photo/security-logo-60504/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kv" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</figcaption></figure><p id="6125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">身份验证是计算机应用程序和系统安全不可或缺的一部分。对于基于web的应用程序和其他支持internet的应用程序，健壮的身份验证更是一个大问题。想想看，只要在浏览器URL中输入一个域名，就可以轻松访问它们。</p><p id="9d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于互联网的系统将互联网作为其直接访问的关键。这意味着必须有一个强大的身份认证系统来防止未经授权的访问。</p><p id="6f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多在线应用程序采用基于密码的身份验证作为主要身份验证。然后，他们可以使用其他身份认证方法，如2FA和生物特征认证来增强这种能力。这使得拥有强大而安全的密码存储在防御网络攻击中变得必不可少。</p><p id="12b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过安全漏洞，攻击者可以访问您系统的凭证存储，但是您用户的密码应该保持安全和不被泄露。散列密码对每个人来说都是无形的，甚至对提供明文来生成它们的原始用户来说也是如此。</p><p id="157b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要以纯文本或任何可破译的格式存储用户密码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="518f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">密码哈希引领潮流</h1><p id="611b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了保护用户的密码，您必须将他们的明文密码转换为晦涩难懂的字符串，即哈希。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f47f" class="nb ma iq mx b gy nc nd l ne nf">2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span></pre><p id="4049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的字符串表示使用SHA-256哈希算法生成的明文<code class="fe ng nh ni mx b"><strong class="ky ir">hello</strong></code> <strong class="ky ir"> </strong>的哈希。</p><p id="b1bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">密码哈希是使用安全的哈希算法将明文密码转换为哈希字符串。这是一个单向的不可逆转变。</p><p id="33de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种散列算法可供选择。但是要注意避免不安全的，比如SHA-1的<strong class="ky ir">和MD5的<strong class="ky ir">。</strong>谷歌合作的一项研究<a class="ae kv" href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html" rel="noopener ugc nofollow" target="_blank">报告了</a>有史以来第一次SHA-1哈希算法的哈希冲突。这个报告意味着两个不同的输入实际上可以生成相同的散列。<strong class="ky ir"> MD5 </strong>很久以前就被认为是脆弱和不安全的，容易受到哈希冲突的攻击。</strong></p><p id="13d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仍然有几种散列算法是安全的，具有很强的抗冲突性。</p><p id="5be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python标准库<code class="fe ng nh ni mx b">hashlib</code>提供了一些强大的哈希算法，可以用来生成安全的哈希。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3f45" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用Python的hashlib模块散列密码</h1><p id="5a7b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/hashlib.html" rel="noopener ugc nofollow" target="_blank"> hashlib </a>是Python解释器附带的一个方便的哈希模块。除了Python解释器之外，不需要额外的安装。</p><p id="198b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">hashlib</code>模块提供了两种生成散列的方法。</p><p id="7f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。使用暴露在<code class="fe ng nh ni mx b">hashlib</code>模块上的哈希算法函数</strong>。<br/>调用这些函数会返回一个散列对象，其中包含检索生成的散列的方法。它还具有用于确定生成的哈希的块大小和摘要大小的属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/ac74b65f9f42c5c7b74270e4a751195a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld7ErLgLdlK6cMu_X6Lrtg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">hashlib模块上可用的散列算法函数</figcaption></figure><p id="a07c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。使用哈希算法</strong> <strong class="ky ir">类</strong>暴露在<code class="fe ng nh ni mx b">hashlib</code>模块上。这些散列算法类在被实例化时返回散列对象，该散列对象具有用于检索所生成的散列和其他便利信息的便利方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/43a48ed46120649609b334fc68c018fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*xh1wYaUBhWYdhuoQ2L0B3g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">hashlib模块上直接提供的散列算法类</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="480c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们生成一些散列</h1><p id="da5d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，像这样导入<code class="fe ng nh ni mx b">hashlib</code>模块</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="7291" class="nb ma iq mx b gy nc nd l ne nf">import hashlib</span></pre><p id="ba5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用这两种方法生成两个散列，首先使用散列函数，然后使用散列算法类。</p><h2 id="4506" class="nb ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated"><strong class="ak">使用</strong> <code class="fe ng nh ni mx b"><strong class="ak">hashlib.sha256(...)</strong></code> <strong class="ak">函数</strong>从明文 <code class="fe ng nh ni mx b"><strong class="ak">hello' </strong></code> <strong class="ak">生成密码哈希</strong></h2><p id="d9c9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>在<code class="fe ng nh ni mx b">hashlib</code>模块上公开的所有散列函数只接受输入或明文的编码字节串。因此，必须使用Python <a class="ae kv" href="https://docs.python.org/3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank"> str对象</a>上的<code class="fe ng nh ni mx b">encode()</code>方法将Unicode字符串转换成字节。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="13c1" class="nb ma iq mx b gy nc nd l ne nf">import hashlib</span><span id="8fa3" class="nb ma iq mx b gy nw nd l ne nf"># encode string "hello" to bytes<br/>plaintext = "hello".encode()</span><span id="4fe2" class="nb ma iq mx b gy nw nd l ne nf"># call the sha256(...) function returns a hash object<br/>d = hashlib.sha256(plaintext)</span><span id="75e8" class="nb ma iq mx b gy nw nd l ne nf"># generate binary hash of "hello" string<br/>hash = d.digest()<br/>print(hash)</span></pre><p id="4caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过调用hash对象<code class="fe ng nh ni mx b">h</code>上的<code class="fe ng nh ni mx b">digest()</code>方法，以字节为单位检索生成的hash</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="67a0" class="nb ma iq mx b gy nc nd l ne nf">\xf2M\xba_\xb0\xa3\x0e&amp;\xe8;*\xc5\xb9\xe2\x9e\x1b\x16\x1e\\\x1f\xa7B^s\x043b\x93\x8b\x98$</span></pre><p id="661c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此二进制哈希不友好。为了改变这一点，您将在hash对象上调用<code class="fe ng nh ni mx b">hexdigest()</code>方法来获得一个精简的、人类可读的十六进制表示。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f3cb" class="nb ma iq mx b gy nc nd l ne nf"># generate human readable hash of "hello" string<br/>hash = d.hexdigest()<br/>print(hash)</span></pre><p id="29ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="02f7" class="nb ma iq mx b gy nc nd l ne nf">2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用hashlib函数算法sha256生成二进制哈希和友好十六进制哈希的完整代码</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="0a71" class="nb ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated"><strong class="ak">使用</strong> <code class="fe ng nh ni mx b"><strong class="ak">hashlib.sha3_256</strong></code> <strong class="ak">类</strong>从明文 <code class="fe ng nh ni mx b"><strong class="ak">hello' </strong></code> <strong class="ak">生成密码哈希</strong></h2><p id="0f42" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在实例化时，<code class="fe ng nh ni mx b">hashlib</code>模块上可用的散列类的构造函数接受一个明文参数，这是一个编码的字符串。这个编码字符串被转换成一个不可逆的散列，它也可以以两种格式检索:使用<code class="fe ng nh ni mx b">digest()</code>的二进制和使用<code class="fe ng nh ni mx b">hexdigest()</code>的十六进制。</p><p id="accb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实例化哈希对象</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a228" class="nb ma iq mx b gy nc nd l ne nf">import hashlib</span><span id="23a9" class="nb ma iq mx b gy nw nd l ne nf">plaintext = "hello".encode()</span><span id="469b" class="nb ma iq mx b gy nw nd l ne nf"># instantiate sha3_256 object<br/>d = hashlib.sha3_256(plaintext)</span></pre><p id="cbfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过对散列对象<code class="fe ng nh ni mx b">d</code>调用<code class="fe ng nh ni mx b">digest()</code>方法来检索二进制散列。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1505" class="nb ma iq mx b gy nc nd l ne nf"># retrieve binary hash <br/>hash = d.digest()<br/>print(hash)</span></pre><p id="12a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e338" class="nb ma iq mx b gy nc nd l ne nf">38\xbeiOP\xc5\xf38\x81I\x86\xcd\xf0hdS\xa8\x88\xb8OBMy*\xf4\xb9 #\x98\xf3\x92</span></pre><p id="4306" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了检索人类友好的散列格式，我们将在散列对象上调用方法<code class="fe ng nh ni mx b">hexdigest()</code>。这将返回可读的十六进制字符串</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1a89" class="nb ma iq mx b gy nc nd l ne nf">hash = d.hexdigest()<br/>print(hash)  </span></pre><p id="ef1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9f50" class="nb ma iq mx b gy nc nd l ne nf">3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用hashlib类算法sha3_256生成二进制哈希和友好哈希的完整代码</figcaption></figure><h1 id="3d75" class="lz ma iq bd mb mc nz me mf mg oa mi mj jw ob jx ml jz oc ka mn kc od kd mp mq bi translated">其他有用的注释</h1><p id="d9dc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">除了<code class="fe ng nh ni mx b">digest()</code>和<code class="fe ng nh ni mx b">hexdigest()</code>之外，哈希函数和类返回的哈希对象公开了其他方便的方法和属性</p><p id="2050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">update(...)</code>这个方法允许你用额外的字符串更新你的初始明文。传递给<code class="fe ng nh ni mx b">update(...)</code>的更新字符串被连接到在函数调用或类实例化期间传递的初始明文。</p><p id="8852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:更新字符串就像传递给函数调用或类实例化一样，必须编码。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1e4d" class="nb ma iq mx b gy nc nd l ne nf">import hashlib</span><span id="d2c2" class="nb ma iq mx b gy nw nd l ne nf">plaintext = "hello".encode()</span><span id="c3a5" class="nb ma iq mx b gy nw nd l ne nf">d = hashlib.sha256(plaintext)</span><span id="7056" class="nb ma iq mx b gy nw nd l ne nf"># update the plaint text to "hellow0rld"<br/>d.update("w0rld".encode())</span><span id="77b0" class="nb ma iq mx b gy nw nd l ne nf"># retrieve a human-readable hash for "hellow0rld"<br/>hash = d.hexdigest()<br/>print(hash)</span></pre><p id="51db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">copy(...)</code>这将返回散列对象的副本。<br/>虽然使用Python比较操作符<code class="fe ng nh ni mx b">==</code>比较时对象不同，但当对其调用<code class="fe ng nh ni mx b">digest()</code>和<code class="fe ng nh ni mx b">hexdigest()</code>时，返回与原始对象相同的散列。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="47e9" class="nb ma iq mx b gy nc nd l ne nf">import hashlib</span><span id="5fd2" class="nb ma iq mx b gy nw nd l ne nf">plaintext = "hello".encode()</span><span id="7bb9" class="nb ma iq mx b gy nw nd l ne nf">d = hashlib.sha256(plaintext)</span><span id="a4a5" class="nb ma iq mx b gy nw nd l ne nf">d2 = d.copy()</span><span id="59ae" class="nb ma iq mx b gy nw nd l ne nf"># d not equal to d2, but both returns the same has<br/>d_hash = d.hexdigest()<br/>d2_hash = d.hexdigest()</span><span id="3b05" class="nb ma iq mx b gy nw nd l ne nf">print(d === d2) # returns False</span><span id="041b" class="nb ma iq mx b gy nw nd l ne nf">print(d_hash === d2_hash) # returns True</span></pre><p id="e226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">block_size</code>以字节为单位返回哈希算法的内部块大小。</p><p id="d423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">digest_size</code>以字节为单位返回结果散列的大小。</p><p id="6e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">name</code>hash对象的这个属性返回用于生成散列的散列算法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="651f" class="nb ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">结束语</h2><p id="1a38" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">哈希对于每个基于密码的认证系统的安全性是必不可少的，尤其是支持互联网的系统。哈希是一种单向函数，可以在网络入侵发生时减轻对用户信息的损害。它维护用户密码的机密性，使其在未经授权的第三方手中变得毫无用处。</p><p id="b885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在考虑简单直接地保护数据库中的用户密码，Python <code class="fe ng nh ni mx b">hashlib</code>是一个不错的起点。</p><p id="474e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回顾一下这篇文章中的重要内容和“hashlib”模块。</p><ol class=""><li id="27ba" class="oe of iq ky b kz la lc ld lf og lj oh ln oi lr oj ok ol om bi translated"><code class="fe ng nh ni mx b">hashlib</code>模块提供了两种生成哈希的方法，基于类库和基于函数的哈希算法。</li><li id="9fad" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated">由函数散列算法和散列类这两种方法中的任何一种返回的散列对象公开了以下方法<code class="fe ng nh ni mx b">digest()</code>、<code class="fe ng nh ni mx b">hexdigest()</code>、<code class="fe ng nh ni mx b">udpate()</code>、<code class="fe ng nh ni mx b">copy</code>和以下属性<code class="fe ng nh ni mx b">digest_size</code>、<code class="fe ng nh ni mx b">block_size</code>、<code class="fe ng nh ni mx b">name</code></li><li id="3397" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><code class="fe ng nh ni mx b">MD5</code>和<code class="fe ng nh ni mx b">SHA1</code>被认为是不安全的，容易受到碰撞攻击</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="68bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="os">嘿，感谢您花时间阅读这篇文章。在你走之前，我想让你知道一些事情。您可以通过</em> <a class="ae kv" href="https://ofelix03.medium.com/membership" rel="noopener"> <strong class="ky ir"> <em class="os">加盟媒介</em> </strong> </a> <em class="os">以我的</em> <a class="ae kv" href="https://ofelix03.medium.com/membership" rel="noopener"> <strong class="ky ir"> <em class="os">推荐链接</em> </strong> </a> <em class="os">作为付费会员支持我的写作。只需5美元</em> <strong class="ky ir"> <em class="os"> </em> </strong> <em class="os">您就可以拥有</em> <strong class="ky ir"> <em class="os">对内容</em> </strong> <em class="os">的完全访问权限，就像您刚刚阅读的内容以及更多内容一样。如果你今天</em> <a class="ae kv" href="https://ofelix03.medium.com/membership" rel="noopener"> <strong class="ky ir"> <em class="os">加入</em> </strong> </a> <em class="os">，我会从你的5美元会员费中收取一小笔佣金，不需要你支付任何额外费用。</em></p><div class="ot ou gp gr ov ow"><a href="https://ofelix03.medium.com/membership" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">通过我的推荐链接加入媒体-费利克斯·奥托</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">ofelix03.medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kp ow"/></div></div></a></div></div></div>    
</body>
</html>