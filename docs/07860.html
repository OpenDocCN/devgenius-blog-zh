<html>
<head>
<title>React Query and why you should use it!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 查询以及为什么应该使用它！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-query-and-why-you-should-use-it-22127afa1d04?source=collection_archive---------2-----------------------#2022-04-28">https://blog.devgenius.io/react-query-and-why-you-should-use-it-22127afa1d04?source=collection_archive---------2-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="047c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React Query 简化了获取、缓存和更新数据，即使没有全局状态！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a47068c008c79f405a71c22864c76ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xw2bNJNjX_vDwpfc2WdIA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这只棒极了的狗正在吸引人！</figcaption></figure><p id="b613" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们创建新的应用程序时，我们有许多架构选择要做。其中之一是创建一个从我们的服务器获取数据的模式。在获取数据时，有几个问题需要考虑；</p><ul class=""><li id="723a" class="lo lp in ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">应该使用全局状态缓存获取的数据，还是在每次装载组件时重新获取？</li><li id="d927" class="lo lp in ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">如果数据缓存在全局状态中，我们如何知道数据何时过期，或者我们如何将它标记为过期？</li><li id="2593" class="lo lp in ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">怎样才能轻易的让缓存失效？</li><li id="5d64" class="lo lp in ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">我们应该如何处理获取状态，加载，出错等。？</li><li id="2d58" class="lo lp in ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">当某些查询操作失败时，如何启用重试？</li></ul><p id="812b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以上所有问题都是使用 React Query 的原因。它简化了为数据获取创建可维护模式的工作！</p><p id="2dc8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mc">在深入举例之前，我需要澄清 React 查询是</em> <strong class="ku io"> <em class="mc">而不是</em> </strong> <em class="mc">与</em> <strong class="ku io"> <em class="mc"> </em> </strong> <em class="mc">相同的 Axios 或 fetch API，也不是 Redux 或 Context API 替换。</em></p><p id="29ee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们来看一个例子。在下面的代码中，我们假设我们有一个 TypeScript 文件，该文件包含一个获取方法来获取返回承诺的用户配置文件。(您可以使用 Axios、fetch-API 或任何其他您喜欢的 HTTP 客户端，只要它返回一个承诺)。下面的示例是显示用户名的个人资料页面。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="1e45" class="mi mj in me b gy mk ml l mm mn">import { useQuery } from 'react-query';<br/>import { getUserProfile } from '@api/profile.ts';</span><span id="9c8d" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {<br/>const { data: userProfile } = <strong class="me io">useQuery</strong>('UserProfile', getUserProfile);</span><span id="318d" class="mi mj in me b gy mo ml l mm mn">return {<br/>   &lt;h1&gt;Hello, { userProfile.name }&lt;/h1&gt;<br/>}}</span></pre><p id="84b6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如您所见，我们使用了 useQuery-hook 形式的 React 查询，它有两个参数:缓存键，第二个参数是一个函数，它返回解析数据或抛出错误的承诺。</p><p id="36b9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如我们所看到的，获取用户名并在屏幕上打印出来很简单，但是如何知道它何时加载呢？</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="cd2e" class="mi mj in me b gy mk ml l mm mn">import { useQuery } from 'react-query';<br/>import { getUserProfile } from '@api/profile.ts';</span><span id="3596" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {</span><span id="54bd" class="mi mj in me b gy mo ml l mm mn">const { data: userProfile, <strong class="me io">isLoading: isUserProfileLoading</strong> } = useQuery('UserProfile', getUserProfile);</span><span id="c7bf" class="mi mj in me b gy mo ml l mm mn">return {<br/><strong class="me io">isUserProfileLoading </strong>?<br/> (&lt;p&gt; Loading user profile&lt;/p &gt;) :<br/> (&lt;h1&gt;Hello, {userProfile?.name}&lt;/h1&gt;)<br/>}}</span></pre><p id="f500" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如我们所看到的，知道用户概要文件何时加载是很简单的。React Query 正在为我们处理这些状态。是的，它也很容易出错。请参见下面的示例。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="5818" class="mi mj in me b gy mk ml l mm mn">import { useQuery } from 'react-query';<br/>import { getUserProfile } from '@api/profile.ts';</span><span id="4b85" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {</span><span id="b071" class="mi mj in me b gy mo ml l mm mn">const { data: userProfile, isLoading: isUserProfileLoading, <strong class="me io">isError: isUserProfileError</strong> } = useQuery('UserProfile', getUserProfile);</span><span id="fab1" class="mi mj in me b gy mo ml l mm mn">return {</span><span id="30bf" class="mi mj in me b gy mo ml l mm mn">&lt;&gt;<br/><strong class="me io">isUserProfileError</strong> &amp;&amp; &lt;p&gt;Something went wrong while fetching&lt;/p&gt;<br/> isUserProfileLoading ?<br/>  (&lt;p&gt; Loading user profile&lt;/p &gt;) :<br/>  (&lt;h1&gt;Hello, {userProfile?.name}&lt;/h1&gt;)<br/>&lt;/&gt;<br/>}}</span></pre><p id="065b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们知道 React Query 是一个非常好的库，可以轻松地从服务器获取数据。但是如果需要的话，我们如何重新获取用户配置文件呢？我们可以像处理 isLoading 和 isError 状态一样简单地做到这一点。请参见下面的示例。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="7fc2" class="mi mj in me b gy mk ml l mm mn">import { useQuery } from 'react-query';<br/>import { getUserProfile } from '@api/profile.ts';</span><span id="60c7" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {</span><span id="3131" class="mi mj in me b gy mo ml l mm mn">const { data: userProfile, isLoading: isUserProfileLoading, isError: isUserProfileError, <strong class="me io">refetch: refetchUserProfile </strong>} = useQuery('UserProfile', getUserProfile);</span><span id="851a" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const onRefetchUserProfile = async(): Promise&lt;void&gt; =&gt; {<br/>  await refetchUserProfile();<br/>}</strong></span><span id="4671" class="mi mj in me b gy mo ml l mm mn">return {<br/>&lt;&gt;<br/>isUserProfileError &amp;&amp; &lt;p&gt;Something went wrong while fetching&lt;/p&gt;<br/>isUserProfileLoading ?<br/> (&lt;p&gt; Loading user profile&lt;/p &gt;) :<br/> (&lt;h1&gt;Hello, {userProfile?.name}&lt;/h1&gt;)</span><span id="80e0" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">&lt;button type="button" onClick={onRefetchUserProfile}&gt;<br/>  Re-fetch the user profile<br/>&lt;/button&gt;</strong><br/>&lt;/&gt;<br/>}}</span></pre><p id="5471" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们已经看到了一些如何轻松获取和重新获取数据的例子，但是我们如何更新数据呢？为了更新数据，我们需要使用 React 查询突变。请参见下面的示例。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="85f7" class="mi mj in me b gy mk ml l mm mn">import { useQuery, <strong class="me io">useMutation </strong>} from 'react-query';<br/>import { getUserProfile, <strong class="me io">updateUserProfile</strong> } from '@api/profile.ts';</span><span id="ae55" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {</span><span id="357e" class="mi mj in me b gy mo ml l mm mn">const { data: userProfile, isLoading: isUserProfileLoading, isError: isUserProfileError, refetch: refetchUserProfile<strong class="me io"> </strong>} = useQuery('UserProfile', getUserProfile);</span><span id="2772" class="mi mj in me b gy mo ml l mm mn">const onRefetchUserProfile = async(): Promise&lt;void&gt; =&gt; {<br/>  await refetchUserProfile();<br/>}</span><span id="5b15" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const { mutation: userProfileMutation, isLoading: isUserProfileMutationLoading, isError: isUserProfileMutationError }= useMutation((username: string) =&gt;    <br/> updateUserProfile(username));</strong></span><span id="7cb5" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const handleOnFormSubmit = (formEvent): void =&gt; {<br/> const inputValue = formEvent.target.username.value;<br/> userProfileMutation(inputValue)<br/>}</strong></span><span id="a1b7" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const componentHasError = isUserProfileError || <br/> isUserProfileMutationError;</strong></span><span id="3a30" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const isComponentLoading = isUserProfileLoading ||  <br/> isUserProfileMutationLoading;</strong></span><span id="9741" class="mi mj in me b gy mo ml l mm mn">return {<br/>&lt;&gt;<br/> <strong class="me io">componentHasError </strong>&amp;&amp; &lt;p&gt;Something went wrong while fetching&lt;/p&gt;<br/> <strong class="me io">isComponentLoading </strong>?<br/>  (&lt;p&gt; Loading user profile&lt;/p &gt;) :<br/>  (&lt;h1&gt;Hello, {userProfile?.name}&lt;/h1&gt;)</span><span id="c34f" class="mi mj in me b gy mo ml l mm mn"> &lt;button type="button" onClick={onRefetchUserProfile}&gt;<br/>   Re-fetch the user profile<br/> &lt;/button&gt;</span><span id="bae3" class="mi mj in me b gy mo ml l mm mn"><strong class="me io"> &lt;form onSubmit="handleOnFormSubmit"&gt;<br/>   &lt;input type="text" name="username" /&gt;<br/>   &lt;button type="submit"&gt;Save profile data&lt;/button&gt;<br/> &lt;/form&gt;<br/></strong>&lt;/&gt;<br/>}}</span></pre><p id="b831" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果上面例子中的更新出错，变异的 isError 状态将被设置为 true，这意味着我们可以创建一个 componentHasError 变量来保存获取和更新的错误状态。React Query 甚至使错误处理变得更加容易。</p><p id="6997" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的代码有一个问题，我们缓存的用户配置文件数据是错误的，因为我们更新了服务器上的数据，但我们没有使缓存无效。在服务器上更新用户配置文件数据后，我们没有重新获取它。请参见下面的示例，了解如何使缓存无效。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="3d82" class="mi mj in me b gy mk ml l mm mn">import { useQuery, useMutation } from 'react-query';<br/>import { getUserProfile, updateUserProfile } from '@api/profile.ts';</span><span id="9ee4" class="mi mj in me b gy mo ml l mm mn">export const MyProfile = (): JSX.Element =&gt; {</span><span id="39eb" class="mi mj in me b gy mo ml l mm mn">const { data: userProfile, isLoading: isUserProfileLoading, isError: isUserProfileError, refetch: refetchUserProfile<strong class="me io"> </strong>} = useQuery('UserProfile', getUserProfile);</span><span id="ed6a" class="mi mj in me b gy mo ml l mm mn">const onRefetchUserProfile = async(): Promise&lt;void&gt; =&gt; {<br/>  await refetchUserProfile();<br/>}</span><span id="a502" class="mi mj in me b gy mo ml l mm mn">const { mutation: userProfileMutation, isLoading: isUserProfileMutationLoading, isError: isUserProfileMutationError }= useMutation((username: string) =&gt;    <br/> updateUserProfile(username));</span><span id="0061" class="mi mj in me b gy mo ml l mm mn"><strong class="me io">const</strong> <strong class="me io">invalidateUserProfileCache = (): Promise&lt;void&gt; =&gt;  <br/> queryClient.invalidateQueries('UserProfile');</strong></span><span id="8653" class="mi mj in me b gy mo ml l mm mn">const handleOnFormSubmit = (formEvent): void =&gt; {<br/> const inputValue = formEvent.target.username.value;<br/>  userProfileMutation(inputValue, <strong class="me io">{<br/>    onSuccess: async () =&gt; {<br/>      await invalidateUserProfileCache();<br/>    }<br/>  }</strong>)<br/>}</span><span id="b9cc" class="mi mj in me b gy mo ml l mm mn">const componentHasError = isUserProfileError || <br/> isUserProfileMutationError;</span><span id="486b" class="mi mj in me b gy mo ml l mm mn">const isComponentLoading = isUserProfileLoading ||  <br/> isUserProfileMutationLoading;</span><span id="47bb" class="mi mj in me b gy mo ml l mm mn">return {<br/>&lt;&gt;<br/> componentHasError &amp;&amp; &lt;p&gt;Something went wrong while fetching&lt;/p&gt;<br/> isComponentLoading ?<br/>  (&lt;p&gt; Loading user profile&lt;/p &gt;) :<br/>  (&lt;h1&gt;Hello, {userProfile?.name}&lt;/h1&gt;)</span><span id="eeb0" class="mi mj in me b gy mo ml l mm mn">&lt;button type="button" onClick={onRefetchUserProfile}&gt;<br/>   Re-fetch the user profile<br/> &lt;/button&gt;</span><span id="6f69" class="mi mj in me b gy mo ml l mm mn">&lt;form onSubmit="handleOnFormSubmit"&gt;<br/>   &lt;input type="text" name="username" /&gt;<br/>   &lt;button type="submit"&gt;Save profile data&lt;/button&gt;<br/> &lt;/form&gt;<strong class="me io"><br/></strong>&lt;/&gt;<br/>}}</span></pre><p id="e4f7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如我们所看到的，使缓存无效很简单。我们只需要告诉 React Query 在变异成功时使缓存失效。好的一面是，当我们使缓存失效时，React Query 会自动从服务器重新获取更新的数据。不需要手动调用重新获取方法。</p><h1 id="17a8" class="mp mj in bd mq mr ms mt mu mv mw mx my jt mz ju na jw nb jx nc jz nd ka ne nf bi translated"><strong class="ak"> QueryClientProvider </strong></h1><p id="73d3" class="pw-post-body-paragraph ks kt in ku b kv ng jo kx ky nh jr la lb ni ld le lf nj lh li lj nk ll lm ln ig bi translated">要使用 React Query，有必要在组件树的顶层添加<strong class="ku io"> QueryClientProvider </strong>，或者将范围扩展到应该能够使用 React Query 的组件。提供程序必须提供在组件之间共享的 QueryClient。QueryClient 使缓存可供其他组件使用。所有使用具有相同缓存键的 useQuery 的组件，React Query，将使用来自缓存的数据，而不是再次从 API 获取。您可以在这里阅读关于查询客户端的更多信息。<a class="ae nl" href="https://react-query.tanstack.com/reference/QueryClientProvider" rel="noopener ugc nofollow" target="_blank">https://react-query . tan stack . com/reference/query client provider</a></p><h1 id="1b85" class="mp mj in bd mq mr ms mt mu mv mw mx my jt mz ju na jw nb jx nc jz nd ka ne nf bi translated">小费！</h1><p id="9e38" class="pw-post-body-paragraph ks kt in ku b kv ng jo kx ky nh jr la lb ni ld le lf nj lh li lj nk ll lm ln ig bi translated">为了提高代码质量并保持代码库的可维护性，我建议创建自定义挂钩来处理查询，而不是直接在组件中使用 react-query。对于上面的例子，我们应该创建一个自定义钩子，命名为类似于<em class="mc"> useUserProfileData。</em>然后这个定制钩子实现 React 查询。这使得我们的代码库更加健壮，因为我们可以创建一个方法来使我们的查询无效，而不是在我们的应用程序中利用缓存键，并且可能拼错缓存键。</p><h1 id="8e15" class="mp mj in bd mq mr ms mt mu mv mw mx my jt mz ju na jw nb jx nc jz nd ka ne nf bi translated">结论</h1><p id="c7e8" class="pw-post-body-paragraph ks kt in ku b kv ng jo kx ky nh jr la lb ni ld le lf nj lh li lj nk ll lm ln ig bi translated">React Query 确实为我们处理了许多与获取、更新、缓存和重试相关的挑战。该库使我们不必花费数小时来开发解决数据读取中普遍挑战的解决方案。使用像 React Query 这样的库，我们不需要维护自定义库来获取数据。</p><p id="8f0e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">React Query 有很好的文档记录，它使新的团队成员很容易获得处理应用程序获取部分所需的知识。</p><p id="778b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢阅读这篇文章，我希望你喜欢它！:-)</p></div></div>    
</body>
</html>