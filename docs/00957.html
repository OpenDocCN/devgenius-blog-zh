<html>
<head>
<title>How to effectively use git rebase — onto?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地使用 git rebase — onto？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-effectively-use-git-rebase-onto-1296c8a7743?source=collection_archive---------26-----------------------#2020-06-20">https://blog.devgenius.io/how-to-effectively-use-git-rebase-onto-1296c8a7743?source=collection_archive---------26-----------------------#2020-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d62083572d4589fba7eae003c3413e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m6gDczRJZ9V7YACA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">git rebase —到</figcaption></figure><p id="1afb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章最初发表于<a class="ae kx" href="https://belev.dev/how-to-effectively-use-git-rebase-onto" rel="noopener ugc nofollow" target="_blank">https://belev.dev/how-to-effectively-use-git-rebase-onto</a></p><p id="975b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将进一步探索<code class="fe ky kz la lb b">git rebase --onto</code>命令。它是什么，如何在重定基础后使用它来修复 Git 分支，如何改变分支的基础，等等？我们将通过探索<code class="fe ky kz la lb b">git rebase --onto</code>真正有用的真实世界场景来学习这些东西。</p><p id="dfaf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们开始吧！</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="b7d1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">快速<code class="fe ky kz la lb b">git rebase</code>回顾</h1><p id="7efd" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">访问<a class="ae kx" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank">文档</a>，我们会看到以下解释:</p><blockquote class="mm mn mo"><p id="b97e" class="jz ka mp kb b kc kd ke kf kg kh ki kj mq kl km kn mr kp kq kr ms kt ku kv kw ig bi translated"><em class="in">在另一个基础提示上重新应用提交</em></p></blockquote><p id="3669" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里最重要的一点是<em class="mp">基</em>是什么意思/指什么？这是上一次/父提交。让我们来看一个例子，这样会更清楚:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="6311" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        f--g--h  feature</span></pre><p id="4357" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ky kz la lb b">h</code>之前提交的是<code class="fe ky kz la lb b">g</code>。这意味着<code class="fe ky kz la lb b">h</code>的基数是<code class="fe ky kz la lb b">g</code>。</p><p id="9a48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在的<code class="fe ky kz la lb b">feature</code>的底座是<code class="fe ky kz la lb b">c</code>。通过检出<code class="fe ky kz la lb b">feature</code>分支并执行<code class="fe ky kz la lb b">git rebase master</code>，我们将把<code class="fe ky kz la lb b">feature</code>分支的基础改为<code class="fe ky kz la lb b">e</code>。</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="a074" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>             \<br/>              f'--g'--h'  feature</span></pre><p id="1ea9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<a class="ae kx" href="https://belev.dev/git-merge-vs-rebase-to-keep-feature-branch-up-to-date" rel="noopener ugc nofollow" target="_blank">之前的博客文章</a>中提到，这是创建新的提交，Git 历史被改变。在<code class="fe ky kz la lb b">f</code>、<code class="fe ky kz la lb b">g</code>、<code class="fe ky kz la lb b">h</code>之后的<code class="fe ky kz la lb b">'</code>，我们展示了这些是不同的提交。但是它们包含相同的变化。</p><p id="8160" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们只有两个分支，并且希望一个分支在另一个分支之上保持同步时，<code class="fe ky kz la lb b">git rebase</code>可以完美地工作。然而，当我们需要在旧的基础上做出改变时，这是不够的。这里<code class="fe ky kz la lb b">git rebase --onto</code>进来帮忙。</p><h1 id="0ca4" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated">什么是<code class="fe ky kz la lb b">git rebase --onto</code>？</h1><p id="1bdb" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们可以说这是更改父分支的更精确的方式。它接受三个参数— <code class="fe ky kz la lb b">&lt;new-base&gt;</code>、<code class="fe ky kz la lb b">&lt;old-base&gt;</code>、<code class="fe ky kz la lb b">&lt;end-inclusive&gt;</code>，其中第三个是可选的。这使我们能够完全控制我们想要重定基础的内容和位置。</p><p id="684c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们以前面的例子为例，使用<code class="fe ky kz la lb b">--onto</code>获得相同的结果。</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="53b0" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        f--g--h  feature</span></pre><p id="1b8a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们想让<code class="fe ky kz la lb b">feature</code>离开<code class="fe ky kz la lb b">master</code>。所以我们知道我们的新基地是什么，它是<code class="fe ky kz la lb b">master</code>。旧基础是我们在分支中的第一个提交的基础，这意味着它将是<code class="fe ky kz la lb b">c</code>。现在我们知道了新的和旧的基础，我们可以运行命令:<code class="fe ky kz la lb b">git rebase --onto master c</code>。</p><p id="578c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将引导我们:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="81f6" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>             \<br/>              f'--g'--h'  feature</span></pre><p id="7f89" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">结果和使用<code class="fe ky kz la lb b">git rebase master</code>一样。这向我们表明，他们在做同样的事情。<code class="fe ky kz la lb b">git rebase</code> master 只是<code class="fe ky kz la lb b">git rebase --onto master &lt;old-base&gt;</code>的速记语法。</p><h1 id="da39" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated">如何跳过不需要的提交来改变基础？</h1><p id="1659" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们已经看到了使用<code class="fe ky kz la lb b">--onto</code>最简单的情况。让我们再看一下前面的例子，但是我们不希望 commit <code class="fe ky kz la lb b">f</code>出现在 rebase 之后，因为它不再相关了。</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="d147" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        f--g--h  feature</span></pre><p id="9c46" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">运行<code class="fe ky kz la lb b">git rebase --onto master f</code>给了我们:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="268c" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>             \<br/>              g--h  feature</span></pre><blockquote class="mm mn mo"><p id="da18" class="jz ka mp kb b kc kd ke kf kg kh ki kj mq kl km kn mr kp kq kr ms kt ku kv kw ig bi translated"><em class="in">注意为</em> <code class="fe ky kz la lb b"><em class="in">&lt;old-base&gt;</em></code> <em class="in">提供的值。认为它具有包容性是一个常见的错误。</em></p></blockquote><p id="032d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">重要的是要记住/理解我们是在与基础打交道，而不是某个特定的承诺。<code class="fe ky kz la lb b">g</code>的基础是<code class="fe ky kz la lb b">f</code>，所以当我们说<code class="fe ky kz la lb b">&lt;old-base&gt;</code>是<code class="fe ky kz la lb b">f</code>时，这将被提供的<code class="fe ky kz la lb b">&lt;new-base&gt;</code>改变，我们将以这种方式释放提交<code class="fe ky kz la lb b">f</code>。</p><h1 id="7378" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated">如何在重设基础后从分支修复分支</h1><p id="89b8" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">与多人一起工作或者在一个大的代码库中工作，几乎可以肯定的是，在某个时候你将需要从一个分支中创建一个分支。例如，您需要启动一个新特性，但是它依赖于另一个特性，因此您需要从以前的分支启动您的分支。或者您有自动化 QA，它从您的特性分支创建一个分支。</p><p id="fa7b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们来看看这个问题的直观表示:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="f5bd" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        f--g--h  feature-1<br/>               \<br/>                i--j--k--l  feature-2</span></pre><p id="56e0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种情况下，您想要移动整个树以基于<code class="fe ky kz la lb b">master</code>。这意味着<code class="fe ky kz la lb b">feature-1</code>将被重新设定在<code class="fe ky kz la lb b">master</code>的顶部，而<code class="fe ky kz la lb b">feature-2</code>将被重新设定在<code class="fe ky kz la lb b">feature-1</code>的顶部。</p><p id="501f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们检查<code class="fe ky kz la lb b">feature-1</code>并运行<code class="fe ky kz la lb b">git rebase master</code>。这将导致:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="f997" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>      |      \<br/>      |       f'--g'--h'  feature-1<br/>       \<br/>        f--g--h--i--j--k--l  feature-2</span></pre><p id="ee26" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您已经打开了从<code class="fe ky kz la lb b">feature-2</code>到<code class="fe ky kz la lb b">feature-1</code>分支的 PR，您将在您的 PR 中看到来自<code class="fe ky kz la lb b">feature-1</code>的提交。没有必要担心，因为正如我们可以从上面的视觉表示和下面的图像中看到的，这是意料之中的。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/6b543cbd57a29dd3b2ee2146d81a03a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KG4RgSnRxM5ugZW7aQXgw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">重设基础特征-1 个结果</figcaption></figure><p id="83e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们现在可以检查<code class="fe ky kz la lb b">feature-2</code>并运行<code class="fe ky kz la lb b">git rebase --onto h' h</code>。这给了我们:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="2c6f" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>             \<br/>              f'--g'--h'  feature-1<br/>                       \<br/>                        i'--j'--k'--l'  feature-2</span></pre><p id="fe0d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请记住，如果 f/g/h 与 f'/g'/h '相同，有时简单的<code class="fe ky kz la lb b">git rebase feature-1</code>会起作用。Git 足够聪明，当我们使用 rebase 时，它将/能够删除具有相同变更集的提交。然而，检查另一个分支中的所有内容是否都相同是困难和烦人的，在这里使用<code class="fe ky kz la lb b">--onto</code>是更好的选择，因为否则，它会导致一个分支有不属于它的提交。</p><p id="ec65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你应该试试<code class="fe ky kz la lb b">--onto</code>。然而，如果你还没有准备好，或者你不想使用它，并在上述情况下结束，有一个交互式 rebase 的解决方案。从<code class="fe ky kz la lb b">feature-1</code>重设<code class="fe ky kz la lb b">feature-2</code>的基础。检查是否有不属于该分支的提交，并通过进行交互式 rebase 来删除这些提交。如果你不熟悉如何做到这一点，看看以前的博客文章<a class="ae kx" href="https://belev.dev/some-of-the-most-used-git-interactive-rebase-options" rel="noopener ugc nofollow" target="_blank">一些最常用的 Git 交互式 rebase 选项</a>。</p><p id="957c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我们几个月来的一个问题。人们对他们在开放的 PRs 中看到的变化感到惊讶。毕竟，你什么也没做，突然你在你的 PR 中看到一些不属于那里的提交。这似乎很奇怪，但希望通过这篇文章，这将被清除，它不会再奇怪了。</p><h1 id="465a" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated">如何改变 Git 分支的基数？</h1><p id="9aed" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们时常需要改变树枝的底部。两个例子是:</p><ul class=""><li id="f9ef" class="nm nn in kb b kc kd kg kh kk no ko np ks nq kw nr ns nt nu bi translated">我们还没有从正确的分支开始我们的分支</li><li id="fbc6" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">我们从<code class="fe ky kz la lb b">master</code>开始工作，但是一位同事在他/她的部门做了一些改变，这将使我们的生活变得更容易。然后也许我们想把<code class="fe ky kz la lb b">master</code>换成一个基数，用同事的分支改动。</li></ul><p id="e5b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了更好地理解，我们来看一个直观的表示:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="678c" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>             \<br/>              f--g  feature-1<br/>                  \<br/>                   h--i  feature-2</span></pre><p id="f4fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们从<code class="fe ky kz la lb b">feature-1</code>开始我们的分支<code class="fe ky kz la lb b">feature-2</code>，但是我们做错了。这些特征被证明根本没有联系，我们希望我们的<code class="fe ky kz la lb b">feature-2</code>分支从<code class="fe ky kz la lb b">master</code>开始。</p><p id="ebaa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将使用<code class="fe ky kz la lb b">--onto</code>并不奇怪。于是我们有了<code class="fe ky kz la lb b">git rebase --onto &lt;new-base&gt; &lt;old-base&gt;</code>。我们的老基地是<code class="fe ky kz la lb b">feature-1</code>，我们从那里开始了我们的分公司。我们的新基地应该是<code class="fe ky kz la lb b">master</code>，因为我们希望我们的分公司从这里开始。我们要处决<code class="fe ky kz la lb b">git rebase --onto master feature-1</code>。</p><p id="06e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这给了我们:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="c19f" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>            | \<br/>            |  f--g  feature-1<br/>             \<br/>              h--i  feature-2</span></pre><p id="cb74" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们在工作中使用<a class="ae kx" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Git flow </a>，并且不时地改变分支的基础。在我们的例子中，主要是当热修复分支不是从正确的分支创建的时候。例如，hotfix 分支是开放的，但是我们从发布分支开始我们的分支。然后，我们需要将基础从版本更改为修补程序。</p><h1 id="fa29" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated"><code class="fe ky kz la lb b">git rebase --onto</code>第三个论点怎么用？</h1><p id="9f6a" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated"><code class="fe ky kz la lb b">git rebase --onto</code>采用第三个参数，该参数用作结束点。</p><p id="ffe5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们看下面的例子:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="38b6" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        f--g--h--i--j--k--l  feature</span></pre><p id="19f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们希望从<code class="fe ky kz la lb b">master</code>重新设定<code class="fe ky kz la lb b">feature</code>的基础，但是只接受某些提交——从<code class="fe ky kz la lb b">h</code>到<code class="fe ky kz la lb b">j</code>。我们已经看到了如何使用<code class="fe ky kz la lb b">--onto</code>跳过冗余提交。如果我们只想这样做，我们需要执行<code class="fe ky kz la lb b">git rebase --onto master g</code>。</p><p id="3a02" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们想要最后一个的具体提交。<code class="fe ky kz la lb b">--onto</code>的第三个论点正是我们想要的。所以我们只需要说哪一个是最后一次提交。</p><blockquote class="mm mn mo"><p id="9983" class="jz ka mp kb b kc kd ke kf kg kh ki kj mq kl km kn mr kp kq kr ms kt ku kv kw ig bi translated"><em class="in">注:含括取。</em></p></blockquote><p id="57af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">运行<code class="fe ky kz la lb b">git rebase --onto master g j</code>，这将为我们提供:</p><pre class="mt mu mv mw gt mx lb my mz aw na bi"><span id="9b80" class="nb lk in lb b gy nc nd l ne nf">a--b--c--d--e  master<br/>       \<br/>        h--i--j  feature</span></pre><h1 id="2e03" class="lj lk in bd ll lm ng lo lp lq nh ls lt lu ni lw lx ly nj ma mb mc nk me mf mg bi translated">结论</h1><p id="ee92" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们更深入地研究了<code class="fe ky kz la lb b">git rebase --onto</code>。它是更高级的命令之一，使用它我们可以轻松地解决我们分支的某些 Git 问题。即使我们对此一无所知，我们也可以通过命令的组合来解决我们的问题——普通的和交互式的 rebase、cherry-pick 等。作为开发人员，我们应该尽可能多地尝试自动化我们的工作，因此使用较少数量的命令是了解<code class="fe ky kz la lb b">--onto</code>的充分条件。</p><p id="9d54" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们讨论了很多内容，所以让我们快速总结一下:</p><ul class=""><li id="dc18" class="nm nn in kb b kc kd kg kh kk no ko np ks nq kw nr ns nt nu bi translated">快速回顾一下<code class="fe ky kz la lb b">git rebase</code>，它<em class="mp">的基础</em>和 rebase 的作用</li><li id="c2df" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">使用<code class="fe ky kz la lb b">git rebase --onto</code>给了我们什么</li><li id="4381" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">如何使用<code class="fe ky kz la lb b">--onto</code>改变分支的基础并跳过不需要的提交</li><li id="1961" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">当我们有一个更深的分支结构——从一个分支到另一个分支——时，如何调整我们的分支</li><li id="d7b9" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">如何改变 Git 分支的基础，为什么它会有用</li><li id="c76b" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated">使用带有 3 个参数的完整形式的<code class="fe ky kz la lb b">git rebase --onto</code>,这允许我们从头到尾只进行某些提交</li></ul><p id="c627" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谢谢你把这个看完。我希望你喜欢它并且学到一些新的东西。如果是这样，请在<a class="ae kx" href="https://twitter.com/BelevMartin" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，我会在那里分享其他的技巧、新文章和我学到的东西。如果你想了解更多，想和我聊聊软件开发，或者给我一些反馈，不要害羞，给我发个邮件。</p></div></div>    
</body>
</html>