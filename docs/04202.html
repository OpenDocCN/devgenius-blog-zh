<html>
<head>
<title>Android Generic RecyclerView Adapter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 通用 RecyclerView 适配器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/android-generic-recyclerview-adapter-67eb8f826cad?source=collection_archive---------1-----------------------#2021-02-09">https://blog.devgenius.io/android-generic-recyclerview-adapter-67eb8f826cad?source=collection_archive---------1-----------------------#2021-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/79ca623df197700dd4dcc5650eb2f165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLiUINfhcoIxCorgEGqcKQ.png"/></div></div></figure><h1 id="aa23" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">先决条件</h1><blockquote class="kt ku kv"><p id="d4f5" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">Kotlin、Recyclerview、Viewbinding、Kotlin <a class="ae lv" href="https://kotlinlang.org/docs/reference/lambdas.html" rel="noopener ugc nofollow" target="_blank">高阶函数和 Lambdas </a>(可选)</p></blockquote><p id="98ac" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">对于 android 开发人员来说，为每个回收器视图创建大量适配器是非常累人的，尽管我们最喜欢的 ANDROID STUDIO IDE 为我们提供了许多功能来编写更少的代码。在作为 Android 开发人员的几年中，我不得不为每个条目列表编写几个适配器。但是每一个新的特性往往会让我面临更大的挑战，这给我带来了经验，也带来了一些问题。</p><p id="4f6d" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">我遇到的最大挑战之一是在创建适配器和视图固定器后更改适配器列表数据类型，因为您必须多次更改整个适配器类中的模型对象，还必须更改视图固定器绑定方法。</p><p id="e19b" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">对于一个使用了大量 recyclerview 的大项目来说，这真的很烦人。</p><h1 id="0ee8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">解决办法</h1><p id="7690" class="pw-post-body-paragraph kw kx in kz b la lz lc ld le ma lg lh lw mb lk ll lx mc lo lp ly md ls lt lu ig bi translated">简单！！。只需创建一个泛型类型适配器和视图容器。</p><p id="ff89" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io">第一步:</strong></p><p id="1653" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">创建名为<strong class="kz io"> <em class="ky"> BaseAdapter.kt </em> </strong>和<strong class="kz io"><em class="ky">base view holder . kt</em></strong>或任何你喜欢的类。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="65d8" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">class </strong>BaseAdapter{</span><span id="c582" class="mn jw in mj b gy ms mp l mq mr">}</span><span id="3769" class="mn jw in mj b gy ms mp l mq mr"><strong class="mj io">class </strong>BaseViewHolder{</span><span id="f543" class="mn jw in mj b gy ms mp l mq mr">}</span></pre><p id="5ad3" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">现在，在 kotlin 泛型中，我们简单地使用“T”关键字来定义泛型类型。那么有哪些泛型呢？仿制药是-</p><blockquote class="mt"><p id="7072" class="mu mv in bd mw mx my mz na nb nc lu dk translated">为了创建这样一个类的实例，我们需要提供类型参数。</p></blockquote><p id="0c1a" class="pw-post-body-paragraph kw kx in kz b la nd lc ld le ne lg lh lw nf lk ll lx ng lo lp ly nh ls lt lu ig bi translated">欲了解更多信息，请访问此<a class="ae lv" href="https://kotlinlang.org/docs/reference/generics.html" rel="noopener ugc nofollow" target="_blank">链接</a>。所以，让我们把泛型放到我们的代码中。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d2a" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">class </strong>BaseAdapter&lt;T&gt;{</span><span id="bce2" class="mn jw in mj b gy ms mp l mq mr">}</span><span id="0d9d" class="mn jw in mj b gy ms mp l mq mr"><strong class="mj io">class </strong>BaseViewHolder&lt;T&gt;{</span><span id="7d82" class="mn jw in mj b gy ms mp l mq mr">}</span></pre><p id="e946" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io">第二步:</strong></p><p id="9b3f" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">继承<strong class="kz io"> <em class="ky"> RecyclerView。适配器</em> </strong>并实现覆盖方法。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f79e" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">class class</strong> BaseAdapter&lt;T&gt;: RecyclerView.Adapter&lt;BaseViewHolder&lt;T&gt;(){<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> onCreateViewHolder(parent: ViewGroup, <br/>                                   viewType:<strong class="mj io">Int</strong>):BaseViewHolder&lt;T&gt; {<br/>   }<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> onBindViewHolder(holder: BaseViewHolder&lt;T&gt;<br/>                                 ,position:<strong class="mj io">Int</strong>{<br/>   }<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> getItemCount(): <strong class="mj io">Int</strong> {</span><span id="e9a7" class="mn jw in mj b gy ms mp l mq mr">   }<br/>}</span></pre><p id="f4a8" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">创建一个通用类型的列表。这个列表是我们想要显示的项目的主要列表。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9d82" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">var</strong> listOfItems:MutableList&lt;T&gt;? = mutableListOf()</span></pre><p id="ace6" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">现在，让我们变个戏法。每当我们从列表中添加、更新或删除一个条目时，我们需要使用<strong class="kz io"><em class="ky">notifydatascethanged()</em></strong>方法通知适配器。让我们在这里不使用任何方法。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a46d" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">var</strong> listOfItems:MutableList&lt;T&gt;? = mutableListOf()<br/><strong class="mj io">set</strong>(value) {<br/>   field = value<br/>   notifyDataSetChanged()<br/>}</span><span id="7f87" class="mn jw in mj b gy ms mp l mq mr"><strong class="mj io">class class</strong> BaseAdapter&lt;T&gt;: RecyclerView.Adapter&lt;BaseViewHolder&lt;T&gt;(){<br/>   <strong class="mj io">var</strong> listOfItems:MutableList&lt;T&gt;? = mutableListOf()<br/>   <strong class="mj io">set</strong>(value) {<br/>     field = value<br/>     notifyDataSetChanged()<br/>   }<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> onCreateViewHolder(parent: ViewGroup, <br/>                                   viewType:<strong class="mj io">Int</strong>):BaseViewHolder&lt;T&gt; {<br/>   }<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> onBindViewHolder(holder: BaseViewHolder&lt;T&gt;<br/>                                 ,position:<strong class="mj io">Int</strong>{<br/>   }<br/>   <strong class="mj io">override</strong> <strong class="mj io">fun</strong> getItemCount(): <strong class="mj io">Int</strong> {</span><span id="7691" class="mn jw in mj b gy ms mp l mq mr">   }<br/>}</span></pre><p id="bef4" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io">第三步:</strong></p><p id="63ee" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">让我们完成<strong class="kz io"><em class="ky">base view holder . kt</em></strong></p><p id="b810" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">添加构造函数和带有“T”类型的绑定方法。因为我们希望将项目与“T”类型的视图绑定。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="001f" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">class</strong> BaseViewHolder&lt;T&gt; <strong class="mj io">internal</strong> <strong class="mj io">constructor</strong>(){<br/>  <strong class="mj io">fun</strong> bind(item:T){ }<br/>}</span></pre><p id="655a" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">但是现在我们应该在哪里绑定项目。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/41c584a2f07b7625c4f1ae51fd9d74ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oizgOFeVWKSzteAB"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="16d8" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">让我们将根 viewBinding 放在 viewHolder 类的构造函数中。因为每个布局的 viewBinding 类都有一个父类叫做<strong class="kz io"> <em class="ky"> ViewBinding </em> </strong>。此外，为 bind 方法的主体创建一个 lambda，并用构造函数传递它。像这样-</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d159" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">private</strong> <strong class="mj io">val</strong> experssion:(T,ViewBinding)-&gt;<strong class="mj io">Unit</strong></span></pre><p id="2733" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">最后，我们的取景框看起来像这样—</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">最终 BaseViewHolder 类</figcaption></figure><p id="edff" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io">第四步:</strong></p><p id="8f20" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">让我们更新我们的 BaseAdapter。</p><p id="46d8" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">我们将创建两个 lambda 变量，名为<strong class="kz io"><em class="ky">expressionViewHolderBinding</em></strong>和<strong class="kz io"><em class="ky">expressionOnCreateViewHolder。</em>T13】</strong></p><p id="0f02" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io"><em class="ky">expressionviewHolder binding—</em></strong>我们必须在我们的 view holder 类中提供表达式 lambda。所以这个 lambda 表达式将完成这项工作。</p><p id="f53f" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated"><strong class="kz io"><em class="ky">expressionOnCreateViewHolder—</em></strong>该表达式将直接从活动/片段中进行膨胀工作。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c108" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">var</strong> expressionViewHolderBinding: ((T,ViewBinding) -&gt; <strong class="mj io">Unit</strong>)? = <strong class="mj io">null</strong></span><span id="0e31" class="mn jw in mj b gy ms mp l mq mr"><strong class="mj io">var</strong> expressionOnCreateViewHolder:((ViewGroup)-&gt;ViewBinding)? = <strong class="mj io">null</strong></span></pre><p id="28dd" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">onCreateViewHolder 看起来会像这样—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0920" class="mn jw in mj b gy mo mp l mq mr"><strong class="mj io">override</strong> <strong class="mj io">fun</strong> onCreateViewHolder(parent: ViewGroup, <br/>                                   viewType:<strong class="mj io">Int</strong>):BaseViewHolder&lt;T&gt; {<br/> return BaseViewHolder(expressionOnCreateViewHolder(parent)<br/>                       ,expressionViewHolderBinding)</span><span id="e068" class="mn jw in mj b gy ms mp l mq mr">}</span></pre><p id="8411" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">所以让我们结束这个适配器—</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">最终基本适配器</figcaption></figure><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/504075edd6fcb4e8fe50a3087354e3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSMGl_jmIoNAP38a"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">由<a class="ae lv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3c2a" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">现在如何在任何片段或活动中使用它—</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">用在片段中</figcaption></figure><h1 id="3b73" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="d193" class="pw-post-body-paragraph kw kx in kz b la lz lc ld le ma lg lh lw mb lk ll lx mc lo lp ly md ls lt lu ig bi translated">您可以在此适配器中使用 DiffUtil、Snaphelper 和许多其他助手核心库。也可以在 ViewPager2 中使用。</p><p id="2883" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt lu ig bi translated">感谢阅读这篇文章，我希望现在你会发现它是有帮助的。这是我发表的第一篇关于媒介的文章。任何疑问请在评论中告诉我。</p></div></div>    
</body>
</html>