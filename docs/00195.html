<html>
<head>
<title>Single Responsibility Principle | SOLID as a Rock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一责任原则|坚如磐石</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/single-responsibility-principle-in-c-solid-as-a-rock-5273067350ae?source=collection_archive---------2-----------------------#2020-05-03">https://blog.devgenius.io/single-responsibility-principle-in-c-solid-as-a-rock-5273067350ae?source=collection_archive---------2-----------------------#2020-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a9ac676d18c59efd0a95642536a2b553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NiOMLSqlkPeclatcLJEO-g.jpeg"/></div></figure><p id="6b41" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本文是关于坚如磐石设计原则系列的五篇文章中的第一篇。坚实的设计原则集中于开发易于维护、可重用和可扩展的软件。在本文中，我们将看到一个 C++中的单一责任原则的例子，以及它的好处。</p><blockquote class="kp kq kr"><p id="b5d5" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kw" href="http://www.vishalchovatiya.com/category/design-patterns/" rel="noopener ugc nofollow" target="_blank"><em class="in">www.vishalchovatiya.com</em></a><em class="in">。</em></p></blockquote><p id="3307" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句，如果你还没有浏览过我以前关于设计原则的文章，下面是快速链接:</p><h1 id="72d6" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目的</h1><blockquote class="lv"><p id="7149" class="lw lx in bd ly lz ma mb mc md me ko dk translated"><strong class="ak"> <em class="mf">一个类应该只有一个理由去改变</em> </strong></p></blockquote><p id="967e" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">换句话说，SRP 声明类应该内聚到它有单一责任的程度，其中责任定义为“变化的原因”</p><h1 id="3eba" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">动机:违反单一责任原则</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="84d2" class="mu ky in mq b gy mv mw l mx my">class Journal {<br/>    string          m_title;<br/>    vector&lt;string&gt;  m_entries;</span><span id="0242" class="mu ky in mq b gy mz mw l mx my">public:<br/>    explicit Journal(const string &amp;title) : m_title{title} {}<br/>    void add_entries(const string &amp;entry) {<br/>        static uint32_t count = 1;<br/>        m_entries.push_back(to_string(count++) + ": " + entry);<br/>    }<br/>    auto get_entries() const { return m_entries; }<br/>    void save(const string &amp;filename) {<br/>        ofstream ofs(filename); <br/>        for (auto &amp;s : m_entries) ofs &lt;&lt; s &lt;&lt; endl;<br/>    }<br/>};</span><span id="def2" class="mu ky in mq b gy mz mw l mx my">int  main() {<br/>    Journal journal{"Dear XYZ"};<br/>    journal.add_entries("I ate a bug");<br/>    journal.add_entries("I cried today");<br/>    journal.save("diary.txt");<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="7ce0" class="na nb in jt b ju jv jy jz kc nc kg nd kk ne ko nf ng nh ni bi translated">上面的 C++例子看起来不错，只要你有一个单独的域对象，即<code class="fe nj nk nl mq b">Journal</code>。但是在真实的应用程序中通常不是这样。</li><li id="c909" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">当我们开始添加像<code class="fe nj nk nl mq b">Book</code>、<code class="fe nj nk nl mq b">File</code>等域对象时。您必须为每个人分别实现 save 方法，这不是实际问题。</li><li id="7804" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">当你不得不改变或维护<code class="fe nj nk nl mq b">save</code>功能时，真正的问题出现了。例如，某一天你将不再把数据保存在文件&amp;所采用的数据库中。在这种情况下，你不得不经历每一个域<a class="ae kw" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">对象实现</a> &amp;需要修改的代码都是不好的。</li><li id="f513" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">在这里，我们违反了单一责任原则，提供了<code class="fe nj nk nl mq b">Journal</code>第二类变更理由，即与<code class="fe nj nk nl mq b">Journal</code>，ii 相关的事情。保存<code class="fe nj nk nl mq b">Journal</code></li><li id="fdd8" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">此外，代码也会变得重复、臃肿&amp;难以维护。</li></ul><h1 id="c730" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案:C++中的单一责任原则示例</h1><ul class=""><li id="24bf" class="na nb in jt b ju nr jy ns kc nt kg nu kk nv ko nf ng nh ni bi translated">作为解决方案我们所做的是<a class="ae kw" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="ks">分离关注点</em> </strong> </a>。</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a3b4" class="mu ky in mq b gy mv mw l mx my">class Journal {<br/>    string          m_title;<br/>    vector&lt;string&gt;  m_entries;</span><span id="517f" class="mu ky in mq b gy mz mw l mx my">public:<br/>    explicit Journal(const string &amp;title) : m_title{title} {} <br/>    void add_entries(const string &amp;entry) {<br/>        static uint32_t count = 1;<br/>        m_entries.push_back(to_string(count++) + ": " + entry);<br/>    } <br/>    auto get_entries() const { return m_entries; }<br/>    //void save(const string &amp;filename)<br/>    //{<br/>    //    ofstream ofs(filename); <br/>    //    for (auto &amp;s : m_entries) ofs &lt;&lt; s &lt;&lt; endl;<br/>    //}<br/>};</span><span id="f680" class="mu ky in mq b gy mz mw l mx my">struct SavingManager {<br/>    static void save(const Journal &amp;j, const string &amp;filename) {<br/>        ofstream ofs(filename);<br/>        for (auto &amp;s : j.get_entries())<br/>            ofs &lt;&lt; s &lt;&lt; endl;<br/>    }<br/>};</span><span id="47b1" class="mu ky in mq b gy mz mw l mx my">SavingManager::save(journal, "diary.txt");</span></pre><ul class=""><li id="8d9e" class="na nb in jt b ju jv jy jz kc nc kg nd kk ne ko nf ng nh ni bi translated"><code class="fe nj nk nl mq b">Journal</code>应该只照顾条目&amp;与日志有关的事情。</li><li id="446f" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">应该有一个单独的中心位置或实体来完成储蓄工作。在我们的例子中，它是<code class="fe nj nk nl mq b">SavingManager</code>。</li><li id="69c7" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">随着你的<code class="fe nj nk nl mq b">SavingManager</code>的增长，所有与保存相关的代码都会在一个地方。你也可以模板化它来接受更多的域对象 T2</li></ul><h1 id="e457" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">单一责任原则的好处</h1><h1 id="7797" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">= &gt;表现力</h1><ul class=""><li id="4945" class="na nb in jt b ju nr jy ns kc nt kg nu kk nv ko nf ng nh ni bi translated">当类只做一件事时，它的接口通常有少量更具表现力的方法。因此，它也有少量的数据成员。</li><li id="d3a0" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">这提高了您的开发速度&amp;使您作为软件开发人员的生活变得更加容易。</li></ul><h1 id="a23e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">= &gt;可维护性</h1><ul class=""><li id="94c7" class="na nb in jt b ju nr jy ns kc nt kg nu kk nv ko nf ng nh ni bi translated">我们都知道需求会随着时间而变化&amp;设计/架构也是如此。你的类的职责越多，你就越需要经常改变它。如果您的类实现了多个职责，它们就不再相互独立。</li><li id="711b" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">孤立的更改减少了对软件其他不相关区域的破坏。</li><li id="3b76" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">由于编程错误与复杂性成反比，更容易理解使得代码更不容易出错&amp;更容易维护。</li></ul><h1 id="2450" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">= &gt;可重用性</h1><ul class=""><li id="b173" class="na nb in jt b ju nr jy ns kc nt kg nu kk nv ko nf ng nh ni bi translated">如果一个类有多个职责，并且在软件的另一个领域中只有其中一个需要，那么其他不必要的职责会阻碍可重用性。</li><li id="8340" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">拥有一个单一的职责意味着这个类不需要修改或者修改很少就可以重用。</li></ul><h1 id="3aa3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用 C++制作 SRP 友好软件的尺度</h1><ul class=""><li id="2632" class="na nb in jt b ju nr jy ns kc nt kg nu kk nv ko nf ng nh ni bi translated">SRP 是一把双刃剑。太具体了&amp;你将最终拥有数百个可笑的相互关联的类，很容易成为一个。</li><li id="0a21" class="na nb in jt b ju nm jy nn kc no kg np kk nq ko nf ng nh ni bi translated">当你觉得你过度工程化时，你不应该使用坚实的原则。如果你把单一责任原则归结起来，一般的想法应该是这样的:</li></ul><p id="16e0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"><em class="ks">SRP 是关于限制变化的影响。所以，把那些因为同样的原因而改变的东西收集在一起。把那些因为不同原因而改变的东西分开。</em> </strong></p><ul class=""><li id="0bfc" class="na nb in jt b ju jv jy jz kc nc kg nd kk ne ko nf ng nh ni bi translated">更重要的是，如果你的类构造函数有 5-6 个以上的参数，这意味着你要么没有遵循 SRP，要么你没有意识到构建器的设计模式。</li></ul><h1 id="3a5e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="906d" class="pw-post-body-paragraph jr js in jt b ju nr jw jx jy ns ka kb kc nw ke kf kg nx ki kj kk ny km kn ko ig bi translated">SRP 是一个被广泛引用的重构理由。这往往是在没有充分理解 SRP 的要点及其背景的情况下完成的，导致代码库的碎片化，带来一系列负面后果。SRP 不是一条通向最小规模班级的单行道，它实际上是在聚集和划分之间提出了一个平衡点。</p><p id="9cbe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe nj nk nl mq b"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>