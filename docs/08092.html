<html>
<head>
<title>TinyXML2: A Convenient C++ XML Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TinyXML2:一个方便的 C++ XML 库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tinyxml2-a-convenient-c-xml-reader-library-8218a268c40?source=collection_archive---------12-----------------------#2022-05-16">https://blog.devgenius.io/tinyxml2-a-convenient-c-xml-reader-library-8218a268c40?source=collection_archive---------12-----------------------#2022-05-16</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="848d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">高层次的解释，随后是带有错误检查的便捷代码片段的示例</h2></div><h1 id="ded8" class="kg kh ir bd ki kj kk kl km kn ko kp kq jx kr jy ks ka kt kb ku kd kv ke kw kx bi translated">它的作用。</h1><p id="aabc" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">简而言之，TinyXML-2 解析一个 XML 文档，并从中构建一个可以读取、修改和保存的文档对象模型(DOM)。[1]</p><h2 id="c14f" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">什么是 XML？</h2><p id="21a1" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">XML 代表“可扩展标记语言”它是一种通用的人和机器可读的标记语言，用来描述任意数据。[1]</p><h2 id="9ed5" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">为什么使用 XML？</h2><p id="c960" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">所有那些为存储应用程序数据而创建的随机文件格式都可以用 XML 替换。一个解析器处理所有事情。[1]</p><figure class="mh mi mj mk gu ml gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj mg"><img src="../Images/4c18a54834126aaa8808b8d73b8e8eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hx1-pSgC2gIkzuO8LbMpdA.png"/></div></div><figcaption class="ms mt gk gi gj mu mv bd b be z dk translated">[2]标准是如何扩散的。<a class="ae mw" href="https://xkcd.com/927/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/927/</a></figcaption></figure><h2 id="76fd" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">TinyXML2 怎么用？</h2><p id="a6d1" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">有不同的方法来访问 XML 数据并与之交互。TinyXML-2 使用文档对象模型(DOM ),这意味着 XML 数据被解析成可以浏览和操作的 C++对象，然后写入磁盘或另一个输出流。您还可以用 C++对象从头开始构造一个 XML 文档，并将其写入磁盘或另一个输出流。您甚至可以使用 TinyXML-2 从代码中以编程方式流式传输 XML，而无需先创建文档。[1]</p><h2 id="679a" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">什么是 DOM(文档对象模型)？</h2><p id="c35a" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">文档对象模型(DOM)是有效的<a class="ae mw" href="https://www.w3.org/TR/DOM-Level-2-Core/glossary.html#dt-HTML" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> HTML </em> </a>和格式良好的<a class="ae mw" href="https://www.w3.org/TR/DOM-Level-2-Core/glossary.html#dt-XML" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> XML </em> </a>文档的应用程序编程接口(<a class="ae mw" href="https://www.w3.org/TR/DOM-Level-2-Core/glossary.html#dt-API" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> API </em> </a>)。它定义了文档的逻辑结构以及访问和操作文档的方式。在 DOM 规范中，术语“文档”是在广义上使用的——XML 越来越多地被用作表示可能存储在不同系统中的许多不同种类的信息的一种方式，并且这些信息中的大部分在传统上被视为数据而不是文档。然而，XML 将这些数据表示为文档，DOM 可以用来管理这些数据。[3]</p><p id="20f1" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">使用文档对象模型，程序员可以构建文档、浏览文档结构、添加、修改或删除元素和内容。HTML 或 XML 文档中的任何内容都可以使用文档对象模型来访问、更改、删除或添加，但也有一些例外——特别是，用于 XML 内部和外部子集的 DOM <a class="ae mw" href="https://www.w3.org/TR/DOM-Level-2-Core/glossary.html#dt-interface" rel="noopener ugc nofollow" target="_blank"> <em class="mx">接口</em> </a>尚未指定。[3]</p><h2 id="2f22" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">错误报告</h2><p id="6b22" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">TinyXML-2 报告 XML 文档中无法正确解析的任何错误的行号。此外，所有节点(元素、声明、文本、注释等。)和属性在解析时会记录一个行号。这允许对解析的 XML 文档执行附加验证的应用程序(例如，应用程序实现的 DTD 验证)报告错误消息的行号信息。[1]</p><h2 id="574a" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">只需打开并加载 XML 文件</h2><p id="b583" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">首先，在我们接触 XML 库之前，让我们用纯 C++做一个操作系统检查，看看这个文件是否存在。这是 C++ 98，所以它甚至可以在最简单的 Linux 发行版和最小的 docker 映像上工作。这里没什么特别的。</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="8f42" class="lu kh ir ne b gz ni nj l nk nl">#include &lt;fstream&gt;</span><span id="b817" class="lu kh ir ne b gz nm nj l nk nl">bool DoesFileExist (const std::string&amp; name);</span><span id="6b19" class="lu kh ir ne b gz nm nj l nk nl">int main (int argc, char *argv[]) {<br/>  std::string file = "path/to/file.xml";<br/>  std::string error = "";</span><span id="2739" class="lu kh ir ne b gz nm nj l nk nl">  if(DoesFileExist(file) == 0) {<br/>    error= "Error: file " + file+ " does not exist. Exiting.";<br/>    std::cout &lt;&lt; error&lt;&lt; std::endl;<br/>    return -1;<br/>  }<br/>}</span><span id="3499" class="lu kh ir ne b gz nm nj l nk nl">bool DoesFileExist (const std::string&amp; name) {<br/> std::ifstream f(name.c_str());<br/> return f.good();<br/>}</span></pre><h1 id="1a3c" class="kg kh ir bd ki kj kk kl km kn ko kp kq jx kr jy ks ka kt kb ku kd kv ke kw kx bi translated">如何获得根节点</h1><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="bd2d" class="lu kh ir ne b gz ni nj l nk nl">#include "tinyxml2.h"<br/>#include "tinyxml2.cpp" // I know this is weird, just do it</span><span id="79cf" class="lu kh ir ne b gz nm nj l nk nl">using namespace tinyxml2;</span><span id="3027" class="lu kh ir ne b gz nm nj l nk nl">void main() {<br/>    XMLDocument doc;<br/>    doc.LoadFile("file.xml");<br/>    std::string errorString = "Error: " + std::string(doc.ErrorIDToName(doc.ErrorID()));<br/>    if(doc.ErrorID() != XML_SUCCESS) {<br/>        std::cout &lt;&lt; errorString &lt;&lt; std::endl;<br/>    }<br/>    XMLElement* root = doc.FirstChildElement();</span><span id="ae3f" class="lu kh ir ne b gz nm nj l nk nl">}</span></pre><h2 id="2cda" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">关于错误检查和文件 IO 的说明</h2><p id="57f1" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我发现只要查一下文件就很方便了。if 语句中的 ErrorID()并使用 doc 打印。ErrorIDToName()在我使用 XML lib 做任何事情之后。原因是，对于文件 IO，在任何和每个操作之后检查错误状态通常是非常关键的，这是很好的实践，等等。</p><p id="ada6" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">文件 io 中可能会出现很多问题，例如，您可能会在加载文件时突然耗尽 RAM，您可能会在写入文件时突然耗尽硬盘空间，等等。</p><h2 id="f9de" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">错误代码示例:从节点获取属性</h2><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="153e" class="lu kh ir ne b gz ni nj l nk nl">std::string type = root-&gt;Attribute("type"); <br/> errorIDString = "Get Type Error: " + std::string(doc.ErrorIDToName(doc.ErrorID()));<br/> NS_LOG_UNCOND (errorIDString);<br/> std::cout &lt;&lt; "Type: " &lt;&lt; type &lt;&lt; std::endl;</span></pre><p id="2ce9" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">可能会返回以下错误消息:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="ab55" class="lu kh ir ne b gz ni nj l nk nl">terminate called after throwing an instance of 'std::logic_error'<br/>  what():  basic_string::_M_construct null not valid</span></pre><p id="65ec" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">如果根节点缺少“类型”属性。</p><p id="a9fc" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">在 XML 中，你想要的是:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="ae9c" class="lu kh ir ne b gz ni nj l nk nl">&lt;Root type="myType"&gt;<br/>&lt;/Root&gt;</span></pre><p id="2c73" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">因此，如果您缺少“类型”属性，它将如下所示:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="b59c" class="lu kh ir ne b gz ni nj l nk nl">&lt;Root&gt;<br/>&lt;/Root&gt;</span></pre><p id="1179" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">如果没有找到具有指定名称的属性，则<code class="fe nn no np ne b">Attribute()</code>返回<code class="fe nn no np ne b">null</code>。您的代码找不到类型属性，所以它将一个空值传递给值为空的<code class="fe nn no np ne b">const char*</code>构造函数<code class="fe nn no np ne b">std::string</code>。[5]</p><p id="9a83" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">您应该这样做:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="55ca" class="lu kh ir ne b gz ni nj l nk nl">// Check event.xml for an attribure called "type" inside the &lt;Event&gt; node<br/>// for production:<br/>//&lt;Event Timespan="3" type="production"&gt;<br/>// for staging:<br/>//&lt;Event Timespan="3" type="staging"&gt;</span><span id="11c8" class="lu kh ir ne b gz nm nj l nk nl">const char* pType = nullptr;<br/>pType = root-&gt;Attribute("standard");<br/>if(pType == nullptr) {<br/> errorIDString = "Get Type Error: No such attribute 'type'";<br/> std::cout &lt;&lt; errorIDString &lt;&lt; std::endl;<br/>} else {<br/> errorIDString = "Event type: " + std::string(pType);<br/> std::cout &lt;&lt; errorIDString &lt;&lt; std::endl;<br/>}</span></pre><h2 id="b181" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated"><strong class="ak">将数据放入 XMLDocument </strong></h2><p id="eb22" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">XML 将数据存储在元素中，每个数据单元一个元素。让我们创建另一个名为“版本”的元素。</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="461b" class="lu kh ir ne b gz ni nj l nk nl">XMLElement * pVersionElement = doc.NewElement("Version");</span></pre><p id="cb5b" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">在 XML 文档中创建一个“<version>”节点。</version></p><p id="712f" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">XMLElement 提供了许多重载函数来设置元素的值。XML 是一种基于文本的语言，所以这个函数的名称是 SetText()，尽管各种重载接受任何基本类型来设置元素的值。在这里，我们将使用它来设置一个字符串值。</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="dcfe" class="lu kh ir ne b gz ni nj l nk nl">pElement-&gt;SetText(10);</span></pre><h2 id="2172" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">在末尾添加一个新元素</h2><figure class="mh mi mj mk gu ml"><div class="bz fq l di"><div class="nq nr l"/></div></figure><h1 id="e5b8" class="kg kh ir bd ki kj kk kl km kn ko kp kq jx kr jy ks ka kt kb ku kd kv ke kw kx bi translated">实体</h1><p id="9bb5" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">TinyXML-2 识别预定义的“字符实体”，即特殊字符。即:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="cbba" class="lu kh ir ne b gz ni nj l nk nl">&amp;amp;   &amp;<br/>&amp;lt;    &lt;<br/>&amp;gt;    &gt;<br/>&amp;quot;  "<br/>&amp;apos;  '</span></pre><p id="f264" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">这些在 XML 文档被读取时被识别，并被翻译成它们的 UTF-8 对等物。例如，具有以下 XML 的文本:</p><pre class="mh mi mj mk gu nd ne nf ng aw nh bi"><span id="df1e" class="lu kh ir ne b gz ni nj l nk nl">Far &amp;amp; Away</span></pre><p id="0758" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">当从 XMLText 对象查询时，将具有“Far &amp; Away”的值()，并将作为&amp;符号写回 XML 流/文件。</p><h2 id="0edb" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">来自我的示例代码:</h2><p id="3777" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我有一个回购协议，在那里我收集代码片段，我做的例子等:<a class="ae mw" href="https://github.com/sitting-duck/simple-cpp-xml-parser" rel="noopener ugc nofollow" target="_blank">https://github.com/sitting-duck/simple-cpp-xml-parser</a></p><p id="8839" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">目前“主”分支有最新的 Windows 信息,“主”分支有最新的 MacOS 信息和例子，但是我会尽快合并这两个分支。</p><p id="ff0a" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">请随意在这里发表 Github 问题，提出请求或在这里留下评论。</p><h2 id="81b3" class="lu kh ir bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">限制</h2><p id="7a9a" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">目前，我能够使用这个库轻松地解析 C++中的许多 xml 文件，但是由于我还不明白的原因，我无法解析这个文件:</p><figure class="mh mi mj mk gu ml"><div class="bz fq l di"><div class="nq nr l"/></div></figure><p id="0a7b" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">只有 255 行长，我对此感到困惑，但我会寻找解决方法，并尝试另一种解决方案。</p><h1 id="15bc" class="kg kh ir bd ki kj kk kl km kn ko kp kq jx kr jy ks ka kt kb ku kd kv ke kw kx bi translated">参考</h1><p id="5ab2" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">[1]tinyxml 2 是做什么的？<a class="ae mw" href="https://leethomason.github.io/tinyxml2/#:~:text=In%20brief%2C%20TinyXML%2D2%20parses,language%20to%20describe%20arbitrary%20data" rel="noopener ugc nofollow" target="_blank">https://leethomason . github . io/tinyxml 2/#:~:text = In % 20 brief % 2C % 20 tiny XML % 2d 2% 20 parses，language % 20 to % 20 description % 20 arbitrary % 20 data</a>。</p><p id="201f" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">[2]标准是如何扩散的。【https://xkcd.com/927/ T4】</p><p id="446a" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">[3]什么是文档对象模型？<a class="ae mw" href="https://www.w3.org/TR/DOM-Level-2-Core/introduction.html" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/DOM-Level-2-Core/introduction.html</a></p><p id="c101" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">[4] TinyXML2 教程。<a class="ae mw" href="https://shilohjames.wordpress.com/2014/04/27/tinyxml2-tutorial/" rel="noopener ugc nofollow" target="_blank">https://Shiloh James . WordPress . com/2014/04/27/tinyxml 2-tutorial/</a></p><p id="5523" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">[5]如何避免错误:在引发“std::logic_error”的实例后调用 termin ate what():basic _ string::_ S _ construct null 无效。<a class="ae mw" href="https://stackoverflow.com/questions/11705886/how-to-avoid-the-error-terminate-called-after-throwing-an-instance-of-stdlog" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/11705886/how-to-avoid-the-error-termin ate-called-after-throwing-an-instance-of-STD log</a></p><p id="f178" class="pw-post-body-paragraph ky kz ir la b lb my js ld le mz jv lg lh na lj lk ll nb ln lo lp nc lr ls lt ik bi translated">[6]检查 TinyXML 中是否存在元素。<a class="ae mw" href="https://stackoverflow.com/questions/62359685/check-for-element-existence-in-tinyxml" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/62359685/check-for-element-existence-in-tinyxml</a></p></div></div>    
</body>
</html>