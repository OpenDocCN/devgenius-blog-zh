<html>
<head>
<title>Mono vs Multi Repos — Pick Your Poison | Raftt Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单条与多条回复——选择你的毒药| Raftt 博客</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mono-vs-multi-repos-pick-your-poison-raftt-blog-1f9787749efa?source=collection_archive---------12-----------------------#2022-08-31">https://blog.devgenius.io/mono-vs-multi-repos-pick-your-poison-raftt-blog-1f9787749efa?source=collection_archive---------12-----------------------#2022-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e814" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当开始一个新的软件项目时，需要做出几个重大的决定。您围绕编程语言、框架和源代码控制结构所做的选择是至关重要的，并将影响您未来几年的工作方式。明智的选择，以一种反映你的组织文化的方式，将会节省大量的时间和挫折。</p><p id="f696" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然你选择的语言和你依赖的框架受团队、领域和产品的影响很大，但是选择使用单一回购还是多重回购并不那么明确。有许多因素对不同的团队或多或少都很重要，甚至对同一组织中的不同项目也是如此。</p><p id="848e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Raftt，我们处于一个独特的位置，可以看到<strong class="jm io">许多</strong>公司的开发设置，了解他们的困难(并解决其中的一些困难！).我们已经看到了<strong class="jm io">巨大的</strong>研发部门规模、公司成熟度和技术堆栈。下面所有的挑战都是我们自己或在客户那里看到的。</p><p id="5578" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在深入细节之前，让我们先明确一些定义:</p><p id="921e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">整体架构</strong>:将公司的产品架构为单一服务。</p><p id="6c95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">微服务:</strong>将公司的产品架构为独立部署的多个(可能是多个)服务。我们的一个潜在假设是，你至少在你产品的某个部分使用微服务。使用一个以上的存储库进行源代码控制，一个纯粹的单一方法没有任何好处。</p><p id="07a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Monorepo: 拥有包含公司所有代码的单一存储库。</p><p id="db1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">多回购:</strong>拥有多个存储库，每个存储库包含公司产品的某个部分的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9d741dc77207e9597ffe4f4b217ef9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lyjr_9S3J8QIEFvy.png"/></div></div></figure><p id="1386" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，[几乎]没有什么是绝对的——在大多数情况下，即使人们选择使用 monorepo，他们也会有额外的存储库用于分叉的开源项目、附带项目、遗留项目或许多其他原因。整体架构也是如此。</p><h1 id="0bc6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用 Monorepos 时的挑战</h1><p id="1867" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">使用 monorepos 可能会面临巨大的挑战。<br/>我们将在下面讨论其中最重要的一些。</p><h2 id="8a83" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">特征分支可能会失去控制</h2><p id="f6ee" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Monorepos，多个团队在不同的应用程序部分工作，不适合长期的特性分支；随着时间的推移，使它们保持最新变得越来越困难，合并冲突会很快失控。</p><p id="b8fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，团队通常使用基于主干的开发，并带有特性标志。这增加了对正在进行的代码的可见性，并减少了对其他开发人员隐藏重大变更的机会。由于较小部分的代码是在编写时合并的，因此出现困难的合并冲突的可能性要低得多。</p><h2 id="d144" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">大型存储库减缓了版本控制</h2><p id="bae4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">根据您的存储库的大小，底层的源代码控制系统(Git 除非您真的是独一无二的！)，可能开始吃力的跟不上了。这意味着更长的时间来克隆、提取、检查分支，这直接减慢了团队的速度，但也可能是一个恶化的因素——例如，更长的重新定基时间意味着人们更少地重新定基，这意味着更难的合并冲突，这导致了更多的挫折。</p><p id="0662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 git-lfs(大文件存储)可以帮助最小化 repo 中的大文件，浅层克隆和稀疏签出等功能可以帮助减少 git 历史或工作树的大小。所有这些都各有利弊。</p><p id="b0bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管多重回购方式也可能受到这种影响，但它往往更易于管理。</p><h2 id="1f58" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">您的 CI/CD 设置可能很复杂</h2><p id="16df" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">大多数现代 CI 系统都非常容易设置和使用，这使得使用好的工具非常快速。存储库内容越复杂，就越难让它们适应您的需要。使用 monorepo，默认情况下，您可能会构建并测试<strong class="jm io">回购中的所有</strong>项目，这可能会花费过多的时间。</p><p id="b33a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅构建、测试或部署存储库内容的一部分可能需要非常特殊的配置，这可能是不可靠的，并且需要维护。在 Raftt，我们花时间创建内部基础设施，它遍历 Golang 包的依赖项，以确定是否应该构建某个包。这花了一些时间，但绝对值得，因为这对我们的 CI 流程来说是一个重大的时间和信号改进。</p><h2 id="492b" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">版本控制会变得很麻烦</h2><p id="f875" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">软件项目输出的版本控制不一定与源代码控制结构直接相关，但是如果是这样的话，会非常方便。在 monorepo 上使用 Git 标签和/或分支意味着您要么有许多发布分支和标签，要么有几个覆盖多个项目。</p><p id="aaa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">拥有许多分支和标签是很危险的，因为很难跟踪它们的状态。例如，如果你有一个影响其中几个的紧急修补程序，就很难确保把它应用到所有地方。</p><p id="5908" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，只使用一个标签可能意味着不必要地更新可能没有重大变化的项目。投资于您的基础设施以简化部署过程(并且经常发生)可以使这成为一个问题，甚至是一个好处—您可以确保相同版本的所有服务一起工作。</p><h2 id="3d9e" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">访问控制需要额外的考虑</h2><p id="7554" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">使用 monorepo 会使向代码应用细粒度权限变得困难。从技术上来说，阻止任何需要部分回购协议的人获得整个回购协议在技术上是不可能的。根据你对公司知识产权的敏感度，这可能是一个关键因素。</p><p id="03f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您肯定可以使用基于目录或文件的权限来影响<strong class="jm io">写</strong>访问，但是这可能需要定制工具，并且需要一些额外的维护。</p><h2 id="81b0" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">开发工具和服务可能会有 Monorepos 的问题</h2><p id="f09f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">有数以千计的开发人员常用的工具。他们中的许多人对您的源代码控制的结构有一定的假设，并且倾向于假设一个项目==一个存储库。这可能是因为他们将某些文件放在存储库的根目录下，或者因为他们自己调用 Git。这通常可以解决，但可能需要更多的工作。</p><p id="2c90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从战略角度来看，采用单一回购方式意味着公司必须投资调整工具以更好地支持单一回购。有时候这些适应可能很困难——例如，它们可能需要分叉开源项目，这增加了您或您的团队需要维护的另一件事情。</p><h1 id="d6f2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">处理多重回购时的挑战</h1><p id="ed1c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">…但是另一边的草并不总是更绿。</p><h2 id="bd43" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">依赖性管理可能会变得困难</h2><p id="a504" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">通过将相互依赖的独立模块、项目或服务放置在不同的存储库中，我们在将它们作为一个整体处理时引入了一个额外的复杂性层。开发人员必须克隆多个存储库，并使它们保持同步。如果一个模块跨多个存储库使用，可能很难确保对它的更改不会破坏其中的任何一个，无论是在本地还是在 CI 中，因为它需要为依赖的存储库触发 CI 运行。</p><h2 id="9d5c" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">代码复制更经常发生</h2><p id="a4c1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">软件开发中的一个大问题是代码重复。函数的每个副本都需要维护，更糟糕的是，它们之间的差异可能会导致难以发现的错误。</p><p id="dfbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当使用多回购方式时，这种情况发生的几率要高得多。IDE 不仅每次只能看到代码的一部分(因此更难找到用法、搜索相似的方法等)。)，但是实际上不可能从另一个存储库中调用代码。</p><p id="47d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些公司通过在另一个存储库中拥有一个共享包来解决这个问题，这个共享包可以在任何地方加载——这可能会导致该模块因在一堆不同的地方使用的代码而变得臃肿，导致多回购结构想要解决的混乱。</p><h2 id="0a26" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">变更可以跨越多个存储库</h2><p id="3b7d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在单个存储库的范围内，小的更改是可能完成的。特性越大，就越有可能需要接触多个存储库来解决它。这可能很困难 IDE 无法帮助找到您需要修改的地方，因此它可能会在 CI 管道中来回多次。</p><p id="9c6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使在根据需要修改了所有的存储库之后，您可能会遇到原子修改的问题——不可能保证同时提交到所有的存储库，因此您可能会遇到这样的情况:一部分的变更已经被提交了，但是其他的被卡住了。这可能是由于 CI 问题、合并冲突或任何其他问题。</p><h2 id="56f7" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">版本和依赖关系管理可能会变得复杂</h2><p id="1bb9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">不出所料，版本化仍然很难:)。如果每个组件都有不同的版本，管理哪个版本与哪个版本一起工作是一项困难的手动任务。如果您有一个单一的全局版本，您如何在所有存储库之间同步它？</p><h2 id="15ea" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">关注点分离可能会失败</h2><p id="6616" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">软件开发的一个基本概念是关注点的分离。</p><p id="291f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个概念通常有两种解释:</p><p id="c702" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">- <strong class="jm io">分离技术关注点。</strong>例如，加密库应该有自己的存储库，因为它只负责整个系统的一个技术方面。<br/> - <strong class="jm io">特征分离</strong>。所有与一个特性相关的代码都应该放在同一个库中。例如，身份验证功能可能由 UI 代码和加密代码组成，但两者一起工作，因此它们将位于同一位置。</p><p id="d916" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多回购方法通常会强制分离一个，导致重复或难以分离另一个。例如，如果我有一个包含自己的 UX 和身份验证库的身份验证服务，在另一个存储库中的另一个服务中重用它们可能需要额外的工作。</p><h2 id="a10f" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">CI 中的端到端测试很难做对</h2><p id="0e17" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">虽然针对特定服务或项目的单元和集成测试可能更容易设置，但是运行端到端测试可能很困难——它们需要来自所有存储库的输出，因此测试的所有阶段都需要额外的设置和维护——</p><p id="7348" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">-从来自多个存储库的变更中触发端到端测试需要它们之间的重复配置，或者处理它们的外部服务。不管怎样，都增加了复杂性。<br/> -运行端到端测试需要一个与运行测试本身的所有其他 repos 断开的上下文。这可以是另一个回购，或外部服务。<br/>——找出失败的特定测试运行的原因是困难的——它可能是来自任何涉及的存储库的变更，并且没有明确的方法来划分正确的提交。</p><h1 id="46ef" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="052e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在最基本的层面上，源代码控制结构之间的选择是一种文化选择。隔离单个组件的行为更重要，还是能够立刻影响整个系统更重要？我们是愿意根据需要投资工具来支持我们的开发人员，还是更喜欢使用现有的(通常是优秀的)工具？</p><p id="3326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Raftt，工程师对堆栈的任何部分进行修改的能力是选择使用 monorepo 结构的关键因素。我们还喜欢简化的版本管理，以及创建部署基础设施的便利性，该基础设施在一个地方管理我们产品的各个部分，尽可能地共享代码。</p><p id="139b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们遇到的(实际上仍然面临的)最大挑战是 CI/CD 工具。我们已经投入时间来创建一个系统，该系统可以适应存储库中不同组件的变化，使用特定于 Golang 的工具来检查给定目标的依赖关系。</p><p id="7295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的一些不太集中的项目位于单独的存储库中，这通常是因为它们是从开源项目中分出来的。在这些方面，我们会遇到许多在多重回购挑战中提到的困难。</p><p id="5ab5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">‍</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="3e8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">原载于</em><a class="ae mj" href="https://www.raftt.io/post/development-challenges-of-working-with-monorepos-and-multirepos" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://www . raftt . io</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>