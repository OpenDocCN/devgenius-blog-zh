<html>
<head>
<title>Playing Window Function in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Postgres 中播放窗口函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/playing-window-function-in-postgres-1eb7bb781f8e?source=collection_archive---------12-----------------------#2022-12-26">https://blog.devgenius.io/playing-window-function-in-postgres-1eb7bb781f8e?source=collection_archive---------12-----------------------#2022-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d849" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">演示 SQL 窗口函数的一些常见做法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/45a618749228a4bf7e6c04e11ad934aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qz0v2k7uXZjAYaZ1"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@mooo3721" rel="noopener ugc nofollow" target="_blank"> R 莫</a>在<a class="ae ks" href="https://unsplash.com/photos/w-_iZqdviAo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="eb75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">做 ETL 的时候，我们总是一批一批的往数据库里写数据，里面包含了每一批的快照。这些快照基本上都是历史数据，可能包含大量的重复，那么我们如何在这些批次中找到我们需要的数据呢？</p><p id="301b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将用一个简单的场景来描述我们常用的一些处理方法，主要是<a class="ae ks" href="https://www.postgresql.org/docs/current/tutorial-window.html" rel="noopener ugc nofollow" target="_blank">窗口函数</a>。</p><h1 id="0d33" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">用户场景</h1><p id="7a99" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">假设一家公司使用 BPM 系统来管理员工变动和工资变动，那么一个简单的 BPM 系统通常会有两个表，分别包含员工的详细信息和每个人的工资，如下所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3ab8a586a034886e9561b5ba3e5367db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*QMUMLc5QuFJs2vuR0IcgFQ.png"/></div></figure><p id="b54e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当使用关系数据库时，我们通常将数据规范化，也就是说，我们根据需求维度来规划表，并且只保留必要的字段，这些字段通过外键相互关联。</p><p id="80f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是在数据分析上下文中，我们经常需要一个事实表，这意味着所有的东西都聚集在一起。用于工资分析的事实表示例如下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d1b1187bb19a12e7bc32e10ff432dd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*_hPyMFxp41l67vOM0n6imA.png"/></div></figure><p id="8e5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">聚合中的常见做法是批处理 ETL，每次都从雇员详细信息表和薪金表中提取所需的列，并保存下来供以后分析，如薪金增长趋势。ETL 聚合后的事实表如下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/729593783a9da019bea183955da65067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hLFP6AMHFWqcml1N.png"/></div></div></figure><p id="c85c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个以天为单位进行批处理的 ETL，每天都会对两个表进行汇总，所以会有<code class="fe mp mq mr ms b">job_process_id</code>进行批处理和<code class="fe mp mq mr ms b">create_time</code>进行数据创建。</p><p id="6446" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是示例中使用的 SQL。</p><pre class="kd ke kf kg gt mt ms mu bn mv mw bi"><span id="c4d0" class="mx lq in ms b be my mz l na nb">CREATE TABLE "public"."cdc_test" (<br/>	"id" serial NOT NULL,<br/>	"create_time" DATE NOT NULL,<br/>	"job_process_id" INT NOT NULL,<br/>	"empid" INT NOT NULL,<br/>	"ename" VARCHAR(100) NOT NULL,<br/>	"sal" INT NOT NULL,<br/>	PRIMARY KEY ("id")<br/>);<br/><br/>INSERT INTO "public"."cdc_test" ("id", "create_time", "job_process_id", "empid", "ename", "sal") VALUES<br/>(1, '2018-12-10', 111, 1, 'Ravi', 3000),<br/>(2, '2018-12-10', 111, 2, 'Raj', 4000),<br/>(3, '2018-12-10', 111, 3, 'Ram', 5000),<br/>(4, '2018-12-11', 112, 1, 'Ravi', 3000),<br/>(5, '2018-12-11', 112, 2, 'Raj', 4000),<br/>(6, '2018-12-11', 112, 3, 'Ram', 5000),<br/>(7, '2018-12-11', 112, 4, 'Srini', 6500),<br/>(8, '2018-12-12', 113, 1, 'Ravi', 7000),<br/>(9, '2018-12-12', 113, 2, 'Raj', 4000),<br/>(10, '2018-12-12', 113, 3, 'Ram', 5000),<br/>(11, '2018-12-12', 113, 4, 'Srini', 6500);</span></pre><p id="62ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，有两个状态变化。</p><ol class=""><li id="648c" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">Srini 于 2018 年 12 月 11 日上船。</li><li id="71b4" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">Ravi 在 2018-12-12 获得加薪。</li></ol><h1 id="e448" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">获取最新状态</h1><p id="3b6e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">从上图可以看出，ETL 生成的事实表会包含大量重复数据，如果我们需要了解当前状态并排除重复，怎么办？这就是窗口功能发挥作用的地方。</p><pre class="kd ke kf kg gt mt ms mu bn mv mw bi"><span id="01ef" class="mx lq in ms b be my mz l na nb">SELECT<br/>  t.*<br/>FROM (<br/>  SELECT<br/>    cdc_test.*,<br/>    (ROW_NUMBER() OVER (PARTITION BY empid,<br/>      ename ORDER BY create_time DESC)) AS seqnum<br/>  FROM<br/>    cdc_test) t<br/>WHERE<br/>  t.seqnum = 1;</span></pre><p id="981d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过使用<code class="fe mp mq mr ms b">PARTITION BY</code>锁定固定列<code class="fe mp mq mr ms b">(empid, ename)</code>，并将时间逆序排序，我们可以知道第一个将是最新的状态。</p><p id="b9f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结果如下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/aab486437576f37067807e2372adb08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyjNnsBEAks_-J5tXgns8w.png"/></div></div></figure><h1 id="d4fb" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">获取每个薪金的变化</h1><p id="0090" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">有了最新状态，我们通常还是想了解每一次薪资变动。我们仍然可以通过窗口功能来实现我们的目标。</p><pre class="kd ke kf kg gt mt ms mu bn mv mw bi"><span id="b6cf" class="mx lq in ms b be my mz l na nb">SELECT<br/>  t.*<br/>FROM (<br/>  SELECT<br/>    cdc_test.*,<br/>    (ROW_NUMBER() OVER (PARTITION BY empid,<br/>      ename,<br/>      sal ORDER BY create_time)) AS seqnum<br/>  FROM<br/>    cdc_test) t<br/>WHERE<br/>  t.seqnum = 1</span></pre><p id="81c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一次，我们用<code class="fe mp mq mr ms b">PARTITION BY</code>来锁定的目标是<code class="fe mp mq mr ms b">(empid, ename, sal)</code>，因为我们要把相同的三列视为同一个组，那么一旦<code class="fe mp mq mr ms b">sal</code>发生变化就会创建一个新的组。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e40400f88173facbc6e740cf4295821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LQjrIjHXJzm3ZX96.png"/></div></div></figure><p id="af54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从结果中，我们可以看到 Ravi 得到了一次加薪，从 3000 到 7000。</p><h1 id="93e8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">获取每个薪金的变化并包括加薪前的结果</h1><p id="2822" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在上面两个例子中，我们只使用了<code class="fe mp mq mr ms b">ROW_NUMBER()</code>，但实际上在窗口函数中还有很多其他函数可用。</p><p id="c81b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一次，我们不仅希望得到工资变动情况，还希望查询结果包含加薪前的列，因此可以使用<code class="fe mp mq mr ms b">LAG()</code>。</p><pre class="kd ke kf kg gt mt ms mu bn mv mw bi"><span id="6a0c" class="mx lq in ms b be my mz l na nb">SELECT<br/>  t.*<br/>FROM (<br/>  SELECT<br/>    cdc_test.*,<br/>    (LAG(sal) OVER (PARTITION BY empid,<br/>      ename ORDER BY create_time)) AS prev_sal<br/>  FROM<br/>    cdc_test) t<br/>WHERE<br/>  prev_sal IS NULL<br/>  OR prev_sal &lt;&gt; sal;</span></pre><p id="ef85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与上面类似，只是使用了另一个窗口函数，并且改变了<code class="fe mp mq mr ms b">WHERE</code>子句。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/55d997678a5d9e2917589f3df8784bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5rPkg0n2qAQnr8dp.png"/></div></div></figure><p id="3bfe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们可以看到一个新的列。</p><h1 id="3494" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">参考</h1><div class="ns nt gp gr nu nv"><a href="https://stackoverflow.com/questions/53729837/how-to-select-only-incremental-records-in-big-query" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">如何在大查询中只选择增量记录</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">我有一个数据在我的数据库中，如下，我期待的结果一样，有人可以请帮我如何写…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">stackoverflow.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj km nv"/></div></div></a></div></div></div>    
</body>
</html>