# GitHub 新手用户指南，了解 Git 和 GitHub

> 原文：<https://blog.devgenius.io/guide-for-newbie-github-users-understanding-git-github-9f8effe69e86?source=collection_archive---------22----------------------->

![](img/3a882c4202138e2975c5cfbdb006b711.png)

GitHub Octocat！

在过去的一年多时间里，我一直在定期使用 GitHub。我对设置我的目录和使用像 git add 这样的命令感到很舒服。、git commit -m 和 git push。然而，当我需要做除了 commit 之外的任何事情并向 GitHub 推送新的更改时，我很快就迷失了。一个例子是当我不可挽回地搞砸了，我需要重置到一个旧的提交。我看到“分支”和“头断开”之类的东西，我开始担心。我最后复制并粘贴 git 命令，希望我没有破坏任何代码。

退一步说，这并不理想。我决定做一些研究来了解 GitHub 是如何工作的，以及 git 命令在后台做什么。

这些是我在研究中遇到的一些问题:

1.  当我第一次建立我的项目时会发生什么？
    git init
    git remote add origin<URL>
    git add。
    git commit -m "第一次提交"
    git 推送源主机
2.  为什么添加、提交和推送有不同的命令？这似乎效率低下。
3.  树枝到底是什么？
4.  如果我犯了一个错误，我如何真正利用版本控制功能，并恢复到我的代码的旧版本？
5.  当我“签出”一个提交时，到底发生了什么？git 检验

首先，为了理解 GitHub，我们必须理解 Git 和版本控制软件，因为 Git 是 GitHub 所基于的软件。

# Git 和版本控制软件的一点背景知识

Git 是 Linux 的创始人 Linus Torvalds 在 2005 年开发的版本控制软件。版本控制系统是一类软件工具，它帮助软件团队管理源代码随时间的变化！VCS 在一个“特殊的数据库”中记录了对代码的每一次修改。如果出现错误，开发人员可以将时钟拨回到代码的早期版本。

VCS 还允许一个工程师团队对源代码的不同部分进行工作，并快速地组合这些变化，以便源代码的不同部分仍然兼容。

VCS 的三个重要特征:

1.  VCS 保存了每个文件的完整**长期变化历史**！
2.  **分支和合并**更改代码。在 VCS 创建一个“分支”可以保持多个工作流相互独立。合并允许那些不同的工作流被组合在一起成为一个兼容的版本。
3.  **可追溯性**。每一个变化都有注释记录，这有助于更好地理解代码和更和谐的调试！

关于安全性的注意事项:Git 的设计将托管源代码的完整性放在首位。Git 存储库中的所有信息都用一种叫做 SHA1 的散列算法来保护。

# VCS 是如何工作的？

VCS 在一个**库**中维护一个代码的所有‘版本’。让我们看看一个经典的源代码库是如何工作的。

![](img/78f49ab6a3df720a1d8cb40e0987e09b.png)

1.  你有你的项目或源代码称为**‘内容’**
2.  **“存储库”**保存了内容的所有版本
3.  你的**‘工作目录’**是你写代码的应用，你修改内容的地方
4.  你**‘check out’**代码从资源库到工作目录
5.  你**‘commit’**在工作目录中所做的修改变成了 repo 中内容的新版本。

## 创建新的提交:

![](img/d4b39589d1a3330e8a73292ae97aea3b.png)

每次提交都会创建内容的一个新的子版本，该子版本派生自之前的父版本。

您的内容的每个版本被称为“**提交**或“**快照**”(*注意“提交”用于表示两种情况。1.已经保存到存储库的代码版本，2。将包含一些更改的版本保存到存储库*。快照保存在链接中，保持父子关系。通过提交在父版本和子版本之间改变的信息被称为**‘改变集’**。

一系列版本称为一个流或分支。在 Git 中，主流通常被称为 **master** 。(如果您已经使用 Git 处理过个人项目，那么您很可能只向“主”分支添加和提交变更。)**“分支”**在协作项目中用于分离出特定功能的开发或用于旧版本的维护！(我们后面会更详细的讲分支)。

# Git 与传统的源代码仓库有什么不同？

Git 与传统源代码存储库的不同之处在于，它使用一个**暂存区**或(**索引)**来暂存变更，然后将变更提交到存储库中的新版本。

![](img/7389717b7950124a42413e9a9395dc1d.png)

我们如何使用 git？(基本的 Git 命令)

1.  **git init** = >将当前目录转换为“工作目录”,并在。git(隐藏)目录。
2.  **git check out**=>“check out”一个快照从存储库到您的工作目录
3.  **git 添加** = >已进行的阶段更改
4.  **git commit** = >为我们所在的流创建一个新的“快照”！

*其他有用的命令:
-****git status****帮助您跟踪哪些变更已经进行或者没有进行，以及您当前正在哪个分支上工作。
-*-**-*git diff*-**-*显示索引和工作区之间的变化
-*-**-*git log*-**-*显示变化的历史*

*注意:到目前为止，我们只讨论了使用本地存储库(比如 git push、git remote、git pull 使用远程存储库)*

# 提交命名:

= >用提交 ID 命名的快照看起来像" c69e0cc 32 F3 C1 c8 f 2730 cade 36 A8 f 75 DC 8e 3d 480 "
=>为了方便起见，Git 可以将这些长散列缩写成仍然唯一的短名称(c 69 E0 cc)

如果我们想要 git checkout 提交，我们可以做**git check out c 69 E0 cc 32 F3 C1 c8 f 2730 cade 36 A8 f 75 DC 8e 3d 480**或 **git commit c69e0cc。**

本文中的图表使用了简单的字母 A，B，C，..等等。因为提交 id 的长度而引用我们的提交。

# 在溪流和支流上工作…

当我们处理版本时，我们通常不处理提交 id。相反，我们用“分支”工作。在 Git 中，**分支是指向特定快照**的命名指针。我们可以使用**git check out<branch>**来检查分支指向的快照。

分支指针指定当分支被修改时，新的提交应该被添加到哪里。当改变被应用到分支时，分支指针移动到新的提交。

git 分支将会给我们一个存储库中分支的列表。

![](img/0bc3a6d607b898edcd7778e3d858d7d3.png)

# Git 如何知道将工作区中的变更放在哪里？？

您的工作区有一个名为 HEAD 的指针，它指向一个分支或特定的快照。在那里您将提交在您的工作目录中所做的更改。HEAD 指向您上次签出工作区的位置。

![](img/356b66f4949b0dfa8eb568fbdba1ffe3.png)

# 创建新分支

对于接下来的两个部分，我建议创建一个测试目录并测试这些命令，以直接了解分支和合并是如何工作的。尝试创建新的分支，检出分支，提交分支，最后合并两个分支！不要忘记使用 git init 将目录转换成带有 git repo 的工作目录。

分支背后的概念是每个快照可以有多个子快照。将第二个变更集应用到同一个快照创建了一个新的独立的开发流。如果新的流被命名，它被称为一个分支！

命令:
**git branch<branch name>**->在当前 HEAD 上创建一个分支(记住 HEAD 就是你的工作区正在查看的快照/分支。)
**git 分支<分支名称> <提交 id >** - >在有效的快照版本上创建分支。

注意:对于这些命令，您的工作区头仍然指向旧的分支。您需要先签出新分支，以便对新分支进行更改。( **git 结帐<分支名称>** )

**git 分支** = >查看分支列表，以及分支头指向的内容

或者你可以这样做:

**git checkout -b <分支名称>** - >在当前头创建一个分支并切换到该分支

# 合并两个分支:

场景:您正在合作一个项目，并且您已经在一个单独的分支上构建了一个特性。现在，您已经完成了一个分支的特性，您需要将它合并回主分支！

1.  返回主分支: **git 结帐主**
2.  将你的特征分支合并到主分支: **git 合并<分支名称>**

**git merge** 将把指定的分支合并到分支头所指向的分支中。

*有三种不同类型的合并场景。要阅读更多关于三种不同类型(快速向前合并、无冲突合并、冲突合并)的合并结果，请查看本文* [*中的合并部分*](https://developer.ibm.com/technologies/web-development/tutorials/d-learn-workings-git/) *。这里，我们将假设合并是成功的。*

这是一个无冲突合并的示意图。

![](img/c7cb619433deb7eb8fc070f45bb1a884.png)

现在我们已经了解了使用 Git 以及分支和合并是如何工作的，我们可以讨论使用远程存储库了！

# 使用像 GitHub 这样的远程存储库:

当我们使用像 GitHub 托管的远程存储库时，我们增加了一个额外的步骤来使用本地存储库。

例如，当我们想要将一些更改“推”到远程存储库时，我们仍然需要 git add，git commit 将工作目录中的更改提交到本地存储库。然后，我们可以将本地存储库中的更改推送至远程存储库。

![](img/7b41bb29c94e7331fb8c10e9548c253d.png)

## Git 如何管理远程存储库？

首先，我们将演示如何使用 **git fetch** 来跟踪和复制远程存储库。这部分变得有点复杂，但是理解 **git fetch** 如何工作以及 git 如何跟踪远程存储库将为理解诸如 **git pull** 、 **git clone** 和 **git push** 之类的命令打下良好的基础。

我们可以使用**git remote add<name _ for _ remote><remote _ repo _ URL>**将远程存储库添加到 git 目录中。

这个命令**在我们的本地存储库中创建一个分支，代表远程存储库**。这叫做**远程跟踪分部。** 然后我们可以使用 **git fetch** 将远程存储库的内容提取到远程跟踪分支中。*注意:Fetch 只更新远程跟踪分支，不更新任何本地分支。*如果我们想要更新本地分支，我们需要 **git 将**远程跟踪分支与主分支这样的本地分支合并。

看看这个流程图:

![](img/4cec47c81cc17558a076b8494e65854d.png)

* * *请注意，在我们将内容从远程存储库提取到远程跟踪分支后，我们的工作目录仍然指向一个空的本地分支。只有在将本地分支与远程跟踪分支合并之后，我们的工作目录和本地分支才会更新。***

现在，我们已经成功地更新了本地存储库，以匹配远程存储库。我们在本地存储库中还有一个远程跟踪分支。

**Git Pull**

**git pull** 是一个 git fetch，后面跟着一个 git merge。它会将远程回购的内容提取到您的远程跟踪分支中，并将远程跟踪合并到 HEAD 指向的本地分支中。这种差别是微妙的，也是让很多 Git 用户困惑的一点。

如果您正在与他人合作，git pull 是一个您将会经常运行的命令，以便用对远程存储库所做的更改来更新您的本地存储库！

**Git 克隆**

**git 克隆**通常使用一次来创建内容的初始副本。

它将创建一个 dir，初始化 git，添加远程跟踪分支，将远程存储库克隆到跟踪分支中，与本地分支合并，并签出主分支。结果是本地分支中的远程存储库的克隆副本以及更新的远程跟踪分支。

**Git 推送**

**git push** 与 git fetch 相反。使用 **git push** 我们可以用提交到本地分支的变更来更新远程存储库。

git push 将(1)更新远程分支的本地副本，以及(2)远程存储库。

![](img/5ff156a6023e77499f8e5f9f524c3962.png)

## 最后，我们了解了初始化 GitHub repo 和一般工作流程的全部情况。

创建一个工作目录和一个本地存储库。git 目录
**git 远程添加 origin git @ github . com:atribecalledarty/test . git**=>添加远程跟踪分支
**git 添加。** = >暂存所有更改
**git commit -m "这是一条提交消息"** = >使用暂存的更改在我们的本地存储库中创建一个新的提交
**git push** = >更新本地 repo 中的远程跟踪分支以及远程存储库

## 最后一件事，git 重置:

好吧，你搞砸了你的项目，你想回到你的项目的一个早期版本，因为撤销你所做的所有更改会有太多的工作要做。向 **git 重置问好。**

**git 复位<模式> <提交>**

reset 命令实际上永远不会删除一个提交或者改变您当前没有签出的分支的内容。它只是简单地移动你的头部和分支指针。但是，根据您指定的模式，它会删除您的索引和/或工作目录中的更改。

我们将讨论两种不同的模式:——**软**&**——硬***(“——”是两条虚线，medium 不让我把它们分开。)*

**—软**将把头和分支指针移动到指定的提交。它将把所有的修改保存在你的工作目录和索引(暂存区)中。
比方说，您刚刚提交了一个包含 10 行代码的变更集。其中一行代码有一处打印错误。您可以 **git reset — soft** 到之前的提交，同时保留您在工作目录和索引中编写的 10 行代码。然后，您可以编辑出错的那一行代码，并重新提交修复的代码行。

**—硬**将重置头&分支指针、索引和工作目录。您可以在项目中获得一个完全干净的石板，并完全恢复到指定的快照。
很多时候，当我想重置**时，硬**是我一直在寻找的模式。我在许多不同的文件中添加了一些代码行，试图实现一个特性。在我做了所有的改变之后，这个特性仍然不起作用，我只想重置我对早期版本所做的所有改变，然后再试一次。对于这种类型的场景，**git reset—hard<commit _ id>**是要使用的模式。

# 结论:

我非常高兴我写了这篇关于 Git 和 GitHub 的博文！我觉得我对(1)如何使用 Git 和(Git & GitHub 实际上做什么有很好的理解。

Git 是一个版本控制软件，我们可以用它来跟踪存储库中代码的变化。GitHub 是一个托管平台，托管着我们可以连接的存储库。通过同时使用 Git 和 GitHub，我们可以很容易地与来自世界各地的人，甚至仅仅是同事协作和共享我们的源代码。

一个重要的认识是，当我们使用 Git & GitHub 时，我们是在使用两个不同的仓库，本地和远程。我最初只是假设 GitHub 存储库是我们承诺的唯一存储库。相反，我们实际上是将变更暂存并提交到本地存储库，然后将这些变更推送到远程存储库。

发现 git 如何通过远程跟踪分支跟踪远程存储库也很有趣。发现 git 创建了一个远程跟踪分支，并随后通过获取/推送来更新该分支，使得使用远程存储库的过程变得不那么抽象了。

我希望这篇指南对你有所帮助和启发，并且现在你不会因为使用 Git 和 GitHub 而感到失落！

资源:

[https://developer . IBM . com/technologies/we b-development/tutorials/d-learn-workings-git/](https://developer.ibm.com/technologies/web-development/tutorials/d-learn-workings-git/)

堆栈溢出问题