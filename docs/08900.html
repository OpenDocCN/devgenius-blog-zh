<html>
<head>
<title>Microservices with Proxy pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有代理模式的微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservices-with-proxy-pattern-6224632b9628?source=collection_archive---------10-----------------------#2022-07-17">https://blog.devgenius.io/microservices-with-proxy-pattern-6224632b9628?source=collection_archive---------10-----------------------#2022-07-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ul class=""><li id="1912" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在这里，我们讨论当从单一应用程序迁移到微服务架构时，以及当服务结构频繁变化时，如何使用代理设计模式。</li><li id="86a4" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">让我们假设你的客户有一个单一的应用程序，你将进入微服务架构。</li><li id="dbc9" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">假设您有一个获取员工出勤信息的微服务。所以我们会通过员工代码来获取考勤信息。考虑这样一个场景，客户决定重新构建数据库，他们决定将雇员 ID 作为所有记录关系跟踪键。所以现在我们必须更新我们的服务，从雇员 ID 而不是雇员代码中获取数据。</li><li id="10a6" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">现在，我们必须相应地部署新版本的服务。</li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi kh"><img src="../Images/8abf9741f2ed7c33363531332d0f8f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOx8QSuYx5acGADOifVUUA.png"/></div></div></figure><ul class=""><li id="aee1" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">因此，目前消费者正在使用您的第 1 版员工服务。现在消费者将传递雇员代码。但是对于版本 2，我们必须输入员工 ID。</li><li id="6e9c" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">如果我们部署/更新我们当前的服务，这将导致消费者的失败，因为他们不知道如何传递员工 Id。</li></ul><p id="6b9d" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">解决方案:</strong></p><ul class=""><li id="03aa" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">作为解决方案，我们需要创建不同的代理服务。</li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi li"><img src="../Images/cfbc7843b1cbaf3d2213d961c9ef64d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqY0VjRlnT6ZhYvrHTWcnA.png"/></div></div></figure><ul class=""><li id="6807" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">现在消费者涉及代理服务。我们修改了代理服务，使其在消费者为雇员服务的版本 2(模式 2)传递雇员 ID 时起作用。如果消费者传递员工代码，则调用员工服务的版本 1。</li><li id="8759" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">这样，我们可以独立地部署我们的服务，而不会干扰消费者。</li></ul><p id="1c72" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">语义版本</strong></p><blockquote class="lj lk ll"><p id="7cff" class="kt ku lm jm b jn jo kv kw jp jq kx ky ln kz la lb lo lc ld le lp lf lg lh jx ig bi translated">少校- <strong class="jm io"> 2 </strong></p><p id="6599" class="kt ku lm jm b jn jo kv kw jp jq kx ky ln kz la lb lo lc ld le lp lf lg lh jx ig bi translated">次要- <strong class="jm io"> 5 </strong></p><p id="4626" class="kt ku lm jm b jn jo kv kw jp jq kx ky ln kz la lb lo lc ld le lp lf lg lh jx ig bi translated">补丁- <strong class="jm io"> 9 </strong></p></blockquote><p id="0b97" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">Major</strong>-当服务与以前的服务不兼容时使用的主要版本。</p><p id="6e0e" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">次要</strong> -每当我们有新功能时使用，但是以前的功能将保持不变。</p><p id="e699" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated">我们可以实现我们想要的方式，这与我们做得如何无关。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi lq"><img src="../Images/24db5d308d37b85b636eb661a0a1a499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6AyFtN2Ijjq5yBdwGrP6w.png"/></div></div></figure><p id="b35a" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">服务发现:</strong>当我们创建服务时，最好使用外部方来发现服务，因为随着基础设施改变主机名，IP 地址同样一切都可以改变。</p><ul class=""><li id="5b3a" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">但是在服务发现的帮助下，代理将调用服务发现工具，并且代理将从服务发现工具请求员工服务版本 1(或者可能是版本 2)。所以服务发现工具告诉服务版本 1 的 ip 地址是什么。</li></ul><p id="5932" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">使用消息队列:</strong>如果一些服务需要很长时间来响应，那么接下来的服务将一个接一个地受到影响，这将产生级联效应。这种影响将通过所有其他服务传递给它。</p><ul class=""><li id="3e96" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为了避免这种情况，我们可以使用消息队列。对于所有的消息，它将存储这些，然后队列处理器将处理一个接一个。</li></ul><p id="972e" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">超时</strong>:当我们的版本 1 越来越延迟时，如果我们不指定一个超时实现，那么阻塞线程会影响版本，这是很重要的。为了避免这类事件，定义超时是一个非常必要的方面。</p><p id="f35e" class="pw-post-body-paragraph kt ku in jm b jn jo kv kw jp jq kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated">参考:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="lr ls l"/></div></figure></div></div>    
</body>
</html>