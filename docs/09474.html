<html>
<head>
<title>Getting started with F1 statistics and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F1 统计和 Python 入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-ergast-f1-statistics-and-python-5112279d743a?source=collection_archive---------6-----------------------#2022-08-23">https://blog.devgenius.io/getting-started-with-ergast-f1-statistics-and-python-5112279d743a?source=collection_archive---------6-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python 中的数据准备，用于使用 Ergast 数据集分析 F1 统计数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c8d2f1442db1428c3023edd78988a41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQBuJ4CihjunmZki3RoqSA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者照片</figcaption></figure><p id="1c87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程介绍了如何使用历史一级方程式数据进行分析。它涵盖了获取数据、清理数据和对这些数据进行的两次初步分析(更多内容将在后面介绍！).本文的主要焦点是这个数据集的数据准备，以便进行分析。这可能感觉像是脏活，但是良好的数据准备会有回报。简单。</p><p id="fd47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据是从<a class="ae lb" href="http://ergast.com/mrd/" rel="noopener ugc nofollow" target="_blank"> Ergast 开发人员 API 中检索的。</a>这是一个提供 F1 比赛历史数据的 API，从 1950 年开始，尽管并非所有数据都是完整的。数据可用于当前赛季，包含所有计划的比赛和所有已完成比赛的结果。</p><p id="9e61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可用数据包含下表:</p><ul class=""><li id="3b44" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">驱动因素—所有当前和以前驱动因素的信息</li><li id="325b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">构造函数—所有当前和以前的构造函数的信息</li><li id="eb40" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">制造商和车手的比赛结果</li><li id="e05b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">资格审查结果—所有资格审查会议的结果，包括单独的 Q1、A2 和 Q3 会议。</li><li id="bc53" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">圈速——所有赛事中所有车手完成的所有圈速</li><li id="2878" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">进站—所有进站，时间和持续时间(进站—出站)</li><li id="72ae" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">每场比赛后的积分榜，包括制造商和车手</li></ul><p id="a5ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种方法可以访问数据。首先，有一个 REST API 从数据集中检索信息。使用特定的 URL GET-request，例如<code class="fe lq lr ls lt b"><a class="ae lb" href="http://ergast.com/api/f1/2008/" rel="noopener ugc nofollow" target="_blank">http://ergast.com/api/f1/2008/</a>8/results</code>返回 2008 赛季第 8 场比赛的结果。</p><p id="c847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，可以直接下载包含所有信息的 MySQL 数据库。它以数据库转储和一组<a class="ae lb" href="http://ergast.com/mrd/db/#csv" rel="noopener ugc nofollow" target="_blank"> CSV 文件</a>的形式提供。我们将在本教程中使用 CSV 文件。它将展示如何下载一个 ZIP 文件并从这个 ZIP 文件中导入所有 CSV 文件。由于我们将在所有可用的数据上构建数据集，这比数百个单独的 API 调用来收集整个数据集更容易、更快。在此之后，进行我们的分析不需要额外的 web 调用，因此我们可以随时随地执行我们的研究，并且我们可以缓存我们的数据准备。</p><h2 id="f6a2" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">输入数据</h2><p id="777d" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">如上所述，我们将从 Ergast 网站下载一个 ZIP 文件，并从中导入 CSV 文件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">温蒂</figcaption></figure><p id="42dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类创建了一个对象 F1Stats，该对象导入比赛数据并将其存储在本地缓存中(稍后将清楚为什么)。在后面的阶段，方法将被添加到这个类中，以准备好的格式检索数据。</p><p id="1763" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在初始化过程中，指定了存储原始下载文件的目录和文件名，以及包含缓存数据的 pickle 的名称。</p><p id="ecc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">核心就是<code class="fe lq lr ls lt b">download_data()</code>法。该方法从网站下载 ZIP 文件，将其存储在本地磁盘上，并将所有 CSV 文件读取到每个 CSV 文件的 Panda 数据帧中。数据帧存储在字典中。</p><p id="1cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 18 到 20 行下载 zip 文件并存储在磁盘上。第 22 行打开这个 zip 文件进行访问，第 25 到 27 行执行导入魔术。它创建一个数据帧字典，字典中的键等于 CSV 文件的名称，没有扩展名(第 25 行)。第 26 行使用<code class="fe lq lr ls lt b">pandas.read_csv</code>方法将 CSV 文件读取到 Panda 数据帧中。<code class="fe lq lr ls lt b">zipfile.open</code>方法打开一个 zip 文件并返回结果。导入后，序列<code class="fe lq lr ls lt b">\n</code>从数据帧中删除。CSV 中的空字段用该代码填充，但是空的 dataframe 单元格更容易处理。</p><p id="8a7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组合键和数据帧是为以'结尾的 ZIP 文件中的每个文件创建的。csv '(第 27 行)。这个 for 循环遍历存储在 zipfile ( <code class="fe lq lr ls lt b">.infolist</code>)中的文件列表。如果文件以'结尾。执行“csv”的第 25 行和第 26 行来为该文件创建一个条目。例如，zipfile 包含一个名为“race_results.csv”的 CSV。CSV 的内容以数据帧的形式存储在字典中的“race_results”项下</p><p id="4fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lt b">save_date</code>方法将字典(<code class="fe lq lr ls lt b">dfs</code>)存储为 pickle 文件。load_date 从文件中读取字典。<code class="fe lq lr ls lt b">initialize()</code>方法初始化该类，由此参数<code class="fe lq lr ls lt b">download</code>确定是从网站下载 zip 文件(并存储在缓存中)还是将缓存用于初始化。后者更快。</p><p id="f602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在后面的阶段，将向该类添加方便的方法，用于获取数据集的视图。例如，比赛结果只包含车手和车队的 ID。将添加一个方法，在返回之前将驱动程序和构造函数的信息添加到比赛结果表中。根据经验，如果一个视图预计会被多次使用，那么它会被添加到类中。</p><p id="cbc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始化方法已经提示了下一步。清理数据。</p><h2 id="ca72" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">数据清理</h2><p id="fe07" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">与大多数数据集一样，需要对数据进行一些清理。不同的表格包含字符串、整数、浮点数、日期和时间。对于每个类别，都需要一些操作。对于每个数据类型，都编写了一个方法来执行转换和清理。这些方法以下划线开始，使它们成为私有的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于字符串，使用清理方法(第 1–3 行)从字符串中删除空格。数据集中的一些列用空格左对齐或右对齐。此方法从指定的列中移除这些。第一个参数<code class="fe lq lr ls lt b">dfname</code>指定了<code class="fe lq lr ls lt b">self.dfs</code>字典中标识我们想要更新的数据帧的键。</p><p id="2f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有整数的列作为字符串导入，因为数据集包含空值。方法(第 5–7 行)在用“0”(零)替换空单元格后，将列内容转换为整数类型。对于我们的分析，这意味着“0”等于缺失、不可用或无效的数据。在第 9–11 行中，创建了一个 equal 方法来将列转换为浮点数。</p><p id="995f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 13 到 26 行将数据转换成一个<code class="fe lq lr ls lt b">datetime</code>对象。datetime 字符串值可以在一列中，也可以分在两列中。在后一种情况下，<code class="fe lq lr ls lt b">timecolumn</code>可用于指定包含时间部分的列。在这种情况下，首先通过简单地连接两个字符串，用时间扩展日期列(第 16–18 行)。时间列将从数据帧中删除。</p><p id="9475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法提供了用<code class="fe lq lr ls lt b">datetime</code>对象值创建新列的可能性。如果使用此选项，原始日期和时间列(如果使用)将从数据帧中删除。最后一个参数<code class="fe lq lr ls lt b">onerror</code>指定出错时采取的动作。默认参数值<code class="fe lq lr ls lt b">ignore</code>忽略格式错误并返回原始值。当它被赋予值<code class="fe lq lr ls lt b">coerce</code>时，无效的格式字符串将导致<code class="fe lq lr ls lt b">NaT</code>，而不是时间。</p><p id="f7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，有两种方法可以转换为仅日期型和仅时间型。这些方法只保留由前面的方法创建的<code class="fe lq lr ls lt b">datetime </code>对象的相关部分。例如，laptimes 没有日期部分。</p><p id="a557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这允许我们清理从数据集导入的所有不同的数据帧:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也强调几个动作，首先让我们看第 3 行。此行调用名为“races”的数据帧和该数据帧的列“name”的字符串的 cleanup 方法。</p><p id="ff34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 4 行从“日期”和“时间”列为同一个数据帧创建了一个日期时间对象。未指定目标列，因此结果日期时间对象将在“日期”列中。“时间”列将从数据框架中删除。</p><p id="7d1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的 5 行为这个事件的不同会话创建了一个 datetime 对象。对于这些，将创建一个新列，并将删除单独的日期和时间列。</p><p id="8ed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入和清理数据需要很长时间。但是每一分钟都是值得的。我们对数据集清理得越好，它就变得越容易使用。例如，不正确地转换整数值将意味着在每次分析期间都必须实现这种转换。通过第一次就做对，我们可以在后面的阶段节省时间。</p><p id="7cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如第一个代码片段已经显示的，这种数据清理是在从 Ergast 下载数据之后、保存到缓存之前执行的。当使用数据的缓存版本时，这会节省大量时间。</p><h2 id="838e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">我们的第一项分析——职业生涯中获胜次数最多的 F1 车手</h2><p id="c8a9" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">终于到了我们第一次数据分析的时候了。从一个相对简单的问题开始，让我们找出赢得大奖赛最多的前 10 名 F1 车手。相对简单，因为它需要组合几个数据帧。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在开始时提到的，F1Stats 类将通过返回数据集的方便视图的方法进行扩展。对于此分析，需要一个关于比赛及其获胜者的视图。基本数据框架是'<code class="fe lq lr ls lt b">results</code>'数据框架，包含所有比赛的所有车手成绩:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/63926bb4151132b5038cda9852a6e0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEp4GMNZ2uRgwnZwh_XkNg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">结果数据框架(作者截图)</figcaption></figure><p id="0926" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dataframe 有 18 列，包括对驱动程序、构造函数和事件的引用。对于大多数关于比赛结果的分析，我们不需要这里列出的所有列，但我们希望手头有车手、构造者和事件信息。</p><p id="a445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加了一个<code class="fe lq lr ls lt b">get_race_results()</code>方法来过滤<code class="fe lq lr ls lt b">results</code>的列，并将其与驱动程序、构造函数和事件信息连接起来。第 6–9 行通过选择要保留的列来过滤结果数据帧，并将其与比赛事件信息合并。事件的列<code class="fe lq lr ls lt b">name</code>被重命名，以防止与驱动程序和构造函数的同名列冲突。此后，结果与驱动程序数据帧合并，最后与构造器数据帧合并。<code class="fe lq lr ls lt b">pd.merge</code>自动检测同名的列，并对这些列执行连接。</p><p id="073e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">产生的数据帧如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/248de9e8a73efaeb8f5a092fe7df4ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cpfe9qjiHWWEyzAQUQdtCg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">比赛结果数据框(作者截图)</figcaption></figure><p id="95e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据帧仍然包含对驱动程序、构造函数和事件的引用，但最重要的信息在数据帧本身。</p><p id="41d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 24 行将这个数据帧存储在变量<code class="fe lq lr ls lt b">winners</code>中，但是它仍然包含所有赛车的所有车手。第 25 行通过保留结束位置(列'<code class="fe lq lr ls lt b">position</code>')等于' 1 '的行来过滤出获胜者。它包含了 1073 名 GP 冠军，而不是超过 250，000 的最终名次。</p><p id="e735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是找到获胜次数最多的车手，所以我们需要计算每个车手出现在这个列表中的次数。为此，使用数据帧的<code class="fe lq lr ls lt b">groupby</code>功能。dataframe 根据作为参数传递的列进行分组。然后可以对这些组调用函数，例如查找最大值/最小值、计算组中的项目数等。这些函数应用于不用于分组的列。因此</p><p id="4bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lt b">winners[[‘driverId’, ‘driver’, ‘race’]].groupby([‘driverId’, ‘driver’]).count()</code></p><p id="8004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从数据帧<code class="fe lq lr ls lt b">winners</code>中选择<code class="fe lq lr ls lt b">driverId</code>、<code class="fe lq lr ls lt b">driver</code>和<code class="fe lq lr ls lt b">race</code>列，并按<code class="fe lq lr ls lt b">driverId</code>和<code class="fe lq lr ls lt b">driver</code>分组。两列中具有相同值的所有行都放在一个组中。方法<code class="fe lq lr ls lt b">count</code>然后计算每组中的项目数(对于列'【T9])。得到的数据帧将分组所依据的列作为索引，将计数结果作为列(以被计数的列命名)。通过调用<code class="fe lq lr ls lt b">reset_index()</code>，索引被转换为“列”。第 27 行最后按照“比赛”(包含获胜次数)以降序对此数据帧进行排序:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bf92f99c7013036a99e070bad342968d.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*0VsNiIma29vpIlollY9IFw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">获胜次数最多的 F1 车手(图片由作者提供)</figcaption></figure><p id="279c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是…赢得最多胜利的 10 位车手。</p><p id="b9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们在<code class="fe lq lr ls lt b">driverID</code>和<code class="fe lq lr ls lt b">driver</code>列上对数据帧进行了分组。驱动程序列包含驱动程序的名称，这是最终表所必需的。但是名称不是唯一的，所以对于每个驱动程序来说，这个列可能不是唯一的。<code class="fe lq lr ls lt b">driverId</code>是唯一的，所以最好将其用作分组变量。通过将<code class="fe lq lr ls lt b">driver</code>列添加到组中，我们在最终的数据帧中有了驱动程序名称。如果仅使用<code class="fe lq lr ls lt b">driverId</code>，则需要添加名称，并与驱动表合并。这里使用的解决方案更容易理解。</p><p id="2989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表格是表示这些信息的好方法，但是图表更好地突出了种族数量之间的差异。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/4e6dc12566879eced0296df5889a71c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BR1BAP-sumdCwyQ_lDpu7Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">获胜次数最多的 F1 车手(图片由作者提供)</figcaption></figure><p id="2803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">介绍了一种制作水平条形图的方法(期望更多用例:-)):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lt b">horizontal_barplot()</code>获取数据帧<code class="fe lq lr ls lt b">df</code>，在列<code class="fe lq lr ls lt b">sort_value</code>上对其进行排序，并获取结果数据帧的第一个<code class="fe lq lr ls lt b">rowcount</code>元素(第 6 行)。这些行被绘制成水平条，其中来自列<code class="fe lq lr ls lt b">xcolumn </code>的值被用于识别行和列，来自列<code class="fe lq lr ls lt b">ycolumn</code>的值确定条的长度。</p><p id="356b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个矩形(图中的条形)都有一个绘制在条形右侧的标签。标签是由横条(<code class="fe lq lr ls lt b">str(get_width(`))</code>)表示的值。如果指定(<code class="fe lq lr ls lt b">invert__yaxis</code>)，y 轴上的值将被反转。条形图从底部开始绘制，因为车手在比赛中获胜是降序排列的，在我们的例子中，轴必须反转，否则获胜最多的车手将绘制在底部。第 15 行到第 17 行将标题 ans 轴标签添加到绘图中。</p><p id="bf97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 19–22 行显示了前面显示的图表是如何生成的。</p><h2 id="a08e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">分析 2 -年度冠军排名</h2><p id="3492" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们的第二项分析是对一段时间内车手排名的概述。哪位车手在积分榜上获得了名次，哪位车手失去了名次？这个季节什么时候？该图实现了:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/f5080cfc25215e548fff779b4030ad9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PF77ZkWt4LoEIGy6S9FOOg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">冠军排名(图片由作者提供)</figcaption></figure><p id="a382" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要收集数据来绘制这个图表。对于给定的一年，我们需要在每场比赛后在车手世界锦标赛中的位置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个方法被添加到<code class="fe lq lr ls lt b">F1Stats</code>类中，该方法在每场比赛后返回 WDC(世界车手锦标赛)排名。可以选择特定的年份来过滤数据。</p><p id="1561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ergast 数据集包含一个表<code class="fe lq lr ls lt b">driver_standings</code>,其中包含大部分所需信息，但与比赛结果一样，还添加了一些关于比赛和车手的额外数据。两个连续的合并增加了这个信息(第 6-10 行)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/0acf6c58881d6591e05114a31593352f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EUUFX0WbgIrpNMZU4KS3w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">排行榜数据框(图片由作者提供)</figcaption></figure><p id="9d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于 2022 年的所有比赛(第<code class="fe lq lr ls lt b">round</code>栏)，车手排名显示在该数据框中。“位置”一栏给出了在积分榜上的位置，驾驶员由 ID、名称和代码指定。</p><p id="1ba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得特定回合后的排名，可以在列'<code class="fe lq lr ls lt b">round</code>'上过滤数据框。要了解特定车手在每轮比赛后的位置，可以对他的<code class="fe lq lr ls lt b">name</code>、<code class="fe lq lr ls lt b">code</code>或<code class="fe lq lr ls lt b">driverId </code>进行过滤。当数据包含多个年份时，在<code class="fe lq lr ls lt b">driverId</code>上过滤是最安全的。随着时间的推移，车手的<code class="fe lq lr ls lt b">code</code>肯定不是唯一的(例如，扬·马格努森使用的是 MAG，凯文·马格努森也在使用)，他的<code class="fe lq lr ls lt b">name</code>可能不是。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法为数据帧<code class="fe lq lr ls lt b">df</code>中的每个驱动器绘制一条线。预计数据帧包含一个名为“<code class="fe lq lr ls lt b">code</code>”的列，包含三个字母的驱动程序代码。为每个驱动器绘制一条线(第 6-8 行)，指定 x 轴的<code class="fe lq lr ls lt b">xcolumn</code>和 y 轴的<code class="fe lq lr ls lt b">ycolumn</code>。在本分析中，这些是'<code class="fe lq lr ls lt b">round</code>'和'<code class="fe lq lr ls lt b">position</code>'。</p><p id="919c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线条的颜色是特定于驱动程序的，从 F1Stats 类中检索，其中一个表为每个驱动程序指定了在图表上表示他的颜色。如果一个驱动程序是未知的，它返回黑色。</p><p id="4194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 9–21 行执行一些布局功能，如标题、刻度和轴标签。第 22–26 行在行的右侧添加一个带有驾驶员代码的标签。这一切导致:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/837d856fff9bbcd1309364155d0f754d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApMjts41NCzXIlGiOk1qVw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">2022 赛季车手积分榜(图片由作者提供)</figcaption></figure><h2 id="bd27" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">结论</h2><p id="8fc0" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">Ergast 数据集包含大量关于 f1 历史比赛的信息。本文重点介绍如何开始使用这个数据集，比如导入数据和清理数据。给出了两个示例，显示了要执行的可能分析的一瞥。</p><p id="465d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花时间清理数据集。这有助于数据的使用，投入的时间将很快收回。在进行分析时，后退一步，想一想所需数据集合的哪一部分可能对未来有用。将这些添加到泛型类中。</p><p id="aaf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多分析可在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/analyzing-f1-statistics-part-i-a526d15b6fc8">分析 F1 统计—第一部分</a>中找到。</p><p id="1a56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的代码可以在名为<a class="ae lb" href="https://github.com/lmeulen/F1Analysis/blob/master/Eregast-analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> Ergast-analysis.ipynb </a>的 Jupyter 笔记本的<a class="ae lb" href="https://github.com/lmeulen/F1Analysis" rel="noopener ugc nofollow" target="_blank"> github </a>中找到(包括下一篇文章的代码)</p><h2 id="c3cd" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">最后的话</h2><p id="bf45" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我希望你喜欢这篇文章。要获得更多灵感，请查看我的其他文章:</p><ul class=""><li id="047a" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae lb" href="https://leo-vander-meulen.medium.com/f1-hungary-2022-some-observations-7d1e80d3831" rel="noopener"> F1 匈牙利:一些观察</a></li><li id="4ca3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" href="https://betterprogramming.pub/how-to-predict-fuel-prices-609f7ec417fb" rel="noopener ugc nofollow" target="_blank">使用 Python 和“scikit-learn”进行燃油价格预测</a></li><li id="3945" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" href="https://towardsdatascience.com/solar-panel-power-generation-analysis-7011cc078900" rel="noopener" target="_blank">太阳能电池板发电分析</a></li><li id="97a5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" href="https://towardsdev.com/perform-a-function-on-columns-in-a-csv-file-a889ef02ca03" rel="noopener ugc nofollow" target="_blank">对 CSV 文件中的列执行功能</a></li><li id="f88e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" href="https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657" rel="noopener" target="_blank">根据你的活动跟踪器的日志创建热图</a></li><li id="ee97" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" href="https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989" rel="noopener" target="_blank">使用 Python 的并行 web 请求</a></li></ul><p id="1a4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这个故事，请点击关注按钮！</p><p id="3fe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nb">免责声明:本文包含的观点和看法仅归作者所有。</em></p></div></div>    
</body>
</html>