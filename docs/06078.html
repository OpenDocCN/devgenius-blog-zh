<html>
<head>
<title>Getting Started with OpenFunction: A Cloud-Native FaaS Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenFunction 入门:云原生 FaaS 平台</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-openfunction-896e7b27b690?source=collection_archive---------2-----------------------#2021-12-11">https://blog.devgenius.io/getting-started-with-openfunction-896e7b27b690?source=collection_archive---------2-----------------------#2021-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="23c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Minikube 上 OpenFunction 的 5 分钟设置，以便在 Kubernetes 上运行功能</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7dd8e98815d4c953869f224713e8a777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wh_wYCLIurRxwV0L"/></div></div></figure><p id="77cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过三年多的开发，Knative 最近宣布<a class="ae kx" href="https://knative.dev/blog/articles/announcing-knative-1.0/" rel="noopener ugc nofollow" target="_blank">推出 Knative 1.0 </a>，标志着其核心组件(发球、赛事)已经全面上市。这表明 Kubernetes 无服务器框架生态系统的成熟，包括 OpenFaaS、OpenWhisk、Kubeless、Fn 等等。然而，所有这些框架都只专注于服务打包成容器的功能，而没有提供功能齐全的功能即服务(FaaS)平台。</p><p id="1ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/OpenFunction/OpenFunction" rel="noopener ugc nofollow" target="_blank"> OpenFunction </a>是由<a class="ae kx" href="https://kubesphere.io/" rel="noopener ugc nofollow" target="_blank"> KubeSphere </a>团队支持的开源项目，于 2021 年 5 月首次发布。它旨在增强现有框架，并提供一个端到端的 FaaS 平台，以在 Kubernetes 上构建和服务事件驱动的功能。</p><h1 id="dc8b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">OpenFunction 组件</h1><p id="a1b8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">目前，OpenFunction 分为四个自定义资源定义(CRD):</p><ul class=""><li id="b186" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><strong class="jp ir">功能:</strong>通过与构建者和服务组件协调来控制功能的生命周期</li><li id="3079" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">构建器:</strong>编译、构建并发布函数到容器注册表</li><li id="b938" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">服务:</strong>运行功能并控制缩放事件</li><li id="d5ff" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">域:</strong>为函数提供一个入口点</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/7df7fd703f5f21a21953365302bb11b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WPqSnQEODGABLG1n"/></div></div></figure><p id="9945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在幕后，OpenFunction 利用几个开源项目来实现每个 CRD:</p><ul class=""><li id="098f" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">Builder 使用<a class="ae kx" href="https://shipwright.io/" rel="noopener ugc nofollow" target="_blank"> Shipwright </a>和<a class="ae kx" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank"> Cloud Native Build Packs </a>将功能代码编译并构建到容器中。</li><li id="fa15" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Serving 支持<a class="ae kx" href="https://knative.dev/docs/" rel="noopener ugc nofollow" target="_blank"> Knative </a>和 OpenFuncAsync，是基于<a class="ae kx" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank"> KEDA </a>和<a class="ae kx" href="https://dapr.io/" rel="noopener ugc nofollow" target="_blank"> Dapr </a>的运行时。</li><li id="527b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">默认情况下，域使用 nginx-ingress。</li><li id="6f8b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">此外，<a class="ae kx" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">证书管理器</a>和<a class="ae kx" href="https://tekton.dev/" rel="noopener ugc nofollow" target="_blank"> Tekton 管道</a>用于将所有部分粘合在一起。</li></ul><p id="5ba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenFunction 提供了一个方便的<a class="ae kx" href="https://github.com/OpenFunction/cli" rel="noopener ugc nofollow" target="_blank"> cli </a>来安装所有的组件，但是在这个演示中，我们将使用原始的安装脚本来控制我们的安装，并在 Minikube 上运行一些示例函数。</p><h1 id="9e5f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">启动 Minikube</h1><p id="c1b7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">OpenFunction 应该可以在 Kubernetes 的任何发行版上工作，但是对于这个演示，我们将使用 Minikube。由于 OpenFunction 所依赖的组件，Minikube 至少需要 2 个 CPU 和 4 GB 才能运行:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="2420" class="mv kz iq mr b gy mw mx l my mz">$ minikube start –cpus 2 –memory 4096</span></pre><p id="082b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意:确保 minikube 运行的是 Kubernetes 1.19 或更高版本</em></p><p id="18e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要为构建器组件提供图像注册凭证，以便将图像推入其中。我将使用 Docker，但任何图像注册表都应该工作:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="a5f4" class="mv kz iq mr b gy mw mx l my mz">$ kubectl create secret docker-registry regcred — docker-server=https://index.docker.io/v1/ — docker-username=&lt;myUsername&gt; — docker-password=&lt;myPassWord&gt;</span></pre><h1 id="2a83" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安装 OpenFunction</h1><p id="632d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在我们准备安装 OpenFunction。克隆<a class="ae kx" href="https://github.com/OpenFunction/OpenFunction" rel="noopener ugc nofollow" target="_blank"> OpenFunction repo </a>并检查<code class="fe nb nc nd mr b">hack/deploy.sh</code>脚本。</p><p id="fa0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个基本的演示，我们只需要 Shipwright、Knative 和 cert-manager 作为先决条件:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="e40f" class="mv kz iq mr b gy mw mx l my mz">$ sh hack/deploy.sh --with-shipwright --with-knative --with-cert-manager</span></pre><p id="a1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，安装 OpenFunction:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="e091" class="mv kz iq mr b gy mw mx l my mz">$ kubectl create -f <a class="ae kx" href="https://github.com/OpenFunction/OpenFunction/releases/download/v0.4.0/bundle.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenFunction/OpenFunction/releases/download/v0.4.0/bundle.yaml</a></span></pre><p id="d1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待控制器管理器运行正常:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="7c82" class="mv kz iq mr b gy mw mx l my mz">$ kubectl get pods — namespace openfunction -w</span><span id="a767" class="mv kz iq mr b gy ne mx l my mz">NAME READY STATUS RESTARTS AGE</span><span id="30c3" class="mv kz iq mr b gy ne mx l my mz">openfunction-controller-manager-6955498c9b-hjql7 2/2 Running 0 2m2s</span></pre><h1 id="7af4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">部署功能</h1><p id="8cf8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">所有的示例应用程序都托管在<a class="ae kx" href="https://github.com/OpenFunction/samples" rel="noopener ugc nofollow" target="_blank">示例</a>部分，但是目前只有 golang 文档有完整的说明。我也使用 golang 示例，但是选择任何支持的语言，并根据需要修改下面的 YAML 文件(openfunction.yaml):</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="e144" class="mv kz iq mr b gy mw mx l my mz">apiVersion: core.openfunction.io/v1alpha2<br/>kind: Function<br/>metadata:<br/>  name: function-sample<br/>spec:<br/>  version: "v1.0.0"<br/>  image: "&lt;your-docker-registry&gt;/sample-go-func:latest"<br/>  imageCredentials:<br/>    name: regcred<br/>  port: 8080 # default to 8080<br/>  build:<br/>    builder: openfunction/builder:v1<br/>    env:<br/>      FUNC_NAME: "HelloWorld"<br/>      FUNC_TYPE: "http"<br/>    srcRepo:<br/>      url: "<a class="ae kx" href="https://github.com/OpenFunction/samples.git" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenFunction/samples.git</a>"<br/>      sourceSubPath: "latest/functions/Knative/hello-world-go"<br/>  serving:<br/>    runtime: "Knative" # default to Knative<br/>    template:<br/>      containers:<br/>        - name: function<br/>          imagePullPolicy: Always</span></pre><p id="e2b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建函数:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="493e" class="mv kz iq mr b gy mw mx l my mz">$ kubectl create -f openfunction.yaml</span></pre><p id="2b0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查正在创建的 pod，并检查这些 pod 的日志，以防遇到错误(例如，错误的 Docker 凭证):</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="22b0" class="mv kz iq mr b gy mw mx l my mz">$ kubectl get functions.core.openfunction.io</span><span id="8574" class="mv kz iq mr b gy ne mx l my mz">$ kubectl get servings.core.openfunction.io</span></pre><h1 id="2c79" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试样本功能</h1><p id="db7d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦功能工作负载正常运行，我们就可以公开服务来触发事件。</p><p id="36d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在单独的终端上，创建一个到 minikube 端点的隧道:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="8728" class="mv kz iq mr b gy mw mx l my mz">$ minikube tunnel</span></pre><p id="7d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行以下命令获取我们函数的 URL:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="bfd3" class="mv kz iq mr b gy mw mx l my mz">$ kubectl get ksvc</span></pre><p id="54f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击端点(用您的端点替换 url):</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="bb03" class="mv kz iq mr b gy mw mx l my mz">$ curl <a class="ae kx" href="http://serving-rjgqg-ksvc-zf8j2.default.127.0.0.1.sslip.io" rel="noopener ugc nofollow" target="_blank">http://serving-rjgqg-ksvc-zf8j2.default.127.0.0.1.sslip.io</a></span></pre><p id="0331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该看到我们的“你好，世界！”消息。</p><h1 id="6047" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">后续步骤</h1><p id="344c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">因为 OpenFunction 实现 Knative 作为其运行时组件，所以所有的<a class="ae kx" href="https://knative.dev/docs/serving/samples/" rel="noopener ugc nofollow" target="_blank"> Knative 示例</a>将是兼容的。从个人经验来看，对于已经在运行 Kubernetes 集群的团队来说，无服务器框架往往最适合允许开发人员快速运行任意业务功能(例如，当事件 X 发生时发送电子邮件，当 webhook 被触发时运行数据转换作业)。我们将在这篇文章的第二部分探讨一个更现实的无服务器场景。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="e189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">更多内容尽在</em><a class="ae kx" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="na">blog . dev genius . io</em></a><em class="na">。</em></p></div></div>    
</body>
</html>