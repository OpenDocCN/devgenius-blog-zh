<html>
<head>
<title>Git rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git rebase</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/git-rebase-4f8fab88405a?source=collection_archive---------4-----------------------#2020-06-08">https://blog.devgenius.io/git-rebase-4f8fab88405a?source=collection_archive---------4-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/55bd50fada12f87c871fbdd5466b54f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpdCB8ssHVk6dpHL31rKbA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="9d2a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，你完成了新功能，你打开了<strong class="kf jh"> P </strong> ull <strong class="kf jh"> R </strong> equest，希望它能很快被合并。不幸的是，现实是，你的公关可能会坐在那里一段时间。与此同时，发展在继续，你的公关目标部门也在更新。</p><p id="fc37" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发生这种情况时，可能会产生冲突。这些是PR中的代码变更和合并到目标分支中的其他变更之间的冲突。你可以做的是<em class="lb">将来自目标分支的变更</em>合并到你的PR分支中，或者做一个<em class="lb"> rebase </em>。</p><p id="aaa7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Git merge和rebase服务于相同的目的。它们被设计成将来自一个或多个分支的变更集成到一个分支中。尽管最终目标是相同的，但这两种方法以不同的方式实现它，了解这种差异是有帮助的。</p><p id="b638" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从下面的图表开始，来了解其中的区别。</p><figure class="ld le lf lg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lc"><img src="../Images/edea6b36f5a613c839e98ae5321bdd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhOk-Zh1jiT-NR3yp-A8gw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">git起始图</figcaption></figure><h2 id="e193" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">Git合并</h2><p id="69e6" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">对于使用版本控制系统的开发人员来说，合并是一种常见的做法。无论分支是为了测试、错误修复还是其他原因而创建的，合并都会将更改应用到另一个位置。更具体地说，合并获取源分支的内容，并将它们与目标分支集成在一起。在这个过程中，只有目标分支被改变。源分支历史保持不变。</p><p id="f116" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">git merge</code>命令将把在一个单独的分支上对代码库所做的任何更改合并到您当前的分支中，作为一个新的提交。合并很好，因为它是一个非破坏性的操作。现有的分支不会以任何方式改变。</p><figure class="ld le lf lg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mj"><img src="../Images/f8da63002953dce891ab1a69745886df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fp1mXOZa8xyCv7_yaf0aOA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">git合并图</figcaption></figure><h2 id="657c" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">Git Rebase</h2><p id="fcca" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Rebase是将变更从一个分支整合到另一个分支的另一种方式。它表示将一系列提交移动或合并到一个新的基础提交的过程，这意味着它改变了分支上第一个提交的父级，使它看起来好像是从不同的提交创建的分支。</p><p id="e0c5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与合并不同，重定基础使历史变平，因为它将完成的工作从一个分支转移到另一个分支。在这个过程中，不需要的历史被删除。在内部，Git通过创建一系列新的提交并将它们应用到指定的库来实现这一点。理解这一点非常重要，即使分支看起来一样，它也是由全新的提交组成的。</p><p id="cae2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Git rebase期间将会发生的是，您想要添加到代码库的提交将会在目标分支的顶部重放。</p><figure class="ld le lf lg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/e8743f0f86d92d520d7ed9a6805a47d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDr4eFoEEFG-HN9O_NnQnA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">git基础图</figcaption></figure><h2 id="a608" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">合并与重设基础</h2><p id="d244" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">重定基数和合并的区别在于:</p><ul class=""><li id="99bb" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">历史的结果树结构(通常只有在查看提交图时才能注意到)是不同的(一个有分支，另一个没有)。</li><li id="7015" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">合并通常会创建额外的提交(例如树中的节点)。</li><li id="2c05" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">合并和重置基础将不同地处理冲突。Rebase将一次显示一个提交的冲突，而merge将一次显示所有冲突。</li></ul><h1 id="1fe3" class="mz li jg bd lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm nn no ly np bi translated">如何使用它</h1><p id="f7e3" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在下一节中，我们将描述各种类型的rebase用法。</p><h2 id="efd6" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">标准基数</h2><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="a71c" class="lh li jg mi b gy nu nv l nw nx">git rebase &lt;base&gt;</span></pre><p id="8d82" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的git命令将当前分支重新定位到目的地<code class="fe mf mg mh mi b">&lt;base&gt;</code>，它可以是任何类型的提交引用(ID、分支名称、标记或对<code class="fe mf mg mh mi b">HEAD</code>的相对引用)。运行时，git执行以下步骤:</p><ol class=""><li id="ff5c" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la ny mr ms mt bi translated">标识每个提交是当前提交的祖先，但不是<code class="fe mf mg mh mi b">&lt;base&gt;</code>的祖先。这可以认为是一个两步的过程:首先，找到<code class="fe mf mg mh mi b">&lt;base&gt;</code>的最后一个共同祖先和当前提交；称之为祖先提交。其次，收集祖先提交和当前提交之间的所有提交。</li><li id="6b4b" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la ny mr ms mt bi translated">确定这些提交中的每一个更改了什么(通过计算更改的增量)，并将这些更改放在一边。</li><li id="e965" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la ny mr ms mt bi translated">设置当前磁头指向<code class="fe mf mg mh mi b">&lt;base&gt;</code>。</li><li id="a535" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la ny mr ms mt bi translated">对于搁置的每个更改，在当前头上重放该更改，并创建新的提交。</li></ol><p id="9157" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成，<code class="fe mf mg mh mi b">HEAD</code>(当前提交)，是<code class="fe mf mg mh mi b">&lt;base&gt;</code>的后代，但是它包含所有的更改，就好像它已经与<code class="fe mf mg mh mi b">&lt;base&gt;</code>合并了一样。</p><p id="cb03" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之:这会将整个特征分支移动到<code class="fe mf mg mh mi b">&lt;base&gt;</code>分支之上。它通过为原始(特性)分支中的每个提交创建全新的提交来重写项目历史。特征分支的独特变化现在成为<code class="fe mf mg mh mi b">&lt;base&gt;</code>分支的<em class="lb">线性</em>历史的一部分。</p><h2 id="c538" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">交互式rebase</h2><p id="ff59" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">交互式重置基础使您可以完全控制项目历史的外观。这给了开发人员很大的自由，因为这让他们更专注于编写高质量的代码，而不用担心他们编写代码时的“混乱”历史。工作完成后，可以重温历史，进行必要的修改。</p><p id="6e6d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数开发人员喜欢在将功能分支合并到主代码库之前，使用交互式rebase来修饰它。这给了他们机会来粉碎无关紧要的提交，删除过时的提交，并确保在提交公共项目历史之前其他一切都是有序的。对于其他人来说，看起来整个特性是在一系列精心设计的提交中开发出来的。</p><p id="1f2c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行带有<code class="fe mf mg mh mi b">-i</code>标志的<code class="fe mf mg mh mi b">git rebase</code>开始一个交互式重置会话。</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="cd34" class="lh li jg mi b gy nu nv l nw nx">git rebase -i &lt;starting commit&gt;</span></pre><p id="9337" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将当前分支重置到<code class="fe mf mg mh mi b">&lt;starting commit&gt;</code>上，但是使用一个交互式重置会话。这将打开一个编辑器，您可以在其中为每个要重置基础的提交输入命令。这允许在提交被移动到新的分支时改变提交。交互式rebase比标准rebase更强大，因为它提供了对分支提交历史的完全控制。</p><p id="0e56" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入rebase会话时，用户会看到一系列可以用可用命令更改的提交:</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="3a2d" class="lh li jg mi b gy nu nv l nw nx">pick <!-- -->3718a197<!-- --> Commit#1<br/>pick <!-- -->8c8fd68a<!-- --> Commit#2<br/>pick <!-- -->e23b7527<!-- --> Commit#3<br/>pick <!-- -->181e3ec4<!-- --> Commit#4</span><span id="f883" class="lh li jg mi b gy nz nv l nw nx"># Rebase <!-- -->20913a56..2f2b483f<!-- --> onto <!-- -->20913a56<!-- --> (4 commands)<br/>#<br/># Commands:<br/># p, pick = use commit<br/># r, reword = use commit, but edit the commit message<br/># e, edit = use commit, but stop for amending<br/># s, squash = use commit, but meld into previous commit<br/># f, fixup = like "squash", but discard this commit's log message<br/># x, exec = run command (the rest of the line) using shell<br/># d, drop = remove commit</span></pre><ul class=""><li id="4dc5" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">Pick ( <code class="fe mf mg mh mi b">p</code>):您希望保持提交不变(这是默认操作)。重新安排<code class="fe mf mg mh mi b">pick</code>命令的顺序会改变rebase过程中提交的顺序。</li><li id="2d34" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Reword ( <code class="fe mf mg mh mi b">r</code>):您想要更改提交的提交消息。类似于<code class="fe mf mg mh mi b">pick</code>,但会暂停并给你机会修改提交消息。</li><li id="91d9" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">编辑(<code class="fe mf mg mh mi b">e</code>):您想要更改提交的内容。如果您选择<code class="fe mf mg mh mi b">edit</code>提交，您将有机会修改提交，这意味着您可以添加、拆分或完全更改提交。您还可以在继续rebase之前进行更多的提交。这允许您将一个大的提交分割成较小的提交，或者删除提交中的错误更改。</li><li id="148a" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Squash ( <code class="fe mf mg mh mi b">s</code>):它将提交与前一个合并，保留两个提交消息。squash命令是我们看到rebase真正效用的地方。挤压允许您指定要将哪些提交合并到以前的提交中。</li><li id="5cc7" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Fixup ( <code class="fe mf mg mh mi b">f</code>):与squash相同，但是它保留了前一次提交的提交消息。</li><li id="af90" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Exec ( <code class="fe mf mg mh mi b">x</code>):执行自定义shell命令。这并不影响提交本身。</li><li id="e377" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Drop ( <code class="fe mf mg mh mi b">d</code>):删除提交及其内容。这是摆脱承诺的最好方法。</li></ul><p id="906a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该在提交id之前写下正确的关键字或其缩写(在括号中)。</p><h2 id="eb70" class="lh li jg bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">高级重定基础方案</h2><p id="a10b" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">还有更高级的功能可用于重新设定基础。命令行参数<code class="fe mf mg mh mi b"> --onto</code>可以传递给<code class="fe mf mg mh mi b">git rebase</code>。在git rebase <code class="fe mf mg mh mi b">--onto</code>模式下，该命令扩展为:</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="18d1" class="lh li jg mi b gy nu nv l nw nx">git rebase --onto &lt;newbase&gt; &lt;oldbase&gt;</span></pre><p id="c53c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">--onto</code>命令支持更强大的表单或rebase，允许传递特定的refs作为rebase的提示。可以这样解释:<em class="lb">Rebase</em><code class="fe mf mg mh mi b"><em class="lb">&lt;oldbase&gt;</em></code><em class="lb">off of</em><code class="fe mf mg mh mi b"><em class="lb">&lt;newbase&gt;</em></code><em class="lb">，但排除</em> <code class="fe mf mg mh mi b"><em class="lb">&lt;oldbase&gt;</em></code> <em class="lb">共有的任何提交。</em></p><p id="f740" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑下面的例子:</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="542e" class="lh li jg mi b gy nu nv l nw nx">o---o---o---o---o master<br/>         \<br/>          o---o---o---o---o featureA<br/>               \<br/>                o---o---o featureB</span></pre><p id="d044" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">featureA</code>分支为<code class="fe mf mg mh mi b">master</code>，<code class="fe mf mg mh mi b">featureB</code>分支为<code class="fe mf mg mh mi b">featureA</code>。现在假设我们想要将<code class="fe mf mg mh mi b">featureB</code>中的所有内容，而不是<code class="fe mf mg mh mi b">featureA</code>中的所有内容，合并到<code class="fe mf mg mh mi b">master</code>中。所以<code class="fe mf mg mh mi b">featureB</code>是基于<code class="fe mf mg mh mi b">featureA</code>的，然而我们意识到<code class="fe mf mg mh mi b">featureB</code>不依赖于<code class="fe mf mg mh mi b">featureA</code>中的任何变化，可以直接从<code class="fe mf mg mh mi b">master</code>中分支出来。</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="e1f5" class="lh li jg mi b gy nu nv l nw nx">git rebase --onto master featureA featureB</span></pre><p id="246a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将告诉git将<code class="fe mf mg mh mi b">featureB</code>中不与<code class="fe mf mg mh mi b">featureA</code>共享的部分重归到<code class="fe mf mg mh mi b">master</code>上。生成的图形如下所示:</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="a353" class="lh li jg mi b gy nu nv l nw nx">                      o---o---o featureB<br/>                     /<br/>    o---o---o---o---o master<br/>     \<br/>      o---o---o---o---o featureA</span></pre><p id="c5f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以使用日志命令的一种高级形式来检查在<code class="fe mf mg mh mi b">featureB</code>中但不在<code class="fe mf mg mh mi b">featureA</code>中的提交集:</p><pre class="ld le lf lg gt nq mi nr ns aw nt bi"><span id="344d" class="lh li jg mi b gy nu nv l nw nx">git log --oneline featureB ^featureA</span></pre><p id="143a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样你就可以确定你做的是对的。</p><h1 id="75e9" class="mz li jg bd lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm nn no ly np bi translated">配置选项</h1><p id="fb52" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用<code class="fe mf mg mh mi b">git config</code>可以设置一些重设基础属性</p><ul class=""><li id="3fdf" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><strong class="kf jh">rebase.stat</strong></code>:默认设置为假的布尔值。该选项切换可视diffstat内容的显示，该内容显示自上次重设基础以来发生了什么变化。</li><li id="60dd" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><strong class="kf jh">rebase.autoSquash:</strong></code>切换<code class="fe mf mg mh mi b">--autosquash</code>行为的布尔值。</li><li id="5e38" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><strong class="kf jh">rebase.missingCommitsCheck:</strong></code>可以设置为多个值，这些值可以改变丢失提交时的rebase行为。<br/> <code class="fe mf mg mh mi b">warn</code>在交互模式下打印警告输出，警告删除提交<br/> <code class="fe mf mg mh mi b">error</code>停止重置并打印删除提交警告消息<br/> <code class="fe mf mg mh mi b">ignore</code>默认设置，忽略任何丢失的提交警告</li><li id="b337" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><strong class="kf jh">rebase.instructionFormat:</strong></code>一个<code class="fe mf mg mh mi b">git log</code>格式字符串，将用于格式化交互式的rebase显示</li><li id="aa12" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><strong class="kf jh">rebase.abbreviateCommands:</strong></code>一个布尔值，如果设置为真，<code class="fe mf mg mh mi b">git rebase</code>将在待办事项列表中使用缩写的命令名</li></ul><h1 id="0200" class="mz li jg bd lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm nn no ly np bi translated">理解重定基数的危险</h1><p id="a62b" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当您执行一个<code class="fe mf mg mh mi b">git rebase</code>操作时，您通常会移动提交。因此，您可能会遇到合并冲突的情况。这意味着您的两次提交修改了同一个文件中的同一行，而git不知道应用哪个更改。</p><p id="44f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">合并失败可能会阻止此过程完全自动化。您必须解决任何此类合并失败并运行<code class="fe mf mg mh mi b">git rebase --continue</code>。另一个选择是用<code class="fe mf mg mh mi b">git rebase --skip</code>绕过导致合并失败的提交。要检查原始的<code class="fe mf mg mh mi b">git &lt;branch&gt;</code>并删除<code class="fe mf mg mh mi b">.git/rebase-apply</code>工作文件，使用命令<code class="fe mf mg mh mi b">git rebase --abort</code>代替。</p><p id="4ad6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Git rebase本身并不十分危险。当执行历史重写交互式rebases并强制将结果推送到其他用户共享的远程分支时，真正的危险出现了。rebase会用新的提交替换旧的提交，这看起来像是你的项目历史的一部分突然消失了。这是一种应该避免的模式，因为它有能力在其他远程用户拉取时覆盖他们的工作。</p><h1 id="eb71" class="mz li jg bd lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm nn no ly np bi translated">摘要</h1><p id="9dba" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Git rebase赋予你修改历史的能力，交互式rebase允许你这样做而不会留下“混乱”的痕迹。这创造了犯错误、改正错误和改进工作的自由，同时仍然保持一个干净的、线性的项目历史。</p></div></div>    
</body>
</html>