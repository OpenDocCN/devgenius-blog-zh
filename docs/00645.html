<html>
<head>
<title>Facebook Log Id button with Symfony Guard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Symfony保护的脸书日志Id按钮</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/facebook-log-id-button-with-symfony-guard-97afb1dd3142?source=collection_archive---------9-----------------------#2020-06-13">https://blog.devgenius.io/facebook-log-id-button-with-symfony-guard-97afb1dd3142?source=collection_archive---------9-----------------------#2020-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/42894fe6c2e6f122a5667ff6635fef3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxAIgoeM-v6y1bGAez34wA.jpeg"/></div></div></figure><p id="5b81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的目标是将<strong class="jx io">继续脸书</strong>(登录)按钮添加到现有的Symfony应用程序中。我没有在这里提供完整的代码。只有创建您的脸书登录按钮的主要部分。以下是我所做的。</p><h1 id="b99e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">概观</h1><p id="ede6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">工作流程概述是:</p><ol class=""><li id="c27d" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">用户点击脸书登录按钮</li><li id="d0c5" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">脸书认证用户</li><li id="9a70" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">应用程序向Symfony后端发送facebook令牌(认证数据)</li><li id="173d" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">后端使用auth data获取用户数据(姓名和电子邮件),并使用Symfony处理程序登录。</li></ol><p id="dfa5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以脸书只在唯一的第一部分是必要的——检查想要登录的人。<br/>我用<a class="ae mk" href="https://symfony.com/doc/current/security/guard_authentication.html" rel="noopener ugc nofollow" target="_blank">守卫</a>在后台给用户授权。</p><h1 id="7c61" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">脸书图书馆</h1><p id="b863" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在此创建新应用<a class="ae mk" href="https://developers.facebook.com/apps" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4c08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前端需要脸书Javascript SDK，后端需要PHP库。<br/>安装PHP脸书库:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="385b" class="mu ku in mq b gy mv mw l mx my">composer require facebook/graph-sdk</span></pre><p id="faf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将脸书Javascript SDK包含到您的模板中。应该是这样的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bdf0" class="mu ku in mq b gy mv mw l mx my">&lt;script async defer crossorigin="anonymous"<br/>src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&amp;version=v7.0&amp;appId=&lt;your app id here&gt;"&gt;<br/>&lt;/script&gt;</span></pre><p id="fca6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最简单的方法是从<strong class="jx io">脸书登录</strong> — <strong class="jx io">快速入门</strong>部分的<a class="ae mk" href="https://developers.facebook.com/apps" rel="noopener ugc nofollow" target="_blank">脸书开发者</a>页面生成这个片段。</p><h1 id="a939" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">前端</h1><p id="3f85" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">接下来，您需要添加一个按钮并处理登录结果。按钮示例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6552" class="mu ku in mq b gy mv mw l mx my">&lt;div class="fb-login-button"<br/>     data-size="large"<br/>     data-button-type="continue_with"<br/>     data-layout="default"<br/>     data-auto-logout-link="false"<br/>     data-use-continue-as="false"<br/>     data-scope="public_profile,email"<br/>     onlogin="fbGetLoginStatus();"<br/>     data-width=""&gt;&lt;/div&gt;</span></pre><p id="0103" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mk" href="https://developers.facebook.com/docs/facebook-login/web/login-button/" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个按钮配置器。</p><p id="326f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我用这段代码创建了一个Javascript模块:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8a46" class="mu ku in mq b gy mv mw l mx my">window.fbGetLoginStatus = function () {<br/>    FB.getLoginStatus(function (response) {<br/>        if (isConnected(response)) {<br/>            fbLogIn(response);<br/>        }<br/>    });<br/>}<br/>function isConnected(response) {<br/>    return response.status === 'connected';<br/>}<br/><br/>function fbLogIn(response) {<br/>    let loginForm = document.querySelector('.login-form');<br/>    let input = getHiddenInput("fbAuthResponse", JSON.stringify(response.authResponse));    <br/>    loginForm.appendChild(input);<br/>    loginForm.submit();<br/>}<br/><br/>function getHiddenInput(name, value) {<br/>    let input = document.createElement("input");<br/>    input.setAttribute("type", "hidden");<br/>    input.setAttribute("name", name);<br/>    input.setAttribute("value", value);<br/>}</span></pre><p id="84e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户点击<em class="mz">*继续脸书</em>按钮并成功登录时，我会提交一个登录(或注册)表单，并通过POST请求将数据发送到后端。</p><h1 id="84cc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">后端— Symfony Guard</h1><p id="adae" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我已经为通常的登录密码认证设置了一个防护。所以我加上第二个。以下是我的security.yaml警卫配置:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0909" class="mu ku in mq b gy mv mw l mx my">security:<br/>    firewalls:<br/>        main:<br/>            guard:<br/>                authenticators:<br/>                    - App\Security\LoginFormAuthenticator<br/>                    - App\Security\FacebookAuthenticator<br/>                entry_point: App\Security\LoginFormAuthenticator</span></pre><p id="5fc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您需要创建保护文件，它扩展了AbstractFormLoginAuthenticator:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c552" class="mu ku in mq b gy mv mw l mx my">class FacebookAuthenticator extends AbstractFormLoginAuthenticator {}</span></pre><p id="ffd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">FacebookAuthenticator的主要方法将是:<br/> <strong class="jx io">支持</strong> —它检查您是否应该使用该保护。我对登录和注册页面使用了相同的逻辑。看起来是这样的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="902b" class="mu ku in mq b gy mv mw l mx my">public function supports(Request $request)<br/>{<br/>    $route = $request-&gt;attributes-&gt;get('_route');<br/>    $isLoginOrRegister = in_array($route, ['app_login', 'app_register']);<br/>    return $isLoginOrRegister <br/>        &amp;&amp; $request-&gt;isMethod('POST') <br/>        &amp;&amp; $request-&gt;get('fbAuthResponse');<br/>}</span></pre><p id="3044" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> getCredentials </strong> —获取脸书认证响应并将其解码为一个数组:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="af32" class="mu ku in mq b gy mv mw l mx my">public function getCredentials(Request $request)<br/>{<br/>    return json_decode($request-&gt;get('fbAuthResponse'), true);<br/>}</span></pre><p id="e0aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">onAuthenticationSuccess</strong>—我将用户重定向到登录页面:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2883" class="mu ku in mq b gy mv mw l mx my">public function onAuthenticationSuccess(<br/>    Request $request, <br/>    TokenInterface $token, <br/>    $providerKey<br/>)<br/>{<br/>    return new RedirectResponse(<br/>        $this-&gt;urlGenerator-&gt;generate('app_landing')<br/>    );<br/>}</span></pre><p id="5d5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用url生成器，将其添加到构造函数中(见下文)。</p><p id="2dad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> getUser </strong> —主要部分，从脸书图形API获取电子邮件和名称，并返回用户实体:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="17e1" class="mu ku in mq b gy mv mw l mx my">public function getUser($credentials, UserProviderInterface $userProvider)<br/>{<br/>    if (empty($credentials['accessToken'])) {<br/>        throw new CustomUserMessageAuthenticationException('Your message here');<br/>    }<br/>    <br/>    $fbUser = $this-&gt;fbService-&gt;getUser($credentials['accessToken']);<br/><br/>    if (empty($fbUser-&gt;getEmail())) {<br/>        throw new CustomUserMessageAuthenticationException('Your message here');<br/>    }<br/><br/>    return $userProvider-&gt;loadUserByUsername($fbUser-&gt;getEmail());<br/>}</span></pre><p id="9d5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户不存在时，我使用电子邮件和名称进行注册。这里只是登录部分，为了简单起见没有注册。</p><p id="ad3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是在Guard构造函数中自动连接服务的方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e86a" class="mu ku in mq b gy mv mw l mx my">public function __construct(<br/>    FacebookService $fbService, <br/>    UrlGeneratorInterface $urlGenerator<br/>)<br/>{<br/>    $this-&gt;fbService = $fbService;<br/>    $this-&gt;urlGenerator = $urlGenerator;<br/>}</span></pre><p id="adf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的fbService是这样的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6c82" class="mu ku in mq b gy mv mw l mx my">&lt;?php<br/><br/>namespace App\Service;<br/><br/>use App\Entity\FacebookUser;<br/>use Facebook\Facebook;<br/><br/>class FacebookService<br/>{<br/>    private $client;<br/><br/>    public function __construct(<br/>        string $fbAppId, <br/>        string $fbAppSecret, <br/>        string $fbGraphVersion<br/>    )<br/>    {<br/>        $this-&gt;client = new Facebook([<br/>            'app_id' =&gt; $fbAppId,<br/>            'app_secret' =&gt; $fbAppSecret,<br/>            'default_graph_version' =&gt; $fbGraphVersion,<br/>        ]);<br/><br/>    }<br/><br/>    public function getUser(string $token): FacebookUser<br/>    {<br/>        $user = new FacebookUser();<br/><br/>        try {<br/>            $fbUser = $this-&gt;client-&gt;get("/me?fields=name,email", $token);<br/>            $data = $fbUser-&gt;getDecodedBody();<br/>            $user<br/>                -&gt;setName($data['name'])<br/>                -&gt;setEmail($data['email']);<br/>        } catch (\Throwable $exception) {<br/>            // handle exception here<br/>        }<br/><br/>        return $user;<br/>    }<br/>}</span></pre><p id="3967" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了自动连接FacebookService构造函数参数，将变量添加到。env文件(根据您的环境)并将参数添加到services.yaml配置:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6cb7" class="mu ku in mq b gy mv mw l mx my">services:<br/>    App\Service\FacebookService:<br/>        arguments:<br/>            $fbAppId: '%env(FB_APP_ID)%'<br/>            $fbAppSecret: '%env(FB_APP_SECRET)%'<br/>            $fbGraphVersion: '%env(FB_GRAPH_VERSION)%'</span></pre><p id="165e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个FacebookUser用户实体。可以用数组代替实体，但是OOP对我来说更方便。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="dc08" class="mu ku in mq b gy mv mw l mx my">&lt;?php<br/><br/>namespace App\Entity;<br/><br/>class FacebookUser<br/>{<br/>    private $name;<br/>    private $email;<br/><br/>    public function getName(): ?string<br/>    {<br/>        return $this-&gt;name;<br/>    }<br/><br/>    public function setName($name): self<br/>    {<br/>        $this-&gt;name = $name;<br/>        return $this;<br/>    }<br/><br/>    public function getEmail(): ?string<br/>    {<br/>        return $this-&gt;email;<br/>    }<br/><br/>    public function setEmail(string $email): self<br/>    {<br/>        $this-&gt;email = $email;<br/>        return $this;<br/>    }<br/>}</span></pre><p id="9527" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。</p><p id="4f51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，在Guard中还有更多的方法，但创建它们应该并不复杂。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="9e70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mz">原载于</em><a class="ae mk" href="https://bogomolov.tech/Facebook-Log-Id-Symfony/" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://bogomolov . tech</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>