<html>
<head>
<title>SwiftUI: Different Ways To Present Modal Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:呈现模态视图的不同方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swiftui-different-ways-to-present-modal-views-26472947a800?source=collection_archive---------0-----------------------#2022-01-20">https://blog.devgenius.io/swiftui-different-ways-to-present-modal-views-26472947a800?source=collection_archive---------0-----------------------#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc39" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 SwiftUI 中学习不同的方式和方法来对视图进行建模</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/764a1b28218fa925673a465e26391cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CLPp_yMElt5rmkSNZfroA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/it-it/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">皮查拜</a>从<a class="ae kv" href="https://www.pexels.com/it-it/foto/micro-fotografia-dello-specchio-d-acqua-221189/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><p id="e964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI 是一个令人惊叹的框架，由苹果公司正式创建，以声明性和令人难以置信的快速方式构建用户界面。它还很年轻，但是越来越多的开发者在他们的应用中采用它。因为太年轻，经常发生的事情是，没有标准的方法来做某事，最佳实践还没有定义，所以我们经常有许多方法来解决同一个问题。</p><p id="99ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在今天的文章中，我将向你展示用模态的方式呈现一个新的<code class="fe ls lt lu lv b">View</code>的不同方法。</p><h2 id="7041" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">一个小小的 UX 速成班…</h2><p id="6031" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，让我们从一堂关于 UX 的课开始…为什么我们需要模态展示？模态流的作用是什么？</p><p id="72ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 UX 流中，我们通常以水平过渡的方式转到下一个屏幕，通常是从左到右，就像你写的那样(请允许我做一点近似)，所以下一个控制器是从屏幕的一侧推出的。这感觉很自然，因为这是我们内心深处的习惯。这就是我们看书时发生的事情。但是，如果需要记下我们正在阅读的内容，会发生什么呢？嗯，我们把放在书下面的便利贴拿出来，放在书页上，写点东西，然后放回别的地方。上上下下。我们已经停止了正常的流向<strong class="ky ir">走一条短弯路</strong>。在应用程序中，我们会用<strong class="ky ir">模态呈现</strong>来完成。就是这样，当我们不得不暂停一个正常的流程来暂时做一些不同的事情时，就需要一个模态。也许我们需要给用户额外的信息，这样我们就可以有模式地呈现这些信息。<br/>举一个现实生活中的例子，几天前，我正在使用我全新的“wi-fi-ed”洗衣机，在中途，我被要求输入序列号。一个按钮将我指向机器上数字的位置，一个模态视图显示了它的位置。</p><h2 id="5487" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">不同的方式…</h2><p id="f9b3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在 SwiftUI 中，基本上有 3 种方式来执行模态呈现，实际上是 3+1，但我们稍后会看到。这些是我们的选择:</p><ul class=""><li id="5550" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">工作表</li><li id="f05c" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">过渡</li><li id="8fb1" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">动画片</li></ul><p id="8d45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些选择都很好，为我们的问题提供了解决方案，但彼此略有不同。让我们逐一分析。</p><p id="4dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将构建一个超级简单的应用程序来显示演示选项。只有两种观点。</p><h2 id="8689" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">工作表</h2><p id="3a04" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Sheets 碰巧是呈现 SwiftUI 的经典方式，因为苹果让它变得超级简单，所以可能 90%的开发者更喜欢用这种方式。好了，别说了，让我们写点代码吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="8eaf" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">第 3 行:类型为<code class="fe ls lt lu lv b">Bool</code>的<code class="fe ls lt lu lv b">@State var</code>保存了整个表示的逻辑。</li><li id="39fd" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 11 行:<code class="fe ls lt lu lv b">Bool</code>被切换。</li><li id="a2c2" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 20 行:<code class="fe ls lt lu lv b">Sheet</code>以标准方式呈现。</li></ul><p id="4611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看显示的屏幕:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="45a7" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">第 3 行:魔法在这里完成了。属性包装器将局部变量与环境连接起来，允许我们在需要时消除这个视图。</li><li id="03c7" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 13 行:用一个标准的命令关闭视图。</li></ul><p id="d2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我只是向你展示了展示一个新视图的标准方法，但是有一点我不喜欢……一种卡片效果被应用到了展示的视图中。视图本身在背景中变小了，并且稍微缩小了。此外，所呈现的视图没有覆盖 100%的可用屏幕:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/56d45b5c9ddc298116eef62bbfaf31e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*M2Zix97OFIB__YSjMdwHWw.jpeg"/></div></figure><p id="e017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，我对这种演示模式并不满意。如果你需要开始一个全新的心流，那么总是有一个开始的视角会很难看…悄悄靠近你…相当可怕和怪异😁。<br/>幸运的是苹果给了我们一个解决方案(你还记得前面某处的+1 吗？).<br/>在 presenting 视图的第 21 行，使用以下代码:</p><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="b8bd" class="lw lx iq lv b gy np nq l nr ns">.fullScreenCover(isPresented: $showView) { SecondView() }</span></pre><p id="5850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…你猜怎么着？<code class="fe ls lt lu lv b">SecondView()</code>现在全屏呈现！</p><h2 id="e877" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">过渡</h2><p id="62c9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">第二种有模式地呈现视图的方法是使用过渡。处理事务的方法略有不同，但对我来说，它更强大，更可定制。事实上，您可以从屏幕的任何一侧呈现视图，而不仅仅是从底部。这样，你也可以模仿一个<code class="fe ls lt lu lv b">Segue</code>的演示模式。</p><p id="01a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们写一些代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="debc" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">第 11 行:<code class="fe ls lt lu lv b">withAnimation</code>需要稍后创建一个动画过渡。</li><li id="bc06" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 21 行:一个绑定变量被传递给呈现的视图。我们将在稍后的解散过程中使用它。</li><li id="af89" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 22 行:请注意<code class="fe ls lt lu lv b">zIndex(1)</code>。稍后需要此修改器，以便在解散动画中，将呈现的视图保持在堆栈顶部。否则，视图将被放在后面，然后随着动画消失。</li><li id="55dd" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 23 行:神奇之处都在这里。这一行代码触发了转换。请注意在该行的和处带有<code class="fe ls lt lu lv b">.bottom</code>值的<code class="fe ls lt lu lv b">enum</code>。该值驱动转换的入口点:呈现的视图将从屏幕底部进入。在解除阶段，动画会反转，因此视图会转到屏幕的底部。</li></ul><p id="9c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们写第二个视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="a149" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">第 12 行:绑定变量用动画切换，以创建一个愉快的解散。</li></ul><p id="5280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常好，超级简单。呈现的视图覆盖了整个屏幕区域，因此您可以毫无问题地开始一个全新的流程。</p><p id="b3a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，由于 Xcode 13.2 实际版本中的一个错误，画布不会以正确的方式显示演示文稿。使用模拟器或在 iPhone 上运行。</p><h2 id="9e6f" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">动画片</h2><p id="1ef5" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">呈现新屏幕的最后一种方式是使用动画。可能这个给了我们更多的灵活性，但是需要更多的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="b50e" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">第 5 行:创建一个计算变量来计算显示屏幕的垂直偏移量。</li><li id="c26c" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 15 行:<code class="fe ls lt lu lv b">Bool</code>在这里用动画切换。</li><li id="dcef" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第 26 行:<code class="fe ls lt lu lv b">.offset</code>修改器允许动画视图。</li></ul><p id="2c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">呈现的<code class="fe ls lt lu lv b">SecondView03</code>和前面的例子完全一样，所以我不再复制了。</p><p id="3352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，由于 Xcode 13.2 实际版本的一个 bug，画布不会以正确的方式显示动画。使用模拟器或在 iPhone 上运行。</p><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，只要付出一点额外的努力，这种动画就能创造出完全不同的美妙效果。我将向您展示一个小例子，对前面的结构做了一点编辑。</p><p id="16dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建第二个计算变量:</p><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="6e87" class="lw lx iq lv b gy np nq l nr ns"><strong class="lv ir">var</strong> yOffset: CGFloat { <br/>    showView ? 0 : UIScreen.main.bounds.height <br/>}</span><span id="73d1" class="lw lx iq lv b gy nt nq l nr ns"><strong class="lv ir">var</strong> xOffset: CGFloat { <br/>    showView ? 0 : -UIScreen.main.bounds.width/2 <br/>}</span></pre><p id="e00c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们也有了一个水平偏移… <br/>让我们改变第 25 行的动画，添加一点弹簧效果:</p><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="cd04" class="lw lx iq lv b gy np nq l nr ns">SecondView03(showView: $showView)<br/>    .animation(.spring(response: 0.75, <br/>                       dampingFraction: 0.7, <br/>                       blendDuration: 1), value: showView)<br/>    .offset(x: xOffset, y: yOffset)</span></pre><p id="43ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个简单的修改，我们创造了一种全新的方式来呈现屏幕…可能性是无限的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/15d1421bfda23267693ebc597d4c644c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*FejjZpzBgOoj0q9dG6oWxA.gif"/></div></figure><h2 id="571a" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">最后的话</h2><p id="33c3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">现在，您已经拥有了按照您想象的方式创建模态转换所需的所有工具。你会用哪一个？嗯，没有金科玉律。这取决于你想要创造的效果。看你的了！你有所有的权力！</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="93ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣了解更多，更多关于 SwiftUI 中的动画，我强烈建议你看看这本很棒的互动书籍:</p><div class="oc od gp gr oe of"><a href="https://www.bigmountainstudio.com/animations-16/jz1m0" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">SwiftUI 动画大师(iOS 16)</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">从初学者到大师，了解本“视频”书如何使用最有效的方法来教授 SwiftUI 动画…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.bigmountainstudio.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="b6f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，如果你喜欢，请鼓掌。<br/>如果这篇文章对你有用，请随意<a class="ae kv" href="https://www.buymeacoffee.com/dy59tqxn794" rel="noopener ugc nofollow" target="_blank">给我一杯咖啡</a>并允许我创造更多酷的内容和文章。</p><p id="56ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">享受你的编码！</p></div></div>    
</body>
</html>