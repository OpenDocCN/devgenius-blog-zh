<html>
<head>
<title>Effective Java: For Instance Control, Prefer Enum types to readResolve</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的Java:对于实例控制，优先使用枚举类型而不是readResolve</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/effective-java-for-instance-control-prefer-enum-types-to-readresolve-4c30c71b765e?source=collection_archive---------9-----------------------#2021-12-08">https://blog.devgenius.io/effective-java-for-instance-control-prefer-enum-types-to-readresolve-4c30c71b765e?source=collection_archive---------9-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da3391d3a799c454d2da839685541fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uz4XIDlV2S2rpViO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马丁·桑切斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d3eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上一节中，我们讨论了在Java中创建单例对象的不同方法。我们讨论的方法之一遵循以下模式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8b7e" class="lk ll iq lg b gy lm ln l lo lp">public class Elvis {<br/>  public static final Elvis INSTANCE = new Elvis();<br/>  private Elvis() { ... }</span><span id="b214" class="lk ll iq lg b gy lq ln l lo lp">  public void leaveTheBuilding() { ... }<br/>}</span></pre><p id="f5fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过构造构造函数<code class="fe lr ls lt lg b">private</code>，我们可以防止意外创建<code class="fe lr ls lt lg b">Elvis</code>对象。这种模式的问题是，如果你把<code class="fe lr ls lt lg b">implements Serializable</code>添加到类中，我们就会绕过私有构造函数。正如前面章节中提到的，序列化有效地引入了一个新的、系统提供的构造函数。</p><p id="a407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理这个问题并收回对一个类产生的实例的一些控制的内置功能是<code class="fe lr ls lt lg b">readResolve</code>函数。该功能允许用另一个实例代替由<code class="fe lr ls lt lg b">readObject</code>创建的实例。如果你的类用正确的签名定义了一个<code class="fe lr ls lt lg b">readResolve</code>函数，它将在<code class="fe lr ls lt lg b">readObject</code>函数之后被调用。此方法返回的引用将代替新创建的对象返回。通常情况下，不会保留对新创建对象的引用，因此可以对其进行垃圾收集。</p><p id="f335" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个功能来确定我们上面的<code class="fe lr ls lt lg b">Elvis</code>类可能最终看起来像下面这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b896" class="lk ll iq lg b gy lm ln l lo lp">private Object readResolve() {<br/>  return INSTANCE;<br/>}</span></pre><p id="155b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，这非常简单，我们不需要对新创建的对象做任何事情，只需要返回一个真正的<code class="fe lr ls lt lg b">Elvis</code>实例。因为没有使用来自序列化的数据，所以我们可以并且应该将所有实例字段声明为<code class="fe lr ls lt lg b">transient</code>。如果你有对象引用类型的实例字段，那么你必须声明它们<code class="fe lr ls lt lg b">transient</code>以避免可能的攻击，攻击者可以在对象被垃圾收集之前得到反序列化的对象，因此可以保留它，导致你的singleton不再是singleton。</p><p id="65cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解这种攻击的具体步骤并不是绝对必要的。鼓励感兴趣的读者阅读原始资料。我只想说，通过创建一个“stealer”类，可以导致与反序列化对象的循环依赖，从而避免垃圾收集。虽然不太可能受到攻击，但安全总比后悔好。</p><p id="c429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然将所有字段声明为<code class="fe lr ls lt lg b">transient</code>是避免这个问题的一种方法，但也有其他方法可以实现。上一章中的另一个模式使用了单元素枚举类型来简化单例。这将大量的单例安全语义放在JVM上执行，并将您从这一负担中解放出来。我们的枚举类型示例如下:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8364" class="lk ll iq lg b gy lm ln l lo lp">public enum Elvis {<br/>  INSTANCE;</span><span id="8345" class="lk ll iq lg b gy lq ln l lo lp">  private String[] favoriteSongs = { "Hound Dog", "Heartbreak Hotel" }<br/>  public void printFavorites() {<br/>    System.out.println(Arrays.toString(favoriteSongs));<br/>  }<br/>}</span></pre><p id="9f2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个类的实例在编译时未知时，即使使用上面的模式也可能是必要的。</p><p id="3b1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lr ls lt lg b">readResolve</code>函数时，另一件要注意的事情是方法的可见性。如果你的班级是<code class="fe lr ls lt lg b">final</code>，那么<code class="fe lr ls lt lg b">readResolve</code>应该是<code class="fe lr ls lt lg b">private</code>。如果你的课程不是期末考试，你会有更多的选择。如果设置为<code class="fe lr ls lt lg b">private</code>，它不会对子类做任何实例控制。如果它是包私有的，它将只适用于存在于同一个包中的子类。最后，如果将它设为<code class="fe lr ls lt lg b">protected</code>或<code class="fe lr ls lt lg b">public</code>，并且子类没有覆盖它，那么该类的任何反序列化都将创建超类的一个实例，而不是子类，这可能会导致<code class="fe lr ls lt lg b">ClassCastException</code>。</p><p id="f877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，在尝试对可序列化的类实施实例控制时，应该尽可能优先使用枚举类型单例。如果不可能使用枚举模式，那么在编写类的<code class="fe lr ls lt lg b">readResolve</code>方法时需要仔细考虑。您应该确保该类的所有实例字段要么是原始的，要么被标记为瞬态的，以防止对您的实例控制机制的潜在攻击。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="d58d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mb">更多内容尽在</em><a class="ae kc" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="mb">blog . dev genius . io</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>