<html>
<head>
<title>Have You Mastered These 9 Vue Techniques?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这9个Vue技巧你都掌握了吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/have-you-mastered-these-9-vue-techniques-c4c2fb245eb8?source=collection_archive---------0-----------------------#2020-07-24">https://blog.devgenius.io/have-you-mastered-these-9-vue-techniques-c4c2fb245eb8?source=collection_archive---------0-----------------------#2020-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7ebc7520ab8d6e92b88105846eefd7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRHUcb0mzBaN_7b41mIhDw.png"/></div></div></figure><p id="e13e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在<a class="ae kt" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>已经成为前端开发的热门框架。有很多工程师在利用<a class="ae kt" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>的便利和强大功能。然而，我们所做的一些解决方案可能没有遵循最佳实践。好了，让我们来看看那些必须知道的<a class="ae kt" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>技术。</p><p id="f21c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(访问<a class="ae kt" href="https://pitayan.com/posts/vue-techniques/?ref=medium" rel="noopener ugc nofollow" target="_blank">https://pitayan.com/posts/vue-techniques/</a>阅读原文。<strong class="jx io">源代码高亮显示。</strong>)</p><h1 id="6636" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/#1-functional-component" rel="noopener ugc nofollow" target="_blank"> 1。功能组件</a></h1><p id="a3a2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">一个<a class="ae kt" href="https://vuejs.org/v2/guide/render-function.html#Functional-Components" rel="noopener ugc nofollow" target="_blank">功能组件</a>是无状态的，没有<code class="fe lx ly lz ma b">lifecycle</code>或<code class="fe lx ly lz ma b">methods</code>。因此它不能被实例化</p><p id="e352" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个功能组件非常容易，您所需要做的就是向SFC添加一个<code class="fe lx ly lz ma b">functional: true</code>属性或者向模板添加<code class="fe lx ly lz ma b">functional</code>。由于它像函数一样轻巧，没有实例引用，所以渲染性能有了很大的提高。</p><p id="3cdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">功能组件依赖于<code class="fe lx ly lz ma b">context</code>,并随着其中给定的数据而变异。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="64f2" class="mj kv in ma b gy mk ml l mm mn">&lt;template functional&gt;<br/>  &lt;div class="book"&gt;<br/>    {{props.book.name}} {{props.book.price}}<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="e346" class="mj kv in ma b gy mo ml l mm mn">&lt;script&gt;<br/>Vue.component('book', {<br/>  functional: true,<br/>  props: {<br/>    book: {<br/>      type: () =&gt; ({}),<br/>      required: true<br/>    }<br/>  },<br/>  render: function (createElement, context) {<br/>    return createElement(<br/>      'div',<br/>      {<br/>        attrs: {<br/>          class: 'book'<br/>        }<br/>      },<br/>      [context.props.book]<br/>    )<br/>  }<br/>})<br/>&lt;/script&gt;</span></pre><h1 id="5c75" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#2-deep-selectors" rel="noopener ugc nofollow" target="_blank"> 2。深度选择器</a></h1><p id="7a0c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有时你甚至需要cha第三方组件CSS，它们是<code class="fe lx ly lz ma b">scoped</code>样式。无法移除<code class="fe lx ly lz ma b">scope</code>或开启新样式。</p><p id="1c57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在<a class="ae kt" href="https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements" rel="noopener ugc nofollow" target="_blank">深度选择器</a> <code class="fe lx ly lz ma b">&gt;&gt;&gt;</code> <code class="fe lx ly lz ma b">/deep/</code> <code class="fe lx ly lz ma b">::v-deep</code>进入正确的求助位置。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="f5df" class="mj kv in ma b gy mk ml l mm mn">&lt;style scoped&gt;<br/>&gt;&gt;&gt; .scoped-third-party-class {<br/>  color: gray;<br/>}<br/>&lt;/style&gt;</span><span id="54bd" class="mj kv in ma b gy mo ml l mm mn">&lt;style scoped&gt;<br/>/deep/ .scoped-third-party-class {<br/>  color: gray;<br/>}<br/>&lt;/style&gt;</span><span id="2c27" class="mj kv in ma b gy mo ml l mm mn">&lt;style scoped&gt;<br/>::v-deep .scoped-third-party-class {<br/>  color: gray;<br/>}<br/>&lt;/style&gt;</span></pre><h1 id="c440" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#3-advanced-watcher" rel="noopener ugc nofollow" target="_blank"> 3。</a>高级“守望者”</h1><h2 id="9dfb" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#execute-immedately" rel="noopener ugc nofollow" target="_blank">立即执行</a></h2><p id="2875" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><code class="fe lx ly lz ma b">watch</code>被监控的道具变异时触发处理程序。但有时，它是在组件创建后立即出现的。</p><p id="7443" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，有一个简单的解决方案:调用<code class="fe lx ly lz ma b">created</code>钩子中的处理程序。但这看起来并不优雅，同时也增加了复杂性。</p><p id="510b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，您可以向watcher添加一个<code class="fe lx ly lz ma b">immediate</code>属性:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="5526" class="mj kv in ma b gy mk ml l mm mn">watch: {<br/>    value: {<br/>        handler: 'printValue',<br/>        immediate: true<br/>    }<br/>},<br/>methods : {<br/>  printValue () {<br/>    console.log(this.value)<br/>  }<br/>}</span></pre><h2 id="2ff5" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#deep-listening" rel="noopener ugc nofollow" target="_blank">深度倾听</a></h2><p id="5523" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有时守望者道具是一个<code class="fe lx ly lz ma b">Object</code>。但是它的属性突变不能触发观察器处理程序。在这种情况下，给watcher添加<code class="fe lx ly lz ma b">deep: true</code>可以使其属性的突变可被检测到。</p><p id="601c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，当您的<code class="fe lx ly lz ma b">Object</code>有许多层时，<code class="fe lx ly lz ma b">deep</code>可能会导致一些严重的性能问题。最好考虑使用更扁平的数据结构。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a7fa" class="mj kv in ma b gy mk ml l mm mn">data () {<br/>  return {<br/>    value: {<br/>      one: {<br/>        two: {<br/>          three: 3<br/>        }<br/>      }<br/>    }<br/>  }<br/>},<br/>watch: {<br/>  value: {<br/>    handler: 'printValue',<br/>    deep: true<br/>  }<br/>},<br/>methods : {<br/>  printValue () {<br/>    console.log(this.value)<br/>  }<br/>}</span></pre><h2 id="9934" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#multiple-handlers" rel="noopener ugc nofollow" target="_blank">多个处理程序</a></h2><p id="8b52" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">实际上观察者可以被设置为一个<code class="fe lx ly lz ma b">Array</code>。支持的类型有<code class="fe lx ly lz ma b">String</code> | <code class="fe lx ly lz ma b">Function</code> | <code class="fe lx ly lz ma b">Object</code>。当被触发时，注册的观察器处理程序将被逐个调用。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="8039" class="mj kv in ma b gy mk ml l mm mn">watch: {<br/>  value: [<br/>    'printValue',<br/>    function (val, oldVal) {<br/>      console.log(val)<br/>    },<br/>    {<br/>      handler: 'printValue',<br/>      deep: true<br/>    }<br/>  ]<br/>},<br/>methods : {<br/>  printValue () {<br/>    console.log(this.value)<br/>  }<br/>}</span></pre><h2 id="98ec" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#subscribe-to-multiple-variables-mutation" rel="noopener ugc nofollow" target="_blank">订阅多变量突变</a></h2><p id="4489" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><code class="fe lx ly lz ma b">watcher</code>不能监听多个变量，但是我们可以将目标组合在一起作为一个新的<code class="fe lx ly lz ma b">computed</code>并观察这个新的“变量”。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4be6" class="mj kv in ma b gy mk ml l mm mn">computed: {<br/>  multipleValues () {<br/>    return {<br/>      value1: this.value1,<br/>      value2: this.value2,<br/>    }<br/>  }<br/>},<br/>watch: {<br/>  multipleValues (val, oldVal) {<br/>    console.log(val)<br/>  }<br/>}</span></pre><h1 id="b99e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#4-event-argument-event" rel="noopener ugc nofollow" target="_blank"> 4。事件参数:$event </a></h1><p id="0db8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><code class="fe lx ly lz ma b">$event</code>是事件对象的特殊变量。在一些复杂的功能场景中，它提供了更多可选的arugment。</p><h2 id="ef04" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#native-events" rel="noopener ugc nofollow" target="_blank">本土事件</a></h2><p id="3397" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本机事件中，该值与默认事件(DOM事件或窗口事件)相同。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4eec" class="mj kv in ma b gy mk ml l mm mn">&lt;template&gt;<br/>  &lt;input type="text" @input="handleInput('hello', $event)" /&gt;<br/>&lt;/template&gt;</span><span id="6a0a" class="mj kv in ma b gy mo ml l mm mn">&lt;script&gt;<br/>export default {<br/>  methods: {<br/>    handleInput (val, e) {<br/>      console.log(e.target.value) // hello<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><h2 id="0bdd" class="mj kv in bd kw mp mq dn la mr ms dp le kg mt mu li kk mv mw lm ko mx my lq mz bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#custom-events" rel="noopener ugc nofollow" target="_blank">自定义事件</a></h2><p id="ca89" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在自定义事件中，值是从子组件中捕获的内容。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e2eb" class="mj kv in ma b gy mk ml l mm mn">&lt;!-- Child --&gt;<br/>&lt;template&gt;<br/>  &lt;input type="text" @input="$emit('custom-event', 'hello')" /&gt;<br/>&lt;/template&gt;</span><span id="1772" class="mj kv in ma b gy mo ml l mm mn">&lt;!-- Parent --&gt;<br/>&lt;template&gt;<br/>  &lt;Child @custom-event="handleCustomevent" /&gt;<br/>&lt;/template&gt;</span><span id="33dc" class="mj kv in ma b gy mo ml l mm mn">&lt;script&gt;<br/>export default {<br/>  methods: {<br/>    handleCustomevent (value) {<br/>      console.log(value) // hello<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><h1 id="b1f6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#5-router-parameter-decoupling" rel="noopener ugc nofollow" target="_blank"> 5。路由器参数解耦</a></h1><p id="71cf" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我相信大多数人都是这样处理组件中的路由器参数的:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ef6f" class="mj kv in ma b gy mk ml l mm mn">export default {<br/>  methods: {<br/>    getRouteParamsId() {<br/>      return this.$route.params.id<br/>    }<br/>  }<br/>}</span></pre><p id="a738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在组件内部使用<code class="fe lx ly lz ma b">$route</code>将为某个URL生成一个强耦合。这限制了组件的灵活性。</p><p id="d0d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正确的解决方法是将<code class="fe lx ly lz ma b">props</code>加到<code class="fe lx ly lz ma b">Router</code>上。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="02c4" class="mj kv in ma b gy mk ml l mm mn">const router = new VueRouter({<br/>  routes: [{<br/>    path: '/:id',<br/>    component: Component,<br/>    props: true<br/>  }]<br/>})</span></pre><p id="a029" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，组件就可以直接从道具中获得<code class="fe lx ly lz ma b">params</code>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0b1d" class="mj kv in ma b gy mk ml l mm mn">export default {<br/>  props: ['id'],<br/>  methods: {<br/>    getParamsId() {<br/>      return this.id<br/>    }<br/>  }<br/>}</span></pre><p id="5b74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，您还可以传入一个函数来返回用于定制目的的<code class="fe lx ly lz ma b">props</code>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="66a4" class="mj kv in ma b gy mk ml l mm mn">const router = new VueRouter({<br/>  routes: [{<br/>    path: '/:id',<br/>    component: Component,<br/>    props: router =&gt; ({ id: route.query.id })<br/>  }]<br/>})</span></pre><h1 id="192c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#6-two-way-binding-for-custom-components" rel="noopener ugc nofollow" target="_blank"> 6。定制组件的双向绑定</a></h1><blockquote class="na nb nc"><p id="fb7d" class="jv jw nd jx b jy jz ka kb kc kd ke kf ne kh ki kj nf kl km kn ng kp kq kr ks ig bi translated"><em class="in">允许自定义组件自定义与v-model一起使用时使用的道具和事件。默认情况下，组件上的v-model使用value作为属性，使用input作为事件，但是一些输入类型(如复选框和单选按钮)可能希望将value prop用于不同的目的。在这种情况下，使用模型选项可以避免冲突。</em></p></blockquote><p id="ff40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">v-model</code>以双向装订闻名。<code class="fe lx ly lz ma b">input</code>是默认的更新事件。该值可以通过<code class="fe lx ly lz ma b">$emit</code>更新。唯一的限制是组件需要一个<code class="fe lx ly lz ma b">&lt;input&gt;</code>标签来绑定<code class="fe lx ly lz ma b">value</code>属性。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c739" class="mj kv in ma b gy mk ml l mm mn">&lt;my-checkbox v-model="val"&gt;&lt;/my-checkbox&gt;</span><span id="a64c" class="mj kv in ma b gy mo ml l mm mn">&lt;template&gt;<br/>  &lt;input type="checkbox" :value="value" @input="handleInputChange(value)" /&gt;<br/>&lt;/template&gt;</span><span id="23e2" class="mj kv in ma b gy mo ml l mm mn">&lt;script&gt;<br/>export default {<br/>  props: {<br/>    value: {<br/>      type: Boolean,<br/>      default: false<br/>    }<br/>  },<br/>  methods: {<br/>    handleInputChange (val) {<br/>      console.log(val)<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="4173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">双向绑定还有另一个解决方案，那就是<code class="fe lx ly lz ma b">sync</code>修改器。与<code class="fe lx ly lz ma b">v-model</code>不同，它不要求你的组件有一个<code class="fe lx ly lz ma b">&lt;input&gt;</code>标签并将值绑定到它。它只通过事件系统触发<code class="fe lx ly lz ma b">update:&lt;your_prop&gt;</code>使道具变异。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="60f2" class="mj kv in ma b gy mk ml l mm mn">&lt;custom-component :value.sync="value" /&gt;</span></pre><h1 id="f3f9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">7。组件生命周期挂钩</h1><p id="67db" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">通常，您可以像这样监听子组件生命周期(例如<code class="fe lx ly lz ma b">mounted</code></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="07e2" class="mj kv in ma b gy mk ml l mm mn">&lt;!-- Child --&gt;<br/>&lt;script&gt;<br/>export default {<br/>  mounted () {<br/>    this.$emit('onMounted')<br/>  }<br/>}<br/>&lt;/script&gt;</span><span id="9363" class="mj kv in ma b gy mo ml l mm mn">&lt;!-- Parent --&gt;<br/>&lt;template&gt;<br/>  &lt;Child @onMounted="handleOnMounted" /&gt;<br/>&lt;/template&gt;</span></pre><p id="f694" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对此还有另一个简单的解决方案。您可以使用<code class="fe lx ly lz ma b">@hook:mounted</code>来代替。它在Vue内部系统中使用。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="350e" class="mj kv in ma b gy mk ml l mm mn">&lt;!-- Parent --&gt;<br/>&lt;template&gt;<br/>  &lt;Child @hook:mounted="handleOnMounted" /&gt;<br/>&lt;/template&gt;</span></pre><h1 id="b00b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">8。事件监听器API</h1><p id="e278" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">例如，在页面加载时添加一个计时器，但是在销毁时需要清除计时器。这看起来不错。</p><p id="8e8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">坦率地说，<code class="fe lx ly lz ma b">this.timer</code>只有在<code class="fe lx ly lz ma b">beforeDestroy</code>中用于获取定时器id时才有意义。不是刻薄，而是你的反应变量越少，你的表现就越好。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="f3d1" class="mj kv in ma b gy mk ml l mm mn">export default {<br/>  data () {<br/>    return {<br/>      timer: null<br/>    }<br/>  },<br/>  mounted () {<br/>    this.timer = setInterval(() =&gt; {<br/>      console.log(Date.now())<br/>    }, 1000)<br/>  },<br/>  beforeDestroy () {<br/>    clearInterval(this.timer)<br/>  }<br/>}</span></pre><p id="53e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使它只能在生命周期挂钩中访问。用<code class="fe lx ly lz ma b">$once</code>放下不必要的东西。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6aa9" class="mj kv in ma b gy mk ml l mm mn">export default {<br/>  mounted () {<br/>    let timer = null</span><span id="af62" class="mj kv in ma b gy mo ml l mm mn">    timer = setInterval(() =&gt; {<br/>      console.log(Date.now())<br/>    }, 1000)</span><span id="925a" class="mj kv in ma b gy mo ml l mm mn">    this.$once('hook:beforeDestroy', () =&gt; {<br/>      clearInterval(timer)<br/>    })<br/>  }<br/>}</span></pre><h1 id="39e1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#9-mount-components-programmatically" rel="noopener ugc nofollow" target="_blank"> 9。以编程方式安装组件</a></h1><p id="606f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在某些场景中，以编程方式加载组件要优雅得多。例如，可以通过全局上下文<code class="fe lx ly lz ma b">$popup()</code>或<code class="fe lx ly lz ma b">$modal.open()</code>打开弹出窗口或模态。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="67ab" class="mj kv in ma b gy mk ml l mm mn">import Vue from 'vue'<br/>import Popup from './popup'</span><span id="cc50" class="mj kv in ma b gy mo ml l mm mn">const PopupCtor = Vue.extend(Popup)</span><span id="3243" class="mj kv in ma b gy mo ml l mm mn">const PopupIns = new PopupCtr()</span><span id="86df" class="mj kv in ma b gy mo ml l mm mn">PopupIns.$mount()</span><span id="70d7" class="mj kv in ma b gy mo ml l mm mn">document.body.append(PopupIns.$el)</span><span id="aa80" class="mj kv in ma b gy mo ml l mm mn">Vue.prototype.$popup = Vue.$popup = function () {<br/>  PopupIns.open()<br/>}</span></pre><p id="791a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js" rel="noopener ugc nofollow" target="_blank">元素UI </a>实现了一个结构良好的模态组件，允许使用自定义API来控制实例的生命周期。这个理论和我上面演示的非常相似。</p><p id="3049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是关于Vue 2.x的9个技巧。希望通过这篇文章，你能对使用这个框架有一个更好的认识。如果你觉得这篇文章很棒，请分享到其他社交网络上。</p><p id="d23b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读！</p><h1 id="1e25" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kt" href="https://pitayan.com/posts/vue-techniques/#references" rel="noopener ugc nofollow" target="_blank">参考文献</a></h1><ul class=""><li id="8b3b" class="nh ni in jx b jy ls kc lt kg nj kk nk ko nl ks nm nn no np bi translated"><a class="ae kt" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank">https://vuejs.org</a></li><li id="82e3" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae kt" href="https://www.digitalocean.com/community/tutorials/vuejs-add-v-model-support" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/vue js-add-v-model-support</a></li><li id="e501" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae kt" href="https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements" rel="noopener ugc nofollow" target="_blank">https://vue-loader . vue js . org/guide/scoped-CSS . html # child-component-root-elements</a></li></ul></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="1318" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原载于<a class="ae kt" href="https://pitayan.com" rel="noopener ugc nofollow" target="_blank">pitayan.com</a></p><div class="oc od gp gr oe of"><a href="https://pitayan.com/posts/vue-techniques/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">这9个Vue技巧你都掌握了吗？-皮塔扬</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">现在Vue.js已经成为前端开发的热门框架。有很多工程师在利用这种便利…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pitayan.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jt of"/></div></div></a></div></div></div>    
</body>
</html>