<html>
<head>
<title>When Python old style string formatting is best practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 旧式字符串格式何时是最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/when-python-old-style-string-formatting-is-best-practice-691a0759b37e?source=collection_archive---------3-----------------------#2022-08-01">https://blog.devgenius.io/when-python-old-style-string-formatting-is-best-practice-691a0759b37e?source=collection_archive---------3-----------------------#2022-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c986dd5a903ad6f8392ac8da0680911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMDcYHa9r_4d5mfPXaP5oA.png"/></div></div></figure><p id="8d9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Python 2 中的字符串格式利用了% modulo 运算符。Python 3 于 2008 年发布，它包含了格式化字符串的替代方法:<code class="fe kt ku kv kw b"><a class="ae kx" href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="noopener ugc nofollow" target="_blank">str.format()</a></code>。快进到 2016 年，Python 3.6 <a class="ae kx" href="https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals" rel="noopener ugc nofollow" target="_blank">格式的字符串文字</a>(或 f 字符串)发布了。</p><p id="14e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说<code class="fe kt ku kv kw b">str.format</code>和 f 字符串并不<em class="ky">总是</em>优于旧风格，这看起来像是破坏传统，但是 Python 文档本身说旧风格在像日志记录这样的情况下会更好。这篇博文将解释为什么在日志记录时不应该使用新的字符串格式。</p><h1 id="9fb3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">何时使用新的字符串格式覆盖旧的格式</h1><p id="9ad0" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">大多数人认为 f 字符串比%操作符更方便，也更容易阅读。它们也更加灵活，可用于将 Python 表达式插入字符串。</p><p id="1210" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如 python 的禅宗所说:可读性很重要。Python 新的字符串格式化工具是提高可读性的好方法。该语法与现有的字符串格式语法非常相似，但也有一些本质区别:</p><pre class="mc md me mf gt mg kw mh mi aw mj bi"><span id="f124" class="mk la in kw b gy ml mm l mn mo"># old style. like <a class="ae kx" href="https://en.wikipedia.org/wiki/Printf_format_string" rel="noopener ugc nofollow" target="_blank">printf</a> in C<br/>print("Hello, %s!" % "world")<br/>print("The answer is %d" % 42)<br/>print("%f + %" = %" % (1, 2, 3))</span></pre><p id="6d7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还可以使用 format()方法来格式化字符串。这提供了更灵活的语法，并允许使用<a class="ae kx" href="https://docs.python.org/3/library/string.html#formatstrings" rel="noopener ugc nofollow" target="_blank">格式规范</a>:</p><pre class="mc md me mf gt mg kw mh mi aw mj bi"><span id="09ed" class="mk la in kw b gy ml mm l mn mo">print("Hello, {0}!".format("world"))<br/>print("The answer is {0}".format(42))<br/>print("{0} + {1} = {2}".format(1, 2, 3)</span></pre><p id="7ade" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模板字符串允许您将 python 代码直接嵌入到字符串中，这对于复杂的格式化任务非常有用:</p><pre class="mc md me mf gt mg kw mh mi aw mj bi"><span id="eee2" class="mk la in kw b gy ml mm l mn mo">import datetime<br/>t = datetime.date(2016, 1, 1)<br/>print("Today is {t.day}/{t.month}/{t.year}".format(t=t))</span></pre><p id="60c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">新的字符串格式化方法有几个优点:</p><ul class=""><li id="c401" class="mp mq in jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">它更灵活，更容易使用。</li><li id="29d2" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">它支持命名参数，这可以使代码更容易阅读。</li><li id="1943" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">它支持复杂的对象(比如列表和字典)，而旧的% operator 方法不支持。</li></ul><p id="006a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当处理遗留代码时，旧的% operator 方法可能更好，因为持续的坏比不一致的好更好，或者(想想就不寒而栗)一个仍然支持 Python 2.7 的库。但是一般来说，最好尽可能使用新的字符串格式化方法。</p><h1 id="8ac5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为了保护旧的字符串格式</h1><p id="5e24" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">根据<a class="ae kx" href="https://docs.python.org/3/howto/logging.html#optimization" rel="noopener ugc nofollow" target="_blank"> Python 日志文档</a>，旧样式的格式化字符串可能更好。</p><h1 id="11bf" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在 Python 3 中登录</h1><p id="0fa2" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">Python 的日志模块为从 Python 程序发出日志消息提供了一个强大而灵活的平台。这个字符串优化的关键是:<em class="ky">根据日志配置，不是每个日志记录器调用都被发送到日志中。</em></p><p id="f795" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">配置日志记录最简单的方法是调用<code class="fe kt ku kv kw b">basicConfig()</code>。这将使用一组默认参数来配置日志模块。一旦配置了日志模块，您就可以使用各种日志函数来发出日志消息。最常用的日志功能有<code class="fe kt ku kv kw b">debug</code>、<code class="fe kt ku kv kw b">info</code>、<code class="fe kt ku kv kw b">warning</code>、<code class="fe kt ku kv kw b">error</code>和<code class="fe kt ku kv kw b">exception</code>。每个函数都接受一个字符串参数，该参数可能会被发送到日志中(同样，这取决于配置)。</p><p id="681e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">debug</code>函数用于调试在开发代码时帮助开发人员的消息，而<code class="fe kt ku kv kw b">info</code>函数用于帮助开发人员理解代码在生产中如何运行的消息。<code class="fe kt ku kv kw b">warning</code>、<code class="fe kt ku kv kw b">error</code>和<code class="fe kt ku kv kw b">exception</code>功能用于记录严重程度不断增加的问题。</p><p id="9d45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些函数都带有可选的第二个参数，这是一个附加信息的字典，它将与消息一起被记录。</p><h1 id="e0a2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">记录时新旧对比</h1><p id="aded" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated"><a class="ae kx" href="https://docs.python.org/3/howto/logging.html#optimization" rel="noopener ugc nofollow" target="_blank">记录模块文档</a>指出 f 字符串不是最佳的，因为正如记录文档所述:</p><blockquote class="nd ne nf"><p id="5568" class="jv jw ky jx b jy jz ka kb kc kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ks ig bi translated">消息参数的格式化被推迟，直到无法避免</p></blockquote><p id="2dcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了优化，该模块倾向于尽可能晚地对记录的字符串进行评估。举几个例子:</p><pre class="mc md me mf gt mg kw mh mi aw mj bi"><span id="d498" class="mk la in kw b gy ml mm l mn mo">logger.debug("encountered %s", foo)  # old style</span></pre><p id="9cc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相对</p><pre class="mc md me mf gt mg kw mh mi aw mj bi"><span id="aba8" class="mk la in kw b gy ml mm l mn mo">logger.debug(f"encountered {foo}")  # f string</span></pre><p id="99bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设日志配置高于 debug(因此<code class="fe kt ku kv kw b">debug</code>调用不会发送到日志)。在第一个版本中，不会计算最终的字符串(因为日志处理程序会忽略调试日志调用)，而在第二个版本中，会立即计算字符串。正如医生所说:</p><blockquote class="nd ne nf"><p id="ac0d" class="jv jw ky jx b jy jz ka kb kc kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ks ig bi translated">如果记录器将丢弃您的事件，您可能希望避免这样做</p></blockquote><p id="8791" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">日志记录模块建议这样做的原因是，可能存在评估字符串是资源密集型的情况:也许<code class="fe kt ku kv kw b">foo</code>表示一个<a class="ae kx" href="https://docs.djangoproject.com/en/4.0/topics/db/queries/#querysets-are-lazy" rel="noopener ugc nofollow" target="_blank"> ORM 延迟评估的 queryset </a>并且评估字符串会强制数据库读取。如果遵守代码会对系统产生负面影响，那将是一种耻辱。如果日志记录降低了应用程序的性能，开发人员就会减少使用它，这将降低他们作为开发人员的性能。</p><h1 id="57f6" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">改进您的代码</h1><p id="2108" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">Code Review Doctor 是一个代码扫描工具，它建议 Python 和 Django 在您的 pull 请求中进行修复:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/24a577d533e9e4896ee4a812727e76af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJlOTEmE1n-Zl21NpBYjPw.png"/></div></div></figure><p id="0fd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">检查你的<a class="ae kx" href="https://github.com/marketplace/django-doctor/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae kx" href="https://marketplace.atlassian.com/apps/1227731/code-review-doctor?tab=overview&amp;hosting=cloud" rel="noopener ugc nofollow" target="_blank"> Bitbucket </a> Pull 请求，<a class="ae kx" href="https://codereview.doctor/" rel="noopener ugc nofollow" target="_blank">在线免费扫描你的整个代码库</a>，或<a class="ae kx" href="https://twitter.com/CodeReviewDr" rel="noopener ugc nofollow" target="_blank">在 Twitter 上关注我们</a>。</p></div></div>    
</body>
</html>