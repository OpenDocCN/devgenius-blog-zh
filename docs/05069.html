<html>
<head>
<title>Avoiding the N+1 Query Problem in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免 Rails 中的 N+1 查询问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/avoiding-the-n-1-query-problem-in-rails-2f571f9e57e5?source=collection_archive---------1-----------------------#2021-06-11">https://blog.devgenius.io/avoiding-the-n-1-query-problem-in-rails-2f571f9e57e5?source=collection_archive---------1-----------------------#2021-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="422a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个非常常见的查询优化案例，它的解决方案也很好看</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f8037e128b0f5eb0ca04ea939cf6753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph_m9KGrsfJPHGwpfXA8nQ.png"/></div></div></figure><p id="004a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">n+1 查询问题是最常见的可伸缩性瓶颈之一。它包括从数据库中获取资源列表，其中包含其他相关资源。这意味着我们可能必须单独查询相关的资源。因此，如果您有一个 n 个父对象的列表，<em class="ln">将不得不执行另外 n 个查询来获取相关的资源</em>。让我们试着摆脱这个 O(n)难题。</p><p id="1e72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你熟悉 Rails、<a class="ae lo" href="https://github.com/rails-api/active_model_serializers" rel="noopener ugc nofollow" target="_blank">主动模型序列化器</a>，并且已经对我们的问题有了很好的想法，那么也许你可以在这里直接进入代码<a class="ae lo" href="https://gist.github.com/UsamaAshraf/95b0c8d0d64ee193148342a931c0a423" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="9a7d" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">具体的例子</h2><p id="ca6d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">假设您正在 GET 端点获取一个由<strong class="kt ir"> Post </strong>对象组成的数组。您还希望加载帖子的各自作者，在每个帖子对象中嵌入一个<strong class="kt ir"> author </strong>对象。这里有一个简单的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8ac1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于正在呈现的 n 个<strong class="kt ir"> Post </strong>对象中的每一个，将运行一个查询来获取相应的<strong class="kt ir">用户</strong>对象。因此，我们将总共运行 n+1 个查询。这是灾难性的。下面是如何通过急切加载<strong class="kt ir">用户</strong>对象来解决这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="86eb" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">当简单连接不可能时</h2><p id="600d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">到目前为止，对于有经验的人来说没有什么新鲜的。</p><p id="1e87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是让我们把这个复杂化。<em class="ln">让我们假设网站的用户没有和帖子存储在同一个 RDMS。相反，用户是存储在 MongoDB 中的文档(不管出于什么原因)。</em>我们如何修改我们的<strong class="kt ir"> Post </strong>序列化程序来获取用户的信息？这将回到起点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="732f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的用户现在驻留在 Mongo 数据库中的困境可以用调用第三方 HTTP 服务来获取用户或将用户存储在完全不同的 RDMS 中来代替。我们的基本问题仍然是没有办法将用户数据存储与 posts 表“连接”起来，并在单个查询中获得我们想要的响应。</p><p id="d81e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我们可以做得更好。我们可以通过两个查询获取完整的响应:</p><ul class=""><li id="bb25" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">获取所有没有<strong class="kt ir">作者</strong>属性的文章(1 个 SQL 查询)。</li><li id="ab50" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">通过运行一个 where-in 查询来获取所有相应的作者，其中用户 id 是从帖子数组中提取的(1 个 Mongo 查询，带有一个 in 子句)。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="6ef7" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">输入批处理加载器</h2><p id="b263" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">所以我们原来的优化问题已经简化为“我们如何使这个代码可读和可维护”。宇宙<a class="ae lo" href="https://www.universe.com/about" rel="noopener ugc nofollow" target="_blank">的人们已经想出了一个漂亮的宝石。Batch Loader </a>对我的帮助非常大。</p><p id="c939" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nd ne nf ng b">gem 'batch-loader'</code></p><p id="7338" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nd ne nf ng b">bundle install</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8f26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你熟悉 JavaScript 承诺，可以把<code class="fe nd ne nf ng b">get_author_lazily</code>方法看作是返回一个稍后被评估的承诺。我认为这是一个很好的类比，因为<code class="fe nd ne nf ng b">BatchLoader </code>使用了<a class="ae lo" href="https://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-lazy" rel="noopener ugc nofollow" target="_blank">惰性 Ruby 对象</a>。默认情况下，<code class="fe nd ne nf ng b">BatchLoader</code>缓存加载的值，因此为了保持响应是最新的，您应该将它添加到您的<code class="fe nd ne nf ng b">config/application.rb</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="73c5" class="lp lq iq ng b gy nl nm l nn no">config.middleware.use BatchLoader::Middleware</span></pre><p id="85e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！我们已经解决了 n+1 查询问题的高级版本，同时保持了代码的整洁，并以正确的方式使用了主动模型序列化器。</p><h2 id="94f6" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">对嵌套资源使用 AMS</h2><p id="36c7" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">但有一个问题。如果你有一个<strong class="kt ir">用户</strong>序列化器(主动模型序列化器也可以和 Mongoid 一起工作)，那么<em class="ln">不会被延迟加载的<strong class="kt ir">作者</strong>对象调用，不像以前那样。为了解决这个问题，我们可以使用一个 Ruby 块<strong class="kt ir"> </strong>并在将<strong class="kt ir">作者</strong>对象“分配”到帖子之前序列化它们。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="946f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是全部代码。尽情享受吧！</p><h1 id="bbdc" class="np lq iq bd lr nq nr ns lu nt nu nv lx jw nw jx ma jz nx ka md kc ny kd mg nz bi translated">资源</h1><p id="a75b" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated"><a class="ae lo" href="https://github.com/rails-api/active_model_serializers" rel="noopener ugc nofollow" target="_blank">https://github.com/rails-api/active_model_serializers</a></p><p id="9de9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://gist.github.com/UsamaAshraf/95b0c8d0d64ee193148342a931c0a423" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/UsamaAshraf/95 b 0 c 8d 0d 64 ee 193148342 a 931 c0a 423</a></p><p id="dfec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://www.universe.com/about" rel="noopener ugc nofollow" target="_blank">https://www.universe.com/about</a></p><p id="5ea2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://github.com/exAspArk/batch-loader" rel="noopener ugc nofollow" target="_blank">https://github.com/exAspArk/batch-loader</a></p></div></div>    
</body>
</html>