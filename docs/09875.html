<html>
<head>
<title>Timeout for arbitrary routines in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中任意例程的超时</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/timeout-for-arbitrary-routines-in-go-88dc1f52866e?source=collection_archive---------9-----------------------#2022-09-19">https://blog.devgenius.io/timeout-for-arbitrary-routines-in-go-88dc1f52866e?source=collection_archive---------9-----------------------#2022-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1677" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某些情况下，我们需要从库或外部 API 中调用一些其他已有的函数，用于您正在开发的功能或特性。如果您希望这些调用并发运行，并且对您自己的代码无害，您是如何管理这些调用的？</p><p id="6e40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一下一些关注点和问题。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="fcbf" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">基本并发</h1><p id="4684" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">从基础开始，你有两个你的特性需要的函数，分别需要 5s 和 2s 来执行</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b341" class="mb kq in lx b gy mc md l me mf">func F1() float64 {<br/>   time.Sleep(5 * time.<strong class="lx io">Second</strong>)<br/>   return 80.3<br/>}</span><span id="073f" class="mb kq in lx b gy mg md l me mf">func F2() int {<br/>   time.Sleep(2 * time.<strong class="lx io">Second</strong>)<br/>   return 45<br/>}</span><span id="8b7c" class="mb kq in lx b gy mg md l me mf">func main() {<br/>   //Call ExternalTask1<br/>   //Call ExternalTask2<br/>}</span></pre><p id="69f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要它们并发运行，我们可以通过使用<strong class="jm io"> go </strong>关键字让它们在 goroutine 中运行，因为它们是已存在的外部函数/API(如 RestAPI 或 RPC…)，我们不能保证它们每次都能正确运行，一个常见的问题可能是这些函数花费太长时间返回一些预期值，这导致您自己的特性将被这些函数阻塞。为了避免这种情况，我们使用一个上限超时，如果执行时间超过超时值，我们可以认为是一个失败，并根据您的特性提前返回或放弃。</p><p id="3746" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从简单 go routine 实现开始，创建 2 个 go routine 和 2 个通道来接收结果。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2393" class="mb kq in lx b gy mc md l me mf">func main() {<br/>   r1 := make(chan float64)<br/>   r2 := make(chan int)</span><span id="d843" class="mb kq in lx b gy mg md l me mf">   e, result1, result2 := func() (e error, res1 float64, res2 int) {</span><span id="47ab" class="mb kq in lx b gy mg md l me mf">go func(r chan&lt;- float64) {<br/>         r &lt;- F1()<br/>      }(r1)</span><span id="0a25" class="mb kq in lx b gy mg md l me mf">go func(r chan&lt;- int) {<br/>         r &lt;- F2()<br/>      }(r2)</span><span id="220d" class="mb kq in lx b gy mg md l me mf">      res1 = &lt;-r1<br/>      res2 = &lt;-r2<br/>      return</span><span id="369f" class="mb kq in lx b gy mg md l me mf">   }()</span><span id="5fd7" class="mb kq in lx b gy mg md l me mf">   if e != nil {<br/>      fmt.Println(e)<br/>   }<br/>   fmt.Printf("Got %f and %d\n", result1, result2)<br/>}</span></pre><p id="4fb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最好的情况下，您将获得良好的输出结果</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2a78" class="mb kq in lx b gy mc md l me mf">Got 80.300000 and 45</span></pre><p id="6ad5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码有什么问题？<br/>这里<br/> res1 = &lt; -r1 <br/>从通道接收基本上会被阻塞，直到有发送者向通道推送某些东西，反之亦然。因此，即使 F2 只需要 2 秒来完成他们的工作，但 F2 的结果从来不会很快出来，因为它被等待 F1 的结果所阻挡。在代码中添加一些日志来证明这一点</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9004" class="mb kq in lx b gy mc md l me mf">func main() {</span><span id="dcdd" class="mb kq in lx b gy mg md l me mf">   r1 := make(chan float64)<br/>   r2 := make(chan int)</span><span id="f693" class="mb kq in lx b gy mg md l me mf">   e, result1, result2 := func(wg *sync.WaitGroup) (e error, res1 float64, res2 int) {<br/>      log.Print("Start")</span><span id="f6cc" class="mb kq in lx b gy mg md l me mf">go func(r chan&lt;- float64) {<br/>         r &lt;- F1()<br/>         log.Print("Finish F1")<br/>      }(r1)<br/>      go func(r chan&lt;- int) {<br/>         r &lt;- F2()<br/>         log.Print("Finish F2")<br/>      }(r2)</span><span id="7bc8" class="mb kq in lx b gy mg md l me mf">      res1 = &lt;-r1<br/>      log.Print("Received from F1")<br/>      res2 = &lt;-r2<br/>      log.Print("Received from F2")<br/>      return</span><span id="325e" class="mb kq in lx b gy mg md l me mf">   }(&amp;wg)</span><span id="2423" class="mb kq in lx b gy mg md l me mf">   if e != nil {<br/>      fmt.Println(e)<br/>   }<br/>   log.Printf("Got %f and %d\n", result1, result2)<br/>}</span></pre><p id="2742" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">得到</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="07c9" class="mb kq in lx b gy mc md l me mf">2022/09/19 08:33:59 Start<br/>2022/09/19 08:34:04 Finish F1<br/>2022/09/19 08:34:04 Received from F1<br/>2022/09/19 08:34:04 Received from F2<br/>2022/09/19 08:34:04 Got 80.300000 and 45<br/>2022/09/19 08:34:04 Finish F2<br/>Exiting.</span></pre><p id="ef14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们几乎同时并在开始 5s 后收到 F1 和 F2 的结果，这正是 F1 执行所花费的时间。如果 F1 不返回或花太长时间响应，导致 F2 结果不能被正确接收，甚至阻塞我们的功能，这当然会有问题。</p><p id="2a83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">怎样才能同时在多个频道上听而不互相屏蔽？有了它，无论任务完成得多快，它的结果也会被更快地接收到。那就是<strong class="jm io">选择</strong>关键字来玩。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6821" class="mb kq in lx b gy mc md l me mf">A "select" statement chooses which of a set of possible <a class="ae mh" href="https://go.dev/ref/spec#Send_statements" rel="noopener ugc nofollow" target="_blank">send</a> or <a class="ae mh" href="https://go.dev/ref/spec#Receive_operator" rel="noopener ugc nofollow" target="_blank">receive</a> operations will proceed. It looks similar to a <a class="ae mh" href="https://go.dev/ref/spec#Switch_statements" rel="noopener ugc nofollow" target="_blank">"switch"</a> statement but with the cases all referring to communication operations.<br/><a class="ae mh" href="https://go.dev/ref/spec#Select_statements" rel="noopener ugc nofollow" target="_blank">https://go.dev/ref/spec#Select_statements</a></span></pre><p id="2072" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 Golang 规范中可以推断出一些著名的东西:<br/> *它只精确地评估一次，对于更多的评估，我们可以将它放在循环中或使用 continue <br/> *如果一个或多个通道可以继续，那么可以通过统一的伪随机选择<br/>来选择一个可以继续的通道* Select 只有<code class="fe mi mj mk lx b">nil</code>个通道，并且永远没有默认的 case 阻塞(如果我们不够小心，这将是一个严重的问题)</p><p id="05a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好，让我们使用选择</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7f12" class="mb kq in lx b gy mc md l me mf">for i := 0; i &lt; 2; i++ {<br/>   select {<br/>   case res1 = &lt;-r1:<br/>      {<br/>         log.Print("Received from F1")<br/>      }<br/>   case res2 = &lt;-r2:<br/>      {<br/>         log.Print("Received from F2")<br/>      }<br/>   }<br/>}</span></pre><p id="7cf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在输出</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5a92" class="mb kq in lx b gy mc md l me mf">2022/09/19 09:15:23 Start<br/>2022/09/19 09:15:25 Finish F2<br/>2022/09/19 09:15:25 Received from F2<br/>2022/09/19 09:15:28 Finish F1<br/>2022/09/19 09:15:28 Received from F1<br/>2022/09/19 09:15:28 Got 80.300000 and 45<br/>Exiting.</span></pre><p id="c4c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来，我们已经在 F1 结果之前得到了 F2 结果。在这里，我们使用 2 次迭代的循环来从 2 个通道中检索结果，但是如果其中一个通道从不返回结果，我们仍然会遇到阻塞问题。我们将在这篇文章的下一部分解决这个问题。现在，让我们稍微改进一下这个工具。<br/>在现实中，我们不需要预先确定我们能从 goroutines 中得到多少结果，或者有时我们不能，我们能做的另一种方法是，只是倾听它们，直到你的所有任务完成。通过使用 WaitGroup 和一个单独的通道来指示所有任务是否完成，有一种方法可以确定所有任务何时完成。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="d652" class="mb kq in lx b gy mc md l me mf">func main() {</span><span id="3f8d" class="mb kq in lx b gy mg md l me mf">   var wg sync.WaitGroup<br/>   c := make(chan struct{})<br/>   r1 := make(chan float64)<br/>   r2 := make(chan int)<br/>   wg.Add(2)</span><span id="93ae" class="mb kq in lx b gy mg md l me mf">   e, result1, result2 := func(wg *sync.WaitGroup) (e error, res1 float64, res2 int) {<br/>      log.Print("Start")</span><span id="9941" class="mb kq in lx b gy mg md l me mf">      go func() {<br/>         defer close(c)<br/>         wg.Wait()<br/>      }()</span><span id="4c52" class="mb kq in lx b gy mg md l me mf">      go func(wg *sync.WaitGroup, r chan&lt;- float64) {<br/>         defer wg.Done()<br/>         r &lt;- F1()<br/>         log.Print("Finish F1")<br/>      }(wg, r1)</span><span id="42c4" class="mb kq in lx b gy mg md l me mf">      go func(wg *sync.WaitGroup, r chan&lt;- int) {<br/>         defer wg.Done()<br/>         r &lt;- F2()<br/>         log.Print("Finish F2")<br/>      }(wg, r2)</span><span id="e7ed" class="mb kq in lx b gy mg md l me mf">      for {<br/>         select {<br/>         case res1 = &lt;-r1:<br/>            {<br/>               log.Print("Received from F1")<br/>            }<br/>         case res2 = &lt;-r2:<br/>            {<br/>               log.Print("Received from F2")<br/>            }<br/>         case &lt;-c:<br/>            return<br/>         }<br/>      }</span><span id="d226" class="mb kq in lx b gy mg md l me mf">   }(&amp;wg)</span><span id="5ec6" class="mb kq in lx b gy mg md l me mf">   if e != nil {<br/>      fmt.Println(e)<br/>   }<br/>   log.Printf("Got %f and %d\n", result1, result2)<br/>}</span></pre><p id="22df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过向等待组添加 2，我们确保了工作组。Wait()将被阻塞，直到 wg 内部的内部计数器再次达到 0，每次调用 wg。Done()将使计数器减 1。请参阅信号量模式了解这一想法。<br/>当 wg。Wait()完成了它的调用，意味着所有的任务都完成了作业，我们可以简单地关闭通道 c，这样，通道 c 本身就会产生一个事件，并表示选择语句，从而打破无限循环。</p><p id="c162" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果会和以前一样</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b2dd" class="mb kq in lx b gy mc md l me mf">2022/09/19 09:52:57 Start<br/>2022/09/19 09:52:59 Received from F2<br/>2022/09/19 09:52:59 Finish F2<br/>2022/09/19 09:53:02 Received from F1<br/>2022/09/19 09:53:02 Finish F1<br/>2022/09/19 09:53:02 Got 80.300000 and 45<br/>Exiting.</span></pre><p id="a874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一切都好了。如果一个或两个任务都没有使用超时返回，我们将继续修复该问题。</p><h1 id="8813" class="kp kq in bd kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm bi translated">添加超时</h1><p id="f90d" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">添加超时非常简单，time pkg 支持 us 函数，为此，这将返回一个通道，事件将在某个时间后发送到该通道，这里我设置为 3 秒。剩下的工作就是等待这一事件的到来。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6be5" class="mb kq in lx b gy mc md l me mf">func main() {<br/>   timeout := 3 * time.<strong class="lx io">Second<br/>   </strong>var wg sync.WaitGroup<br/>   c := make(chan struct{})<br/>   r1 := make(chan float64)<br/>   r2 := make(chan int)<br/>   wg.Add(2)</span><span id="74d2" class="mb kq in lx b gy mg md l me mf">   e, result1, result2 := func(wg *sync.WaitGroup, timeout time.Duration) (e error, res1 float64, res2 int) {<br/>      timerT := time.After(timeout)<br/>      log.Print("Start")</span><span id="65bc" class="mb kq in lx b gy mg md l me mf">      go func() {<br/>         defer close(c)<br/>         wg.Wait()<br/>      }()</span><span id="ed43" class="mb kq in lx b gy mg md l me mf">      go func(wg *sync.WaitGroup, r chan&lt;- float64) {<br/>         defer wg.Done()<br/>         r &lt;- F1()<br/>         log.Print("Finish F1")<br/>      }(wg, r1)</span><span id="f4d0" class="mb kq in lx b gy mg md l me mf">      go func(wg *sync.WaitGroup, r chan&lt;- int) {<br/>         defer wg.Done()<br/>         r &lt;- F2()<br/>         log.Print("Finish F2")<br/>      }(wg, r2)</span><span id="08d7" class="mb kq in lx b gy mg md l me mf">      for {<br/>         select {<br/>         case res1 = &lt;-r1:<br/>            {<br/>               log.Print("Received from F1")<br/>            }<br/>         case res2 = &lt;-r2:<br/>            {<br/>               log.Print("Received from F2")<br/>            }<br/>         case &lt;-c:<br/>            return<br/>         case &lt;-timerT:<br/>            {<br/>               e = errors.New("Got Timeout")<br/>               return<br/>            }</span><span id="0cc9" class="mb kq in lx b gy mg md l me mf">         }<br/>      }</span><span id="09e9" class="mb kq in lx b gy mg md l me mf">   }(&amp;wg, timeout)</span><span id="ca76" class="mb kq in lx b gy mg md l me mf">   if e != nil {<br/>      log.Println(e)<br/>   }<br/>   log.Printf("Got %f and %d\n", result1, result2)<br/>}</span></pre><p id="a121" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">得到</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a31c" class="mb kq in lx b gy mc md l me mf">2022/09/19 12:10:08 Start<br/>2022/09/19 12:10:10 Received from F2<br/>2022/09/19 12:10:10 Finish F2<br/>2022/09/19 12:10:11 Got Timeout<br/>2022/09/19 12:10:11 Got 0.000000 and 45</span></pre><p id="9bdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">听起来不错，对吧？我们在 3s 后超时，只收到 F2 的结果。</p><h1 id="de0d" class="kp kq in bd kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm bi translated">但是呢？</h1><p id="7496" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这是我们从一开始就想达到的预期结果，现在已经完成了。我们在提交代码和部署后关闭票证。<br/>还有撞！有一天你的应用程序在没有明确原因的情况下崩溃了，为什么？<br/>我们正在泄漏资源内存，并且随着时间的推移而增加。这是一个很难解决的问题，尤其是你离开了:D 公司</p><p id="02d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，首先添加一些调试看看这里</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="96f1" class="mb kq in lx b gy mc md l me mf">func main() {<br/>   ...</span><span id="8a21" class="mb kq in lx b gy mg md l me mf">   log.Println("Number of goroutine: ", runtime.NumGoroutine())<br/>   for {<br/>      select {<br/>         ...<br/>      }<br/>   }<br/>   ...</span><span id="f6e2" class="mb kq in lx b gy mg md l me mf">   log.Printf("Got %f and %d\n", result1, result2)<br/>   log.Println("Number of goroutine: ", runtime.NumGoroutine())<br/>   time.Sleep(6 * time.<strong class="lx io">Second</strong>)<br/>   log.Println("Number of goroutine: ", runtime.NumGoroutine())<br/>}</span></pre><p id="34e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查我们创建的 goroutine 的数量以及完成后它们的情况</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f5c0" class="mb kq in lx b gy mc md l me mf">2022/09/19 12:24:01 Start<br/>2022/09/19 12:24:01 Number of goroutine:  4<br/>2022/09/19 12:24:03 Received from F2<br/>2022/09/19 12:24:03 Finish F2<br/>2022/09/19 12:24:04 Got Timeout<br/>2022/09/19 12:24:04 Got 0.000000 and 45<br/>2022/09/19 12:24:04 Number of goroutine:  3<br/>2022/09/19 12:24:10 Number of goroutine:  3<br/>Exiting.</span></pre><p id="fc11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，实际上我们的应用程序不会像 main func 那样退出。<br/>我们看到，即使在中断上面的选择循环后再等待 6 秒钟，仍有 3 个 goroutines 存在。<br/>让我们来识别这 4 种 goroutines 是什么？它们是 Main、F1、F2 和等待<br/>当超时到达时，当然 F1 完成并退出。所以我们还有 Main，F1，等等。忽略主 goroutine，因为我们知道它还在运行。但是 F1 怎么样，等等</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="86a3" class="mb kq in lx b gy mc md l me mf">go func() {<br/>   defer close(c)<br/>   wg.Wait()<br/>}()</span><span id="1d5c" class="mb kq in lx b gy mg md l me mf">go func(wg *sync.WaitGroup, r chan&lt;- float64) {<br/>   defer wg.Done()<br/>   r &lt;- F1()<br/>   log.Print("Finish F1")<br/>}(wg, r1)</span></pre><p id="6277" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到等待，因为工作组。Wait()将被阻止，直到 wg。在 F1 中完成调用，但为什么即使在 6s 后，F1 仍然不调用它。<br/>原因是 F1 试图将其结果发送到 r 通道，但没有其他人监听它，因为由于超时，我们退出了下面的 select 语句，这将被永远阻止。当超时到达时，我们仍然退出循环，如何解决这个问题？有一个非常简单的修复方法，就是让通道 r 成为缓冲通道，这样可以避免在通道资源未达到限制时阻塞写操作。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c0f1" class="mb kq in lx b gy mc md l me mf">var wg sync.WaitGroup<br/>c := make(chan struct{}, 1)<br/>r1 := make(chan float64, 1)<br/>r2 := make(chan int, 1)<br/>wg.Add(2)</span></pre><p id="3e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次运行，我们看到 F1 可以结束，goroutine 的数量为 1 (Main)</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="76d3" class="mb kq in lx b gy mc md l me mf">2022/09/19 12:54:57 Start<br/>2022/09/19 12:54:57 Number of goroutine:  4<br/>2022/09/19 12:54:59 Finish F2<br/>2022/09/19 12:54:59 Received from F2<br/>2022/09/19 12:55:00 Got Timeout<br/>2022/09/19 12:55:00 Got 0.000000 and 45<br/>2022/09/19 12:55:00 Number of goroutine:  3<br/>2022/09/19 12:55:02 Finish F1<br/>2022/09/19 12:55:04 Number of goroutine:  1</span></pre><p id="8206" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的代码在这里:【https://goplay.tools/snippet/Sm_vBastiKI T2】</p><p id="9d00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码快乐！</p></div></div>    
</body>
</html>