<html>
<head>
<title>Implementing Vector Autoregression (VAR) from Scratch with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python从头开始实现向量自回归(VAR)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-vector-autoregression-from-scratch-with-python-b12eedbf35ad?source=collection_archive---------0-----------------------#2021-12-31">https://blog.devgenius.io/implementing-vector-autoregression-from-scratch-with-python-b12eedbf35ad?source=collection_archive---------0-----------------------#2021-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="eb12" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过从头开始构建来了解VAR</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/53dd5d63dfb44408706a39cc5b5faee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-HQDjvH1nCwfR5seQ2aReA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">多元时间序列</figcaption></figure><h1 id="43bb" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">增值转销公司</h1><p id="b954" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">当谈到时间序列分析和预测时，有许多模型和算法可供选择。时间序列领域的基本模型之一是<em class="mg">向量自回归</em> (VAR)，这是我们所知的大多数多元时间序列模型的最简单版本。本文旨在通过用Python编写代码来解释VAR的核心。我会假设你熟悉获取线性回归的估计参数，主要是正态方程。我还假设你熟悉时间序列的特征(即时间序列中的滞后)。</p><p id="9a5a" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">首先，一个<em class="mg"> N </em>变量的VAR模型就是堆叠成1的<em class="mg"> N </em>线性回归模型。这些<em class="mg"> N </em>线性回归使用相同的设计矩阵(简化:相同的预测数据)并将其用于<em class="mg"> N </em>不同的时间序列。预测器数据是先前时间点或滞后的那些<em class="mg"> N </em>时间序列。因此，VAR模型的估计参数就是所有线性回归的估计参数。如果你知道线性回归是如何工作的，你应该不难理解这些内容。</p><h1 id="585a" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">预处理</h1><p id="1b51" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">让我们从我们的图书馆开始。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="759d" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">仅此而已。我们希望创建一个没有外部库的VAR模型。</p><p id="fd1f" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">接下来，我们加载数据。我使用的数据是澳大利亚维多利亚州的电价和需求。它在<a class="ae mo" href="https://aemo.com.au/energy-systems/electricity/national-electricity-market-nem/data-nem/aggregated-data" rel="noopener ugc nofollow" target="_blank"> AEMO网站</a>上公开发布。为了简单起见，我更改了列名，以便用户更容易阅读。你可以在这里下载我的数据版本<a class="ae mo" href="https://drive.google.com/file/d/1CLfYy4KWbGsMnxPwXtMJdBT4hW1yvI0q/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">，尽管你可以在本教程中使用任何你自己的数据。下面是我的数据版本的一个片段。请仅为本教程设置索引中的任何时间指示器，或者删除它们。</a></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/16b1e2b25e13526e9c7b467b8baa99b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYetF_gs2cIiqEfHlMf8jA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">第一数据帧输出</figcaption></figure><p id="d942" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我们现在将得到一点技术。在每个时间序列模型中都有一种叫做最优滞后结构的东西。让我举一个例子来说明这一点。假设我们正在预测一个每日时间序列数据，我们希望预测明天的值。为了预测明天，我用了今天的值，昨天的值和前天的值作为预测值。这个模型的滞后结构为3，因为我们使用了3个过去的数据来预测下一个值。</p><p id="69ab" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">每个模型都有一个最优的滞后结构，它最大化(或最小化)一个统计量。一般来说，统计量的选择是在信息准则之间进行的；AIC (Akaike)、SIC (Schwarz)或HQIC (Hannan-Quinn)，但也有其他方法来确定最佳结构。当使用前三个标准时，最佳实践是计算所有标准，并选择“多数规则”滞后，而不管符合哪个标准。在平局的情况下，任意选择将不会显著影响模型。对于那些对数学感兴趣的人，我提供了我提到的判据的公式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/3456c5f1083ee68ff0397ab9146a9577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYex73Z_z9F0hxJUBY-mxw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">信息标准公式</figcaption></figure><p id="67be" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">其中<em class="mg"> L </em> (θ)是<em class="mg">K</em>-变量VAR模型的似然，<em class="mg"> N </em>是样本量，<em class="mg"> p </em>是估计参数的个数。这个过程可能看起来很复杂，但是Python有针对这个特定任务的库，即<em class="mg"> statsmodel </em>。如果你对滞后结构不是很了解，也不用担心。为了这篇文章，我将选择一个任意的滞后100。</p><p id="0990" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">为了将滞后作为特征，我们将遍历每个特征的每个滞后。方法<code class="fe mr ms mt mu b">df[col].shift(i)</code>是获取任何特征的第<em class="mg">I</em>th lag的便捷方法。如果您很细心，您可能会注意到这个策略会在前100行中产生NaN值。我们不会为此担心，只需删除前100行。注意，每次我提到100，这指的是你的最优滞后结构。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/0c7167468b20ce4ee6178fcfef9d4e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxpa0yKpsePhllWt5uoeyg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">生成的数据框的片段。你也可以用这幅图来理解什么是滞后。</figcaption></figure><p id="1120" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">下一步是获取原始的滞后零数据(在这种情况下，列<code class="fe mr ms mt mu b">Price</code>和<code class="fe mr ms mt mu b">Demand</code>)，将它们存储在其他地方，并从数据框中删除它们。这是因为这些原始数据是预测变量，在数据中用它们来训练模型是没有意义的。</p><p id="a1de" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我们还应该在数据帧的第一个条目上添加一个截取列。用统计学术语来说，截距是用来调整预测偏差的。但是你需要知道的是，在每个回归模型中，我们需要一个截距，因此这里有一个截距。将截距放在第一列只是惯例。</p><p id="ac56" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">最后一步是将数据转换成矩阵。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="5124" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">模特培训</h1><p id="38c3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">这就是我们回归的地方。如果你还记得，我提到过一个<em class="mg"> N </em>变量VAR模型就是简单的<em class="mg"> N </em>个同时线性回归。在我们的例子中，时间序列是二元的(或二元的)；因此，VAR模型只是两个线性回归。</p><p id="94a1" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">求解线性回归就是获得每个变量的参数估计，通常表示为<em class="mg">β</em>-矩阵。如果我们已经准备好预测器和预测矩阵，找到<em class="mg"> β </em>矩阵将会很简单。在我们的代码中，预测矩阵是变量<code class="fe mr ms mt mu b">X</code>，预测矩阵是<code class="fe mr ms mt mu b">y_price</code>和<code class="fe mr ms mt mu b">y_demand</code>。</p><p id="2d8b" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">为了获得估计的<em class="mg">β</em>-矩阵，我们需要做一系列的矩阵乘法。主要是法线方程，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1ebb903d65726c10734edc058d5ecc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*hHZtRjHnUuQmblYv75BqDA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">正规方程</figcaption></figure><p id="44f9" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这里，<em class="mg"> X </em>指预测矩阵<code class="fe mr ms mt mu b">X</code>，<em class="mg"> y </em>指预测矩阵<code class="fe mr ms mt mu b">y_price</code>和<code class="fe mr ms mt mu b">y_demand</code>。使用<em class="mg"> Numpy </em>可以简化Python中的矩阵乘法。我将给出一些Python中矩阵操作的命令，这些命令对我们的目的很有用，</p><ul class=""><li id="461f" class="mx my in lm b ln mh lq mi lt mz lx na mb nb mf nc nd ne nf bi translated">设<code class="fe mr ms mt mu b">A</code>和<code class="fe mr ms mt mu b">B</code>为<em class="mg"> Numpy </em>矩阵。</li><li id="a397" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><code class="fe mr ms mt mu b">np.matmul(A, B)</code>用于将矩阵<code class="fe mr ms mt mu b">A</code>和矩阵<code class="fe mr ms mt mu b">B</code>相乘。请注意，由于矩阵乘法的性质，<code class="fe mr ms mt mu b">np.matmul(B, A)</code>将产生不同的结果。</li><li id="5fd7" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><code class="fe mr ms mt mu b">A.T</code>用于获得矩阵<code class="fe mr ms mt mu b">A</code>的转置。</li><li id="e35b" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><code class="fe mr ms mt mu b">np.linalg.inv(A)</code>用于获得矩阵的逆矩阵<code class="fe mr ms mt mu b">A</code>。</li></ul><p id="8a3d" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">让我们创建一个函数来从正规方程中获得参数估计。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="17d0" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">就这么简单，我们已经在这几行代码中获得了回归参数(和VAR参数)。这就结束了模型的训练。存储在<code class="fe mr ms mt mu b">b_price</code>和<code class="fe mr ms mt mu b">b_demand</code>中的参数估计值。我们现在可以用它来做预测。</p><h1 id="b0a5" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">预测</h1><p id="3bd0" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">让我们继续预测过程。在时间序列预测中，有两种类型的预测。</p><ul class=""><li id="92c6" class="mx my in lm b ln mh lq mi lt mz lx na mb nb mf nc nd ne nf bi translated"><strong class="lm io">事前</strong>:预测目前可用的数据。这意味着在训练数据上测试模型。对模型诊断有用。</li><li id="6d5f" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><strong class="lm io">事后</strong>:利用未来数据进行预测。未来数据是指预测数据。在事后预测中，任何时间<em class="mg"> t </em>的预测数据成为时间<em class="mg"> t + n </em>的预测值。实用的。</li></ul><h2 id="afef" class="nl kt in bd ku nm nn dn ky no np dp lc lt nq nr le lx ns nt lg mb nu nv li nw bi translated">预期的</h2><p id="d4c3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">现在让我们回顾一下回归预测的数学方法。如果已经有了回归的参数估计值，可以通过计算参数估计值和数据的点积来找到预测值。这里有一个简单的解释，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/ca2cac03637b1de0b36b1a9afce9a6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vaxDaYiYxnzu8IfehQouw.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2746" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我们实际上可以将这个过程简化为两行矩阵乘法<code class="fe mr ms mt mu b">price_estimates = np.matmul(X, b_price)</code>和<code class="fe mr ms mt mu b">demand_estimates = np.matmul(X, b_demand)</code>。但是为了更好的理解，我还是决定把它分解一下。</p><p id="efb3" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这就结束了事前预测过程。事前预测有助于模型诊断，我将演示如何计算其中的一些。为了评估VAR模型的性能，我们将使用通常用于评估线性回归模型的统计数据。</p><ul class=""><li id="e326" class="mx my in lm b ln mh lq mi lt mz lx na mb nb mf nc nd ne nf bi translated">r:衡量数据解释了多少差异</li><li id="4f26" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated">MSE:测量误差水平</li><li id="9a16" class="mx my in lm b ln ng lq nh lt ni lx nj mb nk mf nc nd ne nf bi translated">f检验:测量预测值的显著性。</li></ul><p id="f394" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我不会详细解释这些统计数据，但我会为那些对数学感兴趣的人提供公式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/d45080b11c43e75c9d12df7871240373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQCsiHEraHdoMgz_n-EZvg.png"/></div></div></figure><p id="4525" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">让我们做一些诊断。我要把上面的公式复制成Python函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9a53" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">运行<code class="fe mr ms mt mu b">Diagnostics()</code>函数将为我们的数据返回这些输出。</p><p id="e6f3" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">对于价格，</p><p id="e645" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><code class="fe mr ms mt mu b">Diagnostics(y_price, X, b_price, N, p)</code></p><p id="e32b" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">输出:</p><pre class="kd ke kf kg gt nz mu oa ob aw oc bi"><span id="2de7" class="nl kt in mu b gy od oe l of og">The R-squared is: 0.66<br/>The MSE is: 28262.74<br/>The F-statistic is: 686.42</span></pre><p id="7096" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">对于需求，</p><p id="9696" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><code class="fe mr ms mt mu b">Diagnostics(y_demand, X, b_demand, N, p)</code></p><p id="4cd6" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">输出:</p><pre class="kd ke kf kg gt nz mu oa ob aw oc bi"><span id="6a5c" class="nl kt in mu b gy od oe l of og">The R-squared is: 1.0<br/>The MSE is: 3318.01<br/>The F-statistic is: 2517997.46</span></pre><p id="7b62" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">您可以通过计算F统计的调整后R值或p值来进一步研究诊断。还有许多诊断方法可用于回归分析。</p><h2 id="76aa" class="nl kt in bd ku nm nn dn ky no np dp lc lt nq nr le lx ns nt lg mb nu nv li nw bi translated">依据过去经济发展情形分析的</h2><p id="7b27" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">事后预测就是预测未来。要点是，如果<em class="mg"> t </em>表示当前时间点，那么为了预测时间点<em class="mg"> t + n </em>，其中n是大于1的数，我们将需要使用在<em class="mg"> t + n </em>的滞后作为预测器。如果<em class="mg"> n </em>大于1，则在<em class="mg"> t + n </em>处至少有一个滞后在<em class="mg"> t </em>之后。换句话说，<em class="mg"> t + n </em>的一些滞后是未来预测的时间点。观察下表来观想。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="29c8" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">在这里，任何带有星号(*)的条目代表我们在时间<em class="mg"> t </em>没有的数据，因此是预测的。对于大的<em class="mg"> n </em>，我们将所有预测值作为预测值。下面的Python代码显示了事后预测。变量<code class="fe mr ms mt mu b">PointsAhead</code>表示您希望预测多远，您可以根据自己的需求进行更改。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b14b" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">最终预测将存储在<code class="fe mr ms mt mu b">ExPostPrice</code>和<code class="fe mr ms mt mu b">ExPostDemand</code>中。事后预测流程到此结束。因为我们实际上是在预测未来，所以我们不能对我们的预测进行诊断。对事后预测运行诊断的标准解决方案是仅使用到特定时间<em class="mg"> t - n </em>的数据来训练模型，然后从时间<em class="mg"> t - n </em>到时间<em class="mg"> t </em>进行事后预测。然后，您可以对测试集运行诊断，因为这一次，您有了测试集的实际值。</p><h1 id="e16d" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">恭喜</h1><p id="ca4b" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们从始至终只用<em class="mg"> Pandas </em>和<em class="mg"> Numpy </em>成功构建了一个VAR模型。我希望你能用你的数据重建这个模型，最好是用一个3变量的时间序列，只是为了全面的理解。你也可以在<a class="ae mo" href="https://github.com/gerchristko/Vector-Autoregression" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到代码和数据集。如果你喜欢这篇文章，考虑鼓掌。请在评论中分享你的反馈和想法。感谢您的阅读！</p></div></div>    
</body>
</html>