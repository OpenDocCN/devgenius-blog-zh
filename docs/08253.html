<html>
<head>
<title>An Introduction to Caching Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存模式介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-introduction-to-caching-patterns-839111a4a150?source=collection_archive---------6-----------------------#2022-05-30">https://blog.devgenius.io/an-introduction-to-caching-patterns-839111a4a150?source=collection_archive---------6-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="97b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e2c96d9676a21b5e8afc14c6f550343a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DO-0mktgUgbHy7Rpkpka1A.jpeg"/></div></div></figure><p id="d5ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">缓存</strong>是一个软件组件，它存储一个瞬态数据的子集，以便将来对该数据的请求可以得到更快的服务。</p><p id="b01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，它可以被认为是一个高速数据存储层，其主要目的是通过减少访问永久存储器或不必要地重新计算数据的需求来提高应用程序的性能。</p><p id="e469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其理念是，每当处理一个新请求时，该请求的结果都会存储在高速缓存中，以便在同一请求再次运行时可以检索和重用，这最终有助于减少网络开销、CPU 使用量以及总体基础架构成本。</p><h1 id="c335" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">缓存模式</h1><h2 id="ff99" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">备用缓存</h2><p id="9496" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">缓存备用模式是指应用程序第一次从缓存中请求数据的时候。</p><p id="741e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果数据存在于缓存中，则直接发送回应用程序，这一事件称为<strong class="jp ir">缓存命中。</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mn"><img src="../Images/00b23b538c1f681631b5d3abecc5afe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuEHT7S18RLIEhA3yLrCpw.png"/></div></div></figure><p id="53a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，如果数据丢失，该事件被称为<strong class="jp ir">缓存未命中</strong>，应用程序将向数据库发送另一个请求，并将其写入缓存，以便下次可以再次从缓存中检索数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mo"><img src="../Images/b25a1704528e899d8451ca93071d176b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpohwpYHRCPg5YItLOvbHA.png"/></div></div></figure><h2 id="272c" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">通读(延迟加载)</h2><p id="9f10" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">通读或延迟加载模式非常相似，不同之处在于，当发生缓存未命中时，不是应用程序而是缓存本身从数据库中提取数据，并在将数据发送回应用程序之前存储数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/8c912ebf39c5bdd3933131eec74e3a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfyk2skX_SQfOaMUT9KpRA.png"/></div></div></figure><h2 id="e7e6" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">直写</h2><p id="a66d" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">在直写模式的情况下，当应用程序发送要存储的数据时，缓存会捕获数据并将其同步写入内存和数据库。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/d30f75c0b3fc17aacd3d395aa2523926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vv9ZUcpdEdbIvAv_Cja-vA.png"/></div></div></figure><p id="5692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式通常在没有频繁写入的情况下使用，对于数据恢复和一致性非常有帮助，但会带来延迟，因为我们必须写入两个不同的位置。</p><h2 id="fb31" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">写在后面</h2><p id="5340" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">最后，写后缓存模式采用了与直写模式类似的方法，只是对主数据库的写入是异步完成的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/3b3d5d3d78b4c237a9589d2650f4440f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUMNmhyyllf5F7FYtHGWlg.png"/></div></div></figure><p id="5a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是由于存储在缓存中的数据是不稳定的，如果缓存关闭，显然会有数据丢失的风险。</p><p id="a639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但幸运的是，一些先进的缓存解决方案，如 Redis，现在提供了一个故障保险来减少数据丢失。</p><h1 id="d355" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">缓存挑战</h1><p id="f84e" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">尽管缓存是提高系统性能的一种相当简单的方法，就像任何软件解决方案一样，但在实现这种机制时，仍有一些相关的挑战需要认真解决。</p><h2 id="4cbb" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">选择要缓存的数据</h2><p id="9c4a" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">首先要注意的是内存管理。</p><p id="7c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，RAM 空间通常非常有限，如果在同一台机器上运行的多个应用程序之间共享，甚至会更有限，我们真的需要注意不要让大数据太快填满缓存，这自然会导致确定将哪些数据放入缓存。</p><p id="8568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原则上，缓存应该始终准备好存储经常需要的数据，这些数据需要花费大量时间来生成或检索，但不幸的是，识别这些数据不是一项简单的任务，将需要几轮开发，直到找到正确的值来存储。</p><h2 id="ffea" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">维护数据一致性</h2><p id="e5ea" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">第二个挑战是根据我们能够容忍的向用户提供潜在陈旧数据的时间来定义数据应该缓存多长时间，因为实际上，拥有相同数据的两个副本最终会导致它们随着时间的推移而出现差异。</p><p id="10ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须定义最佳的缓存更新或失效机制，以避免由于将损坏或过时的信息存储到数据库中而使系统失去平衡。</p><h2 id="9f54" class="lw kz iq bd la lx ly dn le lz ma dp li jy mb mc lm kc md me lq kg mf mg lu mh bi translated">处理缓存未命中</h2><p id="8d92" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">最后，第三个挑战是保持较低的缓存未命中，因为请求缓存中不可用的数据会增加不必要的请求往返，从而引入延迟，这在不使用缓存的系统中是不会发生的。</p><p id="0189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了充分受益于缓存速度的提高，与缓存命中相比，缓存未命中必须保持尽可能低的水平。</p><h1 id="7a57" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么？</h1><p id="c4ca" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">不要忘记👏🏻x50 如果你喜欢读我的作品！</p><p id="b187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👉你喜欢这种内容？在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《如何使用 Express framework 构建生产就绪的分层认证微服务》一书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">构建分层微服务</strong> </a>，该书从第一行代码到最后一行文档都符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>