<html>
<head>
<title>Explain Message Queue to Grandma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向奶奶解释消息队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/message-queue-what-and-why-230bdf295469?source=collection_archive---------27-----------------------#2020-07-09">https://blog.devgenius.io/message-queue-what-and-why-230bdf295469?source=collection_archive---------27-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释什么是消息队列以及我们为什么使用它的最简单的方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/04903d103d939572f79b090becf267ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IJXLcWF65Qvqi1Qw"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/@ethanhjy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ethan Hu </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="edcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不知道什么是消息队列，我想你可能知道什么是数据结构中的队列。如果你不知道，我想你应该明白上图的人在做什么。</p><h2 id="e336" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">我们的问题是</h2><p id="9c8a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">队列不是一个复杂的术语，它解释了对象在被处理之前必须等待它前面的对象完成。下面是数据结构中的队列:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f4966835c097e4a3e210792ab7dc3b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*_rTJKBKZaz7iWtUyH8U9aA.png"/></div></figure><p id="511e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">消息队列有一个非常相似的功能。生产者将消息发送到队列的尾部，而消费者从队列的头部获取消息。很简单！但是我们为什么在系统设计中使用它呢？</p><h2 id="1097" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">为什么我们使用消息队列？</h2><p id="0f23" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">假设用户 A 为用户 B 和用户 c 生成一个 id，现在我们有一个这样的结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/c470d096f75cbdd08a7d001078d24829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vA7cMFxmrjgU-9s6Oc4KUA.png"/></div></div></figure><p id="824c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以得到下面的伪代码:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="62c4" class="lc ld iq md b gy mh mi l mj mk">public class UserA {      <br/>  UserB userB = new UserB();    <br/>  UserC userC = new UserC();      <br/>  private String userId = "myID";  <br/>  <br/>  public void doSomething() {      <br/>            userB.UserBneed(myID);  <br/>            userC.UserCneed(myID);      <br/>  }<br/>}</span></pre><p id="6553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切看起来都很好！然而，几天后:</p><ul class=""><li id="c442" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">用户 B 告诉 A:“嘿，我不再需要你的 ID 了，你能把它拿掉吗？”。</li><li id="c054" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">用户 D 来告诉 A:“嘿，你能把我包括在你的系统中吗，我需要你的 ID 来做一些事情”</li></ul><p id="1f9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户 A:“好的，我可以做到”。</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="24dc" class="lc ld iq md b gy mh mi l mj mk">public class UserA {      <br/>  UserB userB = new UserB();    <br/>  UserC userC = new UserC();   <br/>  UserD userD = new UserD();  <br/> <br/>  private String userId = "myID";  <br/>  <br/>  public void doSomething() {      <br/>          //  userB.UserBneed(myID);  <br/>            userC.UserCneed(myID);   <br/>            userD.UserDneed(myID);   <br/>  }<br/>}</span></pre><p id="03a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单。嗯，随着时间的推移:</p><ul class=""><li id="1b4f" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">d 说:“你能把我撤了吗？”</li><li id="e257" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">e 说:“可以加我吗？”</li><li id="89da" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">d 说:“可以加我回去吗？”</li><li id="aaf9" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">f 说:“可以加我吗？”</li></ul><p id="549f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎用户 A 必须花费大量时间来添加或删除这些依赖项。</p><p id="5287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这还不是最糟糕的。有一天用户 A 没有把 ID 成功传递给用户 B。与此同时，将 ID 传递给用户 b 要花费非常多的时间。现在，用户 A 必须一个接一个地解决问题。我相信用户 A 除了解决这个问题，还要思考如何逃跑。</p><h2 id="7a72" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">这就是解决方案——消息队列！</h2><p id="f025" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们来解决这个问题。用户 A 意识到我为什么要做你们应该做的工作？然后，他创建了一个消息队列，在这个队列中，他只发送 B 和 C 想要的所有数据。现在 B 和 C 可以在任何需要的时候获取数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/64488632a724b0a2b67d6477d1af884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaIAD_4Mh0_aOrQZPjjW9w.png"/></div></div></figure><p id="55e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过提供这种架构，我们有 4 个好处:</p><ol class=""><li id="b27c" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk na mr ms mt bi translated">用户 A 只是将数据发送到消息队列，并不关心谁使用它。不管用户 D 是否想要数据，这与用户 A 完全没有关系。</li><li id="5112" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk na mr ms mt bi translated">其他用户可以从消息队列中获取数据，而不是等待用户 A 调用他们的 API。通过这样做，即使其他用户无法获取数据或者获取速度很慢，这也不再是用户 A 的工作。</li><li id="97ef" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk na mr ms mt bi translated">需要来自用户 A 的数据的其他用户可以异步获取数据。如果我们没有消息队列，用户 A 必须一个接一个地调用其他用户来发送数据，这将花费更多的时间。因此，消息队列显著提高了请求速度。</li><li id="abfe" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk na mr ms mt bi translated">想象一下，我们有处理请求的服务器，但没有消息队列。如果短时间内请求的数量增加超过了服务器的处理限制，服务器将会关闭。有了消息队列，服务器可以根据自己的能力获取数据，确保不会处理超出限制的请求。</li></ol><h2 id="0839" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">使用消息队列的好处是什么？</h2><ul class=""><li id="45ee" class="ml mm iq jp b jq lv ju lw jy nb kc nc kg nd kk mq mr ms mt bi translated">如果消息队列关闭，整个系统将失去功能。因此，我们必须确保消息队列总是分布式的。如果当前消息队列消失，这将把数据定向到其他健康的消息队列。</li><li id="0358" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">如果消息队列已关闭，队列中的数据将会丢失。复制可以解决这个问题。</li><li id="fb05" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">添加消息队列会使系统更加复杂。一个主要原因是消费者必须从消息队列中获得推送通知，或者定期从队列中轮询数据。</li></ul><h2 id="70d4" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated"><strong class="ak">结论</strong></h2><p id="ac16" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">消息队列无疑是在复杂系统中分离组件的好方法。</p><p id="50a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您花时间阅读这篇文章。如果您有任何建议，请随时发表评论或通过<a class="ae lb" href="https://www.linkedin.com/in/lee-qi/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>