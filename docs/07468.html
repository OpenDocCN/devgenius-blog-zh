<html>
<head>
<title>CS50 Tideman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CS50 Tideman</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cs50-tideman-e1cdafeafcd8?source=collection_archive---------0-----------------------#2022-03-28">https://blog.devgenius.io/cs50-tideman-e1cdafeafcd8?source=collection_archive---------0-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a66ea6780abaac85f99fce3cfa85ce65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-c7jNX8txZVrffsSvB1cg.jpeg"/></div></div></figure><p id="b810" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">伙计，这个问题很难，我在解决它之前写了这个，我想我可以通过写我正在做的事情来更好地理解这个问题，我建议你做一些类似的事情，在某种意义上是给我某种责任，因为现在我必须完成这篇文章。</p><p id="4881" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从第一个名为<code class="fe kt ku kv kw b">vote</code>的函数开始，这个函数有三个参数(rank，name 和 ranks)，所有的数据都是从 main 中第二个嵌套的 for 循环中提取的，<code class="fe kt ku kv kw b">rank</code>是当前被迭代的候选项的索引，<code class="fe kt ku kv kw b">name</code>用户选择的候选项的名称，<code class="fe kt ku kv kw b">ranks</code>用户如何对候选项进行排序，这是我们在这个函数中要解决的问题。</p><p id="f5cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们遍历候选人数组，如果数组中的一个名字与用户输入的名字相同，我们用名字输入的索引更新<code class="fe kt ku kv kw b">ranks</code>数组。例如，如果我们有候选人<code class="fe kt ku kv kw b">Alice Bob Charlie</code>，他们的索引是<code class="fe kt ku kv kw b">[0 1 2]</code>，如果用户投票给<code class="fe kt ku kv kw b">Rank 1: Alice | Rank 2: Charlie | Rank 3: Bob</code>，那么<code class="fe kt ku kv kw b">Ranks</code>数组在第一个投票者之后看起来就像这个<code class="fe kt ku kv kw b">[0 2 1]</code>。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e1a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，<code class="fe kt ku kv kw b">record_preferences</code>函数将填充<code class="fe kt ku kv kw b">preferences</code>数组<code class="fe kt ku kv kw b">preferences[i][j]</code>中候选人的数量，这些候选人更喜欢候选人<code class="fe kt ku kv kw b">i</code>而不是<code class="fe kt ku kv kw b">j</code></p><p id="cd84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个问题的逻辑很让人沮丧，也很难。根据演练视频，首选项数组如下所示:</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="8f35" class="lh li in kw b gy lj lk l ll lm">candidates<br/>Alice Bob Charlie<br/><br/>voter preferences, n candidate is represented by n row<br/>Alice  [0 3 2]<br/>Bob    [2 0 3]<br/>Charlie[1 4 0]<br/>there is one preference array for each candidate</span></pre><p id="d973" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要创建一个嵌套的 for 循环，这是我们开始循环的第二个循环，<code class="fe kt ku kv kw b">i+1</code>，因为我们只需要在<code class="fe kt ku kv kw b">j</code>跟在<code class="fe kt ku kv kw b">i</code>后面时添加到 preferences 数组中。我建议您浏览<code class="fe kt ku kv kw b">debug50</code>来更好地理解这个问题，您可以清楚地看到数字是如何添加到首选项数组中的</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="b38c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我开始讨厌这个问题以前的都很好玩，但是这个 idk 男，不过还是继续用<code class="fe kt ku kv kw b">add_pairs</code>功能吧。这个函数添加到<code class="fe kt ku kv kw b">pairs</code>数组中，该数组由具有一个<code class="fe kt ku kv kw b">winner</code>和一个<code class="fe kt ku kv kw b">loser</code> <code class="fe kt ku kv kw b">int</code>值的<code class="fe kt ku kv kw b">pair</code>结构组成，我们需要更新这个数组，我们还需要更新<code class="fe kt ku kv kw b">pair_count</code>变量。</p><p id="b53e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要与前面的函数相同的嵌套 for 循环，因为我们不想单独比较候选对象，也不想重复检查。</p><p id="88b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们写了一个条件来比较哪个候选人比下一个候选人更受欢迎。如果我们有三个候选人<code class="fe kt ku kv kw b">alice bob char</code>和三个选民，<code class="fe kt ku kv kw b">[i] [j]</code> <code class="fe kt ku kv kw b">[0][1]</code>将是第一个，<code class="fe kt ku kv kw b">[j][i]</code> <code class="fe kt ku kv kw b">[1][0]</code>。将要比较的值是<code class="fe kt ku kv kw b">3 &gt; 0</code>，这里所有三个投票者都更喜欢<code class="fe kt ku kv kw b">candidate[i or 0]</code>而不是<code class="fe kt ku kv kw b">candidate[j or 1]</code>，所以我们将<code class="fe kt ku kv kw b">[i]</code>加到<code class="fe kt ku kv kw b">pairs[0].winner</code>，将<code class="fe kt ku kv kw b">[j]</code>加到<code class="fe kt ku kv kw b">pairs[0].loser</code>，并将下面的<code class="fe kt ku kv kw b">pair_count</code>加 1，这是我们用来访问<code class="fe kt ku kv kw b">pairs</code>的索引的变量，如果条件为假，则我们检查它是否小于，并且获胜者是<code class="fe kt ku kv kw b">[j]</code>。这根据我们下面的选民偏好:</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="5025" class="lh li in kw b gy lj lk l ll lm">Rank 1: alice<br/>Rank 2: bob<br/>Rank 3: char</span><span id="dc74" class="lh li in kw b gy ln lk l ll lm">Rank 1: alice<br/>Rank 2: char<br/>Rank 3: bob</span><span id="6ffb" class="lh li in kw b gy ln lk l ll lm">Rank 1: char<br/>Rank 2: alice<br/>Rank 3: bob</span><span id="4f81" class="lh li in kw b gy ln lk l ll lm">The preferences array would look like this: <br/>[0 3 2]                                                                      <br/>[0 0 1]<br/>[1 2 0]</span></pre><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="8322" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们被要求对配对进行排序，我们使用<code class="fe kt ku kv kw b">sort_pairs</code>函数，我们需要根据胜利的强度对候选人进行排序，我们再次使用嵌套的 for 循环，但是第一个循环是向后的，是降序的，第二个是“正常的”，在 if 语句中，我们转到<code class="fe kt ku kv kw b">preferences</code>数组的位置<code class="fe kt ku kv kw b">[pairs.winner][pairs.loser]</code>，它给出了更喜欢某个候选人的人数。</p><p id="cffd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用<strong class="jx io">冒泡排序</strong>对数组进行排序，注意<code class="fe kt ku kv kw b">i</code>像我们说的那样向下，因为在数组的每一次遍历中，我们需要少查看一个索引。</p><p id="c34b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比较<code class="fe kt ku kv kw b">pairs</code>数组中每对相邻结构的胜利强度，如果配对和位置<code class="fe kt ku kv kw b">[j+1]</code>的胜利强度大于<code class="fe kt ku kv kw b">[j]</code>的胜利强度，则使用临时变量<code class="fe kt ku kv kw b">temp</code>交换配对</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="df00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个函数<code class="fe kt ku kv kw b">lock_pairs</code>的目的是填充<code class="fe kt ku kv kw b">locked</code>二维数组。</p><p id="9b22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此之前，我创建了一个名为<code class="fe kt ku kv kw b">cycle</code>的新函数，如果创建了一个循环，它将返回<strong class="jx io"> true </strong>，我们运行它，直到它返回<strong class="jx io"> false </strong>，为了更好地理解这两个函数，我推荐这篇文章<a class="ae lo" href="https://joseph28robinson.medium.com/cs50-pset3-tideman-87f22f0f0bc3" rel="noopener"><strong class="jx io"/></a>。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="7b03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">lock_pairs</code>中，我们遍历每一对，为每一个输家和赢家调用<code class="fe kt ku kv kw b">cycle</code>函数。如果<code class="fe kt ku kv kw b"><strong class="jx io">cycle</strong></code> <strong class="jx io"> </strong>返回假，那么<code class="fe kt ku kv kw b">locked</code>数组可以为那个<code class="fe kt ku kv kw b">pair</code>设置为真</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="7571" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">print_winner</code>函数循环遍历每个候选项，检查它是否被锁定，如果<code class="fe kt ku kv kw b">locked</code>为假，则增加<code class="fe kt ku kv kw b">falseValues</code>变量，并检查它是否等于候选项计数，换句话说，它检查是否有一个指向它们的箭头。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="b70a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是迄今为止最困难的问题，我无法独自解决它，我必须做大量的谷歌搜索并从其他人那里获得帮助，但作为未来的开发人员，我们需要学习这些技能，重要的是我们要向前迈进，因为如果我们在一个问题上停滞不前太久，我们可能会感到沮丧并停止学习，至少这是我以前发生过的事情。 我当时就停止了学习，甚至认为我得到了帮助，我在 3 周内完成了这个问题，我花了很多时间在调试器上，试图理解这里发生的事情和解释，我认为我仍然没有很好地掌握它，但我觉得我需要像我之前说的那样前进。</p><p id="90ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读:)。</p><p id="ff93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两篇文章给了我很大的帮助:<a class="ae lo" href="https://gist.github.com/nicknapoli82/6c5a1706489e70342e9a0a635ae738c9" rel="noopener ugc nofollow" target="_blank"> art1 </a>，<a class="ae lo" href="https://joseph28robinson.medium.com/cs50-pset3-tideman-87f22f0f0bc3" rel="noopener"> art2 </a>。</p></div></div>    
</body>
</html>