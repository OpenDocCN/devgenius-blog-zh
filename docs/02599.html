<html>
<head>
<title>P5.js animation in 131 characters of code explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">P5.js动画中131个字符的代码讲解</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/p5-js-animation-in-131-characters-of-code-explained-37cd8e1bb996?source=collection_archive---------0-----------------------#2020-08-15">https://blog.devgenius.io/p5-js-animation-in-131-characters-of-code-explained-37cd8e1bb996?source=collection_archive---------0-----------------------#2020-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b247" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个用不到140个字符的代码编写的动画实际上是如何工作的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d99813e41f33090fb463f6b18a2eab55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqmVzK5nDv4B57Y7kcZJIg.png"/></div></div></figure><p id="4b6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一条来自Naoki Tsutae 的推文，其中有一些好看的图形和一些看起来相当神秘的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae ln" href="https://twitter.com/ntsutae/status/1268820823952916486" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ntsutae/status/1268820823952916486</a></figcaption></figure><p id="650c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些图像来自Noaki在OpenProcessing上创作的草图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu lp l"/></div></figure><p id="0239" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现这一切的代码是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lp l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">t=0，draw=_=&gt;{t++？copy(0，0，w，w，0，1，w，w):createCanvas(w=720，w)for(x = 720；—x；){ stroke(abs(t+((x-t)^(x+t))**3)%997&lt;97?w:0);point(x,0)}}</figcaption></figure><p id="b458" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">That's just <strong class="kt ir">131人物</strong>。<strong class="kt ir"> </strong>挺神奇的！</p><h1 id="b6c9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">那么它是如何工作的呢？</h1><p id="0b0d" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">正如所料(因为这是相当简洁和复杂的代码)，并不是每个人都理解这些代码是如何工作的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="5c45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作者不太倾向于解释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e8cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我喜欢拼图、图形和教学，我想它可能试图解释我自己正在发生的事情。</p><h1 id="bf02" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">解开代码</h1><p id="480b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在我们了解这是如何工作的之前，我们需要使代码更具可读性。你看，代码使用了一些技巧和速记符号来去掉多余的字节。</p><p id="7f8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把事情摊开让我们对正在发生的事情有更多的了解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lp l"/></div></figure><p id="3d82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让这段代码如此简洁的原因也是让它更难阅读的原因。</p><ol class=""><li id="530a" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">几乎不使用任何变量。其实只有<strong class="kt ir">三个</strong>。更糟糕的是，<code class="fe nc nd ne nf b">t</code>、<code class="fe nc nd ne nf b">w</code>和<code class="fe nc nd ne nf b">x</code>并不是真正的描述性名字。</li><li id="5341" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm my mz na nb bi translated">使用了<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>。它是这样工作的:<code class="fe nc nd ne nf b">condition ? expresionIfTrue : expresionIfFalse</code>。这是对更冗长(通常更易读)<code class="fe nc nd ne nf b">if</code>和<code class="fe nc nd ne nf b">else</code>语句的一种简化替代。</li></ol><p id="341d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们进一步解包代码并重命名一些变量，它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl lp l"/></div></figure><p id="d3e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这段代码具有完全相同的功能。这本身就应该让你知道把所有这些都折叠成这么几个字符是多么的巧妙。</p><p id="80ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，详细版本应该更容易看到发生了什么。让我们更详细地浏览一下…</p><h1 id="ecea" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">开始吧</h1><p id="589f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">首先发生的事情很容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/deb791b50a9866055c4888a415e3236e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9YnXBnywdD_vWMjiDbeQw.png"/></div></div></figure><ul class=""><li id="9927" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm no mz na nb bi translated">计数器<code class="fe nc nd ne nf b">t</code>被声明。</li><li id="f443" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated">创建了<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/draw" rel="noopener ugc nofollow" target="_blank">draw</a>()</code>功能。这是<a class="ae ln" href="https://p5js.org/" rel="noopener ugc nofollow" target="_blank">P5 . js</a>(open processing用来画草图的库)使用的特殊函数。它在一个连续的循环中被调用(除非<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/noloop" rel="noopener ugc nofollow" target="_blank">noloop</a>()</code>被调用)。</li><li id="439f" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated">计数器递增。每次在P5.js提供的循环中调用<code class="fe nc nd ne nf b">draw()</code>时都会发生这种情况</li><li id="8cf1" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated">定义了设置画布宽度的变量<code class="fe nc nd ne nf b">w</code>。</li><li id="60b5" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated">画布被创建。</li></ul><p id="7547" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的技巧是在 <code class="fe nc nd ne nf b">t</code>递增之前，<code class="fe nc nd ne nf b">t</code>的值用于决定三元运算符<em class="nm">的结果。这确保画布只被创建一次。(因为<code class="fe nc nd ne nf b">t</code>仅在第一次调用<code class="fe nc nd ne nf b">draw()</code>时等于零)。</em></p><p id="7162" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将此代码与详细代码进行比较，结果如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl lp l"/></div></figure><p id="6197" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里<code class="fe nc nd ne nf b">createCanvas()</code>被放在了<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/setup" rel="noopener ugc nofollow" target="_blank">setup</a>()</code>中，这也是P5.js定义的一个特殊函数。为了设置好一切，它只被调用一次。</p><h1 id="fcba" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">画一条线</h1><p id="c06b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">接下来发生的事情是绘制一行(或一条线)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/efee5a614fb79dab53d13324b86bce3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQYslborZBAOtf1RQ3yv9g.png"/></div></div></figure><p id="a8ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/point" rel="noopener ugc nofollow" target="_blank">point</a>()</code>功能一次绘制一个像素。<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/stroke" rel="noopener ugc nofollow" target="_blank">stroke</a>()</code>功能决定了圆点的颜色。</p><p id="deb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个点都绘制在<code class="fe nc nd ne nf b">for</code>循环中。<code class="fe nc nd ne nf b">point()</code>功能在给定的X和Y坐标上绘制一个点。由于只画了<em class="nm">一条</em>线，所以Y始终为零。X从图像的右侧开始，这里X等于图像宽度。然后，随着<code class="fe nc nd ne nf b">for</code>循环的每一次迭代，它都向右移动(因为每次迭代X都减一)。</p><p id="da58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一直持续到X为零。</p><p id="8d52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是这里使用的一个小技巧…省略了 <code class="fe nc nd ne nf b"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">for</a></code> <a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">循环</a>的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">最终表达式。</a></p><p id="2585" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将它添加到我们更详细的代码版本中会得到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl lp l"/></div></figure><p id="25bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么笔画(颜色)是怎么计算的呢？</p><h1 id="ed95" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第一个魔术</h1><p id="5847" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">首先要明白的是，颜色永远不是黑就是白。这是因为传递给<code class="fe nc nd ne nf b">stroke()</code>的值总是<code class="fe nc nd ne nf b">0</code>或<code class="fe nc nd ne nf b">720</code>(<code class="fe nc nd ne nf b">w</code>的值)。零值被解释为黑色，任何大于255的值被解释为白色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/9620cbf11638244b903dcd76fb7e0cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4T7ge2pAK2LZpWh10tA5Q.png"/></div></div></figure><p id="d89d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里事情变得有点复杂。这是大多数人会觉得难以理解的部分，因为它需要牢固的数学知识，尤其是代数。</p><p id="d8e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">决定选择哪种颜色的逻辑使用:</p><ul class=""><li id="3004" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm no mz na nb bi translated">按位<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR" rel="noopener ugc nofollow" target="_blank">异或运算器</a> : <code class="fe nc nd ne nf b">^</code>仅在一个输入为<code class="fe nc nd ne nf b">true</code>而另一个为<code class="fe nc nd ne nf b">false</code>时输出<code class="fe nc nd ne nf b">true</code>(称为<a class="ae ln" href="https://en.wikipedia.org/wiki/Exclusive_or" rel="noopener ugc nofollow" target="_blank">异或</a>)</li><li id="a5f6" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation" rel="noopener ugc nofollow" target="_blank">取幂运算符</a> <code class="fe nc nd ne nf b">**</code>提供<a class="ae ln" href="https://en.wikipedia.org/wiki/Exponentiation" rel="noopener ugc nofollow" target="_blank">取幂运算</a>(重复乘法)，同<code class="fe nc nd ne nf b">Math.pow()</code></li><li id="2762" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated"><code class="fe nc nd ne nf b"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs" rel="noopener ugc nofollow" target="_blank">Math.abs()</a></code>(通过<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/abs" rel="noopener ugc nofollow" target="_blank">abs()</a></code>函数)将始终提供给定整数的<a class="ae ln" href="https://en.wikipedia.org/wiki/Absolute_value" rel="noopener ugc nofollow" target="_blank">绝对值</a>(即大于零的正数)</li><li id="0c7d" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder" rel="noopener ugc nofollow" target="_blank">余数运算符</a> <code class="fe nc nd ne nf b">%</code>(也称为<a class="ae ln" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">模运算</a></li><li id="46f9" class="mt mu iq kt b ku ng kx nh la ni le nj li nk lm no mz na nb bi translated"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">小于操作员</a>T3】</li></ul><p id="119a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了理解“如何”，我们必须将等式分解成更小的部分。完整的等式如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a5e51f25f41f462133e93932dffe17cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A3tDMRtYz8pjpoCf"/></div></div></figure><h2 id="9446" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">异或运算</h2><p id="ad0e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">让我们先取最里面的部分,“异或”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2812de50576853788641ca6f3e890db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/0*WMBqOzttxjM0rZ5Y"/></div></figure><p id="8e6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于图像中的每一行，<code class="fe nc nd ne nf b">x</code>将在<strong class="kt ir"> 0 </strong>和<strong class="kt ir"> 720 </strong>之间。<code class="fe nc nd ne nf b">t</code>将从<strong class="kt ir"> 0 </strong>处开始，并不断上升，直到每一个连续的行。因此，随着<code class="fe nc nd ne nf b">t</code>上升，事情的“负”面将继续下降，而“正”面将继续上升。</p><p id="eaf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么会发生什么呢？</p><p id="4653" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住，“异或”是指只有当等式的一边是<code class="fe nc nd ne nf b">true</code>(或<code class="fe nc nd ne nf b">1</code>)，另一边是<code class="fe nc nd ne nf b">false</code>(或<code class="fe nc nd ne nf b">0</code>)时，结果才会是<code class="fe nc nd ne nf b">true</code>。不过，需要知道的是，这不适用于整数(比如720或97)，而是适用于它们的二进制表示(比如1011010000或1100001)。例如(用720代表<code class="fe nc nd ne nf b">x</code>，用97代表<code class="fe nc nd ne nf b">t</code>，我们得到<strong class="kt ir"> 350 </strong>。</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="e6d6" class="nq lx iq nf b gy oh oi l oj ok">(720 - 97) XOR (720 + 97) = (623) XOR (817) = 350</span></pre><p id="c77b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">怎么会？将十进制转换成二进制，你会看到:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="2b32" class="nq lx iq nf b gy oh oi l oj ok">  1001101111      623<br/>^ 1100110001    ^ 817<br/>============    =====<br/>  0101011110      350</span></pre><p id="46a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这造成了你在图像中看到的一些随机性，但它也是图像结构的基础。</p><h2 id="a0cb" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">指数运算</h2><p id="389e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">接下来发生的事情非常简单。Xor运算产生的整数的3次方为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/65ed0a6b980fd3f2aa4a8a15af5abb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*629AuNYOy5978UCo"/></div></figure><p id="c969" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，使用上例中的350，我们可以得到:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="1e09" class="nq lx iq nf b gy oh oi l oj ok">350 * 350 * 350 = 42875000</span></pre><p id="4fdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个相当大的数字！别担心。这就是模的用途。但我们稍后会谈到这一点。首先，一些可能不明显的事情…</p><p id="dabd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当输入是正整数时，没有什么特别的事情发生。结果总是一个正整数。然而，当输入是负数时，奇数指数的结果将是负的，偶数指数的结果将是正的。</p><p id="0855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请允许我演示:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="a6fe" class="nq lx iq nf b gy oh oi l oj ok">-1^2 =                -1 * -1 =  1<br/>-1^3 =           -1 * -1 * -1 = -1<br/>-1^4 =      -1 * -1 * -1 * -1 =  1<br/>-1^5 = -1 * -1 * -1 * -1 * -1 = -1</span></pre><p id="0575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">诸如此类。</p><p id="d8af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为数字被提升了奇数次(在本例中是3次)，所以结果也可能是负数！所以现在你可能已经猜到为什么会有一个<code class="fe nc nd ne nf b">abs()</code>即将到来。</p><h2 id="e889" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">添加</h2><p id="354b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">下一部分只是将<code class="fe nc nd ne nf b">t</code>添加到求幂运算的结果中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/a579e02838da2913f9bbdba451490bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S2F4IwU27rHwwstz"/></div></div></figure><p id="912e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">继续我们的例子，T2是720，T3是97，我们得到:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="d397" class="nq lx iq nf b gy oh oi l oj ok">97 + 42875000 = 42875097</span></pre><h2 id="d66e" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">赦免</h2><p id="b2af" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">下一部分是另一个简单的部分。记住(因为指数运算),我们在这一点上可能有一个负数？</p><p id="86e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一位为我们解决了这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e14dbe3be8644b404a62b643e5f28c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/0*VYosm3SKvOjJ4YK_"/></div></figure><p id="3a45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我之前提到的<code class="fe nc nd ne nf b">Math.abs()</code>。现在我们终于也达到了我之前提到的模。</p><h2 id="5969" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">以…为模</h2><p id="c907" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我注意到很多人<em class="nm">知道<a class="ae ln" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">模</a>(或“余数”)运算符</em>，但并不是每个人都知道<em class="nm">叫什么</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/6bac293f413c4e55c39c96bf894249e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SvGR9tasF3vgEcCC"/></div></div></figure><p id="09f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，它所做的很简单。它将第一个数字除以第二个数字，并返回余数。所以我们得到:<code class="fe nc nd ne nf b">42875097 % 997 = 109</code></p><p id="1c2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想严格要求的话，应该是:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="f7e8" class="nq lx iq nf b gy oh oi l oj ok">42875097 % 997 = 42875097<!-- --> - (<!-- -->997<!-- --> * int(<!-- -->42875097 <!-- -->/ <!-- -->997<!-- -->)) = 109</span></pre><p id="3179" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只差一个数学步骤了！</p><h2 id="a54d" class="nq lx iq bd ly nr ns dn mc nt nu dp mg la nv nw mi le nx ny mk li nz oa mm ob bi translated">不到</h2><p id="2a6a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">这里发生的最后一件事是比较。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/cece22e4e26fbdbd9f22a352cd019db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rYwhuqITWSJJXfVE"/></div></div></figure><p id="35e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是最终决定我们在当前行上得到黑色还是白色像素的原因。如果等式的输出小于97，则结果为黑色(或者准确地说是<code class="fe nc nd ne nf b">0</code>)，否则为白色(通过<code class="fe nc nd ne nf b">w</code>的值)。</p><p id="4fe7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Pfew。为了得到一个像素，确实需要大量的数学计算，对吗？</p><p id="16c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们把它作为一个独立的函数放在详细的代码中，它看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl lp l"/></div></figure><p id="c6c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上,<em class="nm">包含了太多的数学运算，这就是为什么图像的结构是散列的。现在你可能会想，如果这一切都是为了<em class="nm">仅仅一行</em>我们到底还要走多远？</em></p><p id="70d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，所有的数学难题都解决了，只剩下一行代码需要解释了…</p><h1 id="9f20" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建下一行</h1><p id="639f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">一旦画好线，P5.js提供的循环再次调用<code class="fe nc nd ne nf b">draw()</code>函数。<code class="fe nc nd ne nf b">t++</code>发生了，从现在开始，<code class="fe nc nd ne nf b">createCanvas()</code>将不再被称为。取而代之的是<code class="fe nc nd ne nf b"><a class="ae ln" href="https://p5js.org/reference/#/p5/copy" rel="noopener ugc nofollow" target="_blank">copy()</a></code>的称呼。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/616761ca0f6d7d8bd6fcdf9dcb56a45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQrZdQDvm-L4isGX4-WqRA.png"/></div></div></figure><p id="036b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么copy做什么呢？顾名思义，它复制了一些东西。它复制的内容取决于给定的参数:</p><pre class="kg kh ki kj gt od nf oe of aw og bi"><span id="cfb2" class="nq lx iq nf b gy oh oi l oj ok">copy(<br/>    sourceX, sourceY, sourceWidth, sourceHeight,<br/>    destinationX, destinationY, destinationWidth, destinationHeight<br/>)</span></pre><p id="fa77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能猜出<code class="fe nc nd ne nf b">copy(0, 0, w, w, 0, 1, w, w)</code>是做什么的吗？</p><p id="8ce1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您可能已经猜到的，它从X和Y <code class="fe nc nd ne nf b">0</code>到X和Y <code class="fe nc nd ne nf b">w</code>复制整个画布，X和Y等于整个高度和宽度(因为图像是720平方)。那么它把它复制到哪里呢？往下一行。</p><p id="46dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在第一行画下一行，循环重复。</p><p id="66fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种机制也是产生“滚动”效果的一个巧妙技巧。</p><h1 id="1c55" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">包扎</h1><p id="5395" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">现在我们已经一行一行地看了一遍，应该<em class="nm">清楚每件事都做了什么。我错过什么了吗？你对这篇文章有什么问题吗？欢迎你在推特上留言或联系我。</em></p><p id="4134" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我很乐意解释！</p><p id="c2ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我想留给您这个稍微修改过的详细代码版本。它在一个<code class="fe nc nd ne nf b">config</code>对象中包含了所有的变量，所以你可以更容易地使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl lp l"/></div></figure><p id="33da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用这段代码做了一个关于OpenProcessing的草图，所以你可以从中得到一些乐趣！👋</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu lp l"/></div></figure></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="05bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文中的所有代码示例都是使用<a class="ae ln" href="https://gist.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>或<a class="ae ln" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> Carbon </a>创建的。数学方程式是使用<a class="ae ln" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank"> CodeCog的方程式编辑器</a>创建的。我要感谢<a class="ae ln" href="https://twitter.com/ntsutae/" rel="noopener ugc nofollow" target="_blank"> Naoki Tsutae </a>在发表前看了这篇文章，当然还有那些令人敬畏的动画！</p></div></div>    
</body>
</html>