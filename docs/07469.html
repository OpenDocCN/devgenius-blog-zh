<html>
<head>
<title>Why Python Developers Should Use @staticmethod and @classmethod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么 Python 开发人员应该使用@staticmethod 和@classmethod</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-python-developers-should-use-staticmethod-and-classmethod-d5fe60497f23?source=collection_archive---------1-----------------------#2022-03-28">https://blog.devgenius.io/why-python-developers-should-use-staticmethod-and-classmethod-d5fe60497f23?source=collection_archive---------1-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3e333c7943fc51ac5c1e19581e930785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVJu8LTLZDL6s7Q8LJevAA.jpeg"/></div></div></figure><p id="ebdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将向您展示什么是<code class="fe kt ku kv kw b">@staticmethod</code>和<code class="fe kt ku kv kw b">@classcmethod</code>，以及为什么以及何时应该使用它们！让我们开始吧。</p><blockquote class="kx ky kz"><p id="f4c5" class="jv jw la jx b jy jz ka kb kc kd ke kf lb kh ki kj lc kl km kn ld kp kq kr ks ig bi translated">如果你还不知道什么是装饰器，以及它是如何工作的，那么首先阅读<a class="ae le" href="https://medium.com/@vlad.bashtannyk/what-the-decorators-in-plain-words-python-b600623ea497" rel="noopener"> <strong class="jx io">这篇文章</strong> </a>。</p></blockquote><h1 id="baea" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">定义:</h1><h2 id="003d" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">@静态方法</h2><p id="1768" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated"><code class="fe kt ku kv kw b">@staticmethod</code>是一个内置的装饰器，它在 Python 中定义了类中的静态方法。静态方法既不接受类参数，也不接受实例参数，不管它是由类的实例调用还是由类本身调用。</p><h2 id="7355" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">特征</h2><ul class=""><li id="f06c" class="mu mv in jx b jy mp kc mq kg mw kk mx ko my ks mz na nb nc bi translated">在类中声明一个静态方法。</li><li id="7ef7" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">它不能有<code class="fe kt ku kv kw b">cls</code>或<code class="fe kt ku kv kw b">self</code>参数。</li><li id="e939" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">静态方法不能访问类属性或实例属性。</li><li id="4c15" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">静态方法可以使用<code class="fe kt ku kv kw b">ClassName.MethodName()</code>调用，也可以使用<code class="fe kt ku kv kw b">object.MethodName()</code>调用。</li><li id="d9da" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">它可以返回类的对象。</li></ul><p id="4454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的示例声明了一个静态方法:</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="b2d7" class="md lg in kw b gy nq nr l ns nt">class Supermarket:<br/>    product = "Milk"  <!-- --># class attribute<br/>    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = best_before  # instance attribute<br/>        self.product = product</span><span id="b14a" class="md lg in kw b gy nu nr l ns nt">    @staticmethod    <br/>    def normalize_product_name(product):<br/>        product = product.capitalize().strip()        <br/>        return product</span></pre><p id="af1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面，<code class="fe kt ku kv kw b">Supermarket</code>类使用<code class="fe kt ku kv kw b">@staticmethod</code>装饰器将<code class="fe kt ku kv kw b">normalize_product_name()</code>方法声明为静态方法。注意，它不能有<code class="fe kt ku kv kw b">self</code>或<code class="fe kt ku kv kw b">cls</code>参数。</p><p id="675b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以使用<code class="fe kt ku kv kw b">ClassName.MethodName()</code>或<code class="fe kt ku kv kw b">object.MethodName()</code>调用静态方法。</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="0e70" class="md lg in kw b gy nq nr l ns nt">&gt;&gt;&gt; norm_product = Supermarket.normalize_product_name("milk  ")<br/>'Milk'<br/>&gt;&gt;&gt; obj = Supermarket("Bread", "2022-05-18")<br/>&gt;&gt;&gt; obj.normalize_product_name("milk  ")<br/>'Milk'</span></pre></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h2 id="d71d" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">@classmethod</h2><p id="1f4c" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated"><code class="fe kt ku kv kw b">@classmethod</code>是一个内置的装饰器，在 Python 中定义了类中的类方法。类方法只接收类参数。可以使用<code class="fe kt ku kv kw b">ClassName.MethodName()</code>或<code class="fe kt ku kv kw b">object.MethodName()</code>调用类方法。</p><p id="0ec4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">@classmethod</code>是<code class="fe kt ku kv kw b">classmethod()</code>功能的替代。建议使用<code class="fe kt ku kv kw b">@classmethod</code> decorator 代替函数，因为它只是语法糖。</p><h2 id="380b" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">特征</h2><ul class=""><li id="6e2b" class="mu mv in jx b jy mp kc mq kg mw kk mx ko my ks mz na nb nc bi translated">声明一个类方法。</li><li id="ed76" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">第一个参数必须是<code class="fe kt ku kv kw b">cls</code>，可以用来访问类属性。</li><li id="19e5" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">class 方法只能访问类属性，而不能访问实例属性。</li><li id="df71" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">可以使用<code class="fe kt ku kv kw b">ClassName.MethodName()</code>和<code class="fe kt ku kv kw b">object.MethodName()</code>调用类方法。</li><li id="cc21" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">它可以返回类的对象。</li></ul><p id="798b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的示例声明了一个类方法:</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="e5ab" class="md lg in kw b gy nq nr l ns nt">class Supermarket:<br/>    product = "Milk"  <!-- --># class attribute<br/>    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = best_before  # instance attribute<br/>        self.product = product</span><span id="5b96" class="md lg in kw b gy nu nr l ns nt">    @classmethod    <br/>    def get_product(cls):<br/>        print("product=" + cls.product)</span></pre><p id="aa22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的<code class="fe kt ku kv kw b">Supermarket</code>类包含一个类属性<code class="fe kt ku kv kw b">product</code>和一个实例属性<code class="fe kt ku kv kw b">best_before</code>。<code class="fe kt ku kv kw b">get_product()</code>方法用<code class="fe kt ku kv kw b">@classmethod</code>装饰器装饰，使其成为一个类方法，可以使用<code class="fe kt ku kv kw b">Supermarket.get_product()</code>调用。注意，任何类方法的第一个参数必须是<code class="fe kt ku kv kw b">cls</code>，它可以用来访问类的属性。您可以给第一个参数取任何名称，而不是<code class="fe kt ku kv kw b">cls</code>。</p><p id="cf57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以使用<code class="fe kt ku kv kw b">ClassName.MethodName()</code>或<code class="fe kt ku kv kw b">object.MethodName()</code>调用类方法。</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="88e3" class="md lg in kw b gy nq nr l ns nt">&gt;&gt;&gt; <!-- -->Supermarket<!-- -->.<!-- -->get_product<!-- -->()<br/>'<!-- -->product=Milk<!-- -->'<br/>&gt;&gt;&gt; obj = <!-- -->Supermarket<!-- -->()<br/>&gt;&gt;&gt; obj.<!-- -->get_product<!-- -->()<br/>'<!-- -->product=Milk<!-- -->'</span></pre><p id="4549" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在类方法中你不能使用实例属性:</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="d39b" class="md lg in kw b gy nq nr l ns nt">class Supermarket:<br/>    product = "Milk"  <!-- --># class attribute<br/>    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = best_before  # instance attribute<br/>        self.product = product</span><span id="2076" class="md lg in kw b gy nu nr l ns nt">    @classmethod    <br/>    def get_product(cls):<br/>        print(f"product={cls.product}, age={cls.best_before}")</span><span id="1368" class="md lg in kw b gy nu nr l ns nt"><br/>&gt;&gt;&gt; Supermarket.get_product()<br/>AttributeError: type object 'Supermarket' has no attribute 'best_before'</span></pre></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="989d" class="lf lg in bd lh li oc lk ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc bi translated">什么时候应该使用静态方法？</h1><h2 id="9252" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">1.将效用函数分组到一个类中</h2><p id="1e83" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">静态方法的用例有限，因为像类方法或类中的任何其他方法一样，它们不能访问类本身的属性。</p><p id="a2eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，当你需要一个不访问一个类的任何属性，但有意义的是它属于这个类的效用函数时，我们使用静态函数。</p><p id="169c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您添加了更改“保质期”格式的功能:</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="2cf7" class="md lg in kw b gy nq nr l ns nt">from datetime import datetime</span><span id="9f2a" class="md lg in kw b gy nu nr l ns nt"><br/>class Supermarket:    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = "2022-05-18"<br/>        self.product = "Milk"<br/>    <br/>    @staticmethod    <br/>    def change_date_format(best_before):<br/>        best_before = datetime.strptime(best_before, "%Y-%m-%d")<br/>        best_before = best_before.strftime("%d-%m-%Y")<br/>        return best_before<br/></span><span id="4fba" class="md lg in kw b gy nu nr l ns nt">&gt;&gt;&gt; Supermarket<!-- -->.<!-- -->change_date_format<!-- -->(<!-- -->"2022-08-06"<!-- -->)<br/>'<!-- -->06-08-2022<!-- -->'</span></pre><p id="cc54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它是一个静态方法，因为它不需要访问<code class="fe kt ku kv kw b">Supermarket</code>本身的任何属性，只需要参数。</p><h2 id="1229" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">2.具有单一实现</h2><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="5699" class="md lg in kw b gy nq nr l ns nt">from datetime import datetime</span><span id="ad59" class="md lg in kw b gy nu nr l ns nt"><br/>class Supermarket:    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = best_before<br/>        self.product = product<br/>        <br/>    def get_best_before_date(self):<br/>        return self.best_before<br/>    <br/>    <a class="ae le" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a>    <br/>    def change_date_format(best_before):<br/>        best_before = datetime.strptime(best_before, "%Y-%m-%d")<br/>        best_before = best_before.strftime("%d-%m-%Y")<br/>        return best_before</span><span id="479c" class="md lg in kw b gy nu nr l ns nt"><br/>class GroceryStore(Supermarket):<br/>    def get_best_before_date(self):<br/>        return Supermarket.change_date_format(self.best_before)<br/>    <br/>    <br/>&gt;&gt;&gt; supermarket = Supermarket("Milk", "2022-05-18")<br/>&gt;&gt;&gt; grocery = GroceryStore("Milk", "2022-05-18")<br/>&gt;&gt;&gt; supermarket.get_best_before_date()<br/>'2022-05-18'<br/>&gt;&gt;&gt; grocery.get_best_before_date()<br/>'18-05-2022'</span></pre></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="e154" class="lf lg in bd lh li oc lk ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc bi translated">什么时候应该使用类方法？</h1><p id="838b" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">您可以将类方法用于未绑定到特定实例但绑定到类的任何方法。实际上，对于创建类实例的方法，通常使用类方法。</p><h2 id="ac59" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">1.工厂方法</h2><p id="428c" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">工厂方法是那些为不同用例返回类对象的方法。例如:</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="ce8b" class="md lg in kw b gy nq nr l ns nt">class Supermarket:    <br/>    def __init__(self, product, best_before):<br/>        self.best_before = "2022-05-18"<br/>        self.product = "Milk"<br/>    <br/>    @classmethod    <br/>    def add_product(cls):<br/>        return cls("<!-- -->Bread<!-- -->", "2022-05-29")</span><span id="3463" class="md lg in kw b gy nu nr l ns nt">&gt;&gt;&gt; obj = Supermarket.add_product()<br/>&gt;&gt;&gt; obj.product<br/>'<!-- -->Milk<!-- -->'<br/>&gt;&gt;&gt; obj.best_before<br/>'2022-05-18'</span></pre><p id="b351" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，add_product()函数只创建一个新的类对象(一个新产品及其保质期)。</p><h2 id="c3cf" class="md lg in bd lh me mf dn ll mg mh dp lp kg mi mj lt kk mk ml lx ko mm mn mb mo bi translated">2.更正继承中的实例创建</h2><p id="f730" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">每当您通过将工厂方法实现为类方法来派生一个类时，它都会确保正确创建派生类的实例。</p><p id="e2bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以创建一个静态方法，但是它创建的对象将总是被硬编码为基类。</p><p id="9865" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，当您使用类方法时，它会创建派生类的正确实例。</p><pre class="ni nj nk nl gt nm kw nn no aw np bi"><span id="7b96" class="md lg in kw b gy nq nr l ns nt">class Supermarket:<br/>    product_price = {"Milk": 1}</span><span id="6518" class="md lg in kw b gy nu nr l ns nt">    def __init__(self, product, best_before):<br/>        self.best_before = "2022-05-18"<br/>        self.product = "Milk"</span><span id="fb3b" class="md lg in kw b gy nu nr l ns nt">    @staticmethod<br/>    def add_import_product(product, best_before):<br/>        return Supermarket(product, best_before)</span><span id="deea" class="md lg in kw b gy nu nr l ns nt">    @classmethod    <br/>    def add_product(cls, product, best_before):<br/>        return cls(product, best_before)</span><span id="f95e" class="md lg in kw b gy nu nr l ns nt"><br/>class GroceryStore(Supermarket):<br/>    product_price = {"Milk": 2}</span><span id="e6f3" class="md lg in kw b gy nu nr l ns nt">grocery1 = GroceryStore.add_import_product("Bread", "2022-06-05")<br/>isinstance(grocery1, GroceryStore)<br/>&gt;&gt;&gt; False<br/>grocery2 = GroceryStore.add_product("Apple", "2022-06-10")<br/>isinstance(grocery2, GroceryStore)<br/>&gt;&gt;&gt; True</span></pre><p id="a305" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，使用静态方法创建一个类实例，希望我们在创建过程中硬编码实例类型。</p><p id="8d79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这显然会在继承<code class="fe kt ku kv kw b">Supermarket</code>到<code class="fe kt ku kv kw b">GroceryStore</code>时产生问题。</p><p id="3f39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">add_import_product</code>方法不返回<code class="fe kt ku kv kw b">Grocerystore</code>对象，而是返回其基类<code class="fe kt ku kv kw b">Supermarkets</code>的对象。</p><p id="f3a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这违反了 OOP 范式。使用类方法作为<code class="fe kt ku kv kw b">add_product()</code>可以确保代码的面向对象性，因为它将第一个参数作为类本身，并调用它的工厂方法。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="381d" class="lf lg in bd lh li oc lk ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc bi translated">结论:</h1><p id="21f1" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">在本文中，我们分析了什么是<code class="fe kt ku kv kw b">@staticmethod</code>和<code class="fe kt ku kv kw b">@classcmethod</code>，并了解了如何、在哪里以及为什么使用它们:</p><ul class=""><li id="1fdb" class="mu mv in jx b jy jz kc kd kg oh kk oi ko oj ks mz na nb nc bi translated">我们一般使用@classmethod 来创建工厂方法。工厂方法返回不同用例的类对象。</li><li id="4e92" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">我们通常使用静态方法来创建和分组效用函数。</li></ul><p id="839f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在评论中分享你的想法和观点，如果这篇文章对你有用和有趣，点击<strong class="jx io">“鼓掌”</strong>。点击<strong class="jx io">“关注”</strong>总能获得有用的文章！</p></div></div>    
</body>
</html>