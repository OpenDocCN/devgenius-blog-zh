<html>
<head>
<title>Create Strong Flask + Scrapy + PostgreSQL Project!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建强大的 Flask + Scrapy + PostgreSQL 项目！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-strong-flask-scrapy-postgresql-project-3ab6a3d45b56?source=collection_archive---------2-----------------------#2022-12-19">https://blog.devgenius.io/create-strong-flask-scrapy-postgresql-project-3ab6a3d45b56?source=collection_archive---------2-----------------------#2022-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d002" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好的学习方法是用你想学的工具创建项目！这篇文章将向你展示如何使用 Scrapy，Flask 和 PostgreSQL 数据库！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/175d306de4dabd53d280b1cae2f44be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*giePMSZO_D4RMNw4c5BdxQ.png"/></div></figure><p id="475b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好久不见，但幸运的是，你在这里，我带你创建一个强大的 Flask + Scrapy + PostgreSQL 项目，它将教你如何使用这些工具！跟随<a class="ae kq" href="https://github.com/flyosprey/incense_extractor" rel="noopener ugc nofollow" target="_blank"> GitHub 资源库链接</a>来研究我的代码，并在阅读本文时保持关闭。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="cf27" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">内容计划:</h2><ol class=""><li id="143a" class="lr ls in jm b jn lt jr lu jv lv jz lw kd lx kh ly lz ma mb bi translated"><em class="mc">数据库准备</em></li><li id="fb31" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated"><em class="mc"> Scrapy 项目创建<br/> 2.1 开始项目<br/> 2.2 生成蜘蛛<br/> 2.3 创建辅助<br/> 2.4 构建蜘蛛</em></li><li id="949b" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated"><em class="mc">烧瓶项目创建<br/> 3.1 Models.py <br/> 3.2 模板<br/> 3.3 装饰者<br/> 3.4 控制器<br/>t16】⠀⠀<em class="mc">3 . 4 . 1 注册<br/> ⠀⠀3.4.2 登录<br/> ⠀⠀3.4.3 注销<br/> ⠀⠀3.4.4 主页<br/> 3.5 用户参数验证<br/> 3.6 数据库调度</em></em></li><li id="5093" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated"><em class="mc">烧瓶+刮刀一体化</em></li><li id="a9f3" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated"><em class="mc">结果</em></li><li id="52cf" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated"><em class="mc">结论</em></li></ol></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/3afb9c22b87e143f328df459b52c3e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnIiQwb_di1R_TCR1fqrJQ.png"/></div></div></figure><h1 id="2e15" class="mn kz in bd la mo mp mq ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd bi translated">1.数据库准备</h1><p id="cf7c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">由于我们要创建一个 Scrapy 爬虫，我们应该了解数据库应该是什么样子。这取决于应该提取什么信息。</p><p id="bddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们爬上<a class="ae kq" href="https://zamorskiepodarki.com/uk/blagovoniya-i-aksessuary/aromapalochky-tulasi/" rel="noopener ugc nofollow" target="_blank">出售熏香和其他不同工作人员的站点</a>。所以，为了它，我们应该准备一张桌子。</p><p id="740c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们需要为 Flask 站点准备一个注册用户表。</p><p id="7f71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么数据库将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2a4b2f2487d30437e836c11585b0202a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*fQMMq4lnzsmlL9VZzRDXag.png"/></div></figure><p id="d5cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Incenses </strong>表告诉我们应该提取哪些字段，而<strong class="jm io"> Users </strong>表不需要任何注释，它只有 id、用户名和密码。此外，<strong class="jm io">这些表具有多对一的关系</strong>，这意味着所有提取的产品都将被附加到一个需要爬行的用户。<strong class="jm io"> user_id 是</strong> <strong class="jm io">的</strong> <strong class="jm io">外键</strong>。</p><p id="596c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步我们需要安装 PostgreSQL。</p><blockquote class="ni"><p id="d437" class="nj nk in bd nl nm nn no np nq nr kh dk translated">按照官方文档的<a class="ae kq" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">链接</a>安装 PostgreSQL。</p></blockquote><p id="7a19" class="pw-post-body-paragraph jk jl in jm b jn ns jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd nw kf kg kh ig bi translated">安装后需要通过终端以默认用户<strong class="jm io">的身份连接到 PostgreSQL，postgres </strong>使用以下命令:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="3b1f" class="oc kz in ny b be od oe l of og">sudo -u postgres psql</span></pre><p id="d02a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们为默认用户<strong class="jm io"> postgres </strong>设置一个密码:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="ae20" class="oc kz in ny b be od oe l of og">\password postgres</span></pre><p id="a5b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后需要创建一个名为<strong class="jm io">香</strong>的数据库:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="8b86" class="oc kz in ny b be od oe l of og">CREATE DATABASE incense;</span></pre><p id="2d5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在<strong class="jm io"> Models.py </strong>段落中做的其他事情，如创建表格</p><p id="a18b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你愿意，你可以创建和使用另一个用户，但不要忘记给他特权。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oh"><img src="../Images/fe5343ff0b05e1d38633f48c8e3431bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfUGTJPE_LSRqtW2wHDM5A.png"/></div></div></figure><h1 id="4440" class="mn kz in bd la mo mp mq ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd bi translated">2.零碎的项目创建</h1><h2 id="8335" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">2.1 启动项目</h2><p id="62b7" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">首先，我们需要使用以下代码行创建一个项目:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="ab64" class="oc kz in ny b be od oe l of og">scrapy startproject incense</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="5241" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">2.2 生成蜘蛛</h2><p id="0567" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">之后，蜘蛛应该以如下方式创建:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="c733" class="oc kz in ny b be od oe l of og">cd incense/incense/spiders &amp;&amp; scrapy genspider zamorskiepodarki zamorskiepodarki.com</span></pre><p id="c540" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个阶段，我们有一个关于下一棵树的零碎项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/87b06dc96d315eb24e7dc502d5b83602.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*laybtzudMaQYWD_FvAm2BQ.png"/></div></figure></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="67f7" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">2.3 创建辅助文件</h2><p id="040d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">让我们创建<strong class="jm io"> init_spider.py </strong>，在其中我们将为将来的请求实现一些参数的初始化:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="9b3d" class="oc kz in ny b be od oe l of og">from random_user_agent.user_agent import UserAgent<br/>from random_user_agent.params import SoftwareName, OperatingSystem<br/><br/><br/>def get_headers():<br/>    user_agent = _get_random_user_agent()<br/>    headers = {<br/>        'authority': 'zamorskiepodarki.com',<br/>        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,'<br/>                  '*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',<br/>        'accept-language': 'en-US,en;q=0.9,ru;q=0.8,de;q=0.7,uk;q=0.6',<br/>        'upgrade-insecure-requests': '1',<br/>        'user-agent': user_agent<br/>    }<br/>    return headers<br/><br/><br/>def _get_random_user_agent():<br/>    software_names = [SoftwareName.CHROME.value]<br/>    operating_systems = [OperatingSystem.WINDOWS.value, OperatingSystem.LINUX.value]<br/>    user_agent_rotator = UserAgent(software_names=software_names, operating_systems=operating_systems, limit=100)<br/>    user_agent = user_agent_rotator.get_random_user_agent()<br/>    return user_agent</span></pre><p id="702e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们将发送 GET 请求来获取要提取的数据，所以我们只需要准备头部。随机<strong class="jm io">用户代理的创建需要每个请求看起来都是唯一的</strong>。</p><p id="7a79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，需要<strong class="jm io">延迟发送请求，以避免网站过载，并让爬虫更加匿名</strong>。</p><p id="8280" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将下面的命令放到 Scrapy 项目的<strong class="jm io"> settings.py </strong>中。</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="41be" class="oc kz in ny b be od oe l of og">DOWNLOAD_DELAY = 1 # 1 second delay between requests.</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="cbde" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">2.4 内置蜘蛛</h2><p id="c08c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">最后，我们准备实现蜘蛛的逻辑:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="50e9" class="oc kz in ny b be od oe l of og">import re<br/>import logging<br/>from datetime import datetime<br/>import scrapy<br/>from scrapy.crawler import CrawlerProcess<br/>from incense.spiders.init_spider import get_headers<br/><br/><br/>class ZamorskiepodarkiSpider(scrapy.Spider):<br/>    name = "zamorskiepodarki"<br/>    allowed_domains = ["zamorskiepodarki.com"]<br/>    start_urls = []<br/><br/>    def __init__(self, url_to_parse="", user_id=None, **kwargs):<br/>        self.headers = get_headers()<br/>        self.start_urls.append(url_to_parse)<br/>        self.user_id = user_id<br/>        if not self.user_id:<br/>            raise Exception("user_id is None in scrape")<br/>        super().__init__(**kwargs)<br/>        self.images, self.pages, self.image_index = {"images": []}, None, None<br/><br/>    def start_requests(self):<br/>        for url in self.start_urls:<br/>            yield scrapy.Request(url=url, headers=self.headers, callback=self.parse)<br/><br/>    def parse(self, response, **kwargs):<br/>        products = response.xpath("//div[@class='product-layout product-grid']")<br/>        logging.debug("FIRST - %s", self.images)<br/>        for product in products:<br/>            logging.debug("URL - %s", response.url)<br/>            product_link = product.xpath("div[@class='product-thumb']//div[@class='image']/a/@href").get()<br/>            yield scrapy.Request(url=product_link, headers=self.headers, callback=self._get_image)<br/>        # pagination<br/>        next_page_url = self._next_page_url(response)<br/>        if next_page_url:<br/>            yield scrapy.Request(url=next_page_url, headers=self.headers, callback=self.parse)<br/><br/>    def _extract_images_link(self, response):<br/>        products = response.xpath("//div[@class='product-layout product-grid']")<br/>        for product in products:<br/>            product_link = product.xpath("div[@class='product-thumb']//div[@class='image']/a/@href").get()<br/>            yield scrapy.Request(url=product_link, headers=self.headers, callback=self._get_image)<br/><br/>    @staticmethod<br/>    def _next_page_url(response) -&gt; str or None:<br/>        url = None<br/>        next_pages_tag = response.xpath("//ul[@class='pagination']//li[@class='active']/following-sibling::li")<br/>        next_pages_text = next_pages_tag.xpath("./a/text()").get()<br/>        if next_pages_text and next_pages_text.isdigit():<br/>            url = next_pages_tag.xpath("./a/@href").get()<br/>        return url<br/><br/>    def _get_image(self, response):<br/>        prices_data = self._get_prices_data(response)<br/>        general_product_data = self._get_general_product_data(response)<br/>        logging.debug("IMAGE SHOULD BE DOWNLOADED")<br/>        incense_item = {"user_id": self.user_id, **general_product_data, **prices_data}<br/>        yield incense_item<br/><br/>    @staticmethod<br/>    def _get_general_product_data(response) -&gt; dict:<br/>        deep_link, date_of_parsing, status = response.url, datetime.now(), "NEW"<br/>        category_name = \<br/>            response.xpath("//ul[@class='breadcrumb']//li[@itemprop='itemListElement']//span/text()")[-1].get()<br/>        image_link = response.xpath("//a[@class='thumbnail']/@href").get()<br/>        title = response.xpath("//a[@class='thumbnail']/@title").get().replace("(", "").replace(")", "")<br/>        general_product_data = {"deep_link": deep_link, "date_of_parsing": date_of_parsing, "status": status,<br/>                                "image_link": image_link, "title": title, "category_name": category_name.strip()}<br/>        return general_product_data<br/><br/>    @staticmethod<br/>    def _get_prices_data(response) -&gt; dict:<br/>        product_div = response.xpath("//div[@id='product']")<br/>        currency = product_div.xpath("..//meta[@itemprop='priceCurrency']//@content").get()<br/>        opt_price = product_div.xpath("..//span[@class='price-new price-opt-new']/b//text()").get()<br/>        opt_price = float(re.search(r"\d+.\d+", opt_price)[0])<br/>        drop_price = round(opt_price * 1.1, 2)<br/>        retail_price = product_div.xpath("..//div[@class='price-detached price-retail']/span//text()").get()<br/>        retail_price = float(re.search(r"\d+.\d+", retail_price)[0])<br/>        prices_data = {"opt_price": opt_price, "drop_price": drop_price, "retail_price": retail_price,<br/>                       "currency": currency}<br/>        return prices_data<br/><br/><br/>if __name__ == "__main__":<br/>    process = CrawlerProcess()<br/>    process.crawl(ZamorskiepodarkiSpider)<br/>    process.start()</span></pre><p id="cf25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们简单地提取一些信息，这些信息将被放入数据库。实现了分页逻辑，所以所有页面都将被抓取。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oj"><img src="../Images/7a94168d50e7d7c7937f5c11128e3221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWuvkF15QKOsTHtgyIaqOA.png"/></div></div></figure><h1 id="ab65" class="mn kz in bd la mo mp mq ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd bi translated">3.Flask 项目创建</h1><h2 id="9138" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.1 模型. py</h2><p id="2d40" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">现在让我们构建已经在<strong class="jm io"> models.py </strong>中准备好的表格:</p><blockquote class="ni"><p id="9f05" class="nj nk in bd nl nm nn no np nq nr kh dk translated">重要提示:PostgresQL 应该安装在您的计算机上。</p></blockquote><pre class="ok ol om on oo nx ny nz bn oa ob bi"><span id="67fc" class="oc kz in ny b be od oe l of og">import logging<br/>import psycopg2<br/># credentials.py gets credentials from .env<br/>from credentials import HOSTNAME, USERNAME, PASSWORD, DATABASE<br/><br/><br/>class IncenseProducts:<br/>    def __init__(self):<br/>        self.connection = psycopg2.connect(host=HOSTNAME, user=USERNAME, password=PASSWORD, dbname=DATABASE)<br/>        self.cur = self.connection.cursor()<br/>        logging.debug("CREATING DATABASE")<br/>        self.cur.execute("""<br/>                CREATE TABLE IF NOT EXISTS incenses(<br/>                    id SERIAL PRIMARY KEY, <br/>                    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,<br/>                    category_name VARCHAR(120),<br/>                    title VARCHAR(200),<br/>                    image_link TEXT,<br/>                    deep_link TEXT,<br/>                    opt_price NUMERIC,<br/>                    drop_price NUMERIC,<br/>                    retail_price NUMERIC,<br/>                    currency VARCHAR(10),<br/>                    status VARCHAR(10),<br/>                    date_of_parsing TIMESTAMP<br/>                )<br/>                """)<br/>        self.connection.commit()<br/><br/>    def process_item(self, item):<br/>        self.cur.execute("SELECT * FROM incenses WHERE title = '%s'" % item['title'])<br/>        result = self.cur.fetchone()<br/>        if result:<br/>            logging.debug("ITEM IS ALREADY IN EXIST: '%s'", item['title'])<br/>            self.cur.execute("UPDATE incenses SET status = 'OLD', "<br/>                             "opt_price = %(opt_price)s, "<br/>                             "drop_price = %(drop_price)s, "<br/>                             "retail_price = %(retail_price)s, "<br/>                             "date_of_parsing = %(date_of_parsing)s "<br/>                             "WHERE title = '%(title)s'" % item)<br/>        else:<br/>            logging.debug("INSERTING ITEM")<br/>            self.cur.execute("INSERT INTO incenses "<br/>                             "(user_id, category_name, title, image_link, deep_link, opt_price, drop_price, retail_price, "<br/>                             "currency, status, date_of_parsing) VALUES (%(user_id)s, '%(category_name)s', '%(title)s', "<br/>                             "'%(image_link)s', '%(deep_link)s', %(opt_price)s, %(drop_price)s, %(retail_price)s, "<br/>                             "'%(currency)s', '%(status)s', '%(date_of_parsing)s')" % item)<br/>        self.connection.commit()<br/>        self.cur.close()<br/>        self.connection.close()<br/>        return item<br/><br/><br/>class Users:<br/>    def __init__(self):<br/>        self.connection = psycopg2.connect(host=HOSTNAME, user=USERNAME, password=PASSWORD, dbname=DATABASE)<br/>        self.cur = self.connection.cursor()<br/>        logging.debug("CREATING DATABASE")<br/>        self.cur.execute("""<br/>                        CREATE TABLE IF NOT EXISTS users (<br/>                        id SERIAL PRIMARY KEY,<br/>                        username TEXT NOT NULL UNIQUE,<br/>                        password TEXT NOT NULL<br/>                        );<br/>                        """)<br/>        self.connection.commit()<br/><br/>    def create_user(self, user_credentials):<br/>        query = "SELECT * FROM users WHERE username='%(username)s' AND password='%(password)s'" % user_credentials<br/>        self.cur.execute(query)<br/>        user = self.cur.fetchone()<br/>        if user:<br/>            logging.debug("USER ALREADY EXISTS: '%s'", user_credentials["username"])<br/>            result = {"error": {"message": "Such user already exists"}}<br/>        else:<br/>            logging.debug("CREATING USER")<br/>            self.cur.execute("INSERT INTO users "<br/>                             "(username, password) VALUES (%(username)s, %(password)s)", user_credentials)<br/>            self.cur.execute("SELECT * FROM users WHERE username=%(username)s", user_credentials)<br/>            user = self.cur.fetchone()<br/>            result = {"user_id": user[0]}<br/>        self.connection.commit()<br/>        self.cur.close()<br/>        self.connection.close()<br/>        return result</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="1850" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.2 模板</h2><p id="2773" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">第二步告诉我们，我们需要构建前端。为了简化这个过程，让我们使用免费的 HTML/CSS 模板并编辑它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/576517e9c573004224b646276cbbb776.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*q80BzclAuJncgKwkg90UwQ.png"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated"><a class="ae kq" href="https://github.com/flyosprey/incense_extractor/tree/master/flask_app/templates" rel="noopener ugc nofollow" target="_blank">https://github . com/flyo sprey/香 _ 提取器/tree/master/flask _ app/templates</a></figcaption></figure></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="fa1b" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.3 装修工</h2><p id="8e35" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">因为我们希望 Flask 网站要求用户注册，所以我们需要在用户登录或注销时限制对某些页面的访问:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="350f" class="oc kz in ny b be od oe l of og">from functools import wraps<br/>from flask import session, redirect<br/>from flask_api import status<br/><br/><br/>def login_required(f):<br/>    @wraps(f)<br/>    def decorated_function(*args, **kwargs):<br/>        if session.get('is_logged_in', False) is False:<br/>            return redirect('/login', code=status.HTTP_302_FOUND)<br/>        return f(*args, **kwargs)<br/>    return decorated_function<br/><br/><br/>def logout_required(f):<br/>    @wraps(f)<br/>    def decorated_function(*args, **kwargs):<br/>        if session.get('is_logged_in', False) is True:<br/>            return redirect('/incense', code=status.HTTP_302_FOUND)<br/>        return f(*args, **kwargs)<br/>    return decorated_function</span></pre><p id="f8ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为了保持用户登录，我们可以使用 flask 库的一个会话</strong>。当用户注销时，会话将被清除，并保留用户的一些数据，直到用户登录。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="0324" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.4 控制器</h2><p id="7e74" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">因为我们有模板，我们需要为他们每个人建立一个后端。</p><h2 id="72ee" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.4.1 注册</h2><p id="03b9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">首先，在这个阶段让我们实现用户注册逻辑:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="4461" class="oc kz in ny b be od oe l of og">from flask import request, render_template, make_response<br/>from flask_api import status<br/>from flask_restful import Resource<br/>from flask import redirect, url_for, session<br/>from flask_app.models import Users<br/>from flask_app.decorators import logout_required<br/><br/><br/>class SignUpPage(Resource):<br/>    DEFAULT_HEADERS = {'Content-Type': 'text/html'}<br/><br/>    @logout_required<br/>    def get(self):<br/>        rendered_result = render_template("signup.html", result={})<br/>        return make_response(rendered_result, status.HTTP_200_OK, self.DEFAULT_HEADERS)<br/><br/>    @logout_required<br/>    def post(self):<br/>        log_in_args = request.form<br/>        result = Users().create_user(log_in_args)<br/>        if result.get("error"):<br/>            rendered_result = render_template("signup.html", result=result)<br/>            return make_response(rendered_result, status.HTTP_403_FORBIDDEN, self.DEFAULT_HEADERS)<br/>        else:<br/>            session["is_logged_in"] = True  # Set a user logged in<br/>            session["user_id"] = result["user_id"]<br/>            return redirect(url_for("incense"), code=status.HTTP_302_FOUND)</span></pre><p id="8bb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在该文件中，我们使用我们的用户模型创建一个新用户，并保持该用户登录。注意，这里我们使用了<strong class="jm io">@ logout _ required</strong>decorator，如果用户已经登录，它将限制对页面的访问。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="2757" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">登录</h2><p id="e7d4" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">我们的下一步是实现用户登录逻辑:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="2c42" class="oc kz in ny b be od oe l of og">from flask import request, render_template, make_response<br/>from flask_api import status<br/>from flask_restful import Resource<br/>from flask_app.database_dispatcher import DatabaseDispatcher<br/>from flask import redirect, url_for, session<br/>from flask_app.decorators import logout_required<br/><br/><br/>class LoginPage(Resource):<br/>    DEFAULT_HEADERS = {'Content-Type': 'text/html'}<br/><br/>    @logout_required<br/>    def get(self):<br/>        rendered_result = render_template("login.html", result={})<br/>        return make_response(rendered_result, status.HTTP_200_OK, self.DEFAULT_HEADERS)<br/><br/>    @logout_required<br/>    def post(self):<br/>        log_in_args = request.form<br/>        result = DatabaseDispatcher().get_user(log_in_args)<br/>        if result.get("error"):<br/>            result = {"error": {"message": "Credentials are wrong"}}<br/>            rendered_result = render_template("login.html", result=result)<br/>            return make_response(rendered_result, status.HTTP_401_UNAUTHORIZED, self.DEFAULT_HEADERS)<br/>        else:<br/>            session["is_logged_in"] = True<br/>            session["user_id"] = result["user_id"]<br/>            return redirect(url_for("incense"), code=status.HTTP_302_FOUND)</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="4b47" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">退出登录</h2><p id="0213" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">也许，最简单的是用户注销逻辑。</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="97d6" class="oc kz in ny b be od oe l of og">from flask_api import status<br/>from flask_restful import Resource<br/>from flask import redirect, url_for, session<br/>from flask_app.decorators import login_required<br/><br/><br/>class LogoutPage(Resource):<br/>    DEFAULT_HEADERS = {'Content-Type': 'text/html'}<br/><br/>    @login_required<br/>    def get(self):<br/>        session.clear()<br/>        return redirect(url_for("login"), code=status.HTTP_302_FOUND)</span></pre><p id="fced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们使用了<strong class="jm io">@ log in _ required</strong>decorator，它限制了用户退出时对页面的访问。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="f7ce" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">主页</h2><p id="b037" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">最后，我们应该处理我们的主页:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="372a" class="oc kz in ny b be od oe l of og">from flask import request, render_template, make_response<br/>from flask_api import status<br/>from flask_restful import Resource<br/>from flask_app.scrapy_trigger import ScrapyTrigger<br/>from flask_app.database_dispatcher import DatabaseDispatcher<br/>from flask import session<br/>from flask_app.decorators import login_required<br/>from flask_app.user_input_validator import UserInputValidator<br/><br/><br/>class Incense(Resource):<br/>    __slots__ = ("DEFAULT_HEADERS",)<br/><br/>    def __init__(self):<br/>        self.DEFAULT_HEADERS = {'Content-Type': 'text/html'}<br/><br/>    @login_required<br/>    def get(self):<br/>        rendered_result = render_template("incense.html")<br/>        return make_response(rendered_result, status.HTTP_200_OK, self.DEFAULT_HEADERS)<br/><br/>    @login_required<br/>    def post(self):<br/>        # The page has two options<br/>        # 1. Extract products<br/>        # 2. Show already extracted products<br/>        user_id, form_args = session["user_id"], request.form<br/>        is_extract_args_valid, is_show_args_args_valid = self._put_through_validator(form_args)<br/>        if is_extract_args_valid:<br/>            table_name, scrape = "Table of extracted data", ScrapyTrigger()<br/>            result = scrape.parse_data(form_args["url"], user_id)<br/>            rendered_result = render_template("incense.html", result=result, table_name=table_name)<br/>            return make_response(rendered_result, status.HTTP_200_OK, self.DEFAULT_HEADERS)<br/>        elif is_show_args_args_valid:<br/>            table_name, dispatcher = "Table of already existing data", DatabaseDispatcher()<br/>            result = dispatcher.get_exist_data(form_args, user_id)<br/>            rendered_result = render_template("incense.html", result=result, table_name=table_name)<br/>            return make_response(rendered_result, status.HTTP_200_OK, self.DEFAULT_HEADERS)<br/>        else:<br/>            return {"result": "BAD REQUEST!"}, status.HTTP_400_BAD_REQUEST<br/><br/>    @staticmethod<br/>    def _put_through_validator(form_args):<br/>        validator = UserInputValidator()<br/>        is_extract_args_valid, is_show_args_args_valid = validator.valid_extract_args(form_args), False<br/>        if not is_extract_args_valid:<br/>            is_show_args_args_valid = validator.valid_show_args(form_args)<br/>        return is_extract_args_valid, is_show_args_args_valid</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="bbd0" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.5 用户参数验证</h2><p id="4471" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">因为我们有一个来自用户的 POST 请求，所以我们需要检查他发送的数据。</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="60f2" class="oc kz in ny b be od oe l of og">import re<br/><br/><br/>class UserInputValidator:<br/>    __slots__ = ("RESTRICTED_WORDS",)<br/><br/>    def __init__(self):<br/>        self.RESTRICTED_WORDS = ("drop", "create", "role", "database", "insert", "alter", "select")<br/><br/>    @staticmethod<br/>    def valid_extract_args(args):<br/>        if "url" in args:<br/>            if re.search(r"https?://zamorskiepodarki\.com/uk/.+?/.+?/", args["url"]):<br/>                return True<br/>        return False<br/><br/>    def valid_show_args(self, args):<br/>        if "limit" in args:<br/>            if args["limit"].isnumeric():<br/>                if args.get("category_name"):<br/>                    if self._check_restricted_words(args["category_name"]):<br/>                        return False<br/>                if args.get("title"):<br/>                    if self._check_restricted_words(args["title"]):<br/>                        return False<br/>                return True<br/>        return False<br/><br/>    def _check_restricted_words(self, text):<br/>        for word in self.RESTRICTED_WORDS:<br/>            if word in text.lower():<br/>                return True<br/>        return False</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="1adc" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.6 数据库调度程序</h2><p id="14b0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">此外，我们需要向用户显示提取的数据，并获取用户 id 以将所有提取的产品附加到他身上。那么，让我们创建<strong class="jm io">数据库调度程序</strong>，它将向我们发送我们需要的数据。</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="cf93" class="oc kz in ny b be od oe l of og">import logging<br/>import psycopg2.extras<br/># credentials.py gets credentials from .env<br/>from credentials import HOSTNAME, USERNAME, PASSWORD, DATABASE<br/><br/><br/>class DatabaseDispatcher:<br/>    def get_exist_data(self, filters, user_id) -&gt; list:<br/>        # Returns exists products to user by filters<br/>        where_query_part, limit_query_part = self._build_where_and_limit_query_part(filters, user_id)<br/>        full_query = self._build_full_query(where_query_part, limit_query_part)<br/>        results = self._get_data(full_query)<br/>        return results<br/><br/>    def get_extracted_data(self, limit, user_id) -&gt; list:<br/>        # Returns just extracted products to user<br/>        query = "SELECT * FROM incenses WHERE user_id=%s ORDER BY date_of_parsing DESC LIMIT %s" % (user_id, limit)<br/>        results = self._get_data(query)<br/>        return results<br/><br/>    def get_user(self, user_credentials):<br/>        # Returns user_id to attach extracted products to special user<br/>        query = "SELECT * FROM users WHERE username='%(username)s' AND password='%(password)s'" % user_credentials<br/>        user_credentials = self._get_data(query)<br/>        if not user_credentials:<br/>            result = {"error": {"message": "Credentials are wrong"}}<br/>        else:<br/>            result = {"user_id": user_credentials[0]["id"]}<br/>        return result<br/><br/>    @staticmethod<br/>    def _build_full_query(where_query_part, limit_query_part) -&gt; str:<br/>        # Create query by user's filters<br/>        full_query = "SELECT * FROM incenses %s ORDER BY date_of_parsing DESC %s" \<br/>                     % (where_query_part, limit_query_part)<br/>        full_query = " ".join(full_query.split())<br/>        return full_query<br/><br/>    def _build_where_and_limit_query_part(self, filters, user_id) -&gt; (str, str):<br/>        where_query_part, like_query_part, filters, limit = "", "", {**filters}, None<br/>        for key in filters:<br/>            field = self._get_field(key, filters)<br/>            if key == "limit" and filters[key]:<br/>                limit = filters[key]<br/>                continue<br/>            like_query_part += "%s LIKE %s, " % (key, field) if field else ""<br/>        like_query_part = like_query_part.rstrip(", ")<br/>        like_query_part = " AND %s" % like_query_part if like_query_part else ""<br/>        where_query_part = "WHERE user_id=%s%s" % (user_id, like_query_part)<br/>        limit_query_part = "LIMIT %s" % limit if limit else ""<br/>        return where_query_part, limit_query_part<br/><br/>    @staticmethod<br/>    def _get_field(key, filters) -&gt; str:<br/>        field = None<br/>        if filters[key]:<br/>            field = f"'%{filters[key]}%'"<br/>        return field<br/><br/>    @staticmethod<br/>    def _get_data(query) -&gt; list:<br/>        connection = psycopg2.connect(host=HOSTNAME, user=USERNAME, password=PASSWORD, dbname=DATABASE)<br/>        cur = connection.cursor(cursor_factory=psycopg2.extras.RealDictCursor)<br/>        logging.debug("CONNECTED TO DB")<br/>        cur.execute(query)<br/>        results = cur.fetchall()<br/>        cur.close()<br/>        connection.close()<br/>        return results</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="9878" class="mn kz in bd la mo ou mq ld mr ov mt lg mu ow mw lj mx ox mz lm na oy nc lp nd bi translated">4.<em class="oz">烧瓶+刮刀集成</em></h1><p id="cd37" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">最后，在最后阶段，我们应该<strong class="jm io">将 Flask 集成到 Scrapy </strong>中，根据用户的请求运行一个蜘蛛。<strong class="jm io">触发 Scrapy's spider 的主要工具是钩针库</strong>:</p><pre class="kj kk kl km gt nx ny nz bn oa ob bi"><span id="5212" class="oc kz in ny b be od oe l of og">import time<br/>import crochet # &lt;---<br/>from scrapy import signals<br/>from scrapy.signalmanager import dispatcher<br/>from scrapy.crawler import CrawlerRunner<br/>from incense.spiders.zamorskiepodarki import ZamorskiepodarkiSpider<br/>from flask_app.database_dispatcher import DatabaseDispatcher<br/>from models import IncenseProducts<br/><br/>crochet.setup()  # setting up crochet to execute<br/>CRAWL_RUNNER = CrawlerRunner()  # initialize CrawlerRunner<br/><br/><br/>class ScrapyTrigger:<br/>    def __init__(self):<br/>        self.scrape_complete, self.number_of_items = False, 1<br/><br/>    def parse_data(self, url_to_parse, user_id):<br/>        self.scrape_with_crochet(url_to_parse=url_to_parse, user_id=user_id)<br/>        # Wait until crawling process is finished<br/>        while self.scrape_complete is False:<br/>            time.sleep(5)<br/>        # Get just extracted products from DB<br/>        result = DatabaseDispatcher().get_extracted_data(self.number_of_items, user_id)<br/>        return result<br/><br/>    def crawler_result(self, item):<br/>        # Count extracted products<br/>        self.number_of_items += 1<br/>        # Save extracted product<br/>        save_obj = IncenseProducts()<br/>        save_obj.process_item(item)<br/><br/>    @crochet.run_in_reactor<br/>    def scrape_with_crochet(self, url_to_parse, user_id):<br/>        # Deep to crawler_result func by item scraped signal<br/>        dispatcher.connect(self.crawler_result, signal=signals.item_scraped)<br/>        # Trigger spider and send url to parse data from<br/>        eventual = CRAWL_RUNNER.crawl(ZamorskiepodarkiSpider, url_to_parse=url_to_parse, user_id=user_id)<br/>        # Deep to finished_scrape when all requests are crawled<br/>        eventual.addCallback(self.finished_scrape)<br/>        return eventual<br/><br/>    def finished_scrape(self, *args, **kwargs):<br/>        self.scrape_complete = True</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="e5f9" class="mn kz in bd la mo ou mq ld mr ov mt lg mu ow mw lj mx ox mz lm na oy nc lp nd bi translated">5.结果</h1><p id="8811" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">这个项目已经完成，可以使用了。让我们运行并测试它！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi pc"><img src="../Images/3e6ffb55d138f674f4b3276e08b64b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0DJff8Us4xRpMLPb"/></div></div></figure><h1 id="6643" class="mn kz in bd la mo mp mq ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd bi translated">6.结论</h1><p id="b5e7" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh ig bi translated">让我们看看你会得到什么结果。<br/>现在你知道如何使用:</p><ol class=""><li id="5dea" class="lr ls in jm b jn jo jr js jv pd jz pe kd pf kh ly lz ma mb bi translated">PostgreSQL 数据库并创建查询</li><li id="81a3" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated">整理和解析数据</li><li id="65c1" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated">烧瓶和构建后端</li><li id="d53d" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated">前端并将其连接到后端</li><li id="f8fa" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated">钩针和集成刮刀+烧瓶</li><li id="8915" class="lr ls in jm b jn md jr me jv mf jz mg kd mh kh ly lz ma mb bi translated">模型和集成 Flask + PostgreSQL</li></ol><p id="19a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">附:如果你喜欢这篇文章，</em> <a class="ae kq" href="https://medium.com/@vlad.bashtannyk" rel="noopener"> <em class="mc">关注我</em> </a>，<em class="mc">点击几次“鼓掌”，然后</em> <em class="mc">留下反馈。祝你好运，高效编程！谢谢大家！</em></p><p id="31b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关注我上<a class="ae kq" href="https://www.linkedin.com/in/vladyslav-bashtannyk/" rel="noopener ugc nofollow" target="_blank"><em class="mc">LinkedIn</em></a><em class="mc"/>和<em class="mc"/><a class="ae kq" href="https://github.com/flyosprey" rel="noopener ugc nofollow" target="_blank"><em class="mc">GitHub</em></a>！</p></div></div>    
</body>
</html>