<html>
<head>
<title>Typetta | The TypeScript ORM for type lovers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typetta |打字爱好者的打字格式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typetta-470c627631af?source=collection_archive---------13-----------------------#2022-01-17">https://blog.devgenius.io/typetta-470c627631af?source=collection_archive---------13-----------------------#2022-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9899" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://twinlogix.github.io/typetta/" rel="noopener ugc nofollow" target="_blank"> Typetta </a>是一个用TypeScript编写的<strong class="jm io">开源ORM </strong>，旨在允许以类型化的方式无缝访问所有<strong class="jm io">主要SQL数据库</strong> (MySQL、PostgreSQL、Microsoft SQL Server、SQLLite3、CockroachDB、MariaDB、Oracle e Amazon Redshift)以及NoSQL数据库<strong class="jm io"> MongoDB </strong>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/c13decfb4d018fe4c41215ef342e48b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESVAauXdg_HhSqMw6pPb2A.png"/></div></div></figure><p id="b10d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta可插入任何TypeScript后端(包括无服务器应用程序和微服务)，但就收益而言，我们完全建议在所有<strong class="jm io"> GraphQL </strong>后端中使用它，因为……因为我们就是喜欢GraphQL。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="4d23" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我如何使用Typetta？</h1><p id="a185" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">使用Typetta，一切都围绕着数据模型、描述应用程序域的实体以及它们之间的所有底层关系。这个模型用标准的GraphQL描述，使用了所有的基本概念(标量、类型、枚举等)和一些自定义指令。</p><p id="9e0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从领域分析的模型输出开始，Typetta提供了一系列代码生成器，用于:</p><ul class=""><li id="732c" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">模型中每个实体的TypeScript语言类型定义。</li><li id="55a6" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">每个实体类型的数据访问对象(又名DAO ),它有一个相应的数据源。每个DAO都是一个对象，开发人员也可以使用高级CRUD操作对其进行查询。</li><li id="2efc" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">DAOContext是一个上下文对象，开发人员可以在其中配置每个数据源并检索任何DAO的引用。主要功能</li></ul></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="ba1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是对Typetta令人敬畏之处的简要描述:</p><ul class=""><li id="5a65" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">完全支持主要的SQL数据库和MongoDB。</li><li id="1193" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">多个数据库，包括交叉查询不同数据库的能力。</li><li id="439a" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">多重连接和连接池。</li><li id="40ce" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">实体关系:一对一，一对多，多对多。</li><li id="ded9" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">动态类型和相应的数据投影。</li><li id="f36e" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">分页。</li><li id="3696" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">可以使用中间件进行扩展。</li><li id="0cd7" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">数据库的定制标量和序列化。</li><li id="2e41" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">自动生成的id。</li><li id="ba0b" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">验证规则。</li><li id="f3ac" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">虚拟字段、计算字段和计算字段。</li><li id="ea38" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">聚合查询。</li><li id="58e1" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">能够构建自定义查询。</li><li id="8d5e" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">定义数据访问安全策略。</li><li id="6301" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">MongoDB和SQL都支持嵌入式文档。</li><li id="5216" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">自动化代码生成。</li><li id="da6f" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">轻松集成GraphQL后端。</li><li id="b4e1" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">交易。</li><li id="4e35" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">伐木。</li><li id="ddea" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">嘲讽。</li><li id="a1d5" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">审计。</li><li id="bc2c" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">多租户分区。</li><li id="d1d2" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">软删除。</li></ul></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="d1c1" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么是泰佩塔？</h1><p id="1ca5" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">Typetta满足了一个连接到SQL和NoSQL数据库的类型化ORM的需求，它的设计考虑了生产率和灵活性。</p><p id="0b01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta组件背后的理念是确保易用性和开发时间的优化，仅在严格需要时增加复杂性(直接访问数据源)。</p><p id="8f8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">万一你还不确定，为什么用Typetta而不用其他ORM呢？</p><ul class=""><li id="810b" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">它是唯一完全支持SQL和MongoDB数据库的TypeScript ORM。</li><li id="4afb" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">一个非常<strong class="jm io">严格的类型化</strong>系统，100%利用TypeScript根据请求的数据类型提供类型作为响应。</li><li id="163f" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">使用标准的<strong class="jm io"> GraphQL </strong>，你可以定义模型。使用该标准为基于该标准的一整套工具和第三方框架打开了大门。</li></ul></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="5466" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">入门指南</h1><p id="4d5a" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">Typetta是一个很小的包，可以使用npm安装在任何TypeScript项目上。唯一的显式依赖项是GraphQL。两者都可以非常简单地使用npm添加到项目中:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="f72b" class="my ld in mu b gy mz na l nb nc">npm install <a class="ae ki" href="http://twitter.com/twinlogix/typetta" rel="noopener ugc nofollow" target="_blank">@twinlogix/typetta</a> — save</span></pre><h2 id="9313" class="my ld in bd le nd ne dn li nf ng dp lm jv nh ni lq jz nj nk lu kd nl nm ly nn bi translated"><strong class="ak">项目结构</strong></h2><p id="2da7" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">Typetta不依赖于特定的项目结构，因此是完全可配置的。对于我们的示例，我们可以考虑使用如下的TypeScript项目结构:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="6304" class="my ld in mu b gy mz na l nb nc">MyProject<br/> ┣ src<br/> ┃ ┗ index.ts <br/> ┣ package.json<br/> ┗ tsconfig.json</span></pre><p id="c7fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您需要做的就是用GraphQL语言添加一个应用模型，通常可以在src目录下的一个名为<em class="no"> schema.graphql </em>的文件中找到，也可以在根目录下的一个名为<em class="no"> codegen.yml </em>的配置文件中找到，用于代码生成。</p><p id="bbcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新后的项目结构如下:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="edf4" class="my ld in mu b gy mz na l nb nc">MyProject<br/> ┣ src<br/> ┃ ┣ <strong class="mu io">schema.graphql</strong><br/> ┃ ┗ index.ts <br/> ┣ package.json<br/> ┣ tsconfig.json<br/> ┗ <strong class="mu io">codegen.yml</strong></span></pre><h2 id="4c03" class="my ld in bd le nd ne dn li nf ng dp lm jv nh ni lq jz nj nk lu kd nl nm ly nn bi translated"><strong class="ak">数据模型</strong></h2><p id="2ebf" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">在文件<em class="no"> schema.graphql </em>中，你必须用graphql语言插入应用模型。有关完整的GraphQL语法指南，请直接参考官方网站<a class="ae ki" href="http://graphql.org" rel="noopener ugc nofollow" target="_blank">graphql.org</a>。</p><p id="e8e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta依靠定制的指令来扩展标准模型定义，允许开发人员在绑定到数据源时指定非常有用的细节。</p><p id="af3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面你可以看到一个用户的简单定义，包括名字和姓氏。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="8f4f" class="my ld in mu b gy mz na l nb nc">type User @entity <a class="ae ki" href="http://twitter.com/mongoEntity" rel="noopener ugc nofollow" target="_blank">@mongo</a> {<br/>  id: ID! <a class="ae ki" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a><br/>  firstName: String<br/>  lastName: String<br/>}</span></pre><h2 id="7cf0" class="my ld in bd le nd ne dn li nf ng dp lm jv nh ni lq jz nj nk lu kd nl nm ly nn bi translated"><strong class="ak">代码生成</strong></h2><p id="687b" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">使用Typetta，使用GraphQL之类的标准语言来建模应用程序使开发人员能够使用许多第三方工具和库。因此，开发应用程序变得更快、更有成效。</p><p id="b730" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta中的代码生成依赖于<a class="ae ki" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>，这是一个非常可定制和可扩展的库。GraphQL代码生成器使开发人员能够从许多标准生成器以及我们的嵌入式生成器中进行选择，后者自动提供了TypeScript语言中的DAO。</p><p id="6227" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typetta已经包含了使用TypeScript生成器的所有默认依赖项，但是也可以按照官方指南添加其他生成器。</p><p id="9c4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是时候用最少的努力来配置我们的第一个<em class="no"> codegen.yml </em>了。此操作将启用代码生成。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="88f0" class="my ld in mu b gy mz na l nb nc">schema: "src/schema.graphql"<br/>generates:<br/>   src/models.ts:<br/>     plugins:<br/>       — "typescript"<br/>   src/dao.ts:<br/>     config:<br/>       schemaImport: "./schema.graphql"<br/>       tsTypesImport: "./models"<br/>     plugins:<br/>       — "<a class="ae ki" href="http://twitter.com/twinlogix/typetta" rel="noopener ugc nofollow" target="_blank">@twinlogix/typetta</a>"</span></pre><p id="fbed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了允许代码生成，还可以编辑package.json文件，插入以下脚本:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="2de8" class="my ld in mu b gy mz na l nb nc">{<br/>  "scripts": {<br/>    "generate": "graphql-codegen"<br/>  }<br/>}</span></pre><p id="74fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们运行以下命令，进行第一次代码生成:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="af1e" class="my ld in mu b gy mz na l nb nc">npm run generate</span></pre><p id="817e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上面的设置，代码生成命令将创建两个文件:<em class="no"> src/models.ts </em>包含所有包含在<em class="no"> schema.graphql </em>中的类型脚本类型，另一个文件<em class="no"> src/dao.ts </em>包含dao和DAOContext。这两个文件以后会有用的。</p><h2 id="4d62" class="my ld in bd le nd ne dn li nf ng dp lm jv nh ni lq jz nj nk lu kd nl nm ly nn bi translated"><strong class="ak">一个简单的应用</strong></h2><p id="0a81" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">下面的初始Typetta示例在MongoDB数据库上读写一个实体(在ab SQL DB上几乎是一样的)。这个例子和其他例子可以在一个<a class="ae ki" href="https://github.com/twinlogix/typetta-examples" rel="noopener ugc nofollow" target="_blank">专用存储库</a>中找到。</p><p id="2be5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先…使用官方驱动程序打开到MongoDB数据库的连接:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="85c7" class="my ld in mu b gy mz na l nb nc">import { MongoClient } from 'mongodb';<br/>import { DAOContext } from './dao';</span><span id="1fec" class="my ld in mu b gy np na l nb nc">const main = async () =&gt; {<br/>  const mongoConnection = <br/>     await MongoClient.connect(process.env.MONGODB_URL!);<br/>  const mongoDb =<br/>     mongoConnection.db(process.env.MONGODB_DATABASE_NAME);<br/>};<br/>main();</span></pre><p id="2e94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们做我们的第一个DAOContext，我们的第一个Typetta代码生成的类。此类代表应用模型的所有实体的中央报告。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="f819" class="my ld in mu b gy mz na l nb nc">const daoContext = new DAOContext({<br/>  mongo: {<br/>    default: mongoDb<br/>  }<br/>});</span></pre><p id="5297" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是时候对用户实体进行第一次CRUD简单操作了。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="1e28" class="my ld in mu b gy mz na l nb nc">const user1 = await daoContext.user.insertOne({<br/>  record: {<br/>    firstName: "Mattia",<br/>    lastName: "Minotti"<br/>  }<br/>});</span><span id="4bb5" class="my ld in mu b gy np na l nb nc">const user2 = await daoContext.user.insertOne({<br/>  record: {<br/>    firstName: "Edoardo",<br/>    lastName: "Barbieri"<br/>  }<br/>});</span><span id="6810" class="my ld in mu b gy np na l nb nc">const users = await daoContext.user.findAll();<br/>users.forEach(user =&gt; <br/>  console.log(`${user.firstName} ${user.lastName}`)<br/>);</span></pre><p id="6536" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们个人版本的Hello World示例将在控制台上打印以下两个名称:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="12dd" class="my ld in mu b gy mz na l nb nc">Mattia Minotti<br/>Edoardo Barbieri</span></pre><p id="9288" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是连接到MongoDB的初始Typetta示例的完整源代码:</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="53ee" class="my ld in mu b gy mz na l nb nc">import { MongoClient } from 'mongodb';<br/>import { DAOContext } from './dao';</span><span id="b5dc" class="my ld in mu b gy np na l nb nc">const main = async () =&gt; {</span><span id="ce21" class="my ld in mu b gy np na l nb nc">  const mongoConnection = <br/>    await MongoClient.connect(process.env.MONGODB_URL!);<br/>  const mongoDb = <br/>    mongoConnection.db(process.env.MONGODB_DATABASE_NAME);</span><span id="c2cd" class="my ld in mu b gy np na l nb nc">  const daoContext = new DAOContext({<br/>    mongo: {<br/>      default: mongoDb<br/>    }<br/>  });</span><span id="1cc7" class="my ld in mu b gy np na l nb nc">  const user1 = await daoContext.user.insertOne({<br/>    record: {<br/>      firstName: "Mattia",<br/>      lastName: "Minotti"<br/>    }<br/>  });</span><span id="c6dc" class="my ld in mu b gy np na l nb nc">  const user2 = await daoContext.user.insertOne({<br/>    record: {<br/>      firstName: “Edoardo”,<br/>      lastName: “Barbieri”<br/>    }<br/>  });</span><span id="bbc9" class="my ld in mu b gy np na l nb nc">  const users = await daoContext.user.findAll();<br/>  users.forEach(user =&gt; <br/>    console.log(`${user.firstName} ${user.lastName}`)<br/>  );<br/>};</span><span id="a87f" class="my ld in mu b gy np na l nb nc">main();</span></pre></div></div>    
</body>
</html>