<html>
<head>
<title>Like Regular LINQ, but Faster and Without Allocations: Is It Possible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像普通的LINQ，但是更快并且没有分配:可能吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/like-regular-linq-but-faster-and-without-allocations-is-it-possible-3d4724632e2a?source=collection_archive---------1-----------------------#2022-01-03">https://blog.devgenius.io/like-regular-linq-but-faster-and-without-allocations-is-it-possible-3d4724632e2a?source=collection_archive---------1-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a5e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好，我的小鸭子们！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83b2c3b64a59149ae79e418277c29352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjzCXRSmBoRBjm3ANP2iTA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">LINQ的一个变种能让我们变得多有效率</figcaption></figure><p id="ce6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们大多数人不喜欢LINQ吗？基础类库的神奇之处在于。NET是今天发布的，它允许以声明的方式处理序列。然而，如果我们做一个“更好”的版本呢？</p><p id="09d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于不耐烦的人:<a class="ae ky" href="https://github.com/asc-community/HonkPerf.NET" rel="noopener ugc nofollow" target="_blank"> github </a>。</p><h1 id="53e1" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">简而言之，关于Linq如何工作</h1><p id="42e0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">简而言之，LINQ只是IEnumerable <t>接口上的一组扩展方法。每一种方法都在前一个序列之上创建另一个“层”，添加新的条件或该序列元素的变换。例如，Select <a class="ae ky" href="https://source.dot.net/#System.Linq/System/Linq/Select.cs,13" rel="noopener ugc nofollow" target="_blank">创建</a> SelectEnumerableIterator并返回它(除非其他优化技巧完成了它们的工作)。</t></p><p id="559d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当对用这些方法创建的序列进行foreach时，都要创建一个枚举数，并逐步使用它。以下是foreach是如何降低的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/1c12a888a06c9fb7e0880528e758e94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuD4iOuLsYaNGc1rj0SvPw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Roslyn将foreach扩展到与状态机同步</figcaption></figure><p id="3a8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是foreach的精确扩展，如果你想知道那里到底发生了什么，请访问sharplab。</p><p id="2f68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在… that和其他迭代器都是类，这意味着每次你调用Select/Where或其他LINQ方法时，都会在托管堆上创建一个引用类型的新实例，增加GC压力。GC在。但有时这些分配是不需要的。此外，当这些迭代器运行时(当您执行一个<em class="md">活动的</em>动作时，例如Count()、Sum()或用foreach遍历它)，由于一个虚拟调用(对接口的调用)而创建了一个间接层。</p><h1 id="6a9e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">让我们做我们的Linq</h1><p id="2f77" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这里的想法是，我们将有一个更复杂的类型，它将累积所有迭代器和所有查询，而不是一个单一的公共接口，每个新实例都被向上转换到这个接口中。</p><p id="3c8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们要做的就是存储之前的迭代器，而不是当前的迭代器。方法是泛型。哦，是的，我喜欢泛型，你可能已经猜到了我的<a class="ae ky" href="https://itnext.io/stay-safe-with-your-units-advanced-units-of-measure-in-net-f7d8b02af87e?source=user_profile---------0-------------------------------" rel="noopener ugc nofollow" target="_blank">前一篇文章</a>。这一次我们将把前面迭代器的类型设为类型参数。方法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/87e1b7bce521c18f5396f2a29b2e6468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlITr3YLIWHdBcwvU8XSWw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">枚举器在其内部保存前一个枚举器</figcaption></figure><p id="6c37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在TEnumerator是前面的枚举器本身，因为它是一个结构体。那么，我们如何做出选择呢？让我们首先创建SelectEnumerator:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/0b0351399915d56defa1b63081ccd14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNVm4aQ2QDWMWmDcQu9hWw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">选择枚举器声明</figcaption></figure><p id="6d24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，它保存了以前的枚举数和一个委托，后者从T映射到U(例如，从int映射到string)。此枚举数循环访问上一个枚举数，并将Current设置为新值(通过委托映射的上一个枚举数的值)。TDelegate是委托的类型参数，因此如果想避免调用，可以在其中传递一个值委托。</p><p id="16fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，Select方法本身只是创建了枚举器。你知道，LINQ工作<em class="md">懒散</em>，我们的RefLinq也是。我们只是创建一个枚举器并返回它——它将按需运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/2b2b2f1e06336fdc832eff7e4f8d0749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOZCKg_VO6Piv6JFZGCNNQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">返回值类型选择的新实例</figcaption></figure><p id="add1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与我们创建Where和其他枚举器的方式相同。现在，就像我说的，枚举器在里面保存前一个。让我们看看我们得到的实际类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/b4877223aa1bddc9bc82a9fdca7e08ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*6F4HLsReD_ON3a52OiT1NQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">相互嵌入的枚举器</figcaption></figure><p id="6db0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，最里面的是ArrayEnumerator，它嵌入到Select中，最外面的是Where。Select有一个从int到int的纯值委托，同样有一个从int到bool的委托(谓词)。</p><p id="3b8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们没有一个公共的接口，把我们所有的迭代器向上转换到这个接口中，就像经典的LINQ那样，我们在每次操作中都创建一个新的类型，所以没有堆分配，绝对没有！</p><p id="abdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，由于没有虚拟调用，并且所有方法都是在编译时确定的，所以它们中的许多都被内联，从而提高了性能。这就是为什么这样的实现也会更快！</p><h1 id="d12f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么LINQ不这样实施呢？</h1><p id="3248" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">因为LINQ的实施要普遍得多。让我回顾一下我们在实施过程中遇到的所有问题。</p><h2 id="e5ec" class="mh la in bd lb mi mj dn lf mk ml dp lj jv mm mn ln jz mo mp lr kd mq mr lv ms bi translated">问题1。复制是昂贵的</h2><p id="d441" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这意味着，我们永远不能将我们的结构装入接口/对象。这反过来意味着，将我们的序列传递给一个方法或从该方法返回会对性能产生巨大的影响。要通过复制传递该结构，需要将整个结构复制到被调用的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/1b5c01c0965d65015cbb0b4a45bd73d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKdV4uwTNymlItqhnUwtqA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">复制巨大的结构是昂贵的</figcaption></figure><p id="4124" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，这种传递引入了一大堆指令来移动复制内存以将其传递给DoThings！</p><h2 id="f5c9" class="mh la in bd lb mi mj dn lf mk ml dp lj jv mm mn ln jz mo mp lr kd mq mr lv ms bi translated">问题二。没有通用类型—能力有限</h2><p id="ae3d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在常规Linq中，我们可以有条件地向序列中添加一个新的“层”或覆盖它，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a2654bf7337030f633a33c5ed3584f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*gzIIU2OIOdyXnPM8JWaPDw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Linq更有能力</figcaption></figure><p id="9d7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经典的Linq有通用的引用类型IEnumerable <t>，由于虚拟调用，实际的底层类型可以是任何类型！</t></p><p id="074b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但我们的情况不是这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6d3335a1ebe10a1caaf53eea4b3fcfab.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*8Nr7hMOMFSZsGc_DW-fSjQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不能将新序列的类型装入旧序列</figcaption></figure><p id="a4ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为它都是值类型，没有抽象接口，我们不能把这个新序列装进旧序列。</p><h2 id="60e5" class="mh la in bd lb mi mj dn lf mk ml dp lj jv mm mn ln jz mo mp lr kd mq mr lv ms bi translated">问题三。并不是所有的Linq方法都只能使用堆栈</h2><p id="f173" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">例如，SkipLast需要存储一个元素缓冲区，以确保我们不会访问不需要的元素，同时，访问其他元素不会超过一次。</p><p id="a25f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有找到任何安全的好方法。动态分配堆栈内存的唯一方法是<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc" rel="noopener ugc nofollow" target="_blank"> stackalloc </a>，但是必须在用户端完成，同时用户还要手动传递缓冲区的大小给它。那就扼杀了linq的目的。</p><h2 id="d95c" class="mh la in bd lb mi mj dn lf mk ml dp lj jv mm mn ln jz mo mp lr kd mq mr lv ms bi translated">问题4。渴望堆栈内存</h2><p id="3321" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">大多数时候，人们只关心堆内存，这是绝对公平的。但是在这种罕见的情况下，我还注意了堆栈上分配的内存量——因为它是一个巨大的结构，还记得吗？它会吃很多很多。</p><p id="21d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用我自己的alpha版本<a class="ae ky" href="https://github.com/WhiteBlackGoose/CodegenAnalysis" rel="noopener ugc nofollow" target="_blank"> CodegenAnalysis工具</a>我检查了堆栈分配内存的数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/e419e8f3a507697f7bcdd3c519212803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoV8qNV2FmUBDukH1lZljA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">分析堆栈分配的内存</figcaption></figure><p id="1c9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">堆栈上分配的288 </strong>字节。它只是选择和在哪里！对于长而复杂的查询，它可以是千字节。(注意，这个大小并不<em class="md">而</em>取决于输入的大小，因为它都是枚举器)</p><h1 id="bff3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">有人需要吗？</h1><p id="7ead" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">有，但是不多。游戏开发人员、系统程序员或那些场景完全符合lib用例的人可能需要它(也就是说，不返回/传递那些枚举器，使用一些需要缓冲区的方法，等等)。).</p><p id="433a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，我所做的作为一个想法绝对不是新的，我只是描述了它是如何工作的，它有多有用或没有用。有很多其他的库也有同样的用途:NoAlloq、LinqFaster、Hyperlinq、ValueLinq、LinqAF、StructLinq。他们彼此都有一点不同，但或多或少遵循相同的想法。</p><h1 id="db86" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="7e9b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我实现了<a class="ae ky" href="https://github.com/asc-community/HonkPerf.NET/tree/main/Sources/HonkPerf.NET.RefLinq/Extensions" rel="noopener ugc nofollow" target="_blank">所有的方法，但只有</a>方法只能被堆栈化。要将性能特征与其他库进行比较，请参考<a class="ae ky" href="https://github.com/asc-community/HonkPerf.NET" rel="noopener ugc nofollow" target="_blank">报告</a>的<a class="ae ky" href="https://github.com/asc-community/HonkPerf.NET#benchmarks" rel="noopener ugc nofollow" target="_blank">基准</a>部分。</p><p id="299d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，最终，与手动实现的状态机相比，这种实现的开销要低得多，甚至为零(for循环会更快)。没有虚拟调用，也没有堆分配。</p><p id="7cf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是它有许多负面影响:没有可向上转换的公共类型，一些方法无法实现，复制开销很大，等等。</p><p id="65ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我宣布经典Linq在这里胜出。然而，我仍然认为这篇文章是有用的——在某种意义上，是的，没有比内置linq更好的linq，但有一种方法可以让它更好地用于一些利基场景。</p><p id="c027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的关注！我的<a class="ae ky" href="https://github.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> github </a>，<a class="ae ky" href="https://twitter.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> twitter </a>。</p><p id="5223" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(我用<a class="ae ky" href="https://github.com/dotnet/BenchmarkDotNet" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>分析性能，用<a class="ae ky" href="https://github.com/WhiteBlackGoose/CodegenAnalysis" rel="noopener ugc nofollow" target="_blank"> CodegenAnalysis </a>分析JIT的asm codegen。截图是用仙女座色主题的VS代码做的)</p></div></div>    
</body>
</html>