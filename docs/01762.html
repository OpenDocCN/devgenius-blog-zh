<html>
<head>
<title>Ruby: Destructive vs. Non-destructive Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby:破坏性方法与非破坏性方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-destructive-vs-non-destructive-methods-70a5505a391a?source=collection_archive---------2-----------------------#2020-07-11">https://blog.devgenius.io/ruby-destructive-vs-non-destructive-methods-70a5505a391a?source=collection_archive---------2-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6200bc51ca4327bef729366be1cf1e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ar36Tugc1haDTz0m"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">奥斯卡·伊尔迪兹在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="00fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我想谈谈 Ruby 中的破坏性和非破坏性方法。为了做到这一点，我们需要理解什么是对象 id。Ruby 中的每个对象都有一个唯一的标识符，称为对象 id。这可以通过在对象上调用#object_id 方法来访问。对于不可变的对象，如整数和符号，与对象 id 相关联的值不能改变。例如:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="7aae" class="lm ln iq li b gy lo lp l lq lr">Output:</span><span id="56fd" class="lm ln iq li b gy ls lp l lq lr">x = 2</span><span id="fcae" class="lm ln iq li b gy ls lp l lq lr">Object_id = 5</span><span id="523e" class="lm ln iq li b gy ls lp l lq lr">x = 6</span><span id="5f9b" class="lm ln iq li b gy ls lp l lq lr">Object_id = 13</span></pre><p id="1600" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，变量<strong class="kf ir"> x </strong>被初始化为 2，其对象 id 为<strong class="kf ir"> 5。然后，我们加上 4，这样<strong class="kf ir"> x </strong>等于 6。对象 id 现已更改为<strong class="kf ir"> 13 </strong>。这是因为在第 4 行，我们将<strong class="kf ir"> x </strong>重新分配给<strong class="kf ir"> x + 4 </strong>或 6。在 Ruby 中，整数是不可变的，这意味着它们不能改变。因此，如果不改变对象 id，就不可能改变<strong class="kf ir"> x </strong>的值。符号也是如此。但是字符串、数组和散列是可变的，这意味着它们可以被改变。例如:</strong></p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="f445" class="lm ln iq li b gy lo lp l lq lr">Output:</span><span id="ac6a" class="lm ln iq li b gy ls lp l lq lr">string = Hello</span><span id="a9c6" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70331830343140</span><span id="5f5b" class="lm ln iq li b gy ls lp l lq lr">string = Hello World</span><span id="594b" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70331830343140</span></pre><p id="61f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们改变了字符串变量的值，但是保持对象 id 不变。这是因为<strong class="kf ir"> # &lt; &lt; </strong>方法改变了它所调用的对象，而不是将变量重新分配给一个新的对象。</p><p id="7162" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经讨论了对象 id，我们可以定义一个破坏性的方法。在 Ruby(和其他语言)中，破坏性方法是一种变异它所调用的对象的方法。例如，上一个示例中的<strong class="kf ir"> # &lt; &lt; </strong>方法是一个破坏性方法，因为它变异了调用它的字符串对象。这是另一个使用数组的破坏性方法的例子。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="e50b" class="lm ln iq li b gy lo lp l lq lr">Output: </span><span id="0996" class="lm ln iq li b gy ls lp l lq lr">array = [4, 2, 3, 1, 5]</span><span id="8595" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70141400757740</span><span id="331c" class="lm ln iq li b gy ls lp l lq lr">array = [1, 2, 3, 4, 5]</span><span id="8994" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70141400757740</span></pre><p id="6fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意“！”<strong class="kf ir">#排序结束！</strong>方法。这表明这种方法是破坏性的。许多破坏性方法都有一个“！”最后，但不是所有人都这样做，请务必检查文档。文档用小箭头表示方法的返回值。点击<a class="ae kc" href="https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-sort" rel="noopener ugc nofollow" target="_blank">这个链接</a>明白我的意思。非破坏性的<strong class="kf ir"> #sort </strong>方法显示返回‘new _ ary’，而破坏性的<strong class="kf ir"> #sort！</strong>方法只显示' ary '被返回。需要注意的是，你不能只加一个“！”让它具有破坏性的方法。这是以不同方式实现的两个独立的方法，并非所有方法都有这两种实现。现在，让我们看看非破坏性方法是如何工作的。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="ad0f" class="lm ln iq li b gy lo lp l lq lr">Output:</span><span id="e1b8" class="lm ln iq li b gy ls lp l lq lr">array = [4, 2, 3, 1, 5]</span><span id="c3b0" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70101328557600</span><span id="0629" class="lm ln iq li b gy ls lp l lq lr">array = [4, 2, 3, 1, 5]</span><span id="7831" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70101328557600</span></pre><p id="970f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且…看起来好像什么都没发生。实际上，尽管如此，<strong class="kf ir"> #sort </strong>方法还是像预期的那样工作。因为它不是一个破坏性的方法，所以它返回一个新的排序数组，而不是改变原始数组。然而，我们没有捕获返回值，这使得我们的代码实际上毫无用处。以下是我们可以做的。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="8daa" class="lm ln iq li b gy lo lp l lq lr">Output: </span><span id="283a" class="lm ln iq li b gy ls lp l lq lr">array = [4, 2, 3, 1, 5]</span><span id="0416" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70267318031780</span><span id="bcb2" class="lm ln iq li b gy ls lp l lq lr">array = [4, 2, 3, 1, 5]</span><span id="717d" class="lm ln iq li b gy ls lp l lq lr">sorted_array = [1, 2, 3, 4, 5]</span><span id="2d4d" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70267318031460</span></pre><p id="5427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次我们在一个名为<strong class="kf ir"> sorted_array </strong>的变量中捕获了返回值。这是一个具有自己的对象 id 的新对象，如输出的最后一行所示。现在我们已经看到了 Ruby 中一些内置的破坏性和非破坏性方法，让我们试着创建自己的方法。你认为下面的代码会输出什么？</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="be54" class="lm ln iq li b gy lo lp l lq lr">Output: </span><span id="2798" class="lm ln iq li b gy ls lp l lq lr">Hello</span><span id="6621" class="lm ln iq li b gy ls lp l lq lr">Hello</span></pre><p id="ce1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序输出“Hello”两次，因为我们的方法实际上并没有改变字符串。相反，它会将其重新分配给一个新字符串“Hello World”因为我们没有捕获方法的返回值，所以我们看不到任何变化。对代码进行快速更新可以解决这个问题。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="2595" class="lm ln iq li b gy lo lp l lq lr">Output: </span><span id="13e1" class="lm ln iq li b gy ls lp l lq lr">Hello</span><span id="db77" class="lm ln iq li b gy ls lp l lq lr">Object id = 70312641836240</span><span id="1de7" class="lm ln iq li b gy ls lp l lq lr">Hello World</span><span id="88ec" class="lm ln iq li b gy ls lp l lq lr">Object id = 70312641836240</span></pre><p id="497f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的方法是破坏性的，它改变了我们传递给它的字符串。这是因为我们在自定义方法中使用了破坏性的<strong class="kf ir"> # &lt; &lt; </strong>方法。我们可以通过检查对象 id 是否仍然相同来确认这一点。一般来说，如果我们在自定义方法中调用一个破坏性方法，那么自定义方法也将是破坏性的。然而，也有一些例外。看看下面的例子。在向下滚动之前，尝试猜测它将输出什么。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="3dc1" class="lm ln iq li b gy lo lp l lq lr">Output:</span><span id="1701" class="lm ln iq li b gy ls lp l lq lr">Hello</span><span id="7dd3" class="lm ln iq li b gy ls lp l lq lr">Hello</span></pre><p id="cdab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个有点棘手，让我们把它分成小块。首先，我们将变量<strong class="kf ir">字符串</strong>初始化为“Hello”。然后我们定义<strong class="kf ir">问候</strong>的方法。之后，我们调用<strong class="kf ir">字符串</strong>上的方法。在我们方法的第一行，我们将变量<strong class="kf ir">字符串</strong>重新赋值为“Hello goodbye”。这意味着当我们在方法的第二行调用破坏性方法<strong class="kf ir"> # &lt; &lt; </strong>时，我们是在新对象“Hello goodbye”上调用它。正因为如此，我们原来的字符串没有改变。这可以通过对象 id 更清楚地显示出来。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="a545" class="lm ln iq li b gy lo lp l lq lr">Output: </span><span id="6523" class="lm ln iq li b gy ls lp l lq lr">Hello</span><span id="e71c" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70260376327360</span><span id="9b00" class="lm ln iq li b gy ls lp l lq lr">Object_id = 70260376327160</span><span id="a55f" class="lm ln iq li b gy ls lp l lq lr">Hello</span></pre><p id="dbcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，在我们将字符串重新赋值为“hello goodbye”之后，对象 id 发生了变化。</p><p id="be8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你现在对破坏性和非破坏性方法有了更好的理解。学习这个概念是很重要的，这样你就能理解什么时候你可以调用一个方法，什么时候你需要获取返回值。当你的程序产生意想不到的结果时，它还可以帮助你追踪错误。感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>