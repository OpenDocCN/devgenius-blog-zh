<html>
<head>
<title>Compiling C/C++ : Notes/Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译 C/C++:注意事项/技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/compiling-c-c-notes-tips-8215b82d4a4b?source=collection_archive---------12-----------------------#2022-01-18">https://blog.devgenius.io/compiling-c-c-notes-tips-8215b82d4a4b?source=collection_archive---------12-----------------------#2022-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/925839a43e8016ac736a116dd4a4372a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Raq1b773AyJilk6De359wA.png"/></div></div></figure><p id="356f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说到性能，C 和 C++甚至在今天都是无与伦比的。它们是编译语言，用 C 或 c++编写的代码需要用特定于平台的工具针对给定平台进行编译，这个过程或针对给定平台的编译称为交叉编译。作为一名开发人员，仅仅知道这种漂亮的语言的语法和语义是不够的，还必须知道编译中发生了什么，以及编译是如何进行的。</p><p id="189d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有各种供应商提供 C/C++编译器和各种工具。在本文中，我们将介绍编译过程、一些重要的工具、它们的用法和一些调试技巧。</p><p id="23da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">典型的 C/C++项目有两种类型的文件:</p><ul class=""><li id="1d7e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">头文件(文件扩展名为<code class="fe lc ld le lf b">.h/.hxx/.hpp</code>)和</li><li id="ea1b" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated">源文件(文件扩展名为<code class="fe lc ld le lf b">.c/.cxx/.cpp/.cc</code>)。</li></ul><p id="505c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">C 和 C++是两种不同的语言，因此避免混合使用，但是如果项目需要，通常的经验法则是将 C 文件扩展名命名为<code class="fe lc ld le lf b">.h and .c</code>，而 C++ <code class="fe lc ld le lf b">.hpp and .cpp</code></p><p id="ca12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从文件名为<code class="fe lc ld le lf b">hello_cpp.cpp</code>的一段 C++代码开始:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="f3e8" class="lt lu in lf b gy lv lw l lx ly"><strong class="lf io">#include &lt;iostream&gt;</strong><br/><br/><strong class="lf io">int</strong> <strong class="lf io">main</strong>(<strong class="lf io">int</strong> argc, <strong class="lf io">char</strong>* argv[]) <br/>{<br/>    std::cout &lt;&lt; "<!-- -->Hello C Plus Plus!" <!-- -->&lt;&lt; std::endl;<br/>    <strong class="lf io">return</strong> 0;<br/>}</span></pre><p id="572c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的构建平台是 Darwin(苹果 MacOS)</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="52f6" class="lt lu in lf b gy lv lw l lx ly">$ uname -srmp<br/>Darwin 17.7.0 x86_64 i386</span></pre><p id="7ad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 g++编译器:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="ab89" class="lt lu in lf b gy lv lw l lx ly">$ g++ --version<br/>Apple LLVM version 10.0.0 (clang-1000.11.45.5)</span></pre><h1 id="5c94" class="lz lu in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">阶段:预处理器、编译、链接</h1><p id="b2d7" class="pw-post-body-paragraph jv jw in jx b jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks ig bi translated">所有源文件都转换成目标文件，目标文件遵循 Linux 和 macOS 平台的<a class="ae nb" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#:~:text=In%20computing%2C%20the%20Executable%20and,shared%20libraries%2C%20and%20core%20dumps.&amp;text=By%20design%2C%20the%20ELF%20format,extensible%2C%20and%20cross%2Dplatform." rel="noopener ugc nofollow" target="_blank"> ELF </a>格式。</p><p id="4ed8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目中，可交付成果可以是可执行程序或库。库可以是静态(<code class="fe lc ld le lf b">.a</code>)或动态(<code class="fe lc ld le lf b">.so</code>)链接的。稍后我们将看到如何使用编译选项生成这些各自的输出。</p><p id="9465" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是首先，让我们创建<strong class="jx io">预处理器</strong>文件:</p><p id="29da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于每个 C++源文件，当预处理器找到一个<code class="fe lc ld le lf b">#</code> include 指令、宏替换、条件编译时，它将通过在其中插入内容来构建一个<a class="ae nb" href="https://en.wikipedia.org/wiki/Translation_unit_(programming)" rel="noopener ugc nofollow" target="_blank">翻译单元</a>。这是查找重复符号的最佳时机，或者如果您想用自己的实现覆盖某个特定的符号。</p><p id="8738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了获得翻译单元(预处理的源代码)，可以将选项<code class="fe lc ld le lf b">-E</code>传递给 g++编译器。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="9e39" class="lt lu in lf b gy lv lw l lx ly">$ g++ -E hello_cpp.cpp -o hello_cpp.pp</span></pre><p id="e7c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦预处理器创建完那个(有时是巨大的)翻译单元，编译器就开始编译阶段并生成目标文件。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="7aba" class="lt lu in lf b gy lv lw l lx ly">$ wc -l hello_cpp.pp<br/>   40845 hello_cpp.pp</span></pre><p id="c3af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，<strong class="jx io">用<code class="fe lc ld le lf b">-c</code>选项编译</strong>文件，不链接项目。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="0d4a" class="lt lu in lf b gy lv lw l lx ly">$ g++ -c hello_cpp.cpp<br/>$ file hello_cpp.o<br/>hello_cpp.o: Mach-O 64-bit object x86_64</span></pre><p id="f17e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到我生成了一个文件<code class="fe lc ld le lf b">hello_cpp.o</code>,它是一个没有关联链接的目标文件。</p><p id="c2bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<strong class="jx io">链接</strong>我们可以执行的文件。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="528b" class="lt lu in lf b gy lv lw l lx ly">$ g++ hello_cpp.cpp -o hello_cpp.out<br/>$ hello_cpp.out<br/>Hello C Plus Plus!</span></pre><h1 id="542d" class="lz lu in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">包括路径和链接库(第三方)</h1><p id="d899" class="pw-post-body-paragraph jv jw in jx b jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks ig bi translated">在一个项目中，您可能有来自不同地方的头文件:</p><ul class=""><li id="23f6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">你自己的创造，</li><li id="b7ea" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated">系统文件，</li><li id="9cb2" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated">与第三方软件包或代码集成等。</li></ul><p id="899b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的任务是包含路径，以便编译器可以找到它们。此时最重要的提示:</p><blockquote class="nc nd ne"><p id="cd2f" class="jv jw nf jx b jy jz ka kb kc kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ks ig bi translated">通常，人们会忽略一个很小但非常重要的点，最终导致漫长的调试周期。</p></blockquote><p id="5f4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提示 1 :- <strong class="jx io">包含文件版本和生成库版本必须相同。</strong></p><p id="91b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提示 2:- <strong class="jx io">还要确保这些库是为你要编译的平台编译的。</strong>这很容易检查，只需运行<code class="fe lc ld le lf b">file</code>命令，后跟库名。</p><p id="60fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们举一个例子，调用 OpenCV APIs 在图像上呈现文本。文件被命名为<code class="fe lc ld le lf b">hello_cv.cpp</code></p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="5b6a" class="lt lu in lf b gy lv lw l lx ly">#include &lt;iostream&gt;<br/>#include "opencv2/highgui/highgui.hpp"<br/>#include &lt;opencv2/imgproc.hpp&gt;</span><span id="2e59" class="lt lu in lf b gy nj lw l lx ly">int main(int argc, char* argv[])<br/>{<br/>    /* Create an empty image*/<br/>    cv::Mat img(500, 1000, CV_8UC3, cv::Scalar(0,0, 100));</span><span id="fcde" class="lt lu in lf b gy nj lw l lx ly">    if (img.empty())<br/>    {<br/>        std::cout &lt;&lt; "\n Image is empty, something gone wrong.\n";<br/>        return -1;<br/>    }</span><span id="8448" class="lt lu in lf b gy nj lw l lx ly">    cv::namedWindow("My_Screen", CV_WINDOW_AUTOSIZE);</span><span id="8f5d" class="lt lu in lf b gy nj lw l lx ly">    cv::Point org(30, 100);<br/>    cv::putText(img, "A Perfect Compiled World", org,<br/>           cv::FONT_HERSHEY_SCRIPT_COMPLEX, 2.1,<br/>           cv::Scalar(0, 0, 255), 2, cv::LINE_AA);<br/><br/>    cv::imshow("My_Screen", img);<br/>    cv::waitKey(0);<br/>    cv::destroyWindow("My_Screen");</span><span id="0f46" class="lt lu in lf b gy nj lw l lx ly">    return 0;<br/>}</span></pre><p id="0a8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在编译我们的小程序之前，让我们先熟悉一个叫做<code class="fe lc ld le lf b">pkg-config</code>的小工具。这是一个帮助工具，可以在您的系统上找到库的正确<strong class="jx io">安装路径</strong>和它们各自的头文件，以及编译选项，注意世界<strong class="jx io">安装</strong>。这并不总是如此，因此另一个警告，并注意这一事实。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="ef68" class="lt lu in lf b gy lv lw l lx ly">$ pkg-config --cflags opencv<br/>-I/usr/local/include/opencv -I/usr/local/include</span></pre><p id="1be7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">美在于<code class="fe lc ld le lf b">pkg-config</code>也增加了<code class="fe lc ld le lf b">-I</code>选项。这个标志通知编译器的目录路径，在那里可以找到头文件。类似地，<code class="fe lc ld le lf b">-L</code>下面的选项通知编译器可以找到所有库的路径。</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="66ee" class="lt lu in lf b gy lv lw l lx ly">$ pkg-config --libs opencv<br/>-L/usr/local/lib -lopencv_ml -lopencv_bioinspired -lopencv_dnn_objdetect -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_freetype -lopencv_fuzzy -lopencv_hfs -lopencv_img_hash -lopencv_line_descriptor -lopencv_phase_unwrapping -lopencv_reg -lopencv_tracking -lopencv_dnn -lopencv_video -lopencv_plot -lopencv_xphoto -lopencv_imgproc -lopencv_core</span></pre><p id="ce4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们用 OpenCV 编译我们的代码:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="b0e3" class="lt lu in lf b gy lv lw l lx ly">$ g++ `pkg-config --cflags --libs opencv` hello_cv.cpp -o hello_cv<br/>$ ./hello_cvv</span></pre><p id="b7ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您必须看到以下屏幕:</p><figure class="ll lm ln lo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/cd2bbd9e2daa97edc2d5998b35248099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7Mk2TbI7bRWpnzSTUpKZg.png"/></div></div></figure><p id="09da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">静态库文件</strong></p><p id="e003" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当几个<code class="fe lc ld le lf b">.o </code>文件被实现为一个带有扩展名的文件时，<code class="fe lc ld le lf b">.a</code>被称为静态库。是的，它只是将所有的目标文件归档到一个文件中。</p><p id="d84e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Linux/MacOS 中，这些静态库有一个<code class="fe lc ld le lf b">.a</code>扩展名，而在 Windows 中，它们以<code class="fe lc ld le lf b">.lib</code>扩展名存在。另一个工具<code class="fe lc ld le lf b">ar</code>用于创建静态库:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="8cc9" class="lt lu in lf b gy lv lw l lx ly"># Just an example</span><span id="c6c7" class="lt lu in lf b gy nj lw l lx ly">$ ar -cvq libmyproj.a myproj_file1.o myproj_file2.o myproj_file3.o</span></pre><p id="32c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">共享对象(动态)库文件</strong></p><p id="d236" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于它们是共享的，不同的程序可以对它们进行外部引用。它们不会被添加到程序代码大小中，而是在运行时程序对引用进行调用。如果没有找到引用，您可能会得到一个“<em class="nf"> Symbol not found </em>”错误。</p><ul class=""><li id="1506" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">在 Linux 上，这些库被称为共享对象，扩展名为<code class="fe lc ld le lf b">.so</code>。</li><li id="9ecc" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated">在 MacOS 上，它们有一个<code class="fe lc ld le lf b">.dylib</code>扩展名。</li><li id="cbc7" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated">在 Windows 上，它们被称为动态库，扩展名为<code class="fe lc ld le lf b">.dll.</code></li></ul><p id="37b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Linux 上，使用以下命令创建共享对象:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="c63f" class="lt lu in lf b gy lv lw l lx ly">$ g++ -shared -Wl,-soname,libhellocv.so `pkg-config --cflags --libs opencv` hello_cv.cpp</span></pre><p id="1fba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 MacOS 上，</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="4431" class="lt lu in lf b gy lv lw l lx ly">$ g++ -shared `pkg-config --cflags --libs opencv` hello_cv.cpp-o libhellocv.dylib</span></pre><p id="e555" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">拥有共享对象有很多好处，你能列举几个吗？</p><p id="2e58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这些库在不同的文件夹中会怎样？</p><p id="70d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您在系统路径之外的<code class="fe lc ld le lf b">/path/to/other/library/libfoo.so,</code>有一个库<code class="fe lc ld le lf b">libfoo.so</code>(即<code class="fe lc ld le lf b">LD_LIBRARY_PATH</code>)。</p><p id="52b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以指定包含它的文件夹，如<code class="fe lc ld le lf b">-L/path/to/other/library</code>，然后使用简写形式<code class="fe lc ld le lf b">-lfoo</code>来表示库名。正如你看到的，库的实际名称是<code class="fe lc ld le lf b">libfoos.so</code>，但是你可以跳过序言<code class="fe lc ld le lf b">lib</code>和类似的<code class="fe lc ld le lf b">.so</code>，只提到<code class="fe lc ld le lf b">-lfoo</code>。</p><h1 id="0ecc" class="lz lu in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">调试:有用的工具</h1><p id="9baa" class="pw-post-body-paragraph jv jw in jx b jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks ig bi translated"><strong class="jx io">生产与调试</strong>:开发人员添加了许多调试代码，但在生产版本中通常并不需要。如何使用编译时控制这种行为？</p><p id="f36e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在编译选项期间使用 NDEBUG 宏将启用或禁用调试代码。如下所示:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="969c" class="lt lu in lf b gy lv lw l lx ly">#include &lt;iostream&gt;<br/>#include "opencv2/highgui/highgui.hpp"<br/>#include &lt;opencv2/imgproc.hpp&gt;</span><span id="815c" class="lt lu in lf b gy nj lw l lx ly">int main(int argc, char* argv[])<br/>{<br/>    /* Create an empty image*/<br/>    cv::Mat img(500, 1000, CV_8UC3, cv::Scalar(0,0, 100));</span><span id="cb7e" class="lt lu in lf b gy nj lw l lx ly">    if (img.empty())<br/>    {<br/>       std::cout &lt;&lt; "\n Image is empty, something gone wrong.\n";<br/>       return -1;<br/>    }</span><span id="ab5a" class="lt lu in lf b gy nj lw l lx ly">    cv::namedWindow("My_Screen", CV_WINDOW_AUTOSIZE);</span><span id="7386" class="lt lu in lf b gy nj lw l lx ly">    cv::Point org(30, 100);</span><span id="2cd2" class="lt lu in lf b gy nj lw l lx ly">#ifdef NDEBUG<br/>    cv::putText(img, "RELEASE Build", org,<br/>           cv::FONT_HERSHEY_SCRIPT_COMPLEX, 2.1,<br/>           cv::Scalar(0, 0, 255), 2, cv::LINE_AA);<br/> #else<br/>    cv::putText(img, "DEBUG Build", org,<br/>           cv::FONT_HERSHEY_SCRIPT_COMPLEX, 2.1,<br/>           cv::Scalar(0, 0, 255), 2, cv::LINE_AA);<br/> #endif<br/>    cv::imshow("My_Screen", img);<br/>    cv::waitKey(0);<br/>    cv::destroyWindow("My_Screen");</span><span id="7922" class="lt lu in lf b gy nj lw l lx ly">    return 0;<br/>}</span></pre><p id="fae1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译代码，但只到<strong class="jx io">预处理器</strong>阶段，并验证代码包含性？</p><p id="6312" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在有和没有<code class="fe lc ld le lf b">NDEBUG</code>的情况下进行完整编译，如下图所示，以查看不同之处:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="faab" class="lt lu in lf b gy lv lw l lx ly">$ g++ -DNDEBUG `pkg-config --cflags --libs opencv` hello_cv.cpp -o hello_cv</span></pre><p id="e94b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lc ld le lf b">NDEBUG</code>是系统已知的编译标志，但您也可以定义自己的标志，并使用<code class="fe lc ld le lf b">-D</code>编译选项来控制它们。</p><p id="edf8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="nf">【未定义符号】</em> </strong>:</p><ul class=""><li id="e806" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">有各种各样的工具，但我最喜欢的是<code class="fe lc ld le lf b">nm</code>和<code class="fe lc ld le lf b">grep</code>可以给你最好的结果。</li></ul><p id="0158" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过<code class="fe lc ld le lf b">nm</code>，可以看到符号的名称列表。熟悉符号类型的含义:</p><ul class=""><li id="baaa" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe lc ld le lf b">T</code>(文本段符号)</li><li id="21df" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated"><code class="fe lc ld le lf b">U</code>(未定义—对那些<code class="fe lc ld le lf b">undefined symbol</code>错误有用)</li><li id="58e9" class="kt ku in jx b jy lg kc lh kg li kk lj ko lk ks ky kz la lb bi translated"><code class="fe lc ld le lf b">I</code>(间接符号)</li></ul><p id="b6fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个符号是局部的(非外部的),符号类型用小写字母表示，例如，小写的 u 表示对同一库中另一个模块中私有外部的未定义引用。</p><p id="8dfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Linux 上也可以使用<code class="fe lc ld le lf b">objdump</code>和<code class="fe lc ld le lf b">readelf</code>。MacOS 的<code class="fe lc ld le lf b">otool</code>与<code class="fe lc ld le lf b">readelf</code>非常相似。</p><p id="f54c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">魔法</strong> <code class="fe lc ld le lf b"><strong class="jx io">strings</strong></code> <strong class="jx io">命令:</strong></p><p id="0bf8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，您想要在库中或可执行文件中快速搜索字符串。这可能是由于各种原因，例如搜索次要/主要版本号、建议有效版本的特定字符串等。您可以通过以下方式实现这一点:</p><pre class="ll lm ln lo gt lp lf lq lr aw ls bi"><span id="eb60" class="lt lu in lf b gy lv lw l lx ly">$ string -a hello_cv | grep &lt;your search string&gt;</span></pre><p id="7a62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">删除调试符号:</strong></p><p id="be48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lc ld le lf b">strip</code>是另一个可以显著减小库或可执行文件大小的神奇命令。通常，生产版本必须去除调试符号。</p><p id="ba6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">生成并分析</strong> <a class="ae nb" href="https://medium.com/pune-smart-city-hackathon/guidelines-for-your-solution-code-now-9bcbc6517e23" rel="noopener"> <strong class="jx io">代码转储文件</strong> </a> <strong class="jx io"> : </strong></p><p id="35de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想让我添加更多我遗漏的工具，请发给我 tomdeore@gmail.com。</p><p id="b3df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">可以联系我上|</strong><a class="ae nb" href="https://www.linkedin.com/in/mdeore/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">LinkedIn</strong></a><strong class="jx io">|</strong><a class="ae nb" href="https://tomdeore.wixsite.com/epoch" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">网站</strong></a><strong class="jx io">|</strong><a class="ae nb" href="https://github.com/milinddeore" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Github</strong></a><strong class="jx io">|</strong></p></div></div>    
</body>
</html>