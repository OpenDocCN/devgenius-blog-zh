<html>
<head>
<title>Linux — How to Evaluate Network Performance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux——如何评估网络性能？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-how-to-evaluate-network-performance-9c14ed6f64d9?source=collection_archive---------4-----------------------#2022-04-22">https://blog.devgenius.io/linux-how-to-evaluate-network-performance-9c14ed6f64d9?source=collection_archive---------4-----------------------#2022-04-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="f755" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">评估系统网络性能的有用工具</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/ce6d1527fff427b4d8c032673e63bf22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9lYwXXgoQX7elRXXeqEQw.png"/></div></div></figure><p id="d6da" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我以前的文章中，我们讨论了如何解决网络延迟和性能问题，以及经典的 C10K 和 C1000K 问题。重述一下，C10K 指的是单台主机如何同时处理 10000 个并发请求的问题，C1000K 指的是 1M 的并发请求。</p><h1 id="00e2" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">介绍</h1><p id="8f44" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">I/O 模型的优化是解决 C10K 问题的最佳途径。Liux 2.6 中引入的<code class="fe ml mm mn mo b">epoll</code>完美解决了 C10K，今天很多高性能网络解决方案仍然基于<code class="fe ml mm mn mo b">epoll</code>。</p><p id="ca57" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从 C10K 到 C100K，一个解决方案是增加物理硬件资源满足要求，但是从 C100K 到 C1000K，增加物理资源是不够的。从硬件中断处理到网络协议栈中文件描述符的数量、连接状态跟踪、缓存队列，再到应用程序工作模式的整个网络链接，都需要优化系统的应用程序和硬件。</p><p id="37be" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">再进一步，C10M 呢？这不是增加硬件资源，调优内核和应用就能解决的问题。这时，冗长的网络协议栈就成了内核中最大的问题。</p><p id="8acc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">有两种方法可以解决这个问题:</p><ul class=""><li id="facc" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">使用 XDP 方法在内核协议栈之前处理网络数据包。</li><li id="4ef6" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">使用 DPDK，直接跳过网络协议栈，在用户空间轮询处理。</li></ul><p id="494b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在上述两种方法中，DPDK 是最主流的高性能网络解决方案。不过网卡需要支持 DPDK。</p><p id="dcb8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当然，事实上，在大多数场景中，我们不需要在一台机器上有 1000 万个并发请求。通过调整系统架构，将请求分布到多个服务器进行并行处理，是一种更简单、可扩展性更强的解决方案。</p><p id="8e9e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是，在这种情况下，我们需要评估系统的网络性能，以便检查系统的处理能力，并为容量规划提供基准数据。那么如何评价网络性能呢？</p><h1 id="9b19" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">收集绩效指标</h1><p id="262c" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">在我们谈论评估网络性能之前，我们必须收集用于测量系统网络性能的指标。如果您的应用程序运行在 AWS EC2/ECS/Lambda/EKS 上，现成的 AWS 在 AWS 云观察中有一些基本的监控指标。如果您的应用程序是容器化的，并且运行在 K8s 上，那么您可以利用 Grafana 和 Prometheus 来收集指标(更多的云原生)。否则还有第三方工具如 Datadog，new relic 等。</p><p id="4014" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">无论您使用什么方法/工具，拥有一个指标收集机制和仪表板来显示性能以及警报和通知是至关重要的。我附上了一个示例仪表板，我在下面的一些应用程序中使用它:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nd"><img src="../Images/6fa2a7886d9f21605e8197458a1b743d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uiop5Cs_Mv3QmZkw.png"/></div></div></figure><h1 id="31c7" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">绩效指标审查</h1><p id="8d2d" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">在 Linux 网络基础中，我们曾经说过带宽、吞吐量、延迟、PPS 等。是最常用的网络性能指标。重要网络指标的快速回顾:</p><ul class=""><li id="4ca5" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated"><strong class="ku is">带宽</strong>:链路的最大传输速率，以 b/s 为单位，购买网卡时，常用的带宽有 1G、10G、100G。</li><li id="8c2f" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><strong class="ku is">吞吐量</strong>:表示无丢包的最大数据传输速率，通常以 b/s 或 B/s 为单位，吞吐量受带宽限制，吞吐量/带宽是网络链路的利用率。</li><li id="06b6" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><strong class="ku is">延迟</strong>:从发送网络请求到收到远程响应的时间延迟。它可以表示建立连接所需的时间(如 TCP 握手延迟)，或者数据包往返所需的时间(如 RTT)。</li><li id="fd43" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><strong class="ku is"> PPS </strong>:每秒数据包数，代表网络数据包的传输速率。PPS 通常用于评估网络的转发能力，而基于 Linux 服务器的转发很容易受到网络数据包大小的影响。</li></ul><p id="15a7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在上述四个指标中，带宽与物理网卡配置直接相关。对于 TCP 或 Web 服务，使用了更多的并发连接数、每秒请求数(QPS、每秒查询数)等指标，更能反映实际应用的性能。</p><h1 id="3122" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">标杆管理</h1><p id="caa9" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">在熟悉了网络的性能指标之后，我们来看看如何通过性能测试来确定这些指标的基准值。</p><p id="3c05" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Linux 组网基于 TCP/IP 协议栈，不同协议层的行为明显不同。所以在测试之前，你要搞清楚你要评估的网络性能属于协议栈的哪一层？换句话说，您的应用程序基于协议栈的哪一层？</p><p id="aeb5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">总的来说:</p><ul class=""><li id="6de3" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">基于 HTTP/HTTPS 的基于 Web 的应用程序显然属于应用层。</li><li id="2f9f" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">游戏服务器通常基于 TCP 或 UDP 与客户端进行交互。所以是在 TCP/UDP 层。</li><li id="668b" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">如果您的 Linux 服务器被用作软交换机或路由器，它将位于网络层。</li></ul><h2 id="2e37" class="ne lp ir bd lq nf ng dn lu nh ni dp ly lb nj nk ma lf nl nm mc lj nn no me np bi translated">HTTP 性能</h2><p id="0dd3" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">HTTP 是最常用的应用层协议。比如常用的 Apache、Nginx 等 Web 服务都是基于 HTTP 的。</p><p id="cce7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">测试 HTTP 的性能，也有大量的工具可以使用，比如<code class="fe ml mm mn mo b">ab</code>、<code class="fe ml mm mn mo b">webbench</code>等。，是常用的 HTTP 压力测试工具。其中，<code class="fe ml mm mn mo b">ab</code>是 Apache 自带的 HTTP 压力测试工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量、请求延迟分布等。</p><p id="2b9b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以通过运行以下命令来安装 ab 工具:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="b4e6" class="ne lp ir mo b gz nu nv l nw nx">$ yum install -y httpd-tools</span></pre><p id="425a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，在目标机器上，使用 Docker 启动一个 Nginx 服务，然后使用<code class="fe ml mm mn mo b">ab</code>测试其性能。首先，在目标计算机上运行以下命令:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="b1cc" class="ne lp ir mo b gz nu nv l nw nx">$ docker run -p 80:80 -itd nginx</span></pre><p id="56c3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在另一台机器上，运行 ab 命令来测试 Nginx 的性能:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="e1c6" class="ne lp ir mo b gz nu nv l nw nx"># -c means the number of concurrent requests is 1000, -n means the total number of requests is 10000<br/>$ ab -c 1000 -n 10000 <a class="ae ny" href="http://192.168.0.30/" rel="noopener ugc nofollow" target="_blank">http://192.168.0.30/</a><br/>...<br/>Server Software:        nginx/1.15.8<br/>Server Hostname:        192.168.0.30<br/>Server Port:            80</span><span id="4dda" class="ne lp ir mo b gz nz nv l nw nx">...</span><span id="4471" class="ne lp ir mo b gz nz nv l nw nx">Requests per second:    1078.54 [#/sec] (mean)<br/>Time per request:       927.183 [ms] (mean)<br/>Time per request:       0.927 [ms] (mean, across all concurrent requests)<br/>Transfer rate:          890.00 [Kbytes/sec] received</span><span id="8955" class="ne lp ir mo b gz nz nv l nw nx">Connection Times (ms)<br/>              min  mean[+/-sd] median   max<br/>Connect:        0   27 152.1      1    1038<br/>Processing:     9  207 843.0     22    9242<br/>Waiting:        8  207 843.0     22    9242<br/>Total:         15  233 857.7     23    9268</span><span id="69aa" class="ne lp ir mo b gz nz nv l nw nx">Percentage of the requests served within a certain time (ms)<br/>  50%     23<br/>  66%     24<br/>  75%     24<br/>  80%     26<br/>  90%    274<br/>  95%   1195<br/>  98%   2335<br/>  99%   4663<br/> 100%   9268 (longest request)</span></pre><p id="7692" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在“请求摘要”部分，您可以看到:</p><ul class=""><li id="e0fa" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">每秒的请求数是 1074；</li><li id="13bf" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">每个请求的延迟(每个请求的时间)分为两行。第一行的 927 ms 代表平均延迟，包括线程运行的调度时间和网络请求响应时间，下一行的 0.927 ms 代表实际请求响应时间；</li><li id="c76c" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">传输速率意味着 890 KB/s 的吞吐量(BPS)</li><li id="b959" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">“连接时间摘要”部分显示了建立连接、请求、等待和摘要的各种时间，包括最小、最大、平均和中值处理时间。</li><li id="d50d" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">最终请求延迟摘要部分给出了在不同时间段处理的请求的百分比，例如，90%的请求可以在 274 毫秒内完成。</li></ul><h2 id="cb05" class="ne lp ir bd lq nf ng dn lu nh ni dp ly lb nj nk ma lf nl nm mc lj nn no me np bi translated">TCP/UDP 性能</h2><p id="cfd7" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated"><code class="fe ml mm mn mo b">iperf</code>和<code class="fe ml mm mn mo b">netperf</code>都是测试 TCP 和 UDP 吞吐量最常用的网络性能测试工具。它们都测量客户机和服务器通信时一段时间内的平均吞吐量。</p><p id="28e4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们将以<code class="fe ml mm mn mo b">iperf</code>为例。要安装:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="23eb" class="ne lp ir mo b gz nu nv l nw nx">$ yum install iperf3</span></pre><p id="289b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后，在目标计算机上启动 iperf 服务器:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="78d6" class="ne lp ir mo b gz nu nv l nw nx"># -s means start the server, -i means reporting interval, -p means listening port<br/>$ iperf3 -s -i 1 -p 10000</span></pre><p id="3f04" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，在另一台机器上运行 iperf 客户端来运行测试:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="8b9c" class="ne lp ir mo b gz nu nv l nw nx"># -c means to start the client, 192.168.0.30 is the IP of the target server<br/># -b indicates the target bandwidth (unit is bits/s)<br/># -t means test time<br/># -P indicates the number of concurrency, -p indicates the target server listening port<br/>$ iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000</span></pre><p id="65ba" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">过一会儿(15 秒)测试结束，回到目标服务器并检查<code class="fe ml mm mn mo b">iperf</code>报告:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="a32c" class="ne lp ir mo b gz nu nv l nw nx">[ ID] Interval           Transfer     Bandwidth<br/>...<br/>[SUM]   0.00-15.04  sec  0.00 Bytes  0.00 bits/sec                  sender<br/>[SUM]   0.00-15.04  sec  1.51 GBytes   860 Mbits/sec                  receiver</span></pre><p id="bb5b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">最后的 SUM 行是测试的汇总结果，包括测试时间、数据传输量和带宽。根据发送和接收，这部分分为发送方和接收方两条线。</p><p id="377d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从测试结果可以看到，这台机器的 TCP 接收带宽(吞吐量)为 860 Mb/s，距离目标的 1Gb/s 还是有点远。</p><h2 id="927e" class="ne lp ir bd lq nf ng dn lu nh ni dp ly lb nj nk ma lf nl nm mc lj nn no me np bi translated">转发性能</h2><p id="9077" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">我们先来看网络接口层和网络层，它们主要负责网络数据包的封装、寻址、路由、发送和接收。</p><p id="5b1e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在这一层中，PPS 是最重要的性能指标。要测试网络层，我们可以使用“<a class="ae ny" href="https://wiki.linuxfoundation.org/networking/pktgen" rel="noopener ugc nofollow" target="_blank"> pktgen </a>”。<code class="fe ml mm mn mo b">pktgen</code>自带 Linux 内核，支持丰富的定制选项。</p><p id="3492" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">由于<code class="fe ml mm mn mo b">pktgen</code>作为内核线程运行，您无法直接找到该命令。你需要加载<code class="fe ml mm mn mo b">pktgen</code>内核模块，然后与/proc 文件系统交互。例如:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="beb2" class="ne lp ir mo b gz nu nv l nw nx">$ modprobe pktgen<br/>$ ps -ef | grep pktgen | grep -v grep<br/>root     26384     2  0 06:17 ?        00:00:00 [kpktgend_0]<br/>root     26385     2  0 06:17 ?        00:00:00 [kpktgend_1]<br/>$ ls /proc/net/pktgen/<br/>kpktgend_0  kpktgend_1  pgctrl</span></pre><p id="3534" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe ml mm mn mo b">pktgen</code>在每个 CPU 上启动一个内核线程，可以通过<code class="fe ml mm mn mo b">/proc/net/pktgen</code>下的同名文件与这些线程进行交互；而<code class="fe ml mm mn mo b">pgctrl</code>主要用来控制这个测试的开始和停止。</p><p id="24d3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">假设发送机器使用的网卡是<code class="fe ml mm mn mo b">eth0</code>，目标机器的 IP 地址是<code class="fe ml mm mn mo b">192.168.0.30</code>，MAC 地址是<code class="fe ml mm mn mo b">11:11:11:11:11:11</code>。</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="825b" class="ne lp ir mo b gz nu nv l nw nx"># Define pgset function<br/>function pgset() {<br/>    local result<br/>    echo $1 &gt; $PGDEV</span><span id="fbc5" class="ne lp ir mo b gz nz nv l nw nx">result=`cat $PGDEV | fgrep "Result: OK:"`<br/>    if [ "$result" = "" ]; then<br/>         cat $PGDEV | fgrep Result:<br/>    fi<br/>}</span><span id="627f" class="ne lp ir mo b gz nz nv l nw nx"># Bind the eth0 network card for thread 0<br/>PGDEV=/proc/net/pktgen/kpktgend_0<br/>pgset "rem_device_all"   # Clear network card binding<br/>pgset "add_device eth0"  # Add eth0 network card</span><span id="4674" class="ne lp ir mo b gz nz nv l nw nx"># Configure the test options for the eth0 NIC<br/>PGDEV=/proc/net/pktgen/eth0<br/>pgset "count 1000000"    # Total number of packets sent<br/>pgset "delay 5000"       # Send delay between packets (nanoseconds)<br/>pgset "clone_skb 0"      # SKB package copy<br/>pgset "pkt_size 64"      # Network packet size<br/>pgset "dst 192.168.0.30" # destination IP<br/>pgset "dst_mac 11:11:11:11:11:11"  # MAC address</span><span id="668e" class="ne lp ir mo b gz nz nv l nw nx"># Start test<br/>PGDEV=/proc/net/pktgen/pgctrl<br/>pgset "start"</span></pre><p id="004a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">过一会儿，测试完成了，结果可以从/proc 文件系统中获得。通过下面代码片段中的内容，我们可以查看刚才的测试报告:</p><pre class="kh ki kj kk gu nq mo nr ns aw nt bi"><span id="8ae8" class="ne lp ir mo b gz nu nv l nw nx">$ cat /proc/net/pktgen/eth0<br/>Params: count 1000000  min_pkt_size: 64  max_pkt_size: 64<br/>     frags: 0  delay: 0  clone_skb: 0  ifname: eth0<br/>     flows: 0 flowlen: 0<br/>...<br/>Current:<br/>     pkts-sofar: 1000000  errors: 0<br/>     started: 1534853256071us  stopped: 1534861576098us idle: 70673us<br/>...<br/>Result: OK: 8320027(c8249354+d70673) usec, 1000000 (64byte,0frags)<br/>  120191pps 61Mb/sec (61537792bps) errors: 0</span></pre><p id="5158" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如你所见，测试报告主要分为三个部分:</p><ul class=""><li id="3ed4" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">第一部分中的参数是测试选项；</li><li id="2b85" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">第二部分的电流是测试进度，其中，<code class="fe ml mm mn mo b">pkts-sofar</code>表示已经发送了 100 万个包，表示测试已经完成。</li><li id="15e6" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">结果包括测试花费的时间、网络数据包和碎片数量、PPS、吞吐量和错误数量。</li></ul><p id="db80" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从上面的结果中，我们发现 PPS 是 120，000，吞吐量是 61 Mb/s，并且没有出现错误。</p><h1 id="ec83" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">结论</h1><p id="c534" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">在本文中，我们讨论了可以用来评估网络性能的不同工具。</p><p id="784e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">性能评估是优化网络性能的前提。只有当你发现网络性能瓶颈时，才需要进行网络性能优化。根据 TCP/IP 协议栈的原理，不同协议层的性能侧重点不完全相同，对应不同的性能测试方法。</p><p id="1060" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因为低层协议是高层协议的基础。所以一般来说，我们需要自上而下的测试各个协议层的性能，然后根据性能测试的结果，结合 Linux 网络协议栈的原理，找到性能瓶颈的根源，进而优化网络性能。</p></div></div>    
</body>
</html>