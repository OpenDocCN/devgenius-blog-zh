<html>
<head>
<title>Circuit Breaker Pattern 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">断路器模式 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/circuit-breaker-pattern-101-be2d7fdb656?source=collection_archive---------6-----------------------#2022-05-22">https://blog.devgenius.io/circuit-breaker-pattern-101-be2d7fdb656?source=collection_archive---------6-----------------------#2022-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1f74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本博客是《归零地》(Ground Zero)系列文章的一部分，内容是为起步知识有限的读者讨论 101 个<strong class="jm io"> </strong>概念。本文来自<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为涉及对<strong class="jm io">优先级队列</strong>的理解，主要用于根据租户/业务用例处理不同优先级的异步消息。</p><p id="7192" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列的一些早期博客如下:</p><p id="c78b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/priority-queues-101-40eb4f6f5ee9"> <strong class="jm io">优先级队列 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/api-101-773ec501b485">API 101</a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"><strong class="jm io">T21【异步通信】101</strong></a><strong class="jm io"><br/><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078">数据库 101</a></strong><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计 101 </strong> </a> <strong class="jm io"> <br/> </strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/cd27407f5650831abbb3d4e8853c8c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLeNUqjIZXOR7Q79Qfuw0A.png"/></div></div></figure><h1 id="717f" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是断路器？</h1><p id="0209" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">断路器是分布式系统中使用的一种设计模式，用于防止某个应用程序层的非暂时性故障阻塞应用程序层次结构中其他层的资源。非瞬时故障事件，如<em class="ki">维护、网络连接缓慢、超时等</em>，可持续导致远程呼叫终止而没有预期的响应，是实施断路器的理想情况。非对称重试模式，用于短暂故障的情况，其中客户端进行连续调用(有/没有<a class="ae kj" href="https://en.wikipedia.org/wiki/Exponential_backoff" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">指数回退</strong> </a> <strong class="jm io"> ) <em class="ki">、</em> </strong>此模式对于在<strong class="jm io">多租户</strong>平台架构的情况下防止<a class="ae kj" href="https://en.wikipedia.org/wiki/Denial-of-service_attack" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">拒绝服务</strong> </a>场景至关重要。通过打开长期故障电路来解除资源阻塞，有助于优化系统资源，如<em class="ki">内存、线程、数据库连接</em>，从而防止下游系统出现任何进一步的故障。</p><h1 id="2505" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结束 2 结束流程</h1><p id="1b8e" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">断路器通常被实现为应用程序代理，其监控远程调用故障，然后允许<em class="ki">后续操作/动作</em>。代理通常被配置为作为简单的状态机运行，如下所示—</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/0d274bc54624cdd7fff866ef4bf092b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*i0e_mKmmZ-mFocSiXteeyQ.jpeg"/></div></figure><h2 id="79d8" class="ma kx in bd ky mb mc dn lc md me dp lg jv mf mg lk jz mh mi lo kd mj mk ls ml bi translated"><strong class="ak">关闭状态</strong></h2><ul class=""><li id="e44e" class="mm mn in jm b jn lu jr lv jv mo jz mp kd mq kh mr ms mt mu bi translated">在关闭状态下，所有对下游服务的远程调用都像预期的那样被允许。代理对故障/异常的发生进行计数，并且一旦达到某个阈值，状态就变为打开状态。</li></ul><h2 id="8eb5" class="ma kx in bd ky mb mc dn lc md me dp lg jv mf mg lk jz mh mi lo kd mj mk ls ml bi translated"><strong class="ak">打开状态</strong></h2><ul class=""><li id="c286" class="mm mn in jm b jn lu jr lv jv mo jz mp kd mq kh mr ms mt mu bi translated">在开放状态下，所有远程调用都会间歇性地失败，并出现预定义的异常，所有对下游的调用都会被阻塞，直到设置的超时过期。超时期满后，电路进入半开状态。</li></ul><h2 id="d20c" class="ma kx in bd ky mb mc dn lc md me dp lg jv mf mg lk jz mh mi lo kd mj mk ls ml bi translated"><strong class="ak">半开状态</strong></h2><ul class=""><li id="42c0" class="mm mn in jm b jn lu jr lv jv mo jz mp kd mq kh mr ms mt mu bi translated">在半开状态下，电路允许一定比例的对下游微服务的远程调用。在进一步故障的情况下，电路返回到开路状态，并且如果达到成功阈值，电路返回到健康闭合状态。</li></ul><h1 id="c10d" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用例</h1><ul class=""><li id="bf03" class="mm mn in jm b jn lu jr lv jv mo jz mp kd mq kh mr ms mt mu bi translated"><strong class="jm io">多租户— </strong>大型系统，其中下游平台服务(如身份、认证等)跨多个业务领域共享。</li><li id="8d99" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated"><strong class="jm io">单租户— </strong>同一个租户内的微服务在更严格的<em class="ki">性能和可用性</em>方面具有高可见性，因此电路有助于维持所需的端到端 SLA。</li></ul><h1 id="29c9" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">优势</h1><ul class=""><li id="1048" class="mm mn in jm b jn lu jr lv jv mo jz mp kd mq kh mr ms mt mu bi translated">这种模式的主要目标是隔离<strong class="jm io">单点故障</strong>级联成大型分布式故障，影响多个微服务的整个业务域的整体可用性。</li><li id="fea0" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">优化系统资源(<strong class="jm io"> <em class="ki">线程、内存、CPU 等</em> </strong>)，减少不必要的退休和暂时故障时的消耗。</li><li id="fa85" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">屏蔽受影响的下游系统，并通过避免故障状态下的流量，帮助减少总体<strong class="jm io">平均恢复时间(MTTR) </strong>。</li></ul><h1 id="7824" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="21b5" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我们讨论了<strong class="jm io">断路器</strong>设计模式的基础，这种模式在具有高可用性和毫秒级性能 SLA 的分布式系统中很流行。<strong class="jm io">网飞</strong>通过其开源库<a class="ae kj" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Hystrix</strong></a><strong class="jm io"/>解决了客户在他们端实现的一些重大集成需求。后来，Hystrix 被弃用，被一个 Spring 库取代。</p><p id="8add" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在未来的<strong class="jm io"> Advanced </strong>博客中用一个代码例子来讨论这个库的工作，以解决一个实际的用例。</p><p id="2451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>