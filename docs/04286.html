<html>
<head>
<title>How to Use Circuit Breaker in Spring Boot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Spring Boot 应用中使用断路器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-circuit-breaker-in-spring-boot-application-3803d31a9d60?source=collection_archive---------1-----------------------#2021-02-21">https://blog.devgenius.io/how-to-use-circuit-breaker-in-spring-boot-application-3803d31a9d60?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bf6d415db4601b7e7247ad320728b9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkYskCgUn0ENw9nYZ1a77A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自 Pixabay，作者 Jürgen Diermaier</figcaption></figure><p id="9121" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我将展示如何在 Spring Boot 应用程序中使用断路器模式。当我说断路器模式时，它是一个架构模式。网飞出版了一个处理断路器的 Hysterix 库。作为这篇文章的一部分，我将展示如何在 Spring Boot 应用程序中使用<strong class="kb io">resile 4j</strong>库来使用断路器模式。</p><p id="d47f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另外，我最近出版了我的书<a class="ae kx" href="https://betterjavacode.com/programming/simplifying-spring-security" rel="noopener ugc nofollow" target="_blank">简化春季安全</a>。有兴趣了解弹簧安全的，可以在这里购买<a class="ae kx" href="https://gum.co/VgSdH" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="432c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是断路器？</h1><p id="f7b4" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">断路器的概念来自电气工程。在大多数电力网络中，断路器是保护网络免受电流过载或短路造成的损害的开关。</p><p id="eace" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">类似地，在软件中，如果我们知道对远程服务的调用将失败或超时，断路器会停止对该远程服务的调用。这样做的好处是节省资源，并且在我们对远程过程调用进行故障诊断时更加主动。</p><p id="3450" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">断路器基于呼叫的先前历史做出停止呼叫的决定。但是有其他的方法来处理这些电话。通常，它会跟踪以前的呼叫。假设 5 次调用中有 4 次失败或超时，那么下一次调用将失败。这有助于更主动地处理调用服务的错误，调用服务可以用不同的方式处理响应，使用户体验到与错误页面不同的应用程序。</p><p id="a0fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果在特定持续时间内对远程服务的调用失败，断路器可以采取的另一种方式。断路器将打开，并且不允许下一次呼叫，直到远程服务改善错误。</p><h1 id="0aa4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Resilience4J 库</h1><p id="b9ee" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们有调用远程服务的代码。来自<code class="fe mb mc md me b">resilience4j</code>库的断路器模块将有一个用于调用远程服务的 lambda 表达式或一个用于从远程服务调用中检索值的<code class="fe mb mc md me b">supplier</code>。我将作为示例的一部分展示这一点。断路器以这样一种方式装饰这个远程服务调用，以便它能够跟踪响应和开关状态。</p><h1 id="c91c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Resilience4j 库的不同配置</h1><p id="f226" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">为了理解断路器的概念，我们将看看这个库提供的不同配置。</p><p id="7ef2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">slidingWindowType()</code> -这种配置基本上有助于决定断路器将如何操作。有两种类型<code class="fe mb mc md me b">COUNT_BASED</code>和<code class="fe mb mc md me b">TIME_BASED</code>。<code class="fe mb mc md me b">COUNT_BASED</code>断路器滑动窗口将考虑远程服务的调用次数，而<code class="fe mb mc md me b">TIME_BASED</code>断路器滑动窗口将考虑某一时间段内远程服务的调用次数。</p><p id="a4f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">failureRateThreshold()</code> -以百分比为单位配置故障率阈值。如果 x %的呼叫失败，那么断路器将打开。</p><p id="369e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">slidingWindowSize()</code> -该设置有助于决定闭合断路器时要考虑的呼叫数量。</p><p id="80f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">slowCallRateThreshold()</code> -以百分比为单位配置慢速呼叫速率阈值。如果百分之 x 的通话很慢，那么断路器就会打开。</p><p id="ae20" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">slowCallDurationThreshold</code> -被视为慢速呼叫的持续时间阈值。</p><p id="b4bc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">minimumNumberOfCalls()</code> -断路器计算错误率之前所需的最少呼叫次数。</p><p id="6fc2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">ignoreException()</code> -该设置允许您配置一个断路器可以忽略的异常，并且不计入远程服务调用的成功或失败。</p><p id="2e41" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">waitDurationInOpenState()</code> -在转换到半开状态之前，断路器应保持打开状态的持续时间。默认值为 60 秒。</p><h1 id="a1a6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基于计数的断路器</h1><p id="a090" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">使用<code class="fe mb mc md me b">resilience4j</code>库时，用户可以始终使用断路器提供的默认配置。默认配置基于基于计数的滑动窗口类型。</p><p id="6860" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么我们如何为基于计数的滑动窗口类型创建断路器呢？</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="59c4" class="mn kz in me b gy mo mp l mq mr">CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom() .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.COUNT_BASED) .slidingWindowSize(10) .slowCallRateThreshold(65.0f) .slowCallDurationThreshold(Duration.ofSeconds(3)) .build(); </span><span id="75d7" class="mn kz in me b gy ms mp l mq mr">CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.of(circuitBreakerConfig); </span><span id="be59" class="mn kz in me b gy ms mp l mq mr">CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("BooksSearchServiceBasedOnCount");</span></pre><p id="2c94" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上述示例中，我们正在创建一个断路器配置，其中包括类型为<code class="fe mb mc md me b">COUNT_BASED</code>的滑动窗口。该断路器将记录 10 次呼叫的结果，以将断路器切换到<code class="fe mb mc md me b">closed</code>状态。如果 65%的呼叫缓慢，且持续时间超过 3 秒，断路器将断开。</p><p id="4cd8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">CircuitBreakerRegistry</code>是一家制造断路器的工厂。</p><h1 id="cd89" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基于时间的断路器</h1><p id="08e1" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">现在接通<code class="fe mb mc md me b">Time-Based</code>断路器。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="6254" class="mn kz in me b gy mo mp l mq mr">CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom() .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.TIME_BASED) .minimumNumberOfCalls(3) .slidingWindowSize(10) .failureRateThreshold(70.0f) .build(); </span><span id="d75f" class="mn kz in me b gy ms mp l mq mr">CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.of(circuitBreakerConfig); </span><span id="71a0" class="mn kz in me b gy ms mp l mq mr">CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("BookSearchServiceBasedOnTime");</span></pre><p id="17e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的例子中，我们正在创建一个断路器配置，它包括一个类型为<code class="fe mb mc md me b">TIME_BASED</code>的滑动窗口。断路器将在至少 3 次呼叫后记录呼叫失败。如果 70%的呼叫失败，断路器将打开。</p><h1 id="5db4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Spring Boot 应用中的断路器示例</h1><p id="3470" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们已经介绍了断路器的必要概念。现在，我将展示我们可以在 Spring Boot 应用中使用断路器。</p><p id="8ead" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一方面，我们有一个 REST 应用程序<code class="fe mb mc md me b">BooksApplication</code>，它主要存储图书馆书籍的详细信息。另一方面，我们有一个应用程序<code class="fe mb mc md me b">Circuitbreakerdemo</code>，它使用<code class="fe mb mc md me b">RestTemplate</code>调用 REST 应用程序。我们将通过断路器装饰我们的休息呼叫。</p><p id="82a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">BooksApplication</code>在 MySQL 数据库表<code class="fe mb mc md me b">librarybooks</code>中存储关于书籍的信息。这个应用程序的 REST 控制器有<code class="fe mb mc md me b">GET</code>和<code class="fe mb mc md me b">POST</code>方法。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="5935" class="mn kz in me b gy mo mp l mq mr">package com.betterjavacode.books.controllers;<br/><br/>import com.betterjavacode.books.daos.BookDao;<br/>import com.betterjavacode.books.models.Book;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/>import java.util.Optional;<br/><br/>@CrossOrigin("https://localhost:8443")<br/>@RestController<br/>@RequestMapping("/v1/library")<br/>public class BookController<br/>{<br/>    @Autowired<br/>    BookDao bookDao;<br/><br/>    @GetMapping("/books")<br/>    public ResponseEntity&lt;List&lt;Book&gt;&gt; getAllBooks(@RequestParam(required = false) String bookTitle)<br/>    {<br/>        try<br/>        {<br/>            List&lt;Book&gt; listOfBooks = new ArrayList&lt;&gt;();<br/>            if(bookTitle == null || bookTitle.isEmpty())<br/>            {<br/>                bookDao.findAll().forEach(listOfBooks::add);<br/>            }<br/>            else<br/>            {<br/>                bookDao.findByTitleContaining(bookTitle).forEach(listOfBooks::add);<br/>            }<br/><br/>            if(listOfBooks.isEmpty())<br/>            {<br/>                return new ResponseEntity&lt;&gt;(HttpStatus.<em class="mt">NO_CONTENT</em>);<br/>            }<br/><br/>            return new ResponseEntity&lt;&gt;(listOfBooks, HttpStatus.<em class="mt">OK</em>);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(null, HttpStatus.<em class="mt">INTERNAL_SERVER_ERROR</em>);<br/>        }<br/>    }<br/><br/>    @GetMapping("/books/{id}")<br/>    public ResponseEntity&lt;Book&gt; getBookById(@PathVariable("id") long id)<br/>    {<br/>        try<br/>        {<br/>            Optional&lt;Book&gt; bookOptional = bookDao.findById(id);<br/><br/>            return new ResponseEntity&lt;&gt;(bookOptional.get(), HttpStatus.<em class="mt">OK</em>);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(null, HttpStatus.<em class="mt">INTERNAL_SERVER_ERROR</em>);<br/>        }<br/>    }<br/><br/>    @PostMapping("/books")<br/>    public ResponseEntity&lt;Book&gt; addABookToLibrary(@RequestBody Book book)<br/>    {<br/>        try<br/>        {<br/>            Book createdBook = bookDao.save(new Book(book.getTitle(), book.getAuthor(),<br/>                    book.getIsbn()));<br/>            return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.<em class="mt">CREATED</em>);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(null, HttpStatus.<em class="mt">INTERNAL_SERVER_ERROR</em>);<br/>        }<br/>    }<br/><br/>    @PutMapping("/books/{id}")<br/>    public ResponseEntity&lt;Book&gt; updateABook(@PathVariable("id") long id, @RequestBody Book book)<br/>    {<br/>        Optional&lt;Book&gt; bookOptional = bookDao.findById(id);<br/><br/>        if(bookOptional.isPresent())<br/>        {<br/>            Book updatedBook = bookOptional.get();<br/>            updatedBook.setTitle(book.getTitle());<br/>            updatedBook.setAuthor(book.getAuthor());<br/>            updatedBook.setIsbn(book.getIsbn());<br/>            return new ResponseEntity&lt;&gt;(bookDao.save(updatedBook), HttpStatus.<em class="mt">OK</em>);<br/>        }<br/>        else<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.<em class="mt">NOT_FOUND</em>);<br/>        }<br/>    }<br/><br/>    @DeleteMapping("/books/{id}")<br/>    public ResponseEntity&lt;HttpStatus&gt; deleteABook(@PathVariable("id") long id)<br/>    {<br/>        try<br/>        {<br/>            bookDao.deleteById(id);<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.<em class="mt">NO_CONTENT</em>);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.<em class="mt">INTERNAL_SERVER_ERROR</em>);<br/>        }<br/>    }<br/>}</span></pre><p id="65c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一方面，我们的应用程序<code class="fe mb mc md me b">Circuitbreakerdemo</code>有一个带有百里香模板的控制器，因此用户可以在浏览器中访问应用程序。</p><p id="d926" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">出于演示的目的，我在一个单独的 bean 中定义了 CircuitBreaker，我将在我的服务类中使用它。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="deb4" class="mn kz in me b gy mo mp l mq mr">@Bean<br/>public CircuitBreaker countCircuitBreaker()<br/>{<br/>    CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.<em class="mt">custom</em>()<br/>            .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.<em class="mt">COUNT_BASED</em>)<br/>            .slidingWindowSize(10)<br/>            .slowCallRateThreshold(65.0f)<br/>            .slowCallDurationThreshold(Duration.<em class="mt">ofSeconds</em>(3))<br/>            .build();<br/><br/>    CircuitBreakerRegistry circuitBreakerRegistry =<br/>            CircuitBreakerRegistry.<em class="mt">of</em>(circuitBreakerConfig);<br/><br/>    CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("BooksSearchServiceBasedOnCount");<br/><br/>    return cb;<br/>}<br/><br/>@Bean<br/>public CircuitBreaker timeCircuitBreaker()<br/>{<br/>    CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.<em class="mt">custom</em>()<br/>            .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.<em class="mt">TIME_BASED</em>)<br/>            .minimumNumberOfCalls(3)<br/>            .slidingWindowSize(10)<br/>            .failureRateThreshold(70.0f)<br/>            .waitDurationInOpenState(Duration.<em class="mt">ofSeconds</em>(10))<br/>            .build();<br/><br/>    CircuitBreakerRegistry circuitBreakerRegistry =<br/>            CircuitBreakerRegistry.<em class="mt">of</em>(circuitBreakerConfig);<br/><br/>    CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("BookSearchServiceBasedOnTime");<br/>    return cb;<br/>}</span></pre><p id="dfa5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我定义了两个 beans，一个用于基于计数的断路器，另一个用于基于时间的断路器。</p><p id="bf9c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mb mc md me b">BookStoreService</code>将包含一个调用图书应用程序并显示可用的图书。该服务将如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="fa1f" class="mn kz in me b gy mo mp l mq mr">@Controller<br/>public class BookStoreService<br/>{<br/><br/>    private static final Logger <em class="mt">LOGGER </em>= LoggerFactory.<em class="mt">getLogger</em>(BookStoreService.class);<br/><br/>    @Autowired<br/>    public BookManager bookManager;<br/><br/>    @Autowired<br/>    private CircuitBreaker timeCircuitBreaker;<br/><br/>    @RequestMapping(value = "/home", method= RequestMethod.<em class="mt">GET</em>)<br/>    public String home(HttpServletRequest request, Model model)<br/>    {<br/>        return "home";<br/>    }<br/><br/>    @RequestMapping(value = "/books", method=RequestMethod.<em class="mt">GET</em>)<br/>    public String books(HttpServletRequest request, Model model)<br/>    {<br/>        Supplier&lt;List&lt;Book&gt;&gt; booksSupplier =<br/>                timeCircuitBreaker.decorateSupplier(() -&gt; bookManager.getAllBooksFromLibrary());<br/><br/>        <em class="mt">LOGGER</em>.info("Going to start calling the REST service with Circuit Breaker");<br/>        List&lt;Book&gt; books = null;<br/>        for(int i = 0; i &lt; 15; i++)<br/>        {<br/>            try<br/>            {<br/>                <em class="mt">LOGGER</em>.info("Retrieving books from returned supplier");<br/>                books = booksSupplier.get();<br/>            }<br/>            catch(Exception e)<br/>            {<br/>                <em class="mt">LOGGER</em>.error("Could not retrieve books from supplier", e);<br/>            }<br/>        }<br/>        model.addAttribute("books", books);<br/><br/>        return "books";<br/>    }<br/>}</span></pre><p id="8e90" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以当用户点击图书页面时，我们从 BooksApplication REST 服务中检索图书。</p><p id="9b85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我已经为<code class="fe mb mc md me b">countCircuitBreaker</code>自动绑定了 bean。出于演示的目的——我将在一个循环中调用 REST 服务 15 次来获取所有的书。这样，我可以在我的 REST 服务端模拟中断。</p><p id="3692" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的断路器装饰了一个对远程服务进行 REST 调用的供应商，该供应商存储了我们的远程服务调用的结果。</p><p id="e162" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个演示中，我们以顺序方式调用 REST 服务，但是远程服务调用也可以并行发生。断路器仍将跟踪结果，不管是顺序调用还是并行调用。</p><h1 id="a748" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">演示</h1><p id="16d8" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">现在，我们来看看断路器在现场演示中将如何工作。我的 REST 服务在端口 8443 上运行，我的<code class="fe mb mc md me b">Circuitbreakerdemo</code>应用程序在端口 8743 上运行。</p><p id="6c05" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最初，我启动这两个应用程序并访问<code class="fe mb mc md me b">Circuitbreakerdemo</code>应用程序的主页。主页包含查看书店所有书籍的链接。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/5577a3b39bb882203273bb0b83aa1467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*0N1-p7_W3fcfo0cd"/></div></figure><p id="23f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在为了模拟一些错误，我在我的 RestTemplate 调用中添加了以下代码，该调用在返回 REST 调用的结果之前基本上会休眠 3 秒钟。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="930b" class="mn kz in me b gy mo mp l mq mr">public List&lt;Book&gt; getAllBooksFromLibrary ()<br/>{<br/>    HttpHeaders httpHeaders = new HttpHeaders();<br/>    httpHeaders.setContentType(MediaType.<em class="mt">APPLICATION_JSON</em>);<br/><br/>    ResponseEntity&lt;List&lt;Book&gt;&gt; responseEntity;<br/>    long startTime = System.<em class="mt">currentTimeMillis</em>();<br/>    <em class="mt">LOGGER</em>.info("Start time = {}", startTime);<br/>    try<br/>    {<br/>        responseEntity= restTemplate.exchange(buildUrl(),<br/>                HttpMethod.<em class="mt">GET</em>, null, new ParameterizedTypeReference&lt;List&lt;Book&gt;&gt;()<br/>                {});<br/>        if(responseEntity != null &amp;&amp; responseEntity.hasBody())<br/>        {<br/>            <em class="mt">LOGGER</em>.info("Total time to retrieve results = {}",<br/>                    System.<em class="mt">currentTimeMillis</em>() - startTime);<br/>            return responseEntity.getBody();<br/>        }<br/>    }<br/>    catch (URISyntaxException e)<br/>    {<br/>        <em class="mt">LOGGER</em>.error("URI has a wrong syntax", e);<br/>    }<br/><br/>    <em class="mt">LOGGER</em>.info("No result found, returning an empty list");<br/>    return new ArrayList&lt;&gt;();<br/>}</span></pre><p id="4381" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简而言之，我的断路器循环将调用服务足够多次，超过持续时间超过 3 秒的缓慢调用的 65%的阈值。一旦我点击了<code class="fe mb mc md me b">here</code>的链接，我将会收到结果，但是我的断路器将会打开，并且在它处于<code class="fe mb mc md me b">half-open</code>状态或者<code class="fe mb mc md me b">closed</code>状态之前不允许将来的呼叫。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9fdfabed1019e83e0d7b0fdf0ce6fc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*bA0-an566CvRTJVu"/></div></figure><p id="7bf5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你会注意到，当断路器处于<code class="fe mb mc md me b">OPEN</code>状态时，我们开始得到一个异常<code class="fe mb mc md me b">CallNotPermittedException</code>。此外，在拨打 10 个电话时，断路器是断开的。这是因为我们的滑动窗口大小是 10。</p><p id="8512" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一种方法是，我可以通过关闭 REST 服务或数据库服务来模拟错误。这样，REST 调用可能会比需要的时间长。</p><p id="e1c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们将<code class="fe mb mc md me b">COUNT_BASED</code>断路器切换到<code class="fe mb mc md me b">TIME_BASED</code>断路器。在<code class="fe mb mc md me b">TIME_BASED</code>断路器中，我们将在一秒钟后关闭我们的 REST 服务，然后我们将从主页点击<code class="fe mb mc md me b">here</code>链接。如果最后 10 秒钟内 70%的呼叫失败，我们的断路器将会打开。</p><p id="75be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于 REST 服务已关闭，我们将在<code class="fe mb mc md me b">Circuitbreakdemo</code>应用程序中看到以下错误</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/c62e06651e0d093efc3167dec06c59e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*dyaUBpik3xezDIn2"/></div></figure><p id="5f66" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将看到断路器处于<code class="fe mb mc md me b">OPEN</code>状态之前的错误数量。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d18da40eebd5866ad5bc1c9d6bc78335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*DSOcBRfu6nVGvxN6"/></div></figure><p id="ca8d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一种配置是，我们可以随时添加我们希望断路器保持断开状态的时间。对于演示，我添加了断路器将处于打开状态 10 秒钟。</p><h1 id="f80f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何处理断路开关？</h1><p id="2189" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">一个问题出现了，你如何处理断路开关？幸运的是，<code class="fe mb mc md me b">resilience4j</code>提供了一个带有<code class="fe mb mc md me b">Decorators</code>实用程序的后备配置。在大多数情况下，您总是可以配置它以从以前的成功结果中获取结果，这样用户仍然可以使用该应用程序。</p><h1 id="3864" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="4da1" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">在这篇文章中，我介绍了如何在 Spring Boot 应用中使用断路器。此演示的代码可从<a class="ae kx" href="https://github.com/yogsma/circuitbreakerdemo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="8e35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本演示中，我没有介绍如何监控这些断路器事件，因为<code class="fe mb mc md me b">resilience4j</code>该库允许存储这些带有指标的事件，用户可以使用监控系统进行监控。</p><p id="fe8c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你喜欢这篇文章，可以考虑在这里订阅我的博客。</p><p id="7928" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mt">原载于 2021 年 2 月 21 日</em><a class="ae kx" href="https://betterjavacode.com/spring-boot/how-to-use-circuit-breaker-in-spring-boot-application" rel="noopener ugc nofollow" target="_blank"><em class="mt">【https://betterjavacode.com】</em></a><em class="mt">。</em></p></div></div>    
</body>
</html>