<html>
<head>
<title>Maintainable JavaScript — Null and Object Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的 JavaScript —空值和对象检查</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/maintainable-javascript-null-and-object-checks-7a3449380eef?source=collection_archive---------7-----------------------#2020-09-25">https://blog.devgenius.io/maintainable-javascript-null-and-object-checks-7a3449380eef?source=collection_archive---------7-----------------------#2020-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8e612f4ee7661b9d20864173ef107d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bBNuPQEdnUtLQfXO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢卡斯·法夫尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f6d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想继续使用代码，创建可维护的 JavaScript 代码很重要。</p><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过查看如何检查各种数据来了解创建可维护的 JavaScript 代码的基础。</p><h1 id="0421" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型 of 和 null</h1><p id="a1f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果操作数是<code class="fe me mf mg mh b">null</code>，则<code class="fe me mf mg mh b">typeof</code>运算符返回<code class="fe me mf mg mh b">'object'</code>。</p><p id="105a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个我们不能使用<code class="fe me mf mg mh b">typeof</code>来检查的原始值。</p><p id="a516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe me mf mg mh b">null</code>对比通常不能给我们足够的信息。</p><p id="86e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们使用<code class="fe me mf mg mh b">===</code>和<code class="fe me mf mg mh b">!==</code>操作符，我们可以检查<code class="fe me mf mg mh b">null</code>。</p><p id="a861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8097" class="mq lc iq mh b gy mr ms l mt mu">const element = document.querySelector("div");<br/>if (element !== null) {<br/>  element.className = "found";<br/>}</span></pre><p id="5116" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查具有给定选择器的元素是否存在。</p><p id="bd9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果元素不存在，则<code class="fe me mf mg mh b">querySelector</code>返回<code class="fe me mf mg mh b">null</code>。</p><p id="f339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以使用<code class="fe me mf mg mh b">!==</code>或<code class="fe me mf mg mh b">===</code>操作符来检查这个值。</p><h1 id="6bfc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测参考值</h1><p id="2518" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不能使用<code class="fe me mf mg mh b">typeof</code>操作符来检查对象。</p><p id="b618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们需要另一种方法来检查它们。</p><p id="f674" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象包括对象文字和从类似<code class="fe me mf mg mh b">Object</code>、<code class="fe me mf mg mh b">Array</code>、<code class="fe me mf mg mh b">Date</code>和<code class="fe me mf mg mh b">Error</code>的构造函数创建的对象。</p><p id="be05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">typeof</code>操作符，它总是返回<code class="fe me mf mg mh b">'object'</code>。</p><p id="32c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着它对我们没有多大用处。</p><p id="1ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">typeof null</code>也返回<code class="fe me mf mg mh b">'object'</code>，所以它对检查<code class="fe me mf mg mh b">null</code>也没有用。</p><p id="08bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以使用<code class="fe me mf mg mh b">instanceof</code>操作符来检测特定引用类型的值。</p><p id="a75d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>的一般语法是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e990" class="mq lc iq mh b gy mr ms l mt mu">value instanceof constructor</span></pre><p id="5144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">value</code>是我们要检查的值。</p><p id="eafb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">constructor</code>是我们要检查<code class="fe me mf mg mh b">value</code> os 是否从其创建的构造函数。</p><p id="e25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用它来检测一个<code class="fe me mf mg mh b">Date</code>实例，方法是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fba0" class="mq lc iq mh b gy mr ms l mt mu">if (date instanceof Date) {<br/>  console.log(date.getFullYear());<br/>}</span></pre><p id="8936" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>不仅检查用于创建对象的构造函数。</p><p id="9470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还检查原型链上的构造函数。</p><p id="7313" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于几乎所有的对象都继承自<code class="fe me mf mg mh b">Object</code>，<code class="fe me mf mg mh b">date instanceof Object</code>也返回<code class="fe me mf mg mh b">true</code>。</p><p id="2929" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不能使用<code class="fe me mf mg mh b">value instanceof Object</code>来检查特定类型的对象。</p><p id="ea1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符也可以处理我们自己定义的自定义类型。</p><p id="0885" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="513c" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="639c" class="mq lc iq mh b gy mv ms l mt mu">const jane = new Person("jane");<br/>console.log(jane instanceof Object);<br/>console.log(jane instanceof Person);</span></pre><p id="1a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么两个控制台日志都将是<code class="fe me mf mg mh b">true</code>。</p><p id="a175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个是<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">jane</code>继承了<code class="fe me mf mg mh b">Object.prototype</code>。</p><p id="1484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">jane</code>是从<code class="fe me mf mg mh b">Person</code>构造函数创建的。</p><p id="92a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符是在 JavaScript 中检测定制类型的唯一方法。</p><p id="a830" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它有一个限制。</p><p id="be98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把一个物体从一帧传递到另一帧。</p><p id="ef92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6868" class="mq lc iq mh b gy mr ms l mt mu">frameAPerson instanceof frameAPerson</span></pre><p id="78db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后返回<code class="fe me mf mg mh b">true</code>。</p><p id="0f09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="17e2" class="mq lc iq mh b gy mr ms l mt mu">frameAPerson instanceof frameBPerson</span></pre><p id="13e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后返回<code class="fe me mf mg mh b">false</code>。</p><p id="cd28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个帧都有自己的<code class="fe me mf mg mh b">Person</code>副本，而<code class="fe me mf mg mh b">instanceof</code>只考虑当前帧中的<code class="fe me mf mg mh b">Person</code>。</p><p id="05d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使它们是相同的，情况也是如此。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e0d0c850660213078481d40bf5108d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AsXk36tyXVRCsdx7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@grantritchie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格兰特·里奇</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="cf55" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ebb6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符让我们检查各种对象。</p><p id="be60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一不能检查的是从不同帧传递过来的。</p></div></div>    
</body>
</html>