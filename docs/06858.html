<html>
<head>
<title>Explaining Clean Architecture In .Net Core (Breakdown &amp; Example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中解释干净的架构。核心网(细分和示例)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/explaining-clean-architecture-in-net-core-breakdown-example-f197663964c7?source=collection_archive---------0-----------------------#2022-02-08">https://blog.devgenius.io/explaining-clean-architecture-in-net-core-breakdown-example-f197663964c7?source=collection_archive---------0-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ede4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">干净的架构是关于架构抽象的:构建简单的、可维护的、灵活的、一致的软件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b2b6c9df6c0d8a9dae3a4ea8d9222b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bBKtQjrSgITXanc6"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Frans Ruiter 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="69f5" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><blockquote class="ll"><p id="4daa" class="lm ln in bd lo lp lq lr ls lt lu lv dk translated">“建筑师首先关心的是确保房子可用，而不是确保房子是砖造的。”——鲍勃叔叔</p></blockquote><p id="90b4" class="pw-post-body-paragraph lw lx in ly b lz ma jo mb mc md jr me mf mg mh mi mj mk ml mm mn mo mp mq lv ig bi mr translated"><span class="l ms mt mu bm mv mw mx my mz di"> B </span>构建/维护一个需求总是变化的复杂软件应用程序是软件开发的真正目的。软件设计可以成就你的整个项目，也可以毁掉它。想象一个场景，您在两个不同的应用程序上工作。</p><p id="4369" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">你有一个软件应用程序，其中的<em class="nf">软件架构看起来像意大利面条——每一行代码都很混乱。你不能轻易分开一切的归属；你也不能做出改变，因为你可能会破坏整个事情。</em></p><p id="8d3a" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">你也有一个软件项目，但看起来像千层面。每一层都漂亮地叠放在一起。你可以清楚的<em class="nf">了解每一层是做什么的，你可以轻松的测试一切。</em></p><p id="71fa" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们都同意千层面设计的软件架构更好。</p><p id="ae00" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">这正是清洁建筑所代表的。我们以一种简单、易于理解、尤其是灵活的方式设计我们的软件结构。</p><p id="4214" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated"><strong class="ly io">我们只关注这些<em class="nf"> e es </em>本质——我们构建必要的东西并优化可维护性</strong>。</p><p id="7ca5" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">这些概念也与<strong class="ly io"> YAGNI(你不会需要它)和 DRY(不要重复自己)原则</strong>密切相关。</p><p id="d0c4" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们建造不是为了给人留下深刻印象。我们只想满足用户的需求/期望。这样做，我们可以避免构建不必要的功能或组件。</p><p id="349d" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">对于大学毕业的学生来说，清洁建筑是一种完全不同的思维方式。学校教你使用以数据库为中心的架构(UI、业务逻辑层、数据访问层)，也就是典型的 CRUD 应用。数据库是我们应用程序的中心，我们的应用程序依赖于它。</p><p id="6eb0" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">然而，在商界，我们不能僵化。顾客总是有不同的需求。相反，我们关注以领域为中心的架构或实践，以及领域驱动设计的模式。T25】</p><p id="5845" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我不会用 DDD 的所有做法和模式来烦你。相反，我想把重点放在干净的建筑上。那是 DDD 的心脏。</p><p id="3f58" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们的清洁架构由不同的层组成:</p><ul class=""><li id="61b1" class="ng nh in ly b lz na mc nb mf ni mj nj mn nk lv nl nm nn no bi translated"><strong class="ly io">领域层(我们的应用程序所代表的模型)</strong></li><li id="9312" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">应用层(用例或如何解决用户问题。</strong>更俗称业务逻辑)</li><li id="0567" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">基础设施层(具有外部依赖性的层，如存储库、</strong>和<strong class="ly io">与服务</strong>的集成(如外部 API、Stripe 等)。))</li><li id="0f55" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">持久层(不同类型的数据库。我们通常用 ORM 与数据库对话。</strong></li><li id="82b5" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">表示层。</strong></li></ul><p id="2d1c" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated"><strong class="ly io">重要注意事项:所有内容都指向领域层</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/b29bbce3725bc9c56262541b8030b015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AfaPdOeYH4wKTGY1.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">干净的建筑</figcaption></figure><p id="30e7" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated"><strong class="ly io">我们构建我们的应用程序，使领域成为核心(从根本上说，我们确保我们的核心项目没有依赖性)</strong></p><p id="f679" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们系统的域代表了应用程序的内容。我们关注应用程序的行为和它们周围的界限。</p><p id="64e3" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们的用例(应用层)解决用户的问题。其他的都可以认为是细节。有点像你盖房子——房间是必需品，我们使用的材料是细节。</p><p id="ccd2" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">例如，表示层是一个细节。我们可以用许多不同的界面来展示我们的模型。</p><p id="b1c3" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">此外，我们的持久层是一个细节，因为我们可以实现许多其他数据库，如 NoSQL 或 SQL Server，MongoDB…</p><p id="3678" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">每一层都有明确的定义。</p><p id="0725" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">然而，干净的架构设置/构建只是第一步。企业应用程序也需要存活大约十年。</p><p id="3d06" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们大部分时间都花在维护系统上。这就是为什么我们应用程序最大的<strong class="ly io">成本(60–80 %)来自维护。</strong></p><p id="6e75" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">然而，尽管干净的架构如此美妙，我们并不需要在任何地方都实现它。</p><p id="d41f" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">当我们使用干净的架构时，我们有抽象来实现松散耦合和灵活的软件。缺点是我们增加了更多的复杂性。</p><p id="7189" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">在软件开发中，我们不遵循严格的规则。我们会根据环境和我们的业务目标来质疑什么时候使用哪种工具、模式或实践是最好的。</p><p id="5df3" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">最好从零的角度来问问题。例如，如果我们只是构建一个 REST API 应用程序，我们不需要有 5 个不同的层。那就太夸张了。</p><p id="cd15" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">然而，如果我们想要构建一个功能良好的 IOS 应用程序，能够支持许多用户，那么使用一些设计模式/坚实的原则来处理复杂性是很重要的。这完全取决于上下文</p><p id="0004" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">如果你想了解更多的坚实的原则，我增加了一个额外的链接。</p><div class="nv nw gp gr nx ny"><a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">固体:面向对象设计的前 5 个原则</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">SOLID 是前五个面向对象设计(OOD)原则的首字母缩写，由 Robert C. Martin(也称为大叔…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.digitalocean.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om km ny"/></div></div></a></div><p id="fad1" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">现在，我将向您展示一个简单、干净的架构应用程序，当您想要构建下一个应用程序时，可以使用它来构建项目结构。</p><h1 id="eb64" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">将它整合在一起</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi on"><img src="../Images/189b717beb74eb7b69fbdc8be05fd11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*cD0UUjhOnF7heN28Q0Eytw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">车队管理</figcaption></figure><p id="5a55" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我将通过一个简单的项目演示如何建立一个干净的架构。</p><p id="907b" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我正在制作一个简单的 Asp.Net 核心应用程序，它有一个 ReactJs 前端，叫做车队管理应用程序。</p><p id="5338" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">通过车队管理应用程序，公司可以管理其车队。因此应用程序可以:<br/> -管理车辆<br/> -管理加油卡<br/> -管理司机<br/> -安排维护和修理</p><p id="c40a" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我采用了单一数据库 CQRS 模式。CQRS 代表<strong class="ly io">命令质问责任分离。CQRS </strong>将读取和写入命令(插入、更新、删除)操作分开。它主要用于性能和可伸缩性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/a3d0a49baed8ff7bf807b74fa8f712d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkJzAwz8ch3bR9URyko5cw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">CQRS 模式</figcaption></figure><h2 id="061b" class="op ku in bd kv oq or dn kz os ot dp ld mf ou ov lf mj ow ox lh mn oy oz lj pa bi translated">核心项目</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/5adce29fd683dc83e68b95290cb04cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*PMe_EIy7QbIuigb12xq0Ew.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">核心项目</figcaption></figure><p id="b368" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">核心项目是所有业务规则所在的地方。实体封装了所有的业务规则。实体对其他层一无所知，并且它们不使用外层中任何其他类或组件的名称。</p><p id="16af" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我将用一个司机的实体作为例子。</p><pre class="kd ke kf kg gt pc pd pe pf aw pg bi"><span id="ffd5" class="op ku in pd b gy ph pi l pj pk">public class Drivers : BaseEntity</span><span id="1502" class="op ku in pd b gy pl pi l pj pk">{</span><span id="bcb8" class="op ku in pd b gy pl pi l pj pk">   public string Name { get; set; }</span><span id="7540" class="op ku in pd b gy pl pi l pj pk">   public string Street { get;  set; }</span><span id="d937" class="op ku in pd b gy pl pi l pj pk">    public string City { get; set; }</span><span id="e696" class="op ku in pd b gy pl pi l pj pk">    public string PostCode { get; set; }</span><span id="63e5" class="op ku in pd b gy pl pi l pj pk">    public string StreetNumber { get; set; }</span><span id="c7c1" class="op ku in pd b gy pl pi l pj pk">    public string Adres</span><span id="d547" class="op ku in pd b gy pl pi l pj pk">    {</span><span id="6fb2" class="op ku in pd b gy pl pi l pj pk">       get { return $"{Street} + {StreetNumber}, {City},       {PostCode}"; }</span><span id="bed4" class="op ku in pd b gy pl pi l pj pk">    }</span><span id="92af" class="op ku in pd b gy pl pi l pj pk">    public Datetime Birthday { get; set; }</span><span id="e517" class="op ku in pd b gy pl pi l pj pk">    public string License { get; set; }</span><span id="224b" class="op ku in pd b gy pl pi l pj pk">    public string NationalRegistrationNumber { get; set; }</span><span id="4f5a" class="op ku in pd b gy pl pi l pj pk">    public bool Employed { get; set; }</span><span id="d950" class="op ku in pd b gy pl pi l pj pk">}</span></pre><p id="1eed" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">对于我们的实体，我们应该遵循单一责任原则(任何其他类都是如此)。我们的对象应该有很高的“内聚力”方法和属性都应该与类的目的紧密相关。理解类做什么和维护它要容易得多。</p><p id="eb6f" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">例如，我们的实体没有像 Required 或 MinLength 这样的数据注释。数据注释支持验证，并帮助实体框架将实体映射到关系模型中。然而，数据注释的问题是它们聚集了你的领域。</p><p id="05b7" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">如果我们要改变我们的数据访问技术(不同的 DB)，由于我们的数据注释，我们也必须改变我们的实体。所以这就是为什么我把数据注释排除在外。通过 Guard 子句和 Fluent 验证，我们可以验证我们的模型，并将验证分离到我们的应用层。</p><h2 id="d01b" class="op ku in bd kv oq or dn kz os ot dp ld mf ou ov lf mj ow ox lh mn oy oz lj pa bi translated">应用项目</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/53951d4ef85eac4ed36aece54c7ba3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*G-qAjxjyvKEzDkBwHZIAjg.png"/></div></figure><ul class=""><li id="1e1e" class="ng nh in ly b lz na mc nb mf ni mj nj mn nk lv nl nm nn no bi translated">应用程序接口</li><li id="689c" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">查看模型/dto</li><li id="f70b" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">地图绘制者</li><li id="aca4" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">应用程序例外</li><li id="7bc9" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">确认</li><li id="12a1" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">逻辑</li><li id="d107" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">命令/查询(CQRS)</li></ul><p id="dd8d" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们将用例嵌入到应用层，并拥有我们更高层次的应用逻辑或抽象。用例是与系统的交互，例如，获得所有汽车的列表，并且它是关于我们如何用我们的领域模型做事情。</p><p id="bd10" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">在 CQRS，我们对数据库的读(查询)和写(命令)使用不同的路径。我们最终要做的是将代码组织成特性。因此，功能是一个单独的命令或查询或用例。我们不再有分层的架构。</p><p id="bdde" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">您可以使用 Mediator(<a class="ae ks" href="https://www.dofactory.com/net/mediator-design-pattern" rel="noopener ugc nofollow" target="_blank">Mediator pattern</a>)为每个请求添加额外的行为，比如日志记录、缓存自动验证和性能监控。</p><p id="8a94" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我不会详细讨论事件采购的 CQRS 模式。如果你很好奇，你可以在这里了解更多:</p><div class="nv nw gp gr nx ny"><a href="https://www.upsolver.com/blog/cqrs-event-sourcing-build-database-architecture" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">CQRS，事件采购&amp;如何构建数据库架构| Upsolver</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">事件流是现代组织中增长最快的数据源之一。了解如何构建高性能…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.upsolver.com</p></div></div><div class="oh l"><div class="pn l oj ok ol oh om km ny"/></div></div></a></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi po"><img src="../Images/ce309852eaee3ba6531bf1fc043da2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*xIzcMN8UnCLy5Ctd"/></div></figure><p id="2b4a" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">请记住，应用层知道域，但不知道其他层。</p><pre class="kd ke kf kg gt pc pd pe pf aw pg bi"><span id="62a2" class="op ku in pd b gy ph pi l pj pk">public interface IApplicationDbContext <br/>{<br/>      DbSet&lt;Drivers&gt; Drivers {get;set;}<br/>      <br/>      DbSet&lt;FuelCards&gt; FuelCards {get;set;}<br/>      <br/>      DbSet&lt;Requests&gt; Requests {get;set;}</span><span id="022d" class="op ku in pd b gy pl pi l pj pk">      Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken);</span><span id="a909" class="op ku in pd b gy pl pi l pj pk"><br/>}</span></pre><p id="7b90" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我们的控制流程从表示层到基础设施层。我们通过依赖注入来实现 IApplicationDbContext。但是 IApplicationDbContext 的实现位于基础设施持久层。如果我们要切换到不同的数据库，我们可以很容易地交换它，而不会影响应用层。应用层只使用一个抽象。</p><p id="9c47" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">正是出于这个原因，我们使用了依赖倒置原则。较高层次的模块(应用层)不依赖于较低层次的实现(持久层)</p><h2 id="2f1c" class="op ku in bd kv oq or dn kz os ot dp ld mf ou ov lf mj ow ox lh mn oy oz lj pa bi translated">基础设施项目</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/29f8cb6b58428f762c3d2575e9e94ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*uMsEaICMkPWP7RDHN-xCZw.png"/></div></figure><p id="80ba" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">与 I/O 组件相关的一切都属于基础设施层。所以那就是:</p><ul class=""><li id="19c6" class="ng nh in ly b lz na mc nb mf ni mj nj mn nk lv nl nm nn no bi translated">存储库(数据访问抽象)</li><li id="117d" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">EF 数据库上下文(应用数据库上下文)</li><li id="4758" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">Web API 客户端</li><li id="1c29" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">日志适配器(是域和基础设施之间的转换器。例如，他们从 GUI 中获取输入数据，并以一种方便用例及实体的形式重新打包)</li><li id="d042" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">电子邮件/短信发送</li><li id="7e9a" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi">…</li></ul><p id="6460" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">由于这一层中的内容可能会发生变化，因此它们尽可能远离更稳定的领域层。因为它们是分开保存的，所以进行更改或用一个组件替换另一个组件相对容易。</p><h2 id="0abd" class="op ku in bd kv oq or dn kz os ot dp ld mf ou ov lf mj ow ox lh mn oy oz lj pa bi translated">Web 项目</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/ba3af23d53ad9c8e4d9097f27175da6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*J1KLnBRbjcQuFAzzijNoBw.png"/></div></figure><ul class=""><li id="968c" class="ng nh in ly b lz na mc nb mf ni mj nj mn nk lv nl nm nn no bi translated">MVC 控制器</li><li id="32d3" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">Web API 控制器</li><li id="5abd" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">认证/授权</li></ul><p id="210c" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">从用户的角度来看，<em class="nf">表示层</em>是系统的入口点。它主要关注的是将请求路由到<em class="nf">应用层</em>，并在 IoC 容器中注册所有的依赖关系。我使用 DTO 的自动映射器(数据传输对象)来传输视图模型，并将其发送到 UI。我们可以使用一个中介来处理表示层对 dto 的请求。</p><p id="299d" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">对于身份验证和授权，我们可以使用 IdentityServer 实现。</p><h1 id="0316" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">外卖食品</h1><p id="f801" class="pw-post-body-paragraph lw lx in ly b lz pr jo mb mc ps jr me mf pt mh mi mj pu ml mm mn pv mp mq lv ig bi translated">以防干净的建筑还不清楚。我补充了一个小总结。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pw"><img src="../Images/d5f3568e1b7d1b66ff527a9933a81d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N-TziOMyxwsIZ11o.jpg"/></div></div></figure><p id="cb12" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">清洁建筑的基本原则是:</p><ul class=""><li id="f83f" class="ng nh in ly b lz na mc nb mf ni mj nj mn nk lv nl nm nn no bi translated">这实际上是关于关注点的<strong class="ly io">分离(还记得千层面结构吗？</strong>每一层都与另一层分离</li><li id="214d" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">应该<strong class="ly io">独立于框架(我们可以很容易地将 ReactJs 框架替换成一个有角度的前端)</strong></li><li id="f76f" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">它们应该是<strong class="ly io">可测试的(我们可以用单元测试快速测试代码，用集成测试测试每一个特性)，也称为</strong> <a class="ae ks" href="https://www.guru99.com/test-driven-development.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ly io"> TDD(测试驱动开发)</strong> </a></li><li id="6465" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">它们应该<strong class="ly io">独立于 UI </strong></li><li id="3fa5" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated">它们应该<strong class="ly io">独立于数据库</strong></li><li id="bed0" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">干净的架构图</strong> — <strong class="ly io">核心:</strong>“企业/关键业务规则”(<strong class="ly io">实体</strong> ) — <strong class="ly io">应用</strong>:“应用业务规则”(<strong class="ly io">用例</strong> ) — <strong class="ly io">下一步</strong>:“接口适配器”(<strong class="ly io">网关、控制器、展示者</strong> ) — <strong class="ly io">展示</strong>:“框架和驱动”(<strong class="ly io">设备、Web、UI、外部接口、DB </strong></li><li id="ed61" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">最里面的圆圈</strong>是<strong class="ly io">最高级别(我们的应用程序围绕我们的领域发展)</strong></li><li id="044f" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">内圈定义接口(它们决定发生什么)</strong></li><li id="5e73" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">外环实现接口(应该如何做某事)</strong></li><li id="a14d" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">内圈不能依赖外圈(依赖规则:)</strong></li><li id="4615" class="ng nh in ly b lz np mc nq mf nr mj ns mn nt lv nl nm nn no bi translated"><strong class="ly io">外圈不能影响内圈</strong></li></ul><p id="860d" class="pw-post-body-paragraph lw lx in ly b lz na jo mb mc nb jr me mf nc mh mi mj nd ml mm mn ne mp mq lv ig bi translated">我希望你学到了一些东西。快乐编码:-)</p><h1 id="e9ea" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">资源</strong></h1><div class="nv nw gp gr nx ny"><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">清洁编码器博客</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在过去的几年里，我们已经看到了一系列关于系统架构的想法。这些包括…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">blog.cleancoder.com</p></div></div><div class="oh l"><div class="px l oj ok ol oh om km ny"/></div></div></a></div></div></div>    
</body>
</html>