# JavaScript 算法:合并 k 个排序列表

> 原文：<https://blog.devgenius.io/algorithms-with-javascript-merge-k-sorted-lists-2a76b39ddd8?source=collection_archive---------6----------------------->

像往常一样，在这篇博文中，我们将练习解决算法问题。而今天我们的 leetcode 问题是:[合并 k 个排序列表](https://leetcode.com/problems/merge-k-sorted-lists)。

![](img/aec87d9b42fb0bfb0b9b99664391aef8.png)

**问题定义:**

*合并 k 个排序链表，作为一个排序链表返回。*

*举例:*

```
*Input:**[**1->4->5,**1->3->4,**2->6**]**Output: 1->1->2->3->4->4->5->6*
```

**两个排序列表**

在只有两个排序列表的情况下，我们可以使用带有两个指针的简单二分搜索法。类似地，就像我们对两个排序列表的中位数问题所做的一样。但是当我们有 3 个或更多的列表要遍历时，就变得有点复杂了。

**K 排序列表**

首先让我们检查我们的输入中有多少列表。这将帮助我们确定我们需要多少个指针。在两个列表的情况下，我们可以硬编码两个指针，这样就可以了。但是对于未知数量的列表，我们需要不同的方法来跟踪指针和它们的位置。

此外，我们将有一个问题越来越复杂的比较。在两个列表的情况下，我们将只需要做一次比较操作，在 4 个列表的情况下，做 4 次操作，以此类推。如果我们有 100 个列表，那么硬编码条件就不那么优雅了。我们需要想出一个聪明的方法来同时比较所有的数字。

*每次迭代进行 K 次比较的时间复杂度:*

```
*O(N * K * K)*
```

*排序算法的时间复杂度:*

```
*O(N * K * log(N * K))*
```

Seams like it 把所有列表组合在一个长列表中，然后编写这个列表的排序算法，效率会变得更高。

**两人站成一排**

首先让我们写一个 while 循环，它将合并所有的列表，不管我们输入了多少个列表。我们将同时处理两个列表，并且会一直进行下去，直到输入列表的长度超过 1。

![](img/cc0d234419e114a9028576ae691c8ff6.png)

**合并功能**

正如你在上面的图片中看到的，我们递归地使用了**合并列表**。这个函数负责排序和合并当时的两个列表。请记住，这些列表已经单独排序，这意味着我们可以对它们执行简单的二分搜索法。我们将使用另一个 while 循环，它将一直工作到 a 或 b 列表不为空。在循环内部，我们有一个条件，如果 a 小于 b，那么我们更新指针，移动到列表的下一个值，如果它大于 b，那么我们更新指针，移动到列表的下一个值。下面是 margeLists 函数的样子:

**解决方案**

在所有的列表被合并和排序后，我们在列表变量中只有一个列表。我们在这个变量中返回 0 索引。

**结论**

对于软件工程师来说，使用不同的数据结构是很重要的。以下是 leetcode 对我们解决方案效率的看法:

![](img/0e0ed4cdd81a6793b4a931011be4b150.png)

看起来我们的解决方案的效率还可以更高。我会继续努力优化，并尝试不同的方法来解决这个问题。敬请期待！

不断学习，不断成长！

我们上 [LinkedIn](https://www.linkedin.com/in/pavel-ilin) 连线吧！