<html>
<head>
<title>A little Smalltalk for the soul</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个小小的心灵对话</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-little-smalltalk-for-the-soul-b12051b709d1?source=collection_archive---------1-----------------------#2021-03-16">https://blog.devgenius.io/a-little-smalltalk-for-the-soul-b12051b709d1?source=collection_archive---------1-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="65d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Smalltalk 帮助我成为了今天的软件工程师。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9595b5ff29e7c750f753147a0a865a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTCP1NCFnwlrTeK7_bmn0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在一个现代的 Smalltalk IDE (Pharo 8.0)中处理卡牌形</figcaption></figure><h1 id="ea9f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">说出来，然后去做</h1><p id="600b" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我第一次学习 IBM VisualAge Smalltalk 是在 1994 年。我参加了一个为期五周的面向对象的沉浸式课程 Smalltalk，这是 IBM 作为其对象技术大学项目的一部分提供的。我几乎立刻就爱上了 Smalltalk 语言和 IDE，并且在五个星期的晚上花了无数个小时在实验室里试验 VisualAge Smalltalk。时至今日，我从未遇到过更身临其境的开发者体验。我在 2000 年 3 月左右停止了 Smalltalk 的专业编程。</p><p id="572b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二十多年后，在我现在用 Java 编写的软件中，我仍然在使用我从 Smalltalk 中学到的关于优秀的面向对象编程的一切。我在 2004 年创建了一个开源的 Java 集合框架，现在被称为<a class="ae mb" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse 集合</a>。Eclipse 集合受 Smalltalk 集合框架的启发，但是已经远远超出了 Smalltalk 集合。我希望为 Java 程序员提供全面的面向对象和函数集合体验。</p><p id="3345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本周，我在推特上热切地谈论我什么时候可以再次体验 Smalltalk 开发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="ff9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个小时后，我决定“就这么做”，用 PharoLauncher 给<a class="ae mb" href="https://pharo.org/" rel="noopener ugc nofollow" target="_blank"> Pharo 8.0 </a>加电。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是法老号的样子。我只需点击右边的绿色播放按钮，打开我的 Pharo 8.0 Smalltalk 图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/ef15249da126e469c2f176ca67729ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTtuy1qawqf6yriBJVFXEg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">法罗伦彻</figcaption></figure><h1 id="5b16" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">选择卡牌形</h1><p id="15a6" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">决定用一种编程语言来解决一个不平凡但不太复杂的问题可能是一项挑战。幸运的是，这些年来我已经构建了许多代码表，当我想用编程语言解决更多的小问题时，我可以利用它们。</p><p id="296e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">《纸牌卡塔》是一个开源的 Java 代码卡塔，基于我在 Devoxx US 2017 上与<a class="ae mb" href="https://twitter.com/NikhilNanivade" rel="noopener ugc nofollow" target="_blank"> Nikhil Nanivadekar </a>和<a class="ae mb" href="https://twitter.com/leomrlima" rel="noopener ugc nofollow" target="_blank">莱奥·利马</a>一起发表的演讲，题目是“<a class="ae mb" href="https://www.youtube.com/watch?v=hWwbPguayNA" rel="noopener ugc nofollow" target="_blank"> Collections.compare(JDK、Eclipse、番石榴、阿帕奇…) </a>”。kata 允许开发者使用不同的集合框架来实验解决与一副扑克牌相关的问题。我们已经使用了相同的主题来比较 JVM 语言。我们三个人在 Oracle CodeOne 2018 上做了一个题为“<a class="ae mb" href="https://vimeo.com/331297954" rel="noopener ugc nofollow" target="_blank"> JVM 语言比较(Java，Kotlin，Groovy，Scala) </a>的演讲，Nikhil 和我在 Devnexus 2019 上重复了这个演讲。</p><p id="c957" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">卡牌卡塔是开源<a class="ae mb" href="https://github.com/BNYMellon/CodeKatas" rel="noopener ugc nofollow" target="_blank">代码卡塔报告</a>中包含的代码卡塔之一。这里是一副卡式的 README.md 的快速预览。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/13c5a29621fc5a5a3dc4cbf7f8ee07c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9DqbQVB6f_MgZQul1OT8g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡片组自述文件快照，带类别图，带卡片、等级和花色</figcaption></figure><h1 id="2525" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用 Smalltalk 解决扑克牌形</h1><p id="f467" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">只要你能用这种语言编写单元测试，卡牌卡塔可以用任何编程语言实现，或者使用任何集合库实现。扑克牌问题相当简单，任何看过扑克牌的人都很容易理解。</p><p id="3f1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Smalltalk 拥有强大的 ide、包、类、方法和一个简单而强大的测试框架 SUnit。我决定使用开源的 Pharo IDE。</p><p id="ad1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在 IDE 中创建了两个包。一个包含我的域类，我将其命名为<code class="fe mg mh mi mj b">DeckOfCards</code>。第二个将包含我的测试，我称之为<code class="fe mg mh mi mj b">DeckOfCards-Tests</code>。</p><p id="75fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我从<code class="fe mg mh mi mj b">Tools</code>菜单中打开<code class="fe mg mh mi mj b">System Browser</code>。我将在<code class="fe mg mh mi mj b">System Browser</code>中完成我所有的编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/eb1b33feaaad0165649d2b19dc1b89a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*m7wQomFJMhJLaZgpEqNo4g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">打开系统浏览器</figcaption></figure><p id="8a08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">System Browser</code>中，我在左侧的包列表中单击鼠标右键，创建我想要的两个包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/aab2299fec56cbba153bfd4dca2a4eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*HFqyKRE5Q-wIk4M_EiuxoA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在系统浏览器中创建新包</figcaption></figure><h1 id="4a2d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">等级和套装清单</h1><p id="8640" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在 Java 和其他支持<code class="fe mg mh mi mj b">Enum</code>类型的语言中，我会将<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>类型实现为枚举。枚举是具有一组预定义实例的类型。对于<code class="fe mg mh mi mj b">Suit</code>，数值为<code class="fe mg mh mi mj b">Hearts</code>、<code class="fe mg mh mi mj b">Diamonds</code>、<code class="fe mg mh mi mj b">Clubs</code>和<code class="fe mg mh mi mj b">Spades</code>。对于等级，值为<code class="fe mg mh mi mj b">Ace</code>到<code class="fe mg mh mi mj b">King</code>。</p><p id="a6be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Smalltalk 没有专用的<code class="fe mg mh mi mj b">Enum</code>类型。Smalltalk 中的枚举的等价物是池字典。在我为<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>创建<code class="fe mg mh mi mj b">PoolDictionary</code>类之前，我必须定义<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>。</p><p id="6d70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">System Browser</code>中，当鼠标放在<code class="fe mg mh mi mj b">DeckOfCards</code>包上时，我选择了浏览器底部的 New Class 选项卡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b85fef00d1316bf407a3fdf920b0b945.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*kG-JksmbvgSN-131X1ZCFg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用“新建类别”选项卡创建新类别</figcaption></figure><p id="d85b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一些很酷的事情发生的地方。为了创建一个新类，我向<code class="fe mg mh mi mj b">Object</code>类发送了<code class="fe mg mh mi mj b">subclass:instanceVariableNames:classVariableNames:package:</code>消息。我只需替换<code class="fe mg mh mi mj b">NameOfSubclass</code>文本并保存代码就可以了。文本前面的#很重要，因为它表示这是一个<code class="fe mg mh mi mj b">Symbol</code>，在<code class="fe mg mh mi mj b">Smalltalk</code>中是一个独特的<code class="fe mg mh mi mj b">String</code>。<code class="fe mg mh mi mj b">Symbol</code>型延伸<code class="fe mg mh mi mj b">String</code> IIRC。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b3002166f113b2e7821a7a760496f02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*uy8LaD1ka55r4PmaYB4r_A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">右键单击并选择“接受”或“Mac 上的命令”</figcaption></figure><p id="63e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">Rank</code>的情况下，我想添加两个实例变量。一个我称之为<code class="fe mg mh mi mj b">name</code>，它会有一个类似<code class="fe mg mh mi mj b">ACE</code>或<code class="fe mg mh mi mj b">TWO</code>的名字。另一个我将调用<code class="fe mg mh mi mj b">order</code>，它将包含等级的自然顺序(例如 ACE <code class="fe mg mh mi mj b">order</code> = 1，TWO <code class="fe mg mh mi mj b">order</code> = 2 等)。).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/46214b17c8b5eb5dd98270112d231319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*FLIChms7wSXmU1nARJBRVw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将 name 和 order 实例变量添加到 Rank 中—再次右键单击并接受</figcaption></figure><p id="1485" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我将为<code class="fe mg mh mi mj b">name</code>和<code class="fe mg mh mi mj b">order</code>添加 getters 和 setters。Smalltalk 中的 getter 与变量同名，没有参数。Smalltalk 中的 setter 与变量同名，但它采用一个参数，并且在方法名之后出现一个冒号(:)。没有参数的方法称为<em class="mp">一元消息</em>。采用一个或多个参数的方法称为<em class="mp">关键字消息</em>。还有<em class="mp">二进制消息</em>，是类似<code class="fe mg mh mi mj b">&gt;</code>、<code class="fe mg mh mi mj b">&lt;</code>、<code class="fe mg mh mi mj b">=</code>、<code class="fe mg mh mi mj b">+</code>、<code class="fe mg mh mi mj b">-</code>等方法。二进制消息在方法名后不需要冒号，并且只接受一个参数。</p><h2 id="7913" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">添加 Smalltalk 实例方法</h2><p id="04c6" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">首先，我将为<code class="fe mg mh mi mj b">Rank</code>名称添加一个 getter。我选择了<code class="fe mg mh mi mj b">Rank</code>类。然后我确保“Inst。侧”单选按钮被选中，因为我正在添加一个实例方法。类可以有实例和类方法。然后我点击标题为“+ Inst”的选项卡。方法”。我看到了一个显示如何添加方法的模板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/3780668e52074a540aebcb755469374e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*jdb--VXbbd95LqiD2nLgHA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加实例方法</figcaption></figure><p id="3a5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我输入了所有内容，并输入了一个简单的<code class="fe mg mh mi mj b">name</code>getter 所需的文本，然后右键单击并选择 accept 或输入 Command-S 来保存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/6833bdc13ae8f89b5a8ad23a23501c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egIa2Q0gQEo4EX8iF6PaxQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实现等级名称 getter</figcaption></figure><p id="aad3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法名为<code class="fe mg mh mi mj b">name</code>，语句<code class="fe mg mh mi mj b">^name</code>翻译成“返回名”。插入符号是 Smalltalk 中用于从方法返回结果的符号。</p><p id="0338" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我为<code class="fe mg mh mi mj b">name:</code>定义 setter。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/fe88251eaa3d225d071755876b9a967f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKj60b_vaqtZC7Pfn05Ryw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实现等级名:setter</figcaption></figure><p id="8f5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法的名字是<code class="fe mg mh mi mj b">name:</code>。它与冒号有细微的不同，这表明该方法需要一个参数。冒号后是一个空格，后跟一个参数名。在这种情况下，我调用参数<code class="fe mg mh mi mj b">aName</code>。您会注意到这里没有定义静态类型。这是因为 Smalltalk 是一种动态语言。<code class="fe mg mh mi mj b">aName</code>的类型将在运行时确定，而不是在编译时。方法中的一个语句是<code class="fe mg mh mi mj b">name := aName</code>。<code class="fe mg mh mi mj b">:=</code>是 Smalltalk 中的赋值操作符。所以<code class="fe mg mh mi mj b">aName</code>的值将被赋给实例变量<code class="fe mg mh mi mj b">name</code>。</p><p id="d6cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我重复为<code class="fe mg mh mi mj b">order</code>实例变量创建 getter 和 setter。</p><p id="2678" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我提供了<code class="fe mg mh mi mj b">=</code>和<code class="fe mg mh mi mj b">hash</code>的实现。Smalltalk 中的<code class="fe mg mh mi mj b">=</code>方法用于测试相等性。正如我之前提到的，赋值是通过<code class="fe mg mh mi mj b">:=</code>实现的。如果你覆盖了<code class="fe mg mh mi mj b">=</code>，你也应该覆盖<code class="fe mg mh mi mj b">hash</code>。</p><p id="1c0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我为<code class="fe mg mh mi mj b">Rank</code>实现的<code class="fe mg mh mi mj b">=</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/c9dc237e4ce508bd41a2738f3f4d08b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLQ-GBc3miRKRzyRxwIMCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实现=对于等级</figcaption></figure><p id="96c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我为<code class="fe mg mh mi mj b">Rank</code>实现的<code class="fe mg mh mi mj b">hash</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d5e743d47e9ed7add84bf59a484fa76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHhF8-VlR9WKa6X4sKz4vw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实施<code class="fe mg mh mi mj b">hash</code>进行排名</figcaption></figure><p id="819a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Smalltalk 中，你对你的方法进行分类或归类。您还可以一次编辑一种方法。我将 getters 和 setters 放在访问类别中。</p><p id="bcb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我为<code class="fe mg mh mi mj b">Suit</code>类重复了同样的工作，添加了<code class="fe mg mh mi mj b">name</code>和<code class="fe mg mh mi mj b">order</code>实例变量、getters 和 setters，并覆盖了<code class="fe mg mh mi mj b">=</code>和<code class="fe mg mh mi mj b">hash</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/2d8ae438b634297e70b7944b522ac7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxR3_GK1QyBV4_iwB3IA3Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加带有实例变量、getters 和 setters 以及=和 hash 的 Suit 类</figcaption></figure><h1 id="9261" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">枚举</h1><p id="8a15" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在 Java 版本的纸牌卡塔中，我们将<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>类型定义为枚举。一个<code class="fe mg mh mi mj b">Suit</code>将有<code class="fe mg mh mi mj b">DIAMONDS</code>、<code class="fe mg mh mi mj b">HEARTS</code>、<code class="fe mg mh mi mj b">SPADES</code>和<code class="fe mg mh mi mj b">CLUBS</code>的实例。一个<code class="fe mg mh mi mj b">Rank</code>将拥有从<code class="fe mg mh mi mj b">Ace</code>到<code class="fe mg mh mi mj b">King</code>的所有等级的实例。</p><p id="fd1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Smalltalk 没有枚举的特殊类型。相反，我必须定义两个池字典— <code class="fe mg mh mi mj b">RankConstants</code>和<code class="fe mg mh mi mj b">SuitConstants</code>。这是 Java 版本比 Smalltalk 版本更简洁的一个例子。</p><p id="6cf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了给<code class="fe mg mh mi mj b">SuitConstants</code>定义<code class="fe mg mh mi mj b">PoolDictionary</code>，我将创建一个新类，并让它扩展<code class="fe mg mh mi mj b">SharedPool</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/b470be89b0797eebf06f8459202ec3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXcQxGvRsq243PtbRYjcDg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将 SuitConstants 创建为 SharePool 的子类</figcaption></figure><p id="83d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将<code class="fe mg mh mi mj b">Clubs</code>、<code class="fe mg mh mi mj b">Diamonds</code>、<code class="fe mg mh mi mj b">Hearts</code>和<code class="fe mg mh mi mj b">Spades</code>作为类变量添加到<code class="fe mg mh mi mj b">classVariableNames</code>字符串中。然后我必须定义一个<code class="fe mg mh mi mj b">initialize</code>方法作为类方法。所以在这里我将点击<em class="mp">类侧</em>单选按钮来添加方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/024f5866a0421924091b76e5426d561c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOLx8ozWFqW1XsXGG7h5kQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">向 SuitConstants 添加 initialize 类方法</figcaption></figure><p id="eaf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我决定在这里添加一个名为<code class="fe mg mh mi mj b">withName:order:</code>的类方法。所以我给<code class="fe mg mh mi mj b">Suit</code>加了那个类方法，给<code class="fe mg mh mi mj b">Rank</code>加了一个类似的类方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2fa9238954164f83bc23c911e8b61d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVVw2J2_rVvJfcpMGUWT4Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加 withName:order: class 方法以适应类</figcaption></figure><p id="170a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Smalltalk 中，您可以使用消息后的<code class="fe mg mh mi mj b">;</code>将消息发送到一个对象。所以在上面的代码中，我通过调用<code class="fe mg mh mi mj b">self new</code>创建了一个<code class="fe mg mh mi mj b">Suit</code>的新实例。这种情况下的自我就是套装类。然后我在那个实例上调用<code class="fe mg mh mi mj b">name:</code>方法。下一个对 order:的调用被发送到与被调用的<code class="fe mg mh mi mj b">name: </code>方法相同的接收者。然后我调用方法<code class="fe mg mh mi mj b">yourself</code>，每个对象都懂。<code class="fe mg mh mi mj b">yourself</code>消息将返回从对<code class="fe mg mh mi mj b">self new</code>的调用中返回的实例。</p><p id="2163" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们回到<code class="fe mg mh mi mj b">SuitConstants</code> <code class="fe mg mh mi mj b">initialize</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/e0cf6f47d978a06aaa0bb54a5c7d50c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpSy-KQ18B_SHDRIVf94zQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SuitConstants 类方法—初始化</figcaption></figure><p id="3f29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我使用类方法<code class="fe mg mh mi mj b">withName:order:</code>创建了一个<code class="fe mg mh mi mj b">Suit</code>的实例，并将结果赋给每个相应的类变量。在我创建一个<code class="fe mg mh mi mj b">DeckOfCards</code>之前，需要调用这个<code class="fe mg mh mi mj b">initialize</code>方法。我为<code class="fe mg mh mi mj b">RankConstants</code>类定义了一个类似的初始化方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3b9e30d7a04f0961a0ab368a85d4d464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cbqXfFeOBW9grDUVms7jA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">RankConstants 类方法—初始化</figcaption></figure><p id="eb74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我已经完成了第一组关于<code class="fe mg mh mi mj b">Rank</code>、<code class="fe mg mh mi mj b">RankConstants</code>、<code class="fe mg mh mi mj b">Suit</code>、<code class="fe mg mh mi mj b">SuitConstants</code>的方法，我准备定义<code class="fe mg mh mi mj b">Card</code>类了。</p><h1 id="e6da" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定义卡类</h1><p id="2ef3" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated"><code class="fe mg mh mi mj b">Card</code>类将是一个<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>之间的关联。我将通过计算<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>的笛卡尔乘积来创建一副牌中的所有牌。首先，我用名为<code class="fe mg mh mi mj b">rank</code>和<code class="fe mg mh mi mj b">suit</code>的实例变量定义了<code class="fe mg mh mi mj b">Card</code>类，并在类声明中包含了用于<code class="fe mg mh mi mj b">RankConstants</code>和<code class="fe mg mh mi mj b">SuitConstants</code>的两个<code class="fe mg mh mi mj b">poolDictionaries</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/ed050e5d1771490177a3940604007e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qo-ixXAagy9zt1yyWxF3Q.png"/></div></div></figure><p id="9faf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我定义了一些方法来测试一个<code class="fe mg mh mi mj b">Card</code>是否有一个特定的<code class="fe mg mh mi mj b">Suit</code>。(例如<code class="fe mg mh mi mj b">isClubs</code>、<code class="fe mg mh mi mj b">isDiamonds</code>)。</p><p id="b8fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我实现了一个名为<code class="fe mg mh mi mj b">order</code>的方法，这样我就可以在需要的时候对卡片进行排序。<code class="fe mg mh mi mj b">Card</code>的<code class="fe mg mh mi mj b">order</code>是<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>的<code class="fe mg mh mi mj b">order</code>之和。</p><p id="53e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在名为<code class="fe mg mh mi mj b">rank:suit:</code>的卡片类上定义了一个类方法。我在<code class="fe mg mh mi mj b">DeckOfCards-Tests</code>包中的<code class="fe mg mh mi mj b">CardTest</code>类中为这个方法编写了一个测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1cb9b095a2ba41eaa4eca0746ef8309a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ku8GCisWUQ0ewLL8duaXFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡片测试钻石方法测试等级:套装:</figcaption></figure><p id="747a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在<code class="fe mg mh mi mj b">Rank</code>上定义了一个名为<code class="fe mg mh mi mj b">of:</code>的实例方法。<code class="fe mg mh mi mj b">of:</code>方法创建了一个<code class="fe mg mh mi mj b">Card</code>。我在<code class="fe mg mh mi mj b">CardTest</code>类中包含了<code class="fe mg mh mi mj b">RankConstants</code>和<code class="fe mg mh mi mj b">SuitConstants</code>池字典。这允许我通过池字典中定义的名称来引用所有的<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>实例。我觉得<code class="fe mg mh mi mj b">Ace of: Diamonds</code>或者<code class="fe mg mh mi mj b">Jack of: Clubs</code>非常容易阅读和理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ea02c46148cda958cfcad597df556fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mr14YxXgbypoI1GK9FJcrw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在秩上定义的 of:方法</figcaption></figure><p id="eace" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让测试工作，我在卡<code class="fe mg mh mi mj b">class</code>上定义了一个合适的<code class="fe mg mh mi mj b">=</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/cb935975be7fedc3371608cecbc8acd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Gafl4O2WJkA0KJyP2uhUA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡片上定义的=方法</figcaption></figure><h2 id="d0e5" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">创建一副牌</h2><p id="0415" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我给名为<code class="fe mg mh mi mj b">createDeck</code>的<code class="fe mg mh mi mj b">Card</code>类添加了一个类方法。这通过产生<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>的笛卡尔乘积创建了<code class="fe mg mh mi mj b">Card</code>的<code class="fe mg mh mi mj b">Collection</code>。Smalltalk 中没有笛卡尔积方法，所以我通过对所有的<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>实例使用<code class="fe mg mh mi mj b">flatCollect:</code>和<code class="fe mg mh mi mj b">collect:</code>来实现笛卡尔积。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6e016325d2b009b9773894049a759157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-0jGiGxBLSe8mvUmmf3jg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡片创建方法</figcaption></figure><p id="df40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在<code class="fe mg mh mi mj b">Rank</code>和<code class="fe mg mh mi mj b">Suit</code>上定义了<code class="fe mg mh mi mj b">all</code>方法，这样我就可以在<code class="fe mg mh mi mj b">createDeck</code>方法中获得这两种类型的所有实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/f1883182b1a07878e07af1f753a3c8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CycW0gqFjMFbBUCMlKVT1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用级联 add: messages 到集合来定义用于排名的 all 方法</figcaption></figure><h1 id="08b7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建 DeckOfCardsTest 和 DeckOfCards 类</h1><p id="c498" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">一个<code class="fe mg mh mi mj b">DeckOfCards</code>应该是不可变的。在一个完美的世界中，一副牌中的任何一张牌都不能被添加、删除或修改。在闲聊中或者如果你有小孩，这是很难实现的。对于小型版本的 DeckOfCards 卡形，我使用封装和防御副本来防止牌组中的牌被操纵。我没有编写测试来验证一副牌中的牌永远不会变异。如果读者愿意接受这个挑战，我将把它作为一个练习留给他们。</p><p id="729c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我首先创建一个<code class="fe mg mh mi mj b">DeckOfCardsTest</code>类来保存我将为添加到<code class="fe mg mh mi mj b">DeckOfCards</code>类中的方法编写的测试。我在<code class="fe mg mh mi mj b">poolDictionaries</code>中包含了<code class="fe mg mh mi mj b">RankConstants</code>和<code class="fe mg mh mi mj b">SuitConstants</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/4fc1ebca776dd398bde0fcc44b8fe60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHNLn4KYKWeRF0_8Egx11w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DeckOfCardsTest 类</figcaption></figure><h2 id="788f" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">testAllCards 测试</h2><p id="9bb8" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我编写的第一个测试验证了一副牌中有 52 张牌，每副牌有 4 套 13 张。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/7dc02b0a7dfd931aa61b82b11eb9fce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ls9YriDPZTnPiiE3K0Q4g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DeckOfCardsTest 中的 testAllCards 测试</figcaption></figure><p id="57bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我使用<code class="fe mg mh mi mj b">new</code>消息创建一个<code class="fe mg mh mi mj b">DeckOfCards</code>时，会自动调用<code class="fe mg mh mi mj b">initialize</code>方法。这是 Smalltalk 中常见的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/1cf40a32024629e018816e169abbb926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjpphfj43wDpoUY3LN5kVg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DeckofCards 初始化方法</figcaption></figure><p id="4a07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">initialize</code>方法中，我调用<code class="fe mg mh mi mj b">Card</code> <code class="fe mg mh mi mj b">createDeck</code>，然后使用<code class="fe mg mh mi mj b">&lt;</code>创建一个<code class="fe mg mh mi mj b">SortedCollection</code>来比较每个<code class="fe mg mh mi mj b">Card</code>。我将卡片按照它们的<code class="fe mg mh mi mj b">Suit</code>分组，并将其存储在<code class="fe mg mh mi mj b">cardsBySuit</code>实例变量中。</p><p id="c328" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">testAllCards</code>测试中，我最终在<code class="fe mg mh mi mj b">DeckOfCards</code>上调用了<code class="fe mg mh mi mj b">allCards</code>。这是我通过调用<code class="fe mg mh mi mj b">asOrderedCollection</code>创建防御副本的一个地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/1c0b52d5b7fd052c2e14567bdaedef3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG_4GC3viCBrlccmnIgz6w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">扑克牌的实现</figcaption></figure><h2 id="a6a8" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">梅花测试，方块测试，红桃测试，黑桃测试</h2><p id="0bc7" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我将实现这些方法中的每一个，但只显示其中的一个，这样您就可以看到发生了什么。</p><p id="969f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<code class="fe mg mh mi mj b">testClubs</code>的实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4b48aed76787b9733a216f56567a0489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxyvVkxYPLbWAhNi5k6gNA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DeckOfCardsTest 测试俱乐部的实现</figcaption></figure><p id="89e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将使用我在<code class="fe mg mh mi mj b">initialize</code>方法中创建的<code class="fe mg mh mi mj b">cardsBySuit</code>分组在<code class="fe mg mh mi mj b">DeckOfCards</code>上实现<code class="fe mg mh mi mj b">clubs</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/7f87741ecad9a1772665b2545356665e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_nu1cZvsXNfKKQHHCeNxw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">迪卡俱乐部法的实施</figcaption></figure><p id="53d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mg mh mi mj b">DeckOfCards</code>的<code class="fe mg mh mi mj b">initialize</code>方法中使用的<code class="fe mg mh mi mj b">groupedBy:</code>方法创建了<code class="fe mg mh mi mj b">Suit</code>的<code class="fe mg mh mi mj b">Dictionary</code>到<code class="fe mg mh mi mj b">Card</code>的<code class="fe mg mh mi mj b">Collection</code>。所以当我在<code class="fe mg mh mi mj b">DeckOfCards</code>上调用方法<code class="fe mg mh mi mj b">clubs</code>时，它会通过常量<code class="fe mg mh mi mj b">Clubs</code>在<code class="fe mg mh mi mj b">cardsBySuit</code>和<code class="fe mg mh mi mj b">Dictionary</code>中进行简单的查找。</p><h2 id="e771" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">洗牌和发牌的测试</h2><p id="f93c" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我会通过调用不同的方法来处理一手牌中的一张<code class="fe mg mh mi mj b">Card</code>或一张<code class="fe mg mh mi mj b">Collection</code>。首先，我将洗牌三次，从一张<code class="fe mg mh mi mj b">Stack</code>的顶部发牌。</p><h2 id="3f2f" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">测试交易测试</h2><p id="9bda" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在<code class="fe mg mh mi mj b">testDeal</code>方法中，我将验证用指定数量的牌发牌的结果。我将把一个<code class="fe mg mh mi mj b">Random</code>生成器传递给<code class="fe mg mh mi mj b">DeckOfCards</code>的<code class="fe mg mh mi mj b">shuffleBy:</code>方法，这将返回一个被混洗的<code class="fe mg mh mi mj b">Card</code>的<code class="fe mg mh mi mj b">Stack</code>。然后我将使用<code class="fe mg mh mi mj b">DeckOfCards</code>从<code class="fe mg mh mi mj b">Card</code>的<code class="fe mg mh mi mj b">Stack</code>发牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/13dadd6d0d57d1e4329be88ed687b047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OvT230THppVFyOaAc7XHQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在 DeckOfCardsTest 上实现 testDeal 方法</figcaption></figure><p id="a03b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mg mh mi mj b">shuffleBy:</code>方法将从<code class="fe mg mh mi mj b">DeckOfCards</code>复制卡片，并使用传入的<code class="fe mg mh mi mj b">Random</code>生成器洗牌三次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/236924ba0e881298c9472eda6e421c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYYPlgAoeLRR_VKiOQu_vA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">洗牌:扑克牌上的方法</figcaption></figure><p id="f371" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我洗牌三次后，我用<code class="fe mg mh mi mj b">inject:into:</code>将牌<code class="fe mg mh mi mj b">push</code>到新的<code class="fe mg mh mi mj b">Stack</code>上。</p><p id="e82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">洗牌后，我从<code class="fe mg mh mi mj b">Stack</code>发了 5 张牌。然后我从<code class="fe mg mh mi mj b">Stack</code>发 2 张牌。在总共发了 7 张牌后，我核实了<code class="fe mg mh mi mj b">Stack</code>的大小是 45。我对<code class="fe mg mh mi mj b">dealCount:fromStack:</code>的方法实现如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/8e8142a7b69f85f8a6e661c5edc21e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8JaYxvna8dEVI1UaQMGXA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">方法实现</figcaption></figure><p id="362b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我使用<code class="fe mg mh mi mj b">1 to: count</code>创建一个<code class="fe mg mh mi mj b">Interval</code>。然后我调用<code class="fe mg mh mi mj b">Interval</code>上的<code class="fe mg mh mi mj b">collect:</code>和<code class="fe mg mh mi mj b">Stack</code>中的<code class="fe mg mh mi mj b">pop</code>到结果集合中。我使用<code class="fe mg mh mi mj b">asSet</code>将最终得到的集合转换成一个<code class="fe mg mh mi mj b">Set</code>。</p><h2 id="4e13" class="mq kz in bd la mr ms dn le mt mu dp li jv mv mw lm jz mx my lq kd mz na lu nb bi translated">洗牌和洗牌测试</h2><p id="0ab7" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我写的最后一个测试将测试洗牌和发五手牌，每手五张。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e3d72eb43acda3d058a3f0e64ab8e190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psKFSR734bT8ybgyDj6U7Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">纸牌测试中的洗牌和洗牌测试</figcaption></figure><p id="ec7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将在<code class="fe mg mh mi mj b">DeckOfCards</code>上编写的满足<code class="fe mg mh mi mj b">testShuffleAndDealHands</code>测试的 API 是<code class="fe mg mh mi mj b">shuffleBy:dealHands:cardsPerHand:</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e00c52eb8d05e1a4281bd7e589321b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvKhJmDJ3KcogVyvQXi4aA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">shuffle by:deal hands:cards perhand:on DeckOfCards 的实现</figcaption></figure><p id="b053" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我写的最后一个方法是<code class="fe mg mh mi mj b">dealHands:cardsPerHand:fromStack:</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/64935f043b23e5ca492109132f6519a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46ueGJMKviwQl8iSNt-BRw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DeckOfCards 上 deal hands:cardsPerHand:from stack:方法的实现</figcaption></figure><p id="44ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是实现 DeckOfCards 形所需的最终测试和方法。我使用<code class="fe mg mh mi mj b">1 to: numberOfHands</code>创建了另一个<code class="fe mg mh mi mj b">Interval</code>。然后我<code class="fe mg mh mi mj b">collect:</code>调出了给<code class="fe mg mh mi mj b">dealCount:fromStack:</code>打了那么多次电话的结果。</p><p id="482c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经完成了形。</p><h1 id="e1ff" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="018d" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我想写一些简短的代码。我写的不是通常的 Smalltalk 代码，它只是工作区中这里或那里的几行代码。我希望必须创建类和单元测试，并真正在 Smalltalk IDE 中花一些时间。在 Smalltalk 中实现 DeckOfCards 形给了我这个机会。我花了整整八个小时来练习形，并学习如何在法轮中导航。我不得不掸去 20 年 Smalltalk 蜘蛛网的灰尘，回到 Smalltalk 编码的流程中。我非常喜欢这个练习。我想起了是什么让我在 20 多岁的时候爱上了 Smalltalk 编程语言。我也欣赏 Java 中的一些可用特性(例如枚举、记录)和<a class="ae mb" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse 集合</a>(例如不可变集合、Lazy Iterables、cartesianProduct)。</p><p id="d82c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将经历写在博客上比我最初预期的更具挑战性。我想让读者体验一下我在 IDE 中从头开始实现 DeckOfCards 形的感觉。我不确定我应该尝试教多少 Smalltalk 语言，但是我试着解释我一直在做什么，以及语言和类库中的一些东西是如何工作的。也许你已经学到了足够多的知识来激发你的好奇心，也许你会想了解更多关于这种已经有 40 多年历史的令人惊讶的纯面向对象编程语言的知识。</p><p id="3f6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想<a class="ae mb" href="https://learnxinyminutes.com/docs/smalltalk/" rel="noopener ugc nofollow" target="_blank">“在 Y 分钟内学会闲聊”</a>，请查看这个资源。要下载我使用的 IDE，请查看 Pharo Smalltalk 站点。Pharo 网站也有这个<a class="ae mb" href="http://files.pharo.org/media/pharoCheatSheet.pdf" rel="noopener ugc nofollow" target="_blank"> PDF 备忘单</a>。</p><p id="88cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果你想尝试在线 Smalltalk 学习资源，你可以用<a class="ae mb" href="https://amber-lang.net/learn.html" rel="noopener ugc nofollow" target="_blank"> ProfStef </a>学习 Smalltalk。</p><p id="45aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">旅途愉快，希望你喜欢这次闲聊！</p><p id="51ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mp">我是</em><a class="ae mb" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="mp">Eclipse Collections</em></a><em class="mp">OSS 项目在</em><a class="ae mb" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="mp">Eclipse Foundation</em></a><em class="mp">的项目负责人。</em> <a class="ae mb" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="mp">月食收藏</em> </a> <em class="mp">是开投</em> <a class="ae mb" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="mp">投稿</em> </a> <em class="mp">。如果你喜欢这个库，你可以在 GitHub 上让我们知道。</em></p></div></div>    
</body>
</html>