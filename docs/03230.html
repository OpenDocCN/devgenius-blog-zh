<html>
<head>
<title>Better JavaScript — Higher-Order Functions and Call</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——高阶函数和调用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-higher-order-functions-and-call-f2372ccdfa5f?source=collection_archive---------3-----------------------#2020-10-14">https://blog.devgenius.io/better-javascript-higher-order-functions-and-call-f2372ccdfa5f?source=collection_archive---------3-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06fbdaa7121e93261f259d7528015153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2_24MZSjgHC9iJl6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阿灵顿研究公司在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="a357" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们可以用高阶函数做的事情</h1><p id="2a0d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用高阶函数做各种事情。</p><p id="0026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们让我们简化重复的代码。</p><p id="24f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不是编写一个循环来遍历一个数组并将条目推送到另一个数组。</p><p id="b306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7752" class="mn lc iq mj b gy mo mp l mq mr">const names = ["foo", "bar", 'baz'];<br/>const upper = [];<br/>for (let i = 0; i &lt;  names.length; i++) {<br/>  upper[i] = names[i].toUpperCase();<br/>}</span></pre><p id="ec01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们编写使用<code class="fe ms mt mu mj b">map</code>方法做同样的事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5d05" class="mn lc iq mj b gy mo mp l mq mr">const names = ["foo", "bar", 'baz'];<br/>const upper = names.map((name) =&gt; name.toUpperCase());</span></pre><p id="7642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用回调函数调用了<code class="fe ms mt mu mj b">map</code>,以大写形式返回每个条目。</p><p id="7061" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要短得多，简单得多。</p><p id="f41c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建自己的高阶函数，它接受回调，并通过回调函数来做我们想要的事情。</p><p id="878e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1e8a" class="mn lc iq mj b gy mo mp l mq mr">const buildString = (n, callback) =&gt; {<br/>  let result = "";<br/>  for (let i = 0; i &lt; n; i++) {<br/>    result += callback(Math.floor(Math.random() * 100) + i);<br/>  }<br/>  return result;<br/>}</span><span id="bdd1" class="mn lc iq mj b gy mv mp l mq mr">const str = buildString(8, String.fromCharCode);</span></pre><p id="d421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经创建了接受<code class="fe ms mt mu mj b">callback</code>函数的<code class="fe ms mt mu mj b">buildString</code>函数。</p><p id="3100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数中，我们创建了一个<code class="fe ms mt mu mj b">for</code>循环，并在循环的每次迭代中调用<code class="fe ms mt mu mj b">callback</code>。</p><p id="c151" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用字符代码调用is，让我们得到字符。</p><p id="4c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过传入一个长度值和<code class="fe ms mt mu mj b">String.fromCharCode</code>来调用它。</p><p id="6a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">str</code>就是<code class="fe ms mt mu mj b">'BO@B1&amp;g’</code>。</p><p id="c793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高阶函数让我们只需一次就能修复任何错误，因为没有重复的代码。</p><p id="cc00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的程序中没有代码到处传播。</p><h1 id="f3e7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用自定义接收器调用方法</h1><p id="9556" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在函数上使用<code class="fe ms mt mu mj b">call</code>方法，让我们设置<code class="fe ms mt mu mj b">this</code>的值和我们用函数调用的参数。</p><p id="91b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9fda" class="mn lc iq mj b gy mo mp l mq mr">f.call(obj, arg1, arg2, arg3);</span></pre><p id="f6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就像打电话:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a040" class="mn lc iq mj b gy mo mp l mq mr">f.call(arg1, arg2, arg3);</span></pre><p id="9c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe ms mt mu mj b">f</code>中的<code class="fe ms mt mu mj b">this</code>设置为<code class="fe ms mt mu mj b">obj</code>。</p><p id="0e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于调用可能已经被移除、修改或覆盖的方法来说，<code class="fe ms mt mu mj b">call</code>方法非常方便。</p><p id="30e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe ms mt mu mj b">hasOwnProperty</code>可以被任何对象覆盖。</p><p id="fa4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以设置:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e4b" class="mn lc iq mj b gy mo mp l mq mr">obj.hasOwnProperty = 1;</span></pre><p id="f4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e8d" class="mn lc iq mj b gy mo mp l mq mr">obj.hasOwnProperty("foo");</span></pre><p id="a22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个错误，因为<code class="fe ms mt mu mj b">hasOwnProperty</code>已经被设置为1。</p><p id="21e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<code class="fe ms mt mu mj b">hasOwnProperty</code>的更好方法是使用<code class="fe ms mt mu mj b">call</code>方法。</p><p id="34bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4611" class="mn lc iq mj b gy mo mp l mq mr">const dict = {};<br/>dict.foo = 1;<br/>delete dict.hasOwnProperty;<br/>({}).hasOwnProperty.call(dict, "foo");</span></pre><p id="104b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">foo</code>属性创建了<code class="fe ms mt mu mj b">dict</code>对象。</p><p id="1ec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们从<code class="fe ms mt mu mj b">dict</code>中删除了<code class="fe ms mt mu mj b">hasOwnProperty</code>属性。</p><p id="1b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们这样做了，我们仍然可以通过使用<code class="fe ms mt mu mj b">call</code>方法用一个空对象调用<code class="fe ms mt mu mj b">hasOwnProperty</code>。</p><p id="25fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是<code class="fe ms mt mu mj b">this</code>的值，我们想用它来调用<code class="fe ms mt mu mj b">hasOwnProperty</code>。</p><p id="c0c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而这个论点就是<code class="fe ms mt mu mj b">hasOwnProperty</code>的论点。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7b8af3090d0f3088d1f3fc52270e0b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bFlkGFUz_yBKC-sY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@hazardos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hassan OUAJBIR </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0d0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c5b1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">高阶函数让我们将逻辑抽象成可重用的部分。</p><p id="30f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">call</code>方法让我们用我们想要的任意值<code class="fe ms mt mu mj b">this</code>调用一个函数。</p></div></div>    
</body>
</html>