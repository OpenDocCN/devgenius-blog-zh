<html>
<head>
<title>Kotlin ‘Either’ logic based on sealed class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于密封类的 Kotlin“要么”逻辑</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-either-logic-based-on-sealed-class-97510c16882b?source=collection_archive---------0-----------------------#2021-07-19">https://blog.devgenius.io/kotlin-either-logic-based-on-sealed-class-97510c16882b?source=collection_archive---------0-----------------------#2021-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e46b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“要么”总比“不”好…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fdf4de90e8a43d66f271d1b940bdea50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvjjgUy9pxktN5uRFsxbHw.png"/></div></div></figure><p id="c60c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数式编程带来了很多乐趣。我们有嵌套的链式方法，它们相互跟随，并将结果传递给下一个方法。</p><p id="cc98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在通常情况下，我们可以返回结果<t>来获取我们所做操作的状态。<strong class="jm io">两种</strong>方法都允许我们返回带有值或异常/错误的特定结果。</t></p><p id="d023" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以使用某种类型的库，比如 Arrow，其中任何一个逻辑都已经实现了。但更有趣的是手动创建它并了解所有细节。</p><p id="7e16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在两个相似的变体中使用密封的类结构。</p><p id="1e9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在继承的帮助下，它可以被定义为嵌套类:左边部分是错误，右边部分是结果。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="fa6a" class="kz la in kv b gy lb lc l ld le">sealed class Either&lt;out T : Any&gt; {<br/>    <br/>    data class Error(val message: String, val cause: Exception? = null) : Either&lt;Nothing&gt;()</span><span id="186e" class="kz la in kv b gy lf lc l ld le">    data class Success&lt;out T : Any&gt;(val value: T) : Either&lt;T&gt;()<br/>    object Loading : Either&lt;Nothing&gt;()<br/>}</span></pre><p id="42ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者创建独立的数据类，反正是相似的:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="0242" class="kz la in kv b gy lb lc l ld le">sealed class Either&lt;out L, out R&gt;<br/>data class Left&lt;out L&gt;(val l: L) : Either&lt;L, Nothing&gt;()<br/>data class Right&lt;out R&gt;(val r: R) : Either&lt;Nothing, R&gt;()</span></pre><p id="a9c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> I .我们的目标是获得方法的正确结果以及&lt;T&gt;T4 的一个对象中可能出现的异常</strong></p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6ac9" class="kz la in kv b gy lb lc l ld le">fun main(args: Array&lt;String&gt;) {<br/>    val result: Either&lt;String, Int&gt; = parseToInt("1001a")<br/>    when (result) {<br/>        is Left -&gt; println("Can't read due to: ${result.lft}")<br/>        is Right -&gt; println("Result: ${result.rgt}")<br/>    }<br/>}<br/>fun parseToInt(s: String): Either&lt;String, Int&gt; = try {<br/>    Right(Integer.parseInt(s))<br/>} catch (exception: Exception) {<br/>    Left(exception.message ?: "")<br/>}<br/>sealed class Either&lt;out L, out R&gt;<br/>data class Left&lt;out L&gt;(val lft: L) : Either&lt;L, Nothing&gt;()<br/>data class Right&lt;out R&gt;(val rgt: R) : Either&lt;Nothing, R&gt;()</span></pre><p id="9b97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二。我们也可以返回异常本身。</strong></p><p id="bcc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kotlin 与异常类型结合在一起，但是 Java 将异常分为 3 组:</p><ol class=""><li id="6b36" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh ll lm ln lo bi translated">选中— IOException，SqlException…</li><li id="cf0f" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">未选中 NullPointerException，NumberFormatException...</li><li id="dae0" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">错误—内存不足，堆栈溢出错误…</li></ol><p id="d9a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好只在可能发生检查异常的情况下使用任一种方法。否则，检查 null 以获得显式响应。在这里，我们将在负解析的情况下获得 NumberFormatException。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="7312" class="kz la in kv b gy lb lc l ld le">fun main(args: Array&lt;String&gt;) {<br/>    val result: Either&lt;Exception, Int&gt; = parseToInt("wrongInteger")<br/>            <br/>    val right: Any? = result.checkResult { it }<br/>    println(right)<br/>}<br/>fun parseToInt(s: String): Either&lt;Exception, Int&gt; {<br/>    return isResult { Integer.parseInt(s) }  <br/>}</span><span id="8233" class="kz la in kv b gy lf lc l ld le">sealed class Either&lt;out L, out R&gt;<br/>data class Left&lt;out L&gt;(val l: L) : Either&lt;L, Nothing&gt;()<br/>data class Right&lt;out R&gt;(val r: R) : Either&lt;Nothing, R&gt;()</span><span id="94a7" class="kz la in kv b gy lf lc l ld le">inline fun &lt;L, R, T&gt; Either&lt;L, R&gt;.checkResult(f: (R) -&gt; T) =<br/>    when (this) {<br/>        is Left -&gt; Exception("Incorrect input value: ${this.l}")<br/>        is Right -&gt; f(this.r)<br/>    }</span><span id="68e3" class="kz la in kv b gy lf lc l ld le">inline fun &lt;R&gt; isResult(f: () -&gt; R): Either&lt;Exception, R&gt; =<br/>    try {<br/>        Right(f())<br/>    } catch (e: Exception) {<br/>        Left(e)<br/>    }</span></pre><p id="bed5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用任一逻辑模拟折叠方法扩展。Fold 获取一个初始值，并将集合的第一个元素作为参数。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="47da" class="kz la in kv b gy lb lc l ld le">fun main(args: Array&lt;String&gt;) {<br/>    parseToInt("1001").fold(<br/>        { exception -&gt; println("Error due to $exception") },<br/>        { result -&gt; println("Result: $result") }<br/>    )<br/>}<br/>fun parseToInt(s: String): Either&lt;Exception, Int&gt; {<br/>    return isResult { Integer.parseInt(s) }  <br/>}</span><span id="5380" class="kz la in kv b gy lf lc l ld le">inline fun &lt;L, R, T&gt; Either&lt;L, R&gt;.fold(lft: (L) -&gt; T, rgt: (R) -&gt; T): T =<br/>    when (this) {<br/>        is Left -&gt; lft(this.l)<br/>        is Right -&gt; rgt(this.r)<br/>    }</span></pre><p id="f1cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong>。</p><p id="8f1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用任何一个的优点是获得元组，左和右部分作为 1 个结果参数。第一次看可能会感到困惑，但函数式方法使它变得有用且易于阅读。</p><p id="08a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="lu lv gp gr lw lx"><a href="https://arrow-kt.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">rrow</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">科特林标准库的功能伴侣</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">arrow-kt.io</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><div class="lu lv gp gr lw lx"><a href="https://medium.com/@jcamilorada/arrow-try-is-dead-long-live-kotlin-result-5b086892a71e" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">箭试已死，科特林结果万岁</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">几个月前，Arrow Try 被否决了，我需要一个声明性错误的替代数据结构…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>