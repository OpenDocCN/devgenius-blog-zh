<html>
<head>
<title>S.O.L.I.D Principles in Android Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">南 Android 开发中的 O.L.I.D 原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/s-o-l-i-d-principles-in-android-development-7353f4d5b23a?source=collection_archive---------1-----------------------#2022-11-23">https://blog.devgenius.io/s-o-l-i-d-principles-in-android-development-7353f4d5b23a?source=collection_archive---------1-----------------------#2022-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d73a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建 android 应用程序可能是一项复杂的任务。如果没有对 android 架构组件的良好理解，它会把你引入死胡同。理解和利用 android 架构组件库对于掌握 Android 应用程序开发的艺术非常重要。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="63c6" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">坚实的原则</strong></h1><p id="e9aa" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">当谈到下面的架构时，首先想到的是坚实的原则。它最初是由 Robert C. Martin 提出的，遵循一种规范的开发方法，使 self 和其他开发人员遵循起来不那么混乱。它使得编写可扩展、可维护和可测试的代码变得更加容易。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/1b08075c115d96f12b8c04d320e827c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kx0MJYUpOp-DXhw4cUZRhA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">南国际劳工组织原则</figcaption></figure><h1 id="09d5" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated">单一责任原则</h1><p id="0965" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">第一个原则是，每个类应该只承担一个责任，也就是说，它应该只包含与那个功能/特性相关的代码。对于每个新的特性/功能，应该有一个单独的类。这个原则产生了简短的组件，这是扩展和测试组件的关键构件。</p><p id="98f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果您想要制作一把可以进行计算的多功能刀，它有一个放大镜、光源和一把锤子:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mn"><img src="../Images/5ecb4305776820ace550417d4f2c68dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1-cwYH8jqwFACvSic_zFA.png"/></div></div></figure><p id="9fb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的单一责任原则组件/类应该是这样的。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mo"><img src="../Images/ec29a4f23b1ef827a221bc5767407e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdYWI8Aw_e1uKn52o_VKRQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">每个类只包含与特定功能相关的代码。</figcaption></figure><h1 id="282b" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated"><strong class="ak"> O:开启/关闭原理</strong></h1><p id="6ea7" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">第二个原则通常也被称为开/闭原则。顾名思义，这一原则强调:</p><p id="596c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每节课都应该</p><p id="e481" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">I)对扩展开放</p><p id="ebc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ii)禁止修改</p><p id="246a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你按照第一个单一责任原则编写了一个类/组件，你就不应该改变/修改现有的类。要添加或扩展功能，您应该只使用继承。</p><p id="d358" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在下面的示例中，我们编写了只处理 0 和 1 的情况的代码。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mp"><img src="../Images/1543acf35840d263a104b5f0cf8c351a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3xf__evgsVNyYn2jqE4KQ.png"/></div></div></figure><p id="da28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比方说，我们想添加案例来处理输入，比如 3、4 等等。为了迎合这种情况，我们必须扩展我们的类，而不是修改。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mq"><img src="../Images/7fbe13f03d7219ad3a2ed22c1f163c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBktmxZ37OskJsvcpG4VPA.png"/></div></div></figure><h1 id="a8a0" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated"><strong class="ak"> L:利斯科夫替代原理</strong></h1><p id="ffd5" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">第三个原则说明，如果您用不同的子类参数替换类参数，现有功能不应中断，即</p><p id="0ae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我)。将类“Y”作为参数的方法/函数必须能够与“Y”的任何子类一起工作</p><p id="799b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，看看下面的 Phone 类及其子类:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mq"><img src="../Images/bd2deff3ac23cfe8f321cf403f56dae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVwrTnDKORaFz5aPv_2S8g.png"/></div></div></figure><p id="77c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，假设您想拨打一个号码:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mr"><img src="../Images/7c667571370be123ed71bc2907c84798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zc--6tJG2Qw_eBJjn9jHFg.png"/></div></div></figure><p id="7efd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果手机是智能手机类型，并且被锁定了怎么办？我们不能拨这个号码。因此，功能被破坏，原则被违反。我们可以通过如下更改我们的电话管理器类来解决这个问题:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ms"><img src="../Images/ff763d185ae956e0bf6200de2648fe3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS6TVl2G9Z7JnV7hiUWIWQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">我们检查电话的实例，然后根据需要拨打号码</figcaption></figure><p id="776e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将来，如果有多种类型的电话，我们将不得不再次修改我们的电话管理器类。然而，更改 Phone Manager 类会违反我们的第二个原则，即该类应该关闭以进行修改。</p><p id="1b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，正确的做法是在智能手机类中处理。更新后的代码如下所示:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mt"><img src="../Images/d2f96f74ed378bb19dae8b6717a9f881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFSjuebpN-ykRE15sEoClQ.png"/></div></div></figure><h1 id="4c12" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated"><strong class="ak"> I:界面分离原理</strong></h1><p id="ff9e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们经常最终在我们的接口中编写所有的函数，这些函数不一定需要在每个扩展类中实现。在这种情况下，复杂的接口使得扩展系统的小部分变得更加困难。接口分离原则指出，我们的复杂接口应该被分割成更小的接口，这样更容易将它们扩展到系统的相关部分。</p><p id="0652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举个例子，</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mu"><img src="../Images/afb2ea8e39cdb5df8c01c0b0d1773fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOv5_ESxdSVd8Mzb7G6qIg.png"/></div></div></figure><p id="0191" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，假设我们想要实现计算器功能，但是我们最终会得到 lightOn 和 lightOff 方法的空定义，这违反了这个原则。相反，我们应该使用这三个接口:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mu"><img src="../Images/c0d69bfd458e32adfd30ed28968aca47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTfHyvcDW02CQf4r0-IY9Q.png"/></div></div></figure><h1 id="4f28" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated"><strong class="ak"> D:依存倒置原则</strong></h1><p id="9d79" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">最后一项原则指出:</p><p id="a678" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">I)不应该有隐藏的依赖性</p><p id="bbe1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ii)让调用类创建依赖性，而不是让被调用类自己创建依赖性</p><p id="9028" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举个例子，</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mv"><img src="../Images/021f7fb42212a33db55faa2f1ca40dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gklREcSTVe3JxtHWoMqiQ.png"/></div></div></figure><p id="3b10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，调用 Bank()的类不知道 Bank 构造函数在其中创建的依赖项，这违反了这个原则。相反，应该这样重构它:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mw"><img src="../Images/1bcc466116cab913b0cc3d2af79e0154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98cp6zAnE3I6tmB0owYSxw.png"/></div></div></figure><p id="7f2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在这种情况下，调用类将这些依赖项传递给 Bank 构造函数本身，因此它知道它，并且其中没有隐藏的依赖项。</p><p id="d54b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是编写测试用例的一个重要方面，因为我们知道每个组件，并且可以独立测试它。</p><h1 id="c71f" class="kp kq in bd kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm bi translated"><strong class="ak">结论</strong></h1><p id="d0d3" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">对于新开发人员来说，每个软件都需要可维护、可扩展、可测试和可理解。只有在软件开发的整个生命周期中实施全球开发标准，才能实现所有这些特征。S.O.L.I.D 原则为如何定义正确的方法提供了非常基本的理解，去掉了维护、扩展和理解软件的额外成本。</p></div></div>    
</body>
</html>