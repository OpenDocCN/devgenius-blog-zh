<html>
<head>
<title>Java Garbage Collection: What is the young generation, old generation, and permanent generation?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java垃圾收集:什么是年轻一代、老一代和永久一代？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-garbage-collection-what-is-the-young-generation-old-generation-and-permanent-generation-953462ae2598?source=collection_archive---------1-----------------------#2021-04-06">https://blog.devgenius.io/java-garbage-collection-what-is-the-young-generation-old-generation-and-permanent-generation-953462ae2598?source=collection_archive---------1-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2c8b9e135bdd831672a365965522ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8raugoE4d_dW5sf6is3lrg.png"/></div></div></figure><p id="dbb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在寻找关于Java的年轻一代、老一代和永久一代的基本概念，那么你来对地方了。</p><h1 id="33f2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">几代人？我们在这里谈论什么？</h1><p id="6f86" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这些术语似乎更适合人，而不是软件概念，但是继续读下去，希望它们会更有意义。</p><p id="edee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，我们在这里讨论的范围是<strong class="ka ir"> Java垃圾收集</strong>。</p><h1 id="f054" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">垃圾收集和Java</h1><p id="e2f5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在像C这样的编程语言中，开发人员必须通过相应地分配和释放内存来密切关注内存。</p><p id="5a81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Java有自己的<strong class="ka ir">自动垃圾收集</strong>，其理念是大多数开发人员不必太担心这种手动内存任务，如果有的话。</p><p id="04de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，Java中的对象被分配在一个<strong class="ka ir">堆</strong>(也称为<strong class="ka ir">堆内存</strong>)中。Java的垃圾收集算法然后<strong class="ka ir">遍历堆</strong>并且<strong class="ka ir">标记被JVM使用的对象</strong>，然后稍后<strong class="ka ir">返回并回收任何未被标记的对象的内存</strong>。</p><p id="8531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该算法的细节将在另一篇文章中讨论，但是重要的是标记本身以及堆被分配成更小的部分，称为<strong class="ka ir">代</strong>的事实。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/47e8e6116697a850cb6c10186c2fef10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXkIEt-WySxfj4pRF14dpw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">礼遇<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank">甲骨文</a>。</figcaption></figure><p id="e780" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，我们终于看到了“年轻一代”、“老一代”、“永久一代”这些术语。如果看起来吓人，不用担心；基本概念实际上非常直观。</p><h1 id="066c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">年轻一代</h1><p id="2278" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从高层次来看，<strong class="ka ir">年轻一代</strong>是所有新对象开始的地方。一旦它们在Java代码中被分配，它们就会被专门分配到这个叫做<strong class="ka ir">伊甸园</strong>的子部分。</p><p id="47bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，伊甸园空间充满了物品。此时，发生了一个<strong class="ka ir">小垃圾收集</strong>事件。</p><p id="764e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我之前描述的<strong class="ka ir">标记算法</strong>发挥作用的地方。有些对象(被<strong class="ka ir">引用</strong>的对象)被标记，有些对象(未被<strong class="ka ir">引用</strong>的对象)没有被标记。那些被标记的然后移动到年轻一代的另一个子部分，称为<strong class="ka ir">幸存者空间</strong>的<strong class="ka ir"> S0 </strong>(注意幸存者空间本身被分成两部分，S0和S1)。Java的自动垃圾收集会清除掉那些未被标记的。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/72472222ca2e883d356c99885b74f309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTftt9HbHBGKpS4jtC9T_g.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">礼遇<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank">甲骨文</a>。</figcaption></figure><p id="4660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它保持这种方式，直到伊甸园空间再次填满；此时，一个新的周期开始了。前一段的事件<strong class="ka ir">再次发生</strong>，但是在这个循环中，又有点不一样了。<strong class="ka ir"> S0 </strong>被填充，所以所有从伊甸园空间和S0幸存下来的被标记的对象实际上都去了幸存者空间的第二部分，称为<strong class="ka ir"> S1。</strong>在下图中，我们看到它们分别被标记为来自幸存者空间的<strong class="ka ir">和来自幸存者空间</strong>的<strong class="ka ir">。</strong></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/d3da97844639505443912dc309adf04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThU4tVQnOq9gddticmL8WA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">礼遇<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank">甲骨文</a>。</figcaption></figure><p id="287f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一件非常重要的事情是，任何进入幸存者空间<strong class="ka ir">的物体都会被贴上一个年龄计数器</strong>的标签。该算法将对此进行检查，以查看它是否满足阈值，从而进入下一阶段:老一代。在后面的章节中会有更多的介绍。</p><p id="a8c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，让我们在这里深呼吸，因为在下一个垃圾收集周期中，它变得有点奇怪，但还不算太糟糕。本质上，当<strong class="ka ir">伊甸园空间再次填满</strong>并触发<strong class="ka ir">另一个小的垃圾收集</strong>时，我们并没有将所有被标记(引用)的对象放入<strong class="ka ir">S1</strong>；相反，从幸存者空间和到幸存者空间被交换。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/9908298e133fe55fd035f733ee512341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA8ca_xQ_AQYcHu8taOJEg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">礼遇<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank">甲骨文</a>。</figcaption></figure><p id="f336" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望上面的图表说明了从幸存者空间到幸存者空间的切换。我个人从这里学到的是，物体没有必要从幸存者空间的<strong class="ka ir"> S0 </strong>到<strong class="ka ir"> S1 </strong>。实际上，它们只是随着每个小的垃圾收集事件交替切换到它们切换到的位置。</p><p id="5eef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，这是相当深入的本质。只要知道<strong class="ka ir">基本上所有新对象都从伊甸园空间</strong>开始，然后<strong class="ka ir">在垃圾收集周期中幸存下来，最终进入幸存者空间</strong>就足够了。</p><h1 id="f085" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">老一代人</h1><p id="1c26" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">老一代可以被认为是<strong class="ka ir">长寿对象所在的地方</strong>。基本上，如果对象<strong class="ka ir">在年轻一代</strong>中的多次垃圾收集事件之后达到某个年龄阈值 <strong class="ka ir">，那么它们可以被移动到老一代。</strong></p><p id="d0e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当对象从老一代中收集垃圾时，一个<strong class="ka ir">主要垃圾收集事件</strong>发生。</p><p id="bccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看一个<strong class="ka ir">从年轻一代的幸存者空间晋升到老一代</strong>是什么样子的。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/2b1dcf6c7f8e792e1ef8ff5dda66f6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQbQj_bGYRjiFIUWPXYekg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">礼貌<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank">神谕</a>。</figcaption></figure><p id="848b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<strong class="ka ir">任何达到8个周期的年龄阈值</strong>的幸存对象——这只是一个例子，所以不要特别记住这个数字——都被算法<strong class="ka ir">移动到老一代</strong>。</p><p id="2621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老一代人只由一个被称为<strong class="ka ir">终身任期一代</strong>的部分组成。这就是为什么在谈话或阅读中，有时这两个术语变得可以互换。</p><p id="7b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导致清除老一代的事件—同样是一个主要的垃圾收集事件— <strong class="ka ir">可能会有所不同</strong>，了解它们并不在本文的范围之内。我们继续吧。</p><h1 id="3687" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">永久的一代</h1><p id="2c65" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是一个大问题。当旧代的对象达到某个阈值时，永久代<strong class="ka ir">不<em class="mk">被填充，然后被移动(提升)到永久代。还是那句话，不是这样的！</em></strong></p><p id="549f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，JVM 会在运行时用代表应用程序的<strong class="ka ir">类和方法的元数据<strong class="ka ir">立即填充永久生成。</strong></strong></p><p id="332f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JVM有时会遵循某些规则来清除永久代，当它这样做时，它被称为<strong class="ka ir">完全垃圾收集</strong>。</p><h1 id="969e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是“停止世界”事件？</h1><p id="d7f5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个“停止世界”的事件听起来很戏剧化，但是从Java应用程序是世界的角度来考虑它。</p><p id="69f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当有一个<strong class="ka ir">小垃圾收集</strong>(记住:对于年轻一代)或一个<strong class="ka ir">大垃圾收集</strong>(对于老一代)，那么世界就停止了；换句话说，所有应用程序线程都完全停止，必须等待垃圾收集事件完成。</p><h1 id="3a65" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">就这些了，伙计们</h1><p id="bdce" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">读完这篇文章后，我希望您对年轻一代、老一代和永久一代背后的Java自动垃圾收集过程有一个更好的了解。内部细节并不那么简单，但是我认为从这个角度熟悉这些术语和一般概念并不是一个坏主意。</p><div class="ml mm gp gr mn mo"><a href="https://tremaineeto.medium.com/membership" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">通过我的推荐链接加入媒体</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">tremaineeto.medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jw mo"/></div></div></a></div><h1 id="c5a9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">来源</h1><ul class=""><li id="1395" class="nd ne iq ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">Oracle，<a class="ae mi" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> Java收藏基础知识</em> </a></li></ul></div></div>    
</body>
</html>