# 将您的第一个节点应用程序归档

> 原文：<https://blog.devgenius.io/dockerizing-your-first-node-application-ea77b952a8d6?source=collection_archive---------31----------------------->

![](img/3281836fafacfb3c7a2bf882cb2eb026.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Justus Menke](https://unsplash.com/@justusmenke?utm_source=medium&utm_medium=referral) 拍摄

Docker 对我来说一直是个谜。我一直都知道关于容器化和 Docker 的讨论，但是看配置文件和阅读关于它如何工作的文章总是让我抓狂。

最重要的是，我知道我可以做任何我想做的事情，而不用整理我的申请。是的，当在不同的计算机和环境中移动项目时，有时事情会变得有点棘手，但不知何故我总是设法让它工作。所以何必呢？那是直到现在。

最近，我在网上上了一门 Docker 课程，并将我的几个项目做了文档化。那时我才意识到 Docker **真的有多棒，安装起来又有多简单。一些众所周知的好处是:**

*   由于应用程序容器化大大降低了服务器成本，因此投资回报率很高
*   使开发变得非常容易，并且跨机器保持一致(不再有“它只在我的机器上工作”的问题)
*   每个容器都是隔离的，所以您可以在同一台机器上运行多个容器，而不用担心资源污染

在这篇文章中，我不会从理论上解释 Docker 为何如此优秀，而是将重点放在实践方面，向您展示如何将您现有的应用程序 Docker 化。我将对一个现有的节点 Web 应用程序进行 dockerize。让我们开始吧。

我们有一个非常简单的节点应用程序，带有一个列出我所有依赖项的`package.json`和一个包含我的 express 应用程序的`index.js`。下面是完整的应用程序代码:

如你所见，这是一个超级简单的应用程序。它只有一条航线，`/`，在`3000`港运行。每次点击端点时，它都会返回一个占位符文本。

您要做的第一件事是添加一个`Dockerfile`到您的根项目目录中。这个文件将定义如何构建你的 docker 应用程序的 docker 映像。它看起来是这样的:

让我们一行一行地浏览这个文件，看看发生了什么。

**第 1 行**

该文件必须以关键字`FROM`开头。这是您的图像所基于的基础图像。通常它很轻。你能想到的所有栈都有 docker 镜像:MySQL、Flask、Django、Redis、Node、React、Kafka、RabbitMQ 等等。因此，无论您的应用程序是什么，您都会找到某种基础映像来开始工作。

在我们的例子中，我们的图像基于任何节点应用程序都通用的`node:latest`

**第三行**

`EXPOSE`关键字用于从容器中公开一个端口。默认情况下，所有的容器端口都是关闭的，所以一旦你的容器开始运行，你将无法在任何端口上访问它。因此，您希望通过关键字显式公开所需的端口。

在我们的例子中，我们从我们的`index.js`得知我们的节点应用程序正在监听端口`3000`。所以我们想公开那个集装箱港口。

**第 5 行**

`RUN`关键字用于运行容器中的任何命令。任何你能想到的 Linux 命令，你都可以根据你的基本映像直接运行它，或者使用`apt-get`或者类似的东西安装这个包。

我们使用关键字来创建一个新目录，我们将把应用程序源代码放在这个目录中。

**第 7 行**

`WORKDIR`关键字基本上是一个`cd`，用于移动到我们刚刚创建的目录中。

**第九行**

这就是事情变得有趣的地方。`COPY`关键字用于将文件从本地机器复制到容器中。语法如下:

`COPY <host_directory> <container_directory>`

因此，我们将把包含所有应用程序依赖项的`package.json`从本地机器复制到我们刚刚创建并移动到的容器目录中。

**第 11 行**

这里我们使用`RUN`关键字来运行`npm install`，它将安装我们的应用程序需要的所有包。如果我们只是克隆了一个存储库，并希望安装所有的依赖项，这与我们需要做的事情完全相同。

运行这个命令后，我们的容器将拥有运行我们的应用程序所需的所有包。

**第 13 行**

这里我们只是使用`RUN`关键字来清理 NPM 缓存。默认情况下，当我们安装软件包时，其中一些会被容器缓存。缓存增加了我们图像的大小，还会在以后引入版本问题。因此，删除缓存是一个很好的做法。

**第 15 行**

这里使用相同的`COPY`语法将本地机器当前目录中的所有内容复制到容器的当前目录中。这意味着我们只是将应用程序代码从我们的机器复制到容器中。

**第 17 行**

最后，`CMD`关键字用于定义启动容器时将运行的命令。在我们的例子中，当我们运行容器时，我们希望 Node Express 应用程序启动，所以我们只是使用稍微不同的语法来执行`npm index.js`。

这就是你创建 docker 形象所需要的全部。现在，您将能够创建一个 docker 映像来在任何机器上运行您的应用程序。

# **建筑&运行集装箱进场 1**

自然，接下来要看的是如何实际创建图像，然后运行容器。这就像运行两个命令一样简单:

`docker image build -t <your_username>:<name_of_image> .`

这将使用当前目录中的 docker 文件创建图像，并根据您在`-t`标志后添加的内容对其进行命名。

`docker container run -p 80:3000 -d <image_name>`

然后，您可以使用这个命令来实际运行容器。需要注意的一点是`-p`标志:它将本地机器的端口 80 映射到容器的端口 3000。如果你回头看，我们从容器中暴露了端口 3000，因为我们的节点应用程序正在监听它。我们需要将它映射到本地机器上的一个端口，这样我们就可以通过它到达容器。语法是`-p <port_in_local_machine>:<port_in_container>`

# **建筑&运行集装箱进场 2**

如果您不太熟悉 docker 命令，并且希望有一种更简单的方法来构建和运行容器(假设您已经努力编写了 docker 文件)，那么您可以使用另一个 CLI 工具和名为`docker-compose`的配置文件。

下面是 docker-compose 文件，用于自动构建映像并运行容器:

docker-compose 文件所做的就是使用我们之前定义的 Dockerfile 从当前上下文(目录)构建图像。此外，它还进行端口映射，就像我们用`-p`标志做的那样。设置好之后，您就可以使用 CLI 并运行`docker-compose up`来构建映像并启动容器。

现在，您只需进入`localhost:80`或`localhost`就可以看到您的应用程序正在工作！！

无论何时你完成了开发或测试，你都可以通过运行`docker-compose down`来关闭一切。

如果你在理解代码时遇到困难，我很抱歉，所以我在这里链接了完整的代码示例。

如果你有任何问题，请告诉我，我将非常乐意回答。