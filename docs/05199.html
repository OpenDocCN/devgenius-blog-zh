<html>
<head>
<title>How To Correctly Build a Multi-Environment React App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确搭建多环境React App？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-correctly-build-a-multi-environment-react-app-6715ee8fcc78?source=collection_archive---------0-----------------------#2021-07-01">https://blog.devgenius.io/how-to-correctly-build-a-multi-environment-react-app-6715ee8fcc78?source=collection_archive---------0-----------------------#2021-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5bb7a1e8798abe9f17410af4cdbfc535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r_kCR3un7NIb7SV6.jpeg"/></div></div></figure><p id="3ed5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在使用Create react App构建React应用程序，则用于修改环境变量的内置支持取决于NODE_ENV值。环境文件。</p><p id="2756" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您有一个简单的部署配置时，这是非常理想的。但是，很多时候在企业级系统中，需要支持两种以上的环境；通常，还需要支持三到四种环境。您的企业需要一款多环境React应用来满足需求。据你所知，可以利用内部有经验的资源，或者有<a class="ae kt" href="https://medium.com/top-software-companies/top-reactjs-development-companies-in-india-9cd8bf3f363d" rel="noopener">顶级Reactjs开发公司</a>准备抓住机会。</p><p id="6a60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据传统观点，您可以使用内置系统通过创建额外的。env文件并将NODE_ENV变量设置为所需的值。但是，CRA不允许通过执行弹出来实现这一点，弹出会从React应用程序中移除任何默认约定，并留给您自己定制。</p><h1 id="e7e8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">目录:</h1><ol class=""><li id="a5af" class="ls lt in jx b jy lu kc lv kg lw kk lx ko ly ks lz ma mb mc bi translated"><a class="ae kt" href="#3ed5" rel="noopener ugc nofollow">简介</a></li><li id="d234" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#23c5" rel="noopener ugc nofollow">环境变量</a></li><li id="88ce" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#35af" rel="noopener ugc nofollow">建立数值</a></li><li id="3055" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#3ff1" rel="noopener ugc nofollow">环境的配置</a></li><li id="0370" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#a99e" rel="noopener ugc nofollow">环境特定。环境文件</a></li><li id="e3db" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#b54b" rel="noopener ugc nofollow">结论</a></li></ol><h1 id="23c5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">环境变量</h1><p id="0a2f" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">React接受位于项目根目录的. env文件中定义的环境变量。如果您已经熟悉了细节，请跳到环境配置，但是请记住。env作为默认值。</p><h2 id="181b" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">概观</h2><ul class=""><li id="48d2" class="ls lt in jx b jy lu kc lv kg lw kk lx ko ly ks mx ma mb mc bi translated">变量可以在您的shell或项目的根目录中定义。环境文件。</li><li id="4a83" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">导入的变量以前缀REACT_APP_开头。</li><li id="f68c" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">Process.env用于存储导入的值，例如process . env . REACT _ APP _ SECRET _ CODE。</li><li id="7c94" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">为了查看新添加/更新的变量，必须重新启动开发服务器。</li><li id="d7e7" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">shell中定义的变量优先于. env文件中定义的变量。</li><li id="db65" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">NODE_ENV自动设置为开发(使用npm启动时)、测试(使用npm测试时)或生产(使用npm构建时)。因此，从创建-反应-应用的角度来看，只有三种环境。</li></ul><h1 id="35af" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">建立价值观</h1><p id="b8dc" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">变量可以在执行npm启动或npm构建之前或期间定义:</p><p id="6abd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">$ REACT_APP_SECRET_CODE=dev123 npm start</code></p><p id="38f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">$ REACT_APP_SECRET_CODE=prod456 npm build</code></p><p id="5e33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">值可以在package.json中指定，因此可以通过修订控制进行跟踪:</p><p id="4578" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="256b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"start": "REACT_APP_SECRET_CODE=123 react-scripts start",</code></p><p id="5bce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="e9bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="c748" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然在package.json中设置设置是一种与团队共享配置的方便方法，但是这种方法不能很好地扩展。考虑增加配置变量或环境数量的后果。幸运的是，变量可以在一个名为. env的单独文件中定义。</p><p id="1b05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发服务器和构建过程会自动从. env文件中导入值。格式与shell脚本(name=value)中使用的格式相同，每行一个变量:</p><p id="3633" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">$ cat .env</code></p><p id="3ef1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">REACT_APP_SECRET_CODE=123</code></p><p id="a1d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">REACT_APP_HOST_ENV=staging</code></p><p id="c6bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">$</code></p><p id="90e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在中存储定义的优势。env文件包括以下内容:</p><ul class=""><li id="6d6f" class="ls lt in jx b jy jz kc kd kg nc kk nd ko ne ks mx ma mb mc bi translated">更容易自动化。</li><li id="0487" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">文件的设置作为默认设置，可以使用上面列出的技术之一进行修改。因此，其他人可以手动调整变量，而无需修改。环境文件。这在下面描述的多环境安排中得到了利用。</li><li id="5b65" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">Dotenv用于在create-react应用程序中执行配置。请查阅dotenv的文档，了解更多关于它的语法和语义。</li></ul><h2 id="3fc0" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">利用价值</h2><p id="2d52" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">自动将导入的值添加到process.env。它们不需要手动导入。导入的值与JS文件中指定的值行为相同:</p><p id="0c96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">if (process.env.NODE_ENV === 'production') { ... }</code></p><p id="50ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">app.listen(process.env.REACT_APP_PORT);</code></p><p id="0afc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，将只导入那些以REACT _ APP _开头的值，并且必须重新启动开发服务器或构建以获取新值。</p><h1 id="3ff1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">环境配置</h1><p id="d22e" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">现在，我们将了解如何使用reactor-apps可变支持为许多环境创建一个设置。目标是提供一个简单的方法来标准化和自动化在构建过程中使用环境特定数据的过程，而不管你的应用程序是如何构建的。</p><h2 id="d8c3" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">概观</h2><ol class=""><li id="9a21" class="ls lt in jx b jy lu kc lv kg lw kk lx ko ly ks lz ma mb mc bi translated">在。env文件，定义变量(有或没有默认值)。</li><li id="9c59" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">在目标环境的生成目录的. env.local文件中添加特定于环境的值/覆盖。</li><li id="7a03" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">创建和使用特定于环境的。如果需要，环境文件(例如，环境分段)。</li><li id="9058" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">在。环境文件，定义变量。</li></ol><p id="54e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然变量可以在create-react-app之外设置(例如，在shell启动脚本中)，但是为了准确性、可靠性和有效性，并使事情不那么怪异，我们应该选择一种在所有环境中普遍适用的方法——从本地开发到生产。这使得更广泛的团队子集能够在需要时有效地提供支持。换句话说，我们希望采用最有利于建立流程的策略，在该流程中:</p><ul class=""><li id="c8f6" class="ls lt in jx b jy jz kc kd kg nc kk nd ko ne ks mx ma mb mc bi translated">配置值的来源要么是已知的，要么是容易辨别的。</li><li id="bac3" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">配置和构建都是可跟踪和可复制的。</li><li id="77a5" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">目前，这是通过create-react-app完成的。环境文件。</li></ul><p id="d3ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是为您的项目创建一个. env文件(如果它还没有),在其中保存您的设置，并更改对代码设置的引用。目前，我们假设这些是您的发展价值，尽管这将在以后进一步讨论。</p><p id="2d5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，值得一提的是，通过利用。env文件，变量不是环境的全局变量，在执行start命令后不会保留。在我看来，这是一个积极的发展。但是，由于create-react-app还不支持dotenv-expand，这在某些情况下可能是个缺点(更新:从1.1.0开始，确实支持扩展)。</p><p id="2ca3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特定于环境的值存储在. env.local中。</p><p id="a191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">dotenv(react-scripts导入环境变量的机制)还检查名为. env.local的文件是否存在，如果找到，则导入其中声明的变量。当两个文件声明相同的值时，以下优先顺序适用(最高优先):</p><ul class=""><li id="b816" class="ls lt in jx b jy jz kc kd kg nc kk nd ko ne ks mx ma mb mc bi translated">壳</li><li id="15ed" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">env.local</li><li id="e740" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">。包封/包围（动词envelop的简写）</li><li id="e487" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">因此,. env.local中的值会覆盖. env中的值。</li></ul><p id="8bb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您使用中间服务器或子目录来构建每个环境，第2步是生成一个. env.local文件。包含特定于环境的覆盖的env文件。</p><p id="bb59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在中使用通用默认值。对于本地开发，该文件可能为空。在其他情况下(例如，生产)，您通常希望手动指定每个值，因为修改必须更加小心地处理。</p><p id="2fe5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，应在修订控制忽略列表中添加一个条目(例如gitignore ),因为它不应该被签入。如果模块是用. npmignore文件发布的，它也应该包含在该文件中。</p><h1 id="a99e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">特定环境。环境文件</h1><p id="6511" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">. env.local方法非常有效，因为它确保所有环境都使用相同的方法来设置和使用环境配置。然而，它继续依赖于未跟踪的文件，这违背了再现性的目的。</p><p id="b3ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决这个问题的一个方法是创建。每个环境的env文件(例如. env.staging而不是. env.local ),并在源代码控制中跟踪它们。在这种情况下，dotenv不会自动导入文件；但是，可以更新package.json中的构建脚本来实现这一点(更新:从1.0.0开始，对于三个预定义的环境，这一步不再是必需的——文件是自动导入的):</p><p id="6b33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="36c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build": "sh -ac '. .env.build; react-scripts build'",</code></p><p id="85c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="063c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="f566" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令与源命令相同。这表明该文件将在当前上下文中执行。因此，其中包含的环境变量将在运行以下命令之前定义:react-scripts build。这与使用. env.local时的优先级相同。</p><p id="e9fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前面的方法可以概括为适应各种构建环境:</p><p id="adc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="d096" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build": "sh -ac '. .env.${REACT_APP_ENV}; react-scripts build'",</code></p><p id="186e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="33dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="8c95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，任何有权访问相关配置文件的人都可以通过在构建过程中设置REACT APP ENV来针对该环境进行开发:</p><p id="d589" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">$ REACT _ APP _ ENV =暂存npm运行构建</p><p id="9913" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以为每个环境添加其他快捷方式:</p><p id="b2f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="f1d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build": "sh -ac '. .env.${REACT_APP_ENV}; react-scripts build'",</code></p><p id="c9fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build:staging": "REACT_APP_ENV=staging npm run build",</code></p><p id="548f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build:production": "REACT_APP_ENV=production npm run build",</code></p><p id="43df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="93fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="88ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将构建命令缩短为:</p><p id="0ea1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">$ npm run build: staging</code></p><p id="ebe6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为开发依赖项，按如下方式安装它:</p><p id="157d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">$ yarn add-dev react-app-env(或NPM install-save-dev)</p><p id="b9c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并切换启动和构建脚本:</p><p id="8383" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="f930" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"start": "react-app-env start'",</code></p><p id="045b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build": "react-app-env build'",</code></p><p id="66b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"test": "react-app-env test'",</code></p><p id="67a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">…</p><p id="d104" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">}</p><p id="1c59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，至少包括两个环境变量:development.env和production.env。与前面的阶段不同，react-app-env会自动在变量前面加上REACT_APP_。因此，上例中变量的定义将更新为:</p><p id="4942" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">SECRET_CODE=123</code></p><p id="62a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">HOST_ENV=staging</code></p><p id="73e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，在应用程序中，仍然必须使用变量的完整名称，包括REACT_APP_。考虑到这一点，我希望库不要自动前置以避免误解，但我看不出有什么办法可以绕过它。</p><p id="2569" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，npm start和npm test导入development.env，而npm build导入production . env。—env-file选项可用于为其他环境提供支持:</p><p id="a7cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="ae03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build:staging": "react-app-env --env-file=staging.env",</code></p><p id="ea40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="9a93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="86a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">的内容。env仍然可以用作默认值，但是该文件中的变量不会自动加上REACT_APP_。</p><p id="c3b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，该模块假定默认环境文件位于项目的根目录中。要改变这一点(例如，支持单独的配置存储库)并添加其他环境，可以使用类似于上面描述的配置:</p><p id="90a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"scripts": {</code></p><p id="de6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build": "react-app-env --env-file=config/${BUILD_ENV}.env build",</code></p><p id="016c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build:staging": "BUILD_ENV=staging npm run build",</code></p><p id="6fa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">"build:production": "BUILD_ENV=production npm run build",</code></p><p id="ba91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">...</code></p><p id="737a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">}</code></p><p id="78dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种策略与上述策略的主要区别在于REACT_APP_的自动前置，以及改进的跨平台支持。</p><p id="5e15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内置支持Create-react-app 1.0.0包含了对三种预定义环境的自动配置文件读取:开发、测试和生产。</p><p id="8d67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，默认(最低优先级)值可以在. env中定义，NODE_ENV的值由使用的脚本自动确定:</p><ul class=""><li id="8469" class="ls lt in jx b jy jz kc kd kg nc kk nd ko ne ks mx ma mb mc bi translated">开始→发展</li><li id="be09" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">测试→测试</li><li id="18d0" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks mx ma mb mc bi translated">构建→生产</li></ul><p id="38c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.0.0版包含对以下配置文件的内置支持:. env.development、. env.test和. env.production。这些文件中的值优先于. env中的值。每个文件(包括默认文件)都通过包含扩展名. local来启用额外的覆盖层。以下是完整的优先顺序(最高优先):</p><ol class=""><li id="8fbd" class="ls lt in jx b jy jz kc kd kg nc kk nd ko ne ks lz ma mb mc bi translated">壳</li><li id="fe7d" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">. env. {环境}。当地的</li><li id="0700" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">. env. {环境}</li><li id="5b84" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">env.local</li><li id="7496" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">。包封/包围（动词envelop的简写）</li></ol><p id="c6d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在1.1.0中，实现了对dotenv-expand的兼容性，允许在。env文件(有关示例，请参见create-react-app说明):</p><p id="4522" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">DOMAIN=<a class="ae kt" href="http://www.example.com/" rel="noopener ugc nofollow" target="_blank">www.example.com</a></code></p><p id="7869" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">REACT_APP_FOO=$DOMAIN/foo</code></p><p id="d8c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">REACT_APP_BAR=$DOMAIN/bar</code></p><p id="0620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变量扩展支持在本地(在同一个文件中)或shell上开发的模型，但不支持跨文件开发。例如，在中声明的值。不能在. env.development中放大env。</p><h1 id="b54b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">简单地</h1><p id="a7a8" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">从一个有经验的ReactJS开发公司的角度来看，这种方法肯定是卓有成效的。这可以通过使用. env、. env.production和. env.development文件集合来实现。现在，react开发人员可以很容易地知道您何时运行/构建您的应用程序。CRA会将NODE_ENV环境变量设置为开发或生产，并将相应的。将基于这些值使用env文件。</p><p id="044d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想提高React应用程序的性能，这里有一些你必须尝试的技巧。另外，请在评论中与我们分享你的想法，我们希望听到你的反馈。</p></div></div>    
</body>
</html>