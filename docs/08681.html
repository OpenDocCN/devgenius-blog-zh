<html>
<head>
<title>[Rust] Basics and Concepts, Step by Step — 1st Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Rust]基础和概念，循序渐进—第一次迭代</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rust-basics-and-concepts-step-by-step-1st-iteration-f71dc14d5ae6?source=collection_archive---------1-----------------------#2022-07-03">https://blog.devgenius.io/rust-basics-and-concepts-step-by-step-1st-iteration-f71dc14d5ae6?source=collection_archive---------1-----------------------#2022-07-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9a5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一段时间以来，我一直在考虑开始在<code class="fe ki kj kk kl b">Rust</code>中编码，但是由于永无止境的事情，我不能开始。通常我开始学习一门语言时，会先写一些实用程序代码，然后边学边学。然而这一次，时间似乎对我不利。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e30279698b50ac1be5cea662d155f9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCaWHmYuop_4N8epHSCGzw.png"/></div></div></figure><p id="4985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我决定开始一步一步地学习小概念，一次一两件事，然后从那里开始。这个博客是关于我如何接受这个挑战并开始朝着学习的方向前进的</p><h2 id="a8b1" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">默认情况下，变量 a 是不可变的</h2><p id="8e78" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">我花了一段时间才意识到<code class="fe ki kj kk kl b">Rust</code>默认将所有赋值变量视为<strong class="jm io">不可变。</strong>表示绑定完成后，<em class="lw">(另一个</em> <code class="fe ki kj kk kl b"><em class="lw">Rust</em></code> <em class="lw">的概念，仅仅表示值已经赋给了变量)，</em>不能用不同的值重新赋给那个变量</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="1ee3" class="ky kz in kl b gy mb mc l md me">fn main() {<br/><strong class="kl io">    // Variables by default are immutable use `mut` key word to make<br/>    // mutable</strong><br/>    concept1()<br/>}<br/><br/>fn concept1() {<br/>    let x: i8 = 15;<br/>    println!("Value of X = {}", x);<br/>    x = 20;<br/>    println!("After Reassignment, value of X = {}", x);<br/>}</span></pre><p id="d171" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不管用</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="dee0" class="ky kz in kl b gy mb mc l md me">error[E0384]: cannot assign twice to immutable variable `x`<br/>  --&gt; src/main.rs:17:5<br/>   |<br/>15 |     let x: i8 = 15;<br/>   |         -<br/>   |         |<br/>   |         first assignment to `x`<br/>   |         help: consider making this binding mutable: `mut x`<br/>16 |     println!("Value of X = {}", x);<br/>17 |     x = 20;<br/>   |     <strong class="kl io">^^^^^^ cannot assign twice to immutable variable</strong></span><span id="924c" class="ky kz in kl b gy mf mc l md me">For more information about this error, try `rustc --explain E0384`.<br/>error: could not compile `day1` due to previous error</span></pre><p id="2a5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，问题来了，我们如何运行计数器？简单的答案是让变量<strong class="jm io">可变</strong></p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="ee2d" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    concept1() // Variables by default are immutable, use `mut`<br/>}<br/><br/>fn concept1() {<br/>    let <strong class="kl io">mut</strong> x: i8 = 15;<br/>    println!("Value of X = {}", x);<br/>    x = 20;<br/>    println!("After Reassignment, value of X = {}", x);<br/>}</span></pre><p id="14e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它运行良好</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="3db6" class="ky kz in kl b gy mb mc l md me">Value of X = 15<br/>After Reassignment, value of X = 20</span></pre><p id="4541" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么<code class="fe ki kj kk kl b">Rust</code>要这么做，尽管<strong class="jm io">跟踪</strong>是可能的。事实上<strong class="jm io">隐藏</strong>也允许我们改变变量的类型。简单地说，通过使用<code class="fe ki kj kk kl b">let</code>关键字，我们创建了另一个同名的变量。</p><h2 id="a28c" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">隐藏变量</h2><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="c82b" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    variables_are_immutable();<br/>    variable_shadowing()<br/>}<br/><br/>fn variables_are_immutable() { .... }<br/><br/>fn variable_shadowing() {<br/>    let x: i8 = 15;<br/>    println!("Value of X = {}", x);<br/>    <strong class="kl io">let</strong> x = x + 20; <strong class="kl io">// This is possible because of `let` keyword</strong><br/>    println!("After Reassignment, value of X = {}", x);<br/>}</span></pre><p id="90d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们得到了</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="a51e" class="ky kz in kl b gy mb mc l md me">Value of X = 15<br/>After Reassignment, value of X = 35</span></pre><p id="740c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看下图中的阴影和代码</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mg"><img src="../Images/4127cb0721939c297169adaa74de2143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h9v0MQAUHtCgneSBKJDVA.jpeg"/></div></div></figure><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="e904" class="ky kz in kl b gy mb mc l md me">value of shadowed_variable is 10 <strong class="kl io">-&gt; 1st Value</strong><br/>value of shadowed_variable is ten <strong class="kl io">-&gt; 2nd Value</strong><br/>value of shadowed_variable is 10 <strong class="kl io">-&gt; First Value in different scope</strong><br/>value of shadowed_variable is scope check <strong class="kl io">-&gt; 2nd Value different scope</strong><br/>value of shadowed_variable is 20 <strong class="kl io">-&gt; 3rd Value</strong><br/>First value of shadowed_variable is 10 <strong class="kl io">-&gt; 1st Value accessed using reference variable first_value</strong></span></pre><p id="9081" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，隐藏在内部像一个<strong class="jm io">堆栈</strong>一样工作，你可以通过使用<code class="fe ki kj kk kl b">drop(shadowed_variable)</code>删除先前的值，它将像<strong class="jm io">堆栈</strong>一样工作，并开始以 lifo 方式弹出值。还要记住，只有当<strong class="jm io">变量在</strong>范围内时，<strong class="jm io">隐藏</strong>变量才起作用。</p><p id="bf2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样<code class="fe ki kj kk kl b">const</code>用于定义<strong class="jm io">常量</strong>，该常量对程序的整个运行有效。常量的值不能是需要在运行时计算的东西</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="cd07" class="ky kz in kl b gy mb mc l md me"><strong class="kl io">const <em class="lw">DAY_IN_YEAR</em>: i32 = 31 * 7 + 30 * 4 + 28;</strong><br/><br/>fn main() {<br/>    print_constant();<br/>}<br/><br/>fn variables_are_immutable() {...}<br/><br/>fn variable_shadowing() -&gt; i32 {<br/>    let x: i32 = 15;<br/>    println!("Value of X = {}", x);<br/>    let x = x + 20;<br/>    println!("After Reassignment, value of X = {}", x);<br/>    return x<br/>}<br/><br/>fn print_constant() {<br/>    <strong class="kl io">println!("Value of constant {}", <em class="lw">DAY_IN_YEAR</em>);</strong><br/>}</span></pre><h2 id="0a16" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">可变类型转换又名铸造</h2><p id="6bd1" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Rust</code>允许对可变类型转换又名<strong class="jm io"><em class="lw"/></strong>进行动态铸造。喜欢</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="eaaa" class="ky kz in kl b gy mb mc l md me">fn calculate_avg_using_casting() {<br/>   <strong class="kl io"> let (a, b, c): (i32, f32, f32) = (13, 2.3, 120.0);</strong><br/>    let avg = (<strong class="kl io">a as f32</strong> + b + c) / 3.0; // <strong class="kl io">a is re-casted as f32</strong><br/><br/>    assert_eq!(avg, 45.100002);<br/>    println!("Test Passed");<br/>}</span></pre><p id="2aee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将打印<code class="fe ki kj kk kl b">Test Passed</code>。正如你所看到的，变量<code class="fe ki kj kk kl b">a</code>已经使用<code class="fe ki kj kk kl b">as</code>关键字从<code class="fe ki kj kk kl b">i32</code>转换为<code class="fe ki kj kk kl b">f32</code>。注意，<strong class="jm io">转换</strong>应该小心使用，因为它可能会产生不可预知的结果，比如如果<code class="fe ki kj kk kl b">f32</code>被重新转换为<code class="fe ki kj kk kl b">i32</code>，那么小数点后的所有内容都将被截断。<strong class="jm io">铸造</strong>使用<code class="fe ki kj kk kl b">truncation</code>然后<code class="fe ki kj kk kl b">round</code>将类型转换。</p><h2 id="fc51" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">函数的魔力</h2><p id="4737" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">像大多数语言一样，<code class="fe ki kj kk kl b">Rust</code>也需要至少一个可论证的函数<code class="fe ki kj kk kl b">main()</code>，在<code class="fe ki kj kk kl b">Rust</code>中，我们用<code class="fe ki kj kk kl b">fn</code>关键字定义函数。除此之外<strong class="jm io"> <em class="lw">功能</em> </strong> <em class="lw"> </em>中的<code class="fe ki kj kk kl b">Rust</code>就相当直截了当了。</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="fc79" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    println!("{}", variable_shadowing_and_return());<br/>}</span><span id="b554" class="ky kz in kl b gy mf mc l md me">fn variable_shadowing_and_return() -&gt; i32 {<br/>    let x: i32 = 15;<br/>    println!("Value of X = {}", x);<br/>    let x = x + 20;<br/>    x * x <strong class="kl io">// missing `;` is intentional as it is an expression </strong><br/>}</span></pre><h2 id="26d7" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">语句与表达式</h2><p id="c652" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">以上是返回类型为<code class="fe ki kj kk kl b">i32</code>的<code class="fe ki kj kk kl b">Rust</code>中的函数示例。功能是<strong class="jm io"> <em class="lw">表达式</em> </strong>和<strong class="jm io"> <em class="lw">语句的组合。</em> </strong> <em class="lw"> </em> <strong class="jm io"> <em class="lw">表达式</em> </strong>总是生成一个值，而<strong class="jm io"> <em class="lw">语句</em> </strong>只是一个动作。因此，在<code class="fe ki kj kk kl b">Rust</code>中，像这样的东西是无效的<code class="fe ki kj kk kl b">a = b = 1</code>，因为我们不能将一个<strong class="jm io">语句</strong>赋给变量，因为<code class="fe ki kj kk kl b">b = 1</code>是一个动作而不是一个值。给<strong class="jm io"> <em class="lw">表达式</em> </strong>添加一个<code class="fe ki kj kk kl b">;</code>会将其转换为<strong class="jm io"> <em class="lw">语句</em> </strong></p><blockquote class="mh mi mj"><p id="e7cb" class="jk jl lw jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated"><em class="in">在</em> <code class="fe ki kj kk kl b"><em class="in">Rust</em></code> <em class="in">中如果最后一行是一个</em> <strong class="jm io"> <em class="in">表达式</em> </strong> <em class="in">那么它将作为函数的</em> <strong class="jm io">返回值被传递出去。</strong></p></blockquote><p id="e3ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">功能<code class="fe ki kj kk kl b">main()</code>可以从<a class="ae mn" href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10" rel="noopener ugc nofollow" target="_blank">锈 1.26 </a>开始返回一个<code class="fe ki kj kk kl b">Result</code>类型(<a class="ae mn" href="https://github.com/rust-lang/rust/pull/49162" rel="noopener ugc nofollow" target="_blank">详情</a>)。例如</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="a947" class="ky kz in kl b gy mb mc l md me">use std::num::ParseIntError;</span><span id="4dc8" class="ky kz in kl b gy mf mc l md me">fn main() -&gt; Result&lt;(), ParseIntError&gt; {<br/>    let some_number = "10";<br/>    let n = match some_number.parse::&lt;i32&gt;() {<br/>        Ok(n)  =&gt; n,<br/>        Err(e) =&gt; return Err(e),<br/>    };<br/>    println!("{}", n);<br/>    Ok(())<br/>}</span></pre><p id="c176" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果你的函数没有返回任何值，那么它会返回一个叫做<strong class="jm io"> <em class="lw">的单元数据类型</em> </strong> <code class="fe ki kj kk kl b">()</code>。<code class="fe ki kj kk kl b">Rust</code>如果函数不返回，编译器自动推断单元数据类型。我们可以明确地提到太像了</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="b265" class="ky kz in kl b gy mb mc l md me">fn some_func(x: i8) <strong class="kl io">-&gt; ()</strong> {<br/>  println!("Square of X is {}", x * x)<br/>}</span></pre><h2 id="8297" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">字符串文字或类型…嗯！！</h2><p id="8452" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">看看下面的差异视图，我会试着解释我想要展示的东西</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mo"><img src="../Images/1ea894ed28e26f85712114867077c0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmd8dF2JqTLubtmSu_nkzw.png"/></div></div></figure><p id="ad16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">Rust</code>中，有两种方式使用<strong class="jm io">字符串文字</strong>或<strong class="jm io">字符串类型来处理<strong class="jm io">字符串</strong>。</strong>当说<code class="fe ki kj kk kl b">let some_string = "actually it is random string"</code>时，这被称为<strong class="jm io">字符串文字</strong>，因为它是字面上写在可执行文件中的。如上所述，它们是不可变的，并且在编译之前需要知道尺寸。所以它不能保存任何本质上动态的值。</p><blockquote class="mh mi mj"><p id="29ed" class="jk jl lw jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">一个<code class="fe ki kj kk kl b">String</code>被存储为一个字节向量(<code class="fe ki kj kk kl b">Vec&lt;u8&gt;</code>)，<strong class="jm io">，但是保证总是一个有效的 UTF-8 序列</strong>。是堆分配的、可增长的并且不是空终止的。<code class="fe ki kj kk kl b">&amp;str</code>是一个切片(<code class="fe ki kj kk kl b">&amp;[u8]</code>)，它总是指向一个有效的 UTF-8 序列，并且可以用于查看到一个<code class="fe ki kj kk kl b">String</code>，就像<code class="fe ki kj kk kl b">&amp;[T]</code>是一个到<code class="fe ki kj kk kl b">Vec&lt;T&gt;</code>的视图一样。</p></blockquote><p id="358c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了处理<strong class="jm io">字符串</strong>的动态性质，我们使用<strong class="jm io">字符串类型、</strong>，它们存储在<strong class="jm io">堆</strong>和<strong class="jm io">可变堆中。</strong></p><p id="30ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码将创建一个名为<code class="fe ki kj kk kl b">my_string</code>的变量，它是存储在<strong class="jm io">堆栈</strong>中的<code class="fe ki kj kk kl b"><strong class="jm io">&amp;str</strong></code>类型，而<strong class="jm io"> </strong>将把值存储在<strong class="jm io">堆中。</strong>在<strong class="jm io">栈</strong>中，它将保持<strong class="jm io">指针</strong>指向<strong class="jm io">堆</strong>位置<strong class="jm io">，管柱长度</strong><strong class="jm io">和<strong class="jm io">容量。</strong>星号<strong class="jm io">表示容量始终大于等于<strong class="jm io">管柱的长度。</strong></strong></strong></p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="73c1" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    work_with_strings();<br/>}<br/><br/>fn work_with_strings() {<br/>    let mut my_string = String::<em class="lw">from</em>("APPLE");<br/>    println!("Original my string: {}", my_string);<br/>}</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/ad1cb69a474e931636566bd51a30b732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0x2WMH6qJTenUTviNXn2g.jpeg"/></div></div></figure><p id="9d37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相同的代码，但在现有字符串中添加了更多内容</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="2fa7" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    work_with_strings();<br/>}<br/><br/>fn work_with_strings() {<br/>    let mut my_string = String::<em class="lw">from</em>("APPLE");<br/>    println!("Original my string: {}", my_string);<br/>    my_string.push_str(" is GOOD");<br/>    println!("Final my string: {}", my_string);<br/>}</span></pre><p id="a265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变成了这样</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/b4dd164dab5ce13f4a1fa02bec038974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_eznCBCn0jcfMaDHrv6ICQ.jpeg"/></div></div></figure><p id="cba8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用<strong class="jm io">索引引用字符串中的字符，b </strong>因为字符串是有效的 UTF-8，它们不支持索引。我们需要使用<code class="fe ki kj kk kl b">.chars()</code> <strong class="jm io"> </strong>的方法。<strong class="jm io"> </strong>在这里阅读更多关于弦乐<a class="ae mn" href="https://doc.rust-lang.org/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">的内容</a></p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="15ed" class="ky kz in kl b gy mb mc l md me">fn main() {<br/>    // shadow_variables();<br/>    work_with_strings();<br/>}<br/><br/>fn work_with_strings() {<br/>    let mut my_string = String::<em class="lw">from</em>("APPLE");<br/>    println!("Original my string: {}", my_string);<br/>    my_string.push_str(" is GOOD");<br/>    println!("Final my string: {}", my_string);<br/>    println!("The characters are \n");<br/>    for ch in my_string.chars() {<br/>        print!("{},", ch)<br/>    }<br/>}</span></pre><h2 id="3d66" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><strong class="ak">多圈圈</strong></h2><p id="09b3" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">像其他语言一样,<code class="fe ki kj kk kl b">Rust</code>也有一些机制，我们可以用它们来迭代一些东西。<a class="ae mn" href="https://doc.rust-lang.org/reference/expressions/loop-expr.html" rel="noopener ugc nofollow" target="_blank">循环</a>、<a class="ae mn" href="https://doc.rust-lang.org/rust-by-example/flow_control/while.html" rel="noopener ugc nofollow" target="_blank">而</a>和<a class="ae mn" href="https://doc.rust-lang.org/std/keyword.for.html" rel="noopener ugc nofollow" target="_blank">为</a>，顾名思义它们或多或少与其他语言相似，除了<a class="ae mn" href="https://doc.rust-lang.org/reference/expressions/loop-expr.html" rel="noopener ugc nofollow" target="_blank">循环</a>。</p><p id="7c97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae mn" href="https://doc.rust-lang.org/reference/expressions/loop-expr.html" rel="noopener ugc nofollow" target="_blank">循环</a>与<a class="ae mn" href="https://doc.rust-lang.org/rust-by-example/flow_control/while.html" rel="noopener ugc nofollow" target="_blank">和</a>非常相似，有两个主要区别。它没有像中的<a class="ae mn" href="https://doc.rust-lang.org/rust-by-example/flow_control/while.html" rel="noopener ugc nofollow" target="_blank">那样的条件，它可以返回</a><a class="ae mn" href="https://doc.rust-lang.org/rust-by-example/flow_control/while.html" rel="noopener ugc nofollow" target="_blank">中不能返回的值。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/5581dce461abc6a499e9095584c63bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0L05lzzwLPPdblNP1KghA.jpeg"/></div></div></figure><p id="584f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，一旦<strong class="jm io"> break </strong>语句执行，<a class="ae mn" href="https://doc.rust-lang.org/reference/expressions/loop-expr.html" rel="noopener ugc nofollow" target="_blank">循环</a>实际上将<strong class="jm io">计数</strong>返回到<strong class="jm io">结果</strong>变量，然而<strong class="jm io">同时</strong>刚刚执行并在条件匹配时中断循环。</p><blockquote class="mh mi mj"><p id="03ca" class="jk jl lw jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">还要注意，因为<strong class="jm io"> <em class="in">循环</em> </strong>被赋值给变量<strong class="jm io">结果</strong>，所以我们把<code class="fe ki kj kk kl b">;</code>放在它的末尾，使它成为<strong class="jm io"> <em class="in">语句</em> </strong>。</p></blockquote><p id="19aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有嵌套循环，并且想要<code class="fe ki kj kk kl b">break</code>到外部循环。然后，我们可以使用<strong class="jm io">循环标签</strong>来指定<code class="fe ki kj kk kl b">break</code>或<code class="fe ki kj kk kl b">continue</code>应用于哪个循环。在下面的例子中，<code class="fe ki kj kk kl b">'outer</code>是给外部循环的标签。</p><pre class="kn ko kp kq gt lx kl ly lz aw ma bi"><span id="f41a" class="ky kz in kl b gy mb mc l md me">'outer: for x in 0..5 {<br/>    for y in 0..5 {<br/>        if y &gt; 2{<br/>            break 'outer<br/>        }<br/>        println!("x: {}, y: {}", x, y);<br/>    }<br/>}</span></pre><p id="e16d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想我现在已经有足够的内容可以开始了。希望这有助于理解<code class="fe ki kj kk kl b">Rust</code>的基础知识。我仍在学习，并将继续把我的想法写在未来的文章中！！</p><h1 id="e6fb" class="ms kz in bd la mt mu mv ld mw mx my lg mz na nb lj nc nd ne lm nf ng nh lp ni bi translated">编程快乐！！</h1></div></div>    
</body>
</html>