# 你不知道如何调优 JVM

> 原文：<https://blog.devgenius.io/you-dont-know-how-to-tune-jvm-75cb99b5649?source=collection_archive---------2----------------------->

## 软件工程之旅

## 为了学习如何调优 JVM 以获得更好的性能，软件工程师必须了解这些调优技术。

![](img/fb8b8b3a3ce5287ae0dc32e574617492.png)

图片来自 hcltech.com

# 概观

JVM 调优和 Java 性能优化是应用程序生命周期中的重要活动。它们最大限度地提高应用程序性能，并增加本地硬件或云计算资源的吞吐量

Java 虚拟机调优是调整默认参数以匹配我们的应用程序需求的过程。这包括简单的调整，如堆的大小，通过选择正确的垃圾收集器来使用优化版本的 getters。

# JVM 调优前需要了解的因素

在深入 JVM 调优过程之前，让我们先熟悉一些与 JVM 调优相关的关键概念。

# JVM 主要参数

JVM 参数或 JVM 自变量是改变 Java 虚拟机行为的特定于 Java 的值。

谈到 JVM 调优，有几个重要参数您应该知道，因为在配置、调优和提高 JVM 的整体性能时，您会遇到这些参数。

# 堆内存

无论您做什么，当谈到 JVM 性能时，您很可能会达到必须初始化堆内存的程度。

当设置 JVM 内存的最小和最大堆大小时，您可能想考虑将它们设置为相同的值。这样，您的堆就不必调整大小，节省了宝贵的 CPU 周期。

# 碎片帐集

垃圾收集是 JVM 释放 Java 堆中未使用的 Java 对象的过程。Java 堆是 Java 程序的对象所在的地方。它是活对象、死对象和空闲内存的存储库。当一个对象不再能从正在运行的程序中的任何指针到达时，它被认为是“垃圾”并准备好被收集。

JVM 有四种垃圾收集器实现:

*   串行垃圾收集器
*   并行垃圾收集器
*   CMS 垃圾收集器
*   G1 垃圾收集器

前两个垃圾收集器专用于年轻一代堆空间，而 CMS 和 G1 垃圾收集器专用于老一代堆空间。

# GC 日志记录

垃圾收集性能与 JVM 和 app 性能密切相关。当垃圾收集器无法清除内存时，它会越来越多地工作，最终导致全局事件，甚至出现内存不足的情况。我们希望尽可能避免这种情况。为了做到这一点，我们需要能够观察 JVM 垃圾收集器正在做什么。监控 GC 性能的最好方法之一是查看 GC 日志。

您可以使用以下命令记录 GC 活动:

```
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=<number of log files>
-XX:GCLogFileSize=<file size>[unit]
-Xloggc:/path/to/gc.log
```

# 如何进行 JVM 性能调优

一旦您了解了上述所有内容，下面是执行 JVM 调优需要采取的步骤:

## 测量内存占用

要确定内存使用情况，首先需要知道活动数据的大小。活动数据的大小是自应用程序进入稳定阶段以来被活动数据占用的 Java 堆的数量。

## 应用阶段:稳定与启动

活动数据必须在稳定状态下测量，而不是在启动阶段。在启动阶段，JVM 加载并启动 app 的主要模块和数据；因此，JVM 参数还不稳定。

另一方面，稳定阶段意味着一个应用程序已经运行了一段时间，并进行了压力测试。更具体地说，当应用程序在生产环境中达到满足业务峰值要求的工作负载，并在达到峰值后保持稳定时，它就处于稳定阶段。只有这样，每个 JVM 性能参数才处于稳定状态。

## 如何确定内存占用

请确保使用默认的 JVM 参数执行测试，因为它允许您查看应用程序在稳定阶段需要多少内存。完整的 GC

一旦应用程序在稳定状态下运行，您必须根据平均旧的和永久的占用率来估计内存占用，您可以在稳定状态期间看到完整的 GC 日志。您还可以使用最长的完整 GC 进行估计。

GC 日志是收集有意义的丰富数据来帮助调优的最佳方式之一。启用 GC 日志不会影响性能。因此，您甚至可以在生产环境中使用它们来检测问题。

使用以下命令行打开完整的 GC 日志:

```
-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:<filename>
```

但是，如果没有完整的 GC 日志可用，您可以使用监视工具来调用它们，或者使用以下命令来启用它们:

```
jmap -histo:live pid
```

无论哪种方式，您都会获得类似于以下内容的信息:

```
0.134: [GC (Allocation Failure) [PSYoungGen: 65536K->10720K(76288K)] 65536K->40488K(251392K), 0.0190287 secs] [Times: user=0.13 sys=0.04, real=0.02 secs]
0.193: [GC (Allocation Failure) [PSYoungGen: 71912K->10752K(141824K)] 101680K->101012K(316928K), 0.0357512 secs] [Times: user=0.27 sys=0.06, real=0.04 secs]
0.374: [GC (Allocation Failure) [PSYoungGen: 141824K->10752K(141824K)] 232084K->224396K(359424K), 0.0809666 secs] [Times: user=0.58 sys=0.12, real=0.08 secs]
0.455: [Full GC (Ergonomics) [PSYoungGen: 10752K->0K(141824K)] [ParOldGen: 213644K->215361K(459264K)] 224396K->215361K(601088K), [Metaspace: 2649 K->2649K(1056768K)], 0.4409247 secs] [Times: user=3.46 sys=0.02, real=0.44 secs]
0.984: [GC (Allocation Failure) [PSYoungGen: 131072K->10752K(190464K)] 346433K->321225K(649728K), 0.1407158 secs] [Times: user=1.28 sys=0.08, real=0.14 secs]
1.168: [GC (System.gc()) [PSYoungGen: 60423K->10752K(190464K)] 370896K->368961K(649728K), 0.0676498 secs] [Times: user=0.53 sys=0.05, real=0.06 secs]
1.235: [Full GC (System.gc()) [PSYoungGen: 10752K->0K(190464K)] [ParOldGen: 358209K->368152K(459264K)] 368961K->368152K(649728K), [Metaspace: 2652K->2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]
2.612: [Full GC (Ergonomics) [PSYoungGen: 179712K->0K(190464K)] [ParOldGen: 368152K->166769K(477184K)] 547864K->166769K(667648K), [Metaspace: 2659K->2659K(1056768K)], 0.2662589 secs] [Times: user=2.14 sys=0.00, real=0.27 secs]
```

我们可以看到 JVM 版本 8 执行的几个操作。让我们看一下这里的一行，它描述了通过使用 System.gc()方法从我们的测试代码中有意执行的完整 GC 事件:

```
1.235: [Full GC (System.gc()) [PSYoungGen: 10752K->0K(190464K)] [ParOldGen: 358209K->368152K(459264K)] 368961K->368152K(649728K), [Metaspace: 2652K->2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]
```

如您所见，在描述完整 GC 事件的一行中包含了大量信息。除了事件类型之外，我们还可以看到年轻代空间中发生了什么[PSYoungGen:10752k-> 0K(190464k)]，老代空间中发生了什么，[ParOldGen:358209k-> 368152k(459264k)]，内存的元空间区域中发生了什么[元空间:2652K->2652K(1056768K)]，总内存差 368961K->36815

关于年轻代垃圾收集器工作的信息告诉我们，在年轻代垃圾收集事件之后，空间从 10752K 下降到 0K，总分配的年轻代空间是 190464K。

老一代垃圾收集器开始时使用 358209K 的内存，工作结束后使用 368152K。分配给老一代空间的总内存是 459264K。这意味着这个 GC 周期没有释放太多的老一代空间。

在整个垃圾收集完成后，我们从最初的 368961K 内存开始使用 368152K 内存，整个内存空间占用了 649728K。

内存的元空间区域以相同的内存使用量 2652K 开始和结束，整个区域占用 1056768K。

最后，JVM 用了 1.18 秒来执行整个垃圾收集操作。user=10.64 部分告诉我们在操作系统内核之外的用户模式代码中花费的 CPU 时间。sys=0.05 部分是 CPU 在进程本身的内核中花费的时间，这意味着 CPU 执行系统相关调用所花费的时间。

正如您所看到的，单个垃圾收集器日志行可以让我们深入了解发生了什么，释放了多少内存，以及整个操作花费了多长时间。

## 延迟调整

一旦确定了内存占用，下一步就是延迟调整。在这个阶段，堆内存大小和延迟不能满足应用程序的要求。因此，需要根据 app 的实际需求进行新的调试。您可能需要再次调整堆大小，确定 GC 持续时间和频率，并决定是否需要切换到另一个垃圾收集器。

## 确定系统延迟要求

之前，我们提到过绩效目标，但是我们没有为它们设定值。这些目标是您在调优后需要满足的系统延迟要求。有助于实现这一目标的指标有:

*   可接受的平均次要 GC 频率，您将把它与次要 GC 的数量进行比较。
*   可接受的最大完整 GC 暂停，您可以将它与最长的完整 GC 周期进行比较。
*   可接受的最大完全 GC 暂停频率，您将把它与完全 GC 的最高频率进行比较。
*   可接受的平均次要 GC 暂停时间，您可以将它与次要 GC 持续时间进行比较。

您可以通过分别优化年轻一代和老一代的规模来获得这些数据。您可以在我们的垃圾收集调优指南中了解更多信息。

## 吞吐量调整

在 JVM 性能调优的最后一步，我们对目前得到的结果进行吞吐量测试，然后根据需要进行细微的调整。

基于测试和整体应用需求，一个应用应该有一个设定的吞吐量指标。当达到或超过这个目标时，您可以停止优化。

但是，如果在优化之后，您仍然不能达到吞吐量目标，那么您需要重新评估吞吐量需求和当前吞吐量之间的差距。如果差距在 20%左右，您可以更改参数、增加内存并再次调试应用程序。但是如果差距大于 20%，就需要把吞吐量目标作为吞吐量目标来审核，设计可能不符合整个 Java 应用的要求。

对于垃圾收集，吞吐量调优有两个目的:最小化传递到旧区域的对象数量，减少整个 GC 执行时间或停止世界事件。这些会导致低吞吐量。

# 增强 Java Web 应用程序性能的配置

*   转移到最新稳定的 Java 版本。
*   正确确定 Java 堆内存的大小。
*   设置初始 Java 堆大小。
*   选择正确的垃圾收集算法。
*   调整垃圾收集器。
*   确保 Web 容器的线程池大小正确。

# 该调音了！

JVM 性能调优是一个复杂的过程，需要系统的方法和对期望的性能结果的清晰想法，正如您在本 JVM 调优指南中注意到的。默认的 JVM 调优在提高应用程序性能方面做得很好，并确保它在大多数情况下都是稳定的。另一方面，根据您的应用程序如何处理所需的工作负载，基本的初始 JVM 参数可能不够。在这种情况下，您必须对您的应用程序进行基准测试，并调整 JVM 以达到一组合适的参数。

# 结论

通过这篇文章，我认为您可以了解如何调优 JVM 以获得更好的性能。最后，我想感谢你阅读我的文章。