# 让我们的生活更轻松的软件设计

> 原文：<https://blog.devgenius.io/aspects-of-a-software-design-to-make-our-lives-easier-8c081bb3f4ab?source=collection_archive---------34----------------------->

![](img/0f84a2342e4831203a37baedaa050ea5.png)

诺德伍德主题公司在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

设计软件需要考虑很多因素。我们必须处理大量的用例、风险和许多其他可能出现的问题。

在本文中，我们将看看软件系统的各个部分。

# 继承-当继承简化设计时

当继承简化了设计，那么我们就可以创建一个类继承层次。

继承层次结构应该简单，这样我们就不必在混乱的继承树中导航。

我们可以将多个类共享的代码放在一个父类中，而不共享的代码可以放在子类中。

它遵循抽象原则，因此我们不必复制代码。

# 信息隐蔽

我们要隐藏其他部分不需要的信息。

此外，我们可能有我们也想隐藏的秘密。

如果存在错误，隔离数据可以防止错误传播。

# 秘密的种类

秘密可能包括隐藏复杂性，以便我们的大脑不必处理它们，除非我们需要或定位一个组件内的变化。

# 信息隐藏的障碍

为了隐藏数据，我们必须阻止信息的过度传播。

例如，如果我们有全局数据，我们应该将它们放在本地，这样就可以防止访问。

循环依赖还会不必要地暴露信息。它们很难测试，因为它们相互依赖，所以一个方面的变化会传播到另一个方面。

# 类数据被误认为是全局数据

全球数据并不好，因为它们随处可得。如果他们应该代替类数据时，我们应该让他们这样做。

我们可以限制对类数据而不是全局数据的访问。

# 感知绩效惩罚

如果隐藏数据会导致性能下降，那么我们就不能隐藏它们。

直接访问数据比间接访问数据更快，所以如果它使我们的系统太慢，我们可能无法隐藏数据。

# 信息隐藏的价值

通过减少耦合和不暴露外界不应该知道的数据，隐藏信息使我们的生活更容易。

因此，这是一个重要的启发。我们应该考虑隐藏什么而不是展示什么。

# 确定可能发生变化的领域

应该确定可能改变的区域，以便我们可以采取措施使它们更容易改变。

如果它们可能会改变，那么我们就要概述我们应该如何改变它们。

为了使改变它们更容易，我们应该将可能改变的区域分开，这样我们可以单独处理它们，而不会影响其他部分。

然后当我们实现它们时，我们必须隔离它们，这样无论我们做了什么改变，它们都保留在类中。

# 商业规则

业务规则很可能会改变，所以我们应该通过隔离它们和隐藏信息来减少耦合，从而确保它们可以很容易地更新。

# 硬件依赖性

硬件依赖关系也应该被隔离，以便任何与硬件相关的东西都在它们自己的位置上。

# 输入和输出

任何需要输入和输出的东西都应该分开，因为它们也是不稳定的。

业务需求改变了，这要求我们改变输入和输出的字段。

输出格式也可能会改变，所以我们必须确保通过将它们分开，使我们未来的生活更加轻松。

# 不标准的语言特征

任何非标准的扩展都必须改变。如果我们有它们，那么我们应该隐藏它们的实现，这样我们就不会直接使用它们。

# 困难的设计和施工领域

任何有问题的地方都应该隐藏起来，这样如果他们做得不好，就不会影响我们系统的其他部分。

把它们放在一个单独的区域来隔离它们的设计。

![](img/db8c756b12722e0ce49e052e18dcbe21.png)

照片由[戴维斯科](https://unsplash.com/@codytdavis?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

# 状态变量

状态变量比其他变量变化更多，所以这是我们想要隔离它们的地方，以便它们可以更容易地被改变。

枚举是状态变量的最佳选择，因为状态变量的可能性是有限的。

访问例程比直接检查变量要好，因为它们允许更复杂的状态检测。

我们可以在其他地方的例程中编写代码。

# 数据大小约束

这些是应该保密的常量，我们可以在需要验证数据时使用它们。

所以我们应该把它们放在一边，只在必要的时候引用它们。

# 结论

让我们的生活变得更容易就是与世隔绝。我们必须确保这样做是为了减少耦合。

像业务规则、问题代码和常量这样的东西应该被隔离。