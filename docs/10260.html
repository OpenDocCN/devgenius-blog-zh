<html>
<head>
<title>Typescript RxJs takeUntil, takeWhile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript RxJs takeUntil，takeWhile</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-rxjs-takeuntil-takewhile-34e7939e4fba?source=collection_archive---------4-----------------------#2022-10-19">https://blog.devgenius.io/typescript-rxjs-takeuntil-takewhile-34e7939e4fba?source=collection_archive---------4-----------------------#2022-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fb86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何及时停止数据发射？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76ec196e0f5b5829cda54cd7983d9704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iba64QDM7hyrdIPX3fFE8g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">反应式函数编程的魔力。</figcaption></figure><p id="48dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于 3“O”原则的反应式方法。</p><p id="cfd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可观察的—操作者—观察者</p><ol class=""><li id="85fc" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">可观察的—一些输入数组、数据流、异步集合…</li><li id="4bac" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">操作员—允许对发出的数据进行操作。</li><li id="91c2" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">观察者—消耗排放数据。在操作员的帮助下，当可观察的物体将被结束时，你将被通知。</li></ol><p id="c286" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可观察的对象只有当你订阅它们时才会起作用。</p><p id="a4bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个可观察的管道。经常需要停止执行流并通知另一个服务。RxJs 提供了 2 个以上的操作员来处理这种情况。</p><ol class=""><li id="c575" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">当一些外部事件表明是时候退订时，使用<strong class="jm io"> takeUntil </strong>。</li><li id="02d5" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">当输入值达到退订条件时，使用<strong class="jm io"> takeWhile </strong>。</li></ol><p id="3b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理可观察对象的过程中，有一个很好的做法来区分这些变量，例如使用<strong class="jm io"> $ </strong>符号。所以我指的是结果美元。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="25e6" class="lr ls in ln b gy lt lu l lv lw">export class MyComponent implements OnInit, OnDestroy {</span><span id="5337" class="lr ls in ln b gy lx lu l lv lw">private resultValue: number;<br/>private readonly destroy$: Subject&lt;void&gt; = new Subject();</span><span id="7b07" class="lr ls in ln b gy lx lu l lv lw">constructor(private readonly calcService: CalculationService) {<br/>}</span><span id="eb57" class="lr ls in ln b gy lx lu l lv lw">private checkPriceState(): void {<br/>  this.calcService.getLatestData()<br/>    .pipe(takeUntil(this.destroy$),<br/>      .tap(data =&gt; console.log(data) ))<br/>    .subscribe((value: number) =&gt; {<br/>      this.resultValue = value;<br/>    });<br/>}</span><span id="7397" class="lr ls in ln b gy lx lu l lv lw">ngOnDestroy(): void {<br/>  this.destroy$.next();<br/>  this.destroy$.complete();<br/>}</span></pre><p id="c783" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">angular life cycle method<strong class="jm io">NgOnDestroy</strong>允许我们控制何时在组件期间删除订阅。</p><p id="69c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> TakeUntil </strong>操作者帮助我们在<strong class="jm io"> destroy$ </strong>主体发出时停止发出可观察值。它可以防止内存泄漏。</p><p id="85aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，<strong class="jm io"> destroy$ </strong> subject 是私有的，所以它在我们的类之外是不可用的。我们不允许任何人将数据放入其中！</p><p id="0c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">他们之间的主要区别是基于这样一个事实，即<strong class="jm io">直到</strong>接受可观察的值。</p><p id="1c1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> TakeWhile </strong>只要满足某个条件 stateUpdated 谓词就会发出值。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="4e24" class="lr ls in ln b gy lt lu l lv lw">private changeState = false; // used for outer component<br/>private charges: ChargesObject[] = [];<br/>isSaving$: Observable&lt;boolean&gt;;</span><span id="7ad9" class="lr ls in ln b gy lx lu l lv lw">constructor(private readonly store: Store&lt;State&gt;) {<br/>  this.isSaving$ = this.store.pipe(select(s<strong class="ln io"><em class="ly">electors</em></strong>.isSaving));<br/>}</span><span id="60b9" class="lr ls in ln b gy lx lu l lv lw">updateWithGlobalState(): void {<br/>  let stateUpdated = true;<br/>  this.isSaving$.pipe(<br/>    takeWhile(() =&gt; stateUpdated)).subscribe(hasSaving =&gt; {<br/>    if (!hasSaving) {<br/>      const state = this.store.select(s<strong class="ln io"><em class="ly">electors</em></strong>.getState);<br/>      state.pipe(take(1)).subscribe(result =&gt; {<br/>        stateUpdated = false;<br/>        this.charges = deepCopy(result); </span><span id="b8c7" class="lr ls in ln b gy lx lu l lv lw">        this.changeState = true;<br/>      });<br/>    }<br/>  });<br/>}</span></pre><p id="b624" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以添加第二个参数 boolean <code class="fe lz ma mb ln b">inclusive</code>，它将包含第一个为<code class="fe lz ma mb ln b">takeWhile</code>返回 false 的值。有时需要查看打破条件的值。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="dce6" class="lr ls in ln b gy lt lu l lv lw">source$.pipe(takeWhile(predicate, true));</span></pre><p id="1c14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举例来说:</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="b9bf" class="lr ls in ln b gy lt lu l lv lw">const breakParam = "Y";<br/>const result = of(["X","Y","Z"])<br/>.pipe(takeWhile(v =&gt; v != breakParam, true))<br/>.subscribe(item =&gt;<br/>  console.log(item);<br/>);</span></pre><p id="aec3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以使用运算符<code class="fe lz ma mb ln b">endWith(value)</code>。它在完成时发出给定值。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="c22c" class="lr ls in ln b gy lt lu l lv lw">const result = source$.pipe(<br/>  takeWhile(item =&gt; item != 5), endWith(5))<br/>  <!-- -->.subscribe(value =&gt; console.log(value),<br/>      err =&gt; console.log('error', err),<br/>      () =&gt; console.log('complete'));<br/>  }</span><span id="f0fe" class="lr ls in ln b gy lx lu l lv lw">or let's take first 3 values</span><span id="67cb" class="lr ls in ln b gy lx lu l lv lw">interval(1000).pipe(<br/>      take(3),<br/>      endWith(999)<br/>    ).subscribe(value =&gt; console.log(value));</span></pre><h1 id="ca97" class="mc ls in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">过滤器与耗时</h1><p id="2897" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">在 RxJS 中比较这两个相似的操作符也很有趣:<code class="fe lz ma mb ln b">takeWhile</code> &amp; <code class="fe lz ma mb ln b">filter</code></p><p id="0caf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们试图将该值与某些条件相匹配，并丢弃其他条件。但是，<code class="fe lz ma mb ln b">takeWhile</code>只有在满足中断条件操作符之前才与可观察对象一起工作。虽然<code class="fe lz ma mb ln b">filter</code>永远不会停止可观测。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="713d" class="lr ls in ln b gy lt lu l lv lw">const source$ = of(1,1,2,2,1,3,4);</span><span id="7767" class="lr ls in ln b gy lx lu l lv lw">source$<br/>  .pipe(takeWhile(it =&gt; it === 1))<br/>  .subscribe(val =&gt; console.log('takeWhile', val)); //1,1</span><span id="1db0" class="lr ls in ln b gy lx lu l lv lw">// filter will filtered out all '1' items.<br/>source$<br/>  .pipe(filter(it =&gt; it === 1))<br/>  .subscribe(val =&gt; console.log('filter', val)); //1,1,1</span><span id="a479" class="lr ls in ln b gy lx lu l lv lw">// filter will take only 1 value that more than 2.<br/>source$<br/>  .pipe(filter(x =&gt; x &gt; 2), takeLast(1)).subcribe(...); //4</span></pre><p id="b234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="5466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些操作符看起来都很有逻辑，读起来也很简单，尽管总会出现一些意想不到的行为。</p><p id="ba5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RxJS、RxJava、RxKotlin 中有很多类似的运算符可以让你及时停止订阅:first、single、take、takeLast、takeUntil、takeWhile。运营商将帮助您管理如何订阅以及何时手动或自动退订。Rx 允许最小化该过程的例行程序。</p><p id="137d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="ne nf gp gr ng nh"><a href="https://rxjs.dev/guide/overview" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">RxJS</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">编辑描述</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">rxjs.dev</p></div></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://rxjs-dev.firebaseapp.com/api/operators/endWith" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">RxJS</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">编辑描述</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">rxjs-dev.firebaseapp.com</p></div></div></div></a></div></div></div>    
</body>
</html>