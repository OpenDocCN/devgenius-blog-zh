<html>
<head>
<title>Best of Modern JavaScript — Control Object Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——控制对象操作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-control-object-operations-69f3fa96a973?source=collection_archive---------6-----------------------#2020-11-12">https://blog.devgenius.io/best-of-modern-javascript-control-object-operations-69f3fa96a973?source=collection_archive---------6-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24fd351582daf101b18452fc8c286d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8T4Q4qQ0IJE6ao9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">让·卡洛·埃默在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="5d7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究使用 JavaScript 代理的元编程。</p><h1 id="8e92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理负数组索引</h1><p id="5d9e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了代理，我们可以通过访问负索引的数组来增强数组。</p><p id="636d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6b9a" class="mn lc iq mj b gy mo mp l mq mr">const handler = {<br/>  get(target, propKey, receiver) {<br/>    const index = Number(propKey);<br/>    if (index &lt; 0) {<br/>      propKey = String(target.length + index);<br/>    }<br/>    return target[propKey];<br/>  }<br/>};</span><span id="aaed" class="mn lc iq mj b gy ms mp l mq mr">const target = [];<br/>target.push(1, 2, 3);<br/>const arr = new Proxy(target, handler);</span><span id="1445" class="mn lc iq mj b gy ms mp l mq mr">console.log(arr[-1])</span></pre><p id="4fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">get</code>方法创建了<code class="fe mt mu mv mj b">handler</code>对象。</p><p id="44f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个小于 0 的<code class="fe mt mu mv mj b">index</code>，那么我们通过给它加上<code class="fe mt mu mv mj b">target.length</code>使它为正。</p><p id="9904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用数组的索引返回数组的属性。</p><p id="cee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们用参数创建了<code class="fe mt mu mv mj b">target</code>数组。</p><p id="ef2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们返回一个代理，它是一个类似数组的对象，我们可以对它使用负索引。</p><h1 id="afb3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置属性</h1><p id="7137" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">handler</code>对象中的<code class="fe mt mu mv mj b">set</code>方法让我们控制如何在对象中设置属性。</p><p id="d0e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a19" class="mn lc iq mj b gy mo mp l mq mr">function createArray(callback) {<br/>  const array = [];<br/>  return new Proxy(array, {<br/>    set(target, propertyKey, value, receiver) {<br/>      callback(propertyKey, value);<br/>      return Reflect.set(target, propertyKey, value, receiver);<br/>    }<br/>  });<br/>}<br/>const arr = createArray(<br/>  (key, value) =&gt; console.log(key, value));<br/>arr.push('a');</span></pre><p id="82fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个数组，我们可以观察它的操作。</p><p id="dc88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe mt mu mv mj b">createArray</code>函数，它接受一个<code class="fe mt mu mv mj b">callback</code>，每当我们在数组上设置一个值时，这个函数就会被调用。</p><p id="dc56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe mt mu mv mj b">propertyKey</code>和<code class="fe mt mu mv mj b">value</code>调用<code class="fe mt mu mv mj b">callback</code>。</p><p id="a44f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到阵列操作在完成时被记录下来。</p><h1 id="3e47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Revocable References</code></h1><p id="5ce6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建可撤销的引用，这样我们只有在被允许的情况下才能访问对象。</p><p id="1f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="84a0" class="mn lc iq mj b gy mo mp l mq mr">const target = {};<br/>const handler = {};<br/>const {<br/>  proxy,<br/>  revoke<br/>} = Proxy.revocable(target, handler);</span></pre><p id="3b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">target</code>是一个我们可以用来创建代理的对象。</p><p id="9e2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">handler</code>是一个让我们截取对象和改变对象的操作。</p><p id="2551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">proxy</code>是否代理返回。</p><p id="9ec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe mt mu mv mj b">revoke</code>是一个让我们撤销对代理的访问的函数。</p><h1 id="015f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">元对象</h1><p id="6e63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript 对象有隐藏的属性，让我们可以获取对象。</p><p id="9e07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个方法可以让我们获取对象的属性并返回它。</p><p id="d34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以捕获 get 和 call 操作。</p><h1 id="9991" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为代理实施不变量</h1><p id="72fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用代理来实现各种不变量。</p><p id="9409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以做的一件事是禁用对象的可扩展性。</p><p id="34c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe mt mu mv mj b">Object.preventExtensions</code>方法来禁止向对象添加属性。</p><p id="1266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9cd2" class="mn lc iq mj b gy mo mp l mq mr">'use strict'<br/>const obj = Object.preventExtensions({});<br/>obj.bar = 'foo';</span></pre><p id="0867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来阻止我们给一个对象添加属性。</p><p id="4784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果严格模式为 on，则当我们尝试向不可扩展的对象添加属性时，会出现错误“未捕获类型错误:无法添加属性栏，对象不可扩展”。</p><p id="e3e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来检查对象是否可扩展:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6909" class="mn lc iq mj b gy mo mp l mq mr">console.log(Object.isExtensible(obj));</span></pre><p id="c94f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它返回<code class="fe mt mu mv mj b">true</code>，那么我们可以向它添加属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f7fbd6a6dea2a4cf4290d24d45d468af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*meZA7xqsAbPGeGRT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@louisrdn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易·雷诺</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3c76" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ccc9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用代理做各种事情，比如控制对一个对象的访问等等。</p><p id="f94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于其他操作，我们不需要代理。<code class="fe mt mu mv mj b">Object</code>构造函数有静态方法让我们控制对象操作。</p></div></div>    
</body>
</html>