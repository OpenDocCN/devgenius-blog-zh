<html>
<head>
<title>Valet, a job queuing and async task running service packed in a Go module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Valet，打包在 Go 模块中的作业队列和异步任务运行服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/valet-a-job-queuing-and-async-task-running-service-packed-in-a-go-module-6057416b7e7e?source=collection_archive---------4-----------------------#2022-05-02">https://blog.devgenius.io/valet-a-job-queuing-and-async-task-running-service-packed-in-a-go-module-6057416b7e7e?source=collection_archive---------4-----------------------#2022-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/47c1ed6bfd06038e54be99d2fc63f78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5r3h2wCnFlGU8xHjPRllw.jpeg"/></div></div></figure><p id="bc30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">几个月前，我偶然发现了@ matiasvarela 的这篇文章，作者通过一个示例项目向我们介绍了六边形架构。这激励我通过实践特定的设计模式来构建这个新项目。</p><blockquote class="ku kv kw"><p id="3143" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">什么是贴身男仆？</p></blockquote><p id="204b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个想法并不新鲜。作业队列服务和异步任务运行程序。一个守护进程，它公开一个 API，负责异步和并发地执行“繁重”的任务。它位于其他服务之间，只有一个职责:完成繁重的工作并存储结果(如果有的话)。</p><p id="2ed0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么什么是合适的任务呢？如何安排任务的执行？我们如何向每个任务传递参数，我们如何从语言对并发性的内置支持中获益，以使所有这些更有效？让我们通过进入项目的实现细节来回答这些问题。</p><p id="e676" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在 GitHub 上找到这个项目:<a class="ae kt" href="https://github.com/svaloumas/valet" rel="noopener ugc nofollow" target="_blank">https://github.com/svaloumas/valet</a></p><p id="9372" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不言而喻，这里介绍的每种方法都只是可能的解决方案之一，如果有任何反馈，我们将不胜感激。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="49cc" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">回调</strong></p></blockquote><p id="7806" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任务是用户定义的函数，由服务在未来的某个时间或立即作为回调运行。代客按如下方式处理所有可能的回电:</p><p id="6ce6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个任务都应该实现一个固定的类型。签名<code class="fe li lj lk ll b">func(…interface{}) (interface{}, error)</code>被用作任务的类型。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">TaskFunc 是任务应该实现的类型。</figcaption></figure><p id="fd5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过 API 端点向函数传递参数。这些参数将总是放在<code class="fe li lj lk ll b">args[0]</code>中，因此可以从函数内部访问它们，它们的类型将是<code class="fe li lj lk ll b">map[string]interface{}</code>。正如我们将在后面看到的，多个任务可以按顺序一个接一个地运行。在这种情况下，<code class="fe li lj lk ll b">args[1]</code>将保存前一个任务的结果，以便当前的任务可以使用它们和自己的参数。任务的返回值总是一个<code class="fe li lj lk ll b">interface{}</code>，带有我们可能需要存储为任务结果的任何元数据和一个<code class="fe li lj lk ll b">error</code>。</p><p id="96e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以定义自定义结构，并将请求有效负载中给出的<code class="fe li lj lk ll b">map[string]interface{}</code>类型参数解码成您自己的数据结构。</p><p id="7910" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的两个函数将参数解码成自定义结构。他们都在内部使用@ <a class="ae kt" href="https://github.com/mitchellh" rel="noopener ugc nofollow" target="_blank"> Mitchell Hashimoto </a>的<a class="ae kt" href="https://github.com/mitchellh/mapstructure" rel="noopener ugc nofollow" target="_blank"> mapstructure </a>。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">任务函数中使用的助手函数。</figcaption></figure><p id="624b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们把它们放在一起。下面是一个用户定义的任务的例子，它实现了<code class="fe li lj lk ll b">TaskFunc</code>类型，以及一个将任务参数解码成的结构。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">一个虚拟任务回调示例。</figcaption></figure><p id="84e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任务在服务初始化时注册，并存储在内存中的映射中，以便可以使用唯一的字符串标识符调用它们的函数值。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">服务初始化期间的任务注册。</figcaption></figure><p id="9802" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该服务在运行时使用简单的查找机制，将每个任务名称与其对应的函数值相关联。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">内存中任务查找。</figcaption></figure><p id="72db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经将任务存储在内存中，我们可以创建新的作业和管道，通过 API 调用将参数传递给函数，方法是将它们添加到请求有效负载中。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">作业创建请求负载示例。</figcaption></figure><p id="c363" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，什么是工作，什么是管道呢？</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="219f" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">六角形建筑</strong></p></blockquote><p id="8513" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你还没有，花几分钟阅读 Matias 关于这个设计模式的文章(你可以找到下面的链接)。</p><p id="fe89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">域</strong></p><p id="b8f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">项目的核心是领域。这是与业务逻辑相关的数据结构存在的地方。代客的主域实体是<em class="kx">作业</em>。</p><p id="aa98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作业只是封装了与将要运行的任务相关的所有元数据。诸如我们在标记为失败之前为特定作业设置的超时间隔、作业状态(是挂起、正在进行还是已完成)以及创建、开始或完成时间的时间戳等信息都是作业的一部分。</p><p id="4bb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个主要实体是<em class="kx">管道</em>，它代表了需要以指定顺序一个接一个运行的作业序列。执行管道时，每个作业都可以选择使用前一个已完成作业的结果。</p><p id="944a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">端口(接口)</strong></p><p id="841e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代客需要两个“外部”系统才能正常运行。一个队列，用于实现其作业排队机制，一个存储系统，用于保存作业和/或管道的元数据及其结果。</p><p id="8648" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在设计模式的术语中，队列和存储系统都是受驱动的角色。定义了两个端口来启用与参与者的交互，<em class="kx">作业队列</em> &amp; <em class="kx">存储</em>。</p><p id="dbbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于像 CLI 工具或任何其他应用程序这样的驱动程序参与者，为了创建新的或管理现有的作业和管道，还定义了驱动程序参与者接口及其具体实现，即所谓的服务。</p><p id="6303" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">适配器</strong></p><p id="73ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，该项目提供了 JobQueue 接口的三个具体实现。一个简单而轻量级的内存 FIFO 队列，</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">简单的内存 FIFO 队列实现。</figcaption></figure><p id="29b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个 RabbitMQ 客户端，用于将服务与现有的消息代理连接起来；一个 Redis 客户端，利用<code class="fe li lj lk ll b">LPUSH</code>和<code class="fe li lj lk ll b">RPOP</code> Redis 命令，将 NoSQL 存储用作作业队列。</p><p id="74de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至于存储接口，提供了四个具体的实现，使服务成为许多环境的即插即用组件。内存中的键值存储，用于没有外部存储可用时或用于测试目的。关系存储系统支持 MySQL 和 PostgreSQL。最后，作为 NoSQL 代表的 Redis 也可以用于持久性，因为它有一个可用的适配器。</p><p id="0224" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于驱动参与者适配器，提供了支持 HTTP 和 gRPC 通信的处理程序实现。</p><p id="20c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">依赖注入</strong></p><p id="9b7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照这种方法构建项目布局的另一个主要优点是，我们可以在初始化不同的内部组件时利用依赖注入。这也涉及到工厂模式的使用。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用工厂模式初始化适配器。</figcaption></figure><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">依赖注入来初始化服务。</figcaption></figure></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="74cf" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">并发</strong></p></blockquote><p id="197a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行任务的内部组件是一个基本的工人池实现。可用工作线程的数量以及工作线程池内部队列都是可配置的。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">初始化可配置数量的员工。</figcaption></figure><p id="0104" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个工作者监听这个内部队列，等待要完成的工作，消费消息，并执行工作。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Worker 侦听 worker pool 队列中的工作。</figcaption></figure><p id="3cad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在流水线的情况下，所有的任务都由同一个工人执行，因为他们必须等待每个任务完成，然后才能继续下一个任务。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="6629" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">运行任务</strong></p></blockquote><p id="0c43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理用户定义的函数可能很棘手。最好的情况是函数成功运行，或者甚至产生一个错误值，这是意料之中的，它的消息将与任何结果元数据一起保存。但是函数很容易引入死锁，导致永久等待，当然还有资源泄漏。它也可以快乐地恐慌。</p><p id="405b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在围棋中，恐慌是个例外。然而，它足以将其错误堆栈跟踪传播到执行的主线程，并破坏整个进程。对于一个至少需要运行数百个功能的服务，我们当然负担不起这样的费用！我们必须像处理普通事件一样处理恐慌。我们可以通过利用内置的<code class="fe li lj lk ll b">recover()</code>函数来做到这一点。一个匿名的<code class="fe li lj lk ll b">func</code>被延迟来检查是否发生了紧急情况，提取紧急消息，并通过一个通道将其作为一个作业结果发送，该作业结果将在我们的持久层中结束。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">负责任务执行的 go-routine。</figcaption></figure><p id="d056" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至于潜在的死锁，我们能做的不多，至少用这个简单而不复杂的方法。我们可以为任务设置一个超时间隔，而不是试图在死锁条件下停止正在运行的 go-routine。这样，在出现死锁的情况下，我们仍然会损失一些资源，但是我们应该能够继续服务于其他任务，而不是永远等待有问题的任务结束。毕竟，在将它们注册为服务中的任务之前，由用户来测试他们自己的功能的行为。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">等待作业结果或超时，以先出现的为准。</figcaption></figure></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="fd87" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io"> Go 模块</strong></p></blockquote><p id="6166" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初的想法是将<em class="kx">代客</em>作为<code class="fe li lj lk ll b">cmd</code>提供，这样我们就可以构建和扩展 Docker 容器并开始使用它。使用这种方法，我们必须下载项目的源代码，并将我们的任务函数放在项目的特定目录中。从那里，我们要么有一些脚本来解析我们的源文件，并在构建可执行文件之前通过修改<em class="kx"> valet </em>源代码的某个部分来注册任务，要么我们必须自己完成。那将是既乏味又容易出错的。最糟糕的是，我们必须在两个地方维护这些功能，一个是我们的仓库，另一个是<em class="kx">代客</em>仓库。</p><p id="ae2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让每个人都更容易，该服务作为 Go 模块提供。您可以在存储库下维护您的任务函数，并通过实现一个简单的<code class="fe li lj lk ll b">main</code>函数来构建您自己的可执行文件副本，如下所示。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">一个主函数的例子，需要建立自己的代客 cmd。</figcaption></figure><p id="2132" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在相应的<a class="ae kt" href="https://github.com/svaloumas/valet#installation" rel="noopener ugc nofollow" target="_blank">自述文件</a>部分找到完整的安装指南。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><blockquote class="ku kv kw"><p id="f04a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">参考文献</strong></p></blockquote><ul class=""><li id="24b5" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><a class="ae kt" href="https://medium.com/@matiasvarela/hexagonal-architecture-in-go-cfd4e436faa3" rel="noopener">https://medium . com/@ matiasvarela/hexagon-architecture-in-go-CFD 4 e 436 FAA 3</a></li><li id="ee39" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><a class="ae kt" href="https://vaadin.com/learn/tutorials/ddd/ddd_and_hexagonal" rel="noopener ugc nofollow" target="_blank">https://vaadin.com/learn/tutorials/ddd/ddd_and_hexagonal</a></li><li id="839f" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">【https://github.com/mitchellh/mapstructure T2】号</li></ul></div></div>    
</body>
</html>