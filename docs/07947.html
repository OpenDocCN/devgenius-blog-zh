<html>
<head>
<title>Let, Var and Const in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS 中的 Let、Var 和 Const</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/let-var-and-const-in-js-2f6226457d2f?source=collection_archive---------8-----------------------#2022-05-05">https://blog.devgenius.io/let-var-and-const-in-js-2f6226457d2f?source=collection_archive---------8-----------------------#2022-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ace" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，今天讨论的是关于变量让 var 和 const..</p><p id="fd1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">人们可能会在 var，let 和 const 之间搞不清为什么要用和什么时候要用，所以博客在这里来澄清这种混乱…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/91097b202af28bc24f9d5d4855750409.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*6p7X5UaTSSjBrJL2EKeb4w.png"/></div></figure><p id="16cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个博客将帮助你理解为什么使用 const 和 let over var 以及在哪里使用它们，所以让我们开始…</p><blockquote class="kq kr ks"><p id="47d7" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated">建议:只是一个建议，用下面给出的例子，在你的游戏机上也试试，这样它会一直留在你的脑海里</p></blockquote></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="b1d8" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1) Var:</h1><p id="0873" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">Var 在 Javascript 中使用了很长时间，但是 let 和 const 是在 ES6 版本中引入的。使用<strong class="jm io">变量</strong>你可以重新赋值给一个变量，也可以使用变量关键字重新声明变量..</p><p id="84a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">举例:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="60eb" class="mm lf in mi b gy mn mo l mp mq">var b = "Hello"<br/>var b = "Hey" // user can redeclare it using var keyword<br/> b = "nice"  // you can also reassign value to the variable<br/></span></pre><p id="df7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">范围:</strong></p><p id="3691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Var 关键字有全局作用域或函数作用域。这意味着如果任何带有 var 关键字的变量是全局声明的(在函数外部)，那么它在函数内部是可访问的，也是全局可访问的。看例子才能正确理解。</p><p id="8321" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1 : </strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="b49c" class="mm lf in mi b gy mn mo l mp mq">var b = "Hello"<br/>        function Checkb(){<br/>            console.log(b)<br/>        }<br/>    Checkb();<br/>    console.log(b);</span></pre><p id="9936" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解释:</strong>在上面的例子中，你可以看到变量“b”和 var 关键字是全局声明的，我们尝试两次获取值，一次在函数内部，第二次在函数外部，所以这两种方法都能得到正确的结果。参见输出</p><p id="48b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kt">输出:</em> </strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="bc15" class="mm lf in mi b gy mn mo l mp mq">"Hello"<br/>"Hello"</span></pre><p id="4edc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果变量“b”在函数内部声明了 var 关键字，那么它只能在函数内部访问，在函数外部不可访问，并抛出一个引用错误。</p><p id="cb79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 2: </strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="3176" class="mm lf in mi b gy mn mo l mp mq">function f() {<br/> <br/>        var b = "Hello";     // It can be accessible anywhere<br/>        console.log(b)        // within this function<br/>    }<br/>    f();<br/> <br/>    console.log(b);      // B cannot be accessible<br/>                        //because outside of function</span></pre><p id="fc95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/6c39e6cddadfb46022691ceb5ebd60f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*rYwrgeTaksP5WALpMMEcpw.png"/></div></figure><p id="f305" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解释:</strong>所以在第二个例子中，变量“b”是在函数内部声明的，所以我们试图在函数内部获取一次，然后在函数外部获取。在第一个示例中，我们得到了预期的结果，但在第二个示例中，我们得到了 ReferenceError，因为带有 var 关键字的变量在函数外部是不可访问的。所以我们知道 var 关键字有全局作用域，也有函数作用域。</p><h1 id="b562" class="le lf in bd lg lh ms lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx mw lz ma mb bi translated">2)让:</h1><p id="cee2" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">正如我上面提到的，<strong class="jm io">让</strong>在 ES6 中引入。<strong class="jm io">让</strong>是<strong class="jm io"> var 的改进版。</strong>使用 let 关键字，您可以将值重新分配给带有 let 关键字的变量，但不能重新声明带有 let 关键字的变量。</p><p id="9d57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="5f8b" class="mm lf in mi b gy mn mo l mp mq">let b = 1<br/>let b = 2     //error~ user cannot redeclare the variable again<br/> b = "0"      // you can reassign value to the variable</span></pre><p id="2f0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">说明:</strong></p><p id="3ba7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变量“b”已经用 let 关键字声明，所以不能重新声明。如果你这样做，你将得到 SyntaxError( b 已经被定义)。但是你可以像我上面做那样给变量重新赋值。</p><p id="9d72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">范围:</strong></p><p id="2b62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设</strong>有块作用域。在<code class="fe mx my mz mi b">{}</code>内的任何东西都被认为是一个块。块范围意味着如果“b”变量是在块内声明的，那么它在块外是不可访问的。</p><p id="b1e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="9fad" class="mm lf in mi b gy mn mo l mp mq">let c = 10</span><span id="ee28" class="mm lf in mi b gy na mo l mp mq"><strong class="mi io">if</strong> <!-- -->(c == 10) {</span><span id="dd8a" class="mm lf in mi b gy na mo l mp mq">let a = "hi"</span><span id="7cf6" class="mm lf in mi b gy na mo l mp mq">console.log(a) </span><span id="1af4" class="mm lf in mi b gy na mo l mp mq">}</span><span id="b116" class="mm lf in mi b gy na mo l mp mq">console.log(a)</span></pre><p id="36d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="5ff7" class="mm lf in mi b gy mn mo l mp mq">hi<br/>ReferenceError: a is not defined</span></pre><p id="bd3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">说明:</strong></p><p id="622d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们试图在声明“a”的代码块中获取“a”的值，因此我们得到了预期的值。但是第二次我们没有得到预期的值，而是得到了 ReferenceError。因为" a "是在块内声明的，如果我们试图在块外访问它，会显示错误。发生这种情况是因为任何用 let 关键字声明的变量都变成了块范围。</p><h1 id="45f8" class="le lf in bd lg lh ms lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx mw lz ma mb bi translated">3)常数:</h1><p id="61ef" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">Const 关键字也是在 ES6 中用<code class="fe mx my mz mi b">let</code>引入的。<code class="fe mx my mz mi b">Const</code>相当自明。<code class="fe mx my mz mi b">const</code>变量保持恒定值。虽然<code class="fe mx my mz mi b">const</code>的本质与<code class="fe mx my mz mi b">let</code>大不相同，但它们有很多相似之处，比如它们都有块范围。<em class="kt"> const </em>关键字具有与<em class="kt"> let </em>关键字相同的所有属性，除了用户不能更新的属性。参见下面的例子</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="5a28" class="mm lf in mi b gy mn mo l mp mq">//let<br/>let a = "john"<br/>a = "micheal"       //value can be updated</span><span id="fe35" class="mm lf in mi b gy na mo l mp mq">//const<br/>const b = "red"<br/>b = "blue"       // give you error because can't be updated</span></pre><p id="ea17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 const 关键字，既不能重新赋值，也不能用 const 重新声明变量。如果你这样做，会给你带来错误。</p><p id="d51a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">举例:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="3245" class="mm lf in mi b gy mn mo l mp mq">const b = "red"<br/>const b = "green"   // not allowed to redeclare <br/>b = "yellow"     // not allowed to reassign the value</span></pre><p id="d090" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">范围:</strong></p><p id="9575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我之前提到的，const 也有类似 let 的块范围。block 作用域是什么，上面已经讲清楚了。</p><p id="99da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="2f15" class="mm lf in mi b gy mn mo l mp mq">{<br/> const x = 9<br/> console.log(x)<br/> }<br/> <br/> console.log(x)</span></pre><p id="82e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="0cf6" class="mm lf in mi b gy mn mo l mp mq">9<br/>ReferenceError: x is not defined</span></pre><h2 id="babf" class="mm lf in bd lg nb nc dn lk nd ne dp lo jv nf ng ls jz nh ni lw kd nj nk ma nl bi translated"><strong class="ak">最可取:</strong></h2><p id="43fd" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">使用 const 关键字，代码变得更干净，但使用 var 关键字，代码变得混乱，因为如果在长代码中错误地将值重新分配给使用 var 关键字的变量，将很难调试代码。所以开发人员最喜欢的是 const 和 let……尤其是 const 使得代码更干净，更容易调试错误。</p><h2 id="9f11" class="mm lf in bd lg nb nc dn lk nd ne dp lo jv nf ng ls jz nh ni lw kd nj nk ma nl bi translated">结论:</h2><p id="52f8" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">在结束之前，让我们总结一下我们刚刚理解的内容:</p><p id="a235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mx my mz mi b">var</code> : <strong class="jm io">函数作用域，可以更新和重新声明。</strong></p><p id="2ab0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mx my mz mi b">let</code> : <strong class="jm io">块范围，可以更新，但不能重新声明。</strong></p><p id="eb7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mx my mz mi b">const</code> : <strong class="jm io">块范围的</strong>，<strong class="jm io">不能更新和重新声明。</strong></p><h2 id="f5ab" class="mm lf in bd lg nb nc dn lk nd ne dp lo jv nf ng ls jz nh ni lw kd nj nk ma nl bi translated">我几乎清楚了所有主要的东西，但如果你想深入了解范围的细节，你可以查看这个<a class="ae nm" href="https://www.freecodecamp.org/news/var-let-and-const-whats-the-difference/#:~:text=var%20declarations%20are%20globally%20scoped%20or%20function%20scoped%20while%20let,be%20updated%20nor%20re%2Ddeclared." rel="noopener ugc nofollow" target="_blank"> freeCodeCamp </a>。</h2></div></div>    
</body>
</html>