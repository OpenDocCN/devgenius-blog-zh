<html>
<head>
<title>React Tips — Input Event, Redux, Forward Ref and Bubbling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—输入事件、重复、前向引用和冒泡</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-input-event-redux-forward-ref-and-bubbling-7824a0c3c713?source=collection_archive---------7-----------------------#2020-07-26">https://blog.devgenius.io/react-tips-input-event-redux-forward-ref-and-bubbling-7824a0c3c713?source=collection_archive---------7-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e81fb135d913b520e39e89ffbf9914ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UriHYJxCO8vyloY3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">maggie bell 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="dd9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React 是一个用于创建 web 应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的 React 应用程序的技巧。</p><h1 id="5094" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 React 中触发变更事件的最佳方式</h1><p id="b932" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过获取本机输入值设置器以编程方式触发事件。</p><p id="55eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它而不是 React 的版本来触发输入事件。</p><p id="2f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cdf3" class="mn lc iq mj b gy mo mp l mq mr">const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set;<br/>nativeInputValueSetter.call(input, 'something');</span><span id="1fe6" class="mn lc iq mj b gy ms mp l mq mr">const ev = new Event('input', { bubbles: true });<br/>input.dispatchEvent(ev);</span></pre><p id="a32f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过以下方式获得本机输入值设置器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="46ae" class="mn lc iq mj b gy mo mp l mq mr">const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set;</span></pre><p id="3d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过编写以下内容创建一个本地输入事件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="90bf" class="mn lc iq mj b gy mo mp l mq mr">nativeInputValueSetter.call(input, 'something');</span></pre><p id="20c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是输入元素。</p><p id="3125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是输入的值。</p><p id="2db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了事件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0c70" class="mn lc iq mj b gy mo mp l mq mr">const ev = new Event('input', { bubbles: true });</span></pre><p id="12a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们在<code class="fe mt mu mv mj b">input</code>元素上调度输入事件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a28" class="mn lc iq mj b gy mo mp l mq mr">input.dispatchEvent(ev);</span></pre><h1 id="cb63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单击时防止嵌套组件中的事件冒泡</h1><p id="679e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe mt mu mv mj b">stopProphation</code>方法来防止嵌套组件中的事件冒泡。</p><p id="29ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27d3" class="mn lc iq mj b gy mo mp l mq mr">class ListItem extends React.Component {<br/>  constructor(){<br/>    super();<br/>    this.handleClick = this.handleClick.bind(this);<br/>  }</span><span id="6d40" class="mn lc iq mj b gy ms mp l mq mr">  handleClick(e) {<br/>    e.stopPropagation();<br/>    this.props.onClick();<br/>  }</span><span id="6987" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;li onClick={this.handleClick}&gt;<br/>        {this.props.children}<br/>      &lt;/li&gt;       <br/>    )<br/>  }<br/>}</span><span id="a132" class="mn lc iq mj b gy ms mp l mq mr">class List extends React.Component {<br/>  constructor(){<br/>    super();<br/>    this.handleClick = this.handleClick.bind(this);<br/>  }</span><span id="b22a" class="mn lc iq mj b gy ms mp l mq mr">  handleClick(e) {<br/>    // ...<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;ul onClick={this.handleClick}&gt;<br/>        &lt;ListItem onClick={this.handleClick}&gt;Item&lt;/ListItem&gt; <br/>      &lt;/ul&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="763f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们有一个 ul 元素的 click listenerss 和多个 li 元素的 click listener，我们必须在 li 元素的 click 处理程序上调用<code class="fe mt mu mv mj b">stopPropagation</code>,这样 click 事件就不会冒泡到 ul 元素和其他元素。</p><p id="ba9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们是这样做的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f090" class="mn lc iq mj b gy mo mp l mq mr">e.stopPropagation();</span></pre><p id="847b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">ListItem</code>中的<code class="fe mt mu mv mj b">handleClick</code>法。</p><h1 id="6ecb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在基于类的组件中使用 React.forwardRef</h1><p id="e35f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在基于类的组件中使用<code class="fe mt mu mv mj b">React.forwardRef</code>，方法是传入一个回调函数，该函数返回基于类的组件。</p><p id="3e5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="28be" class="mn lc iq mj b gy mo mp l mq mr">class DivComponent extends Component {<br/>  render() {<br/>    return (<br/>      &lt;div ref={this.props.innerRef}&gt;<br/>        foo<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="b04f" class="mn lc iq mj b gy ms mp l mq mr">const Comp = React.forwardRef((props, ref) =&gt; &lt;DivComponent<br/>  innerRef={ref} {...props}<br/>/&gt;);</span></pre><p id="be2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个带有<code class="fe mt mu mv mj b">props</code>和<code class="fe mt mu mv mj b">ref</code>参数的回调，并返回带有 props 和 ref 的<code class="fe mt mu mv mj b">DivComponent</code>作为它的 props。</p><p id="3dad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过引用<code class="fe mt mu mv mj b">this.props.innerRef</code>来访问 ref，这样我们就可以将它指定为 div 的 ref。</p><h1 id="48bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 connect with Redux 从 this.props 进行简单调度</h1><p id="5214" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe mt mu mv mj b">mapDispatchToProps</code>方法将我们的调度函数映射到 props。</p><p id="cc30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b130" class="mn lc iq mj b gy mo mp l mq mr">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return {<br/>    onClick: () =&gt; dispatch(decrement())<br/>  };<br/>}</span></pre><p id="50a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将减量动作的<code class="fe mt mu mv mj b">dispatch</code>调用映射到<code class="fe mt mu mv mj b">onClick</code>属性。</p><p id="249b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将<code class="fe mt mu mv mj b">dispatch</code>函数放入对象中直接访问它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="54e0" class="mn lc iq mj b gy mo mp l mq mr">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    dispatch,<br/>    onClick: () =&gt; dispatch(decrement())<br/>  };<br/>}</span></pre><p id="5de5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe mt mu mv mj b">bindActionCreators</code>来转动:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8232" class="mn lc iq mj b gy mo mp l mq mr">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    onPlusClick: () =&gt; dispatch(increment()),<br/>    onMinusClick: () =&gt; dispatch(decrement())<br/>  };<br/>}</span></pre><p id="e76a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9d0f" class="mn lc iq mj b gy mo mp l mq mr">import { bindActionCreators } from 'redux';</span><span id="8b4e" class="mn lc iq mj b gy ms mp l mq mr">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return bindActionCreators({<br/>    onPlusClick: increment,<br/>    onMinusClick: decrement<br/>  }, dispatch);<br/>}</span></pre><p id="add7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">increment</code>和<code class="fe mt mu mv mj b">decrement</code>动作映射到<code class="fe mt mu mv mj b">onPlusClick</code>和<code class="fe mt mu mv mj b">onMinusClick</code>道具。</p><p id="b77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将其简化为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f819" class="mn lc iq mj b gy mo mp l mq mr">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return bindActionCreators({ increment, decrement }, dispatch);<br/>}</span></pre><p id="983e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们只需要从道具中获取<code class="fe mt mu mv mj b">increment</code>和<code class="fe mt mu mv mj b">decrement</code>，并调用它们来调度动作。</p><p id="3aba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它变得更短:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fe96" class="mn lc iq mj b gy mo mp l mq mr">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return bindActionCreators({ increment, decrement }, dispatch);<br/>}</span><span id="fd58" class="mn lc iq mj b gy ms mp l mq mr">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(App);</span></pre><p id="e614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a18a" class="mn lc iq mj b gy mo mp l mq mr">export default connect(<br/>  mapStateToProps,<br/>  { increment, decrement }<br/>)(App);</span></pre><p id="ea17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样会注入<code class="fe mt mu mv mj b">increment</code>和<code class="fe mt mu mv mj b">decrement</code>作为没有<code class="fe mt mu mv mj b">mapDispatchToProps</code>的道具。</p><h1 id="aa5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更新 Redux 中特定数组项内的单个值</h1><p id="4d58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在 Redux 中更新特定数组项中的单个值，通过划分数组、修改要更改的条目，然后将它们重新组合在一起的方式编写 reducer。</p><p id="5dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="253b" class="mn lc iq mj b gy mo mp l mq mr">case 'MODIFY_ARRAY':<br/>   return { <br/>       ...state, <br/>       contents: [<br/>          ...state.contents.slice(0, index),<br/>          { title: "title", text: "text" },<br/>         ...state.contents.slice(index + 1)<br/>       ]<br/>    }</span></pre><p id="3cc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">slice</code>将数组分成块。然后我们有了下一个物体。</p><p id="a1a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用速度操作符将它们重新组合成一个数组。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/33f1e619c4b9c59e33b188dfc9e14f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RHbl98_W4zzTAdkA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯蒂娜·安妮·科斯特洛在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="838c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="088a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">mapDispatchToProps</code>有很多人手不足。</p><p id="8539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过在 reducer 中返回一个新的数组来改变一个数组条目。</p><p id="82a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调用<code class="fe mt mu mv mj b">stopPropagation</code>来停止事件冒泡。</p><p id="026c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用本机输入值设置器以编程方式触发输入事件。</p></div></div>    
</body>
</html>