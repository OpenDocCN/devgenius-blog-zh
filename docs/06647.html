<html>
<head>
<title>RecyclerView with Multiple Views in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 中具有多个视图的 RecyclerView</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/recyclerview-with-multiple-views-in-kotlin-bffe299c1994?source=collection_archive---------2-----------------------#2022-01-23">https://blog.devgenius.io/recyclerview-with-multiple-views-in-kotlin-bffe299c1994?source=collection_archive---------2-----------------------#2022-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c897f7fea2fbc6e2b0fd87c6a8447980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5CEQopXe1Z4M42W4juZYA.jpeg"/></div></div></figure><div class=""/><p id="0dbf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的 recycle view 文章的第一部分中，我展示了如何从头开始创建一个简单的 recycle view。现在，我将演示如何使用相同的适配器向相同的 recyclerview 添加不同的项目布局。因为我将建立在我以前的项目上，你可能想要<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/android-kotlin-recyclerview-with-databinding-788d353a67bf">看看它</a>。</p><p id="461a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们深入研究代码。</p><p id="e1dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在之前的项目中，我有一个名为<code class="fe ku kv kw kx b">LargeNews</code>的模型类。现在，我添加另一个名为<code class="fe ku kv kw kx b">ShortNews</code>的类。考虑到 OOP 原则，拥有一个名为<code class="fe ku kv kw kx b">News</code>的抽象父类是一个很好的实践，它拥有任何新闻类型的蓝图。任何继承<code class="fe ku kv kw kx b">News</code>的类都必须有一个标题和一个图像，这些属性应该被它们覆盖。因此，我们将<code class="fe ku kv kw kx b">News</code>及其属性定义为抽象的。另外，<code class="fe ku kv kw kx b">ShortNews</code>接受一个日期，<code class="fe ku kv kw kx b">LargeNews</code>接受一个描述。虽然它并不意味着在现实生活中使用，但它有助于我们更清楚地看到差异。</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="74f3" class="lg lh iy kx b gy li lj l lk ll">abstract class News {<br/>    abstract val title: String<br/>    abstract val image: Drawable?<br/>}</span><span id="664a" class="lg lh iy kx b gy lm lj l lk ll">data class ShortNews(<br/>    override val title: String,<br/>    override val image: Drawable?,<br/>    val date: String<br/>) : News()</span><span id="3785" class="lg lh iy kx b gy lm lj l lk ll">data class LargeNews(<br/>    override val title: String,<br/>    override val image: Drawable?,<br/>    val description: String<br/>) : News()</span></pre><p id="6213" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ku kv kw kx b">DummyData</code>中有一个函数创建并返回<code class="fe ku kv kw kx b">News</code>对象作为一个由<code class="fe ku kv kw kx b">LargeNews </code>和<code class="fe ku kv kw kx b">ShortNews</code>组成的列表。由于<code class="fe ku kv kw kx b">News</code>是<code class="fe ku kv kw kx b">LargeNews</code>和<code class="fe ku kv kw kx b">ShortNews</code>的父节点，我们可以将它们返回到与<code class="fe ku kv kw kx b">News</code>相同的列表中。显然，条目将根据我们添加到列表中的顺序显示在屏幕上。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="cfe6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是准备<code class="fe ku kv kw kx b">ShortNews</code>项目的布局。为了节省时间，我将创建一个真正基本的、没有吸引力的 UI。因此，创建一个新的布局文件，并根据需要进行定制。正如我在文章的第一部分中演示的，如果你想使用数据绑定，把文件转换成数据绑定布局。我向同一个<code class="fe ku kv kw kx b">item_large_news.xml</code>文件添加了一个文本视图。我的<code class="fe ku kv kw kx b">item_short_news.xml</code>文件是这样的:</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="49a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，是时候为<code class="fe ku kv kw kx b">ShortNews</code>创建 viewholder 类了。除了命名之外，它与<code class="fe ku kv kw kx b">LargeNewsViewHolder</code>几乎相同。在视图持有者内部，有一个函数将<code class="fe ku kv kw kx b">shortNews</code>对象绑定到布局的 shortNews 变量。可以定义不同于<code class="fe ku kv kw kx b">LargeNewsViewHolder</code>的功能和行为。</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="e269" class="lg lh iy kx b gy li lj l lk ll">class ShortNewsViewHolder(<br/>    private val binding: ItemShortNewsBinding<br/>) : RecyclerView.ViewHolder(binding.<em class="lp">root</em>) {<br/>    fun bind(shortNews: ShortNews) {<br/>        binding.<em class="lp">shortNews </em>= shortNews<br/>    }<br/>}</span></pre><p id="8742" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此后，是时候根据我们的需要，为不同的视图类型安排具有所有逻辑的<code class="fe ku kv kw kx b">NewsAdapter</code>了。</p><p id="e6a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上一个项目中的<code class="fe ku kv kw kx b">NewsAdapter</code>，以<code class="fe ku kv kw kx b">LargeNewsViewHolder</code>为视图持有人。然而，这已经不起作用了，因为我们有了另一个视图持有者，即<code class="fe ku kv kw kx b">ShortNewsViewHolder</code>。适配器必须与两种类型的观察架兼容。为此，使用<code class="fe ku kv kw kx b">RecyclerView.ViewHolder</code> a 类，因为两个视图持有者都从<code class="fe ku kv kw kx b">RecyclerView.ViewHolder</code>继承。正如<code class="fe ku kv kw kx b">LargeNews</code>、<code class="fe ku kv kw kx b">ShortNews</code>和<code class="fe ku kv kw kx b">News</code>的情况。</p><p id="905f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随后，开始将列表的类型从<code class="fe ku kv kw kx b">LargeNews</code>更改为<code class="fe ku kv kw kx b">News</code>，因为列表由<code class="fe ku kv kw kx b">LargeNews </code>和<code class="fe ku kv kw kx b">ShortNews</code>组成，正如我已经解释过的，它们都继承自<code class="fe ku kv kw kx b">News</code>。</p><div class="ky kz la lb gt ab cb"><figure class="lq ip lr ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><img src="../Images/8c486a64e31643f407865520fe52b78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*NOwhdxjUCEhCHPmW7M-ifg.png"/></div></figure><figure class="lq ip lw ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><img src="../Images/f69e470d0b7ece31114eb674b3ec25c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*9QG0yHPGHhz61ahXMg131A.png"/></div></figure></div><p id="214c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于 viewholder 类型已经改变，IDE 告诉我们要覆盖这些函数。然后，在类中添加两个项目布局的绑定类。</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="e33a" class="lg lh iy kx b gy li lj l lk ll">private lateinit var bindingLargeNews: ItemLargeNewsBinding<br/>private lateinit var bindingShortNews: ItemShortNewsBinding</span></pre><p id="33ed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您查看<code class="fe ku kv kw kx b">onCreateViewHolder</code>函数时，您会看到该函数返回<code class="fe ku kv kw kx b">RecyclerView.ViewHolder</code>。因此，我们将使用<code class="fe ku kv kw kx b">when</code>结构返回<code class="fe ku kv kw kx b">LargeNewViewHolder </code>或<code class="fe ku kv kw kx b">ShortNewViewHolder</code>。为了区分当前绘制的视图，我们将使用函数的 viewType 参数。该参数将根据当前项的类型返回一个整数值。要处理这种行为，覆盖<code class="fe ku kv kw kx b">getItemViewType</code>功能。</p><p id="3422" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实现这个函数之前，为了保持有序，创建一个名为<code class="fe ku kv kw kx b">NewsType</code>的枚举类，它保存可能的新闻类型和一个值。该值将用作视图类型。尽管如此，您仍然可以在不使用 enum 类的情况下给出这个值。</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="0be2" class="lg lh iy kx b gy li lj l lk ll">enum class NewsType(val value: Int) {<br/>    <em class="lp">LARGE_NEWS</em>(1), <em class="lp">SHORT_NEWS</em>(2)<br/>}</span></pre><p id="2b26" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ku kv kw kx b">getItemViewType</code>中获取当前项目，并通过<code class="fe ku kv kw kx b">is</code>关键字检查其类型。如果是一种类型的<code class="fe ku kv kw kx b">ShortNews</code>，那么返回我们在<code class="fe ku kv kw kx b">NewsType</code>中定义的值 2。<code class="fe ku kv kw kx b">onCreateViewHolder</code>将使用这个值来检查视图类型。这同样适用于<code class="fe ku kv kw kx b">LargeNews</code>。此外，我们必须写 else 情况，我更喜欢把<code class="fe ku kv kw kx b">LargeNews</code>放在里面。但是，这不会有任何区别，因为我们只有两种类型。作为另一种选择，你可以抛出一个异常。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lx"><img src="../Images/b385af2b038e3826287489be4ee6b4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJ1x9s3PJvSv7sdQzwGKxw.png"/></div></div></figure><p id="833c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在<code class="fe ku kv kw kx b">onCreateViewHolder</code>中，通过检查我们最近设置的 viewType 的值，我们将扩展视图的布局并返回它的一个实例。同样，我们必须编写 else 块，我将用 LargeNews 填充它。或者如前所述，您可以抛出一个异常。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ly"><img src="../Images/4c71f7c7f819770fac22ddbb401981da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vs1tb_IrdcbB33nl9qVtaw.png"/></div></div></figure><p id="0989" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ku kv kw kx b">onBindViewHolder</code>函数中，我们将调用 viewholder 的<code class="fe ku kv kw kx b">bind</code>函数。为了决定调用哪个视图持有者的绑定函数，再次检查当前项的类型。要使用 holder 参数作为所需的 viewholder 类型，请使用<code class="fe ku kv kw kx b">as</code>关键字并转换它。如果当前项目是<code class="fe ku kv kw kx b">ShortNews</code>的类型，则将项目绑定为<code class="fe ku kv kw kx b">ShortNews</code>，这同样适用于<code class="fe ku kv kw kx b">LargeNews</code>。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lz"><img src="../Images/148806ea47c8c07fa31c2c1685d06906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTodA4dP0QYsH7_kQEhUvg.png"/></div></div></figure><p id="2de6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<code class="fe ku kv kw kx b">getItemCount</code>返回列表的大小。</p><p id="1923" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步是更改<code class="fe ku kv kw kx b">MainActivity.kt</code>中的变量名，以保持清晰。但是，如果您遵循了我的第一篇文章，就没有必要添加或删除代码。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ma"><img src="../Images/308c719aed9a301fc6127876c885e7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yB_ZoG_Hjzm9OXpPjNg8oQ.png"/></div></div></figure><p id="2cd5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅此而已。虽然它看起来不漂亮，但工作正常。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mb"><img src="../Images/68c25717de38979331202c6c1ae964cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ccKk6fTqCt8A45rQKmSV_A.gif"/></div></div></figure><p id="ca38" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里查看完整项目<a class="ae kt" href="https://github.com/canonall/MultiView-RecyclerView" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4394" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常感谢任何反馈或建议！</p></div></div>    
</body>
</html>