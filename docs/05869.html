<html>
<head>
<title>Effective Java: Prefer Alternatives To Java Serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的Java:Java序列化的首选替代方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/effective-java-prefer-alternatives-to-java-serialization-3cf14eee190?source=collection_archive---------1-----------------------#2021-11-12">https://blog.devgenius.io/effective-java-prefer-alternatives-to-java-serialization-3cf14eee190?source=collection_archive---------1-----------------------#2021-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fe28ce41ab5a8c302dc6b5872ce1e1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eoMibSqGpKWbOOiN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@mikael_seegen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米凯尔·西根</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="81bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从1997年开始，Java的内置序列化就已经成为该语言的一部分，仅仅是在它诞生两年之后。甚至从它作为语言的一部分诞生之初，它就被认为是危险的。虽然目标是善意的，即不费吹灰之力地分发对象，但事后看来，人们普遍认为在正确性、性能、安全性和维护方面的成本是不值得的。</p><p id="8f89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Java语言的历史中，有无数的例子表明Java的内置序列化带来了问题。一个这样的例子是2016年对旧金山大都会运输署市政铁路的勒索软件攻击，该攻击使整个收费系统关闭了两天。</p><p id="ef6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java序列化的一个核心问题是它的目标太广，以至于攻击面非常大。对象图由<code class="fe lb lc ld le b">ObjectInputStream</code>类上的<code class="fe lb lc ld le b">readObject</code>方法反序列化。这有效地充当了一个神奇的构造函数，可以实例化基本上任何类型的对象，只要它实现了<code class="fe lb lc ld le b">Serializable</code>接口。</p><p id="eed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上没有不属于序列化攻击面的类。JVM类、第三方类和应用程序本身的类都是可能的目标。即使您的代码没有显式使用Java序列化，它也可能在幕后使用序列化。这是因为Java平台的主要部分，如RMI(远程方法调用)、JMX (Java管理扩展)和JMS (Java消息传递系统)都是建立在Java提供的序列化之上的。通过这些系统对不可信来源进行反序列化会导致远程代码执行、拒绝服务攻击和其他问题。</p><p id="117b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">攻击者和安全研究人员总是在寻找他们可以通过序列化利用的新类。很多时候，实际的攻击是通过这些攻击的链接进行的。这正是上文提到的铁路系统所发生的情况。</p><p id="72ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使没有这些攻击链，我们也可能会遇到序列化问题，即使是基本的代码。攻击者通常会寻找一些方法，他们可以提供少量的代码并执行大量的计算来寻找拒绝服务攻击。这通常被称为<em class="lf">反序列化炸弹</em>。让我们看一个例子:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="cef7" class="lo lp iq le b gy lq lr l ls lt">static byte[] bomb() {<br/>  Set&lt;Object&gt; root = new HashSet&lt;&gt;();<br/>  Set&lt;Object&gt; s1 = root;<br/>  Set&lt;Object&gt; s2 = new HashSet&lt;&gt;();<br/>  for (int i=0; i&lt;100; i++) {<br/>    Set&lt;Object&gt; t1 = new HashSet&lt;&gt;();<br/>    Set&lt;Object&gt; t2 = new HashSet&lt;&gt;();<br/>    t1.add("foo");<br/>    s1.add(t1);<br/>    s1.add(t2);<br/>    s2.add(t1);<br/>    s2.add(t2);<br/>    s1 = t1;<br/>    s2 = t2;<br/>  }</span><span id="a6e3" class="lo lp iq le b gy lu lr l ls lt">  return serialize(root);<br/>}</span></pre><p id="ae96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码创建了201个<code class="fe lb lc ld le b">HashSet</code>实例的对象图，每个实例有3个或更少的对象引用。整个图形仅占用5744字节，但无法反序列化。这是因为反序列化一个<code class="fe lb lc ld le b">HashSet</code>需要计算其所有元素的散列码。根<code class="fe lb lc ld le b">HashSet</code>的两个元素本身在100层之下还有两个散列集。这使得<code class="fe lb lc ld le b">hashCode</code>函数被称为2^100时间。令人沮丧的是，除了代码没有完成之外，没有任何问题的迹象。</p><p id="6f0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我认为我们已经充分证明了Java的内置序列化有很多缺陷。我们该怎么办？解决这个问题的最好方法是完全避免它。没有充分的理由在您今天编写的任何新代码中使用Java序列化。相反，您应该使用其他形式的数据传输。这些系统具有跨平台的优势。这些表示的好处是比Java序列化简单得多，范围也小得多。这使得it更加安全，因为他们通常只关注数据。这些格式的一些例子是JSON、协议缓冲区(Protobuf)和Avro。虽然协议缓冲区和Avro也可以促进模式验证，并具有远程过程调用系统(RPC)的扩展，但在简单传输状态时，它们仍然比Java序列化简单得多。</p><p id="ac09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您正在使用序列化的遗留系统上工作，您仍然可以做一些事情来降低风险。首先是只反序列化可信数据。Java的官方安全编码指南用红色粗体字写道“不可信数据的反序列化本质上是危险的，应该避免”。这是唯一的指导方针，所以我们不应该忽视它。您可以使用的另一个工具是Java 9中添加的<code class="fe lb lc ld le b">java.io.ObjectInputFilter</code>类(也是后端口的)。这允许更多地控制什么类型的对象可以和不可以在我们的系统中被反序列化。您可以选择只接受某些类型(允许列表)或不接受某些类型(不允许列表)。如果可能的话，你应该使用一个允许列表，因为这样可以最大程度地控制什么是可以接受的。不允许列表虽然仍然有用，但它只能保护您免受已知问题的影响，而不能防止新发现的问题。</p><p id="9c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天仍然有很多使用序列化的Java代码在使用。既然如此，我们应该理解它可能带来的复杂性和问题。我们还应该利用我们所拥有的任何工具来限制我们对这些问题的暴露程度以及它们的影响范围。一般来说，如果可以避免Java序列化，就避免它。在新系统中根本不引入Java序列化。相反，使用现代数据交换格式来跨系统传输数据。</p></div></div>    
</body>
</html>