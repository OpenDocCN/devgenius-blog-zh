<html>
<head>
<title>LeetCode 104: Maximum Depth of Binary Tree using recursive way (solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 104:使用递归方式的二叉树的最大深度(带图像的解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-104-maximum-depth-of-binary-tree-using-recursive-way-solution-with-images-91c427de9c6c?source=collection_archive---------14-----------------------#2022-08-19">https://blog.devgenius.io/leetcode-104-maximum-depth-of-binary-tree-using-recursive-way-solution-with-images-91c427de9c6c?source=collection_archive---------14-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="c0a7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题:→</h1><p id="12fa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定二叉树的<code class="fe lj lk ll lm b">root</code>，返回<em class="ln">其最大深度</em>。</p><p id="ed5a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">二叉树的<strong class="kn ir">最大深度</strong>是从根节点到最远叶节点的最长路径上的节点数。</p><p id="4fe7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 1: </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6d2dab8315a22b81c176bb4f62f56661.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*CJO3ZlYShWDBnITv.jpg"/></div></figure><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="8017" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lm ir">Output:</strong> 3</span></pre><p id="2463" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 2: </strong></p><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="7341" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> root = [1,null,2]<br/><strong class="lm ir">Output:</strong> 2</span></pre><p id="2976" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">约束:</strong></p><ul class=""><li id="b2c0" class="mk ml iq kn b ko lo ks lp kw mm la mn le mo li mp mq mr ms bi translated">树中的节点数量在范围<code class="fe lj lk ll lm b">[0, 104]</code>内。</li><li id="ade3" class="mk ml iq kn b ko mt ks mu kw mv la mw le mx li mp mq mr ms bi translated"><code class="fe lj lk ll lm b">-100 &lt;= Node.val &lt;= 100</code></li></ul><h1 id="bafd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案:→</h1><p id="c33e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，我们可以通过以下方式检查深度。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi my"><img src="../Images/78345a342881177574215e8408afdde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/0*IW2GRYceZVZ-25Mw.gif"/></div></figure><p id="6d10" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们用代码来理解，</p><p id="44c7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先我们会检查，如果<strong class="kn ir">根节点</strong>为<strong class="kn ir"> null </strong>，那么我们不需要做任何树的遍历，我们可以简单的返回<strong class="kn ir"> 0 </strong>。</p><p id="0ae3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，节点是<strong class="kn ir">非空</strong>，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/039d70d8b03229e63b6dcec880030001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WJ7DdqsCOR7UTN9z6sLTQ.png"/></div></div></figure><p id="0f50" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">节点(1) </strong>将被添加到<strong class="kn ir">堆栈</strong>中，现在我们正在用<strong class="kn ir"> root.left. </strong>通过<strong class="kn ir"> maxDepth </strong>进行<strong class="kn ir">递归</strong>调用</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ne"><img src="../Images/4f69f2801bbe858a069a5a7800f94878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hASmus43SoTzlPaoe4oCyg.png"/></div></div></figure><p id="9260" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，在递归调用中，我们用<strong class="kn ir"> node.left </strong>调用<strong class="kn ir"> maxDepth </strong>，我们将检查<strong class="kn ir">根节点</strong>是否为<strong class="kn ir"> null </strong>或<strong class="kn ir">不是</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nf"><img src="../Images/247ba16cdeecb514432b4e60d3c5d6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_3WT65wtkQWL1RVZwrKXA.png"/></div></div></figure><p id="0ee4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">节点(2)不为空。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/3081892b834049c924330d271fd13b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZB6pMcBTsmLiDZ_guX3Tw.png"/></div></div></figure><p id="5ebb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，在递归调用中，我们用<strong class="kn ir"> root.left </strong>调用<strong class="kn ir"> maxDepth </strong>，我们将检查<strong class="kn ir">根节点</strong>是否为空<strong class="kn ir">或<strong class="kn ir">不是</strong>。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nh"><img src="../Images/013dba072223b08887610cdabb19f857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zBrunFAbq9IYvQ0Uyj0pw.png"/></div></div></figure><p id="87cf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这里，我们发现<strong class="kn ir">为空</strong>，所以我们将返回<strong class="kn ir"> 0 </strong>，这里<strong class="kn ir">逆向过程</strong>将被启动，我们将从<strong class="kn ir">堆栈</strong>中取出<strong class="kn ir">最后一个节点</strong>(也就是<strong class="kn ir"> 2 </strong>)并用 root.right 调用<strong class="kn ir"> maxDepth。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ni"><img src="../Images/6d56c9eade73643e7e0f0f2cae6a4dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dNCLm4Eu2eg-v9A9DX2CA.png"/></div></div></figure><p id="ed39" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">同样，节点<strong class="kn ir">为空</strong>，因此返回<strong class="kn ir"> 0 </strong>。</p><p id="9410" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir">节点 2 的</strong>左<strong class="kn ir">右</strong>和<strong class="kn ir">都为空，所以都返回 0，</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nj"><img src="../Images/9c69a750c3c51dd7724b6076175a1728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycJPUNMYqyz0r5HBcPzIKA.png"/></div></div></figure><blockquote class="nk nl nm"><p id="8309" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated">所以，<strong class="kn ir">节点(2)</strong><strong class="kn ir">=&gt;</strong><strong class="kn ir">math . max(0，0) + 1 = &gt; 0 + 1 = &gt; 1 </strong>。</p></blockquote><p id="073b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">与上述过程相同，将会重复，我们将从<strong class="kn ir">堆栈</strong>中取出<strong class="kn ir">最后一个节点</strong>(也就是<strong class="kn ir"> 1 </strong>)并用<strong class="kn ir"> root.right. </strong>调用<strong class="kn ir"> maxDepth </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nq"><img src="../Images/eaf85f2bde4a17b0f18a99320dae6252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8KmxIPMxfKhnF4PxBfbig.png"/></div></div></figure><p id="a098" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir"> 3 </strong>的根节点<strong class="kn ir">不为空</strong>，因此，它将被添加到<strong class="kn ir">堆栈中。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nr"><img src="../Images/99f7e5296e7dc5ab62705ee979f87891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxDiSwlcCLEPHC0hOSQ8dA.png"/></div></div></figure><p id="1825" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在<strong class="kn ir">递归</strong>调用<strong class="kn ir"> maxDepth </strong>与<strong class="kn ir"> root.left </strong>将被调用。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ns"><img src="../Images/b4e2fcb67caba495eb777afe8955211d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OM4yHL46bDq-4abBbHrn2g.png"/></div></div></figure><p id="5a82" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，成为<strong class="kn ir"> 4、</strong>的根节点是<strong class="kn ir">而不是空</strong>，因此，它将被添加到<strong class="kn ir">堆栈中。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nt"><img src="../Images/6179f454c8dc75f45e307205bfeb7b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANt8NbyvmEBGf7SO_Pl8rA.png"/></div></div></figure><p id="528d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在<strong class="kn ir">递归</strong>调用<strong class="kn ir"> maxDepth </strong>与<strong class="kn ir"> root.left </strong>将被调用。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nt"><img src="../Images/81edeaf38c68baeb0ec568643cdfb227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5igYPYSk4aH6WiJWTxSNwg.png"/></div></div></figure><p id="4f58" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里节点<strong class="kn ir">为空</strong>，所以返回<strong class="kn ir"> 0 </strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nu"><img src="../Images/9c6aeca4aa46a9ac6ffd727f8e121075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K68ndfr5XSZ6zRO4o4p1iQ.png"/></div></div></figure><p id="2870" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在我们将从<strong class="kn ir">堆栈</strong>中取出<strong class="kn ir">最后一个节点</strong>(也就是<strong class="kn ir"> 4 </strong>)并用<strong class="kn ir"> root.right. </strong>调用<strong class="kn ir"> maxDepth </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nv"><img src="../Images/8df9f9495570e19b7b882428dfff11cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yirEyqJTCqXUAUlZd388Qg.png"/></div></div></figure><p id="5aeb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，成为<strong class="kn ir"> 5、</strong>的根节点是<strong class="kn ir">非空</strong>，因此，它将被添加到<strong class="kn ir">堆栈中。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nv"><img src="../Images/bf1816abc33545795ab3d4ed9b569fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2257jLCdC1qKtE70FydSA.png"/></div></div></figure><p id="619e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，在下一步中，对于<strong class="kn ir">节点 5 </strong>，我们将检查它是<strong class="kn ir">左节点</strong>，也就是<strong class="kn ir">空</strong>，所以返回值将是<strong class="kn ir"> 0 </strong>，然后在我们将<strong class="kn ir">从堆栈中移除</strong>节点(也就是<strong class="kn ir">节点 5 </strong>)并检查它是<strong class="kn ir">右节点</strong>，也是<strong class="kn ir">空，</strong>所以<strong class="kn ir">..</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nw"><img src="../Images/3f5233c23040cde8a8e67a20f993aaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nx-btcvoDkveKq80J8gJ8w.png"/></div></div></figure><p id="99cc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir">节点 5 的</strong>左<strong class="kn ir">和右<strong class="kn ir">都为空，所以都返回 0，</strong></strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nx"><img src="../Images/325e6b64a4c1e75f42fada5f7afa2c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7AVnEuljRws_TS-NuQpig.png"/></div></div></figure><blockquote class="nk nl nm"><p id="3471" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated">所以，<strong class="kn ir">节点(5)</strong><strong class="kn ir">=&gt;</strong><strong class="kn ir">math . max(0，0) + 1 = &gt; 0 + 1 = &gt; 1 </strong>。</p></blockquote><p id="94d6" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是现在 N <strong class="kn ir"> ode 4 的</strong>都<strong class="kn ir"> left (0 为空)</strong>和<strong class="kn ir"> right (1 = &gt; Node (5)为 1) </strong>也被求值，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ny"><img src="../Images/8d6fd8051b400b6a4fe5801138805d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfdpNM6cPr4uAAum9pcq2Q.png"/></div></div></figure><blockquote class="nk nl nm"><p id="85b8" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated">所以，<strong class="kn ir">节点(4) </strong></p><p id="d61c" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; Math.max(NULL，Node(5)) + 1 </strong></p><p id="394e" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; Math.max(0，1) + 1 </strong></p><p id="cd6a" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 1 + 1 </strong></p><p id="1485" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 2 </strong></p></blockquote><p id="7a97" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在我们将从<strong class="kn ir">栈</strong>中取出<strong class="kn ir">最后一个节点</strong>(也就是<strong class="kn ir"> 3 </strong>)，用<strong class="kn ir"> root.right、</strong>调用<strong class="kn ir"> maxDepth </strong>，也是 NULL，所以会返回 0 <strong class="kn ir">。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nz"><img src="../Images/f4ddf3f4348fcab8fc4b1d021a7074ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_Q4gtzVcKTniVKPr7H7Ow.png"/></div></div></figure><p id="3b27" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir">节点 3 左边是节点(4) </strong>右边是<strong class="kn ir">NULL，</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oa"><img src="../Images/844e7ab5fe3325eb2986152a7f530c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L80gARc2_47qYJ0BBMDsew.png"/></div></div></figure><blockquote class="nk nl nm"><p id="09c3" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated">所以，<strong class="kn ir">节点(3) </strong></p><p id="ccf4" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; Math.max(Node(4)，NULL) + 1 </strong></p><p id="5b91" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; Math.max(2，1) + 1 </strong></p><p id="43c4" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 2 + 1 </strong></p><p id="d13e" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 3 </strong></p></blockquote><p id="6db3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，在最后，<strong class="kn ir">节点(1) = &gt; </strong>既<strong class="kn ir">左(节点(2)) </strong>又<strong class="kn ir">右(节点(3)) </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ob"><img src="../Images/65b0c3e57ccbdb59e138396d6af88121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2awDHnZLB_XhssS3ECEYg.png"/></div></div></figure><blockquote class="nk nl nm"><p id="a8e0" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated">所以，<strong class="kn ir">节点(1) </strong></p><p id="5799" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir">=&gt;</strong><strong class="kn ir">math . max(Node(2)，Node(3)) + 1 </strong></p><p id="a5c9" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; Math.max(1，3) + 1 </strong></p><p id="db5a" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 3 + 1 </strong></p><p id="1d88" class="kl km ln kn b ko lo kq kr ks lp ku kv nn lq ky kz no lr lc ld np ls lg lh li ij bi translated"><strong class="kn ir"> = &gt; 4 </strong></p></blockquote><p id="caee" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">因此，最后<strong class="kn ir"> 4 </strong>将被<strong class="kn ir">返回</strong>，这将是总<strong class="kn ir">深度</strong>。</p><h1 id="5874" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Java)递归方式:→</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="d798" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Python)递归方式:→</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="3de3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="b4ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这里，我们遍历所有节点，所以总时间复杂度是<strong class="kn ir"> O(n) </strong>。</p><h1 id="742c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">空间复杂性</h1><p id="d232" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于我们使用了递归，在内部创建了一个栈，所以空间复杂度将是<strong class="kn ir"> <em class="ln"> O(n) </em> </strong>。</p><p id="7d9c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果你想用<strong class="kn ir">迭代的方式</strong>得到解，你可以<a class="ae oe" href="https://medium.com/dev-genius/leetcode-104-maximum-depth-of-binary-tree-solution-with-images-6c43c03af382" rel="noopener">点击这里</a>。</p><p id="57d7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">感谢你阅读这篇文章，❤</p><p id="0a12" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果这篇文章对你有帮助，请鼓掌👏这篇文章。</p><p id="2d6d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请在<a class="ae oe" href="https://medium.com/@alexmurphyas8" rel="noopener">媒体</a>上关注我，我会像上面一样发布有用的信息。</p><p id="0df9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">insta gram→<a class="ae oe" href="https://www.instagram.com/alexmurphyas8/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/alexmurphyas8/</a></p><p id="52f3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">推特→【https://twitter.com/AlexMurphyas8 T42】</p><p id="0fce" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p></div></div>    
</body>
</html>