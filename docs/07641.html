<html>
<head>
<title>Salt and hash password using bcrypt in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 NodeJS 中使用 bcrypt 的 Salt 和 hash 密码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/salt-and-hash-password-using-bcrypt-in-nodejs-3df1b7d23705?source=collection_archive---------3-----------------------#2022-04-12">https://blog.devgenius.io/salt-and-hash-password-using-bcrypt-in-nodejs-3df1b7d23705?source=collection_archive---------3-----------------------#2022-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="86e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保护用户密码的安全以防范网络攻击至关重要。第一步是在安全的数据库服务器上存储密码。然而，无论您采取多少预防措施，您都不能假设数据库是不可渗透的。这就是为什么你必须采取第二个步骤来使破解任何被盗密码更加困难:加盐和散列。</p><p id="12b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本帖中，我们将:</p><ol class=""><li id="94b8" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">了解 NodeJS 中的哈希</li><li id="7e66" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">了解盐腌</li><li id="d5aa" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">使用 bcrypt 的 Salt 和 hash 密码</li><li id="b95e" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将密码与哈希进行比较</li></ol><p id="8de3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在 YouTube 上浏览我的 NodeJS 库管理系统播放列表的视频教程。在这里，我已经向<strong class="jm io">解释了真实项目</strong>中的盐和散列</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">NodeJS 图书馆管理系统项目(YouTube)</figcaption></figure><p id="a292" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么是哈希？</strong></p><p id="6652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希指的是获取纯文本并通过哈希算法对其进行处理。哈希算法接受任意大小的输入文本，并返回固定长度的字符串。不管字符串/文本的大小，它总是返回相同长度的字符串。</p><p id="04c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为散列算法返回相同的散列字符串，所以这很可能是可预测的&amp;黑客也有可能使用另一个字符串并生成相同的散列值。正如我们所见，散列是不够的。</p><p id="8efe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么是腌制？</strong></p><p id="d944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">加盐只不过是在你的密码散列中添加一个随机的字符串。现在，当您使用 salt 时，它会自动包含在您的哈希密码中。因此，对于相同的密码，整体哈希值是不同的，这是不可预测的。</p><p id="4053" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设置所需的环境和库</strong></p><p id="e5db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个 NodeJS 项目。它使用 NPM 来管理其依赖关系。您需要创建一个新的项目目录，并使用以下命令初始化节点应用程序:</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="ff46" class="lm ln in li b gy lo lp l lq lr">npm init -y</span></pre><p id="9148" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将生成默认的 package.json 来管理这个项目的依赖项。</p><p id="9138" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在安装这个项目需要的包</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="7e3b" class="lm ln in li b gy lo lp l lq lr">npm init express bcrypt --save</span></pre><p id="de52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们安装<strong class="jm io"> nodemon </strong>，它实际上被用作代码监视器(这意味着如果你在你的项目中做了任何改变，那么你的应用程序将自动重启)</p><p id="5ce0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我完整的包</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="40ab" class="lm ln in li b gy lo lp l lq lr">{<br/>  "name": "auth",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "scripts": {<br/>     "devStart":"nodemon server.js"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "bcrypt": "^5.0.1",<br/>    "express": "^4.17.3"<br/>  },<br/>  "devDependencies": {<br/>    "nodemon": "^2.0.15"<br/>  }<br/>}</span></pre><p id="6a8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我修改了<strong class="jm io">脚本</strong> &amp;并在项目主文件中添加了<strong class="jm io"> devStart </strong>。</p><p id="b44c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">创建 NodeJS 基本服务器</strong></p><p id="f90c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在创建一个我们在 package.json 中使用过的<strong class="jm io"> server.js </strong>文件，并添加以下代码</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="6fc0" class="lm ln in li b gy lo lp l lq lr">const <strong class="li io"><em class="ls">express </em></strong>= require('express');<br/>const app = <strong class="li io"><em class="ls">express</em></strong>();<br/><br/>app.listen(3000);</span></pre><p id="0dcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我刚刚创建了一个快速服务器应用程序&amp;监听端口 3000。</p><p id="e5d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在将<strong class="jm io"> bcrypt </strong>添加到我们的应用程序中，它实际上用于 NodeJS 中的加密目的，主要用于散列密码。</p><p id="8ab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用阵列进行存储。请注意，对于真正的应用程序，您必须将数据存储在一些持久存储中。但出于学习的目的，我将它存储在数组中。</p><p id="f9d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">创建获取用户详细信息的路线</strong></p><p id="8528" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我将创建一个路由来获取所有用户。我们不会在生产中创建这样的路线，但出于学习目的，我们将在这里创建这样的路线</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="4df0" class="lm ln in li b gy lo lp l lq lr">let users = []; // store user details in an array</span><span id="4f74" class="lm ln in li b gy lt lp l lq lr">app.get('/users', (req, res) =&gt; {<br/>    res.json(users)<br/>});</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/b6f1e81301bf49daf0fe64849389d399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fMG-Unr-AKVy3x3RHbmTA.png"/></div></div></figure><p id="0fd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">创建用户注册路径</strong></p><p id="fdd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建注册用户的发布路径。但在此之前，我们必须添加一个中间件来接受 JSON 主体。在 NodeJS 中我们可以使用<strong class="jm io"> body-parser </strong>，但是新版本的 express 也支持带有<strong class="jm io"> app.use(express.json()) </strong>中间件的 JSON body。我将这个中间件添加到我们的代码中</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="4382" class="lm ln in li b gy lo lp l lq lr">app.use(<strong class="li io"><em class="ls">express</em></strong>.<strong class="li io"><em class="ls">json</em></strong>());</span><span id="b27a" class="lm ln in li b gy lt lp l lq lr">app.post('/user/register', async (req, res) =&gt; {<br/>    try {<br/>        const salt = await bcrypt.genSalt();<br/>        const passwordHash = await bcrypt.hash(req.body.password, salt);<br/>        users.push({username: req.body.username, password: passwordHash});<br/>        res.json(users);<br/>    } catch (e) {<br/>        res.status(500).send(e.toString());<br/>    }<br/>});</span></pre><p id="3254" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里<strong class="jm io"> bcrypt </strong>返回一个承诺，所以我们将添加异步。为了获得 Salt 字符串，我们将使用 genSalt 并将其存储在 salt 变量中。因为 genSalt 方法返回承诺，所以我们将等待该方法。</p><p id="7215" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是生成散列密码的时候了——为了生成散列密码，我们将使用<strong class="jm io"> bcrypt.hash </strong>方法。该方法将第一个参数作为纯文本，第二个参数作为 salt 字符串，并返回一个包含 salt 字符串的哈希值。这里我使用了 await，因为它返回 Promise，但是如果你不想使用 await，那么你必须注册一个回调来获得返回值。</p><p id="18e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一行中，我将用户详细信息推送到我们的<strong class="jm io"> users </strong>数组中。对于真正的应用程序，您将在数据库中存储所有的细节。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mb"><img src="../Images/a06d9923416717e78f5a27c6e9ed5b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kq15Zr-6exBwR6Z60anLPQ.png"/></div></div></figure><p id="0d30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为登录用户创建发布路由</strong></p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="6e73" class="lm ln in li b gy lo lp l lq lr">app.post('/user/login', async (req, res) =&gt; {<br/>    try {<br/>        const user = users.find(user =&gt; user.username === req.body.username);<br/>        <strong class="li io"><em class="ls">console</em></strong>.log(user);<br/>        if (!user) {<br/>            res.status(400).send('User Not Found!');<br/>        }<br/>        if (await bcrypt.compare(req.body.password, user.password)) {<br/>            res.send('LoggedIn');<br/>        } else {<br/>            res.send('Not Valid User!');<br/>        }<br/>    } catch (e) {<br/>        <strong class="li io"><em class="ls">console</em></strong>.log(e.toString());<br/>    }<br/>})</span></pre><p id="6b93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们首先根据用户名从用户数组中获取用户(这里我们假设用户名对于每个用户都是唯一的)。在下一行中，我们检查了用户是否存在，如果用户不存在，那么我们发送响应用户未找到！否则，我们将使用 bcrypt.compare 方法比较 password。该方法将第一个参数作为纯文本，第二个参数作为哈希密码。如果两者相等，则返回 true，否则返回 false。</p><p id="8ba2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">请注意</strong>我在 bcrypt.compare 方法之前使用了 await 关键字。如果您错过了 await 关键字，那么这将始终给您发送一个响应作为登录。(我过去也犯过这个错误，调试了差不多半个小时:)。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mc"><img src="../Images/43b1ebb219003ca587521667e763ef25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwzgJrr5Bc6qlO3tuJGwsA.png"/></div></div></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi md"><img src="../Images/217337ac0927758f6c8a84e1ef16b698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nrrjQH5TapkQgkO2ItOPg.png"/></div></div></figure><p id="9471" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是完整的代码</p><pre class="kw kx ky kz gt lh li lj lk aw ll bi"><span id="6900" class="lm ln in li b gy lo lp l lq lr">const <strong class="li io"><em class="ls">express </em></strong>= require('express');<br/>const bcrypt = require('bcrypt');<br/>const app = <strong class="li io"><em class="ls">express</em></strong>();<br/><br/>let users = [];<br/>app.use(<strong class="li io"><em class="ls">express</em></strong>.<strong class="li io"><em class="ls">json</em></strong>());<br/><br/>app.post('/user/register', async (req, res) =&gt; {<br/>    try {<br/>        const salt = await bcrypt.genSalt();<br/>        const passwordHash = await bcrypt.hash(req.body.password, salt);<br/>        users.push({username: req.body.username, password: passwordHash});<br/>        res.json(users);<br/>    } catch (e) {<br/>        res.status(500).send(e.toString());<br/>    }<br/>});<br/><br/>app.post('/user/login', async (req, res) =&gt; {<br/>    try {<br/>        const user = users.find(user =&gt; user.username = req.body.username);<br/>        <strong class="li io"><em class="ls">console</em></strong>.log(user);<br/>        if (!user) {<br/>            res.status(400).send('User Not Found!');<br/>        }<br/>        if (await bcrypt.compare(req.body.password, user.password)) {<br/>            res.send('LoggedIn');<br/>        } else {<br/>            res.send('Not Valid User!');<br/>        }<br/>    } catch (e) {<br/>        <strong class="li io"><em class="ls">console</em></strong>.log(e.toString());<br/>    }<br/>})<br/><br/>app.listen(3000);</span></pre><p id="0f1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae me" href="https://www.youtube.com/channel/UCvEB7wXUEXGFE9lCx0USR3Q" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">订阅获取更多类似内容解码，我们的 YouTube 频道</strong> </a> <strong class="jm io">！</strong></p><p id="b14d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！</p></div></div>    
</body>
</html>