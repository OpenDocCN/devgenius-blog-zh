<html>
<head>
<title>Introduction to GraphQL for NodeJS Developers, pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 开发人员的 GraphQL 介绍。一</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-graphql-for-nodejs-developers-5eb10240d38?source=collection_archive---------7-----------------------#2022-04-05">https://blog.devgenius.io/introduction-to-graphql-for-nodejs-developers-5eb10240d38?source=collection_archive---------7-----------------------#2022-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ce142e19d24a357188ef3352a446d990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbxinSpnD2NsOIc3qxMbJA.png"/></div></div></figure><p id="398d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有没有听说过“GraphQL”或者“GraphQL API”这样的词组却不知道？或者也许你知道它是什么，但你不知道如何开始使用它？或者也许你不知道它是否适合你的 API？如果是这样，你来对地方了。在本文中，我将解释 GraphQL 的基本概念。这是一系列文章中的第一篇，帮助您作为 NodeJs 开发人员准备好使用 GraphQL。</p><p id="eab1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么 GraphQL 到底是什么，你为什么要关心它呢？GraphQL 它只是一种用于在客户端和服务器之间交换数据的查询语言。它是建立在 HTTP 协议之上的。当使用 GraphQL API 时，您可以控制您确切获取的内容。在 REST APIs 中，您总是接收整个模型，即使您只需要它的一部分。在 GraphQL 中，您作为客户端，决定获取什么。如果您需要来自两个独立模型的数据？没问题，您可以在一个查询中获取它们。GraphQL 优化了网络上的数据交换。</p><p id="e6a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这些知识，我们就可以直接进入代码了。<br/>但是，我们要建造什么呢？先说简单的。假设你有一些电影数据库。我们的目标是创建一个用于查询电影和添加新电影的 API。我不会用数据库相关的东西来烦你。我将简单地模拟数据，并专注于 GraphQL 本身。<br/>我已经准备了一个 JSON 文件，里面有我们的模型。它有两个关键词:“电影”和“流派”两者都是数组。您可以在下面的示例中看到它:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="b559" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将从节点项目的初始化开始。对于这个演示，我将使用两个包——Apollo-server 和 nodemon。Apollo-server 它是服务器的 GraphQL 标准的实现之一。在我看来，它是最好的之一。它有一个广泛的社区、优秀的文档和一个用于测试 API 的内置客户端。</p><pre class="kt ku kv kw gt kz la lb lc aw ld bi"><span id="41ff" class="le lf in la b gy lg lh l li lj">npm init -y</span><span id="303c" class="le lf in la b gy lk lh l li lj">npm i apollo-server nodemon</span></pre><p id="7bcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建 GraphQL API，您需要一个来自 apollo 包的<code class="fe ll lm ln la b">ApolloServer</code>类和<code class="fe ll lm ln la b">gql</code>方法。<code class="fe ll lm ln la b">gql</code>是一个定义 GrapQL 模式的辅助方法。您可以将 GraphQL 模式视为数据库模式。作为程序员，我们定义它们来描述我们的模型看起来像什么。然后客户端可以不受任何限制地自由查询它们。但是模式本身并不是全部。为了拥有一个全功能的 API，您需要创建解析器。换句话说，您必须告诉 ApolloServer 如何从系统中获取或更新特定的模型。稍后我将介绍解决方案。让我们首先关注模式。</p><p id="8f2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的例子中，您可以看到我们的第一个模式定义:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="3c40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的模式的变量名是<code class="fe ll lm ln la b">typeDefs</code>。这是一个命名惯例。模式是通过调用<code class="fe ll lm ln la b">gql</code>方法创建的。您必须使用<code class="fe ll lm ln la b">type</code>关键字，并给出一个描述性的名称来提供类型定义。在花括号内，您可以定义类型的属性。为此，提供变量名，并在冒号后设置一个类型。</p><p id="c928" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类型可以是标量、枚举或对象。例如，move 类型有一个 id 属性，可以定义为 GraphQL ID 类型。GraphQL Ids 是唯一标识对象的序列化字符串。接下来，将标题设置为字符串，将年份设置为整数，将运行时间设置为浮点，将绘图设置为字符串，将流派设置为字符串数组。值得一提的是，在 GrahpQL 中，<strong class="jx io">所有属性都被当作可选的</strong>。</p><p id="52f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一步中，您必须定义查询。是的，在 GraphQL 中，查询是在 schema 中定义的。但是你告诉我客户可以自由地查询数据。所以你骗了我！</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/08189c4cb25ad4778d85c7fe69ff590d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZgbUzfSordArY_EngNQ6g.jpeg"/></div></div></figure><p id="f4b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">客户可以自由地查询数据，这意味着他们可以决定对模型的什么属性感兴趣。此外，他们可以选择在一个查询中查询两个、三个或更多模型。这在 REST API 中是不可能的。记住，我比较的是 GraphQL API 和 REST API，而不是 SQL query！</p><p id="1053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到查询…模式定义中的查询类似于接口定义。这是一个抽象，而不是实现。您可以选择定义查询名称、返回类型和输入参数。您可以在下面的示例中看到它:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="7a4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，你所做的只是一个简单的模式定义。但是，正如我前面提到的，模式只是难题的一部分。除了模式之外，您还必须告诉 GraphQL 如何解析查询。为此，您需要一个解析器函数。解析函数必须与模式定义中定义的名称相匹配。你可以把它想象成接口实现。您可以在下面的示例中检查我的解析器实现:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0bc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ll lm ln la b">getMovies</code>解析器中，我从 JSON 文件中返回被嘲笑的电影。通常，这里您会看到对数据库或其他 API 的调用。</p><p id="47e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置好<code class="fe ll lm ln la b">typeDefs</code>和<code class="fe ll lm ln la b">resolvers</code>之后，你终于可以启动我们的服务器了。我认为代码是自我描述的。这里没有什么新奇的:)<br/>要启动实际的服务器，请在终端中键入以下命令:</p><pre class="kt ku kv kw gt kz la lb lc aw ld bi"><span id="2441" class="le lf in la b gy lg lh l li lj">nodemon index.js</span></pre><p id="cffa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你打开打印在控制台内的 URL 时，你将被重定向到 apollo studio 页面。Apollo studio 是测试 API 的一个很好的工具。它由三个主要部分组成。在左侧，您可以看到 API 的文档。你所有的查询和类型都在那里。中间是用于编写查询的测试编辑器，最后，在右边是响应部分。我鼓励你玩一会儿。请熟悉一下。当你实现 GraphQL API 时，你会大量使用它。</p><p id="f7d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了测试查询是否按预期工作，我为您创建了一个:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="e575" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要从 GraphQL API 中获取一些东西，必须使用关键字<code class="fe ll lm ln la b">query</code>。接下来，必须提供查询的名称。它只是客户端的名称——为了区别更多的名称，您可以在查询对象中添加:)<br/>,您可以指定希望从服务器上可用的查询中触发哪些查询。最后，在花括号内，定义要获取对象的哪些属性。您可能已经注意到，电影模式的属性比我预期的要多得多。使用 GraphQL，您可以选择。很好，调用这样的查询的结果应该如下:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/7559245170f806d620c3cb835b72e71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reQqotk4jprJmC8omn2WIw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">获取电影查询结果</figcaption></figure><p id="6fb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很好，但是为了了解 GraphQL 的真正威力，我为您创建了另一个查询。该查询将返回一个流派列表:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="1b23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象一下，在你的客户端应用程序中，你有一个电影列表。您可以添加过滤功能。要做到这一点，你需要两样东西——电影列表和滤镜列表。我希望该应用程序能够通过电影类型过滤。因此，您将从 API 获取电影，并从 API 获取过滤器(类型)。如果使用 rest？你调用 API 两次。如果使用 GraphQL —只有一个！</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/94fddc01823910f28935c44692b1f77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfYG3ZWrcerwjaVq_Qn9Rg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">获取电影获取类型查询结果</figcaption></figure><p id="54db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在，关于查询和获取就足够了。如果能知道如何创建或更新一些数据就太好了。在 GraphQL 中，创建、更新或删除数据在语法上没有区别。为此，我们使用突变。真的很好记。当我们获取数据时，我们使用查询。否则，我们总是使用突变。所以程序是一样的。首先，您必须向模式定义中添加一个变体(为该动作创建一个接口)，然后在 resolver 对象中提供实现。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0b89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当 apollo 服务器需要查找一些数据时，它会调用所有解析器函数。例如，假设客户机试图创建一部新电影——它将调用<code class="fe ll lm ln la b">createmovie</code>解析器函数。所有解析器函数都可以接受四个输入参数，<code class="fe ll lm ln la b">createMovie</code>变异函数也是如此。目前，我只对第二个感兴趣，那就是输入。所以我们省略其余的。相反，我将在另一篇教程中深入讨论它们。<br/>我的解析器函数生成下一部电影的 id，并将其推送到电影数组。最后，它向用户返回一部新电影。更新了模式和解析器之后，就可以开始测试了。首先，让我们试试这个突变:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="b669" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，它与您之前做的查询超级相似，尽管有一些不同。最重要的是，您必须使用突变关键字来代替查询。还有带` $ '符号的变量。它们是输入变量——在这里，你描述新电影将会是什么样子。您可以在代码编辑器下面的部分填写它们。执行<code class="fe ll lm ln la b">CreateMovie</code>突变后，您应该会看到类似于我的结果:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/e983a43b02376687bb009ff039fa86bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7bQbaVzN02jBU0P08ydNQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">创建电影突变结果</figcaption></figure><p id="a117" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天的课就到这里。您已经学习了如何创建一个简单的 GraphQL 模式，创建解析器函数，并将其粘合在一起。这是向完全理解 GraphQL APIs 迈出的一大步。下一次，我将讨论更高级的模式类型，所以我鼓励您保持联系。下次见！</p></div></div>    
</body>
</html>