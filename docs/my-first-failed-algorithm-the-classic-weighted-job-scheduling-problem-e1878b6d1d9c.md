# 我的第一个失败的算法——经典的“加权作业调度”问题

> 原文：<https://blog.devgenius.io/my-first-failed-algorithm-the-classic-weighted-job-scheduling-problem-e1878b6d1d9c?source=collection_archive---------1----------------------->

![](img/40f170c179a89085a9374d60381be73e.png)

照片由[西格蒙德](https://unsplash.com/@sigmund?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

作为一名新的软件开发人员，参加编码面试肯定是求职过程中最令人生畏的方面之一。你必须把自己从正在做的项目中抽离出来，花一些时间拓展你解决问题的技能，理解数据结构和算法，只是为了有机会得到一份工作。解决问题可以带来很多乐趣，是这个领域许多人的快乐源泉，但是当你有一个潜在的机会，而这个机会取决于你开发最佳解决方案的能力时，压力可能是巨大的。

我的第一个编码挑战是在几个月前，当时我刚结束训练营，正试图理解 heaps 和 Dijkstra 的算法。这个职位是为新毕业的学生准备的，他们将被安排到这家社交媒体公司软件团队的一个轮岗项目中。我觉得它非常适合我的初级技能，很幸运我的简历被接受了。然后是编码挑战。我收到了一封电子邮件，其中包含在接下来的 3 天内完成自动测试的链接。前两天，我在网上浏览了一遍算法和数据结构课程，希望这些信息能帮助我解决问题。我没有投入我需要的时间来准备应对挑战。

一旦我开始测试，看到前两个问题并不复杂，我就放心了。他们涉及到使用二分搜索法和多个指针，这些技巧很容易掌握和理解。然后是第三个也是最后一个问题。这是我还没有遇到的经典算法的一个版本，即“加权作业调度”问题。问题是，给定一系列工作，每个工作包含开始时间、结束时间和利润，确定完成非重叠工作可以获得的最大利润。这个问题可以用许多不同的方法来解决。我看到它被描述为“两个数组，第一个数组 n 包含演示的开始时间，另一个数组 m 包含演示的长度，其中 n[i]与 m[i]相关，您的任务是找到可以进行的最大演示。输入可以是一个或两个数组，或者一个对象，包含更多带键的数组或对象。对于我的问题，输入可能如下所示:

```
jobs = [[1,2,15],[1,3,20],[2,4,40],[3,5,75],[4,5,50],[1,4,35]]
jobs[i][0] = start-time
jobs[i][1] = end-time
jobs[i][2] = profit
```

因此，由于没有练习过很多动态编程，我对这个问题的复杂性以及如何解决这个问题是天真的。给定第一个测试用例，我试图强行找到解决方案，但是随着输入的增长和变得无序，每个测试用例都破坏了我的解决方案。长话短说，我在挑战中失败了，在这个过程中没有进步。

这是一个寻找最优解的问题，直到我理解了如何使用制表，我才能够破解这个解。回头看看输入，如果我们在遍历数组时试图找到最优解，结果可能是这样的:

```
jobs = [[1,2,15]]
optimal solution is jobs[0] as its the only optionjobs = [[1,2,15],[1,3,20]]
optimal solution is jobs[1] as jobs[1][2] > jobs[0][2] and they conflictjobs = [[1,2,15],[1,3,20],[2,4,40]]
now [jobs[0],jobs[2]] is the optimal solution as they don't conflict, and generate a larger combined profit than jobs[1].jobs = [[1,2,15],[1,3,20],[2,4,40],[3,5,75]]
but now [jobs[1],jobs[3]] are optimal
```

正如您所看到的，每次我们考虑一个额外的输入，我们都必须将它放在我们已经看到的上下文中，并重新评估什么是最佳的，这在处理大型数据集时似乎是一项复杂的任务。当我们获取更多数据时，我们如何跟踪每个潜在的解决方案？答案是制表。

通过存储我们评估每一步的数据的最大最佳利润，我们能够在评估每一项工作时获取该利润并将其添加到我们的下一个兼容工作中。我们只需要一个数组和一个辅助函数。

在我们的主函数中，我们可以接受一个数组，但是在这个例子中，我硬编码了一个数组。然后，我们按照作业开始时间对数组进行排序。当开始时间相同时，我们按结束时间排序，当开始时间相同时，我们按利润排序。这也有助于理解函数是如何工作的。在这个排序函数之后，我们的数组看起来像这样:

```
[[0,1,20],[0,4,50],[1,2,20],[3,4,10],[3,5,100],[4,5,15]]
```

然后我们传入数组和它的长度。如果长度为零，我们知道没有利润，结束函数。然后，我们为制表创建“表格”数组，以存储我们的滚动最大利润。我们使长度为 n+1，因此我们可以在表[n]中存储和更新我们的回报最大利润。我们将表[0]和表[n]的利润设置为数组[0][2]，因为在这一点上，这是我们目前的最大利润，因为没有其他利润可以考虑。现在，因为我们已经考虑了我们的第一个任务，我们开始循环数组[1]的输入。在获取我们的值之后，我们运行我们的助手函数，并传入我们的作业数组、我们所在的索引和我们的最大利润表。这个助手函数“findPreviousJob”从我们刚才所在的索引开始，在我们的作业数组中向后循环，并找到结束时间与我们当前的作业不冲突的最近的作业。一旦找到该作业(jobs[j])，它将返回该作业的相关最大利润，table[j]，因为我们知道当前的作业利润可以添加到该数字中。如果没有以前的兼容作业，我们返回 0。如前所述，我们然后将返回的 0 或先前兼容的最大利润添加到存储当前作业利润的变量中，这为我们提供了包括作业[i]在内的最大最优利润。我们将这个最大利润存储在表[i]中，如果它大于我们的最佳利润，表[n]，我们也更新这个值。

同样，我们的表数组存储了他们各自工作的滚动最大利润，其中表[i]引用了直到并包括工作[i]可以获得的最大利润。

一旦我们完成了这个表，我们将有一个数组来存储考虑每项工作时可获得的最大利润，我们的最后一个值 table[n]将是该数组的最大值。有了 main()的这个给定输入，我们排序后的作业数组如下所示:

```
[
  [ 0, 1, 20 ],
  [ 0, 4, 50 ],
  [ 1, 2, 20 ],
  [ 3, 4, 10 ],
  [ 3, 5, 100 ],
  [ 4, 5, 15 ]
]
```

我们完成的表格如下所示:

```
[20, 50,  40, 50, 140, 65, 140]
```

最后，我们的最佳利润是表[n]是 140。

如您所见，虽然 65 是考虑最终作业时可获得的最大利润，但它并没有导致我们的最优解，因为它与之前的最大利润不兼容，这就是为什么跟踪每种可能性并在表[n]中存储最优解很重要。

制表和动态编程是强大的技能，能够识别这些技能何时可以实现是很重要的。如果你想重温一下这些概念，可以看看我的博客。

我很高兴我能够回去破解这个问题的解决方案。我希望我以一种易于理解的方式介绍了它，并且当遇到类似的问题时，你能够运用这些概念。