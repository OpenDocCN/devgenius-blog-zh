<html>
<head>
<title>Create Effective Test Code By Leveraging The Mockito Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 Mockito 框架创建有效的测试代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-effective-test-code-by-leveraging-the-mockito-framework-1f25ee74db82?source=collection_archive---------6-----------------------#2020-10-17">https://blog.devgenius.io/create-effective-test-code-by-leveraging-the-mockito-framework-1f25ee74db82?source=collection_archive---------6-----------------------#2020-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8710" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何隔离依赖其他服务进行测试的组件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/748de2bc4193a57d11dd81e6f8a81d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ss7-uN2jPH0Ua4glp8N8iA.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">由<a class="ae ko" href="https://www.pinterest.com/" rel="noopener ugc nofollow" target="_blank"> Pinterest </a>上的<a class="ae ko" href="https://www.pinterest.com/The_Purple_Dragon/_saved/" rel="noopener ugc nofollow" target="_blank"> spyro </a></figcaption></figure><p id="afc2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">测试是编码中非常重要的一部分，📈测试驱动开发是一种非常流行的测试方式，在实际编写任何实际代码之前，先编写测试代码😲。</p><p id="08b0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">测试应该是隔离一个服务的一个功能，并确保它工作✅.然而，当这个服务依赖于其他服务时，可能很难隔离那个部分并验证任何错误都来自那个服务😞。</p><p id="a27b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这是一个为什么我们需要嘲笑的例子</p><ul class=""><li id="4177" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">假设我们想测试服务 A，它将把一串字符串转换成一个句子。</li><li id="8f28" class="ll lm in kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">服务 A 通过调用服务 b 来获取这个列表。</li><li id="1c51" class="ll lm in kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">服务 B 中断并返回 null。</li><li id="6937" class="ll lm in kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">即使我们正确地实现了 A，我们对服务 A 的测试也会失败。</li></ul><p id="aef5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们如何解决这个问题？</p><p id="12cd" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">嘲讽！！！</p><p id="ee97" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">通过模仿服务 B，我们可以告诉我们的测试当服务 B 被调用时返回什么，而不是依赖于 B 的实际实现。</p><h1 id="dff3" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">个案研究</h1><p id="3fcb" class="pw-post-body-paragraph kp kq in kr b ks mr jo ku kv ms jr kx ky mt la lb lc mu le lf lg mv li lj lk ig bi translated">我们将测试服务 A，它打印出一个句子<em class="mw">“添加了{num1}和{num2}结果是{ sum }”</em>。服务 A 将调用📞服务 B 获取 num1 和 num2 的总和并放入句子中。</p><h2 id="55c7" class="mx ma in bd mb my mz dn mf na nb dp mj ky nc nd ml lc ne nf mn lg ng nh mp ni bi translated">服务 A</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e977" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">服务 A (MyService)依赖于服务 B(未完成)。我们称<em class="mw">为 unfinished.addNumbers(a，b) </em>。让我们看看我们现在已经在服务 B 中实现了什么。</p><h2 id="8837" class="mx ma in bd mb my mz dn mf na nb dp mj ky nc nd ml lc ne nf mn lg ng nh mp ni bi translated">服务 B</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e890" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">哦不！🙀看起来我们的服务 B 总是返回-1。那么当我们测试它的时候会发生什么呢？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/d36718475ada61f9270add78c1c68d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rXejhcKLorK7JiXnQH-tg.jpeg"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">通过<a class="ae ko" href="https://unsplash.com/@sctgrhm" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>上<a class="ae ko" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">的 Unsplash </a></figcaption></figure><h2 id="c727" class="mx ma in bd mb my mz dn mf na nb dp mj ky nc nd ml lc ne nf mn lg ng nh mp ni bi translated">测试(不带嘲讽)👎</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f711" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">毫不奇怪，我们得到这个…😕</p><pre class="kd ke kf kg gt nq nr ns nt aw nu bi"><span id="3c5d" class="mx ma in nr b gy nv nw l nx ny">org.junit.ComparisonFailure: <br/>Expected :Added 5 and 7 result is 12<br/>Actual :Added 5 and 7 result is -1</span></pre><p id="ea37" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这是意料之中的，因为 addNumbers()总是返回-1。但是即使懒惰的 dev😪 😴负责编码的 addNumbers()还没有完成，我们不应该被封锁🚫在我们的测试中。既然我们知道 addNumbers()的行为应该是怎样的，为什么我们不干脆<em class="mw">嘲弄一下呢？</em></p><h2 id="b826" class="mx ma in bd mb my mz dn mf na nb dp mj ky nc nd ml lc ne nf mn lg ng nh mp ni bi translated">属国</h2><p id="aa41" class="pw-post-body-paragraph kp kq in kr b ks mr jo ku kv ms jr kx ky mt la lb lc mu le lf lg mv li lj lk ig bi translated">为了嘲弄它，我们要用🥁🥁🥁·莫克托！！</p><pre class="kd ke kf kg gt nq nr ns nt aw nu bi"><span id="7a84" class="mx ma in nr b gy nv nw l nx ny">&lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-all --&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.mockito&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;<br/>    &lt;version&gt;1.10.19&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="1d44" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在您的 POM 文件中添加这个依赖项来开始。</p><h2 id="fb3e" class="mx ma in bd mb my mz dn mf na nb dp mj ky nc nd ml lc ne nf mn lg ng nh mp ni bi translated">测试(带嘲讽)👍</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="59e5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这个测试中…</p><ul class=""><li id="3c6c" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">我们在第 11–12 行声明了一个未完成类的模拟。</li><li id="71e2" class="ll lm in kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">然后，我们使用<em class="mw">mockito annotations . init mocks(this)</em>启动模拟，这将启动所有声明的模拟。并将我们的模拟注入到我们的 MyService 实例中(第 18–19 行)</li><li id="0b0f" class="ll lm in kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">最后，神奇的事情发生在第 28 行。我们告诉 Mockito，当这个未完成的实例使用存储在<em class="mw"> a (5) </em>和<em class="mw"> b (7) </em>中的值调用<em class="mw"> addNumbers() </em>时，它应该返回<em class="mw"> a + b (12) </em>。</li></ul><p id="8127" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">该测试运行成功！耶！</p><p id="b24c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">⚠️NOTE⚠️:如果你想测试当模拟服务失败时会发生什么，你也可以使用。然后抛出()而不是。然后返回()。</p><h1 id="88d7" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">何时嘲笑</h1><p id="76cf" class="pw-post-body-paragraph kp kq in kr b ks mr jo ku kv ms jr kx ky mt la lb lc mu le lf lg mv li lj lk ig bi translated">当你有一个注入的对象时，应该使用模仿💉通过构造函数依赖于其他对象。使用该构造函数，我们可以注入我们的模拟对象，并指定我们希望它们如何表现，这样我们就可以确保我们编写的测试只关注我们想要测试的单个对象。这样一来，被模仿的对象是否有缺陷、未实现或未测试都无关紧要，因为 or test 不会使用这些对象的实际实现！我们告诉它什么，它就会做什么😃！</p><p id="e7c6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果你对学习感兴趣📚关于 more 的更多信息，这里是到 Mockito 文档的链接。在那里，您可以了解更多关于验证方法调用和监视真实对象上的🕵️‍♀️的知识，以及其他一些很酷的事情。</p></div></div>    
</body>
</html>