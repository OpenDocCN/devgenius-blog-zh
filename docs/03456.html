<html>
<head>
<title>Best of Modern JavaScript — Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——迭代</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-iteration-fa72d04f4d09?source=collection_archive---------5-----------------------#2020-11-06">https://blog.devgenius.io/best-of-modern-javascript-iteration-fa72d04f4d09?source=collection_archive---------5-----------------------#2020-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/627ea8275c18e6aafeb286454f75e3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-8i7q2_OobCiEBi3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">rafael Souza 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="11d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 可迭代对象。</p><h1 id="cf7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迭代协议的速度</h1><p id="9ab3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在创建迭代协议时，已经考虑了它的速度。</p><p id="dedd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理小对象时，内存管理速度很快。</p><p id="f305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 引擎优化迭代，以便不分配中间对象。</p><h1 id="a315" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重用相同的可迭代对象</h1><p id="eecd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以多次使用 iterable。</p><p id="99dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8d5b" class="mn lc iq mj b gy mo mp l mq mr">const results = [];<br/>const iterator = [1, 2, 3][Symbol.iterator]();</span><span id="e314" class="mn lc iq mj b gy ms mp l mq mr">while (!(val = iterator.next()).done) {<br/>  results.push(val);<br/>}</span></pre><p id="dc32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从数组中获取迭代器。</p><p id="4779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用我们的<code class="fe mt mu mv mj b">while</code>循环调用它来得到结果。</p><h1 id="ffd9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">循环</h1><p id="e9d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript 迭代协议有规则可循。</p><p id="2e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">next</code>方法有一些规则。</p><p id="53c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要迭代器返回值<code class="fe mt mu mv mj b">next</code>，就返回一个带有<code class="fe mt mu mv mj b">value</code>属性的对象。</p><p id="1db2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe mt mu mv mj b">done</code>将会是<code class="fe mt mu mv mj b">false</code>。</p><p id="3dd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d14f" class="mn lc iq mj b gy mo mp l mq mr">{ value: x, done: false }</span></pre><p id="805a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迭代完最后一个值后，<code class="fe mt mu mv mj b">next</code>应该返回一个属性<code class="fe mt mu mv mj b">done</code>为<code class="fe mt mu mv mj b">true</code>的对象。</p><h1 id="2f92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">返回迭代器的 Iterables</h1><p id="3c6d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Iterables 可以返回新的迭代器或者返回相同的迭代器。</p><p id="1b28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们返回新的迭代器，那么每个迭代器都从开始返回值。</p><p id="1ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有一个数组，我们用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e22" class="mn lc iq mj b gy mo mp l mq mr">function getIterator(iterable) {<br/>  return iterable[Symbol.iterator]();<br/>}</span></pre><p id="112b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来获取迭代器，然后我们可以比较它们，看它们是否返回相同的迭代器。</p><p id="6295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="84e9" class="mn lc iq mj b gy mo mp l mq mr">const arr = ['a', 'b'];<br/>console.log(getIterator(arr) === getIterator(arr));</span></pre><p id="8461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么表达式将记录<code class="fe mt mu mv mj b">false</code>。</p><p id="6479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着即使数组是相同的，它们也返回相同的迭代器。</p><p id="6a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他的可迭代对象，比如生成器，每次都返回相同的迭代器。</p><p id="6f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有生成器对象，我们每次调用时都返回同一个生成器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5d14" class="mn lc iq mj b gy mo mp l mq mr">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>}</span><span id="bdde" class="mn lc iq mj b gy ms mp l mq mr">const gen = genFn();<br/>console.log(getIterator(gen) === getIterator(gen));</span></pre><p id="1587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">genFn</code>是一个生成器函数，返回一个生成器，</p><p id="8ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们从生成器中得到迭代器时，我们从生成器中得到迭代器，并将它们与表达式日志<code class="fe mt mu mv mj b">true</code>进行比较。</p><p id="5831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以同一个生成器有相同的迭代器。</p><p id="3acf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以多次迭代一个新的迭代器。</p><p id="9ced" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4b15" class="mn lc iq mj b gy mo mp l mq mr">const arr = ['foo', 'bar', 'baz'];</span><span id="b03a" class="mn lc iq mj b gy ms mp l mq mr">for (const a of arr) {<br/>  console.log(a);<br/>}</span><span id="2ebf" class="mn lc iq mj b gy ms mp l mq mr">for (const a of arr) {<br/>  console.log(a);<br/>}</span></pre><p id="fce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同一个数组中循环两次。</p><p id="02eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有一个发电机:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6700" class="mn lc iq mj b gy mo mp l mq mr">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>}<br/>const gen = genFn();</span><span id="ff35" class="mn lc iq mj b gy ms mp l mq mr">for (const a of gen) {<br/>  console.log(a);<br/>}</span><span id="4adb" class="mn lc iq mj b gy ms mp l mq mr">for (const a of gen) {<br/>  console.log(a);<br/>}</span></pre><p id="ece0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们有两个循环，我们也只循环一次。</p><h1 id="08e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭迭代器</h1><p id="101d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有两种方法可以关闭迭代器。</p><p id="7773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迭代器可以用穷举或关闭来关闭。</p><p id="0e15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">穷举是指迭代器返回所有可迭代的值。</p><p id="cb54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在迭代器函数中调用<code class="fe mt mu mv mj b">return</code>来完成关闭。</p><p id="b208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们呼叫<code class="fe mt mu mv mj b">return</code>时，那么<code class="fe mt mu mv mj b">next</code>就不会被呼叫。</p><p id="529c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">return</code>是可选方法。</p><p id="bb97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是所有迭代器都有。</p><p id="c60e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个<code class="fe mt mu mv mj b">return</code>调用的迭代器被称为可关闭的。</p><p id="244e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当迭代器没有用尽时，才应该调用<code class="fe mt mu mv mj b">return</code>。</p><p id="fe8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用<code class="fe mt mu mv mj b">break</code>、<code class="fe mt mu mv mj b">continue</code>、<code class="fe mt mu mv mj b">return</code>或<code class="fe mt mu mv mj b">throw</code>循环 for-of 循环，就会发生这种情况。</p><p id="69b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">return</code>应该产生一个返回<code class="fe mt mu mv mj b">{ done: true, value: x }</code>的对象。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/0a757fde2f750e6df8cc651a91c52893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pW9P_PdFaOuNruwn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@iamv_7?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦桑特</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="82f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b1c6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可迭代对象可以有不同的变化。</p><p id="2fc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以返回单个迭代器或多个实例。</p><p id="ef7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也可以是可关闭的。</p></div></div>    
</body>
</html>