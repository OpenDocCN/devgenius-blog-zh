<html>
<head>
<title>Snowpark vs Snowflake Connector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Snowpark vs 雪花连接器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/snowpark-vs-snowflake-connector-5c6baa44bde2?source=collection_archive---------0-----------------------#2022-08-31">https://blog.devgenius.io/snowpark-vs-snowflake-connector-5c6baa44bde2?source=collection_archive---------0-----------------------#2022-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi jr"><img src="../Images/d7f094599d516e683dc94ba4793ea898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*R0SPgZcS0Sl9IpxSKfkEcg.png"/></div></figure><p id="b2c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当 Snowpark API 可供使用时，一个明显的问题浮现在脑海中:-它与现有的雪花连接器/驱动程序有什么不同？虽然 Snowpark 和 Connectors 的唯一目的是相同的，即:-连接到雪花数据库并对数据进行操作，但这两者之间有一些重要的区别，如下所列。</p><p id="b593" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意:-为了更好地理解，我们将考虑<strong class="kb io">snow park For Python</strong>VS<strong class="kb io">snow flake Python Connector</strong>。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="26b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="kx">雪花蟒连接器:</em> </strong></p><ol class=""><li id="7a4b" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">它提供了一个开发<strong class="kb io"> Python 应用</strong>的接口，可以连接到雪花并执行 DDLs、DMLs 和 SQL 的标准操作。</li><li id="dc88" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">您可以从 python 程序建立与 SF 的连接，并将复杂的查询传递给雪花，雪花将在 SF 数据库中运行。</li><li id="f53e" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">这里要注意的关键点是:-将被利用的处理/Cpu 在雪花生态系统内，并且并行处理的好处将基于雪花仓库的大小来利用。</li><li id="0cfd" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">但是，一些开发人员习惯于数据框架风格的编程，对编写 SQL 查询不太适应。因此，他们可能希望将表数据发送到 Pandas DF，然后使用 Pandas dataframe 方法对数据进行复杂的计算。</li><li id="918d" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">Python Pandas DF 的挑战和处理边界来了，它将在非常大的数据集上表现不佳，因为处理不会发生在雪花生态系统内，而是发生在资源有限的客户机上。</li><li id="44e4" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">将大量数据从 SF 提取到 Pandas DF 也会导致资源争用，因为大量数据从 SF 移动到客户端系统。</li></ol><p id="7231" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Snowpark 来帮忙了！！！</p><p id="1f3f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="kx">雪域巨蟒:</em> </strong></p><ol class=""><li id="1442" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">Snowpark 库为查询和处理数据管道中的数据提供了一个直观的 API。使用这个库，您可以构建在雪花中处理数据的应用程序<strong class="kb io">,而不用将数据移动到您的应用程序代码运行的系统中</strong></li><li id="e440" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">Snowpark 的核心抽象是 Dataframe，它为开发人员提供了 DF 风格的编程结构，具有与 SQL 查询相同的性能。</li><li id="3642" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">Snowpark 操作是在服务器上延迟执行的，这减少了客户机和雪花数据库之间传输的数据量。除非您在 DF 上执行操作，否则不会有数据从 SF 传输到客户端系统。</li><li id="c2dd" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">最棒的是，它使用了<strong class="kb io">代码下推</strong>方法，将包括您最喜欢的 Python 函数(UDF)在内的所有代码都推送到服务器，并在 Snowflake 的计算引擎中本地运行，为您提供最佳性能。</li></ol></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="d0eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> IMP 注意:-用于 Python/Scala 的雪花连接器可能存在资源争用问题，但是 Spark 连接器性能更好，因为 Spark 集群本身是分布式的，并且能够非常快速地进行内存计算。但是你可以考虑转投 Snowpark，因为:- </strong></p><ul class=""><li id="fd7a" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw lm le lf lg bi translated">Snowpark 支持所有操作的下推，包括雪花 UDF。</li><li id="f0d4" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw lm le lf lg bi translated">数据不需要从 SF 拉到 Spark DF，计算可以在有数据的地方运行。</li><li id="1ce2" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw lm le lf lg bi translated">Snowpark <strong class="kb io">不需要雪花</strong>之外的独立集群进行计算。所有的计算都是在雪花内部完成的</li><li id="53b2" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw lm le lf lg bi translated">您可以在 Spark connector 和 Snowpark-Spark 之间运行一些样本负载，以决定是否可以从基于 Spark 的应用程序迁移到 Snowpark，这样就可以完全消除 Spark 集群维护。</li></ul><h1 id="4bc8" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">测试以确定事实(SQL 查询与 Snowpark DF 性能)</h1><p id="863c" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated"><strong class="kb io"> SQL 查询:- </strong></p><p id="4c1a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">数据库中触发的示例查询:-在 XS·WH 上运行</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/519087618a46755ff7d2efcde22fa944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2QxTe9JL0Rj_XH9E7bYVw.png"/></div></div></figure><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/d019d1baaf59d8e047ca7f55f8c09eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgBewfs37CU-wD_wfge3mg.png"/></div></div></figure><ol class=""><li id="9074" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">两个表的简单连接</li><li id="4b1f" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">3s 内完成</li><li id="bf80" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">处理了 600 万行</li><li id="e81f" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">第一次运行，不涉及缓存</li><li id="0728" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">扫描了 12 个分区</li></ol><p id="2c04" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">雪场 DF:- </strong></p><p id="3558" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">用 Python 编写的 Snowpark DF 程序示例:-在 XS·WH 上运行</p><pre class="js jt ju jv gt mw mx my mz aw na bi"><span id="fd6f" class="nb lo in mx b gy nc nd l ne nf">df1 = session.table('JHU_COVID_19')<br/>df2 = session.table('DEMOGRAPHICS')<br/><br/>df1.join(df2, df1.col("FIPS") == df2.col("FIPS")).select(df1["FIPS"].as_("FIPS"), "COUNTRY_REGION", df1["COUNTY"], "CASE_TYPE", "TOTAL_POPULATION","CASES").collect()</span></pre><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/5f376adfefc01b7c4a798a0689916115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdT1lYbA_ZHhsJPR_-6ZeA.png"/></div></div></figure><ol class=""><li id="0ad6" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">使用 Snowpark DF 简单连接两个表</li><li id="470e" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb io">在内部，它被转换成下面的 SQL </strong></li><li id="c399" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">2s 内完成</li><li id="5468" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">处理了 600 万行</li><li id="92e0" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">第一次运行，不涉及缓存</li><li id="4e12" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">扫描了 12 个分区</li></ol><p id="aa7e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">内部转换的 SQL</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/ac4340dd2e08a573c25d97a3748df22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZrqnT20CUFcOwL8FaaWQQ.png"/></div></div></figure><p id="612d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">最终要点:- </strong></p><p id="7de8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们了解到 Snowpark 提供了一种 DF 风格的编程结构，其中应用程序代码被推送到 SF 环境中，并在雪花中本地运行，并且<strong class="kb io">提供了与我们通过向雪花发出 SQL 查询</strong>所获得的相同的性能。</p><p id="147d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谢谢大家！快乐阅读</p></div></div>    
</body>
</html>