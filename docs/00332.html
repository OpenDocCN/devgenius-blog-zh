<html>
<head>
<title>Heaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">很</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/heaps-fff0f776a8f?source=collection_archive---------19-----------------------#2020-06-02">https://blog.devgenius.io/heaps-fff0f776a8f?source=collection_archive---------19-----------------------#2020-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3f68" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">遵循一些属性的专门的基于树的数据结构</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ef78e80257a660fdfac2a89f36775a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QUoO7wSGBhEVtb1Q"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">卢卡斯·布拉塞克在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cc63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在计算机科学中，堆是一种专门的基于树的数据结构，它遵循一些导致堆形成的属性。在堆中，所有的节点都是按特定的顺序排列的，可以是升序，也可以是降序，这就形成了两种类型的堆。堆本质上是一种称为优先级队列的抽象数据类型的最充分的实现，事实上，优先级队列通常被称为堆，而不管它们是如何实现的。</p><p id="fbc6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果 X 是 Y 的父节点，那么 X 的值遵循关于 Y 的值的特定顺序，并且在整个树中将遵循相同的顺序。下图也对此进行了解释。</p><p id="3639" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">堆中节点的最大子节点数取决于堆的类型。然而，在更常用的堆类型中，一个节点最多有两个子节点，这就是所谓的二进制堆。</p><p id="7690" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在二进制堆中，如果堆是具有 N 个节点的完全二叉树，那么它具有最小的可能高度，即 log N。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/70f48ed142239d6bfdb887b6c342cd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j2C_aUQtzS-Pr690.jpg"/></div></div></figure><p id="f271" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你已经对什么是堆有了一个基本的概念，让我们来谈谈导致堆形成的三个重要属性。</p><ol class=""><li id="33a0" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">二叉树:树应该是一个确定的二叉树，也就是说，它应该有 0 个子节点或 1 个子节点或最多 2 个子节点。</li><li id="bd3a" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">完全二叉树:除了树是二叉树之外，它还应该遵循完全二叉树的属性，即除了树的最后一层，所有层都应该完全填充。在最后一层，从左到右填充节点，填充空节点，使树成为二叉树。</li><li id="d1b0" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">堆顺序属性:这意味着树应该遵循它们被填充的节点顺序，因为它们应该在整个树中以节点值的升序或降序排列(下面将详细解释)</li></ol><p id="5c6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在第三点中谈到的树，现在我们要讨论一下。堆树基本上有两种类型:</p><ol class=""><li id="9024" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><strong class="kv io"> Max Heap </strong>:在 Max Heap 中，出现在根节点的值必须是树的所有节点中最大的，同样，一个子树中的父节点应该是所有树中最大的，依此类推。基本上，值的比较是在父节点和它的子节点之间完成的，如果所有的父节点都大于它的子节点，那么它最终将是一个最大堆。</li><li id="43c4" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">最小堆</strong>:在最小堆中，出现在根节点的键必须小于堆树中出现的所有节点。如果从节点值的排列来比较，Min heap 正好与 Max Heap 相反。在这种情况下，也对父节点和子节点的值进行比较，唯一的区别是父节点的值应该小于子节点的值，类似地，如果所有节点都遵循该属性，将导致形成最小堆。</li></ol><p id="03d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了更好的理解，你可以参考下面的图片。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi me"><img src="../Images/022e4a5c45191459e44557623927a4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*yR24F8ZhNMRmaaOk2m1PHg.png"/></div></figure><p id="d45b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们讨论一下，如果给我们一个数组，我们想把它转换成一个堆，我们该怎么做:</p><p id="cd41" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们假设，如果我们在数组 Arr 中的索引 I 处保存一个元素，那么它的父元素将保存在索引 i/2 处(除非它是根，因为根没有父元素)并且可以通过 Arr[i/2]获得，它的左子元素可以通过 Arr[2∫I]获得，它的右子元素可以通过 Arr[2∫I+1]访问。根的索引在数组中是 1。</p><p id="56bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">借助下面给出的图片，可以更好地理解这一点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/47886488e9b8360ddad0ed0ab1963a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VE3OHZPT3VGdPD5V.jpg"/></div></div></figure><p id="915b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们研究一下如何将我们的树转换成一个堆，这个堆具有我们前面讨论过的所有属性</p><ol class=""><li id="bc3e" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><strong class="kv io"> Upheapify() </strong> —该函数在堆中添加节点的操作中执行，因为在我们在堆中添加节点后，树不再是堆，然后我们使用 Upheapify 使其再次成为堆。upheapify 函数不言自明，如果您仍然不明白，可以查看参考资料。代码是通用的数据类型，你可以根据自己的需要修改它。</li></ol><p id="b95a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">添加一个节点</strong>的过程代码片段</p><p id="3f39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">public void add(T element){<br/>this . data . add(element)；<br/>this . upheapify(this . data . size()-1)；<br/> }</p><p id="9414" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">private void upheapify(int ci){<br/>if(ci = = 0){<br/>return；<br/>}<br/><br/>int pi =(ci-1)/2；<br/>如果(！isLarger(pi，ci)) { <br/> this.swap(pi，ci)；<br/>this . upheapify(pi)；<br/>}<br/>}<br/>}<br/><br/>私有 void swap(int pi，int ci){<br/>T ithitem = this . data . get(pi)；<br/>T JT hitem = this . data . get(ci)；<br/> <br/> this.data.set(pi，jthitem)；<br/> this.data.set(ci，ithitem)；<br/> } <br/> <br/>私有布尔 isLarger(int pi，int ci){<br/>T ithitem = this . data . get(pi)；//parent<br/>T JT hitem = this . data . get(ci)；//child<br/><br/>if(this . ismin){<br/>return ithitem . compare to(jthitem)&lt;0；<br/>} else {<br/>return ithitem . compare to(JT hitem)&gt;0；<br/> } <br/> }</p><p id="786f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.<strong class="kv io"> DownHeapify: </strong>这个函数在我们从树中删除一个节点的过程中使用，类似于 add。当我们从树中删除一个节点时，我们也扰乱了堆的属性，所以为了重新获得正确的堆，我们应用 DownHeapify 函数。下面也给出了它的代码，请仔细阅读它的不言自明的部分，如果你想了解更多，你可以去查阅参考资料。代码是通用的数据类型，你可以根据自己的需要修改它。</p><p id="db00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">删除一个节点过程的代码片段</strong></p><p id="51cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">public T remove(){<br/>T RV = this . data . get(0)；<br/> this.swap(0，this . data . size()-1)；<br/>this . data . remove(this . data . size()-1)；<br/>this . downheapify(0)；<br/>返回房车；<br/> } <br/> <br/>私有 void downheapify(int pi){<br/>int LCI = 2 * pi+1；<br/>int rci = 2 * pi+2；<br/>int mi = pi；<br/><br/>if(LCI&lt;this . data . size()&amp;&amp;this . is larger(LCI，mi)){<br/>mi = LCI；<br/>}<br/><br/>if(rci&lt;this . data . size()&amp;&amp;this . is larger(rci，mi)){<br/>mi = rci；<br/> } <br/> <br/>如果(mi！=pi) { <br/> this.swap(mi，pi)；<br/>this . downheapify(mi)；<br/> } <br/> <br/> <br/> }</p><p id="252d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望你已经理解了堆的概念。你可以尝试更多的问题，如寻找堆的最大元素，堆的最小元素，堆中元素的数量来测试你的知识。</p><p id="7862" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你觉得这个博客有任何帮助，请一定要为它鼓掌。您还可以在 Medium 上关注我，并在我的社交媒体手柄上关注我，以获得更多类似这样的信息。</p><p id="8d2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">参考资料:</p><div class="mf mg gp gr mh mi"><a href="http://pages.cs.wisc.edu/~mcw/cs367/lectures/heaps.html" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd io gy z fp mn fr fs mo fu fw im bi translated">二进制堆和优先级队列</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">该树是一个完整的二叉树:每一层都包含它的全部子节点，除了最深的一层，它…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">pages.cs.wisc.edu</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw km mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://www.hackerearth.com/practice/data-structures/trees/heapspriority-queues/tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd io gy z fp mn fr fs mo fu fw im bi translated">堆/优先级队列教程和注释|数据结构|黑客地球</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">堆是一种基于树的数据结构，其中树的所有节点都按照特定的顺序排列。例如，如果…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.hackerearth.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw km mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://www.geeksforgeeks.org/heap-data-structure/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd io gy z fp mn fr fs mo fu fw im bi translated">堆数据结构— GeeksforGeeks</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">极客的计算机科学门户。它包含写得很好，很好的思想和很好的解释计算机科学和…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="mr l"><div class="my l mt mu mv mr mw km mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd io gy z fp mn fr fs mo fu fw im bi translated">堆(数据结构)</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">在计算机科学中，堆是一种专门的基于树的数据结构，本质上是一种几乎完整的树…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">en.wikipedia.org</p></div></div><div class="mr l"><div class="mz l mt mu mv mr mw km mi"/></div></div></a></div></div></div>    
</body>
</html>