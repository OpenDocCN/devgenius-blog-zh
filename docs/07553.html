<html>
<head>
<title>5 Habits Java Experts Like to See</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 专家喜欢看到的 5 个习惯</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-habits-java-experts-like-to-see-67d963dd3689?source=collection_archive---------2-----------------------#2022-04-05">https://blog.devgenius.io/5-habits-java-experts-like-to-see-67d963dd3689?source=collection_archive---------2-----------------------#2022-04-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="10cd" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><strong class="ak">经验丰富的 Java 开发人员喜欢在公关中看到这些实践</strong></h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/ae5dfc915edc6105bab273ee6321e27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HoJalMjRbiOOtQ_J.png"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>拍摄，来自<a class="ae ks" href="https://www.pexels.com/photo/man-in-orange-blazer-using-black-tablet-computer-5439455/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a>——作者编辑</figcaption></figure><p id="5fa1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">大多数 Java 专家喜欢看到年轻开发人员的这些实践。</p><p id="53df" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><a class="ae ks" href="https://zivce.gumroad.com/l/become-high-quality-code-reviewer" rel="noopener ugc nofollow" target="_blank">我自己看了很多 pr</a>之后，确实喜欢看接下来的习惯。你会同意，其他人也喜欢这些做法。其中大部分提高了 Java 代码的可读性和性能，还有一些减少了冗长性。</p><p id="2115" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们看看专家们喜欢从年轻的开发人员那里看到什么实践。</p><h1 id="e9c2" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">1.尽可能使用方法引用</h1><p id="eaf2" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">即便如此，大多数开发者还是创造了大 lambdas。</p><p id="2f54" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">小型 lambdas 更容易阅读，并且<a class="ae ks" href="https://medium.com/javarevisited/experienced-developers-use-these-quirks-to-create-better-java-lambdas-4ae656148274" rel="noopener">具有更好的性能</a>。如果可能的话，在 lambdas 中放置尽可能少的行。最好使用方法引用，如果可能的话，使用未绑定的方法引用。</p><p id="6d9e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你看到类似的 lambda 代码了吗？提取这些，并使用方法引用。</p><p id="6fc1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">最好使用未绑定的方法引用，<code class="fe mn mo mp mq b">Class::yourMethod</code>。由于有一个绑定的小性能打击，<code class="fe mn mo mp mq b">Instance::yourMethod</code>。同样，方法引用的可读性比重复的 lambda 代码好。</p><h1 id="5ca4" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">2.你翻译异常</h1><p id="c572" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">阅读更多关于<a class="ae ks" href="https://blog.maskalik.com/blog/2018/09/12/best-practices-for-exceptions-in-java/" rel="noopener ugc nofollow" target="_blank">异常翻译</a>的信息。</p><p id="28a2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是<a class="ae ks" href="https://web.archive.org/web/20060407124638/http://www.artima.com/intv/solid3.html" rel="noopener ugc nofollow" target="_blank">詹姆斯·高斯林对异常翻译</a>的评论:<br/> <em class="lp">这就是异常翻译能派上用场的地方。假设你有一个读取数据库的软件。在它内心深处的某个地方，它可能会得到一个</em> <code class="fe mn mo mp mq b"><em class="lp">MalformedURLException</em></code> <em class="lp">。把那个向外宣传成</em> <code class="fe mn mo mp mq b"><em class="lp">MalformedURLException</em></code> <em class="lp">是没有意义的。</em></p><p id="5395" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">最好想想什么样的异常是接口的一部分。而不是底层方法是如何实现的。在 Java 异常机制中，您可以将 cause 包装在异常中。于是你创建了一个新的</em> <code class="fe mn mo mp mq b"><em class="lp">IOException</em></code> <em class="lp">，你把它的起因设置为这个</em> <code class="fe mn mo mp mq b"><em class="lp">MalformedURLException</em></code> <em class="lp">。你把它们捆在一起。这非常有效。</em></p><p id="013c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">没有人喜欢看到这段代码:</p><pre class="kh ki kj kk gu mr mq ms mt aw mu bi"><span id="5949" class="mv lr ir mq b gz mw mx l my mz">throw ex;</span></pre><p id="721c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">使用这种方法会丢失堆栈跟踪。甚至只有<code class="fe mn mo mp mq b">throw</code>也不是一条好路可走。</p><p id="c270" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">更好的方法是重新抛出您的自定义异常。如果你不知道如何在一个较低的层次上处理它，翻译成一个较高层次的异常。</p><pre class="kh ki kj kk gu mr mq ms mt aw mu bi"><span id="e748" class="mv lr ir mq b gz mw mx l my mz">throw new CustomException(ex);</span></pre><h1 id="3141" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">3.你用枚举来表示常数</h1><p id="3cfc" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">你可以在一些代码库中看到只有常量的接口。即便如此，它们也是一种反模式。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="na nb l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://www.govnokod.ru/17104" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="79c7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">枚举是常量的更好选择。</em></p><p id="e07e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">您可以向枚举添加自定义方法。</em>或者迭代值，或者<a class="ae ks" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks#dont-iterate-over-enumvalues" rel="noopener ugc nofollow" target="_blank">缓存它们以提高性能</a>。并在<a class="ae ks" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks" rel="noopener ugc nofollow" target="_blank">适当的枚举结构</a>中使用它们。</p><p id="9a48" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">我喜欢枚举的另一点是凝聚力。他们把相似的常数包装在一起。而在界面中，它会变得混乱。这里有一个例子:</em></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="na nb l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://stackoverflow.com/a/14419212/5999670" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="4d5c" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">4.您避免了异常反模式</h1><p id="5f4d" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">我最不喜欢的就是异常吞咽和空抓。</em> </strong></p><p id="406b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">还有其他的，比如:</p><ul class=""><li id="df1f" class="nc nd ir kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">日志重掷</li><li id="b651" class="nc nd ir kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">暴露安全细节</li><li id="3165" class="nc nd ir kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">将检查的异常转换为未检查的异常。</li></ul><p id="f2f4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你应该处理异常或者翻译异常。你不能两样都做。 </p><p id="b9e0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">此外，您不能转换为运行时异常。您首先需要理解检查异常和未检查异常之间的区别。</p><p id="ecfd" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">“对可恢复条件使用检查异常，对编程错误使用运行时异常。”—约书亚·布洛赫</em></p><h1 id="a4f3" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">5.需要的时候你用<code class="fe mn mo mp mq b">varargs</code></h1><p id="cc37" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">尽管在某些情况下更清洁，但这可能会造成问题。</p><p id="bf37" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">例如当<code class="fe mn mo mp mq b">varargs</code>与仿制药混合使用时。Varargs 创建了一个遭受未检查强制转换的数组。所以确保类型安全是你的工作。</p><pre class="kh ki kj kk gu mr mq ms mt aw mu bi"><span id="ed72" class="mv lr ir mq b gz mw mx l my mz">// Joshua Bloch - Item 32 - snippet around type safety</span><span id="cbc6" class="mv lr ir mq b gz nq mx l my mz">**// Mixing generics and varargs can violate type safety!**<br/>static void dangerous(**List&lt;String&gt;... stringLists**) {<br/>    List&lt;Integer&gt; intList = List.of(42);<br/>    Object[] objects = stringLists;<br/>    objects[0] = intList;             **// Heap pollution**<br/>    String s = stringLists[0].get(0); **// ClassCastException**<br/>}</span></pre><p id="da75" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">当你需要变量 arity，或者传入一个参数数组时，你应该使用<code class="fe mn mo mp mq b">varargs</code>。尽管它创建了一个<code class="fe mn mo mp mq b">Object[]</code>,但它更简洁，可读性更好。希望在将来，这个数组会被转换成一个不可变的列表。</p><h1 id="cce5" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">外卖食品</h1><p id="492e" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated"><em class="lp">枚举实际上是创建常数的工具。</em></p><p id="81b1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这是有原因的。它们可读性强，性能好，简洁明了。因此，年轻的开发人员没有必要忽视它们。</p><p id="9b94" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">此外，年轻的开发人员不会在异常上投入时间。</em></p><p id="7196" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我不喜欢创建例外镇，但是连一些基础知识都缺乏。正如我所提到的，专家们希望看到的是了解检查异常和未检查异常之间的区别。</p></div></div>    
</body>
</html>