<html>
<head>
<title>Welcome to Rust Memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欢迎来到信任记忆</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/welcome-to-rust-memory-a21e64c6e07c?source=collection_archive---------3-----------------------#2021-04-05">https://blog.devgenius.io/welcome-to-rust-memory-a21e64c6e07c?source=collection_archive---------3-----------------------#2021-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="c744" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Rust 中的内存管理</h1><p id="51be" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所有权是 Rust 最独特的特性，它使 Rust 能够在不需要垃圾收集器的情况下保证内存安全。因此，理解所有权在 Rust 中是如何工作的非常重要</p><h1 id="5b94" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">所有权</strong></h1><p id="8425" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">所有权</em>是 Rust 管理内存的方式。它是编译器在编译时检查的一组规则，这些规则不会降低程序运行的速度。</p><h1 id="2ea7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">堆栈和堆</h1><ul class=""><li id="fd70" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated">堆栈和堆都是程序在运行时可用的内存的一部分</li><li id="58dd" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">在编译时，堆栈上的数据必须具有已知的固定大小</li><li id="18df" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">编译时大小未知或大小可能改变的数据必须存储在堆中</li><li id="6d09" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">操作方面(分配、访问)堆更昂贵(更慢)</li><li id="84b5" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">堆还需要簿记(代码的什么部分使用什么数据，重复数据删除，清理未使用的数据)，这种所有权地址</li></ul><p id="482e" class="pw-post-body-paragraph ki kj in kk b kl lv kn ko kp lw kr ks kt lx kv kw kx ly kz la lb lz ld le lf ig bi translated"><strong class="kk io">所有权规则<br/> </strong>首先，我们来看看所有权规则。当我们通过举例说明这些规则时，请记住这些规则:</p><ul class=""><li id="0676" class="lh li in kk b kl lv kp lw kt ma kx mb lb mc lf lm ln lo lp bi translated">Rust 中的每个值都有一个变量，称为它的所有者。</li><li id="9325" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">一次只能有一个所有者。</li><li id="bfa7" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">当所有者超出范围时，该值将被丢弃。</li></ul><h1 id="5e91" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">变量作用域</h1><p id="16ee" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">范围</em>是项目有效的程序范围。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2c19" class="mm jl in mi b gy mn mo l mp mq">{                      // s is not valid here, it’s not yet declared<br/>    let s = "hello";   // s is valid from this point forward</span><span id="4150" class="mm jl in mi b gy mr mo l mp mq">    // do stuff with s<br/>}                      // this scope is now over, and s is no longer valid</span></pre><h1 id="a333" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><code class="fe ms mt mu mi b">String</code>型</h1><ul class=""><li id="e5fc" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated">字符串文字是不可变的，它们的值在编译时必须是已知的</li><li id="c40e" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated"><code class="fe ms mt mu mi b">String</code>另一方面，类型是在堆上分配的</li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0eec" class="mm jl in mi b gy mn mo l mp mq">// create a `String` from a literal:<br/>let s = String::from("hello");<br/>// mutate `String` (append to it):<br/>s.push_str(", world!");</span></pre><h1 id="55fe" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">内存和分配</h1><ul class=""><li id="db4c" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated">Rust 既不使用显式的<code class="fe ms mt mu mi b">free</code>(将内存返回给操作系统)，也不使用垃圾收集(GC)</li><li id="6ca6" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">相反，一旦所有者超出范围，内存就会自动返回</li><li id="cae2" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">然后调用特殊功能<code class="fe ms mt mu mi b">drop</code></li></ul><h1 id="8afe" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">移动</h1><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ea4f" class="mm jl in mi b gy mn mo l mp mq">// `s1` is *moved* which makes a shallow copy of and then invalidates it<br/>let s1 = String::from("hello");<br/>let s2 = s1;<br/>// s1 is not valid anymore</span></pre><h1 id="6d83" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">克隆</h1><ul class=""><li id="1e2e" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated">深层拷贝</li><li id="dfd2" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">更贵</li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b812" class="mm jl in mi b gy mn mo l mp mq">let s1 = String::from("hello");<br/>let s2 = s1.clone();</span><span id="0a29" class="mm jl in mi b gy mr mo l mp mq">// both, `s1` and `s2` are valid<br/>println!("s1 = {}, s2 = {}", s1, s2);</span></pre><h1 id="6681" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">复制(仅堆栈)</h1><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f044" class="mm jl in mi b gy mn mo l mp mq">// make copy of `x`<br/>let x = 5;<br/>let y = x;</span></pre><ul class=""><li id="8f52" class="lh li in kk b kl lv kp lw kt ma kx mb lb mc lf lm ln lo lp bi translated">如果值完全存储在堆栈中，并且具有<code class="fe ms mt mu mi b">Copy</code>特征，它将被复制而不是移动，也就是说，旧变量在被赋值给新变量后仍然可用</li><li id="57cf" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated"><code class="fe ms mt mu mi b">Copy</code>和<code class="fe ms mt mu mi b">Drop</code>特征是互斥的</li><li id="aead" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">一些具有<code class="fe ms mt mu mi b">Copy</code>特质的类型有:</li><li id="97ad" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">所有整数和浮点类型，例如<code class="fe ms mt mu mi b">u32</code>和<code class="fe ms mt mu mi b">f64</code></li><li id="9a03" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated"><code class="fe ms mt mu mi b">bool</code></li><li id="731e" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated"><code class="fe ms mt mu mi b">char</code></li><li id="727e" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">元组，如果它们只包含<code class="fe ms mt mu mi b">Copy</code>的类型，例如<code class="fe ms mt mu mi b">(i32, i32)</code>而不是<code class="fe ms mt mu mi b">(i32, String)</code></li></ul><h1 id="b8da" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">功能</h1><p id="ad4f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">与给变量赋值类似，将变量传递给函数会复制或移动它。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b901" class="mm jl in mi b gy mn mo l mp mq">fn main() {<br/>    let s = String::from("hello");<br/>    takes_ownership(s);<br/>    // `s` is not valid anymore, its value has been moved into function</span><span id="16d0" class="mm jl in mi b gy mr mo l mp mq">    let x = 5;<br/>    makes_copy(x);<br/>    // `x` is still valid<br/>}</span><span id="ef70" class="mm jl in mi b gy mr mo l mp mq">fn takes_ownership(some_string: String) {<br/>    println!("{}", some_string);<br/>}</span><span id="d8e4" class="mm jl in mi b gy mr mo l mp mq">fn makes_copy(some_integer: i32) {<br/>    println!("{}", some_integer);<br/>}</span></pre><h1 id="8a38" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">返回值和范围</h1><p id="900f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">返回值也可以转移所有权。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e552" class="mm jl in mi b gy mn mo l mp mq">fn main() {<br/>    let s1 = gives_ownership();</span><span id="7f48" class="mm jl in mi b gy mr mo l mp mq">    let s2 = String::from("hello");<br/>    let s3 = takes_and_gives_back(s2);<br/>}</span><span id="1128" class="mm jl in mi b gy mr mo l mp mq">fn gives_ownership() -&gt; String {<br/>    let some_string = String::from("hello");<br/>    some_string<br/>}</span><span id="525a" class="mm jl in mi b gy mr mo l mp mq">fn takes_and_gives_back(a_string: String) -&gt; String {<br/>    a_string<br/>    // note: if we would want to return additional data, we could use tuple. e.g.<br/>    // let length = a_string.len();<br/>    // (a_string, length)<br/>}</span></pre><p id="a8e9" class="pw-post-body-paragraph ki kj in kk b kl lv kn ko kp lw kr ks kt lx kv kw kx ly kz la lb lz ld le lf ig bi translated">如果我们想让函数使用一个值，但不获取所有权，而不是将它传递回来，我们可以使用<em class="lg">引用</em>。</p><h1 id="1338" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考和借用</h1><ul class=""><li id="2e0c" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated">可以传递一个<em class="lg">引用</em>，而不是像上一个例子那样从一个函数传回一个值</li><li id="2b71" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">这个引用可以用来代替获取所有权</li><li id="16bb" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">将引用作为函数参数称为<em class="lg">借用</em></li><li id="b6f1" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">正如变量一样，默认情况下引用是不可变的</li><li id="e880" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated"><code class="fe ms mt mu mi b">&amp;</code>:引用运算符，<code class="fe ms mt mu mi b">*</code>:解引用运算符</li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="156c" class="mm jl in mi b gy mn mo l mp mq">fn main() {<br/>    let s1 = String::from("hello");<br/>    let len = calculate_length(&amp;s1);<br/>    println!("The length of '{}' is {}.", s1, len);<br/>}</span><span id="9ac4" class="mm jl in mi b gy mr mo l mp mq">fn calculate_length(s: &amp;String) -&gt; usize {<br/>    s.len()<br/>}</span></pre><h1 id="1fd3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">可变引用</h1><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f939" class="mm jl in mi b gy mn mo l mp mq">fn main() {<br/>    let mut s = String::from("hello");<br/>    change(&amp;mut s);<br/>}</span><span id="4ae3" class="mm jl in mi b gy mr mo l mp mq">fn change(some_string: &amp;mut String) {<br/>    some_string.push_str(", world");<br/>}</span></pre><ul class=""><li id="d16e" class="lh li in kk b kl lv kp lw kt ma kx mb lb mc lf lm ln lo lp bi translated">在特定的范围内，对特定值的可变引用可以有且只能有一个</li><li id="8f5b" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">这可以防止编译时的数据竞争</li><li id="ea26" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">有不可变引用时不能有可变引用</li><li id="1362" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">不可变的值可能会改变</li><li id="bca2" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">引用的范围从它被引入的地方开始，一直延续到它的最后一次使用</li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="bdaa" class="mm jl in mi b gy mn mo l mp mq">let mut s = String::from("hello");</span><span id="4207" class="mm jl in mi b gy mr mo l mp mq">// declare two immutable references<br/>let r1 = &amp;s;<br/>let r2 = &amp;s;<br/>println!("{} and {}", r1, r2);</span><span id="ae17" class="mm jl in mi b gy mr mo l mp mq">// scope of s1 and s2 have ended (they are not used anymore),<br/>// we can now declare an immutable reference<br/>let r3 = &amp;mut s;<br/>println!("{}", r3);</span></pre><h1 id="6ea7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">悬空引用</h1><ul class=""><li id="b1ff" class="lh li in kk b kl km kp kq kt lj kx lk lb ll lf lm ln lo lp bi translated"><em class="lg">悬空指针</em>:引用已经释放的内存的指针</li><li id="c842" class="lh li in kk b kl lq kp lr kt ls kx lt lb lu lf lm ln lo lp bi translated">Rust 编译器防止这种情况，因为它确保数据不会在对数据的引用超出范围之前超出范围</li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a4e9" class="mm jl in mi b gy mn mo l mp mq">fn dangle() -&gt; &amp;String { // returns *reference* to a String<br/>    let s = String::from("hello");<br/>    &amp;s // return reference to new String `s`<br/>} // Here, s goes out of scope, and is dropped. Its memory goes away.<br/>  // Error</span></pre><p id="7e55" class="pw-post-body-paragraph ki kj in kk b kl lv kn ko kp lw kr ks kt lx kv kw kx ly kz la lb lz ld le lf ig bi translated">下一次生锈寿命</p></div></div>    
</body>
</html>