<html>
<head>
<title>Anchor scrolling in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">锚滚动角度</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/anchor-scrolling-in-angular-47ed1f393c77?source=collection_archive---------2-----------------------#2022-11-22">https://blog.devgenius.io/anchor-scrolling-in-angular-47ed1f393c77?source=collection_archive---------2-----------------------#2022-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="02ce" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么它不起作用？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/785e4e133abea25d3e81bd7497dc797f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKH1N77qdf3zZMJ5TnBsJg.png"/></div></div></figure><p id="46e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果当 URL 中包含一个片段时，您曾经遇到过将正文滚动到正确位置的问题，那么请不要离开。</p><h1 id="cf6a" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">水疗中心的主播卡嗒声。</h1><p id="18b2" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">片段是 URL 的<code class="fe mh mi mj mk b">hash</code>属性，通常指向页面上的一个锚点。锚点击在网络上工作需要以下基本知识:</p><p id="edaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">&lt;a href="#anchor"&gt;Click me&lt;/a&gt;</code></p><p id="5a90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在另一个地方</p><p id="40f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">&lt;element id="anchor"&gt;&lt;/element&gt;</code></p><p id="7fe3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在页面加载时工作，不需要任何其他东西。在 Angular 中，值得一提的是，链接应该是具有<code class="fe mh mi mj mk b">fragment</code>属性的路由器链接，就像这样:</p><p id="4d4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">&lt;a routerLink="." fragment="anchor"&gt;Click me&lt;/a&gt;</code></p><p id="8ee1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据<a class="ae ml" href="https://angular.io/api/router/InMemoryScrollingOptions#anchorScrolling" rel="noopener ugc nofollow" target="_blank">角度文档</a>，我们需要将根路由器的<code class="fe mh mi mj mk b">anchorScrolling</code>属性设置为<code class="fe mh mi mj mk b">enabled</code>来进行滚动。但这并不准确。</p><p id="0d2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么这个属性到底是做什么的呢？当用<code class="fe mh mi mj mk b">anchor</code>捕捉到滚动事件时，调用<a class="ae ml" href="https://github.com/angular/angular/blob/b653ee340e3361b484837b028bdd7c4f91a46f85/packages/common/src/viewport_scroller.ts#L119" rel="noopener ugc nofollow" target="_blank">函数</a> <code class="fe mh mi mj mk b">scrollToAnchor</code>。让我们深入研究一下这个函数。该函数进行一些检查，找到元素，然后<a class="ae ml" href="https://github.com/angular/angular/blob/b653ee340e3361b484837b028bdd7c4f91a46f85/packages/common/src/viewport_scroller.ts#L156" rel="noopener ugc nofollow" target="_blank">得到坐标</a>，如下所示:</p><blockquote class="mm mn mo"><p id="60a8" class="ko kp mp kq b kr ks jo kt ku kv jr kw mq ky kz la mr lc ld le ms lg lh li lj ig bi translated">看，Medium 终于采用了代码着色！</p></blockquote><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="4b10" class="mx ll in mk b be my mz l na nb">// Angular internal function common library<br/>scrollToElement(el) {<br/>  const rect = el.getBoundingClientRect();<br/>  const left = rect.left + this.window.pageXOffset;<br/>  const top = rect.top + this.window.pageYOffset;<br/>  const offset = this.offset();<br/>  this.window.scrollTo(left - offset[0], top - offset[1]);<br/>}</span></pre><p id="de66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">那么，为什么——即使它找到了元素——返回值都是零呢？</strong></p><p id="fc68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果元素在主组件之外(因此比任何子组件加载得都快),它可能会被找到，但是它会出现在最上面。所以零是正确的读数。然而，如果它在子组件中，返回的滚动对象可能是<code class="fe mh mi mj mk b">null</code>，如果它还没有被加载的话。</p><p id="831f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们必须等待客户端加载。但是需要多久呢？</p><p id="5e28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我分享一下<code class="fe mh mi mj mk b">RouterModule</code> <a class="ae ml" href="https://github.com/angular/angular/blob/main/packages/router/src/router_scroller.ts#L67" rel="noopener ugc nofollow" target="_blank">角度代码</a>中的滚动事件“消费者”函数，以供参考，因为我们将使用我们自己的订阅者覆盖它:</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="270d" class="mx ll in mk b be my mz l na nb">// Angular internal code in router module library<br/>private consumeScrollEvents() {<br/>  return this.router.events.subscribe(e =&gt; {<br/>    if (!(e instanceof Scroll)) return;<br/>    // a popstate event. The pop state event will always ignore anchor scrollin<br/>    if (e.position) {<br/>      if (this.options.scrollPositionRestoration === 'top') {<br/>        this.viewportScroller.scrollToPosition([0, 0]);<br/>      } else if (this.options.scrollPositionRestoration === 'enabled') {<br/>        this.viewportScroller.scrollToPosition(e.position);<br/>      }<br/>      // imperative navigation "forward"<br/>    } else {<br/>      if (e.anchor &amp;&amp; this.options.anchorScrolling === 'enabled') {<br/>      /*********** here is where things happen ************/<br/>        this.viewportScroller.scrollToAnchor(e.anchor);<br/>      } else if (this.options.scrollPositionRestoration !== 'disabled') {<br/>        this.viewportScroller.scrollToPosition([0, 0]);<br/>      }<br/>    }<br/>  });<br/>}</span></pre><h1 id="5b94" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">计时器</h1><p id="77b1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">解决这个问题的第一个也是最明显的方法是在滚动到元素之前使用一个<code class="fe mh mi mj mk b">timeout</code>。如果我们在根路由模块中设置<code class="fe mh mi mj mk b">anchorScrolling</code>为<code class="fe mh mi mj mk b">enabled</code>，那么<code class="fe mh mi mj mk b">Scroll</code>事件会在<code class="fe mh mi mj mk b">NavigationEnd</code>之后立即触发。然而，在<strong class="kq io">版本 15 中，</strong>事件被超时触发(<a class="ae ml" href="https://github.com/angular/angular/commit/79e9e8ab779d230f6a1df25c4ccff94b13129305" rel="noopener ugc nofollow" target="_blank">见发布修复</a>):</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="9f3c" class="mx ll in mk b be my mz l na nb">// Angular internal code<br/>private scheduleScrollEvent(routerEvent: NavigationEnd, anchor: string|null): void {<br/>  this.zone.runOutsideAngular(() =&gt; {<br/>    setTimeout(() =&gt; {<br/>      this.zone.run(() =&gt; {<br/>        this.router.triggerEvent(new Scroll(<br/>            routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null,<br/>            anchor));<br/>      });<br/>    }, 0);<br/>  });<br/>}</span></pre><p id="2b47" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">但是事情是这样的</strong>，定时器几乎立刻触发事件(0 毫秒)。这仍然不是我们想要的，因为有时内容在加载之前需要一点时间(想想 headless CSM，预渲染并不能解决这个问题，因为 Angular 在 JavaScript 准备好的时候就开始了)。因此，让我们编写自己的事件订阅者，至少有 1 秒钟的延迟。</p><blockquote class="mm mn mo"><p id="8bb4" class="ko kp mp kq b kr ks jo kt ku kv jr kw mq ky kz la mr lc ld le ms lg lh li lj ig bi translated">最终代码在<a class="ae ml" href="https://stackblitz.com/edit/angular-anchor-scrolling" rel="noopener ugc nofollow" target="_blank">堆栈上</a></p></blockquote><p id="b759" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的<strong class="kq io">根路由模块</strong>中，我们将设置一个事件监听器，超时后调用<code class="fe mh mi mj mk b">scrollToAnchor</code>函数。我们还应该禁用任何<code class="fe mh mi mj mk b">anchorScrolling</code>,这样它就不会运行内置代码。</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="9fc5" class="mx ll in mk b be my mz l na nb">// root routing module<br/>@NgModule({<br/>  imports: [<br/>    RouterModule.forRoot(routes, {<br/>      // you may still do this<br/>      scrollPositionRestoration: 'top',<br/>      // but don't do this, the default is disabled<br/>      // anchorScrolling: 'enabled'<br/>    })<br/>  ],<br/>  exports: [RouterModule]<br/>})<br/>export class AppRoutingModule {<br/>  constructor(<br/>    router: Router,<br/>    viewportScroller: ViewportScroller,<br/>  ) {<br/>    // listen to events<br/>    router.events.pipe(<br/>      // catch the Scroll event<br/>      filter(event =&gt; event instanceof Scroll)<br/>    ).subscribe({<br/>      next: (e: Scroll) =&gt; {<br/>         if (e.anchor) {<br/>           // timeout for 1 second before scrolling<br/>           // or timer(1000) RxJS<br/>           zone.runOutsideAngular(() =&gt; {<br/>             setTimeout(() =&gt; {<br/>               zone.run(() =&gt; {<br/>                 viewportScroller.scrollToAnchor(e.anchor);<br/>               });<br/>             }, 1000);<br/>           });<br/>         }<br/>      }<br/>    });<br/>  }<br/>}</span></pre><p id="b8e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以用有棱角的男人用的区外法，让自己看起来很酷。😎</p><p id="50d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以微调计时器以适合您的项目，并且记住您需要与页面加载保持足够的距离，但要足够快，以免混淆用户。</p><p id="68cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这并不理想。我们能做得更好吗？</p><h1 id="b9a8" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">滚动特定事件</h1><p id="1e7c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">如果我们需要的只是一个带有标题的简单页面，那么等待 1 秒钟应该没问题。但是，如果我们有一个复杂的设置<strong class="kq io">无头 CSM 与我们想要链接的副标题</strong>，那么我们希望有点创意。以下是我的建议:</p><p id="b5d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">触发滚动事件，不影响历史状态</strong>。我仍然想使用 Angular 库的内部机制，我不希望显式地计算位置，也不希望在没有必要时超时。有两个地方我们可以这样做:</p><ul class=""><li id="586a" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated">每次 HTTP 调用结束后</li><li id="8cdb" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">选择性地在返回的 HTML 绑定完成后</li></ul><p id="85a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为只有通过触发导航事件才能触发滚动事件，所以我们的解决方案是使用<code class="fe mh mi mj mk b">navigate</code>方法。</p><p id="9a75" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们假设一个 HTTP 调用，它在几毫秒内结束:</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="078f" class="mx ll in mk b be my mz l na nb">// example call to an http function<br/>this.post$ = this.postService.GetPost('someparams').pipe(<br/>  // on finish, try to navigate<br/>  finalize(() =&gt; {<br/>    // router = Router<br/>    // url has the hash with it<br/>    // skipLocationChange so that it does not build up in history<br/>    // for this to work, the root router module needs to be set to<br/>    // onSameUrlNavigation: 'reload'<br/>    this.router.navigateByUrl(this.router.url, {skipLocationChange: true});<br/>  })<br/>);</span></pre><p id="f62e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这也加上了<code class="fe mh mi mj mk b">anchorScrolling</code>为<code class="fe mh mi mj mk b">enabled</code>，<code class="fe mh mi mj mk b">onSameUrlNavigation</code>为<code class="fe mh mi mj mk b">reload</code>。我们也可以考虑将<code class="fe mh mi mj mk b">scrollOffset</code>设置为远离边缘的值，比如<code class="fe mh mi mj mk b">200px</code>:</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="2b4d" class="mx ll in mk b be my mz l na nb">// root routing module, for navigate solution to work<br/>RouterModule.forRoot(routes, {<br/>   onSameUrlNavigation: 'reload',<br/>   anchorScrolling: 'enabled',<br/>   scrollOffset: [0, 200],<br/>})</span></pre><p id="154b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们有一个服务和一个 HTTP <strong class="kq io">拦截器</strong>，这可以设计得更好。但是我不会用我的设置来迷惑你，只要记住，在一个好的应用程序中，在完成一个 HTTP 拦截器时，通常会发生另一个事件:<strong class="kq io">隐藏页面加载器</strong>。你可能想把这条线和它放在一起。</p><p id="aa25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">别担心，<code class="fe mh mi mj mk b">navigatgeByUrl</code>不重装组件，其实重装组件是一个几乎永远不会实现的梦想。</p><p id="a044" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了找出 URL 是否有片段，我们可以使用<code class="fe mh mi mj mk b">ActivatedRoute</code> snapshot 属性:</p><p id="2f53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">this.activatedRoute.snapshot.fragment</code></p><p id="e0e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者简单地在你的<code class="fe mh mi mj mk b">router.url</code>中找到<code class="fe mh mi mj mk b">#</code></p><p id="9b21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">this.router.url.indexOf('#') &gt; -1</code></p><p id="7f40" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们需要设计的几条基本线是:</p><pre class="kd ke kf kg gt mt mk mu bn mv mw bi"><span id="78dc" class="mx ll in mk b be my mz l na nb">// we need to run this after the event we think creates and populates our HTML<br/>if (this.router.url.indexOf('#') &gt; -1) {<br/> this.router.navigateByUrl(this.router.url, {skipLocationChange: true});<br/>}</span></pre><p id="d92c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就我个人而言，我使用的是无头 CSM，在我渲染 HTML 之后，我调用一个函数来处理超出原始格式的 HTML。我用区外超时来看起来很酷。😎</p><p id="4e1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意:关于 SSR，生成的锚被 SEO 爬虫检测到就可以了。</p><p id="2270" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">谢谢你对我的容忍。你抓住那只熊了吗？</p><h1 id="4b24" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">资源</h1><ul class=""><li id="1246" class="nc nd in kq b kr mc ku md kx nq lb nr lf ns lj nh ni nj nk bi translated"><a class="ae ml" href="https://angular.io/api/router/InMemoryScrollingOptions#anchorScrolling" rel="noopener ugc nofollow" target="_blank">锚点滚动角度文档</a></li><li id="c29a" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae ml" href="https://github.com/angular/angular/blob/b653ee340e3361b484837b028bdd7c4f91a46f85/packages/common/src/viewport_scroller.ts#L119" rel="noopener ugc nofollow" target="_blank"> GitHub Angular 源代码</a></li><li id="fb45" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae ml" href="https://github.com/angular/angular/commit/79e9e8ab779d230f6a1df25c4ccff94b13129305" rel="noopener ugc nofollow" target="_blank">角度 15°释放固定</a></li><li id="e339" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae ml" href="https://stackblitz.com/edit/angular-anchor-scrolling" rel="noopener ugc nofollow" target="_blank">斯塔克布里兹</a></li></ul></div></div>    
</body>
</html>