<html>
<head>
<title>Node.js Best Practices — Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—项目结构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-project-structure-48a3b4dcaad7?source=collection_archive---------0-----------------------#2020-08-18">https://blog.devgenius.io/node-js-best-practices-project-structure-48a3b4dcaad7?source=collection_archive---------0-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6bbe26e345b93370fa1b9e6d5ca9472b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1dTvDDukRwEK5N7j"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@octadan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">明锐丹</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="4335" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件夹结构</h1><p id="4a51" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的节点应用程序应该遵循一些标准的文件夹结构。</p><p id="28c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以有这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="abab" class="mn lc iq mj b gy mo mp l mq mr">src<br/>│   app.js          <br/>└───api             <br/>└───config          <br/>└───jobs            <br/>└───loaders         <br/>└───models          <br/>└───services        <br/>└───subscribers     <br/>└───types           </span></pre><p id="c010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">app.js</code>是app的入口。</p><p id="8535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">api</code>拥有端点的控制器。</p><p id="0d73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">config</code>有环境变量和配置相关的东西。</p><p id="0cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">jobs</code>有预定的工作。</p><p id="c4fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">loaders</code>拥有应用程序启动时运行的代码。</p><p id="be2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">models</code>拥有数据库模型。</p><p id="55e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">services</code>有业务逻辑。</p><p id="1136" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">subscribers</code>拥有队列等事件处理程序。</p><p id="35f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">types</code>是TypeScript项目的类型定义。</p><h1 id="3435" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">三层架构</h1><p id="c91b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">3层架构由控制器、服务层和数据访问层组成。</p><p id="619d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制器是客户端的接口。</p><p id="e3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受请求并发送响应。</p><p id="d326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务层具有逻辑，它从控制器获取信息并返回给控制器。</p><p id="7bed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据访问层具有与服务层对话的数据库逻辑。</p><p id="1702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该将业务逻辑放在控制器中。</p><p id="6dd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们编写单元测试时，将它们分开会使测试更容易。</p><p id="48b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们测试控制器时，我们可以模拟所有的服务实体。</p><h1 id="8a08" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">业务逻辑的服务层</h1><p id="5fcc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">服务层用于业务逻辑。</p><p id="10c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一切都是为了做控制器和数据库层不做的事情。</p><p id="77d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ad49" class="mn lc iq mj b gy mo mp l mq mr">route.post('/', <br/>  validators.userSignup, <br/>  async (req, res, next) =&gt; {<br/>    const userParams = req.body;<br/>    const { user } = await UserService.Signup(userParams);<br/>    return res.json(user);<br/>  });</span></pre><p id="6efe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">UserService.Signup</code>有业务逻辑。</p><p id="81fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请求和响应由控制器处理。</p><h1 id="3987" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发布/子层</h1><p id="e917" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">发布/订阅层用于侦听来自外部源的事件。</p><p id="edfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">pub部分向其他模块发送数据。</p><p id="2186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分离这个逻辑是有意义的，因为它们创建了一个内聚层。</p><h1 id="42e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">依赖注入</h1><p id="03f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">依赖注入让我们可以在一个地方处理所有的依赖初始化。</p><p id="b3f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa81" class="mn lc iq mj b gy mo mp l mq mr">export default class UserService {<br/>  constructor(userModel, companyModel, employeeModel){<br/>    this.userModel = userModel;<br/>    this.companyModel = companyModel;<br/>    this.employeeModel = employeeModel;<br/>  }</span><span id="20f2" class="mn lc iq mj b gy mv mp l mq mr">  getUser(userId){<br/>    const user = this.userModel.findById(userId);<br/>    return user;<br/>  }<br/>}</span></pre><p id="182d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe ms mt mu mj b">UserService</code>类，它在构造函数中包含了所有需要的依赖项。</p><p id="b1a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在整堂课中使用。</p><p id="e7b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用第三方解决方案来简化这一过程。</p><p id="19c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.npmjs.com/package/typedi" rel="noopener ugc nofollow" target="_blank"> typedi </a>库为我们提供了一个依赖注入容器，让我们注入依赖。</p><p id="ef6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写如下代码将依赖注入与Express结合使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="435b" class="mn lc iq mj b gy mo mp l mq mr">route.post('/', <br/>  async (req, res, next) =&gt; {<br/>    const userParams = req.body;<br/>    const userServiceInstance = Container.get(UserService);<br/>    const { user} = userServiceInstance.Signup(userParams);  <br/>    return res.json(user);<br/>  });</span></pre><p id="83ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe ms mt mu mj b">typedi </code>调用<code class="fe ms mt mu mj b">Container.get</code>方法来获取<code class="fe ms mt mu mj b">UserService</code>，这样我们就可以使用它了。</p><h1 id="b4ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Cron作业和重复任务</h1><p id="4c8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Cron作业和计划任务应该在它们自己的文件夹中。</p><p id="c411" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用服务层的业务逻辑。</p><p id="761a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该使用<code class="fe ms mt mu mj b">setTimeout</code>或其他原始方式来延迟代码的执行。</p><p id="ba7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用一个库来帮助我们。</p><p id="0d86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以控制失败的作业，并对成功的作业进行反馈。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e321323381bb07c3f65063627d2248aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ozAhCnQj90UynHab"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@bormot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·巴甫洛夫·博尔莫丁</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0e6b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7369" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该创建具有标准结构的应用程序。</p><p id="eded" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些文件夹紧密地组织了我们应用程序的不同部分。</p></div></div>    
</body>
</html>