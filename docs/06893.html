<html>
<head>
<title>Introduction to Docker in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 中的 Docker 介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-docker-in-r-cbc886faed3?source=collection_archive---------16-----------------------#2022-02-09">https://blog.devgenius.io/introduction-to-docker-in-r-cbc886faed3?source=collection_archive---------16-----------------------#2022-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="77c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 技术已经成为软件开发领域中最常用的技术之一，开发者现在能够开发、复制和运输容器化的应用程序。该系统以这样一种方式工作，即容器运行在与主机隔离的环境中。一种密切相关的方式是通过旋转虚拟机，然后安装操作系统以及依赖项，但是与轻量级的容器化相比，这种方式在资源方面有点受限并且有点昂贵，因为容器化在共享方面是快速和可移植的。</p><p id="afc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图有助于说明 docker 与虚拟机相比是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b77bcd21c1cb31f4cfa95187c2514b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5otBQM-gEZh64pElEbccA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">[图片来自 cloudblogs.microsoft.com]</figcaption></figure><p id="7097" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Docker 和 RShiny </strong></p><ul class=""><li id="ccc7" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">Shiny 是单线程的，这意味着一个应用程序的多个用户使用一个会话，这经常会产生问题。容器化解决了这个问题，因为有了 docker，每个用户都能得到一个容器化的闪亮应用。</li><li id="58a1" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">通常情况下，包和依赖项在更新时会带来问题，比如一个运行良好的应用程序会因为之前使用的包的某个版本被更新为另一个版本而停止运行。</li><li id="f9cd" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">如果你想在一些托管平台上托管一个闪亮的应用程序，比如<a class="ae lm" href="https://www.heroku.com" rel="noopener ugc nofollow" target="_blank"> heroku </a>，你需要对你的应用程序进行文档化。这些知识会派上用场。</li></ul><p id="a094" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">码头建筑</strong></p><p id="138e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图向我们概述了 docker 系统的工作原理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ln"><img src="../Images/69de48b8e1f9d6f80a95d64552e40af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lIGnaJl0sVq6ZMjDR1Jvng.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">[图片来自 docs.docker.com]</figcaption></figure><p id="1ec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Docker 客户端</strong></p><p id="ba5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户端为用户提供了一个命令行界面，您可以在其中运行 docker 命令，这些命令通过 API 与 docker 守护进程进行对话。</p><p id="87a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Docker 守护进程</strong></p><p id="6119" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是 docker 对象的管理器；图像、容器、网络和卷。</p><ul class=""><li id="516b" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io"> <em class="lo">图像</em> </strong>:这是一个带有指令的文件，用于创建一个容器。图像是从 docker 文件创建的。</li><li id="22d5" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><strong class="jm io"> <em class="lo"> Dockerfile </em> </strong>:这是一个文本文件，包含构建图像的指令/命令。</li><li id="cab9" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><strong class="jm io"> <em class="lo">容器</em> </strong>:图像的可运行实例。</li><li id="ab5f" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><strong class="jm io"> <em class="lo">网络</em> </strong>:连接 docker 容器的系统。</li></ul><p id="4619" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Docker 注册表</strong></p><p id="2096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是 docker 图像存储、共享和管理的地方。</p><p id="a496" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">安装</strong></p><p id="ab7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 系统是在 linux 上构建的，但是，对于 windows 和 Mac 用户，您仍然可以安装桌面版本，如下所述:</p><ul class=""><li id="f260" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><a class="ae lm" href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" rel="noopener ugc nofollow" target="_blank">在 mac 上安装 docker</a></li><li id="6c55" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><a class="ae lm" href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" rel="noopener ugc nofollow" target="_blank">在 windows 上安装</a></li><li id="1d04" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><a class="ae lm" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">沉迷于 ubuntu </a>发行版</li></ul><p id="8b16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个 Dockerfile 文件的简单例子，它是我在<a class="ae lm" href="https://oyogo.github.io/shiny/2021/06/08/gentle-introduction-to-r-shiny.html" rel="noopener ugc nofollow" target="_blank">这篇</a>文章的前面开发的教育应用程序中构建的。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="47b3" class="lu lv in lq b gy lw lx l ly lz">FROM rocker/shiny-verse:latest<br/>USER root</span><span id="e844" class="lu lv in lq b gy ma lx l ly lz">RUN R -e 'install.packages("devtools")'<br/>RUN R -e 'devtools::install_version("shiny", version = "1.6.0", dependencies= T)'  <br/>RUN R -e 'devtools::install_version("ggplot2", version = "3.3.2", dependencies= T)'<br/>RUN R -e 'devtools::install_version("plotly")' <br/>RUN R -e 'devtools::install_version("dplyr", version = "1.0.0", dependencies= T)'</span><span id="1d30" class="lu lv in lq b gy ma lx l ly lz">COPY ./www/ /shiny/dashboard/www/<br/>COPY app.R /shiny/dashboard/</span><span id="1447" class="lu lv in lq b gy ma lx l ly lz">EXPOSE 3838</span><span id="c92e" class="lu lv in lq b gy ma lx l ly lz">CMD R -e 'shiny::runApp("/shiny/dashboard", port = 3838, host = "127.0.0.1")'</span></pre><p id="51a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lo">在命令行上，您可以使用*touch Dockerfile*创建一个空文件，然后使用您喜欢的文本编辑器向其添加层</em></p><p id="6086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">来自</strong></p><p id="bd36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们 docker 文件的第一层，它指定了将用于构建新映像的基础映像。每一个 docker 文件都从这一层开始，你经常会使用另一个图像作为你的起点。另一种方法是通过安装所需的依赖项从头开始，但这将需要更多的工作，而这些工作可能是不必要的。</p><p id="ea31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的图像，我们使用 rocker 的 r-base 作为我们的基础图像，然后添加图层。</p><p id="b3b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用户</strong></p><p id="2e7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该命令指定用户，在本例中为<em class="lo"> root。</em>指定的用户将用于运行后续的<em class="lo">运行</em>、<em class="lo">复制</em>、<em class="lo">曝光</em>和<em class="lo"> CMD </em>命令。</p><p id="c618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">复制</strong></p><p id="91f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">copy 命令将文件或目录从主机复制到容器中。该命令有两条路径:</p><p id="3bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lo">主机路径和容器路径</em></p><p id="3a70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它的形式是:</p><p id="f931" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于文件:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="24a8" class="lu lv in lq b gy lw lx l ly lz">path-in-host/files.txt path-in-container/</span><span id="0490" class="lu lv in lq b gy ma lx l ly lz">#example<br/>/shiny/dashboards/app.R /shiny/dashboards/</span></pre><p id="19ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意两条路径之间的间距。从上面一行，我们复制了文件应用程序。r 从里面亮晶晶的文件夹仪表板到容器里亮晶晶的文件夹下的文件夹仪表板。</p><p id="d4df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于文件夹:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="d2f4" class="lu lv in lq b gy lw lx l ly lz">path-in-host/myfolder/ path-in-container/</span></pre><ul class=""><li id="07d8" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">复制<em class="lo"> myfolder </em>时，只有内容会被复制到*path-in-container*中，以创建<em class="lo"> myfolder </em>然后写入*path-in-container/myfolder/</li><li id="ecb4" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">通过这样写——<em class="lo">my folder</em>将在容器文件系统中创建，而不需要使用<em class="lo"> mkdir </em>命令，然后，<br/>来自主机的<em class="lo"> myfolder </em>的内容将被粘贴到其中。</li><li id="aeb1" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">如果碰巧你的路径有空白，即<em class="lo">项目/我的文件夹/ </em>，那么使用 COPY<em class="lo">["/项目/我的文件夹/"，"/项目/我的文件夹/"] </em></li><li id="19ea" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">如果你有多个文件，比如从 mod 开始…那么你可以使用 COPY <em class="lo"> mod* /myfolder/ </em>来复制所有的文件。所有以 mod 开头的文件都将被复制。</li><li id="1dd0" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">在我们的例子中，第一行复制了 www 文件夹，其中包含一些我们使用过的图片。第二行复制应用程序。r 脚本文件，其中包含用于构建我们的应用程序的 ui 和服务器代码。</li></ul><h2 id="ee33" class="lu lv in bd mb mc md dn me mf mg dp mh jv mi mj mk jz ml mm mn kd mo mp mq mr bi translated"><strong class="ak">运行</strong></h2><p id="aeef" class="pw-post-body-paragraph jk jl in jm b jn ms jp jq jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh ig bi translated">这条指令在容器内部执行给定的命令。在这种情况下，我们使用它在容器中安装必要的包。<br/>注意，我们首先从安装 devtools 开始，这样我们就可以用它来安装所需软件包的特定版本。</p><p id="0feb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> CMD </strong></p><p id="0a96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个命令告诉 docker 在容器内部运行哪个命令。对于这种情况，其<strong class="jm io"> <em class="lo"> R -e </em> </strong>命令如下所示:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="be0a" class="lu lv in lq b gy lw lx l ly lz">R -e 'shiny::runApp("/shiny/dashboard", port = 3838, host = "127.0.0.1")'</span></pre><p id="4843" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">曝光 3838 </strong></p><p id="815a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个命令指示容器向外界开放网络端口 3838。</p><p id="f3fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">构建映像</strong></p><p id="6a52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们如上所述编写了 docker 文件，导航到包含您的应用程序文件的工作目录，并输入以下命令来构建映像:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="70ac" class="lu lv in lq b gy lw lx l ly lz">$ docker build -t nameofimage .</span></pre><p id="abd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[-t]标记我们的图像，因为它给我们的图像一个名字。<br/>的[。]指示 docker 使用当前文件夹中的 docker 文件。否则我们会给它 docker 文件所在的路径。</p><p id="054f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">N/B 请记住将图像的名称替换为您想要的名称。如果您有 docker hub 帐户，您可以使用<strong class="jm io"><em class="lo">yournameindockerhub/nameofimage</em></strong></p><p id="6fc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">旋转容器</strong></p><p id="41aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要等待几分钟来建立你的图像，这取决于你的电脑规格、网速和你的应用程序有多大。成功构建映像后，使用以下命令检查您的系统中是否存在该映像。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="4e28" class="lu lv in lq b gy lw lx l ly lz">$ docker image</span></pre><p id="f469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该命令列出了您的计算机中的所有图像，您要么建立或从 docker 注册表拉。</p><p id="37b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要从我们使用的图像旋转容器:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="f372" class="lu lv in lq b gy lw lx l ly lz">$ <!-- -->docker run -it --rm -p 3838:3838 -v '/pathtofolder/data':'/shiny/data' nameofimage</span></pre><p id="6e8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">docker run 是从 docker 映像旋转容器的命令。<br/>-<strong class="jm io">-<em class="lo">p 3838</em></strong>对外公布港口。<br/> - <strong class="jm io"> <em class="lo"> v </em> </strong>:挂载一个卷。-v 标记告诉 docker 将位于'/pathtodatfolder/data '的数据文件夹挂载到容器内的' shiny/data '上。好吧，记得当我们创建 docker 文件时，我们没有创建数据目录，所以你可能想知道这是如何工作的，没必要担心。docker 会自动在容器中创建文件夹，然后将它链接到主机中的数据文件夹。</p><p id="34ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，您现在可以在我们的浏览器上查看<strong class="jm io"><em class="lo">localhost:3838</em></strong>来查看您的容器化应用程序。</p><h1 id="9fc8" class="mx lv in bd mb my mz na me nb nc nd mh ne nf ng mk nh ni nj mn nk nl nm mq nn bi translated">这就对了！你已经容器化了你的应用程序</h1><p id="213d" class="pw-post-body-paragraph jk jl in jm b jn ms jp jq jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh ig bi translated">您可以抽出一些时间，访问以下页面进行进一步阅读:</p><ol class=""><li id="a0a9" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh no le lf lg bi translated"><a class="ae lm" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> docker 文档</a></li><li id="8e70" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh no le lf lg bi translated"><a class="ae lm" href="https://docker-curriculum.com/" rel="noopener ugc nofollow" target="_blank">docker-课程表</a></li></ol></div></div>    
</body>
</html>