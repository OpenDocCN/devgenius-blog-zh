<html>
<head>
<title>How Easy Can Testing Be?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试能有多简单？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-easy-can-testing-be-3f9ad2ce7a7c?source=collection_archive---------8-----------------------#2022-04-30">https://blog.devgenius.io/how-easy-can-testing-be-3f9ad2ce7a7c?source=collection_archive---------8-----------------------#2022-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6243" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果你真的认为在 Golang 中测试很复杂，看看这篇介绍吧！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/85290ac39316aaf11ef8d9c038b4e402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ffd0Dwjoj6Uzfjag"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·伊德里</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ad47" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><p id="7f5c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">如今，当开发软件时，仅仅交付一个满足需求并做了预期工作的产品是不够的。如今，以下特征也很重要:</p><ul class=""><li id="2c40" class="mh mi in ln b lo mj lr mk lu ml ly mm mc mn mg mo mp mq mr bi translated">可维护性</li><li id="b8f7" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated">可量测性</li><li id="fde1" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated">易测性</li><li id="1b07" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated">成本效益</li></ul><p id="6e97" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">特别是成本效益这一点，因为特别是在软件开发中，假设了 1–10–100 规则，这意味着修正和错误修复的支出和成本呈指数增长。如果开发人员直接发现了一个错误，他可以直接用很少的支出来纠正这个错误(因素 1)。然而，如果测试人员发现了一个错误，这个过程需要更长的时间，因为测试人员必须首先与开发人员沟通这个问题，然后开发人员必须修复这个错误(10 倍)。在最后一步，即在最终客户处或在实际操作中，故障排除已经变得非常困难，因为客户必须首先创建对不当行为的精确描述。那么必须对这种行为进行分析和调整，这也会给最终客户带来经济损失。最后，问题仍然需要修复、测试和交付(100 倍)。</p><p id="70be" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">这只是对测试原因的简单总结。存在多种类别和类型的测试，但最常见的是单元测试。顾名思义，单元测试用于测试最小的代码单元，在大多数情况下是函数。</p><h2 id="66aa" class="na ku in bd kv nb nc dn kz nd ne dp ld lu nf ng lf ly nh ni lh mc nj nk lj nl bi translated">先决条件</h2><p id="ee72" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">要遵循本教程，你至少应该有一些编码经验。对于本教程，至少了解一点 Golang 是明智的。此外，必须存在 Golang 的运行安装(使用 Golang v1.16)。安装说明可以在<a class="ae ks" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="4658" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">在 Golang 测试</h1><p id="45fb" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为您的项目创建新文件夹。打开命令行，运行命令<code class="fe nm nn no np b">go mod init</code>。它初始化并在当前目录中写入一个新的<code class="fe nm nn no np b">go.mod</code>文件，实际上是在当前目录中创建一个新的模块。创建一个子目录<code class="fe nm nn no np b">math</code>，并在新目录下创建一个<code class="fe nm nn no np b">math.go</code>。向文件中添加两个函数:</p><ul class=""><li id="aa73" class="mh mi in ln b lo mj lr mk lu ml ly mm mc mn mg mo mp mq mr bi translated"><code class="fe nm nn no np b">Add()</code>:两个整数之和</li><li id="b76e" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated"><code class="fe nm nn no np b">Subtract()</code>:两个整数之差</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0cfe" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">包<code class="fe nm nn no np b">testing</code>自动执行以下形式的所有测试:</p><pre class="kd ke kf kg gt ns np nt nu aw nv bi"><span id="477c" class="na ku in np b gy nw nx l ny nz">func TestXxx(*testing.T)</span></pre><p id="76dd" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了编写测试，创建一个包含测试函数的<code class="fe nm nn no np b">math_test.go</code>。下面的例子展示了函数<code class="fe nm nn no np b">Add()</code>的测试是怎样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="51d4" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了执行测试，使用命令<code class="fe nm nn no np b">go test</code>，这表明所有测试都通过了:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9981" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">当在功能 Add()中用<code class="fe nm nn no np b">-</code>替换<code class="fe nm nn no np b">+</code>时，测试失败，输出如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="054e" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了提高单元测试的质量，可以使用像<code class="fe nm nn no np b">github.com/stretchr/testify/assert</code>这样的包。最后一个例子中的<code class="fe nm nn no np b">if</code>可以用调用<code class="fe nm nn no np b">assert.Equal()</code>来代替。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1917" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在大多数情况下，当编写单元测试时，会使用不止一个用例来测试一个功能。因此，可以使用所谓的测试表。以下示例包含一个测试表，其中包含所需的输入和预期的输出:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1184" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了在运行测试时获得更多细节，可以使用标志<code class="fe nm nn no np b">-v</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d3f4" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">编写测试时，尽可能多地覆盖代码是很重要的。您可能想知道如何知道，代码的哪些部分已经被覆盖了。问这个问题的时候<em class="oa">报道</em>大多时候是答案。顾名思义，覆盖率报告是关于代码覆盖率的报告。运行命令<code class="fe nm nn no np b">go test</code>时，可以用标志<code class="fe nm nn no np b">-coverprofile</code>创建 coverprofile。正如所料，当前覆盖率为 50%，因为只有功能<code class="fe nm nn no np b">Add()</code>被覆盖。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4038" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了更深入地了解代码的哪些部分，可以使用命令<code class="fe nm nn no np b">go tool cover -html="cover.out"</code>。这将生成一个<code class="fe nm nn no np b">.html</code>文件，其中包含一份关于所覆盖文件的报告。它将在浏览器中打开并可视化，功能<code class="fe nm nn no np b">Add()</code>被覆盖，但功能<code class="fe nm nn no np b">Subtract()</code>未被覆盖；</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0917dab7fc23f9043b50ae129c65569f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*hcZRNG0Sm1zZ11zXlh3CJA.png"/></div></figure><p id="1b72" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了覆盖代码的所有部分(因此覆盖率为 100%)，必须添加函数<code class="fe nm nn no np b">Subtract()</code>的测试:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5056" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">为了显示更高级的单元测试，将使用 Golang <code class="fe nm nn no np b">FizzBuzz</code>。你们中的许多人可能知道，这里有一个小总结:从 1 到<code class="fe nm nn no np b">n</code>循环并打印每个数字。</p><ul class=""><li id="7010" class="mh mi in ln b lo mj lr mk lu ml ly mm mc mn mg mo mp mq mr bi translated">对于 3 的每个倍数，打印<code class="fe nm nn no np b">Fizz</code>而不是数字。</li><li id="4ca6" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated">对于每个 5 的倍数，打印<code class="fe nm nn no np b">Buzz</code>而不是数字。</li><li id="2399" class="mh mi in ln b lo ms lr mt lu mu ly mv mc mw mg mo mp mq mr bi translated">对于 3 和 5 的每个倍数，打印<code class="fe nm nn no np b">FizzBuzz</code>而不是数字。</li></ul><p id="db85" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">如果你想尝试，先解决问题，这里有一个<a class="ae ks" href="https://www.hackerrank.com/challenges/fizzbuzz/problem" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>的链接。获取输出的示例解决方案可以在这里找到:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8add" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">对于这个函数，你会看到，用一个输入来测试这个函数是不够的。因此，使用测试表进行测试是很常见的。测试表包含测试数据和预期结果。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ed25" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在这个例子中，函数<code class="fe nm nn no np b">GetOutput</code>用不同的输入进行测试，测试不同的用例。这就产生了一个完全覆盖的功能:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/ac38b8fec83a00adaf7020f8a4da2e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urhzHRSIzeXWGxTS5OkM1g.png"/></div></div></figure><p id="b687" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">当您现在尝试优化该功能时，您可以轻松地验证它是否仍在工作，而不必手动检查每种情况。</p><h1 id="b015" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结论</h1><p id="3019" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这篇文章强调了在 Golang 中保持高测试覆盖率是多么容易，以及如何编写测试。以一个软件测试笑话来结束这篇文章:</p><p id="431b" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><em class="oa">问题</em>:换一个灯泡需要多少个软件测试人员？<em class="oa">回答</em>:没有，测试人员不修复问题，他们只是发现问题。</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="2378" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">如果你觉得这篇文章和内容有用，请与你的朋友分享，留着以后看，并留下你的👏甚至是 5️⃣0️⃣</p><p id="30e9" class="pw-post-body-paragraph ll lm in ln b lo mj jo lq lr mk jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">如果你对软件开发和 IT 领域的其他话题感兴趣，请跟我来💯</p></div></div>    
</body>
</html>