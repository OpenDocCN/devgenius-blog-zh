<html>
<head>
<title>Writing Custom Platform-Specific Code in Flutter App [Method Channel]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Flutter App 中编写定制的平台特定代码[方法通道]</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-custom-platform-specific-code-in-flutter-app-method-channel-a4c49bf3f4f2?source=collection_archive---------4-----------------------#2022-11-24">https://blog.devgenius.io/writing-custom-platform-specific-code-in-flutter-app-method-channel-a4c49bf3f4f2?source=collection_archive---------4-----------------------#2022-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5172" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解如何编写自定义平台代码，并在 flutter app 内连接它</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/187f5212b70c66054cbf68af4efe4cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoc_khZOipcEKE4dXzIbGQ.png"/></div></div></figure><blockquote class="ku kv kw"><p id="d75e" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">Flutter 使用了一个灵活的系统，允许您以一种直接使用这些 API 的语言调用特定于平台的 API:</p></blockquote><ul class=""><li id="7b6f" class="lb lc in jm b jn jo jr js jv ld jz le kd lf kh lg lh li lj bi translated">Android 上的 Kotlin 或 Java</li><li id="d87c" class="lb lc in jm b jn lk jr ll jv lm jz ln kd lo kh lg lh li lj bi translated">iOS 上的 Swift 或 Objective-C</li><li id="c2f6" class="lb lc in jm b jn lk jr ll jv lm jz ln kd lo kh lg lh li lj bi translated">Windows 上的 C++</li><li id="ea38" class="lb lc in jm b jn lk jr ll jv lm jz ln kd lo kh lg lh li lj bi translated">macOS 上的目标 C</li><li id="a233" class="lb lc in jm b jn lk jr ll jv lm jz ln kd lo kh lg lh li lj bi translated">Linux 上的 c</li></ul><p id="a9a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的解释来自官方文件，用来解释方法通道是如何工作的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/5c6c918b6a37a4dc66b4cf8b364ecf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*IyZxSjFOQNVju3WUu758Bg.png"/></div></figure><blockquote class="ku kv kw"><p id="f6c2" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">我还将在官方文档中解释如何获取当前设备的电池电量，以提供更多关于它如何工作的背景信息</p></blockquote><h1 id="bd84" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">首先，使用您喜欢的 IDE 创建一个 Flutter 应用程序</h1><p id="254d" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">清除 Flutter Starter app 并创建一个新的 dart 文件<strong class="jm io"> home_screen.dart </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/1938d251df3185ffc822f88344334491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4pnqeOs_5EBeGWz6q_vag.png"/></div></div></figure><p id="a440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你的<strong class="jm io"> home_screen.dart </strong>中创建一个新的 statefull 小部件，现在返回一个 scafolld</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="11e7" class="mz lr in mv b be na nb l nc nd">import 'package:flutter/material.dart';<br/><br/>class HomeScreen extends StatefulWidget {<br/>  const HomeScreen({Key? key}) : super(key: key);<br/><br/>  @override<br/>  State&lt;HomeScreen&gt; createState() =&gt; _HomeScreenState();<br/>}<br/><br/>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold();<br/>  }<br/>}</span></pre><p id="a953" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后导入这些库</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="0f9d" class="mz lr in mv b be na nb l nc nd">import 'dart:async';<br/>import 'package:flutter/material.dart';<br/>import 'package:flutter/services.dart';</span></pre><p id="f144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所知，与 platfrom 的交流是以一种<strong class="jm io">异步</strong>的方式进行的，所以我们将在这个应用上做<strong class="jm io">未来</strong></p><p id="adb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您的状态中创建一个字符串</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="b3b3" class="mz lr in mv b be na nb l nc nd">String _batteryLevel = 'Unknown battery level.';</span></pre><p id="fef2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您的代码现在应该如下所示</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="1f67" class="mz lr in mv b be na nb l nc nd">import 'package:flutter/material.dart';<br/>import 'dart:async';<br/>import 'package:flutter/material.dart';<br/>import 'package:flutter/services.dart';<br/><br/>class HomeScreen extends StatefulWidget {<br/>  const HomeScreen({Key? key}) : super(key: key);<br/><br/>  @override<br/>  State&lt;HomeScreen&gt; createState() =&gt; _HomeScreenState();<br/>}<br/><br/>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br/>  String _batteryLevel = 'Unknown battery level.';<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold();<br/>  }<br/>}</span></pre><p id="5879" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在您的状态中创建一个未来的异步函数 getBatteryLevel</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="8e44" class="mz lr in mv b be na nb l nc nd">Future&lt;void&gt; _getBatteryLevel() async {<br/>  String batteryLevel;<br/>  try {<br/>    final int result = await platform.invokeMethod('getBatteryLevel');<br/>    batteryLevel = 'Battery level at $result % .';<br/>  } on PlatformException catch (e) {<br/>    batteryLevel = "Failed to get battery level: '${e.message}'.";<br/>  }<br/><br/>  setState(() {<br/>    _batteryLevel = batteryLevel;<br/>  });<br/>}</span></pre><blockquote class="ku kv kw"><p id="d32b" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">现在你会注意到平台中的一个错误，因为我们还没有定义它</p><p id="1519" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">在我们声明它之前，我们需要知道方法通道必须有一个唯一的域供两端通信，所以它是常量不可变的</p><p id="84fb" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">返回到您的状态并删除 methodChannel 对象</p></blockquote><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="4545" class="mz lr in mv b be na nb l nc nd">static const platform = MethodChannel('mediumExplain/battery');</span></pre><p id="9f27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们需要添加一些简单的用户界面来获取电池电量</p><p id="8b85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用以下代码替换您的构建方法</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="ba1f" class="mz lr in mv b be na nb l nc nd">@override<br/>Widget build(BuildContext context) {<br/>  return Scaffold(<br/>    appBar: AppBar(),<br/>    body: Column(<br/>      children: [<br/>        Text('Your battery level is ${_batteryLevel}'),<br/>        ElevatedButton(<br/>          onPressed: _getBatteryLevel,<br/>          child: const Text('Get Battery Level'),<br/>        ),<br/>      ],<br/>    ),<br/>  );<br/>}</span></pre><blockquote class="ku kv kw"><p id="619e" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">现在是 android 的原生部分，</p></blockquote><h1 id="6e17" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Android 配置 Kotlin</h1><p id="a62e" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">打开您的 android 应用程序目录</p><ul class=""><li id="121d" class="lb lc in jm b jn jo jr js jv ld jz le kd lf kh lg lh li lj bi translated"><strong class="jm io">&gt;app-&gt;src-&gt;main-&gt;kot Lin-&gt;main activity . kt</strong></li><li id="a8b7" class="lb lc in jm b jn lk jr ll jv lm jz ln kd lo kh lg lh li lj bi translated">添加那些导入</li></ul><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="bfa9" class="mz lr in mv b be na nb l nc nd">import io.flutter.embedding.android.FlutterActivity<br/>import io.flutter.embedding.engine.FlutterEngine<br/>import io.flutter.plugin.common.MethodChannel<br/>import androidx.annotation.NonNull<br/>import android.content.Context<br/>import android.content.ContextWrapper<br/>import android.content.Intent<br/>import android.content.IntentFilter<br/>import android.os.BatteryManager<br/>import android.os.Build.VERSION<br/>import android.os.Build.VERSION_CODES</span></pre><blockquote class="ku kv kw"><p id="03d4" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">这些是 android 的本地库，用于联系电池电量的 api</p></blockquote><p id="27f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后添加这个变量，和我们在 flutter 应用程序中创建的一样</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="f641" class="mz lr in mv b be na nb l nc nd">class MainActivity: FlutterActivity() {<br/>  private val CHANNEL = "mediumExplain/battery"</span></pre><p id="e660" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后忽略这个函数，让它保持原样</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="ae6c" class="mz lr in mv b be na nb l nc nd">override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {<br/>    super.configureFlutterEngine(flutterEngine)<br/>    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {<br/>      call, result -&gt;<br/>      // This method is invoked on the main thread.<br/>      // TODO<br/>    }<br/>  }</span></pre><p id="c005" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在它之后添加这个方法，它将得到电池的百分比，并重新发送到我们的渠道</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="628b" class="mz lr in mv b be na nb l nc nd">  private fun getBatteryLevel(): Int {<br/>    val batteryLevel: Int<br/>    if (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) {<br/>      val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager<br/>      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)<br/>    } else {<br/>      val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))<br/>      batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)<br/>    }<br/><br/>    return batteryLevel<br/>  }</span></pre><blockquote class="ku kv kw"><p id="a7a8" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">注意:这些与 flutter 无关，这是一个 android 原生 kotlin 代码，你一定不知道，你也可以从 android 或 ios 调用任何 api，即使你不知道原生代码，你可以在 stackoverflow 上搜索以找到你需要的相关内容。你只需要知道在这些代码之间建立一个通道</p></blockquote><p id="b5cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你的整个代码应该看起来像这样</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="735e" class="mz lr in mv b be na nb l nc nd">package com.example.bateery_level<br/><br/>import io.flutter.embedding.android.FlutterActivity<br/>import io.flutter.embedding.engine.FlutterEngine<br/>import io.flutter.plugin.common.MethodChannel<br/>import androidx.annotation.NonNull<br/>import android.content.Context<br/>import android.content.ContextWrapper<br/>import android.content.Intent<br/>import android.content.IntentFilter<br/>import android.os.BatteryManager<br/>import android.os.Build.VERSION<br/>import android.os.Build.VERSION_CODES<br/><br/>class MainActivity: FlutterActivity() {<br/>    private  val CHANNEL ="mediumExplain/battery"<br/><br/>    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {<br/>        super.configureFlutterEngine(flutterEngine)<br/>        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {<br/>            // This method is invoked on the main thread.<br/>                call, result -&gt;<br/>            if (call.method == "getBatteryLevel") {<br/>                val batteryLevel = getBatteryLevel()<br/><br/>                if (batteryLevel != -1) {<br/>                    result.success(batteryLevel)<br/>                } else {<br/>                    result.error("UNAVAILABLE", "Battery level not available.", null)<br/>                }<br/>            } else {<br/>                result.notImplemented()<br/>            }<br/>        }<br/><br/>    }<br/>    private fun getBatteryLevel(): Int {<br/>        val batteryLevel: Int<br/>        if (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) {<br/>            val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager<br/>            batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)<br/>        } else {<br/>            val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))<br/>            batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)<br/>        }<br/><br/>        return batteryLevel<br/>    }<br/><br/>}</span></pre><p id="6df7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到你的 flutter 应用程序并运行它</p><blockquote class="ku kv kw"><p id="9b76" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">下一步是 ios 配置，如果您在 windows 设备上运行，请跳过</p></blockquote><h1 id="b1c7" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">IOS 配置</h1><p id="38f6" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">打开 Xcode 中的 ios 文件夹</p><p id="3bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在 runner 目录下打开 AppDelegate.swift</p><p id="b280" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">方法</strong>中添加这两行</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="9f68" class="mz lr in mv b be na nb l nc nd">let controller : FlutterViewController = window?.rootViewController as! FlutterViewController<br/>    let batteryChannel = FlutterMethodChannel(name: "mediumExplain/battery",<br/>                                              binaryMessenger: controller.binaryMessenger)</span></pre><p id="44eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后加上这个</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="41ce" class="mz lr in mv b be na nb l nc nd">      batteryChannel.setMethodCallHandler({<br/>        (call: FlutterMethodCall, result: @escaping FlutterResult) -&gt; Void in<br/><br/>          guard call.method == "getBatteryLevel" else {<br/>            result(FlutterMethodNotImplemented)<br/>            return<br/>          }<br/>          self.receiveBatteryLevel(result: result)<br/>      })</span></pre><p id="5934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在文件的底部添加这个函数</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="f319" class="mz lr in mv b be na nb l nc nd">private func receiveBatteryLevel(result: FlutterResult) {<br/>  let device = UIDevice.current<br/>  device.isBatteryMonitoringEnabled = true<br/>  if device.batteryState == UIDevice.BatteryState.unknown {<br/>    result(FlutterError(code: "UNAVAILABLE",<br/>                        message: "Battery level not available.",<br/>                        details: nil))<br/>  } else {<br/>    result(Int(device.batteryLevel * 100))<br/>  }<br/>}</span></pre><p id="d44d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你的整个文件应该看起来</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="361c" class="mz lr in mv b be na nb l nc nd">import UIKit<br/>import Flutter<br/><br/>@UIApplicationMain<br/>@objc class AppDelegate: FlutterAppDelegate {<br/>  override func application(<br/>    _ application: UIApplication,<br/>    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?<br/>  ) -&gt; Bool {<br/>      let controller : FlutterViewController = window?.rootViewController as! FlutterViewController<br/>       let batteryChannel = FlutterMethodChannel(name: "mediumExplain/battery",<br/>                                                 binaryMessenger: controller.binaryMessenger)<br/>      batteryChannel.setMethodCallHandler({<br/>        (call: FlutterMethodCall, result: @escaping FlutterResult) -&gt; Void in<br/><br/>          guard call.method == "getBatteryLevel" else {<br/>            result(FlutterMethodNotImplemented)<br/>            return<br/>          }<br/>          self.receiveBatteryLevel(result: result)<br/>      })<br/>    GeneratedPluginRegistrant.register(with: self)<br/>    return super.application(application, didFinishLaunchingWithOptions: launchOptions)<br/>  }<br/>    private func receiveBatteryLevel(result: FlutterResult) {<br/>      let device = UIDevice.current<br/>      device.isBatteryMonitoringEnabled = true<br/>      if device.batteryState == UIDevice.BatteryState.unknown {<br/>        result(FlutterError(code: "UNAVAILABLE",<br/>                            message: "Battery level not available.",<br/>                            details: nil))<br/>      } else {<br/>        result(Int(device.batteryLevel * 100))<br/>      }<br/>    }<br/>}<br/><br/></span></pre><p id="bc1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后从真实的 ios 设备而不是模拟机上运行应用程序</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a7c211ca9e89fd78225400a34b0b34f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*dz88qe_W5D6pvPWX5F9TDA.gif"/></div></figure><h1 id="c47e" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">GitHub 知识库</h1><p id="ca2c" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated"><a class="ae nf" href="https://github.com/mohaberabi/flutter_method_channel" rel="noopener ugc nofollow" target="_blank">https://github.com/mohaberabi/flutter_method_channel</a></p><p id="4c46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读，如果它有助于为我鼓掌</p></div></div>    
</body>
</html>