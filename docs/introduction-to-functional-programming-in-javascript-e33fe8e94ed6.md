# JavaScript 函数式编程介绍—第 1 部分

> 原文：<https://blog.devgenius.io/introduction-to-functional-programming-in-javascript-e33fe8e94ed6?source=collection_archive---------6----------------------->

## 纯函数、参照透明性和等式推理

![](img/760070141414908ceda4f2c705102146.png)

照片由[乔纳森派](https://unsplash.com/@r3dmax?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

*我目前正在学习 JavaScript 的函数式编程。*

所以我决定写下我的发现，以提高我对这个主题的理解，并帮助走上类似道路的人。

尽管总是调查相关来源，并尝试对我文章中的每一个观点进行事实核查，错误还是会发生。所以，如果你注意到我的文章中有任何语法、语义、推理或任何其他类型的错误，请在下面的评论区留下建设性的反馈。

## 有用的来源

*   *“函数式轻 JavaScript”作者凯尔·辛普森(1)*
*   *“编写软件，Javascript 中函数式编程和对象组合的探索”，作者 Eric Elliot (2)*
*   *“弗里斯比教授的函数式编程基本指南”，作者布莱恩·朗斯多夫(3)*
*   *MDN 网络文档/ JavaScript*
*   *维基百科*

# 介绍

本文的目标是分析以下 FP 概念:

*   **纯功能**
*   **参照透明度**
*   **方程式推理**

示例用于展示如何在基于 JS 的应用程序中实现这些概念。

# 论纯函数与副作用

> 一个**纯函数**是一个给定相同输入的函数，将总是返回相同的输出，并且没有任何可观察到的副作用

在继续举例之前，我们需要定义什么是副作用。

首先，一个**效果**是在一个结果的计算中发生的任何事情，除了结果本身。

> **副作用**是在结果的计算过程中，与“外部”世界的可观察到的相互作用，它导致系统状态的改变。

副作用例子有:

*   从 API 中获取数据(或者更一般地说，进行 HTTP 调用)
*   记录到控制台
*   查询和/或改变 DOM
*   处理用户事件(如鼠标点击、输入字段改变等)。)

函数式编程并不禁止在我们的程序中使用副作用。如果是这样的话，那么几乎没有什么程序是有用的。

但是 FP 的目标之一是以一种更加可控和包容的方式执行那些“危险”的计算。

# 非纯函数的例子

**fetchData** 做它所说的。它从一个 API 获取一些数据，但是以一种*不受控制的方式，*所以它被认为是一个副作用。

**简单地记录一个错误。但这也被认为是副作用。**

在这两种情况下，正确的 FP 实现应该是使用 Monad(我计划在以后的文章中解决这个构造)。

**随机数发生器**函数并不纯粹，因为当给定相同的输入时，它并不总是返回相同的输出。这是使用 **Math.random()** 方法的明显结果。

**sum2Numbers** 不好有两个原因。

第一个，与 FP 相关，是函数在其词法范围之外改变状态(变量 *planets* ，从而在系统状态中产生不可预测的变化(这是一个副作用)。

第二个问题与最佳实践有关，即函数的名称会产生误导。除了名字所暗示的之外，这个函数还做了额外的事情，这使得这个函数很难调试。

幸运的是，有一个简单的修复方法，不需要使用单子(或任何其他高级 FP 结构):

这个函数实际上做了它所说的，它在 FP 意义上是纯函数。如果给定相同的输入，它将总是返回相同的输出，并且它也不会改变其词法范围之外的任何系统状态。

# 纯函数的例子

**slice** 是内置的 JS 数组方法。

> **Slice** 将数组的一部分的浅拷贝返回到一个从头到尾选定的新数组对象中(不包括 end ),其中 start 和 end 表示该数组中项的索引。

定义的第一部分解释了为什么这个函数是纯的(不像一个非常相似的内置 JS 数组方法叫做 **splice** 是不纯的)。

最后，****remove vehicletype from inventory**是一个纯函数，因为它不改变传递给它的参数(即 *inventory* 对象)，当给定相同的输入时，它总是返回相同的输出。**

# **浅复制与深复制**

**查看**removevehicletypefromtumentory**函数，我们如何确定它没有修改 *inventory* 对象(位于其作用域之外，并且*作为引用传递)？***

**因为*库存*是在突变发生之前复制的(在函数体中)。**

**另一种确保我们没有改变*库存*对象的方法是冻结它:**

**但是 **Object.freeze** 也浅。很像在**removevehicletypefromtinventory**函数({ … vehicles})中使用的 spread 运算符。**

**因此，如果您在 JS 中对嵌套的、通过引用传递的类型、数据(如对象和数组)的任何属性进行变异，请小心。尤其是当您将数据作为函数参数传递时。**

**如果数据结构更复杂，并且由多个嵌套层组成，那么有几个选项可用于保持数据的不变性；**

*   **使用类似于*JSON . parse(JSON . stringify(obj)*的东西执行深度复制。(但这不是很好的表现)**
*   **用 JS 原语手动浅复制数据结构的每一层，如 *Object.assign* 或 spread (…)操作符。**
*   **使用外部库中的实用函数，如 *Lodash* 来执行深度复制**
*   **在外部库的帮助下使用不可变的数据结构，比如 *Immutable.js* (推荐的方法)**

# **论指称透明性和等式推理**

**纯函数是透明的。**

**这意味着带有特定参数的函数可以在代码中被其计算值完全替换。程序的逻辑也不会受到影响。**

**例如，函数:**

**可以替换为:**

**当试图对代码流进行推理时，这个属性很方便。**

**使用纯函数(引用透明)和不可变数据类型的组合开启了一种特殊的重构和调试 FP 代码的技术，称为**等式推理**。**

**让我们尝试一个例子来展示这种技术的威力。**

**下面是一个非常糟糕的关系匹配算法:**

***mike* 和 *jane* 数据结构是不可变的(借助于 Immutable.js)，**是 CompatibleMatch** 和 **generateMessage** 函数是纯函数。因此，我们可以使用等式推理来更详细地思考代码:**

**这种技术简化了对代码进行推理的过程，因此重构和调试也变得更加容易。**

# ****结论****

**在这篇文章中，我试图用一种初学者友好和可理解的方式来处理一些简单的 FP 概念。**

**我希望你喜欢它。**

**在以后的博客文章中，我计划写一些关于 FP 的其他重要东西，比如不变性(更详细)，部分应用，Currying，Composition，Piping，Point Free style，函子，单子等等。**