<html>
<head>
<title>How TCP Works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TCP 是如何工作的？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tcp-icp-deep-dive-d8497e774bc1?source=collection_archive---------5-----------------------#2022-06-28">https://blog.devgenius.io/tcp-icp-deep-dive-d8497e774bc1?source=collection_archive---------5-----------------------#2022-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="381d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">OSI 模型的层次</strong></h1><ul class=""><li id="dedb" class="ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">这是一个 7 层架构，每一层执行特定的功能。所有这 7 层协同工作，将数据从一个人传输到另一个人</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/1b27d7c582c07cc39e83fd84bfcc2b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*a4uCc_etWl8TS1g6zfZjgw.png"/></div></figure><ul class=""><li id="de77" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated"><strong class="kk io">传输层:</strong>所以有一层负责处理协议(TCP/UDP)。<strong class="kk io">传输层</strong>还负责创建主机之间的端到端连接，主要使用 TCP 和 UDP。</li><li id="3d47" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">所以接下来我们可以找到几层<strong class="kk io">应用层</strong>。应用层接口直接与应用程序交互并提供通用的 web 应用程序服务。当我们编写一个应用程序时，大多数 HTTP 应用程序都运行在这个应用层上。但是 HTTP 已经建立在 TCP/IP 协议之上。</li><li id="c7c3" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">当我们使用 HTTP 时，有一个持久性 HTTP，然后没有持久性 HTTP。<br/> <strong class="kk io">持久性 HTTP</strong>——他们有呃另外两个分支管道有管道和没有管道。</li><li id="c5d2" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">今天，我们将讨论两个网络何时需要连接，以及它们如何通过 TCP 相互连接/对话。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/ca2ee1bf54bdcd96f5941ce3d618a8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmAIVnlWGHORF_HQXzeALA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">TCP 报头格式</figcaption></figure><p id="f5a9" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">让我们看看它们是如何工作的。</p><ul class=""><li id="d174" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">假设客户端是 10.0.1.1，服务器是 10.0.2.1。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mq"><img src="../Images/6bc150deb06dc76bdec53e025dc71917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PN0CLh6r7Z_8960zrFhrIw.png"/></div></div></figure><p id="22ed" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><strong class="kk io">确认</strong></p><ol class=""><li id="ec78" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv mr kx ky kz bi translated">第一步客户端尝试发送消息。</li></ol><ul class=""><li id="221b" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">在第一个请求中，客户端发送一个标志 Syn 标志被启用。它说序列是 0。(这可以是任意随机数，不必是 0。)</li></ul><p id="e0d3" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">2.服务器看到此消息。</p><ul class=""><li id="73a3" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">现在，服务器用 ACK(确认)来响应。这表示 ACK 被设置为 1。(这里 ACK 和 Syn 同时从服务器发送)</li></ul><p id="bcb8" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">3.现在客户端必须确认这个序列，所以客户端发送一个 ACK 给服务器。</p><p id="7c8d" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">4.因此，此时客户机和服务器之间的通信就建立了。</p><p id="bdc5" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><strong class="kk io">窗口更新</strong></p><p id="ffba" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">5.现在有一个可选的调用，叫做“窗口更新”。</p><ul class=""><li id="edcb" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">当彼此通信时，它们共享窗口大小。(在缓冲区填满之前可以发送多少字节)。如果缓冲区已满，则他们向另一端发送缓冲区已满标志，说明由于缓冲区已满，不要发送消息。</li><li id="c987" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">因此，一旦应用程序消耗了缓冲区，缓冲区就会获得一些空闲空间。然后它会发送窗口更新调用，说嘿，现在你可以发送消息了。</li><li id="9acd" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">然后，服务器将窗口更新发送回客户端。(长度为 0)</li></ul><p id="43a7" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><strong class="kk io">消息发送</strong></p><p id="9bdc" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">6.所以 ACK 1 意味着当我们发送序列号时，另一方说这是我下一步期望的。它没有告诉我收到了什么。告诉我接下来会发生什么。</p><p id="7935" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">7.现在服务器想要发送消息。</p><ul class=""><li id="6a07" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">假设服务器发送一个消息“你好客户端”。所以长度是 12。Ack 是 1，SEQ 是 1。</li><li id="8b7a" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">现在另一边计算下一个数=(当前数+这个数的长度字节数)。lask Ack=1，消息长度=12。所以是 1+12=13。</li></ul><p id="7dd3" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">8.现在，服务器将消息发送给客户端，因此客户端必须向服务器发回确认，即确认 13。现在，消息事务完成。</p><p id="46e0" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><strong class="kk io">连接终止:</strong></p><p id="031f" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">9.现在，服务器向客户端发回一条消息，表示它将终止连接。为此，服务器将 Fin 标志发送到 1(完成标志设置为 1)。</p><p id="28e2" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">SEQ 是 13 岁，因为最后一次确认是 13 岁。</p><p id="de70" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">10.现在客户端需要向 Fin 发送确认消息。</p><p id="2107" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">现在 ACK 是 14，因为上一个 SEQ 是 13。</p><p id="e9ea" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">11.所以客户可以终止连接。但与此同时，客户端正在发送其 Fin 数据包。所以 ACK 是 14。SEQ 是 1。</p><p id="ca3d" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">12.所以在服务器端看到消息，它需要向客户端确认。确认=2。SEQ=14。</p><ul class=""><li id="2101" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">此时，消息通信和连接建立完成。</li><li id="c1c1" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">现在看看这些处理是如何实际发生的。在这里，我使用 wireshark 来分析 TCP 是如何工作的。</li><li id="8521" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">对于连接，我们创建了两个程序，一个用于客户端，另一个用于服务器。</li></ul><p id="795d" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><strong class="kk io"> server.js </strong></p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="6cd0" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated"><em class="mu">我将我的服务器设置为在本地主机上的</em> <strong class="kk io"> <em class="mu">端口 42181 上运行。</em> </strong> <em class="mu">当客户端成功连接时，它会发出“你好，客户端”。然后断开。</em></li></ul><p id="0785" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated">client.js</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="5611" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">当我们运行客户端程序时，它也设置为<strong class="kk io">端口 42181。</strong>过一会儿当断线信号到达时，断线。</li><li id="4f0b" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">在 wireshark 中，我选择了我的接口作为<strong class="kk io">回送流量捕获</strong>进行分析。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mv"><img src="../Images/b677cfda3b7c93b53c1106c7b5ccb850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DnnTEpP-ANRuRQ78y97Eg.png"/></div></div></figure><blockquote class="mw mx my"><p id="963e" class="mb mc mu kk b kl li md me kn lj mf mg mz mh mi mj na mk ml mm nb mn mo mp kv ig bi translated">现在，我将过滤这些流量—端口 42181</p></blockquote><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nc"><img src="../Images/24d18b259996b57a278efd804a0d5789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t99OfuunPv1Xf3_xpZombA.png"/></div></div></figure><p id="d4cc" class="pw-post-body-paragraph mb mc in kk b kl li md me kn lj mf mg kp mh mi mj kr mk ml mm kt mn mo mp kv ig bi translated"><em class="mu">所以你可以看到现在没有交通。</em></p><ul class=""><li id="72c3" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">现在我正在启动我的服务器(使用 node server.js)。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mv"><img src="../Images/cea8a3bbbfbaaf074d1f50f1aa49f9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ct6wowrNdKezEMM6vL1u-g.png"/></div></div></figure><ul class=""><li id="27ad" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">仍然没有交通。</li><li id="013c" class="ki kj in kk b kl ln kn lo kp lp kr lq kt lr kv kw kx ky kz bi translated">所以现在我正在运行 client.js 程序。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mv"><img src="../Images/7eb6d927a6edf9987c3c33301ee580f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFt9tgxMc9lz_nUKn1xP0A.png"/></div></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nd"><img src="../Images/cdf35dc05f03d48412ecbd846402120e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPH6EKRQMZtoEiOJDFQW8A.png"/></div></div></figure><ul class=""><li id="c5a2" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">现在让我们看看 wireshark 界面。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ne"><img src="../Images/5deed0b55bb6625a2545f81fae42989d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93IMPAxn2_nzyHIyPQbcIg.png"/></div></div></figure><ul class=""><li id="0109" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">因此，在这里您可以看到，它最初发送 Syn 数据包。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nf"><img src="../Images/4545abe291b45f7efbdd4feeecd0ee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqC5FtKyGzw5ksElqbxHsQ.png"/></div></div></figure><ul class=""><li id="ed52" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">作为回报，服务器发送同步和确认。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ng"><img src="../Images/a9ffb4b49819a5c15c90e824f94213bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LndAHr-hgape7M-zLyE-8w.png"/></div></div></figure><ul class=""><li id="9695" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">在这里你也可以看到窗口更新号。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nh"><img src="../Images/c87cd77b7cd54b45fbf8071dbf54ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhI1epov-dqhT5zVobzCMw.png"/></div></div></figure><ul class=""><li id="2189" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">现在服务器正在发送消息。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ni"><img src="../Images/20e073b032605716f766ba62aee3a675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iSiZsISFZIPr9y1W52WCw.png"/></div></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/12bc9a83d3608f6be070e9dbc46f31a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-9ql_jpM_SuySDh0QhZJA.png"/></div></div></figure><ul class=""><li id="31a5" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">现在服务器终止连接，Fin 标志也被设置。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nk"><img src="../Images/bc44cb2a2be09c120a7fd43a2bd5dabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1XLgBACreMnqQsdSMNnpg.png"/></div></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nl"><img src="../Images/d28d16992d623dc3495873e9b31c97fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4F6A-YkVSRsKxQgPWYekQ.png"/></div></div></figure><ul class=""><li id="7df6" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">然后客户确认这一点。然后客户端也向客户端发送 Fin 标志，正如我们在上面的步骤 11 中所讨论的，然后服务器向其发送确认。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ni"><img src="../Images/c335ff7b1acad3a764c0b1b312df9d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cko28RMqHdvR1rTws1d3Qw.png"/></div></div></figure><ul class=""><li id="9311" class="ki kj in kk b kl li kn lj kp lk kr ll kt lm kv kw kx ky kz bi translated">这就是 TCP 的工作原理。</li></ul><h1 id="f93f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">引用自:</h1><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nm mt l"/></div></figure></div></div>    
</body>
</html>