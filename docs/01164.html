<html>
<head>
<title>React Best Practices — Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—表达式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-best-practices-expressions-6724d83de3f9?source=collection_archive---------26-----------------------#2020-06-25">https://blog.devgenius.io/react-best-practices-expressions-6724d83de3f9?source=collection_archive---------26-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4bb7f07fdf26a85cfadca02e0b210a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pMVazcRorDGThDDO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安妮·斯普拉特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5dd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何种类的应用程序一样，React应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="d58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写React应用程序时的一些最佳实践。</p><h1 id="5a81" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等号两边的空格</h1><p id="fa2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">等号周围应该有空格。</p><p id="8b3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="513e" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello sameName={firstname === lastName} /&gt;;</span></pre><p id="1141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以很容易地看到我们比较的表情。</p><h1 id="3ead" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可以有JSX的文件的文件扩展名</h1><p id="641a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在<code class="fe ms mt mu mj b">.js</code>或<code class="fe ms mt mu mj b">.jsx</code>文件中有JSX代码。</p><p id="5ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道它们是我们React项目的一部分。</p><h1 id="ef31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第一个属性的位置</h1><p id="613c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果第一个属性在一行中，它可以与组件或元素名称在同一行中，</p><p id="a500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可以把它们放到下一行。</p><p id="2401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="598e" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello personal={true} /&gt;</span></pre><p id="d99a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="11af" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello <br/>  personal={true}<br/>  foo="bar"<br/>/&gt;</span></pre><p id="dd0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都易于阅读，不会横向溢出页面。</p><h1 id="e7ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应碎片</h1><p id="8a6f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用React Fragements使我们的生活变得更容易，因为它让我们有一个包装器，而不是呈现任何元素或组件。</p><p id="2f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6634" class="mn lc iq mj b gy mo mp l mq mr">&lt;React.Fragment&gt;&lt;Foo /&gt;&lt;/React.Fragment&gt;</span></pre><p id="2b76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8449" class="mn lc iq mj b gy mo mp l mq mr">&lt;&gt;&lt;Foo /&gt;&lt;/&gt;</span></pre><p id="f39e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简称。</p><p id="ac28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们需要将一个道具传递给一个片段，那么我们必须使用<code class="fe ms mt mu mj b">React.Fragment</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eaf2" class="mn lc iq mj b gy mo mp l mq mr">&lt;React.Fragment key="key"&gt;&lt;Foo /&gt;&lt;/React.Fragment&gt;</span></pre><h1 id="a1b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件处理程序命名约定</h1><p id="398f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的事件处理程序应该有一些命名约定，这样我们可以更容易地找到它们。</p><p id="6d27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能坚持使用像<code class="fe ms mt mu mj b">handle</code>或<code class="fe ms mt mu mj b">on</code>这样的前缀:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb92" class="mn lc iq mj b gy mo mp l mq mr">&lt;MyComponent handleChange={handleChange} /&gt;</span></pre><p id="760b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8549" class="mn lc iq mj b gy mo mp l mq mr">&lt;MyComponent onChange={onChange} /&gt;</span></pre><p id="d14c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道任何带有这些前缀的都是事件处理程序。</p><h1 id="19f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX压痕</h1><p id="c502" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">2个空格是缩进的理想长度。当我们仍然可以看到缩进的时候，它最小化了输入。</p><p id="9d3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选项卡在不同平台上呈现时会有问题，所以最好不要使用它。</p><p id="08ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们可以将空格转换成制表符。</p><p id="997d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd18" class="mn lc iq mj b gy mo mp l mq mr">&lt;App&gt;<br/>  &lt;Hello /&gt;<br/>&lt;/App&gt;</span></pre><p id="8e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在文本编辑器中将制表符转换成两个空格。</p><p id="1cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们这样做，我们可以使用标签。</p><h1 id="d205" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">支柱缩进</h1><p id="573c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果每行有一个道具，那么道具应该缩进。</p><p id="e431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，出于同样的原因，两个空间也是理想的。</p><p id="25e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1050" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello<br/>  firstName="John"<br/>/&gt;</span></pre><p id="6f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以很容易地看到我们的代码。</p><h1 id="4760" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总是在列表中包含关键道具</h1><p id="ee4a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当我们在列表中呈现一个数组时，我们应该添加<code class="fe ms mt mu mj b">key</code> prop。</p><p id="2642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，React可以正确地跟踪。</p><p id="3355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该确保我们传递的是一个独特的值。</p><p id="e5c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a53" class="mn lc iq mj b gy mo mp l mq mr">data.map(item =&gt; &lt;Hello key={item.id}&gt;{item.name}&lt;/Hello&gt;);</span></pre><p id="7948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会从React得到错误，也不会在操作列表时出现意外的行为。</p><h1 id="ec6b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX码的最大深度</h1><p id="9ebc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">嵌套代码很难阅读，所以我们应该尽量减少它们。</p><p id="3030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3944" class="mn lc iq mj b gy mo mp l mq mr">&lt;Foo&gt;<br/>  &lt;Bar /&gt;<br/>&lt;/Foo&gt;</span></pre><p id="45fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ae3a" class="mn lc iq mj b gy mo mp l mq mr">&lt;App&gt;<br/>  &lt;Foo&gt;<br/>    &lt;Bar&gt;<br/>      &lt;Baz /&gt;<br/>    &lt;/Bar&gt;<br/>  &lt;/Foo&gt;<br/>&lt;/App&gt;</span></pre><p id="8945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是嵌套太多了。</p><p id="24d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概3层以上的嵌套对我们的眼睛来说太多了。</p><h1 id="07b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单行的最大道具数</h1><p id="9507" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在一行有太多的道具，因为它会溢出页面。</p><p id="fbf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们在阅读代码时就不用水平滚动了。</p><p id="5f39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以每行使用一个或两个道具:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0dad" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello lastName="Smith" firstName="John" /&gt;;</span></pre><p id="9dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="10ad" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello <br/>  lastName="Smith" <br/>  firstName="John" <br/>/&gt;;</span></pre><p id="b025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不用滚动了。</p><h1 id="1583" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在JSX道具中使用箭头功能</h1><p id="8382" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们不需要在传递的函数中引用<code class="fe ms mt mu mj b">this</code>作为合适的值，那么我们应该使用箭头函数。</p><p id="a597" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们更短，没有自己的<code class="fe ms mt mu mj b">this</code>价值。</p><p id="1e76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="67d5" class="mn lc iq mj b gy mo mp l mq mr">&lt;Foo onClick={() =&gt; console.log('Hello!')}&gt;&lt;/Foo&gt;</span></pre><p id="7562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果需要指定<code class="fe ms mt mu mj b">this</code>的值，需要使用<code class="fe ms mt mu mj b">bind</code>和传统函数。</p><p id="93b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们必须写下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="874e" class="mn lc iq mj b gy mo mp l mq mr">&lt;Foo onClick={function() { console.log(this.foo) }.bind(this)}&gt;&lt;/Foo&gt;</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/65f303cc60cac624f7cc05fd5334f55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RzTd2xtE-Nctpg85"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Annie Spratt </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6a02" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="951a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该减少代码的长度，这样我们就不用水平滚动了。</p><p id="cae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该有太多的嵌套，因为它很难阅读。</p><p id="e576" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不需要通过<code class="fe ms mt mu mj b">bind</code>设置<code class="fe ms mt mu mj b">this</code>的值，可以使用箭头功能。</p><p id="186e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用片段来包装元素，但不想渲染任何东西。</p></div></div>    
</body>
</html>