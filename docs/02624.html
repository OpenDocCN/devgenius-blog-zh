<html>
<head>
<title>Build Automation For Beginners (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为初学者构建自动化(第3部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-automation-for-beginners-part-3-d7f262799dd0?source=collection_archive---------10-----------------------#2020-08-16">https://blog.devgenius.io/build-automation-for-beginners-part-3-d7f262799dd0?source=collection_archive---------10-----------------------#2020-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7950" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">建筑测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/441fbf9e4110a98cef927b0b7b92c1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eRhpO0DD0vEWMrh-neO0A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kv" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="1a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了手动测试，部署所有东西，看看是否有效之外，我至今没有做过任何测试。许多开发人员都坚信单元测试，但是我采用了另一种方法。在微服务领域，服务本身相当简单，但服务之间的协调却很复杂，我认为最好的测试方法是对系统中运行的服务进行测试。在我们的例子中，到目前为止只有一个服务，但是当我们将服务分解成许多小服务时会发生什么呢？单一应用程序中固有的复杂性现在分布在各个服务中。正是这种复杂性导致了我们的大多数问题，所以我们必须通过测试整个系统来克服它。</p><p id="f894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我正在构建一个库，或者一个框架，我仍然会做单元测试。但是我的大部分时间都花在了构建微服务上，而这些微服务并不足以证明单元测试的合理性。所以我一直等到它们被部署，然后我可以创建一套针对真实系统运行的测试。在我看来，这是对时间的更好利用，而且能更快地找到真正的问题。过去，当部署软件很困难时，单元测试是有意义的，因为它们在努力部署之前就发现了许多问题。现在部署可以自动化了，所以我们将重点转移到部署后的测试上。</p><p id="11ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我只是花了几段时间来论证这个可能会引起其他开发者争议的问题。现在让我们开始测试。</p><p id="c57a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是首先，让我提一下，虽然这篇文章的标题是为初学者构建自动化，但这并不意味着它很容易。我们在这里使用非常复杂的工具，其中许多是尖端的，这意味着除了最常见的情况之外，让它们在所有情况下都工作可能会有问题。我所说的“绝对初学者”是指你刚开始时只有一台普通的笔记本电脑和强烈的学习欲望。</p><p id="3769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有太多的编程，大多是其他行业的人所说的后期制作。但是，为了让你拥有成为多面手所需的技能，为了让你在一家要求你面面俱到的初创企业中找到一份高薪工作，你需要学习。所以，如果你无所畏惧，请继续读下去！</p><p id="b9d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文假设您已经阅读了本系列的其他文章，并且已经在您的笔记本电脑上安装了一些东西，包括Docker Desktop、Git和Atom。您可以使用Atom以外的其他编辑器，但我发现它是一个很好的通用工具，可以编辑所有类型的文件。我们将扩展我们在上一篇文章中创建的构建管道，专门用于测试本系列中构建的应用程序。</p><p id="a8c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在测试的这个应用程序与我通常构建的服务只是返回数据的应用程序略有不同。该应用程序获取数据并构建浏览器显示的HTML。我可以写一整篇文章来测试这个应用程序，但是现在我将保持事情简单，只做几个断言。我将获取输出，并确保它被解析为正确的HTML，我将断言第一行包含短语“My Awesome Server”</p><p id="211b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个测试将在Kubernetes下运行，所以我将创建一个包含测试的图像。为了防止测试文件与应用程序文件混淆，但是仍然保持在同一个存储库中，我要做的第一件事是创建一个测试文件夹。回到Atom，右键点击myfirstrepository，选择“新建文件夹”，输入“测试”。我们所有的测试代码都会放在那里。为了确保测试代码没有被添加到我们的应用程序代码中，打开<code class="fe ls lt lu lv b">.dockerignore</code>文件，添加一行“test”。这将防止测试文件夹中的任何内容被添加到应用程序映像中。</p><p id="8a66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该提到，我创建存储库的通常策略是每个工件一个存储库。因此，对于我构建的每个映像，通常我会在一个存储库中拥有构建该工件所需的所有东西，除此之外别无其他。这确保了我们通过允许严格版本控制的二进制存储库共享代码。我总是说“分享很难，但不分享更难。”如果你在开始你的项目时就把分享放在心上，那么如果你在项目变得难以管理后决定把事情分开，那么它们将会变得不那么容易。有了Artifactory或Nexus这样的二进制存储库，你就没有理由不通过适当的渠道分享。</p><p id="6c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我完成了哲学思考，现在回到终端，运行<code class="fe ls lt lu lv b">cd test</code>切换到<code class="fe ls lt lu lv b">test</code>目录，然后运行<code class="fe ls lt lu lv b">npm init</code>。它会问你一堆问题，我只是默认了每个问题。我将从主目录中复制几个文件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4684" class="ma mb iq lv b gy mc md l me mf">cp ../.dockerignore .<br/>cp ../Dockerfile .</span></pre><p id="91b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试文件夹中新docker文件的最后一行将改为:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9385" class="ma mb iq lv b gy mc md l me mf">CMD [ "node", "index.js" ]</span></pre><p id="1c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使节点运行测试的<code class="fe ls lt lu lv b">index.js</code>脚本。</p><p id="f4a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用<a class="ae kv" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>读取服务，使用<a class="ae kv" href="https://github.com/taoqf/node-html-parser" rel="noopener ugc nofollow" target="_blank"> node-html-parser </a>检查返回的html。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6bac" class="ma mb iq lv b gy mc md l me mf">npm install --save node-html-parser axios</span></pre><p id="f8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在测试文件夹中创建文件<code class="fe ls lt lu lv b">index.js</code>，并在其中填入以下内容:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9e45" class="ma mb iq lv b gy mc md l me mf">const axios = require('axios')<br/>const assert = require('assert')<br/>var HTMLParser = require('node-html-parser')</span><span id="6a8d" class="ma mb iq lv b gy mg md l me mf">const SUT_HOST = process.env.SUT_HOST || 'localhost';</span><span id="b9b2" class="ma mb iq lv b gy mg md l me mf">(async function() {<br/>  try {<br/>    const url = `<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/${SUT_HOST}`">http://${SUT_HOST}`</a><br/>    console.log(`Reading ${url}`)<br/>    const response = await axios.get(url)</span><span id="3e01" class="ma mb iq lv b gy mg md l me mf">    const root = HTMLParser.parse(response.data)</span><span id="cfc9" class="ma mb iq lv b gy mg md l me mf">    console.log(`found html ${root}`)</span><span id="6de1" class="ma mb iq lv b gy mg md l me mf">    const h1 = root.querySelector('h1')</span><span id="ef49" class="ma mb iq lv b gy mg md l me mf">    console.log(`found h1 ${h1}`)</span><span id="ab21" class="ma mb iq lv b gy mg md l me mf">    assert.equal('My awesome server!', h1.text)<br/>  } catch (err) {<br/>    console.log(err.stack)<br/>  }<br/>})()</span></pre><p id="5b21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们保持它非常简单！这是可行的，因为在我们的应用程序的输出中只有一个<code class="fe ls lt lu lv b">&lt;h1&gt;</code>标签，否则，我们必须搜索正确的标签。</p><p id="50c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还必须修改Jenkinsfile来构建新的测试映像。我们将复制Kaniko第一次执行的代码行来构建测试:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7c78" class="ma mb iq lv b gy mc md l me mf">steps {<br/>  git '<a class="ae kv" href="https://github.com/rkamradt/myfirstrepository'" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/myfirstrepository'</a><br/>          container(name: 'kaniko') {<br/>            sh "/kaniko/executor \<br/>                --dockerfile `pwd`/Dockerfile \<br/>                --context `pwd` \<br/>                --destination=docker.io/rlkamradt/myfirstrepository:latest"<br/>            sh "/kaniko/executor \<br/>                --dockerfile `pwd`/test/Dockerfile \<br/>                --context `pwd`/test \<br/>                --destination=docker.io/rlkamradt/myfirstrepositorytest:latest"</span></pre><p id="f06d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二次执行中，我们更改了<code class="fe ls lt lu lv b">dockerfile</code>和<code class="fe ls lt lu lv b">context</code>参数以包含<code class="fe ls lt lu lv b">test</code>文件夹，并且在<code class="fe ls lt lu lv b">destination</code>参数中我们给了图像另一个名称。记得控制-s来保存！</p><p id="d815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以提交和推动一切，然后让Jenkins来构建这一切。首先，把这些都上传到GitHub:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="eef3" class="ma mb iq lv b gy mc md l me mf">git status<br/>git add .<br/>git status<br/>git commit -m "added test suite"<br/>git push</span></pre><p id="4945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我在<code class="fe ls lt lu lv b">git add .</code>前后添加了<code class="fe ls lt lu lv b">git status</code>，这是我的一个小习惯，用来仔细检查我将要提交的内容。</p><p id="00a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到Jenkins，您应该能够按下“立即构建”按钮来构建应用程序和测试。</p><p id="c792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该在这里指出，Kaniko在获得DockerHub的授权时遇到了一些问题。似乎如果图像不在DockerHub中，它就不会创建它。Kaniko是由谷歌的团队开发的，常见的情况是使用谷歌仓库而不是DockerHub。这是一个例子，尖端工具专注于使通用路径工作，而忽略了它认为应该工作的其他用例。我手动推送图像，詹金斯管道运行顺利。如果我能缩小问题的范围，我可能会向Kaniko提出一个问题，它是一个非常好的工具，不会不可靠地工作。如果您有类似的问题，请尝试像我们在本系列前面所做的那样手动推送。不管怎样，你可以去DockerHub查看图片是否被推送:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/22fe64afe98feaba0677f6200f4fe988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BgFK0aOagvzgs2dekzpvA.png"/></div></div></figure><h2 id="3f43" class="ma mb iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">运行测试</h2><p id="a3f2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们已经创建了测试映像，我们如何运行它呢？这是一个好问题，因为我们希望在部署服务之前运行我们的测试，那么我们如何在不干扰可能实际存在的部署的情况下部署服务来进行测试呢？答案是名称空间。Kubernetes允许您通过使用名称空间来创建“虚拟”集群。一个服务可以同时存在于不同的名称空间中。到目前为止，我们一直使用“默认”名称空间，这是一个坏主意。我们将创建两个不同的名称空间，<code class="fe ls lt lu lv b">test</code>和<code class="fe ls lt lu lv b">prod</code>。创建名称空间很简单:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9309" class="ma mb iq lv b gy mc md l me mf">kubectl create namespace test<br/>kubectl create namespace prod</span></pre><p id="9ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在大多数<code class="fe ls lt lu lv b">kubectl</code>命令都需要一个<code class="fe ls lt lu lv b">-n</code>参数，例如<code class="fe ls lt lu lv b">kubectl get pods -n test</code>。如果您现在运行它，您将发现没有pod，因为没有部署任何东西。</p><p id="5df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们将运行mongodb，所以我们还需要在每个名称空间中创建一个秘密。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1123" class="ma mb iq lv b gy mc md l me mf">kubectl create secret generic mongo-secret \<br/>    --from-literal=username=mongo \<br/>    --from-literal=password=ognom -n test<br/>kubectl create secret generic mongo-secret \<br/>    --from-literal=username=mongo \<br/>    --from-literal=password=ognom -n prod</span></pre><p id="219b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要能够在Jenkinsfile中运行<code class="fe ls lt lu lv b">kubectl</code>命令。完成这一点最简单的方法是向我们的kaniko-pod.yaml添加一个<code class="fe ls lt lu lv b">kubectl</code>图像。这可能不是完成这一点的最佳方法，因为我们只是为我们的工人pod制作一个大的通用pod，将它们分开可能更好。但是，我们试图让事情尽可能简单。因此，让我们向kaniko-pod.yaml添加一个新容器:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0ef5" class="ma mb iq lv b gy mc md l me mf">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: kaniko<br/>spec:<br/>  containers:<br/>    - name: jnlp<br/>      workingDir: /tmp/jenkins<br/>    - name: kubectl<br/>      image: gcr.io/cloud-builders/kubectl<br/>      workingDir: /tmp/jenkins<br/>      command:<br/>      - cat<br/>      tty: true<br/>    - name: kaniko<br/>      workingDir: /tmp/jenkins<br/>      image: gcr.io/kaniko-project/executor:debug-v0.19.0<br/>      imagePullPolicy: Always<br/>      command:<br/>      - /busybox/cat<br/>      tty: true<br/>      volumeMounts:<br/>        - name: docker-config<br/>          mountPath: /kaniko/.docker<br/>  volumes:<br/>    - name: docker-config<br/>      configMap:<br/>        name: docker-config</span></pre><p id="b83c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个名为<code class="fe ls lt lu lv b">kubectl</code>的带有<code class="fe ls lt lu lv b">gcr.io/cloud-builders/kubectl</code>图像的容器。</p><p id="05bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加到我们的<code class="fe ls lt lu lv b">Jenkinsfile</code>部署中。我们现在还不会费心实际运行测试。编辑Jenkinsfile以填充测试阶段:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f8a5" class="ma mb iq lv b gy mc md l me mf">stage('Test') {<br/>      agent {<br/>        kubernetes {<br/>          label 'kaniko'<br/>          idleMinutes 5<br/>          yamlFile 'kaniko-pod.yaml'<br/>          defaultContainer 'kaniko'<br/>        }<br/>      }<br/>      steps {<br/>        container(name: 'kubectl') {<br/>          sh "kubectl apply -n test -f mongodb.yaml"<br/>          sh "kubectl apply -n test -f myfirstrepository.yaml"<br/>        }<br/>      }<br/>    }</span></pre><p id="d897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Control-s保存并运行常用的<code class="fe ls lt lu lv b">git</code>命令，以推送到GitHub(您现在应该已经记住它们了)。</p><p id="676d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回到Jenkins，按下Build Now按钮，看看它是否部署了测试名称空间中的所有内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/ec903f0148904bd3892a2758caf8ba47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dlaos0eWCPf6dlI2HB_q0A.png"/></div></div></figure><p id="bbde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切看起来都很好，但有一个问题。当我查看测试名称空间中的服务时，我看到了以下内容:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="108c" class="ma mb iq lv b gy mc md l me mf">randalkamradt@Fuji myfirstrepository % kubectl get all -n test<br/>NAME                                                READY   STATUS    RESTARTS   AGE<br/>pod/mongodb-0                                       1/1     Running   0          2m18s<br/>pod/myfirstrepository-deployment-757c4c9b4b-ndw66   1/1     Running   0          2m14s</span><span id="970e" class="ma mb iq lv b gy mg md l me mf">NAME                                TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br/>service/mongodb                     ClusterIP      None            &lt;none&gt;        27017/TCP      2m18s<br/>service/myfirstrepository-service   LoadBalancer   10.107.144.57   &lt;pending&gt;     80:32163/TCP   2m14s</span></pre><p id="df1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">service/myfirstrepository-service</code>有一个&lt;的外部IP等待&gt;。原来我忽略了删除运行在默认名称空间中的服务，您只能有一个服务运行在端口80上。虽然我可以(并且将会)删除在默认名称空间中运行的服务，但这会导致另一个问题，当我最终将它部署到prod名称空间时，我们将会遇到同样的冲突。</p><p id="a487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们只在测试命名空间中测试，所以我不需要向外界公开running，所以我可以将类型设置回ClusterIP，这样我的测试就可以看到它(它将在<a class="ae kv" href="http://myfirstrepository)," rel="noopener ugc nofollow" target="_blank"> http://myfirstrepository、</a>上运行)，但它不会试图占用localhost上的端口80。我也可以给每个名称空间不同的端口，但是我可以以后再做。我的新<code class="fe ls lt lu lv b">myfirstrepository.yaml</code>服务部分将如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1f61" class="ma mb iq lv b gy mc md l me mf">...<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myfirstrepository-service<br/>spec:<br/>  type: ClusterIP<br/>  selector:<br/>    app: myfirstrepository<br/>  ports:<br/>  - port: 80<br/>    targetPort: 3000</span></pre><p id="49bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在某些情况下,<code class="fe ls lt lu lv b">kubectl apply</code>命令无法应用更改，所以让我们向Jenkins文件添加一个<code class="fe ls lt lu lv b">kubectl delete</code>,以确保服务是新创建的，而不仅仅是升级的。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="538e" class="ma mb iq lv b gy mc md l me mf">sh "kubectl delete -n test --ignore-not-found=true \<br/>           -f myfirstrepository.yaml"</span></pre><p id="6247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以通常的方式将所有内容推回GitHub(不要忘记控制-s)。</p><p id="f935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到詹金斯再次运行管道。如果一切正常，在测试名称空间中签出您的服务:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6a16" class="ma mb iq lv b gy mc md l me mf">randalkamradt@Fuji myfirstrepository % kubectl get services -n test                       <br/>NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>mongodb                     ClusterIP   None            &lt;none&gt;        27017/TCP   48m<br/>myfirstrepository-service   ClusterIP   10.104.187.43   &lt;none&gt;        80/TCP      2m34s</span></pre><p id="261e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们只需运行测试应用程序。测试应用程序不是长期运行的应用程序，所以我们不需要部署描述符。我们有几个选择，创建一个作业描述符而不是部署描述符，或者只是作为一个“裸机”运行。因为我是一个简单的人，我将选择简单的方法“裸吊舱”。这只是意味着我们定义了pod并让它运行。我们还可以检查结果，并打印出日志。</p><p id="62b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试将需要一个定义，因此创建一个名为<code class="fe ls lt lu lv b">myfirstrepostiorytest.yaml</code>的文件，并用以下内容填充它:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a211" class="ma mb iq lv b gy mc md l me mf">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: myfirstrepositorytest<br/>spec:<br/>  containers:<br/>    - name: myfirstrepositorytest<br/>      image: rlkamradt/myfirstrepositorytest<br/>      env:<br/>        - name: SUT_HOST<br/>        value: myfirstrepository</span></pre><p id="ae5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，它将运行的主机是<code class="fe ls lt lu lv b">myfirstrepository-service</code> (Kubernetes使用服务的名称创建一个具有该名称的主机，以便名称空间中的其他应用程序可以访问它)。我之前没有解释过，但是SUT主机中的SUT来自于“测试对象”，一个常见的测试缩写。</p><p id="d756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将在Jenkinsfile中添加运行pod的命令。我将收集脚本中的所有命令，然后从Jenkins运行该脚本。创建一个名为<code class="fe ls lt lu lv b">run_test</code>的文件，并填入以下内容:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2d91" class="ma mb iq lv b gy mc md l me mf">kubectl apply -n test -f mongodb.yaml<br/>kubectl delete -n test --ignore-not-found=true -f myfirstrepository.yaml<br/>kubectl apply -n test -f myfirstrepository.yaml<br/>kubectl delete -n test --ignore-not-found=true pod myfirstrepositorytest<br/>kubectl apply -n test -f myfirstrepositorytest.yaml<br/>sleep 20s<br/>kubectl logs -n test myfirstrepositorytest -f --pod-running-timeout=20s<br/>kubectl get -n test pod myfirstrepositorytest \<br/>     -o jsonpath='{.status.containerStatuses[0].lastState.terminated.exitCode}'</span></pre><p id="429a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建或更新任何现有的MongoDB实例，创建一个新的<code class="fe ls lt lu lv b">myfirstrepository</code>和<code class="fe ls lt lu lv b">myfirstrepositorytest</code>实例，等待二十秒钟让系统稳定下来，显示测试实例的日志，并获得退出代码。我不喜欢等待，因为那会使考试变得不靠谱。如果需要更长的时间来稳定，测试将失败。我还没有找到一种好的方法来检查一个pod是否准备好了(通常的方法似乎不可靠)，如果我试图在pod准备好之前访问日志，那么它将失败。</p><p id="c075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让Jenkins能够运行它，我们需要将其设置为可执行的:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5882" class="ma mb iq lv b gy mc md l me mf">chmod +x run_test</span></pre><p id="cf88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在测试阶段将它添加到Jenkinsfile中:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ac13" class="ma mb iq lv b gy mc md l me mf">steps {<br/>  container(name: 'kubectl') {<br/>    sh "./run_test"<br/>  }<br/>}</span></pre><p id="2de7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到pod的名称只是<code class="fe ls lt lu lv b">myfirstrepositorytest</code>，没有添加任何随机字符串。当我们在一个名称空间中部署裸pod时，我们必须注意不要有pod名称冲突。</p><p id="bab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们应用pod定义之后，我们等待它进入就绪状态，然后我们跟踪日志(f标志导致它跟踪)。完成后，log命令将停止，我们将继续下一步。保存一切，提交并推送到GitHub，试一试。在Jenkins中按Build Now，观看它的构建和测试。如果测试工作正常，您应该在构建日志中看到以下内容:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="db41" class="ma mb iq lv b gy mc md l me mf">found h1 &lt;h1&gt;My awesome server!&lt;/h1&gt;<br/>0</span></pre><p id="361a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试工作正常，并返回“0”作为退出代码！</p><p id="cb99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会说这是完整的，但我得到了它的工作。如果你能跟上并让它也能工作，你肯定有勇气在这个行业工作。我喜欢说“编程不难，做产品难。”我们离制造产品只有一步之遥。在本系列的下一篇文章中，我们将部署到生产环境中！感谢您抽出时间与我一起踏上这一旅程，我真诚地希望您能从中有所收获。下次见。</p><p id="9f4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的存储库:</p><div class="nf ng gp gr nh ni"><a href="https://github.com/rkamradt/myfirstrepository/tree/v0.3" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">rkamradt/myfirstrepository</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">我的第一个仓库。通过在GitHub上创建一个帐户，为rkamradt/myfirstrepository开发做出贡献。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><p id="ca1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本系列的其他文章:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/dev-genius/application-programming-for-absolute-beginners-bf2a035efdf6" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">绝对初学者的应用程序设计</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">如何将您的普通Mac笔记本电脑变成一个疯狂的开发怪物</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/dev-genius/application-containers-for-absolute-beginners-253a61bb6e39" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">绝对初学者的应用程序容器</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">为真实世界准备您的应用程序</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ny l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/dev-genius/build-automation-for-absolute-beginners-part-1-73ecf15ebd72" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">为绝对初学者构建自动化(第1部分)</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">自动化应用程序构建、测试和部署</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="nz l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/dev-genius/build-automation-for-absolute-beginners-part-2-244551a4168a" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">为绝对初学者构建自动化(第2部分)</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一键构建、测试和部署应用程序。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="oa l nt nu nv nr nw kp ni"/></div></div></a></div></div></div>    
</body>
</html>