<html>
<head>
<title>Framer Motion — Handling Gestures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成帧器动作-处理手势</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/framer-motion-handling-gestures-3e0312a7ff09?source=collection_archive---------3-----------------------#2021-02-18">https://blog.devgenius.io/framer-motion-handling-gestures-3e0312a7ff09?source=collection_archive---------3-----------------------#2021-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/777a17003c2fed99a126fc3e7906f91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GKnhcA6hWbKu0S02"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰西卡·鲁斯切洛在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6b86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了成帧器运动库，我们可以轻松地在React应用程序中渲染动画。</p><p id="dec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看如何开始与帧运动。</p><h1 id="72ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">手势</h1><p id="1751" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">成帧器动作能够识别手势。</p><p id="c245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1a0a" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="26ea" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;motion.button<br/>      whileHover={{<br/>        scale: 1.2,<br/>        transition: { duration: 1 }<br/>      }}<br/>      whileTap={{ scale: 0.9 }}<br/>    &gt;<br/>      hello world<br/>    &lt;/motion.button&gt;<br/>  );<br/>}</span></pre><p id="91ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们悬停或点击时改变按钮的大小。</p><p id="68f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">scale</code>改变尺寸。<code class="fe mt mu mv mj b">transition.duration</code>设置效果的持续时间。</p><p id="b0a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以设置<code class="fe mt mu mv mj b">variants</code>道具来设置按钮的效果。</p><p id="bebf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e158" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="e50b" class="mn lc iq mj b gy ms mp l mq mr">const variants = {<br/>  buttonVariants: { opacity: 1 },<br/>  iconVariants: { opacity: 0.5 }<br/>};</span><span id="b078" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;motion.button whileTap="tap" whileHover="hover" variants={variants}&gt;<br/>      &lt;svg&gt;<br/>        &lt;motion.path variants={variants} /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/motion.button&gt;<br/>  );<br/>}</span></pre><p id="52d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置<code class="fe mt mu mv mj b">whileTap</code>和<code class="fe mt mu mv mj b">whileHover</code>来设置这些手势的处理程序。</p><p id="0d5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们设置<code class="fe mt mu mv mj b">variants</code>道具来设置我们想要看到的效果。</p><h1 id="35ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">盘旋</h1><p id="5452" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们用<code class="fe mt mu mv mj b">whileHover</code>道具悬停在一个元素上时，我们可以添加动画。</p><p id="0e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b4f" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="5bfa" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;motion.div<br/>      whileHover={{ scale: 1.2 }}<br/>      onHoverStart={(e) =&gt; {<br/>        console.log(e);<br/>      }}<br/>      onHoverEnd={(e) =&gt; {<br/>        console.log(e);<br/>      }}<br/>    &gt;<br/>      hello<br/>    &lt;/motion.div&gt;<br/>  );<br/>}</span></pre><p id="b26d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">onHoverStart</code>和<code class="fe mt mu mv mj b">onHoverEnd</code>道具来听悬停开始和悬停结束事件。</p><p id="5126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">e</code>我们可以得到关于悬停的对象信息。</p><h1 id="c7e7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">轻敲，水龙头</h1><p id="b27c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以用<code class="fe mt mu mv mj b">whileTap</code>道具处理点击事件的动画。</p><p id="3440" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="637b" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="731d" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return &lt;motion.div whileTap={{ scale: 0.8 }}&gt;hello&lt;/motion.div&gt;;<br/>}</span></pre><p id="7551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">whileTap</code>道具设置想要应用的动画效果。</p><p id="9855" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">onTap</code>道具监听敲击声:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5039" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="6560" class="mn lc iq mj b gy ms mp l mq mr">function onTap(event, info) {<br/>  console.log(info.point.x, info.point.y);<br/>}</span><span id="dbfa" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;motion.div onTap={onTap} whileTap={{ scale: 0.8 }}&gt;<br/>      hello<br/>    &lt;/motion.div&gt;<br/>  );<br/>}</span></pre><p id="a7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">onTap</code>功能得到了抽头的位置。</p><p id="ecbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">info.point.x</code>和<code class="fe mt mu mv mj b">info.point.y</code>有攻丝的坐标。</p><h1 id="5b8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">平底锅</h1><p id="c295" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以监听带有帧运动的平移事件。</p><p id="2378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a29c" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="144d" class="mn lc iq mj b gy ms mp l mq mr">function onPan(event, info) {<br/>  console.log(info.point.x, info.point.y);<br/>}</span><span id="3efc" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return &lt;motion.div onPan={onPan}&gt;hello&lt;/motion.div&gt;;<br/>}</span></pre><p id="8b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">去听潘的声音。</p><p id="6510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们拖动div时，<code class="fe mt mu mv mj b">onPan</code>就会运行。</p><p id="2e7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">成帧器运动组件也使用<code class="fe mt mu mv mj b">onPanStart</code>和<code class="fe mt mu mv mj b">onPanEnd</code>道具来监听平移的开始和结束。</p><p id="f5b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3936" class="mn lc iq mj b gy mo mp l mq mr">import { motion } from "framer-motion";<br/>import React from "react";</span><span id="e919" class="mn lc iq mj b gy ms mp l mq mr">function onPan(event, info) {<br/>  console.log(info.point.x, info.point.y);<br/>}</span><span id="ccf7" class="mn lc iq mj b gy ms mp l mq mr">function onPanStart(event, info) {<br/>  console.log(info.point.x, info.point.y);<br/>}</span><span id="34ef" class="mn lc iq mj b gy ms mp l mq mr">function onPanEnd(event, info) {<br/>  console.log(info.point.x, info.point.y);<br/>}</span><span id="f61d" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;motion.div onPan={onPan} onPanStart={onPanStart} onPanEnd={onPanEnd}&gt;<br/>      hello<br/>    &lt;/motion.div&gt;<br/>  );<br/>}</span></pre><h1 id="0bb4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6cd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过成帧器动作库监听各种手势。</p></div></div>    
</body>
</html>