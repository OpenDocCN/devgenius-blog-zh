<html>
<head>
<title>REST API with OIDC, Spring, and FusionAuth.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST API与OIDC、斯普林和福辛纳乌斯。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rest-api-with-oidc-spring-and-fusionauth-f8a7915e4d06?source=collection_archive---------6-----------------------#2022-01-03">https://blog.devgenius.io/rest-api-with-oidc-spring-and-fusionauth-f8a7915e4d06?source=collection_archive---------6-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="0f0b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">目标</h1><p id="ca5d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">本文将创建一个非常简单的Spring应用程序示例，该应用程序使用FusionAuth作为身份提供者，提供一个由OIDC保护的基本REST API。用户将能够有三个角色，“基本”，“编辑”，和“管理”，“管理”提供访问一切。将有一个任何人都可以调用的API端点，一个用于具有“基本”角色的已验证用户的端点，一个用于具有“编辑”角色的用户的端点，以及一个用于“管理”用户的端点。我们还将使用OpenAPI 3和Swagger来记录API，并提供一个Swagger UI来测试我们的调用。</p><p id="56f5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是为那些了解Java和Spring的人准备的。如果您刚刚开始使用其中任何一种，那么在继续本文之前，您可能需要为那些初学者寻找一些资源。此外，这个例子主要是关于用FusionAuth保护REST API，而不是详细研究Spring对REST的支持。</p><h1 id="3b2a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">先决条件</h1><p id="c1ce" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Java(我在示例中使用的是Java 17)</p><p id="5470" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">FusionAuth实例(我正在本地网络上使用安装)</p><p id="fa0a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">curl(或某种访问端点的方式)</p><p id="e867" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Spring Boot、Java和FusionAuth的一些基础知识</p><h1 id="69b9" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">源代码</h1><p id="c4ba" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个例子的源代码可以在https://gitlab.com/welarson/spring-rest-fusionauth-example的<a class="ae ll" href="https://gitlab.com/welarson/spring-rest-fusionauth-example" rel="noopener ugc nofollow" target="_blank">git lab找到</a></p><p id="4818" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有一个名为step1的分支，它拥有完成step1后的源代码。还有一个名为step2的分支，它拥有完成step2后的源代码。最后，有一个名为step4的分支，它拥有位于step4(最后一步)末尾的源代码。主分支是最新的。</p><h1 id="b515" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">步骤1——创建Spring项目</h1><p id="2463" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将从一个非常简单的提供REST API的服务器开始。为了加快速度，让我们在<a class="ae ll" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank"> https://start.spring.io </a>使用Spring Initializr</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/585dcb556b717166d4d82a298d95597d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AP7fJo-mxxMpEG3gJWizZA.png"/></div></div></figure><p id="f350" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于依赖项，我们将只使用Spring Web、Spring Security和OAuth2资源服务器。这就是这个基本例子所需要的。</p><p id="287f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">至于其他选择，这是我在这个例子中要做的。</p><p id="ee8c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">项目:Maven项目(我觉得Maven更常见)</p><p id="a733" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">语言:Java</p><p id="7481" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Spring Boot: 2.6.2(目前最新发布的版本)</p><p id="8636" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Group: net.example</p><p id="505b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">神器:最远的</p><p id="282b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">姓名:farest</p><p id="581f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">描述:用FusionAuth保护的简单REST API</p><p id="628e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">包名:net.example.farest</p><p id="ebb6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">包装:广口瓶</p><p id="8b9b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Java: 17</p><p id="fbfd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这将创建一个名为“farest.zip”的zip文件，其中包含生成的项目。一旦提取出来，这个项目看起来就像这样。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/8728289a60b6f09bd6e19cfbb4e15743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*GSVsALRXyOMzvbDXt3Bt4A.png"/></div></figure><p id="503f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们现在有一个项目模板，但到目前为止它什么都不做。是时候进行第二步了。</p><h1 id="207b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">步骤2——创建REST API</h1><p id="318e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在这一步中，我们将创建一个REST API，创建一个完全不安全的安全配置，以便我们可以访问该API，并添加一个Swagger UI接口，以便我们使用一个漂亮的GUI测试该API。</p><p id="3308" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，让我们添加一个属性来设置服务器将使用的端口。项目生成器将两个空目录和一个空属性文件放在<code class="fe lz ma mb mc b">{root}/src/main/resources</code>目录中。因为Spring也支持在YAML文件中定义属性，所以让我们来代替它。所以删除<code class="fe lz ma mb mc b">{root}/src/main/resources</code>中的所有内容，创建<code class="fe lz ma mb mc b">{root}/src/main/resources/application.yml</code> <strong class="kk io"> </strong>来代替。</p><p id="3d4c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">项目树现在看起来像这样:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/5bc02b607a2dc0f42f960a097844ccb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*-RiUUzJYVHV9EF7gT0UzfQ.png"/></div></figure><p id="3d8a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因为这个项目现在在git中，所以我没有显示隐藏文件和所有与git相关的cruft。此外，您将看到我添加了一个许可证文件，但这对本例来说无关紧要。</p><p id="71d0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，对于应用程序属性，我们唯一需要的是设置服务器端口。我在这个例子中使用9080，但是当然你可以使用任何你想使用的端口，只要记住与你使用的端口保持一致。所以，我们来编辑一下<code class="fe lz ma mb mc b">{root}/src/main/resources/application.yml</code></p><p id="fa4a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> application.yml </strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="5d05" class="mi jl in mc b gy mj mk l ml mm">server:<br/>  port: 9080</span></pre><p id="4282" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">暂时就这样了。</p><p id="4341" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在来定义API。API中的所有端点都是简单的GET方法，只返回允许哪些用户使用API端点、发出调用的用户的身份验证状态以及用户拥有的权限。</p><p id="9391" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们为将从API返回的数据创建一个POJO。我们API中的所有方法都将以相同的格式返回数据，所以我们只需要一个名为… SomeData的类。</p><p id="d855" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们创建一个新包<code class="fe lz ma mb mc b">net.example.farest.model</code>，并在新包中创建类SomeData。我们将使用一个记录类来保持事物的整洁。</p><p id="5650" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">SomeData.java</strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="f0d6" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.model</em>;<br/><br/>public record <em class="mn">SomeData</em>(<em class="mn">String </em>allowed, <br/>                       boolean authenticated,<br/>                       <em class="mn">String </em>authorities) {<br/>}</span></pre><p id="582f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在让我们为我们的API创建REST调用。为此，让我们在名为<code class="fe lz ma mb mc b">net.example.farest.controller</code>的新包中创建一个控制器类BasicController。</p><p id="067d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">BasicController.java</strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="384f" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.controller</em>;<br/><br/>import <em class="mn">net.example.farest.model.SomeData</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.GetMapping</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.RequestMapping</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.RestController</em>;<br/><br/><em class="mn">@RestController<br/>@RequestMapping</em>("/api/v1")<br/>public class <em class="mn">BasicController </em>{<br/><br/>    <em class="mn">@GetMapping</em>("/anyone")<br/>    public <em class="mn">SomeData </em>allowAnyone() {<br/>        return new SomeData("Anyone",<br/>                isAuthenticated(),<br/>                getAuthorities());<br/>    }<br/><br/>    <em class="mn">@GetMapping</em>("/basic")<br/>    public <em class="mn">SomeData </em>allowBasicUser() {<br/>        return new SomeData("Basic User",<br/>                isAuthenticated(),<br/>                getAuthorities());<br/>    }<br/><br/>    <em class="mn">@GetMapping</em>("/editor")<br/>    public <em class="mn">SomeData </em>allowEditorUser() {<br/>        return new SomeData("Editor User",<br/>                isAuthenticated(),<br/>                getAuthorities());<br/>    }<br/><br/>    <em class="mn">@GetMapping</em>("/admin")<br/>    public <em class="mn">SomeData </em>allowAdminUser() {<br/>        return new SomeData("Admin User",<br/>                isAuthenticated(),<br/>                getAuthorities());<br/>    }<br/><br/>    private boolean isAuthenticated() {<br/>        return false;<br/>    }<br/><br/>    private <em class="mn">String </em>getAuthorities() {<br/>        return "";<br/>    }<br/>}</span></pre><p id="da6b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如您所见，基本控制器确实非常简单。因为我们还没有实现任何安全性，所以我们只返回经过验证的状态和权限的占位符。</p><p id="8ab2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">此时，我们有了一个REST API，但是没有安全配置。调用端点只会给出401错误，因为我们使用默认的Spring安全性，并且默认情况下它使用基本的auth。因此，让我们创建另一个新的包，并添加一个不安全的安全配置，以便我们可以使用端点。</p><p id="b592" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们将在新的包<code class="fe lz ma mb mc b">net.example.farest.config</code>中创建SecurityConfig类。</p><p id="d1f5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">SecurityConfig.java</strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="6e06" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.config</em>;<br/><br/>import <em class="mn">org.springframework.context.annotation.Configuration</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.builders.HttpSecurity</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.configuration.</em>WebSecurityConfigurerAdapter;<br/>import <em class="mn">org.springframework.security.config.http.SessionCreationPolicy</em>;<br/><br/><em class="mn">@Configuration<br/>@EnableWebSecurity<br/></em>public class <em class="mn">SecurityConfig </em>extends WebSecurityConfigurerAdapter {<br/><br/>    <em class="mn">@Override<br/>    </em>protected void configure(<em class="mn">HttpSecurity http</em>) throws <em class="mn">Exception </em>{<br/>        <em class="mn">http</em>.cors()<br/>            .and()<br/>                .sessionManagement()<br/>                    .sessionCreationPolicy(<em class="mn">SessionCreationPolicy</em>.STATELESS)<br/>            .and()<br/>                .csrf().disable()<br/>                .authorizeRequests()<br/>                    .anyRequest()<br/>                        .permitAll();<br/>    }<br/>}</span></pre><p id="252a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们快速看一下这个。SecurityConfig扩展了WebSecurityConfigurerAdapter，因此我们继承了很多配置，而不必实现整个WebSecurityConfigurer接口。此外，我们需要用<code class="fe lz ma mb mc b">@Configuration</code>注释SecurityConfig，让Spring知道这个类需要作为配置加载，并用<code class="fe lz ma mb mc b">@EnableWebSecurity</code>注释来指示我们想要激活的安全类型。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="98d8" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Configuration<br/>@EnableWebSecurity<br/></em>public class <em class="mn">SecurityConfig </em>extends WebSecurityConfigurerAdapter {</span></pre><p id="3c2d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们来看看配置本身。虽然我们非常简单的服务不会对CORS配置做任何事情(不要担心，我们稍后仍会处理一些CORS问题)，但通常您需要激活CORS支持。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="9f2e" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">http</em>.cors()</span></pre><p id="746c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，我们指定不使用会话，因为这个REST API服务是无状态的。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="ba25" class="mi jl in mc b gy mj mk l ml mm">.sessionManagement()<br/>    .sessionCreationPolicy(<em class="mn">SessionCreationPolicy</em>.STATELESS)</span></pre><p id="efdc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">由于我们不使用会话，我们也不需要CSRF保护，因此我们将禁用它。同样，因为这个服务非常简单，所以这并不重要，但是，一般来说，如果您的API是无状态的，您应该禁用CSRF保护。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="fe60" class="mi jl in mc b gy mj mk l ml mm">.csrf().disable()</span></pre><p id="182b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最后，我们将配置访问端点所需的内容。此时，我们将只允许来自任何人的所有请求，无论是否经过身份验证。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="2e97" class="mi jl in mc b gy mj mk l ml mm">.authorizeRequests()<br/>    .anyRequest()<br/>        .permitAll();</span></pre><p id="77df" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在让我们试一试。</p><p id="8367" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">从项目目录的根目录运行Maven命令来构建和打包项目。</p><p id="ef81" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">./mvnw package</code></p><p id="ce63" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后执行Spring应用程序。</p><p id="a5af" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">java -jar target/farest-0.0.1-SNAPSHOT.jar</code></p><p id="16e6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在使用curl来练习应用程序的端点。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="931e" class="mi jl in mc b gy mj mk l ml mm">curl <a class="ae ll" href="http://localhost:9080/api/v1/anyone" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/api/v1/anyone</a></span><span id="8ddb" class="mi jl in mc b gy mo mk l ml mm">curl <a class="ae ll" href="http://localhost:9080/api/v1/anyone" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/api/v1/</a>basic</span><span id="8e2f" class="mi jl in mc b gy mo mk l ml mm">curl <a class="ae ll" href="http://localhost:9080/api/v1/anyone" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/api/v1/</a>editor</span><span id="d7e7" class="mi jl in mc b gy mo mk l ml mm">curl <a class="ae ll" href="http://localhost:9080/api/v1/anyone" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/api/v1/</a>admin</span></pre><p id="55ea" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您应该看到JSON向我们展示了谁(理论上在这一点上)被允许使用端点，而身份验证总是为假，并且没有权威机构存在。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/cc74528a6742772e90c6ae38409d6f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*j-ko6gsuC9OStSfLdrMyIg.png"/></div></figure><p id="3673" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用curl来测试端点并不特别方便，而且一旦我们获得了API，使用curl来测试端点就不那么方便了，所以现在让我们将Swagger的UI添加到组合中。由于Swagger的UI是基于OpenAPI 3文档构建的，这意味着我们也将添加API文档。</p><p id="356d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们将使用OpenAPI 3的Springdoc实现，它不是由我们当前的任何依赖项提供的，所以让我们将这些依赖项添加到我们的Maven pom.xml文件中。首先，让我们添加一个包含我们将使用的Springdoc实现版本的属性。目前，最新版本是1.6.3，所以我们将使用它。</p><p id="1f3d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">在pom.xml中… </strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="c337" class="mi jl in mc b gy mj mk l ml mm">...<br/>&lt;properties&gt;<br/>   &lt;java.version&gt;17&lt;/java.version&gt;<br/>   <strong class="mc io">&lt;springdoc.version&gt;1.6.3&lt;/springdoc.version&gt;</strong><br/>&lt;/properties&gt;<br/>...</span></pre><p id="2d7f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们将添加实际的依赖项，使用版本的新属性。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="dfbe" class="mi jl in mc b gy mj mk l ml mm">...<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><strong class="mc io">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springdoc&lt;/groupId&gt;<br/>   &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;<br/>   &lt;version&gt;${springdoc.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springdoc&lt;/groupId&gt;<br/>   &lt;artifactId&gt;springdoc-openapi-data-rest&lt;/artifactId&gt;<br/>   &lt;version&gt;${springdoc.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/></strong>...</span></pre><p id="a331" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在让我们为rest控制器BasicController添加一些注释，以便更好地记录事情。</p><p id="d51d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">在BasicController.java中… </strong></p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="f5db" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">...<br/></em><strong class="mc io"><em class="mn">@Operation</em>(summary = "Get some data for anyone")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json", <br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})</strong><br/><em class="mn">@GetMapping</em>("/anyone")<br/>public <em class="mn">SomeData </em>allowAnyone() {<br/>    return new SomeData("Anyone",<br/>            isAuthenticated(),<br/>            getAuthorities());<br/>}<br/><br/><strong class="mc io"><em class="mn">@Operation</em>(summary = "Get some data for basic users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})</strong><br/><em class="mn">@GetMapping</em>("/basic")<br/>public <em class="mn">SomeData </em>allowBasicUser() {<br/>    return new SomeData("Basic User",<br/>            isAuthenticated(),<br/>            getAuthorities());<br/>}<br/><br/><strong class="mc io"><em class="mn">@Operation</em>(summary = "Get some data for editor users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})</strong><br/><em class="mn">@GetMapping</em>("/editor")<br/>public <em class="mn">SomeData </em>allowEditorUser() {<br/>    return new SomeData("Editor User",<br/>            isAuthenticated(),<br/>            getAuthorities());<br/>}<br/><br/><strong class="mc io"><em class="mn">@Operation</em>(summary = "Get some data for admin users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})</strong><br/><em class="mn">@GetMapping</em>("/admin")<br/>public <em class="mn">SomeData </em>allowAdminUser() {<br/>    return new SomeData("Admin User",<br/>            isAuthenticated(),<br/>            getAuthorities());<br/>}<br/>...</span></pre><p id="1ed4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">@Operation注释让我们提供端点所做工作的摘要，而@ApiResponses注释提供了可能响应的描述。为了简单起见，我们将只记录成功的结果以及响应数据的类型和形状。</p><p id="c133" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果您再次构建并启动应用程序，您现在可以在<code class="fe lz ma mb mc b"><a class="ae ll" href="http://localhost:9080/v3/api-docs" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/v3/api-docs</a></code>访问OpenAPI文档</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mq"><img src="../Images/4e72e53fd0e5c664916c211a2e7c49e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZOx2RDadYREi5rMqLb_dg.png"/></div></div></figure><p id="084d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这很好，但是我们需要为REST服务提供一个实际的UI。可以在<code class="fe lz ma mb mc b"><a class="ae ll" href="http://localhost:9040/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config</a></code>访问</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/794a1256d9e0e68eda97bc40544663c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgbAE_uCRGpH0MmUMAoVcA.png"/></div></div></figure><p id="3762" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">很好。但是你会注意到标题是版本0的“OpenAPI定义”。我们可以通过更多的改变来改善这一点。首先，我们将对Maven pom.xml文件进行另一项添加，以提供我们的服务构建信息。我们通过在spring-boot-maven-plugin声明中添加一个执行来做到这一点。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="6dcc" class="mi jl in mc b gy mj mk l ml mm">...<br/>&lt;plugin&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>   <strong class="mc io">&lt;executions&gt;<br/>      &lt;execution&gt;<br/>         &lt;id&gt;build-info&lt;/id&gt;<br/>         &lt;goals&gt;<br/>            &lt;goal&gt;build-info&lt;/goal&gt;<br/>         &lt;/goals&gt;<br/>      &lt;/execution&gt;<br/>   &lt;/executions&gt;</strong><br/>&lt;/plugin&gt;<br/>...</span></pre><p id="bbf5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们将使用OpenApi3Config类向<code class="fe lz ma mb mc b">net.example.farest.config</code>包添加另一个配置。</p><p id="43aa" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">【OpenApi3Config.java T4】</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="126f" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.config</em>;<br/><br/>import <em class="mn">io.swagger.v3.oas.models.OpenAPI</em>;<br/>import <em class="mn">io.swagger.v3.oas.models.info.Info</em>;<br/>import <em class="mn">org.springframework.beans.factory.annotation.Autowired</em>;<br/>import <em class="mn">org.springframework.boot.info.BuildProperties</em>;<br/>import <em class="mn">org.springframework.context.annotation.Bean</em>;<br/>import <em class="mn">org.springframework.context.annotation.Configuration</em>;<br/><br/><em class="mn">@Configuration<br/></em>public class <em class="mn">OpenApi3Config </em>{<br/>    private final <em class="mn">BuildProperties </em>buildProperties;<br/><br/>    <em class="mn">@Autowired<br/>    </em>public OpenApi3Config(<em class="mn">BuildProperties buildProperties</em>) {<br/>      this.buildProperties = <em class="mn">buildProperties</em>;<br/>    }<br/><br/>    <em class="mn">@Bean<br/>    </em>public <em class="mn">OpenAPI </em>openAPI() {<br/>      return new OpenAPI()<br/>        .info(new Info()<br/>        .title("Simple Example REST Service")<br/>        .description("""<br/>Simple REST Service used to demonstrate<br/>securing a Spring REST service with<br/>FusionAuth.<br/>                     """)<br/>        .version(buildProperties.getVersion())<br/>      );<br/>    }<br/>}</span></pre><p id="7427" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们所做的只是为OpenAPI提供一个标题、描述和当前版本。项目结构现在将如下所示。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/591ebdddd74d57cd2d81fc424458e852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*6o79PbTQgiG5xmAgGLAXgA.png"/></div></figure><p id="286f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在重新构建并再次运行服务器，然后再次加载Swagger UI(IntelliJ IDE提示，在从IDE再次运行之前，使用Maven编译任务或重新构建项目，否则将不会创建BuildProperties对象。)<code class="fe lz ma mb mc b"><a class="ae ll" href="http://localhost:9040/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config</a></code></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/9478cd37d97155fa3a0cec4465da56a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75vR2q08SnKEosJnLwqkmg.png"/></div></div></figure><p id="4e69" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">那更好。现在，如果我们尝试一个端点(使用“尝试”然后“执行”按钮)，我们得到预期的结果。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/6c9339e913e139470d9747d6281a4660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsWTxZAjlDaiootqFLXSQQ.png"/></div></div></figure><p id="3124" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们可以使用/api/v1/admin端点，因为我们允许所有内容，并获得占位符值。</p><p id="4ba7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个简单的例子显然不适合生产环境，所以我们不用担心在生产环境中禁用OpenAPI 3文档和Swagger，但这可以通过几个springdoc属性轻松完成。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="7515" class="mi jl in mc b gy mj mk l ml mm">springdoc.api-docs.enabled=false<br/>springdoc.swagger-ui.enabled=false</span></pre><p id="a099" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">好了，我们现在有了一个简单的REST API和文档以及一个测试UI。现在让我们用融合术来保护它。</p><h1 id="9894" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">步骤3 —在FusionAuth中创建一个租户和应用程序</h1><p id="c6d2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我在我的本地网络yorktown.net.lan上安装了FusionAuth，您需要替换托管FusionAuth实例的地址(或者如果它安装在您用来构建示例的同一台机器上，则只替换localhost)。我在端口9011上运行FusionAuth，这是安装FusionAuth时的默认端口。本文不打算介绍如何设置FusionAuth安装，但是您可以在FusionAuth的网站<a class="ae ll" href="https://fusionauth.io" rel="noopener ugc nofollow" target="_blank"> https://fusionauth.io </a>上找到您需要的所有信息。</p><p id="26bd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们将从一个新的租户开始，以避免与您可能已经在FusionAuth实例上设置的任何其他应用程序的设置发生冲突。</p><p id="dca2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在创建租户之前，让我们创建一个用于它的密钥。根据我的经验，使用默认密钥会导致Spring OAuth 2库出现问题，但是生成一个新的RSA密钥就可以了。为此，点击FusionAuth侧边栏中的“设置”，然后选择“密钥管理器”。从显示“生成椭圆”的下拉列表中，选择“生成RSA”选项，并生成一个名为“Example Key”的RSA密钥对。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/e12bcc6830ab0c4b90867456f51f90bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0uEFPyS-Oj5ksLcp9LZBQ.png"/></div></div></figure><p id="7041" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们准备创建一个租户。点击侧边栏中的“租户”，然后点击添加按钮(带加号的那个)。给新租户一个名称“Example ”,我们将对发行者使用“example.net”。</p><p id="ddb0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">作为一个公平的警告，我提到点击带有磁盘图标的蓝色按钮来保存很多次，因为我很容易忘记它。抱歉，如果它变得重复。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/b3818f6e640e3d07c27fd8cefa0f14a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsF5NxZRBFaE8MWcM6fALw.png"/></div></div></figure><p id="aa99" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在切换到“JWT”选项卡，并将“访问令牌签名密钥”和“Id令牌签名密钥”的值都设置为“示例密钥(RS256)”。(截图是在编辑中，不是添加，但是UI是一样的。)</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/1bd62ac557d6d561db89c5289a8fa5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x0H3UxNBx_kG3SbMTfMZw.png"/></div></div></figure><p id="6d6d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">通过单击带有磁盘图标的蓝色按钮来保存新租户。</p><p id="0e36" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们需要添加一个新的应用程序。点击侧边栏上的“应用程序”并添加一个新的。我们将应用程序命名为“SimpleREST”。为租户选择“示例”。然后添加我们的三个角色，基本、编辑和管理。“基本”应该是默认角色，而“管理员”是超级角色。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/301c43802d6e57f2b904a6d82c8caa3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSknsqu7S1-PqoK582JXRA.png"/></div></div></figure><p id="ae00" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">再次单击蓝色磁盘按钮进行保存。现在，单击编辑我们的新应用程序并设置OAuth设置。我们需要做的唯一更改是添加一个授权的重定向URL:<a class="ae ll" href="http://localhost:9080/swagger-ui/oauth2-redirect.html" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/swagger-ui/oauth 2-redirect . html</a>。在这里，复制“客户端Id”和“客户端机密”的值，因为我们稍后会用到它们。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/540b72de1d0fc83995bfa2c329e2517a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Et5bFOG1O17gpCBdUZ-EQ.png"/></div></div></figure><p id="4700" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">单击蓝色磁盘按钮保存应用程序，现在添加一个新用户。将租户设置为“Example”，然后输入电子邮件和用户名。由于我们没有为租户或应用程序设置电子邮件，因此关闭发送电子邮件选项以设置密码并手动创建密码(可能需要记下该密码，因为您稍后会需要它)。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/c1cb5807391ba81cab3a28c0253b4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YX1Fd2zl7S0sUdgcRQiDwQ.png"/></div></div></figure><p id="04d3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">保存用户。这应该会将您带到新用户的详细信息页面。在这里，向SimpleREST应用程序注册用户。我现在只给用户分配基本角色。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/89252401d13706c4709ae418f875f929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiTQEknJhgDZoQRh6ND8IA.png"/></div></div></figure><p id="5760" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">快到了。我承诺了一个CORS问题，现在我们要解决它。我们需要添加一些CORS设置，让我们的Swagger-UI为FusionAuth进行登录。选择FusionAuth侧边栏上的“设置”，然后选择“系统”并编辑CORS滤波器。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/e802634416bce4eef13128dfe06fa2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqAbgAqqA34yYl37kYBUgQ.png"/></div></div></figure><p id="f353" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">记得再次用蓝色磁盘按钮保存。</p><p id="31e3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">好了，FusionAuth已经为我们的应用程序设置好了。是时候回到java代码并保护它了。</p><h1 id="dbcd" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">步骤4 —保护REST服务</h1><p id="bbf2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们需要给我们的<code class="fe lz ma mb mc b">application.yml</code>添加一些属性来处理所有这些OAuth的东西。您的FusionAuth实例的配置值应该在<code class="fe lz ma mb mc b">{FusionAuth Instance Address}/.well-known/openid-configuration</code>可用。您可能会注意到发行者并不是我们之前设置的“example.net”。这是因为这是默认租户，而不是我们创建的租户。我们可以使用tenantId查询参数来指定租户，但是所有重要的东西都是一样的。我们将使用另一个属性来设置正确的发行者。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mv"><img src="../Images/bd2532d3494a290aeab37375181202fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNg46GJeVzrsQlABojEGZA.png"/></div></div></figure><p id="906b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Spring将能够通过使用openid配置信息来配置issuer-uri中的大多数值。然而，我们还需要为JWT解码器的实现设置jwk-set-uri值。所以我们将设置属性<code class="fe lz ma mb mc b">spring.security.oauth2.resourceserver.jwt.issuer-uri</code>和<code class="fe lz ma mb mc b">spring.security.oauth2.resourceserver.jwt.jwk-set-uri</code>。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="49eb" class="mi jl in mc b gy mj mk l ml mm">spring:<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          jwk-set-uri: http://yorktown.net.lan:9011/.well-known/jwks.json<br/>          issuer-uri: http://yorktown.net.lan:9011/</span></pre><p id="3597" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后，我们将添加一些我们自己的属性，我们将使用这些属性来提供适当的颁发者，并为我们的OpenAPI3配置提供一些值。发行者属性将是<code class="fe lz ma mb mc b">oidc.issuer</code>，并设置为“example.net”以匹配我们的租户。授权端点将被设置为<code class="fe lz ma mb mc b">oidc.auth-url</code>，令牌_端点将被设置为<code class="fe lz ma mb mc b">oidc.token-url</code>。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="0d57" class="mi jl in mc b gy mj mk l ml mm">oidc:<br/>  issuer: example.net<br/>  auth-url: http://yorktown.net.lan:9011/oauth2/authorize<br/>  token-url: http://yorktown.net.lan:9011/oauth2/token</span></pre><p id="c811" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Swagger UI必须实际进行登录，因此它需要我们在FusionAuth中创建SimpleREST应用程序时复制下来的client-id和client-secret值。这将允许Swagger执行一个用户登录的验证码流。在实际的应用程序中，您不希望将原始值放在yml文件中，但是对于这个简单的示例来说，它可以做到。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="96ee" class="mi jl in mc b gy mj mk l ml mm">spring:<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          jwk-set-uri: http://yorktown.net.lan:9011/.well-known/jwks.json<br/>          issuer-uri: http://yorktown.net.lan:9011/</span></pre><p id="af7c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">结尾<code class="fe lz ma mb mc b">application.yml</code>应该是这样的:</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="eaff" class="mi jl in mc b gy mj mk l ml mm">server:<br/>  port: 9080<br/><br/>spring:<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          jwk-set-uri: http://yorktown.net.lan:9011/.well-known/jwks.json<br/>          issuer-uri: http://yorktown.net.lan:9011/<br/><br/>oidc:<br/>  issuer: example.net<br/>  auth-url: http://yorktown.net.lan:9011/oauth2/authorize<br/>  token-url: http://yorktown.net.lan:9011/oauth2/token<br/><br/>springdoc:<br/>  swagger-ui:<br/>    oauth:<br/>      client-id: &lt;YOUR CLIENT ID&gt;<br/>      client-secret: &lt;YOUR CLIENT SECRET&gt;</span></pre><p id="0142" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们需要对我们的安全配置做一些大的改变，但是其中一部分将告诉Spring如何计算用户的权限。如果任其自生自灭，Spring将添加一个名为“ROLE_USER”的角色，并将任何OAuth2范围添加到用户的权限中。然而，我们想要的是我们在FusionAuth中为用户定义的角色。为此，我们将为从JWT到身份验证令牌的转换器创建自己的实现。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="683e" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.security</em>;<br/><br/>import <em class="mn">org.springframework.core.convert.converter.Converter</em>;<br/>import <em class="mn">org.springframework.security.authentication.</em>AbstractAuthenticationToken;<br/>import <em class="mn">org.springframework.security.authentication.UsernamePasswordAuthenticationToken</em>;<br/>import <em class="mn">org.springframework.security.core.GrantedAuthority</em>;<br/>import <em class="mn">org.springframework.security.core.authority.SimpleGrantedAuthority</em>;<br/>import <em class="mn">org.springframework.security.oauth2.jwt.Jwt</em>;<br/>import <em class="mn">org.springframework.util.</em>StringUtils;<br/><br/>import <em class="mn">java.util.Arrays</em>;<br/>import <em class="mn">java.util.Collection</em>;<br/>import <em class="mn">java.util.Collections</em>;<br/>import <em class="mn">java.util.stream.Collectors</em>;<br/><br/>public class <em class="mn">OidcJwtAuthConverter </em>implements <em class="mn">Converter</em>&lt;<em class="mn">Jwt</em>, AbstractAuthenticationToken&gt; {<br/>    private static final <em class="mn">String </em>EMAIL_CLAIM = "email";<br/>    private static final <em class="mn">String </em>ROLES_CLIAM = "roles";<br/><br/>  <em class="mn">@Override<br/>  </em>public AbstractAuthenticationToken convert(final <em class="mn">Jwt jwt</em>) {<br/>    return new UsernamePasswordAuthenticationToken(<br/>            getUserName(<em class="mn">jwt</em>), "n/a", getAuthorities(<em class="mn">jwt</em>));<br/>  }<br/><br/>  private <em class="mn">String </em>getUserName(final <em class="mn">Jwt jwt</em>) {<br/>        return <em class="mn">jwt</em>.getClaimAsString(EMAIL_CLAIM);<br/>    }<br/><br/>  private <em class="mn">Collection</em>&lt;<em class="mn">GrantedAuthority</em>&gt; getAuthorities(final <em class="mn">Jwt jwt</em>) {<br/>    return this.getRoles(<em class="mn">jwt</em>).stream()<br/>      .map(<em class="mn">role </em>-&gt; new SimpleGrantedAuthority(<em class="mn">role</em>.toLowerCase()))<br/>      .collect(<em class="mn">Collectors</em>.<em class="mn">toSet</em>());<br/>  }<br/><br/>  private <em class="mn">Collection</em>&lt;<em class="mn">String</em>&gt; getRoles(final <em class="mn">Jwt jwt</em>) {<br/>    final var claim = <em class="mn">jwt</em>.getClaims().get(ROLES_CLIAM);<br/>    if (claim instanceof <em class="mn">String roles </em>&amp;&amp; StringUtils.<em class="mn">hasText</em>(<em class="mn">roles</em>)) {<br/>      return <em class="mn">Arrays</em>.<em class="mn">asList</em>(<em class="mn">roles</em>.split(" "));<br/>    }<br/>    if (claim instanceof <em class="mn">Collection</em>&lt;?&gt; <em class="mn">roles</em>) {<br/>      return <em class="mn">roles</em>.stream()<br/>              .map(<em class="mn">Object</em>::toString)<br/>              .collect(<em class="mn">Collectors</em>.<em class="mn">toSet</em>());<br/>    }<br/>    return <em class="mn">Collections</em>.<em class="mn">emptyList</em>();<br/>  }<br/>}</span></pre><p id="e4e7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这也是将您可能需要的任何附加用户信息加载到usernamepasswordtauthenticationtoken的绝佳位置。第一个参数(Principal)是一个对象，所以当我们将它设置为用户的电子邮件地址时，您可以放入任何您想要表示用户的对象。</p><p id="4925" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">至于权威，我们将从“角色”声明中得到它们。FusionAuth将提供该声明中的角色作为集合。</p><p id="9324" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在让我们修改我们的安全配置。新的安全配置如下所示。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="f567" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.config</em>;<br/><br/>import <em class="mn">net.example.farest.security.OidcJwtAuthConverter</em>;<br/>import <em class="mn">org.springframework.beans.factory.annotation.Autowired</em>;<br/>import <em class="mn">org.springframework.beans.factory.annotation.Value</em>;<br/>import <em class="mn">org.springframework.boot.autoconfigure.security.oauth2.resource.OAuth2ResourceServerProperties</em>;<br/>import <em class="mn">org.springframework.context.annotation.Bean</em>;<br/>import <em class="mn">org.springframework.context.annotation.Configuration</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.builders.HttpSecurity</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity</em>;<br/>import <em class="mn">org.springframework.security.config.annotation.web.configuration.</em>WebSecurityConfigurerAdapter;<br/>import <em class="mn">org.springframework.security.config.http.SessionCreationPolicy</em>;<br/>import <em class="mn">org.springframework.security.oauth2.jwt.JwtDecoder</em>;<br/>import <em class="mn">org.springframework.security.oauth2.jwt.JwtValidators</em>;<br/>import <em class="mn">org.springframework.security.oauth2.jwt.NimbusJwtDecoder</em>;<br/><br/><em class="mn">@Configuration<br/>@EnableWebSecurity<br/>@EnableGlobalMethodSecurity</em>(prePostEnabled = true)<br/>public class <em class="mn">SecurityConfig </em>extends WebSecurityConfigurerAdapter {<br/>  private final <em class="mn">OAuth2ResourceServerProperties </em>oauth2Properties;<br/>  private final <em class="mn">String </em>issuer;<br/><br/>  <em class="mn">@Autowired<br/>  </em>public SecurityConfig(<em class="mn">OAuth2ResourceServerProperties oauth2Properties</em>,<br/>                        <em class="mn">@Value</em>("${oidc.issuer}") <em class="mn">String issuer</em>) {<br/>    this.oauth2Properties = <em class="mn">oauth2Properties</em>;<br/>    this.issuer = <em class="mn">issuer</em>;<br/>  }<br/><br/>  <em class="mn">@Override<br/>  </em>protected void configure(<em class="mn">HttpSecurity http</em>) throws <em class="mn">Exception </em>{<br/>    <em class="mn">http</em>.cors()<br/>      .and()<br/>        .sessionManagement()<br/>          .sessionCreationPolicy(<em class="mn">SessionCreationPolicy</em>.STATELESS)<br/>      .and()<br/>        .csrf().disable()<br/>        .authorizeRequests()<br/>          .antMatchers("/api/v1/anyone").permitAll()<br/>          .antMatchers("/swagger-ui/**").permitAll()<br/>          .antMatchers("/v3/api-docs/**").permitAll()<br/>          .anyRequest()<br/>            .fullyAuthenticated()<br/>      .and()<br/>        .oauth2ResourceServer()<br/>          .jwt()<br/>            .jwtAuthenticationConverter(new OidcJwtAuthConverter());<br/>  }<br/><br/>  <em class="mn">@Bean<br/>  </em>public <em class="mn">JwtDecoder </em>jwtDecoder() {<br/>    final var jwtDecoder =<br/>      <em class="mn">NimbusJwtDecoder</em>.<em class="mn">withJwkSetUri</em>(oauth2Properties.getJwt().getJwkSetUri())<br/>              .build();<br/>    final var withIssuer = <em class="mn">JwtValidators</em>.<em class="mn">createDefaultWithIssuer</em>(issuer);<br/>    jwtDecoder.setJwtValidator(withIssuer);<br/>    return jwtDecoder;<br/>  }<br/>}</span></pre><p id="1390" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们添加了一个值为<code class="fe lz ma mb mc b">prePostEnabled=true</code>的<code class="fe lz ma mb mc b">@EnableGlobalMethodSecurity</code>注释。这将允许我们使用注释来指定访问端点所需的权限。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="d1f9" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">...<br/>@Configuration<br/>@EnableWebSecurity<br/></em><strong class="mc io"><em class="mn">@EnableGlobalMethodSecurity</em>(prePostEnabled = true)</strong><br/>public class <em class="mn">SecurityConfig </em>extends WebSecurityConfigurerAdapter {<br/>...</span></pre><p id="f02f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们以前不需要注入任何bean或值，但是随着我们的配置更加复杂，我们将需要具有Spring的OAuth2属性的bean。除此之外，我们还需要为我们的租户定义的发布者(“example.net”)，它位于oidc.issuer属性中。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="8b89" class="mi jl in mc b gy mj mk l ml mm">...<br/>public class <em class="mn">SecurityConfig </em>extends WebSecurityConfigurerAdapter {<br/>  <strong class="mc io">private final <em class="mn">OAuth2ResourceServerProperties </em>oauth2Properties;<br/>  private final <em class="mn">String </em>issuer;<br/><br/>  <em class="mn">@Autowired<br/>  </em>public SecurityConfig(<em class="mn">OAuth2ResourceServerProperties oauth2Properties</em>,<br/>                        <em class="mn">@Value</em>("${oidc.issuer}") <em class="mn">String issuer</em>) {<br/>    this.oauth2Properties = <em class="mn">oauth2Properties</em>;<br/>    this.issuer = <em class="mn">issuer</em>;<br/>  }</strong><br/>...</span></pre><p id="9a13" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们的HTTPSecurity配置开始时是一样的，但是我们不允许任何人的任何请求，而是只允许任何人的少数请求。在我们的API中，任何人都可以使用一个端点，无论是否经过身份验证，因此需要允许所有人都使用一个端点。我们还需要允许未经认证的用户访问api文档和Swagger UI，这样我们就可以测试我们的API。所有其他请求都要求用户经过完全身份验证。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="4677" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">...<br/>@Override<br/></em>protected void configure(<em class="mn">HttpSecurity http</em>) throws <em class="mn">Exception </em>{<br/>  <em class="mn">http</em>.cors()<br/>    .and()<br/>      .sessionManagement()<br/>        .sessionCreationPolicy(<em class="mn">SessionCreationPolicy</em>.STATELESS)<br/>    .and()<br/>      .csrf().disable()<br/>      .authorizeRequests()<br/>        <strong class="mc io">.antMatchers("/api/v1/anyone").permitAll()<br/>        .antMatchers("/swagger-ui/**").permitAll()<br/>        .antMatchers("/v3/api-docs/**").permitAll()<br/>        .anyRequest()<br/>          .fullyAuthenticated()</strong><br/>...</span></pre><p id="644b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，我们需要指定我们的身份验证将由OAuth2提供。为此，我们使用oauth2ResourceServer()配置，并告诉它我们希望使用我们的客户转换器OidcJwtAuthConverter将JWT令牌转换为身份验证实例。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="3655" class="mi jl in mc b gy mj mk l ml mm">...<br/><em class="mn">@Override<br/></em>protected void configure(<em class="mn">HttpSecurity http</em>) throws <em class="mn">Exception </em>{<br/>  <em class="mn">http</em>.cors()<br/>    .and()<br/>      .sessionManagement()<br/>        .sessionCreationPolicy(<em class="mn">SessionCreationPolicy</em>.STATELESS)<br/>    .and()<br/>      .csrf().disable()<br/>      .authorizeRequests()<br/>        .antMatchers("/api/v1/anyone").permitAll()<br/>        .antMatchers("/swagger-ui/**").permitAll()<br/>        .antMatchers("/v3/api-docs/**").permitAll()<br/>        .anyRequest()<br/>          .fullyAuthenticated()<br/>    <strong class="mc io">.and()<br/>      .oauth2ResourceServer()<br/>        .jwt()<br/>          .jwtAuthenticationConverter(new OidcJwtAuthConverter());</strong><br/>}<br/>...</span></pre><p id="37eb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还需要提供一个JWT解码器bean。Spring的OAuth库为我们提供了NimbusJwtDecoder，所以我们将使用它来构建我们的JwtDecoder，给它我们在Spring的OAuth属性中设置的jwt-set-uri。然后我们为发行者创建自己的验证器，因为Spring无法为我们的租户计算出正确的值。我们告诉解码器使用发行者验证并返回解码器。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="c8dc" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">...<br/></em><strong class="mc io"><em class="mn">@Bean<br/></em>public <em class="mn">JwtDecoder </em>jwtDecoder() {<br/>  final var jwtDecoder =<br/>    <em class="mn">NimbusJwtDecoder</em>.<em class="mn">withJwkSetUri</em>(oauth2Properties.getJwt().getJwkSetUri())<br/>            .build();<br/>  final var withIssuer = <em class="mn">JwtValidators</em>.<em class="mn">createDefaultWithIssuer</em>(issuer);<br/>  jwtDecoder.setJwtValidator(withIssuer);<br/>  return jwtDecoder;<br/>}</strong><br/>...</span></pre><p id="45a1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，让我们修改REST控制器，根据用户的权限限制对端点的访问，并实际判断用户是否经过身份验证并列出权限。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="5de7" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.controller</em>;<br/><br/>import <em class="mn">io.swagger.v3.oas.annotations.Operation</em>;<br/>import <em class="mn">io.swagger.v3.oas.annotations.media.Content</em>;<br/>import <em class="mn">io.swagger.v3.oas.annotations.media.Schema</em>;<br/>import <em class="mn">io.swagger.v3.oas.annotations.responses.ApiResponse</em>;<br/>import <em class="mn">io.swagger.v3.oas.annotations.responses.ApiResponses</em>;<br/>import <em class="mn">net.example.farest.model.SomeData</em>;<br/>import <em class="mn">org.springframework.security.access.prepost.PreAuthorize</em>;<br/>import <em class="mn">org.springframework.security.core.Authentication</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.GetMapping</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.RequestMapping</em>;<br/>import <em class="mn">org.springframework.web.bind.annotation.RestController</em>;<br/><br/><em class="mn">@RestController<br/>@RequestMapping</em>("/api/v1")<br/>public class <em class="mn">BasicController </em>{<br/><br/>    <em class="mn">@Operation</em>(summary = "Get some data for anyone")<br/>    <em class="mn">@ApiResponses</em>({<br/>      <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>        description = "Success",<br/>        content = {<br/>          <em class="mn">@Content</em>(mediaType = "application/json",<br/>            schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>    })<br/>    <em class="mn">@GetMapping</em>("/anyone")<br/>    <em class="mn">@PreAuthorize</em>("permitAll()")<br/>    public <em class="mn">SomeData </em>allowAnyone(<em class="mn">Authentication authentication</em>) {<br/>        return new SomeData("Anyone",<br/>                isAuthenticated(<em class="mn">authentication</em>),<br/>                getAuthorities(<em class="mn">authentication</em>));<br/>    }<br/><br/>    <em class="mn">@Operation</em>(summary = "Get some data for basic users")<br/>    <em class="mn">@ApiResponses</em>({<br/>      <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>        description = "Success",<br/>        content = {<br/>          <em class="mn">@Content</em>(mediaType = "application/json",<br/>            schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>    })<br/>    <em class="mn">@GetMapping</em>("/basic")<br/>    <em class="mn">@PreAuthorize</em>("hasAuthority('basic') or hasAuthority('admin')")<br/>    public <em class="mn">SomeData </em>allowBasicUser(<em class="mn">Authentication authentication</em>) {<br/>        return new SomeData("Basic User",<br/>                isAuthenticated(<em class="mn">authentication</em>),<br/>                getAuthorities(<em class="mn">authentication</em>));<br/>    }<br/><br/>    <em class="mn">@Operation</em>(summary = "Get some data for editor users")<br/>    <em class="mn">@ApiResponses</em>({<br/>      <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>        description = "Success",<br/>        content = {<br/>          <em class="mn">@Content</em>(mediaType = "application/json",<br/>            schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>    })<br/>    <em class="mn">@GetMapping</em>("/editor")<br/>    <em class="mn">@PreAuthorize</em>("hasAuthority('editor') or hasAuthority('admin')")<br/>    public <em class="mn">SomeData </em>allowEditorUser(<em class="mn">Authentication authentication</em>) {<br/>        return new SomeData("Editor User",<br/>                isAuthenticated(<em class="mn">authentication</em>),<br/>                getAuthorities(<em class="mn">authentication</em>));<br/>    }<br/><br/>    <em class="mn">@Operation</em>(summary = "Get some data for admin users")<br/>    <em class="mn">@ApiResponses</em>({<br/>      <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>        description = "Success",<br/>        content = {<br/>          <em class="mn">@Content</em>(mediaType = "application/json",<br/>            schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>    })<br/>    <em class="mn">@GetMapping</em>("/admin")<br/>    <em class="mn">@PreAuthorize</em>("hasAuthority('admin')")<br/>    public <em class="mn">SomeData </em>allowAdminUser(<em class="mn">Authentication authentication</em>) {<br/>        return new SomeData("Admin User",<br/>                isAuthenticated(<em class="mn">authentication</em>),<br/>                getAuthorities(<em class="mn">authentication</em>));<br/>    }<br/><br/>    private boolean isAuthenticated(<em class="mn">Authentication authentication</em>) {<br/>        return <em class="mn">authentication </em>!= null &amp;&amp; <em class="mn">authentication</em>.isAuthenticated();<br/>    }<br/><br/>    private <em class="mn">String </em>getAuthorities(<em class="mn">Authentication authentication</em>) {<br/>        return isAuthenticated(<em class="mn">authentication</em>)<br/>                ? <em class="mn">authentication</em>.getAuthorities().toString()<br/>                : "";<br/>    }<br/>}</span></pre><p id="19e5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有了更新的安全配置，我们可以使用@PreAuthorize注释来设置端点方法的安全性。端点/api/v1/anyone对于任何人都是允许的，所以我们将允许每个人访问它。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="71ee" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Operation</em>(summary = "Get some data for anyone")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})<br/><em class="mn">@GetMapping</em>("/anyone")<br/><strong class="mc io"><em class="mn">@PreAuthorize</em>("permitAll()")</strong><br/>public <em class="mn">SomeData </em>allowAnyone(<em class="mn">Authentication authentication</em>) {<br/>    return new SomeData("Anyone",<br/>            isAuthenticated(<em class="mn">authentication</em>),<br/>            getAuthorities(<em class="mn">authentication</em>));<br/>}</span></pre><p id="7100" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">端点/api/v1/basic可供具有“基本”或“管理”角色的用户使用，因此我们将使用一个允许“基本”权限或“管理”权限的表达式。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="c750" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Operation</em>(summary = "Get some data for basic users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})<br/><em class="mn">@GetMapping</em>("/basic")<br/><strong class="mc io"><em class="mn">@PreAuthorize</em>("hasAuthority('basic') or hasAuthority('admin')")</strong><br/>public <em class="mn">SomeData </em>allowBasicUser(<em class="mn">Authentication authentication</em>) {<br/>    return new SomeData("Basic User",<br/>            isAuthenticated(<em class="mn">authentication</em>),<br/>            getAuthorities(<em class="mn">authentication</em>));<br/>}</span></pre><p id="bdf4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">端点/api/v1/editor可供具有“编辑”或“管理”角色的用户使用，因此我们将使用一个允许“编辑”权限或“管理”权限的表达式。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="0c6a" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Operation</em>(summary = "Get some data for editor users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})<br/><em class="mn">@GetMapping</em>("/editor")<br/><strong class="mc io"><em class="mn">@PreAuthorize</em>("hasAuthority('editor') or hasAuthority('admin')")</strong><br/>public <em class="mn">SomeData </em>allowEditorUser(<em class="mn">Authentication authentication</em>) {<br/>    return new SomeData("Editor User",<br/>            isAuthenticated(<em class="mn">authentication</em>),<br/>            getAuthorities(<em class="mn">authentication</em>));<br/>}</span></pre><p id="4067" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">端点/api/v1/admin仅对admin用户可用，因此表达式将只允许具有“admin”权限的用户。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="b2c7" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Operation</em>(summary = "Get some data for admin users")<br/><em class="mn">@ApiResponses</em>({<br/>  <em class="mn">@ApiResponse</em>(responseCode = "200",<br/>    description = "Success",<br/>    content = {<br/>      <em class="mn">@Content</em>(mediaType = "application/json",<br/>        schema = <em class="mn">@Schema</em>(implementation = <em class="mn">SomeData</em>.class))})<br/>})<br/><em class="mn">@GetMapping</em>("/admin")<br/><strong class="mc io"><em class="mn">@PreAuthorize</em>("hasAuthority('admin')")</strong><br/>public <em class="mn">SomeData </em>allowAdminUser(<em class="mn">Authentication authentication</em>) {<br/>    return new SomeData("Admin User",<br/>            isAuthenticated(<em class="mn">authentication</em>),<br/>            getAuthorities(<em class="mn">authentication</em>));<br/>}</span></pre><p id="4bbb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还需要用实际的实现替换我们的isAuthenticated()和getAuthorities()方法。所有的端点现在都有一个认证参数，Spring会自动为我们填充这个参数。然后，我们可以将该身份验证实例传递给更新后的方法，以获取身份验证和授权信息。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="bea0" class="mi jl in mc b gy mj mk l ml mm"><strong class="mc io">private boolean isAuthenticated(<em class="mn">Authentication authentication</em>) {<br/>    return <em class="mn">authentication </em>!= null &amp;&amp; <em class="mn">authentication</em>.isAuthenticated();<br/>}<br/><br/>private <em class="mn">String </em>getAuthorities(<em class="mn">Authentication authentication</em>) {<br/>    return isAuthenticated(<em class="mn">authentication</em>)<br/>            ? <em class="mn">authentication</em>.getAuthorities().toString()<br/>            : "";<br/>}</strong></span></pre><p id="c857" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们的REST API现在是安全的，但是我们仍然需要配置我们的Swagger UI，以便我们有一个方便的测试工具。让我们给OpenAPI3Config类添加一些安全设置。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="f0c4" class="mi jl in mc b gy mj mk l ml mm">package <em class="mn">net.example.farest.config</em>;<br/><br/>import <em class="mn">io.swagger.v3.oas.models.Components</em>;<br/>import <em class="mn">io.swagger.v3.oas.models.OpenAPI</em>;<br/>import <em class="mn">io.swagger.v3.oas.models.info.Info</em>;<br/><strong class="mc io">import <em class="mn">io.swagger.v3.oas.models.security.</em>*;</strong><br/>import <em class="mn">org.springframework.beans.factory.annotation.Autowired</em>;<br/>import <em class="mn">org.springframework.beans.factory.annotation.Value</em>;<br/>import <em class="mn">org.springframework.boot.info.BuildProperties</em>;<br/>import <em class="mn">org.springframework.context.annotation.Bean</em>;<br/>import <em class="mn">org.springframework.context.annotation.Configuration</em>;<br/><br/>import <em class="mn">java.util.List</em>;<br/><br/><em class="mn">@Configuration<br/></em>public class <em class="mn">OpenApi3Config </em>{<br/>  private final <em class="mn">BuildProperties </em>buildProperties;<br/>  <strong class="mc io">private final <em class="mn">String </em>authUrl;<br/>  private final <em class="mn">String </em>tokenUrl;</strong><br/><br/>  <em class="mn">@Autowired<br/>  </em>public OpenApi3Config(<em class="mn">BuildProperties buildProperties</em><strong class="mc io">,<br/>                        <em class="mn">@Value</em>("${oidc.auth-url}") <em class="mn">String authUrl</em>,<br/>                        <em class="mn">@Value</em>("${oidc.token-url}") <em class="mn">String tokenUrl</em></strong>) {<br/>    this.buildProperties = <em class="mn">buildProperties</em>;<br/>    <strong class="mc io">this.authUrl = <em class="mn">authUrl</em>;<br/>    this.tokenUrl = <em class="mn">tokenUrl</em>;</strong><br/>  }<br/><br/>  <em class="mn">@Bean<br/>  </em>public <em class="mn">OpenAPI </em>openAPI() {<br/>    return new OpenAPI()<br/>      <strong class="mc io">.components(new Components()<br/>        .addSecuritySchemes("oauth2", new SecurityScheme()<br/>          .type(<em class="mn">SecurityScheme</em>.<em class="mn">Type</em>.OAUTH2)<br/>          .description("OAuth2 Flow")<br/>          .flows(new OAuthFlows()<br/>            .authorizationCode(new OAuthFlow()<br/>              .authorizationUrl(authUrl)<br/>              .tokenUrl(tokenUrl)<br/>              .scopes(new Scopes())<br/>            )<br/>          )<br/>        )<br/>      )<br/>      .security(<em class="mn">List</em>.<em class="mn">of</em>(new SecurityRequirement()<br/>              .addList("oauth2")))</strong><br/>      .info(new Info()<br/>        .title("Simple Example REST Service")<br/>        .description("""<br/>Simple REST Service used to demonstrate<br/>securing a Spring REST service with<br/>FusionAuth.<br/>                     """)<br/>        .version(buildProperties.getVersion())<br/>    );<br/>  }<br/>}</span></pre><p id="7e38" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以让我们快速看一下这里发生了什么。首先，我们需要从应用程序属性中注入一些值，这样我们就可以在OAuth流中配置授权url和令牌url。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="c212" class="mi jl in mc b gy mj mk l ml mm"><em class="mn">@Configuration<br/></em>public class <em class="mn">OpenApi3Config </em>{<br/>  private final <em class="mn">BuildProperties </em>buildProperties;<br/>  <strong class="mc io">private final <em class="mn">String </em>authUrl;<br/>  private final <em class="mn">String </em>tokenUrl;</strong><br/><br/>  <em class="mn">@Autowired<br/>  </em>public OpenApi3Config(<em class="mn">BuildProperties buildProperties</em><strong class="mc io">,<br/>                        <em class="mn">@Value</em>("${oidc.auth-url}") <em class="mn">String authUrl</em>,<br/>                        <em class="mn">@Value</em>("${oidc.token-url}") <em class="mn">String tokenUrl</em></strong>) {<br/>    this.buildProperties = <em class="mn">buildProperties</em>;<br/>    <strong class="mc io">this.authUrl = <em class="mn">authUrl</em>;<br/>    this.tokenUrl = <em class="mn">tokenUrl</em>;</strong><br/>  }</span></pre><p id="f9a7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，我们将实际的安全方案添加到OpenAPI配置中。我们使用OAUTH2类型的安全性，并添加一个授权代码流来认证用户。我们需要配置授权url和令牌url，以便Swagger可以执行登录操作。我们不关心示波器，所以我们就让它空着。因为我们还为客户端id和secret添加了springdoc属性，所以Swagger用户不必知道这些值就可以执行身份验证流程。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="b53b" class="mi jl in mc b gy mj mk l ml mm">...<br/>return new OpenAPI()<br/>      <strong class="mc io">.components(new Components()<br/>        .addSecuritySchemes("oauth2", new SecurityScheme()<br/>          .type(<em class="mn">SecurityScheme</em>.<em class="mn">Type</em>.OAUTH2)<br/>          .description("OAuth2 Flow")<br/>          .flows(new OAuthFlows()<br/>            .authorizationCode(new OAuthFlow()<br/>              .authorizationUrl(authUrl)<br/>              .tokenUrl(tokenUrl)<br/>              .scopes(new Scopes())<br/>            )<br/>          )<br/>        )<br/>      )<br/>...</strong></span></pre><p id="f982" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最后，我们将安全方案添加到API的已配置安全需求列表中。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="c5c5" class="mi jl in mc b gy mj mk l ml mm"><strong class="mc io">...<br/>      .security(<em class="mn">List</em>.<em class="mn">of</em>(new SecurityRequirement()<br/>              .addList("oauth2")))</strong><br/>      .info(new Info()<br/>...</span></pre><p id="c08d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">是时候再次构建和执行服务了。</p><pre class="ln lo lp lq gt me mc mf mg aw mh bi"><span id="91e6" class="mi jl in mc b gy mj mk l ml mm">./mvnw package</span><span id="81b9" class="mi jl in mc b gy mo mk l ml mm">java -jar target/farest-0.0.1-SNAPSHOT.jar</span></pre><p id="aa84" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我建议打开一个私有或匿名窗口进行测试，以避免与同时登录FusionAuth实例发生冲突。我们可能还好，因为它是一个不同的租户，但这是一个少担心的事情。现在使用Swagger url来打开Swagger。<a class="ae ll" href="http://localhost:9080/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/swagger-ui/index . html？configUrl =/v3/API-docs/swagger-config</a></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/c3df1e69addc75f61ecde7412e585b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmjRnQ0vEqKVkJQT65fl8w.png"/></div></div></figure><p id="f0fe" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">你会看到现在有一个“授权”按钮。单击该按钮将允许我们使用FusionAuth进行身份验证。然而，在认证之前，让我们尝试几个端点。首先，我们将尝试我们配置为每个人都可以访问的/api/v1/anyone端点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/1f52d086fd0da490cc27309de722798a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FShdhm4zZpMUsIkuSDNVqg.png"/></div></div></figure><p id="23d0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">它工作，我们被告知用户是未经认证的，没有权力。当然，这正是以前的工作方式。</p><p id="d111" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，让我们试试/api/v1/basic，它需要一个具有“basic”或“admin”角色的认证用户。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/b68a0d02cb9574e9bdc7f93e6fc3b009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYlh-rYzkFWqo5F7Z4M7eQ.png"/></div></div></figure><p id="7be5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这一次，我们得到一个401错误，因为用户未经身份验证。到目前为止，一切顺利。</p><p id="24d4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，单击“授权”按钮，我们将看到一个对话框，显示可用的授权。唯一可用的是OAuth2授权码。client_id和client_secret字段是预先填充的，因此我们不必担心它们。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/2bbb8807b9bb9b7756d2568494e42090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9WbPKIjpH2rXwJLWr3oLQ.png"/></div></div></figure><p id="4296" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">点击“授权”会将我们带到FusionAuth进行身份验证。继续，以我们在FusionAuth中创建的基本用户身份登录。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/31ad7c7b195b5d713b8b833216baa0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5N4cNiPhaaytF6U3BX619w.png"/></div></div></figure><p id="8da4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这让我们回到了斯瓦格。关闭授权对话框，让我们再次尝试/api/v1/anyone端点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/a34a3a6c0600bbbe3c76599b3271a48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DW9NH79aVgfdpYiVQUEPpw.png"/></div></div></figure><p id="501e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">调用再次成功，但是现在我们可以看到用户已经过身份验证，并且拥有“基本”权限。</p><p id="ce42" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在让我们再次尝试/api/v1/basic端点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/aa387d94773b738e548b7bb41105c5a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4tibhy8H1g4sS3TFB4QCg.png"/></div></div></figure><p id="2afb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">与上次不同，这次调用是成功的，再次告诉我们用户已经过身份验证，并且拥有“基本”权限。</p><p id="bda9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最后，让我们试试/api/v1/admin端点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/19aff463468a18cd20264fc114d73bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RDOA0OHhhNXPsqWX0X5Zg.png"/></div></div></figure><p id="ee69" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们得到一个403禁止错误，因为用户已经过身份验证，但是没有使用端点所需的权限。您可以随意尝试其他权威机构的用户，但是您可能已经准备好结束本文了。</p><p id="86ed" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如您所见，实现FusionAuth支持并不需要太多代码，而且在很大程度上，相同的代码也适用于其他身份提供者。Spring会为您处理大部分工作。即使添加对Swagger UI的支持也不需要太多的努力，尽管从文档中并不总是显而易见如何做。</p><p id="5983" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我希望这对你有所帮助。</p><p id="cb55" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如前所述，你可以在Gitlab的<a class="ae ll" href="https://gitlab.com/welarson/spring-rest-fusionauth-example" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/welarson/spring-rest-fusionauth-example</a>找到这个例子的源代码。</p><p id="3002" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">编码快乐！</p></div></div>    
</body>
</html>