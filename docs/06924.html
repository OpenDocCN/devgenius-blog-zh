<html>
<head>
<title>Common hashCode Issues Every Java Developer Faces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个 Java 开发人员都面临的常见 hashCode 问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/common-hashcode-issues-every-java-developer-faces-dfc61c9a119e?source=collection_archive---------3-----------------------#2022-02-12">https://blog.devgenius.io/common-hashcode-issues-every-java-developer-faces-dfc61c9a119e?source=collection_archive---------3-----------------------#2022-02-12</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="5d81" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">这就是为什么你应该知道更多关于 equals 和 hashCode 的知识</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/2ff76f44bf4d1a37d30886a10821d98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ohfKrEcajajQN4Lg.png"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://www.pexels.com/@andres-ayrton?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安德烈斯·埃尔顿</a>从<a class="ae ks" href="https://www.pexels.com/photo/black-bearded-man-typing-on-laptop-at-home-6578421/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="2641" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b">hashCode</code>和<code class="fe lp lq lr ls b">equals</code>有什么区别？可以用<code class="fe lp lq lr ls b">hashCode</code>实现<code class="fe lp lq lr ls b">equals</code>吗？定制<code class="fe lp lq lr ls b">hashCode</code>有什么好处？不好的<code class="fe lp lq lr ls b">hashCode</code>有哪些坏处？</p><p id="7a51" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这些都可以到你下次求职面试的时候。它们在我的上面。</p><p id="717a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们深入了解一下<code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>方法。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="eeee" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">有哪些常见的<code class="fe lp lq lr ls b">hashCode</code>问题？</h1><p id="f140" class="pw-post-body-paragraph kt ku ir kv b kw ms js ky kz mt jv lb lc mu le lf lg mv li lj lk mw lm ln lo ik bi translated"><code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>有什么区别？我们可以用<code class="fe lp lq lr ls b">hashCode</code>来比较物体吗？你会在 Java 开发人员面试中听到这些。大部分开发者回答错误。</p><p id="f7c2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这是有经验的开发者常见的面试问题。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="516e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b">hashCode</code>用在哪里？<code class="fe lp lq lr ls b">HashSet</code>能出什么问题？对于不相等的对象，<code class="fe lp lq lr ls b">hashCode</code>应该总是返回不同的整数吗？</p><p id="11a7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">哈希对于<code class="fe lp lq lr ls b">HashSets</code>来说是必不可少的。不相等对象的相同散列会使散列集变得毫无意义。相同对象的不同散列会导致讨厌的错误。我们会继续讨论这个问题。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="1a05" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">为什么不可变散列很重要？应该使用哪些字段来计算它？hashCode 的默认实现是什么？</p><p id="96cc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">假设你有一个<code class="fe lp lq lr ls b">HashMap</code>。你还没有覆盖<code class="fe lp lq lr ls b">Customer</code>的<code class="fe lp lq lr ls b">hashCode</code>方法。所有字段都用于计算哈希值。你用<code class="fe lp lq lr ls b">Customer</code>它作为<code class="fe lp lq lr ls b">Cart</code>一张地图的钥匙。在您更改了<code class="fe lp lq lr ls b">Customer</code>的一个字段后，散列将会改变。</p><p id="5b5a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="mx">你将无法为旧的未修改的</em> <code class="fe lp lq lr ls b"><em class="mx">Customer</em></code> <em class="mx">实例检索值作为键。</em></p><p id="64e8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这意味着你需要一个不可变的<code class="fe lp lq lr ls b">hashCode</code>方法。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="8d7c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">为什么<code class="fe lp lq lr ls b">hashCode</code>很重要？现在我们有了不可变的<code class="fe lp lq lr ls b">Records</code>来解决这个问题。<code class="fe lp lq lr ls b">Records</code>生成<code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>方法。为什么要担心这些方法呢？</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="c5e3" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">关于<code class="fe lp lq lr ls b">hashCode</code>你应该知道什么？</h1><p id="7ef7" class="pw-post-body-paragraph kt ku ir kv b kw ms js ky kz mt jv lb lc mu le lf lg mv li lj lk mw lm ln lo ik bi translated">让我们更深入地研究记录，以及它们生成的<code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>方法。</p><p id="fccb" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b">Records</code>默认生成这些方法。所有的<code class="fe lp lq lr ls b">Record</code>字段都被标记为<code class="fe lp lq lr ls b">private final</code>，使得它们不可改变。</p><p id="dded" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b">Records</code>会有什么问题？它们有不可变的字段，这反过来会生成一个好的散列。对吗？这是对的，但也有可能出错。</p><p id="f24b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">没有什么可以阻止您在记录中添加可变字段。可变字段不能很好地与自动生成的<code class="fe lp lq lr ls b">hashCode</code>和<code class="fe lp lq lr ls b">equals</code>方法一起工作。这里有什么问题？</p><p id="2b14" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">记录提供了浅层不变性。您可以添加可变的数组或其他字段类型。这意味着您生成的<code class="fe lp lq lr ls b">hashCode</code>和<code class="fe lp lq lr ls b">equals</code>也需要被覆盖。<code class="fe lp lq lr ls b">hashCode</code>只能从不可变字段计算。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="8492" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Piotr <a class="ae ks" href="https://softwaregarden.dev/en/posts/new-java/records/should-write-equals-and-hashcode/" rel="noopener ugc nofollow" target="_blank">写了一个很好的例子</a>来说明散列和记录是如何产生奇怪的错误的。</p><p id="2bf7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有问题的记录是 Rekord。上面有创建时间和仓库列表的糖果条。</p><pre class="kh ki kj kk gu my ls mz na aw nb bi"><span id="14c0" class="nc mb ir ls b gz nd ne l nf ng">public record Rekord(Instant created, List&lt;String&gt; locations) {}</span></pre><p id="562e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们总结一下他发现的问题。</p><ol class=""><li id="e9cf" class="nh ni ir kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">创建了两个糖果条。</li><li id="bb81" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">两者都被添加到一个盒子中，该盒子是一个<code class="fe lp lq lr ls b">HashMap&lt;Rekord&gt;</code></li><li id="2c3e" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">两块糖都变了</li><li id="2026" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">两者都被放回盒子里，前提是它们将取代之前的糖果棒</li><li id="5a06" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">盒子的总尺寸是 4</li></ol><p id="bee7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所有 4 块糖都有不同的哈希值。这就是为什么我们得到 4 个“独特的”糖果条——hashcode-wise。虽然它们是相同的。<code class="fe lp lq lr ls b">HashMap</code>将两对相同的实例存储为 4 个不同的元素。这些实例在哈希方面是不同的。</p><p id="b936" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">看到这一点，我们仍然需要了解<code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>是如何工作的。尽管我们有闪亮的<code class="fe lp lq lr ls b">Record</code>和我们在一起。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="823c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b">HashSets</code>和性能怎么样？我们的<code class="fe lp lq lr ls b">hashCode</code>方法如何在<code class="fe lp lq lr ls b">HashSets</code>上禁用常量访问或 O(1)？</p><p id="308a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">返回常量值会将<code class="fe lp lq lr ls b">HashSets</code>变为<code class="fe lp lq lr ls b">List</code>。每个散列将是相同的，映射到一个桶，并且检索将是 O(N)。对于 Java 8，这将是<a class="ae ks" href="https://dzone.com/articles/hashmap-performance" rel="noopener ugc nofollow" target="_blank"> O(logN) </a>。</p><p id="f3f1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们运行下面的基准测试。一条记录<code class="fe lp lq lr ls b">Rekord</code>覆盖<code class="fe lp lq lr ls b">hashCode</code>并返回<code class="fe lp lq lr ls b">1</code>。另一个使用默认的<code class="fe lp lq lr ls b">hashCode</code>方法。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gi gj nv"><img src="../Images/eb0c3b400a949084aa8b5e6e5e8c7025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUxfS-CtjSwKPgvXH_SZOQ.png"/></div></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://jmh.morethan.io/?gist=577d5e9cbe97e1a774c41344e1970307" rel="noopener ugc nofollow" target="_blank">https://jmh.morethan.io/?gist = 577 D5 e9 CBE 97 E1 a 774 c 41344 e 1970307</a></figcaption></figure></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="0e2f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">用常量<code class="fe lp lq lr ls b">hashCode</code>设置的访问速度较慢，因为对<code class="fe lp lq lr ls b">HashSet</code>的元素没有常量访问。每个元素都会导致冲突，因为 hashCode 是常数，所以访问是 O(N)。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="cdd7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mx">覆盖默认 hashCode 方法会启用</em></strong><a class="ae ks" href="https://quarkus.io/blog/biased-locking-help/#what-is-biased-locking" rel="noopener ugc nofollow" target="_blank"><strong class="kv is"><em class="mx"/></strong></a><strong class="kv is"><em class="mx">。</em> </strong>偏置锁定会提高锁定/解锁对象的工作速度。</p><p id="b44d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">根据<a class="ae ks" href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" rel="noopener ugc nofollow" target="_blank">研究</a>，如果没有自定义 hashCode 方法，偏向锁将被禁用。如果没有偏向锁定，即使一个线程也需要原子操作来锁定/解锁一个对象。</p><p id="749f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">尽管<a class="ae ks" href="https://openjdk.java.net/jeps/374" rel="noopener ugc nofollow" target="_blank">在较新的 Java 版本中没有偏向锁定</a>，但在低于 Java 15 的版本中它仍然存在。大多数企业代码仍然启用了这个特性:)</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="2c5d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="mx">能否用</em> <code class="fe lp lq lr ls b"><em class="mx">hashCode</em></code> <em class="mx">来实现</em> <code class="fe lp lq lr ls b"><em class="mx">equals</em></code> <em class="mx">？</em>简答:没有。</p><p id="18bc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="mx">不同对象的 Hashcodes 可以是常量。</em> </strong></p><p id="5b71" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以自定义默认 hashCode 函数。你可以使用<strong class="kv is">-XX:hashCode = 0–5</strong>来<a class="ae ks" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l555" rel="noopener ugc nofollow" target="_blank">选择正确的 hashCode </a>算法。</p><p id="3d18" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是<a class="ae ks" href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" rel="noopener ugc nofollow" target="_blank">自定义 hashCode 选项</a>:</p><ol class=""><li id="954c" class="nh ni ir kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">随机生成的数字。</li><li id="85cd" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">对象的内存地址的函数。</li><li id="776d" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">a 硬编码 1(用于灵敏度测试。)</li><li id="26ef" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">一个序列。</li><li id="5cd4" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">对象的内存地址，强制转换为 int。</li><li id="38fc" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">线程状态结合 xor shift(<a class="ae ks" href="https://en.wikipedia.org/wiki/Xorshift" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Xorshift</a>)</li></ol><p id="3374" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你也不能用 hashCode 来改进 equals 方法。Hashcode 可以不同，对象可以相同。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="5873" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">为什么您应该更多地了解<code class="fe lp lq lr ls b">equals</code>和<code class="fe lp lq lr ls b">hashCode</code>？</h1><p id="01a7" class="pw-post-body-paragraph kt ku ir kv b kw ms js ky kz mt jv lb lc mu le lf lg mv li lj lk mw lm ln lo ik bi translated">你会在性能上损失很多。如果没有自定义 hashCode，您将失去<a class="ae ks" href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" rel="noopener ugc nofollow" target="_blank">4 倍的锁定/解锁操作性能提升。</a></p><p id="77c0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有了坏习惯<code class="fe lp lq lr ls b">hashCode</code>你可以把<code class="fe lp lq lr ls b">Hash-like</code>建筑变成<code class="fe lp lq lr ls b">Lists</code>。我们看到<code class="fe lp lq lr ls b">HashSet</code>可以变成<code class="fe lp lq lr ls b">List</code>。这反过来恶化了访问性能。</p><p id="104b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可能会在下一次面试中得到用<code class="fe lp lq lr ls b">hashCode</code>实现<code class="fe lp lq lr ls b">equals</code>的问题。看完应该就知道答案了。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="5ed1" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">今天就加入 Medium！</h1><p id="5fb2" class="pw-post-body-paragraph kt ku ir kv b kw ms js ky kz mt jv lb lc mu le lf lg mv li lj lk mw lm ln lo ik bi translated"><strong class="kv is"> <em class="mx">为什么你</em>要</strong> <a class="ae ks" href="https://zivce.medium.com/membership?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"> <strong class="kv is"> <em class="mx">亡国</em> </strong> </a> <strong class="kv is"> <em class="mx">？</em> </strong>率先抛弃微服镀铬模式。其次，你会接触到很多精彩的故事。你可以从实用主义程序员的书架上读到<a class="ae ks" href="https://medium.com/pragmatic-programmers/directory-of-pragmatic-programmer-books-on-medium-6a5cbadbd4b4?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"> 100 本左右的书。你可以从</a><a class="ae ks" href="https://medium.com/@Pinterest_Engineering?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"> Pinterest 团队</a>那里看到障碍、非常有用的提示和很棒的建议。你可以阅读<a class="ae ks" href="https://medium.com/google-cloud?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener">谷歌云的最新进展</a>。</p><p id="52d0" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is">这就是你每月</strong><a class="ae ks" href="https://zivce.medium.com/membership?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"><strong class="kv is">【5 美元(两杯咖啡)</strong> </a> <strong class="kv is">得到的东西。</strong>你可以花<a class="ae ks" href="https://zivce.medium.com/membership?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"> $5 </a>阅读整个实用程序员库。</p><p id="655f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">免责声明:$2 出<a class="ae ks" href="https://zivce.medium.com/membership?source=responses-----f49b64432202---------------------respond_sidebar-----------" rel="noopener"> $5 </a>将直接支持我，为你传递精彩话题。</p></div></div>    
</body>
</html>