<html>
<head>
<title>Spring Boot with PostgreSQL and Hibernate — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PostgreSQL 和 Hibernate 的 Spring Boot—第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-with-postgresql-and-hibernate-part-2-5406f3c93665?source=collection_archive---------10-----------------------#2022-02-16">https://blog.devgenius.io/spring-boot-with-postgresql-and-hibernate-part-2-5406f3c93665?source=collection_archive---------10-----------------------#2022-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1fef94e8e1540b5bd35df4f9a3cfb2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHnE-o4Mv7iYhVeIIrmm6g.png"/></div></figure><p id="4e67" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上一个教程中，我们使用 Spring Boot 设置了一个非常基本的 REST API。在本教程中，我们将进一步探索我们能做些什么，同时也改进我们现有的代码。我们将添加服务，还将添加实体之间的关系，以便我们可以将对象绑定在一起。例如，一篇博文应该能够附加博客类别或/和博客标签。当我们需要列出某个类别/标签中的所有博客文章时，这让我们更容易。</p><p id="cf36" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，我们将改进现有的代码。我们将创建一个名为<strong class="jt io"> service </strong>的新包，其中将存储我们的服务，这些服务将为我们执行业务逻辑。让我们的控制器端点远离过多的代码是一个很好的实践，通常过一段时间就会这样。</p><p id="6fc7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们将在新的包<strong class="jt io">服务</strong>中创建以下文件:【BlogPostService.java】<strong class="jt io"/><strong class="jt io">BlogTagService.java</strong>。这些文件将有非常相似的代码，所以我将只演示一下<strong class="jt io">BlogPostService.java</strong>的样子，其余的你可以查看我的<strong class="jt io"> GitHub </strong>库(文章底部的链接)。</p><p id="8757" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以现在我们将把下面的代码添加到我们的<strong class="jt io">BlogPostService.java</strong>(稍后我会试着分解它):</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="38ff" class="ky kz in ku b gy la lb l lc ld">package com.mjovanc.blog.service;<br/><br/>import com.mjovanc.blog.model.BlogPost;<br/>import com.mjovanc.blog.repository.BlogPostRepository;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.stereotype.Service;<br/><br/>import java.util.List;<br/>import java.util.Optional;<br/><br/>@Service<br/>public class BlogPostService {<br/><br/>    private final BlogPostRepository blogPostRepository;<br/><br/>    @Autowired<br/>    public BlogPostService(BlogPostRepository blogPostRepository) {<br/>        this.blogPostRepository = blogPostRepository;<br/>    }<br/><br/>    public List&lt;BlogPost&gt; getAllBlogPosts() {<br/>        return blogPostRepository.findAll();<br/>    }<br/><br/>    public BlogPost getBlogPostById(Long id) {<br/>        if (blogPostRepository.existsById(id)) {<br/>            BlogPost blogPost = blogPostRepository.findById(id).get();<br/>            return blogPost;<br/>        }<br/><br/>        return null;<br/>    }<br/><br/>    public HttpStatus createBlogPost(BlogPost blogPost) {<br/>        blogPostRepository.save(blogPost);<br/>        return HttpStatus.CREATED;<br/>    }<br/><br/>    public HttpStatus updateBlogPostById(Long id, BlogPost blogPost) {<br/>        Optional&lt;BlogPost&gt; blogPostToFind = blogPostRepository.findById(id);<br/><br/>        if (blogPostToFind.isPresent()) {<br/>            BlogPost blogPostToUpdate = blogPostToFind.get();<br/>            blogPostToUpdate.setTitle(blogPost.getTitle());<br/>            blogPostToUpdate.setText(blogPost.getText());<br/>            blogPostToUpdate.setCreated(blogPost.getCreated());<br/>            blogPostToUpdate.setUpdated(blogPost.getUpdated());<br/><br/>            blogPostRepository.save(blogPostToUpdate);<br/>            return HttpStatus.OK;<br/>        } else {<br/>            blogPostRepository.save(blogPost);<br/>            return HttpStatus.CREATED;<br/>        }<br/>    }<br/><br/>    public HttpStatus deletePostById(Long id) {<br/>        if (blogPostRepository.existsById(id)) {<br/>            blogPostRepository.deleteById(id);<br/>            return HttpStatus.OK;<br/>        }<br/><br/>        return HttpStatus.NOT_FOUND;<br/>    }<br/>}</span></pre><p id="bb74" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以这里我们将向我们的类添加另一个装饰器。这将使类充当服务对象:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="d6a8" class="ky kz in ku b gy la lb l lc ld">@Service<br/>public class BlogPostService</span></pre><p id="3173" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这一次我们将做一些改变，因为更好的做法是将我们的 Autowired 装饰器直接放在构造函数上。这将使我们的代码更容易测试:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="9bbf" class="ky kz in ku b gy la lb l lc ld">@Service<br/>public class BlogPostService {<br/><br/>    private final BlogPostRepository blogPostRepository;<br/><br/>    @Autowired<br/>    public BlogPostService(BlogPostRepository blogPostRepository) {<br/>        this.blogPostRepository = blogPostRepository;<br/>    }</span></pre><p id="ca1b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将使用的方法与我们在上一个教程中创建的初始控制器方法非常相似，但这里我们将返回从数据库中获取的对象本身(或多个)或<strong class="jt io"> HttpStatus </strong>。</p><p id="0455" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么为什么我们把<strong class="jt io"> HttpStatus </strong>作为一些方法的返回类型呢？这是因为我们可以检查，例如，如果我们试图通过<strong class="jt io"> id </strong>更新一篇博客文章，如果根据 HTTP 请求<strong class="jt io"> PUT </strong>没有找到，我们将创建该对象。因此，我们将根据情况向用户发送不同的 HTTP 请求，在我们的服务中直接处理这些请求要容易得多，在我们的控制器方法中看起来也干净得多。</p><p id="c1ff" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以现在我们将更新我们创建的初始 BlogPostController，如下所示:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="4bb7" class="ky kz in ku b gy la lb l lc ld">package com.mjovanc.blog.controller;<br/><br/>import com.mjovanc.blog.model.BlogPost;<br/>import com.mjovanc.blog.service.BlogPostService;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.List;<br/><br/>@RestController<br/>@RequestMapping("v1/posts")<br/>public class BlogPostController {<br/><br/>    private final BlogPostService blogPostService;<br/><br/>    @Autowired<br/>    public BlogPostController(BlogPostService blogPostService) {<br/>        this.blogPostService = blogPostService;<br/>    }<br/><br/>    @GetMapping<br/>    public ResponseEntity&lt;List&lt;BlogPost&gt;&gt; getAllBlogPosts() {<br/>        return new ResponseEntity&lt;&gt;(blogPostService.getAllBlogPosts(), HttpStatus.OK);<br/>    }<br/><br/>    @GetMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; getBlogPostById(@PathVariable Long id) {<br/>        BlogPost blogPost = blogPostService.getBlogPostById(id);<br/>        if (blogPost != null) {<br/>            return new ResponseEntity&lt;&gt;(blogPost, HttpStatus.OK);<br/>        }<br/><br/>        return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);<br/>    }<br/><br/>    @PostMapping<br/>    public ResponseEntity&lt;BlogPost&gt; createBlogPost(@RequestBody BlogPost blogPost) {<br/>        return new ResponseEntity&lt;&gt;(blogPostService.createBlogPost(blogPost));<br/>    }<br/><br/>    @PutMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; updateBlogPostById(@PathVariable Long id, @RequestBody BlogPost blogPost) {<br/>        return new ResponseEntity&lt;&gt;(blogPostService.updateBlogPostById(id, blogPost));<br/>    }<br/><br/>    @DeleteMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; deleteBlogPostById(@PathVariable Long id) {<br/>        return new ResponseEntity&lt;&gt;(blogPostService.deletePostById(id));<br/>    }<br/>}</span></pre><p id="6f7e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以在这里，我们也将 Autowire 装饰器改为在构造函数上，而不是直接在字段上。正如你在控制器方法上看到的，如果我们需要添加更多的端点，它会更加简洁和易于维护。使用<strong class="jt io">服务</strong>的目的也是为了能够在不同的控制器中使用，因此我们也增加了我们的模块化。</p><p id="f66e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，现在当用 cURL/Postman 进行 API 调用时，它应该完全像以前一样工作了。现在，我们将完全按照之前的操作来操作，但不包括其他控制器。</p><p id="ba0d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们将了解如何为我们的实体添加关系。所以我们需要考虑他们之间会有什么样的关系。</p><p id="d340" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">博客发布- &gt;博客标签</strong>(多对多)<br/> <strong class="jt io">博客发布- &gt;博客类别</strong>(多对多)</p><ul class=""><li id="ebe1" class="le lf in jt b ju jv jy jz kc lg kg lh kk li ko lj lk ll lm bi translated">一篇博客文章可以有许多博客标签，许多博客标签可以有许多博客文章。</li><li id="a6f5" class="le lf in jt b ju ln jy lo kc lp kg lq kk lr ko lj lk ll lm bi translated">一篇博客文章也可以有许多博客类别，而博客类别可以有许多博客文章。</li></ul><p id="9211" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，我们将数据库图表定义如下，以了解需要存储哪些数据:</p><figure class="kp kq kr ks gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/eff55cd6a43e23a433e5c46df958404a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsFZFNrHCnMXQ9NIBthMug.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">实体之间的关系</figcaption></figure><p id="9645" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，我们现在需要做的第一件事是在所有实体(模型)中添加一个新的 getter 方法，并将其放在构造函数下:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="901e" class="ky kz in ku b gy la lb l lc ld">public Long getId() {<br/>    return id;<br/>}</span></pre><p id="f298" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后转到我们的 BlogPost 类，在字段下添加以下内容:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="a9fc" class="ky kz in ku b gy la lb l lc ld">@ManyToMany(cascade = CascadeType.ALL)<br/>@JoinTable(<br/>        name = "blog_post_category",<br/>        joinColumns = {@JoinColumn(name = "blog_post_id")},<br/>        inverseJoinColumns = {@JoinColumn(name = "blog_post_category_id")}<br/>)<br/>@JsonProperty("blog_categories")<br/>public List&lt;BlogCategory&gt; blogCategories;<br/><br/>@ManyToMany(cascade = CascadeType.ALL)<br/>@JoinTable(<br/>        name = "blog_post_tag",<br/>        joinColumns = {@JoinColumn(name = "blog_post_id")},<br/>        inverseJoinColumns = {@JoinColumn(name = "blog_post_tag_id")}<br/>)<br/>@JsonProperty("blog_tags")<br/>public List&lt;BlogTag&gt; blogTags;<br/><br/>@JsonGetter("blog_categories")<br/>public List&lt;String&gt; getAllWalletPlatforms() {<br/>    if(blogCategories != null) {<br/>        return blogCategories.stream()<br/>                .map(bc -&gt; {<br/>                    return "/v1/categories/" + bc.getId();<br/>                }).collect(Collectors.toList());<br/>    }<br/>    return null;<br/>}<br/><br/>@JsonGetter("blog_tags")<br/>public List&lt;String&gt; getAllWalletStorages() {<br/>    if(blogTags != null) {<br/>        return blogTags.stream()<br/>                .map(bt -&gt; {<br/>                    return "/v1/tags/" + bt.getId();<br/>                }).collect(Collectors.toList());<br/>    }<br/>    return null;<br/>}</span></pre><p id="bf08" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这里，我们实现了之前在数据库图表中设计的关系。我们正在添加一个名为<strong class="jt io"> ManyToMany </strong>的新装饰器和一个<strong class="jt io"> JoinTable </strong>。我们有参数<em class="mb"> name </em>、<em class="mb"> joinColumns </em>和<em class="mb"> inverseJoinColumns </em>。第一个参数是我们的表的名称，在<em class="mb"> joinColumns </em>中我们描述了第一列应该被称为什么，在<em class="mb"> inverseJoinColumns </em>中描述了第二列应该被称为什么。</p><p id="28e6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后我们将一个<strong class="jt io"> JsonProperty </strong> decorator 添加到一个<strong class="jt io">blog category</strong>/<strong class="jt io">blog tag</strong>的列表中，当我们在<strong class="jt io">服务</strong>中访问这个列表时，它将被用来生成 JSON 数据。使用我们在<strong class="jt io"> JsonProperty </strong>下创建的字段名，我们将使用它通过<strong class="jt io">流</strong>遍历对象，并生成相对 URL 路径的列表。我们不想获取完整的对象并显示它们，因为当有大量数据时，这可能非常昂贵。</p><p id="8965" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，接下来我们将向我们的<strong class="jt io"> BlogCategory </strong>和<strong class="jt io"> BlogTag </strong>添加一些代码，这样当对每个类别或标签的端点进行 API 调用时，我们将获得哪些博客文章被连接:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="d210" class="ky kz in ku b gy la lb l lc ld">@ManyToMany(mappedBy="blogCategories")<br/>List&lt;BlogPost&gt; blogPosts;<br/><br/>@JsonGetter("blogPosts")<br/>public List&lt;String&gt; getAllBlogPosts() {<br/>    if (blogPosts != null) {<br/>        return blogPosts.stream()<br/>                .map(bp -&gt; {<br/>                    return "/v1/posts/" + bp.getId();<br/>                }).collect(Collectors.toList());<br/>    }<br/>    return null;<br/>}</span></pre><p id="1a8b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里我们映射了我们在 BlogPost 实体中定义的<em class="mb"> blogCategories </em>字段。因此，在<strong class="jt io">博客标签</strong>实体中，我们将添加<strong class="jt io">博客标签</strong>作为<strong class="jt io"> mappedBy </strong>参数。我们基本上是在这里生成一个博客帖子的相对 URL 路径列表，就像我们在 BlogPost 实体中所做的那样。</p><p id="5900" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以现在我们已经完成了实体的关系部分。让我们添加一些数据并检查结果。</p><p id="5233" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">发布/v1/标签</strong></p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e5a3" class="ky kz in ku b gy la lb l lc ld">{<br/>  "name": "Kryptokrona"<br/>}</span></pre><p id="1bea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">岗位/v1/类别</strong></p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="c792" class="ky kz in ku b gy la lb l lc ld">{<br/>  "name": "Crypto"<br/>}</span></pre><p id="0ff2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">岗位/v1/岗位</strong></p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="52e3" class="ky kz in ku b gy la lb l lc ld">{<br/>  "title": "A Spring Boot Tutorial Part 2",<br/>  "text": "Possimus sunt et provident molestiae id aut omnis. Et minus praesentium repellendus porro non. Eos et fugit doloribus.",<br/>  "created": "2015-03-25T12:00:00-06:30",<br/>  "updated": "2015-03-25T12:00:00-06:30",<br/>  "blog_categories": [<br/>    "2"<br/>  ],<br/>  "blog_tags": [<br/>    "13"<br/>  ]<br/>}</span></pre><p id="3e18" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这里，我们做了一个 POST 请求，并将 id 作为字符串添加到一个类别和标签的数组中，我们希望将博文与这些类别和标签相关联。</p><p id="1163" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> GET /v1/posts </strong></p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="7431" class="ky kz in ku b gy la lb l lc ld">[<br/>  {<br/>    "id": 1,<br/>    "title": "A Spring Boot Tutorial Part 2",<br/>    "text": "Possimus sunt et provident molestiae id aut omnis. Et minus praesentium repellendus porro non. Eos et fugit doloribus.",<br/>    "created": "2015-03-25T12:00:00-06:30",<br/>    "updated": "2015-03-25T12:00:00-06:30",<br/>    "blog_categories": [<br/>      "/v1/categories/16"<br/>    ],<br/>    "blog_tags": [<br/>      "/v1/tags/17"<br/>    ]<br/>  }<br/>]</span></pre><p id="d133" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，当执行 GET 请求时，我们看到它已经与博客文章相关联。</p><p id="977f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">就是这样！我们现在有了一个可以处理关系和使用服务的 REST API。</p><p id="e8ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要查看这个小系列教程的最终代码，请查看我的 GitHub 库:<a class="ae mc" href="https://github.com/mjovanc/spring-boot-postgresql-hibernate" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/spring-boot-postgresql-hibernate</a></p><p id="ab8a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关注我的 Twitter 账户，询问关于你想让我做的其他教程的问题，或者如果你想讨论别的事情:<a class="ae mc" href="https://twitter.com/mjovanc" rel="noopener ugc nofollow" target="_blank">https://twitter.com/mjovanc</a></p></div></div>    
</body>
</html>