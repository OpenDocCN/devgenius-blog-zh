<html>
<head>
<title>Ruby Web Scraping Using Nokogiri</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nokogiri的Ruby网页抓取</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-web-scraping-using-nokogiri-54a116e64471?source=collection_archive---------3-----------------------#2020-10-22">https://blog.devgenius.io/ruby-web-scraping-using-nokogiri-54a116e64471?source=collection_archive---------3-----------------------#2020-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="606b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">概观</h1><p id="e563" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Nokogiri是一个开源的Ruby库，用来读取HTML和XML，基本上是用来从网站上读取信息，供你的应用程序使用。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/ae33ea134f4373948fb5aa279e5399bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J9XYnGkmdCZ__acI"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">尼图·乔治在<a class="ae lw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4c73" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">装置</h1><p id="a8c9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要将Nokogiri添加到您的应用程序中，您只需运行以下命令</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="e098" class="mc jl in ly b gy md me l mf mg">gem install nokogiri</span></pre><p id="a518" class="pw-post-body-paragraph ki kj in kk b kl mh kn ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">安装后，确保您需要nokogiri和open-uri。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="9a61" class="mc jl in ly b gy md me l mf mg">require 'nokogiri' <br/>require 'open-uri'</span></pre><h1 id="e91b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">从网站抓取</h1><p id="f936" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要从网站上抓取，您需要您想要抓取的页面的url。然后将url传递给URI.open方法以获取HTML。之后，将HTML传递给Nokogiri::HTML方法，以获得一组可以使用Nokogiri解析的节点。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="5ddf" class="mc jl in ly b gy md me l mf mg">url = 'https://www.101cookbooks.com/ingredient.html'<br/>html = URI.open(url)<br/>doc = Nokogiri::HTML(html)</span></pre><h1 id="a8f8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">过程数据</h1><p id="c26c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">从网站上抓取数据有点复杂。您需要弄清楚您想从DOM中读取的数据在哪里。一种方法是检查元素并将鼠标悬停在HTML中的元素上。弹出窗口将显示您可以使用的元素的CSS。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/e8ca15a1ede43f3e8394a3d7e9b9dcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJdndtjicNZYRmfusIW4Jw.png"/></div></div></figure><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="2314" class="mc jl in ly b gy md me l mf mg">content = doc.css("div.maincontent.fullarchives.ingredients.col-lg-8.col-xl-8")</span></pre><p id="a9d6" class="pw-post-body-paragraph ki kj in kk b kl mh kn ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">在这种情况下，我们希望阅读该网站中的所有成分。所有的成分都按字母顺序分组，但是都包含在一个div容器中。所有的元素都在第一个节点中，所以我们使用第一个索引并解析它的子节点。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/ea34285e4f7e0b6cbb90199a9b3102a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyJC69y5raC5aV5Zzywp_Q.png"/></div></div></figure><p id="2d9c" class="pw-post-body-paragraph ki kj in kk b kl mh kn ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">如果我们检查每组配料，它们都包含在一个div中，带有我们可以检查的类“archives”和“flex-wrap”。之后，我们需要看看它的孩子。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/9338c3d05ff4c8968f865111e2aa2914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJDbACihUv2pgY47SpObsA.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/6c2ac62b71f7060a9bfb647676ec228d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWWc8mP9ctovNuYW4kODjw.png"/></div></div></figure><p id="893a" class="pw-post-body-paragraph ki kj in kk b kl mh kn ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">配料的文本被包装在一个超链接中，该超链接又被一个带有“tagholder”类的div包装。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="c7b9" class="mc jl in ly b gy md me l mf mg">content[0].children.each_with_index do |div, index|<br/>  if(div.attributes["class"] &amp;&amp; div.attributes["class"].value == "archives flex-wrap")<br/>    div.children.each do |child|        <br/>      if(child.attributes["class"] &amp;&amp; child.attributes["class"].value == "tagholder")          <br/>        child.children.each do |li|            <br/>          if(!li.attributes["class"] &amp;&amp; li.children[0])<br/>            ingredient = li.text<br/>            # Remove tabs<br/>            ingredient = ingredient.gsub("\t", "")              <br/>            # Remove end lines<br/>            ingredient = ingredient.gsub("\n", "")<br/>            Ingredient.create(name: ingredient.titleize)            <br/>          end          <br/>        end        <br/>      end      <br/>    end  <br/>  end<br/>end</span></pre><p id="5870" class="pw-post-body-paragraph ki kj in kk b kl mh kn ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf ig bi translated">检索配料名称后，它用于创建配料。这可以用于测试数据或初始数据。</p><h1 id="4f43" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="5920" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">网络抓取对于读取和处理其他应用程序是有用的，但是缺点是你需要明确你想要读取的数据。这意味着，如果开发人员改变设计，删除东西，甚至移动一些东西，Nokogiri可能无法正确读取数据。对于需要不断检查数据的应用程序来说，使用web抓取可能不是最好的。但是如果你只需要一次数据，那么网络抓取是一个有效的选择。</p></div></div>    
</body>
</html>