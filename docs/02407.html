<html>
<head>
<title>Json Web Token: How to Secure Spring Boot REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Json Web Token:如何保护 Spring Boot REST API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/json-web-token-how-to-secure-spring-boot-rest-api-4be1369009b0?source=collection_archive---------4-----------------------#2020-08-02">https://blog.devgenius.io/json-web-token-how-to-secure-spring-boot-rest-api-4be1369009b0?source=collection_archive---------4-----------------------#2020-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/898d82a05c6428f126a0e920abbdfc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oGjbH75vlVTDU2BK"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">亚历山大·德比耶夫在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7c74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将展示如何保护基于 REST API 的 spring boot。保护 REST APIs 以避免任何不必要的公共 API 调用已经成为一种趋势。我们将使用一些用于 Spring 安全的 Spring boot 特性，以及用于授权的 JSON WebTokens。</p><h1 id="9caf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这种情况下的用户流量是</h1><ol class=""><li id="ecb4" class="lw lx in kc b kd ly kh lz kl ma kp mb kt mc kx md me mf mg bi translated">用户登录</li><li id="4cae" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">我们验证用户凭证</li><li id="7a69" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">令牌被发送回用户代理。</li><li id="eddb" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">用户试图访问受保护的资源。</li><li id="c37f" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">用户在访问受保护资源时发送 JWT。我们认可 JWT。</li><li id="3008" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">如果 JWT 有效，我们允许用户访问资源。</li></ol><p id="4147" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JSON WebTokens，也称为 jwt，用于为用户形成授权。这有助于我们构建安全的 API，并且易于扩展。在身份验证过程中，会返回一个 JSON web 令牌。每当用户想要访问一个受保护的资源时，浏览器必须在请求的同时在<code class="fe mm mn mo mp b">Authorization</code>头中发送 jwt。这里需要理解的一点是，保护 REST API 是一个很好的安全实践。</p><p id="8b57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，我们将展示</p><ol class=""><li id="5ff0" class="lw lx in kc b kd ke kh ki kl mq kp mr kt ms kx md me mf mg bi translated">验证 JSON WebToken</li><li id="9d25" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">验证签名</li><li id="fdbb" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">检查客户端权限</li></ol><h1 id="51d7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你需要什么？</h1><ol class=""><li id="ba46" class="lw lx in kc b kd ly kh lz kl ma kp mb kt mc kx md me mf mg bi translated">Java 8，</li><li id="ace9" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">MySQL 数据库</li><li id="d66d" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">智能编辑器</li><li id="3dec" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">格拉德勒</li></ol><p id="8af9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意——这不会是一个完全成熟的应用，而是基于 Spring boot、Spring security 的 REST APIs。</p><h1 id="9fbb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基于 Spring Boot 的 REST API</h1><p id="c9d0" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">因为我已经在我的博客上展示过了，所以我不会创建任何新的 API。我将保护我在这篇博文<a class="ae jz" href="https://betterjavacode.com/2018/02/25/caching-how-to-use-redis-caching-with-spring-boot/" rel="noopener ugc nofollow" target="_blank"> REST API </a>中创建的<code class="fe mm mn mo mp b">company</code>的 REST API。这个 API 还包括缓存。一个用户将试图访问<code class="fe mm mn mo mp b">/cachedemo/v1/companies/</code>，由于 API 是受保护的，他将得到如下响应:</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/d821746ee7a4267071566b8fd41fdcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByMCNPP0thmBMruFxI1hUA.jpeg"/></div></div></figure><p id="feb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们将实现如何保护这个 API 以及当它被保护时如何访问它。</p><h1 id="6474" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">添加用户和用户注册</h1><p id="366d" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">因为我们想要为 API 添加授权，所以我们需要用户能够登录和发送凭证的地方。将验证这些凭据，并生成一个令牌。然后，这个令牌将在对 API 调用的请求中传输。令牌将在我们将要添加的 Spring 安全授权过滤器中进行验证。如果令牌有效，用户将能够访问 API。</p><h1 id="5da2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建用户模型</h1><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e78d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将添加一个控制器，用户可以在其中注册<code class="fe mm mn mo mp b">username</code>和<code class="fe mm mn mo mp b">password</code>的详细信息。</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f162" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在当我们<code class="fe mm mn mo mp b">POST</code>向<code class="fe mm mn mo mp b">/cachedemo/v1/users/signup</code>发出请求时，一个用户将被保存在数据库中。当我们使用<code class="fe mm mn mo mp b">BCryptPasswordEncoder</code>时，用户的密码将以加密格式保存。我们将展示用户如何登录来创建令牌。</p><h1 id="8291" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用户登录</h1><p id="68b7" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了处理用户登录，我们将在<code class="fe mm mn mo mp b">FilterChain</code>中添加一个<code class="fe mm mn mo mp b">AuthenticationFilter</code>，Spring boot 将适当地处理它的执行。该过滤器如下所示:</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="367a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，用户将在请求中发送凭证到以<code class="fe mm mn mo mp b">/login</code>结尾的 URL。该过滤器将有助于对用户进行身份验证，如果身份验证成功，将在响应头中添加一个带有密钥<code class="fe mm mn mo mp b">Authorization</code>的令牌。</p><h1 id="4aa2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">令牌验证和授权</h1><p id="7ebd" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们添加了另一个过滤器<code class="fe mm mn mo mp b">AuthorizationFilter</code>来验证我们之前通过<code class="fe mm mn mo mp b">AuthenticationFilter</code>传递的令牌。该过滤器如下所示:</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f6ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果令牌验证成功，则返回一个用户并将其分配给一个安全上下文。</p><p id="d0fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了启用 Spring 安全性，我们将添加一个带有注释<code class="fe mm mn mo mp b">@EnableWebSecurity</code>的新类<code class="fe mm mn mo mp b">WebSecurityConfiguration</code>。这个类将扩展标准<code class="fe mm mn mo mp b">WebSecurityConfigurerAdapter</code>。在这个类中，我们将限制我们的 API，并添加一些白名单中的 URL，我们将需要在没有任何授权令牌的情况下访问它们。这将如下所示:</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bb2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在方法<code class="fe mm mn mo mp b">configure</code>中，我们限制了大多数 API，只允许招摇的 URL 和<code class="fe mm mn mo mp b">signup</code> URL。我们也给<code class="fe mm mn mo mp b">HttpSecurity</code>加滤镜。我们将添加自己的<code class="fe mm mn mo mp b">UserDetailsServiceImpl</code>类来验证用户凭证。</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="ce45" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">演示</h1><p id="cd32" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">经过所有的代码修改，现在我们可以创建一个用户，登录并访问安全的 REST APIs 了。从上图可以看出，用户在访问安全 API 时出现了<code class="fe mm mn mo mp b">Access Denied</code>错误。为了演示这个，我已经用用户名<code class="fe mm mn mo mp b">test1</code>和密码<code class="fe mm mn mo mp b">test@123</code>注册了一个用户。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/ee12883c55cc8290deba53ca9b64941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*ZjWronxHpw4xM5Ok"/></div></div></figure><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/cc17294805630c0f879e67f99875a411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*4mkwBO50m2ie0V5b"/></div></div></figure><p id="bf8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个 POST 请求将给我们<code class="fe mm mn mo mp b">Authorization</code>令牌作为响应，如上所示。现在在 GET 请求中使用这个令牌来检索<code class="fe mm mn mo mp b">companies</code>数据。这个 GET 请求将如下所示:</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1181b9b430001b578f4f1f77670f46e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*w1gA_LBh0Am9UQMR"/></div></figure><p id="df26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们展示了如何使用 JSON web token 保护 REST API。</p><h1 id="a4b0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ol class=""><li id="a234" class="lw lx in kc b kd ly kh lz kl ma kp mb kt mc kx md me mf mg bi translated">在 Spring Boot API 上实现 JWTs 认证— <a class="ae jz" href="https://auth0.com/blog/implementing-jwt-authentication-on-spring-boot/" rel="noopener ugc nofollow" target="_blank"> JWT 认证</a></li><li id="5d85" class="lw lx in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">如何保护 REST API—<a class="ae jz" href="https://dzone.com/articles/thoughts-and-ideas-related-to-java-programming" rel="noopener ugc nofollow" target="_blank">保护 REST API</a></li></ol></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="e9c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">原载于 2020 年 8 月 2 日 https://betterjavacode.com</em><a class="ae jz" href="https://betterjavacode.com/java/securing-spring-boot-rest-api" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">。</em></p></div></div>    
</body>
</html>