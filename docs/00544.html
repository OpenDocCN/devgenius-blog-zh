<html>
<head>
<title>Readability, Scalability and Testability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可读性、可扩展性和可测试性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/readability-scalability-and-testability-ae0d1d8b08c0?source=collection_archive---------8-----------------------#2020-06-10">https://blog.devgenius.io/readability-scalability-and-testability-ae0d1d8b08c0?source=collection_archive---------8-----------------------#2020-06-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f0c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MVVM-C在swift中的应用更加接近完美</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/226372f441a9238ab11219ecaf64b309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j6NG-sfSoO8KM7KwWUlew.jpeg"/></div></div></figure><p id="f66e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从现在开始，许多架构设计模式被引入，其中少数几个在开发iOS应用程序时更受欢迎。早些时候，我们使用MVC设计模式开发iOS应用程序，这种模式现在已经很老了，因为许多开发人员已经为他们的iOS应用程序采用了MVVM设计模式，以更加专注于清晰地定义架构各层的责任。</p><p id="5ecf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的故事中，我们将看到，为什么需要进一步增强MVVM，以及MVVM-C如何成为广泛使用的建筑设计模式之一。</p><p id="2fdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要回答这些问题，让我们先来看看MVC和MVVM。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="928a" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">MVC中负担过重的ViewControllers</h2><p id="58d0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">MVC有三个组件:模型-视图-控制器。</p><p id="249a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">模型</strong>被很好地定义并有具体的责任。</p><p id="2aee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">视图</strong>组件与<strong class="jm io"> iPhoneSDK </strong>中的<em class="lz">视图控制器</em>概念有些混淆。</p><p id="56bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开发人员倾向于让<em class="lz"> ViewController </em>负责<strong class="jm io">视图</strong>的渲染以及<strong class="jm io">控制器</strong>活动(<em class="lz">即导航逻辑、业务逻辑等)。</em>)</p><p id="0622" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这使得<strong class="jm io">视图</strong>和<strong class="jm io">控制器</strong>彼此紧密耦合，因此它们难以重用，当然也难以进行单元测试。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="0a4f" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">呼叫MVVM救援以减轻管制员的责任</h2><p id="59b3" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">与MVC相比，MVVM相当不错，因为它有助于克服MVC设计模式的视图控制器负担过重的缺点。</p><p id="fb6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MVVM也有三个组件模型-视图-视图模型。</p><p id="26d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">模型</strong>是直接的，像MVC一样有单一的职责。</p><p id="4931" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">视图</strong>被简化，更加清晰，避免了ViewController与MVC中的<strong class="jm io">控制器</strong>混淆。<strong class="jm io">视图</strong>负责UI在屏幕上的渲染。它可以是UIView或UIViewController子类。</p><p id="2146" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">视图模型</strong>负责业务逻辑的实现，同时也是<strong class="jm io">模型</strong>和<strong class="jm io">视图</strong>之间的沟通者。ViewModel可以是<code class="fe ma mb mc md b">struct</code>或者<code class="fe ma mb mc md b">class</code>。</p><p id="1840" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ViewModel </strong>负责包含<em class="lz">导航逻辑、业务逻辑等</em>。因为它不是UIViewController子类，所以测试在<strong class="jm io"> ViewModel </strong>中实现的业务逻辑更容易。</p><p id="3445" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ViewModel </strong>也有助于使<strong class="jm io">视图</strong>组件变得愚笨，因为它去除了ViewController包含导航逻辑的责任。使用一个愚蠢的<strong class="jm io">视图</strong>组件，它是完全可重用的。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="4be2" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">ViewModel有许多职责，使得重用更加困难</h2><p id="18f9" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">视图模型有助于视图组件的可重用性和可测试性，也使得业务逻辑的单元测试变得更加容易。</p><p id="d540" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果你观察过，除了实现业务逻辑的主要职责之外，它还有其他的职责(即<em class="lz">导航逻辑</em>)。</p><p id="ce1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是时候考虑减轻视图模型的责任了。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="b9e9" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">随着在MVVM引入新的组成部分“协调员”,出现了MVVM-C模式。</h2><p id="67f8" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">为了减少<code class="fe ma mb mc md b">ViewModel</code>的责任，我们可以增加一个组件，它可以从<code class="fe ma mb mc md b">ViewModel</code>中取出责任来实现<em class="lz">导航逻辑</em></p><p id="ca1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们称新组件为<code class="fe ma mb mc md b">Coordinator</code>，因为它充当了<code class="fe ma mb mc md b">View</code>和<code class="fe ma mb mc md b">ViewModel</code>之间的协调器。</p><p id="220b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">Coordinator</code>将帮助<strong class="jm io">视图模型</strong>单独负责实现<em class="lz">业务逻辑，</em>这意味着它现在更容易测试和重用<em class="lz">。</em></p><p id="408d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过向MVVM引入第四个组件(<strong class="jm io">协调器</strong>)来实现关注点的分离。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="5112" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">调用MVVM-C来提高可读性、可伸缩性和可测试性</h2><p id="49eb" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">MVVM-C中每个组成部分的概述:</p><p id="5e43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">型号</strong></p><ul class=""><li id="dc32" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">表示数据对象</li><li id="91ad" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">可以是<code class="fe ma mb mc md b">struct</code>或<code class="fe ma mb mc md b">class</code>(推荐使用<code class="fe ma mb mc md b">struct</code>，并符合<code class="fe ma mb mc md b">Codable</code>协议，便于编解码操作。)</li></ul><p id="21dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查看</strong></p><ul class=""><li id="b1a5" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">负责在屏幕上呈现用户界面元素</li><li id="4867" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">使其成为哑对象，它应该只遵循<code class="fe ma mb mc md b">ViewModel</code>的命令</li><li id="7c56" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">建议用<code class="fe ma mb mc md b">Protocol</code>代替<code class="fe ma mb mc md b">Concrete</code>类型使<code class="fe ma mb mc md b">View</code>依赖于<code class="fe ma mb mc md b">ViewModel</code>。(即数据源、可加载、可刷新、可搜索等。)</li><li id="262a" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">使其成为附加行为(数据渲染除外)<code class="fe ma mb mc md b">Abstract</code>(即加载可显示)</li></ul><p id="92c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ViewModel </strong></p><ul class=""><li id="5765" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">负责实现业务逻辑</li><li id="d1ae" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">与<code class="fe ma mb mc md b">DataLayer</code>通信以从API/数据库加载数据</li><li id="e0ae" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">为<code class="fe ma mb mc md b">View</code>充当方便的<code class="fe ma mb mc md b">Datasource</code></li><li id="136e" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">当<code class="fe ma mb mc md b">state</code>改变时必须通知<code class="fe ma mb mc md b">View</code>(即<em class="lz">正在加载</em>，<em class="lz">正在刷新</em></li><li id="02b3" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">更新时必须通知<code class="fe ma mb mc md b">View</code>(例如，来自API/数据库的数据或任何种类的数据分类/过滤)</li><li id="278e" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">可选地与<code class="fe ma mb mc md b">Coordinator</code>通信以进行<code class="fe ma mb mc md b">Error</code>处理</li></ul><p id="c1bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">协调员</strong></p><ul class=""><li id="c620" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">负责实现导航逻辑</li><li id="5ff9" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">通过<code class="fe ma mb mc md b">start()</code>方法实例化并返回<code class="fe ma mb mc md b">ViewController</code></li><li id="8342" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">实例化<code class="fe ma mb mc md b">ViewModel</code>并将其提供给<code class="fe ma mb mc md b">ViewController</code></li><li id="84f7" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">可选地作为<code class="fe ma mb mc md b">ViewModel</code>的<code class="fe ma mb mc md b">ErrorDelegate</code>来处理错误</li><li id="44df" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">通过<code class="fe ma mb mc md b">finished()</code>方法通知父协调器其任务完成</li></ul><p id="82a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们只关注理论部分。也许你对实施MVVM协议不是100%清楚</p><p id="210b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">放心吧！！在下一节中，我们将围绕实际代码进行讨论，以便让您更好地理解。:)</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="c181" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将构建一个演示应用程序，它使用远程API并填充屏幕上的列表。</p><p id="6f7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个演示中，我们使用<a class="ae ms" href="https://restcountries.eu" rel="noopener ugc nofollow" target="_blank">https://rest countries . eu</a>API根据<em class="lz">搜索关键字</em>在屏幕上填充国家。</p><p id="a2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们开始为我们的应用程序逐个定义实体。</p><h1 id="37ef" class="mt lc in bd ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj bi translated">模型</h1><p id="68f2" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如下图所示，我将我的模型定义为<code class="fe ma mb mc md b">struct</code>，并将我的模型确认为<code class="fe ma mb mc md b">Codable</code>协议，以便于编码/解码。</p><p id="abac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想了解更多<code class="fe ma mb mc md b">Codable</code>，可以查看我的故事:<a class="ae ms" href="https://medium.com/macoclock/essential-of-codable-in-swift-18c83718d010" rel="noopener">Swift中“可编码”的必备</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="7c24" class="mt lc in bd ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj bi translated">视图模型</h1><p id="c20c" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如上所述，<code class="fe ma mb mc md b">ViewModel</code>负责实现业务逻辑，并通知<code class="fe ma mb mc md b">View</code>其<em class="lz">状态</em>的变化。</p><p id="a636" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我更喜欢定义<code class="fe ma mb mc md b">ViewModel</code> <em class="lz">协议</em>，用方法不断通知<code class="fe ma mb mc md b">View</code>它的<em class="lz">状态</em>改变，并在<em class="lz">用数据更新</em>时通知<code class="fe ma mb mc md b">View</code>。</p><blockquote class="nm nn no"><p id="1c5d" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">这种通知视图的机制将使<code class="fe ma mb mc md b">View</code>和<code class="fe ma mb mc md b">ViewModel</code>之间的通信非常容易实现和理解。</p><p id="03ba" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">它还会使<code class="fe ma mb mc md b">View</code>实现变得清晰易读，以便在<code class="fe ma mb mc md b">ViewModel</code>更新时呈现更新的数据。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="28c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以定义我们的具体<code class="fe ma mb mc md b">ViewModel</code>，让我们命名为<code class="fe ma mb mc md b">CountryListViewModel</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6a93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewModel</code>确认<code class="fe ma mb mc md b">CountryListDatasource</code>协议，这将使<code class="fe ma mb mc md b">CountryListViewModel</code>作为<code class="fe ma mb mc md b">View</code>的<em class="lz">数据源</em>。</p><p id="4ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewModel</code>确认<code class="fe ma mb mc md b">ViewModel</code>协议，通知<code class="fe ma mb mc md b">View</code>状态变化。</p><p id="b2ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewModel</code>执行“<em class="lz">func seach for(keyword:String)</em>方法确认<code class="fe ma mb mc md b">Searchable</code>协议。</p><p id="0527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewModel</code>通过<code class="fe ma mb mc md b">RequestManager</code>与数据层通信。</p><p id="b8a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且通过<code class="fe ma mb mc md b">ErrorDelegate</code>协议与<code class="fe ma mb mc md b">Coordinator</code>通信。</p><p id="304a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewModel</code>实现了所有需要的东西，我们在上面部分列出了这些东西，可读性很好<strong class="jm io">。</strong></p><p id="969e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还增加了<strong class="jm io"/><strong class="jm io"/><code class="fe ma mb mc md b">CountryListViewModel</code>的可扩展性，在某种意义上可以轻松添加新行为。</p><p id="955c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它可以确认<code class="fe ma mb mc md b">Refreshable</code>协议，并像我们实现“func searchFor(keyword: String)”一样实现“<em class="lz"> func refresh() </em>”方法。</p><p id="fa6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们来看看，它是如何帮助提高代码的可测试性的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="acc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面看到的，我们可以很容易地测试我们<code class="fe ma mb mc md b">ViewModel</code>的所有职责。它具有100%的代码覆盖率。</p><p id="24b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不仅仅是代码覆盖率，它还会让你更容易实现100% <em class="lz">功能覆盖率</em>来测试你的<em class="lz">业务逻辑</em>的各种场景。</p><h1 id="8def" class="mt lc in bd ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj bi translated">视角</h1><p id="8831" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我更喜欢把<code class="fe ma mb mc md b">View</code>做成哑对象，让它易于重用。</p><p id="bccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它必须与<code class="fe ma mb mc md b">ViewModel</code>通信以获取数据并将其呈现在屏幕上。应观察<em class="lz">状态</em>变化和<em class="lz">更新<code class="fe ma mb mc md b">ViewModel</code>的</em>刷新屏幕数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6f33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListViewController</code>通过<code class="fe ma mb mc md b">CountryListViewControllerDelegate</code>协议与<code class="fe ma mb mc md b">Coordinator</code>通信。</p><blockquote class="nm nn no"><p id="9d2c" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">View</code>取决于“func configure(viewModel:CountryListViewModelProtocol)”中<code class="fe ma mb mc md b">ViewModel</code>的协议类型</p><p id="eced" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">这会增加<strong class="jm io"><em class="in"/><strong class="jm io"/><code class="fe ma mb mc md b">View</code>的伸缩性。例如，如果我们想增加“刷新”屏幕的能力，我们可以很容易地要求我们的<code class="fe ma mb mc md b">ViewModel</code>成为如下的<code class="fe ma mb mc md b">Refreshable</code>。</strong></p><p id="1ab2" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">type alis CountryListViewModelProtocol = countrylistdata source &amp; ViewModel &amp; Searchable &amp;<strong class="jm io">可刷新</strong></p></blockquote><h1 id="cad7" class="mt lc in bd ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj bi translated">协调者</h1><p id="977b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><code class="fe ma mb mc md b">Coordinator</code>主要负责实现<em class="lz">导航</em>逻辑。</p><p id="7e2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我更喜欢定义<code class="fe ma mb mc md b">Coordinator</code>协议，它定义了<code class="fe ma mb mc md b">Coordinator</code>的基本职责。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们实现具体的协调器，并将其命名为<code class="fe ma mb mc md b">CountryListCoordinator</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b289" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看到<code class="fe ma mb mc md b">CountryListCoordinator</code>实现了<code class="fe ma mb mc md b">Coordinator</code>协议的功能。</p><p id="8572" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListCoordinator</code>实例化<code class="fe ma mb mc md b">CountryListViewController</code>并从<code class="fe ma mb mc md b">start()</code>方法返回。</p><p id="08f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">CountryListCoordinator</code>通过确认<code class="fe ma mb mc md b">CountryListViewControllerDelegate</code>协议充当<code class="fe ma mb mc md b">View</code>的<code class="fe ma mb mc md b">delegate</code>。</p><p id="aef1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过确认<code class="fe ma mb mc md b">CountryListViewModeLoadingErrorDelegate</code>协议，<code class="fe ma mb mc md b">CountryListCoordinator</code>也作为<code class="fe ma mb mc md b">ViewModel</code>的<code class="fe ma mb mc md b">ErrorDelegate</code>。</p><p id="5150" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行<code class="fe ma mb mc md b">Coordinator</code>可以很容易地将执行<em class="lz">导航逻辑</em>与<code class="fe ma mb mc md b">View</code>或<code class="fe ma mb mc md b">ViewModel</code>分开。</p><p id="6a86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以轻松测试<code class="fe ma mb mc md b">Coordinator</code>了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="nm nn no"><p id="110b" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">MVVM-C帮助遵循鲍勃大叔的坚实原则。</p><p id="b6ea" class="jk jl lz jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">坚实的原则帮助你提高应用程序的可读性、可伸缩性和可测试性。</p></blockquote><p id="d563" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望您喜欢阅读这个故事，并对MVVM-C的swift应用有很好的了解。</p><p id="26fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我很乐意回答你的问题。</p><p id="b719" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码快乐！！:)</p></div></div>    
</body>
</html>