<html>
<head>
<title>Django Rest Framework + React — Authentication workflow 2022 (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django Rest 框架+ React —认证工作流 2022(第 2 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-rest-framework-react-authentication-workflow-2022-part-2-d299b7fef875?source=collection_archive---------0-----------------------#2022-02-26">https://blog.devgenius.io/django-rest-framework-react-authentication-workflow-2022-part-2-d299b7fef875?source=collection_archive---------0-----------------------#2022-02-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="67c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在这篇博客中，我们将介绍认证工作流程的前端部分。我们将创建页面，组件，自定义挂钩，实用功能和路线与路线警卫。到本博客结束时，您将拥有一个面向未来全栈应用的成熟认证工作流。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4fe80ed02475f5bfdad667bf0bb4fab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYhd0XqypOxliy1zM72vSg.png"/></div></div></figure><blockquote class="ko kp kq"><p id="fb1e" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">通过第一部分，我们涵盖后端部分。</p></blockquote><div class="lo lp gp gr lq lr"><a href="https://sushil-kamble.medium.com/django-rest-framework-react-authentication-workflow-2022-part-1-a21f22b3f358" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd io gy z fp lw fr fs lx fu fw im bi translated">Django Rest 框架+ React —认证工作流 2022(第 1 部分)</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">在这篇博客中，我们将介绍完整的认证工作流程。我们将从项目设置、git 设置、后端…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">sushil-kamble.medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf km lr"/></div></div></a></div><h2 id="b801" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">内容</h2><p id="7cdc" class="pw-post-body-paragraph kr ks in ku b kv nc jo kx ky nd jr la mp ne ld le mt nf lh li mx ng ll lm ln ig bi translated">–需求<br/>–项目设置(前端)<br/>–开始<br/>–应用测试<br/>–代码访问(跳到好的部分)<br/>–参考</p><h2 id="e368" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">要求</h2><ul class=""><li id="3bed" class="nh ni in ku b kv nc ky nd mp nj mt nk mx nl ln nm nn no np bi translated">确保您已经安装了<a class="ae nq" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a></li><li id="c2c4" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln nm nn no np bi translated"><a class="ae nq" href="https://classic.yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank">纱</a>推荐为包装经理。你可以简单地输入<code class="fe nw nx ny nz b">npm install --global yarn</code>来安装纱线</li><li id="b54e" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln nm nn no np bi translated">任何 IDE，<a class="ae nq" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"> VS 代码</a>推荐</li><li id="d591" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln nm nn no np bi translated"><a class="ae nq" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git 版本控制</a>(可选但推荐)</li></ul><h2 id="a4b9" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">项目设置(前端)</h2><ol class=""><li id="317f" class="nh ni in ku b kv nc ky nd mp nj mt nk mx nl ln oa nn no np bi translated"><strong class="ku io">将目录<br/> </strong> <code class="fe nw nx ny nz b">cd</code>改为前端目录</li><li id="35c0" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln oa nn no np bi translated"><strong class="ku io">创建 React App</strong><br/><code class="fe nw nx ny nz b">yarn create react-app .</code><br/><strong class="ku io"><em class="kt">注意</em> </strong> <em class="kt">:一定要在前面的命令中添加一个</em> <code class="fe nw nx ny nz b"><em class="kt">.</em></code> <em class="kt">，这样 React 项目就会搭建在当前目录下。</em></li><li id="0343" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln oa nn no np bi translated"><strong class="ku io">安装包<br/> </strong> <code class="fe nw nx ny nz b">yarn add axios dayjs jwt-decode react-router-dom@5.2.0</code></li><li id="56f5" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln oa nn no np bi translated"><strong class="ku io">运行应用</strong> <br/> <code class="fe nw nx ny nz b">yarn start</code></li></ol><h2 id="66cc" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">我们开始吧</h2><blockquote class="ko kp kq"><p id="93b9" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须将用户存储在前端&amp;用户状态为空或已定义必须可以跨整个应用程序访问。所以，基本上我们需要一个商店。如果我们想到商店，Redux 就会出现在我们的脑海中，对！。让我们在没有 Redux 的情况下实现这一点。让我们使用 React 钩子<code class="fe nw nx ny nz b">useContext</code></p></blockquote><ul class=""><li id="5d97" class="nh ni in ku b kv kw ky kz mp ob mt oc mx od ln nm nn no np bi translated">在<code class="fe nw nx ny nz b">src</code>中创建一个名为<code class="fe nw nx ny nz b">context</code>的文件夹&amp;在里面创建一个名为<code class="fe nw nx ny nz b">AuthContext</code>的文件。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="02e4" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><strong class="ku io">我们来分解一下这段代码。</strong> <br/>我们基本上是在创建一个<code class="fe nw nx ny nz b">AuthContext</code>，我们将能够把它导入到<code class="fe nw nx ny nz b">src</code>文件夹中的任何文件中。我们将能够使用它访问<code class="fe nw nx ny nz b">contextData</code>。<br/> <em class="kt">我们基本会把整个 app 包裹在</em> <code class="fe nw nx ny nz b"><em class="kt">AuthProvider</em></code> <em class="kt">里面。</em> <br/> <code class="fe nw nx ny nz b">loginUser </code> —需要用户名和密码。如果用户在数据库中(凭证有效)，则用户登录。令牌(访问&amp;刷新)存储在本地存储中，<br/> <code class="fe nw nx ny nz b">registerUser</code> —需要用户名、密码 1、密码 2。这个函数在数据库中注册用户。唯一的用户名，密码匹配检查在后端完成。如果注册请求成功，则用户被重定向到登录页面。<br/> <code class="fe nw nx ny nz b">logoutUser</code> —简单地注销用户&amp;清除本地存储。<br/>每当<code class="fe nw nx ny nz b">authTokens</code>的&amp;状态改变时。用户状态已更改(<code class="fe nw nx ny nz b">useEffect</code>导致此更改)。<code class="fe nw nx ny nz b">jwt_decode</code>只解码一个访问令牌。</p><blockquote class="ko kp kq"><p id="b050" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你想看<code class="fe nw nx ny nz b">jwt_decode</code>输出什么，去<a class="ae nq" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/</a>T33】粘贴你的访问&amp;看解码输出，同样的事情会在这里完成。</p></blockquote><p id="8a70" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><strong class="ku io">问题:</strong>访问令牌寿命通常很短。因此，用户的令牌将在很短的时间内有效，然后它将过期，用户将无法访问应用程序的所有私有路由。</p><p id="2dcd" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><strong class="ku io">方法:</strong>为了解决这个问题，我们需要一种方法在请求被发送到服务器之前拦截它。我们拦截请求，查看令牌是否有效，如果无效，我们将通过刷新令牌请求新的令牌，我们将获得新的访问令牌，并将该令牌用于对私有路由的 API 请求，如果令牌有效，我们将使用相同的令牌向私有路由发送请求。</p><p id="348f" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><strong class="ku io">实现:</strong>我们可以使用<code class="fe nw nx ny nz b">axios</code>库来解决这个问题。<code class="fe nw nx ny nz b">axios</code>已经拿到了<code class="fe nw nx ny nz b">interceptors</code>。<code class="fe nw nx ny nz b">axios</code>基本上会拦截所有的请求。它将首先运行<code class="fe nw nx ny nz b">interceptors</code>，然后向服务器发出实际请求。<strong class="ku io"> <em class="kt">所以我们在调用私有 API 的时候要用到</em> </strong> <code class="fe nw nx ny nz b"><strong class="ku io"><em class="kt">axios</em></strong></code> <strong class="ku io"> <em class="kt">。此外，如果我们获得新的访问令牌，我们必须更新应用程序的状态。所以我们可以使用 React 自定义钩子。</em></strong></p><ul class=""><li id="8c77" class="nh ni in ku b kv kw ky kz mp ob mt oc mx od ln nm nn no np bi translated">在<code class="fe nw nx ny nz b">src</code>文件夹内创建名为<code class="fe nw nx ny nz b">utils</code>的文件夹&amp;在名为<code class="fe nw nx ny nz b">useAxios.js</code>的<code class="fe nw nx ny nz b">utils </code>内创建文件。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8abb" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><strong class="ku io">我们来分解一下这段代码。</strong> <br/>我们正在从<code class="fe nw nx ny nz b">useContext</code>访问<code class="fe nw nx ny nz b">authTokens</code>、<code class="fe nw nx ny nz b">setUser</code>、<code class="fe nw nx ny nz b">setAuthTokens</code>。<br/>我们需要他们获取和更改 React 应用程序的状态。<br/>此外，我们正在创建一个<code class="fe nw nx ny nz b">axios</code>实例，它具有认证头，确保它只用于私有路由。然后我们正在解码用户访问令牌。令牌有<code class="fe nw nx ny nz b">exp</code>日期，告知它何时到期。在下一行，我们只是检查令牌是否有效。如果过期，获取新的访问令牌&amp;更改应用程序的状态。</p><p id="f95c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">我们的应用程序将有 4 条路线<br/><code class="fe nw nx ny nz b">/login</code><br/><code class="fe nw nx ny nz b">/register</code><br/><code class="fe nw nx ny nz b">/ </code><br/><code class="fe nw nx ny nz b">/protected </code>——私有路线</p><p id="2ddc" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">如果用户已经登录，他们应该只能访问私有路由，否则应该被重定向到登录页面。我们需要一个专用路由组件来实现这一点。</p><p id="4bd4" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">所以在<code class="fe nw nx ny nz b">src</code>下的<code class="fe nw nx ny nz b">utils</code>文件夹内的<code class="fe nw nx ny nz b">PrivateRoute.js</code>中创建一个文件</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8269" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">这段代码所做的只是检查用户是否存在。如果用户在场，那么它会将所有的道具传递给子组件，并呈现该路线。否则，它将重定向到登录页面。</p><p id="ac29" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">最困难的部分已经过去了，现在我们必须在应用程序中使用这一部分。我们必须创建路线(页面)和组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cca9" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated"><code class="fe nw nx ny nz b">FolderName_FileName.js</code> —此处使用的命名格式。<br/>这里我说的是代码末尾下面提到的那一行。比如<code class="fe nw nx ny nz b">views_registerPage.js</code>用 GitHub <br/>托管的<code class="fe nw nx ny nz b">view_regiterPage.js</code>，应该位于<code class="fe nw nx ny nz b">views</code>文件夹，文件名应该是<code class="fe nw nx ny nz b">registerPage.js</code>。你可以看看我的目录结构，以便清楚地了解。</p><p id="a1a7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">下面是目录结构</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5a96e0e1d13f2ab402b7ed18da7bc64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*vE8Jjm9DvpfTx2mzuv1jgg.png"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">目录结构(这不是整个目录结构，还有像 public 和 all 这样的文件夹，我们还没有触及)</figcaption></figure><p id="e1c2" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">就这些，如果你能走到这一步，恭喜你。</p><h2 id="1f8a" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">测试应用程序的时间到了</h2><ul class=""><li id="90be" class="nh ni in ku b kv nc ky nd mp nj mt nk mx nl ln nm nn no np bi translated">确保你的后端正在运行。<br/>麻烦？转到后端应用程序的根目录，激活你的虚拟 env 和<code class="fe nw nx ny nz b">python manage.py runserver</code></li><li id="9915" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln nm nn no np bi translated">确保您的前端正在运行。<br/>麻烦？转到前端应用程序的根目录<code class="fe nw nx ny nz b">yarn start</code></li><li id="8438" class="nh ni in ku b kv nr ky ns mp nt mt nu mx nv ln nm nn no np bi translated">转到<a class="ae nq" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6680bf4fb7aec908c0c0d9fc8340f046.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*X4zSVBJU0NgNIR3nNJNb7A.png"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">主页(用户未登录)</figcaption></figure><ul class=""><li id="4574" class="nh ni in ku b kv kw ky kz mp ob mt oc mx od ln nm nn no np bi translated">进入登录页面，输入超级用户的<code class="fe nw nx ny nz b">username</code> &amp; <code class="fe nw nx ny nz b">password</code> <br/>如果忘记了，不用担心。进入注册页面&amp;注册新用户。注册成功后，您将被重定向到登录页面。现在使用这些最近注册的凭证登录。<br/>成功登录后，您将被重定向到主页，在那里您将看到您的用户名。Navbar 也改了，旁边会看到一个注销按钮。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi om"><img src="../Images/29b4f8e51999832866bf746b46f6437a.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*3KkjrRvO3w3tgkwaPddz0Q.png"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">主页(用户已登录)</figcaption></figure><ul class=""><li id="4709" class="nh ni in ku b kv kw ky kz mp ob mt oc mx od ln nm nn no np bi translated">投影页面——没有登录，您无法访问<a class="ae nq" href="http://localhost:3000/protected" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/protected</a>，您将被重定向到<code class="fe nw nx ny nz b">/login</code>页面。<br/>当你访问一个受保护的页面时，你会得到<code class="fe nw nx ny nz b">Congratulation &lt;username&gt;, your API just responded to GET request</code>这条消息。</li></ul><h2 id="951a" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">代码访问</h2><p id="f5e7" class="pw-post-body-paragraph kr ks in ku b kv nc jo kx ky nd jr la mp ne ld le mt nf lh li mx ng ll lm ln ig bi translated">阅读存储库的<code class="fe nw nx ny nz b">README.md</code>以了解运行项目的步骤。</p><div class="lo lp gp gr lq lr"><a href="https://github.com/sushil-kamble/django-react-auth" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd io gy z fp lw fr fs lx fu fw im bi translated">GitHub-sushil-kam ble/django-react-auth:未来全栈的认证模板…</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">未来全栈应用的认证模板-GitHub-sushil-kam ble/django-react-auth…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="on l mc md me ma mf km lr"/></div></div></a></div><h2 id="32c4" class="mg mh in bd mi mj mk dn ml mm mn dp mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">参考</h2><p id="69a1" class="pw-post-body-paragraph kr ks in ku b kv nc jo kx ky nd jr la mp ne ld le mt nf lh li mx ng ll lm ln ig bi translated">Dennis Ivy — <a class="ae nq" href="https://www.youtube.com/watch?v=xjMP0hspNLE&amp;t=9s&amp;ab_channel=DennisIvy" rel="noopener ugc nofollow" target="_blank">认证&amp;刷新令牌实现</a></p><p id="1232" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la mp lc ld le mt lg lh li mx lk ll lm ln ig bi translated">谢谢&amp;祝你黑客愉快…</p></div></div>    
</body>
</html>