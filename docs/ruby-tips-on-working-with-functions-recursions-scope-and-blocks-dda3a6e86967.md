# Ruby:使用函数、递归、作用域和块的技巧

> 原文：<https://blog.devgenius.io/ruby-tips-on-working-with-functions-recursions-scope-and-blocks-dda3a6e86967?source=collection_archive---------2----------------------->

![](img/b09e7c7946ffb0d1c7509d854b65415d.png)

1337

## 只是一些在 Ruby 函数和块中使用变量引用的提示和指针。

## 背景

我一直在为技术面试学习:在 Leetcode 上做一堆问题，每当我需要对 DFS 或任何其他问题使用递归时，我真的很困惑，遇到了很多错误。

更具体地说，当我需要将变量传入递归函数并更新某种类型的`counter`变量时。

如果你们一直在练习 Leetcode，我相信你们已经看到了一个问题:[岛屿数量问题](https://leetcode.com/problemset/all/?search=number%20of%20islands)。比方说，除了记录岛屿的数量之外，我还想记录有多少陆地。所以每当我遇到一个‘1’，我需要在递归时增加一个计数器。

每当我试图传入一个“计数器”变量并在我的递归中更新计数器变量时，它都不会得到我想要的更新。在我的函数中修改它之后，计数器保持了我最初设置的变量。

所以，在这篇文章中，我想回顾一下我在 RUBY 中处理变量、作用域和递归之后的发现，以及任何其他关于递归和搜索算法的通用技巧。

## 按值传递

首先，上面的例子不起作用，因为 **Ruby 是一种通过值传递的语言。**

当我们`puts x`调用我们的方法后，我们仍然得到 0，因为函数定义内的`b`没有引用函数外的变量`x`。`b`实际上只是指向同一个值的完全不同的变量。

当我们用`x`调用函数时会发生什么:

1.  该函数创建一个名为`b`的局部变量，并将其设置为等于传入的值。('指针`b`指向 int 0 的内存位置')。
2.  然后，它将局部变量`b`设置为 2。(' Point `b`指向 int 2 的新内存位置')。

因此，函数没有改变后，位置`x`仍然指向 0。您可以使用 **object_id 检查变量指向的对象。我建议你试验一下 object _ ids，看看变量赋值是如何工作的。**

## 修改函数中的数组

我们可以在函数内部修改外部变量的一种方法是传入一个数组(和一个散列)。执行数组修改，如`push`、`pop`和`shift`、**会改变对象内存位置**中的数组。然而，赋予一个新值是将变量指向内存中的一个新对象。

因此，无论出于什么原因，你需要在递归时跟踪一些答案列表，你可以只传入一个数组并修改它。

## 我们能不能只修改函数中的外部变量而不传入变量？

不，我们不能。(我应该说‘不，我们不能用经典的 Ruby 函数定义*’，我们稍后会谈到这一点。)*

**Ruby 函数定义创建自己不同的作用域。**因此它们被称为**范围门**。他们不能访问在函数外声明的变量。

## 那么，我们如何在 Ruby 函数中不断修改计数器变量呢？

第一种方法是使用全局变量(使用键`$`创建的全局变量)，但是使用全局变量通常不被认可，所以我们将讨论其他方法。

## 阻碍

我们可以用积木。块是我们以后可以调用的代码块(它们本质上是函数，但属性略有不同)。它们通常被传递给类似于`array.map`中的函数。

`[1, 2, 3].map {|x| x+1}`

你可以阅读更多关于块如何工作和块的细节，但重要的是**块有闭包**，这意味着当块稍后被调用时，它们可以引用在与块定义相同的作用域中定义的变量和方法。

更简单地说，块可以使用在块外部定义的变量和方法。

我们可以用两种不同的方式定义块:

1.  **λs**和**过程**

当我第一次开始使用递归时，我使用 lambdas 和 procs，因为我在使用普通的 Ruby 函数时遇到了很多问题。

Lambdas 和 procs 只是我们可以存储在变量中的 Ruby 块。我们可以使用关键字`lambda`或`proc`来定义它们。稍后我们可以使用`lambda_name.call(any_args)`或`proc_name.call(any_args)`调用`lambda`或`proc`。

你可以在这里阅读更多关于 lambdas 和 procs [的内容，但重要的是 **lambdas 和 procs 是块，因此有闭包**。](https://www.rubyguides.com/2016/02/ruby-procs-and-lambdas/#:~:text=Lambdas%20are%20defined%20with%20%2D%3E%20%7B%7D%20and%20procs%20with%20Proc.&text=Procs%20return%20from%20the%20current,lambdas%20will%20raise%20an%20exception.)

如果你打算使用 lambdas 和 procs，你应该知道 procs 和 lambdas 是如何处理返回语句的。

Proc 'returns '将从调用 Proc 的方法中返回。而兰姆达斯只从兰姆达斯本身返回。

procs 的一个用例是，如果你递归遍历一个结构，当你找到目标时，你想从外部函数返回值。如果你想让你的程序块像普通函数一样返回，就使用 lambdas。

## 定义方法

2.您也可以通过使用 **define_method 使用一个块来创建一个方法。**该功能将会关闭。

现在，我们知道我们可以使用块来增加一个方法或代码块中的外部变量。

## 递增计数器的其他方法:

## 只需在需要 DFS 时使用堆栈

不使用递归块或方法，我们可以只使用堆栈，不用担心变量范围。

这要多做一点工作，因为你必须显式地使用一个堆栈，而不是仅仅使用一个隐式的递归，但老实说，它可以让你不用处理递归中的变量引用。

另外，栈在算法中很常见，为什么不熟悉一下栈呢？

最重要的是，如果您需要实现 BFS，可以非常容易地将使用堆栈的 DFS 切换到使用队列的 BFS。

*这是一个旁注，因为这适用于队列，但是 Ruby 数组可以作为* ***队列*** *工作。其他语言需要为它们的队列使用名为“deques”的结构，否则在数组的开头插入和删除一个值将花费 O(N)时间，但是 Ruby 数组作为 deques 工作得非常好。ruby 数组的 Push、pop、shift 和 unshift 都有 O(1)时间摊销。看看这个* [*堆栈溢出问题。*](https://stackoverflow.com/questions/8353026/what-is-the-run-time-of-shift-unshift-in-a-ruby-array)

## 我们如何使用堆栈跟踪 DFS 中的深度？

最后一点是肯定的，使用堆栈跟踪 DFS 中的*计数器*很容易，但是我们如何跟踪*深度*？深度不同于计数器，因为计数器只对每次迭代进行计数，而深度会跟踪您搜索了多少层节点才能到达某个点。

这可能很重要，因为一些算法问题要求返回路径的深度或“长度”。例如，当你设计一个嵌套数组时，你需要返回一个目标值的深度。

将遇到的每个节点存储在深度为的数组中:

从堆栈中移除的每个节点将知道到该节点的路径的当前深度或“长度”。它的任何一个孩子都应该用 curr_depth + 1 插入堆栈。

## 从这篇文章中学到什么…

*   Ruby 函数定义创建了自己的作用域。当使用经典的 Ruby 函数定义时，即(`def function_name … end`)，不能引用或修改外部变量。但是，您可以传入一个数组，并在函数中修改该数组，因为数组修改会改变内存中的数组。
*   接下来，如果可以的话，使用栈进行 DFSing。使用变量更容易。这会让你更熟悉算法中常见的堆栈。您还可以轻松地从带堆栈的 DFS 切换到带队列的 BFS。
*   最后，如果您仍然需要使用递归，请使用 lambdas、procs 或 define_method。它们有闭包，可以引用外部变量。

好吧，我希望你觉得这有帮助。我不是真正的专家，我只是分享一些我在解决 Leetcode 问题时学到的东西。祝你面试好运。