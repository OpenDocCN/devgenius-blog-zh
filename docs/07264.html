<html>
<head>
<title>Typescript: interface vs type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript:接口与类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-interface-vs-type-cb334add97fa?source=collection_archive---------7-----------------------#2022-03-10">https://blog.devgenius.io/typescript-interface-vs-type-cb334add97fa?source=collection_archive---------7-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1b48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择什么不容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40fa909541040daf595442038647d841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0B9c0y0qo93rY7Tnz3MXQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">华金·索罗拉，1910 年。两种相似的方法。</figcaption></figure><p id="5eb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类型和接口有什么区别？寻找相似之处:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="6b33" class="ld le in kz b gy lf lg l lh li">interface CruiseMissile {<br/>    distance: number;<br/>    modelName: string;<br/>}</span><span id="94d6" class="ld le in kz b gy lj lg l lh li">type CruiseMissile = {<br/>    distance: number;<br/>    modelName: string;<br/>};</span></pre><h1 id="c8b2" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">功能类型</h1><p id="ffcd" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">函数可以由关键字<code class="fe mm mn mo kz b">type</code>和<code class="fe mm mn mo kz b">interface</code>键入:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="cd12" class="ld le in kz b gy lf lg l lh li">type Sum = (x: number, y: number) =&gt; number;</span><span id="c28e" class="ld le in kz b gy lj lg l lh li">interface Sum {<br/>  (x: number, y: number): number;<br/>}</span></pre><p id="a28b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要的核心区别是接口可以重新声明。类或其他接口可以扩展源接口。另一方面，类型永远不能改变，我们不能给类型添加新的属性。</p><p id="d71a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举例来说，我们有 1 个接口，并希望使用继承:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8dbe" class="ld le in kz b gy lf lg l lh li">interface CruiseMissile {<br/>  distance: number;<br/>  modelName: string;<br/>}<br/>interface CruiseMissileTask extends CruiseMissile<br/> { lat: number; lng: number; }</span><span id="eaa0" class="ld le in kz b gy lj lg l lh li">const getMissile = (item: CruiseMissileTask): string =&gt; {<br/>  return `${item.lat} ${item.lng}`;<br/>};</span></pre><p id="9152" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以创建具有所有属性的对象实例:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d52d" class="ld le in kz b gy lf lg l lh li">const missile: CruiseMissileTask = {<br/>  distance: 4000,<br/>  modelName: 'XYZ99',<br/>  lat: 0.00,<br/>  lng: 0.00<br/>};</span></pre><p id="1345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个类型也可以扩展另一个类型。类似这样的东西:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="338e" class="ld le in kz b gy lf lg l lh li">type CruiseMissile = {<br/>  distance: number,<br/>  modelName: string<br/>};<br/>type <!-- -->CruiseMissileTask <!-- -->= <!-- -->CruiseMissile <!-- -->&amp; { targetName: string; };</span><span id="7039" class="ld le in kz b gy lj lg l lh li">const getMissile = (item: <!-- -->CruiseMissileTask<!-- -->): string =&gt; {<br/>  return `${item.targetName}`;<br/>};</span><span id="d1c3" class="ld le in kz b gy lj lg l lh li">const missile: CruiseMissileTask = {<br/>  distance: 4000,<br/>  modelName: 'XYZ99',<br/>  targetName: 'Black Rock'<br/>};<br/>console.log(missile);</span></pre><p id="f2df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者在转换成数字实际方面使用这个逻辑:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="b1d8" class="ld le in kz b gy lf lg l lh li">private readonly mapToNumber = (value: unknown):<br/>  undefined | number =&gt; value &amp;&amp; Number(value);</span><span id="2d7c" class="ld le in kz b gy lj lg l lh li">this.mapToNumber(this.dataControl.value);</span></pre><h1 id="d41c" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">不同结构的优势</h1><p id="5539" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated"><strong class="jm io">类型好处:什么类型能做，接口不能做:</strong></p><p id="8e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">元组类型</strong> <code class="fe mm mn mo kz b">|</code></p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="cad6" class="ld le in kz b gy lf lg l lh li">type FlyingSaucer = string | { name: string };<br/>const mySaucer: FlyingSaucer = { name: 'UFO' }<br/>console.log(mySaucer.name);</span></pre><p id="05a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个例子:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="c01c" class="ld le in kz b gy lf lg l lh li">export type AircraftType= 'PLANE' | 'HELICOPTER' | 'SAUCER' | 'UFO';<br/><br/>export const AirType = {<br/>    PLANE: 'PLANE' as AircraftType,<br/>    HELICOPTER: 'HELICOPTER' as AircraftType,<br/>    SAUCER: 'SAUCER' as AircraftType,<br/>    UFO: 'UFO' as AircraftType<br/>};</span></pre><p id="609e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">映射对象类型键/值</strong> —类型可用选项</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="bf2b" class="ld le in kz b gy lf lg l lh li">type Aircraft = 'discoVolante' | 'saucer' | 'ufo';</span><span id="a7ed" class="ld le in kz b gy lj lg l lh li">// works with types, not with necessary<br/>type AircraftCount = {<br/>  [key in Aircraft]: number;<br/>}</span><span id="02c8" class="ld le in kz b gy lj lg l lh li">const aircrafts: AircraftCount = {<br/>  discoVolante: 10,<br/>  saucer: 1,<br/>  ufo: 2<br/>};<br/>console.log(aircrafts);</span></pre><p id="37f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用枚举用法作为关键字:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="5e9e" class="ld le in kz b gy lf lg l lh li">enum Engine { petrol = 'PETROL', electric = 'ELECTRIC' }<br/>type TEngine = {<br/>  [k in Engine]: boolean;<br/>}<br/>const engine: TEngine = { PETROL: true, ELECTRIC: false};<br/>console.log(engine);</span></pre><h1 id="8644" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么时候用<code class="fe mm mn mo kz b">interface</code>？</h1><p id="0164" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated"><strong class="jm io">多态性</strong></p><p id="3386" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将接口命名为契约，以实现如何使用该对象。</p><p id="6d8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个类可以实现一个接口或类型别名，就像任何其他 OOP 一样，两者都以完全相同的方式实现。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="47f3" class="ld le in kz b gy lf lg l lh li">interface Engine {<br/>  power: number;<br/>  torque: number;<br/>}</span><span id="2ecb" class="ld le in kz b gy lj lg l lh li">class EngineParams implements Engine {<br/>  power = 250;<br/>  torque = 488;<br/>}</span><span id="a57e" class="ld le in kz b gy lj lg l lh li">type Engine = {<br/>  power: number;<br/>  torque: number;<br/>};</span><span id="61b5" class="ld le in kz b gy lj lg l lh li">class EngineParams2 implements AnotherEngine {<br/>  power = 100;<br/>  torque = 130;<br/>}</span></pre><p id="027d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接口无法实现/扩展命名联合类型的类型别名。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="4d58" class="ld le in kz b gy lf lg l lh li">type EngineAsUnionType = { power: number; } | { torque: number; };<br/>class test implements EngineAsUnionType {<br/>  power = 1001;<br/>  torque = 500;<br/>}<br/>// error with union type</span></pre><h1 id="2aad" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">5.声明合并</h1><p id="5203" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">接口可以多次定义，并将合并为一个。这样使用类型将会产生错误，因为类型不能重新声明。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="5c80" class="ld le in kz b gy lf lg l lh li">interface User {<br/>  name: string;<br/>}</span><span id="817a" class="ld le in kz b gy lj lg l lh li">interface User {<br/>  phone: string;<br/>}</span><span id="fd56" class="ld le in kz b gy lj lg l lh li">// no error<br/>const user: User = {<br/>  name: 'alex',<br/>  phone: 'XXX-XXXX-XXX'<br/>};<br/>console.log(`${user.name} , ${user.phone}`);</span></pre><h1 id="71b3" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么时候用<code class="fe mm mn mo kz b">type</code>？</h1><p id="b35d" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated"><strong class="jm io">类型混叠</strong></p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="b8a1" class="ld le in kz b gy lf lg l lh li">type Primitive = boolean | null | undefined | number | string;</span></pre><p id="484e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">类型捕捉</strong> —使用 typeof 识别对象的类型。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="001f" class="ld le in kz b gy lf lg l lh li">const engine = { capacity: 2200, type: "diesel" }<br/>type Engine = typeof engine;<br/>console.log(typeof engine);</span><span id="8725" class="ld le in kz b gy lj lg l lh li">// use type to assign new values<br/>const customEngine: Engine = { capacity: 2500, type: 'petrol'};<br/>console.log(customEngine);</span></pre><p id="b83d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，让我们从对象中提取属性的类型:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8f30" class="ld le in kz b gy lf lg l lh li">type ObjectInfer&lt;O&gt; = O extends {message: infer A} ? A: never<br/>const object = {message: 'test'};<br/>type testResult1 = ObjectInfer&lt;typeof object&gt;; // string<br/>type testResult2 = ObjectInfer&lt;string&gt;; // never</span><span id="c412" class="ld le in kz b gy lj lg l lh li">const msg: testResult1 = "result string";<br/>console.log(msg);</span></pre><p id="a7bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">通用转换</strong></p><p id="d271" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您将多个类型转换成一个通用类型时，使用<code class="fe mm mn mo kz b">type</code>。</p><pre class="kj kk kl km gt ky kz mp bn mq mr bi"><span id="6522" class="ms le in kz b be mt mu l mv li">type Nullable&lt;T&gt; = T | null | undefined<br/>type NonNull&lt;T&gt; = T extends (null | undefined) ? never : T<br/>type EngineType = { power: number; torque: number; };<br/>const engine : NonNull&lt;EngineType&gt; = { power: 1001, torque: 800 }<br/>console.log(engine.power);</span></pre><p id="d5cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">应该避免什么。</strong></p><p id="1079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果是联合类型，那么我们就不能使用实现。</p><pre class="kj kk kl km gt ky kz mp bn mq mr bi"><span id="d057" class="ms le in kz b be mt mu l mv li">type EngineFuel= Petrol | Diesel | Electric | Methane gas | Hydrogen | Ethanol;<br/>class CustomCar implements EngineFuel {<br/>} </span></pre><p id="ad4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不可能多次使用同一类型的名称。</p><pre class="kj kk kl km gt ky kz mp bn mq mr bi"><span id="ad71" class="ms le in kz b be mt mu l mv li">type CustomType = {a: string}<br/>type CustomType = {b: number}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/d0a18a421d0daf7b305c26bd67663d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35jYwiZSPQ_F9o6FIN-ARQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每个细节中的神秘和象征</figcaption></figure><p id="33d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="db65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原则上，使用类型或接口大多是个人选择。看情况。</p></div></div>    
</body>
</html>