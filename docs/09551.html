<html>
<head>
<title>Understanding Golang net/textproto</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Golang net/textproto</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-golang-net-textproto-d179591d2dae?source=collection_archive---------3-----------------------#2022-08-28">https://blog.devgenius.io/understanding-golang-net-textproto-d179591d2dae?source=collection_archive---------3-----------------------#2022-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4cc7b1aff76b02e374df21f5904b730e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AoHeOV4v5iuaAnWFVm6uQ.jpeg"/></div></div></figure><p id="4511" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在进入<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> textproto </strong> </a>包和它的一些用途之前，让我们写一个简单的客户机和服务器代码来理解客户机和服务器之间是如何执行读写的。</p><p id="d900" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标准的<a class="ae kt" href="https://pkg.go.dev/net" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> net </strong> </a>包提供了一个类型<a class="ae kt" href="https://pkg.go.dev/net#Conn" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Conn 接口</strong> </a> <strong class="jx io"> </strong>，可用于向连接写入数据和从连接读取数据。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="fd4a" class="ld le in kz b gy lf lg l lh li">type Conn interface {<br/>   Read(b []byte) (n int, err error)<br/>   Write(b []byte) (n int, err error)<br/>   ....<br/>}</span></pre><p id="3c06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，客户端使用<strong class="jx io"> Write </strong>方法将数据写入连接，服务器使用<strong class="jx io"> Read </strong>方法读取连接上写入的数据。</p><p id="f769" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:为了简单起见，我忽略了代码中返回的错误检查。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用<strong class="ak">读取</strong>的服务器代码</figcaption></figure><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">客户端代码使用<strong class="ak">编写</strong></figcaption></figure><p id="7926" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种读写方式可以是使用<a class="ae kt" href="https://pkg.go.dev/bufio" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> bufio </strong> </a>读取器和写入器来实现对<strong class="jx io"> io 的缓冲。阅读器</strong>和<strong class="jx io"> io。分别写入</strong>对象。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="5e88" class="ld le in kz b gy lf lg l lh li">func <a class="ae kt" href="https://pkg.go.dev/bufio#NewReader" rel="noopener ugc nofollow" target="_blank">NewReader</a>(rd io.Reader) *Reader<br/>NewReader returns a new Reader whose buffer has the default size.</span><span id="b4c8" class="ld le in kz b gy lq lg l lh li">func <a class="ae kt" href="https://pkg.go.dev/bufio#NewWriter" rel="noopener ugc nofollow" target="_blank">NewWriter</a>(w io.Writer) *Writer<br/>NewWriter returns a new Writer whose buffer has the default size.</span></pre><p id="d7e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个例子。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">服务器代码使用<strong class="ak"> bufio 读取</strong></figcaption></figure><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">客户端代码使用<strong class="ak"> bufio 写</strong></figcaption></figure><p id="9f9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是来自标准文档页面的 textproto 的概述。</p><blockquote class="lr ls lt"><p id="3bab" class="jv jw lj jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated">Package textproto 实现了对 HTTP、NNTP 和 SMTP 风格的基于文本的请求/响应协议的一般支持。</p></blockquote><p id="ce2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好的理解，我举一个<strong class="jx io"> SMTP </strong>协议的例子。在 SMTP 协议中，电子邮件的正文部分在<strong class="jx io">数据</strong>命令后从客户端逐行传输到服务器。正文由一系列以<code class="fe lx ly lz kz b">\r\n</code>结尾的行组成。该序列在仅包含一个点的行结束:<code class="fe lx ly lz kz b">.\r\n</code>。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/b7370db2d58c8707f28afd3d57ff4c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNVd0o0ax6mUp_tO3udDjA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#:~:text=An%20SMTP%20transaction%20consists%20of,times%2C%20one%20for%20each%20recipient." rel="noopener ugc nofollow" target="_blank"> SMTP 维基百科</a></figcaption></figure><p id="41f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">textproto 的<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Writer.DotWriter" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> DotWriter </strong> </a>返回一个可以用来编写上述格式的编写器，<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Reader.DotReader" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">dot reader</strong></a><strong class="jx io"/>提供了一个方便的方法来读取它。它还支持代表 MIME 风格头映射的<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#MIMEHeader" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">类型 MimeHeader </strong> </a>。它提供了添加新的键-值标题对、获取与标题键相关的值等功能。</p><p id="f1ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个使用 textproto 包的客户端和服务器的例子。</p><p id="2dd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用 textproto 的<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#NewReader" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> NewReader </strong> </a>，它采用<strong class="jx io"> *bufio。阅读器</strong>阅读器和返回<strong class="jx io">*阅读器</strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="aee6" class="ld le in kz b gy lf lg l lh li">type Reader struct {<br/>	R *<a class="ae kt" href="https://pkg.go.dev/bufio" rel="noopener ugc nofollow" target="_blank">bufio</a>.<a class="ae kt" href="https://pkg.go.dev/bufio#Reader" rel="noopener ugc nofollow" target="_blank">Reader</a><br/>}</span></pre><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用 textproto DotReader 和 MIMEHeader 的服务器代码</figcaption></figure><p id="02ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">textproto 的<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Dial" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">拨</strong> </a>用网。内部拨号并返回一个新的<strong class="jx io">型</strong>连接器<strong class="jx io">用于连接</strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="171b" class="ld le in kz b gy lf lg l lh li">type Conn struct {<br/>	<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Reader" rel="noopener ugc nofollow" target="_blank">Reader</a><br/>	<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Writer" rel="noopener ugc nofollow" target="_blank">Writer</a><br/>	<a class="ae kt" href="https://pkg.go.dev/net/textproto@go1.19#Pipeline" rel="noopener ugc nofollow" target="_blank">Pipeline</a><br/>}</span></pre><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用 textproto DotWriter 的客户端代码</figcaption></figure><p id="6371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在就这些了。希望这有所帮助:-)</p></div></div>    
</body>
</html>