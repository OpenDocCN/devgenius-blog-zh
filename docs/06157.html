<html>
<head>
<title>Single Sign-on Implementation for Enterprise Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业应用程序的单点登录实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/single-sign-on-implementation-for-enterprise-applications-ea51086d0548?source=collection_archive---------10-----------------------#2021-12-17">https://blog.devgenius.io/single-sign-on-implementation-for-enterprise-applications-ea51086d0548?source=collection_archive---------10-----------------------#2021-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f33b46b991840fbc59bd3dddea19abd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzS9AgRm5gptX7tgSXqOJg@2x.png"/></div></div></figure><p id="7ba2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">公司在转向单点登录(SSO)实施时经常面临困难。他们中的许多人都停留在第一步，试图找出SSO的好处、实现的最佳实践、类型、协议和其他基本的东西。我决定阐明单点登录的意义，分享MobiDev的经验，甚至为在移动应用程序之间以最方便的方式使用SSO重新发明轮子。</p><p id="61c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">单点登录(SSO) </strong>是一种身份验证的技术方法，允许用户使用一套凭据登录多个应用程序和网站。该技术基于在应用程序(称为服务提供商)和访问管理系统之间建立可靠的关系。服务提供商和访问管理系统共享带有标识数据的证书，在SSO的情况下，标识数据采用包括电子邮件、用户名或其他数据的令牌的形式。</p><p id="7cb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">简单来说，使用单点登录，用户在应用程序之间切换时不需要重新输入用户名和密码。</strong></p><h1 id="7307" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">单点登录的类型有哪些？</h1><p id="15d3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">SSO是<a class="ae lw" href="https://www.techtarget.com/searchsecurity/definition/federated-identity-management" rel="noopener ugc nofollow" target="_blank">联合身份管理</a> (FIM)架构的一部分。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/359c60de696790410b3142f51e01e170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kX7embr-SZcERDX-i23vA.jpeg"/></div></div></figure><h1 id="6dae" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">单点登录使用什么协议？</h1><p id="999f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">用于SSO实现的协议有安全断言标记语言(SAML)、Web服务联合(WS-Fed)、OpenID连接(OIDC)、轻量级目录访问协议(LDAP)和Kerberos。</p><h1 id="1746" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">单点登录优势</h1><p id="577b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">根据研究和市场，全球单点登录市场预计到2027年将达到22亿美元。然而，公司担心与一次点击访问相关的潜在安全威胁，他们认为SSO实现是简化对其应用程序的访问并改善用户体验的一种手段。</p><p id="410f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单点登录的好处不止于此，还包括以下几点:</p><ul class=""><li id="5ff1" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">减少密码疲劳—用户只需记住一个密码</li><li id="7a34" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">高效的B2B协作——B2B合作关系随着<a class="ae lw" href="https://www.ibm.com/docs/sk/cip?topic=access-federated-sso-overview" rel="noopener ugc nofollow" target="_blank">联合单点登录</a>而繁荣，因为用户可以轻松访问不同公司提供的服务</li><li id="15d6" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">通过更快的登录来提高生产力</li><li id="93bf" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">高采用率—单点登录增加了用户更频繁地打开应用程序的可能性</li></ul><p id="e5a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">主要缺点</strong>是如果单点登录失败，用户无法访问任何相关系统。至于复杂，被认为是有条件的下行。</p><p id="cab1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安全性可以单独列出。</p><p id="6a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一方面</strong>，拥有一套凭证的SSO意味着在出现安全漏洞的情况下，攻击者可以访问帐户和链接的系统、应用程序和数据，并且攻击者在公司内的足迹会增加。</p><p id="e606" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">另一方面</strong>，SSO减少了攻击面的数量，因为用户每天登录一次，只使用一套凭证。如果您将SSO与基于风险的身份验证(RBA)结合起来，识别异常行为，并要求用户通过额外的验证，则可以实现更高的安全级别。</p><h1 id="3202" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">企业应用程序的SSO实现最佳实践</h1><p id="1032" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">SSO很难实现吗？问题的一般观点是这样的:对于遗留解决方案来说，SSO部署是一项复杂而耗时的任务，但是基于云的SSO是不同的。让我分享一下我们的经验，这将有助于了解企业应用程序中的单点登录。</p><p id="31fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直到最近，为本地应用程序设置联邦SSO还是一项复杂的挑战。开发人员有两种选择可以使用SSO在应用程序中显示内容:将用户从应用程序切换到系统浏览器，然后返回或显示应用程序内webview，以便直接在应用程序中呈现html内容。这些选项对用户来说不方便，或者它们有安全和隐私问题。</p><p id="b0d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三种选择的出现——SFSafariViewController(IOs 9+)和Chrome自定义标签(Android)增加了一个web控制器，提供了原生系统浏览器的所有优势——这让开发者受益匪浅。</p><p id="2bca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的经验与使用不同版本的NativeScript构建的两个移动应用程序之间的SSO实现有关— <strong class="jx io"> app1 </strong>和<strong class="jx io"> app2 </strong>。但事实上，所描述的SSO方法对于本地和跨平台应用程序都是相同的。</p><p id="b4fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> App1 </strong>是移动的，而<strong class="jx io"> app2 </strong>暗示了移动和web的结合，在这种情况下，向新版本的过渡预计会出现问题。通过OpenID Connect (OIDC)客户端进行授权的身份提供者在应用程序中很常见，这有助于启动。我们有三个选项可供选择:WebView、系统浏览器和InAppBrowser。</p><h1 id="0f4d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">1.单点登录实现方法:带有COOKIE共享的WEBVIEW</h1><p id="a0e5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">登录第一个应用程序基于<a class="ae lw" href="https://developer.android.com/reference/android/webkit/WebView" rel="noopener ugc nofollow" target="_blank"> WebView </a>，而登录第二个应用程序使用混合应用程序世界中众所周知的<a class="ae lw" href="https://cordova.apache.org/docs/en/3.1.0/cordova/inappbrowser/inappbrowser.html" rel="noopener ugc nofollow" target="_blank"> InAppBrowser </a>，带有Android的Chrome自定义标签和iOS的safari services/AuthenticationServices。</p><p id="2ea6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该研究揭示了在规定的条件下实现SSO的三个可用选项，尽管它们对日志记录意味着相同的事情— WebView(应该设想共享cookies)。</p><p id="e5ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WebView嵌入在应用程序的本机屏幕中(就像它是web中的iFrame一样)，这可以被视为该方法的优势，因为登录期间的导航对于用户来说看起来很自然。动画和风格在整体画面中并不突出。</p><p id="75b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用WebView进行日志记录的主要问题是与页面加载相关的回调延迟。为了解决这个问题，开发人员提出了他们自己的想法，如何准确地理解登录表单(网页)何时被加载，他们可能会隐藏指示器。否则，它将显示在已经加载的登录屏幕上，或者在屏幕加载之前隐藏。该故障可能会导致提交到App Store的应用程序的审核出现问题。在Android上访问cookies也有问题，如果不打开使用SSO的外部链接，很难设置一个通用登录。</p><h1 id="d662" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">2.单点登录实现方法:系统浏览器</h1><p id="b379" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用系统浏览器可能是一个可靠的解决方案，但这意味着离开应用程序并打开浏览器来填写登录表单。带有登录信息的选项卡在浏览器中保持未关闭状态，并会累积。但是，这种方法很容易实现，因为一切都与web上的工作方式相同，两个应用程序都将在相同的环境中打开一个登录表单，使用OIDC客户端用来验证用户的相同cookies，并正确设置两个应用程序的服务器标识。在系统浏览器的情况下，一切运行顺利，没有延迟，但对用户来说不舒服。</p><p id="2b2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Microsoft Authenticator不被认为是SSO实现解决方案，因为要登录，用户应该离开一个应用程序，在第二个应用程序中授权，然后在第一个应用程序中确认授权，依此类推。委婉地说，它对用户来说不方便，甚至比系统浏览器还糟糕。</p><h1 id="e53c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.SSO实现方法:INAPPBROWSER</h1><p id="a677" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Android中的标签和iOS中的服务可以在系统中定制为带有平台动画和外观的本地弹出窗口。它们跟踪重定向，如果登录输入正确，就会被关闭。在WebView的情况下没有问题，尽管如果设计不同于本地平台的组件，登录表单看起来与应用程序分离。这是在移动应用程序中实现SSO的一种推荐且安全的方法。</p><p id="b078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">经过反复试验，我们决定选择InAppBrowser。它有一个共同的沙箱，在一个应用程序中有cookies，所以如果你应用它，然后打开其中的其他web链接，用户应该通过SSO登录，这意味着根本不会出现问题。但是在两个不同的应用程序中，这些沙箱会有所不同，您需要以某种方式从一个沙箱中获取信息，并将其放入另一个沙箱中，以实现应用程序之间的SSO。</p><p id="b346" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这样的共享过程，我们在iOS中应用了钥匙串存储，在Android中应用了安全存储，因为它们都可以在设备上安全地存储数据。他们可以为一个应用程序或几个受信任的应用程序隔离商店，但这需要在每个移动应用程序中执行额外的配置步骤。</p><p id="6329" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">配置了共享存储之后，我们就可以在两个应用程序之间进行数据交换了。一个在localStorage api中再现输入-输出方法的附加包装器允许我们为OIDC客户端UserManager引入公共本地存储。</p><h1 id="4a6c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">MobiDev实现单点登录的方法</h1><p id="0d72" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于大多数应用程序来说，实现这些步骤就足够了，在这些应用程序中，身份提供者最初是为应用程序之间的SSO而配置的，但是由于这存在一些困难，我们必须进一步“重新发明轮子”。</p><p id="2661" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到OIDC客户端，我应该提到它有几个不同的流程，用于使用用户名和密码登录、双因素身份验证和其他功能。但是，SSO和会话更新需要所谓的代码流，在用户输入凭据后，返回的不是会话令牌，而是必须与会话数据交换的对象代码，即:</p><ul class=""><li id="37bc" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">会话令牌(Session token用于访问应用程序API)</li><li id="442b" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">令牌的寿命</li><li id="2ca1" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">用于刷新会话的令牌(refreshToken用于刷新会话令牌)</li><li id="e3cd" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">令牌的寿命</li></ul><p id="6aa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要配置令牌生命周期，应使用身份服务器。和往常一样，sessionToken持续数小时或数天，refreshToken持续数周或数月。长期refreshToken可用于在移动应用程序中使用生物特征进行登录。一种算法如下:</p><ol class=""><li id="8196" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mq mi mj mk bi translated">生物特征读取</li><li id="9a12" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mq mi mj mk bi translated">吃点新鲜的</li><li id="0495" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mq mi mj mk bi translated">获取新的会话令牌</li><li id="29b3" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mq mi mj mk bi translated">让用户访问应用程序</li></ol><p id="b251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种令牌更新不会被应用程序用户注意到，因为它并不意味着打开浏览器、WebView或InAppBrowser窗口，令牌的简单更新就是授予用户对应用程序的访问权限。所描述的方法使登录运行顺畅，并在两个应用程序中使用。</p><p id="807b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据文档，在移动应用程序之间使用SSO，无论哪种方式，都需要打开浏览器WebView，InAppBrowser，它将登录，并在关闭后打开第二个应用程序。我们努力创造更方便的东西，并找到适合每个人的解决方案。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/125f395e68204ae9ec1dba183aa1bd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uL43utof5zMSkzJ878c5ow.jpeg"/></div></div></figure><h1 id="0d04" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">深层链接和进一步行动</h1><p id="c055" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">解决方案在于通过深度链接功能从另一个应用程序打开一个应用程序(深度链接将用户直接发送到特定的应用程序内位置)——然后神奇的事情就发生了。</p><p id="457b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> App1 </strong>打开深度链接，<strong class="jx io"> app2 </strong>使用深度链接打开。在点击打开深度链接之前，<strong class="jx io"> app1 </strong>生成一个唯一的令牌并存储在两个应用的公共存储器中，然后将相同的令牌作为参数插入深度链接并处理点击。这种方法是出于安全目的而实现的。没有其他人可以访问这个共享存储，也不可能通过从外部使用深层链接登录并自动进入另一个应用程序。</p><p id="9cf7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成的唯一令牌包括时间戳、用户名、安全和验证用户数据所需的数据以及防止猜测的随机内容，时间戳定义了令牌的有效期。</p><p id="b6a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">获得与令牌的深层链接，<strong class="jx io"> app2 </strong>解析令牌，将其与共享存储中的令牌进行比较，然后检查用户身份。从创建令牌开始的时间应该大约是一秒钟。仅在此之后，<strong class="jx io"> app2 </strong>通过refreshToken获得一个新令牌，该令牌使用应用程序的生物特征登录，并在深度链接中添加的屏幕上重定向用户。</p><p id="2fc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅当<strong class="jx io"> app2 </strong>拥有有效(未过期)的刷新令牌并且启用了生物识别登录时，此功能才有效。否则，用户仍然需要手动输入数据，就好像令牌或用户名不匹配一样。打开浏览器或WebView的默认SSO流程也有同样的缺点。登录后，仍然可以将用户直接发送到所需的应用程序屏幕。</p><p id="7263" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个应用程序都有自己的设置和id，这些设置和id在identity server的系统中是唯一的。所有的更改将仅由UI团队完成，并且该解决方案将与任何具有代码流的身份提供者一起工作。</p><p id="b6c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，公司正在集中投资建立单点登录，而实现方法是由他们的需求驱动的。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="7948" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由<a class="ae lw" href="https://mobidev.biz/services/web-application-development" rel="noopener ugc nofollow" target="_blank"> MobiDev </a>的JavaScript小组负责人Andrii Sulymka撰写。</p><p id="ab34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="my">全文原载于</em><a class="ae lw" href="https://mobidev.biz/blog/single-sign-on-sso-implementation-benefits-enterprise" rel="noopener ugc nofollow" target="_blank"><em class="my">https://mobidev . biz</em></a><em class="my">，基于mobi dev技术研究。</em></p></div></div>    
</body>
</html>