<html>
<head>
<title>How to Profile and Benchmark Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何评测 Python 代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-profile-and-benchmark-python-code-e82a22a2a72c?source=collection_archive---------6-----------------------#2022-12-29">https://blog.devgenius.io/how-to-profile-and-benchmark-python-code-e82a22a2a72c?source=collection_archive---------6-----------------------#2022-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/e9ca2da90e9b9a01c958de2f16661350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*Pr7HP1fV3VE_I63BHSiiPw.jpeg"/></div></figure><p id="e4b2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">假设我们有两个功能:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="b66d" class="ky kz in ku b be la lb l lc ld">def multiples_of(x: int, max: int) -&gt; list[int]:<br/>    """<br/>    Iteratively Find all the multiples of `x` between 0 and `max`<br/>    i.e 0 &lt; M &lt;= max.<br/>    <br/>    :return list[int]: all multiples<br/>    """<br/>    v = max // x<br/>    return [(i + 1) * x for i in range(v)]</span></pre><p id="2942" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">和</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="068d" class="ky kz in ku b be la lb l lc ld">def gen_multiples_of(x: int, max:int) -&gt; Generator:<br/>    """<br/>    Find all the multiples of `x` between 0 and `max`<br/>    i.e 0 &lt; M &lt;= max.<br/>    <br/>    :return Generator: Can be iterated over to return a list of multiples<br/>    """<br/>    v = max // x<br/>    i = 0<br/>    multiple = 0<br/>    while (multiple &lt;= max) and (i &lt; v):<br/>        multiple = (i + 1) * x<br/>        i += 1<br/>        yield multiple</span></pre><p id="c5a9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">他们都做同样的事情。我们如何判断哪个函数优化得更好，效率更高？我们应该在项目中使用哪个？</p><blockquote class="le lf lg"><p id="ef94" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">在这种情况下，效率意味着用最少的时间做大量的工作。我们不一定会考虑计算成本。在现实世界中，选择任何功能都需要更多的上下文(可维护性、可用资源等)。)</p></blockquote><h1 id="0550" class="ll kz in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Timeit 模块</h1><p id="f9c2" class="pw-post-body-paragraph jr js in jt b ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko ig bi translated">开始概要分析的最简单方法之一是，<strong class="jt io"> timeit </strong>模块是 Python 标准库的一部分。</p><p id="c6e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">技术上，<code class="fe mn mo mp ku b"><strong class="jt io">timeit</strong></code> <strong class="jt io">是</strong>用于标杆代码。从<a class="ae mq" href="https://rbspy.github.io/" rel="noopener ugc nofollow" target="_blank"> rbspy 文档</a>中，</p><blockquote class="le lf lg"><p id="b969" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated"><strong class="jt io">基准测试告诉你你的代码有多慢(“做 X Y Z 花了 20 秒”)，剖析器告诉你为什么慢(“35%的时间花在压缩上”)</strong></p></blockquote><p id="1fd7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面是我们如何使用它来测试我们的功能:</p><ul class=""><li id="bde0" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated">我们将首先创建一个 main/runner 函数，这样我们的生成器也会得到评估</li></ul><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="3653" class="ky kz in ku b be la lb l lc ld">def run(f):<br/>    # f will be one of our functions<br/>    for i in f(x=3, max=1000):<br/>        pass<br/><br/># Example Usage<br/>lambda: run(multiples_of)<br/>lambda: run(gen_multiples_of)</span></pre><ul class=""><li id="039c" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated">导入<code class="fe mn mo mp ku b"><strong class="jt io">timeit</strong></code>包并使用它的<code class="fe mn mo mp ku b"><strong class="jt io">timeit</strong></code>函数来测量代码执行时间</li></ul><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="503f" class="ky kz in ku b be la lb l lc ld">import timeit <br/><br/>n = int(1500)<br/>r = timeit.timeit(lambda: run(multiples_of), number=n)<br/>print(f"Iterative Function:, Total Time (for {n} cycles): {r}s, Average time (per cycle) {r/n}s")<br/><br/>r = timeit.timeit(lambda: run(gen_multiples_of), number=n)<br/>print(f"Generator Function:, Total Time (for {n} cycles): {r}s, Average time (per cycle) {r/n}s")</span></pre><p id="7173" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">样本输出:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="e8ca" class="ky kz in ku b be la lb l lc ld">Iterative Function:, Total Time (for 1500 cycles): 0.15279039996676147s, Average time (per cycle) 0.00010186026664450765s<br/>Generator Function:, Total Time (for 1500 cycles): 0.29554930003359914s, Average time (per cycle) 0.0001970328666890661s</span></pre><p id="920c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">看来迭代函数比生成函数快。这可能是因为列表理解和 while 循环中的常量求值吗？我们会和另一个侧写员一起深入调查。</p><p id="c2d6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">来自<code class="fe mn mo mp ku b"><a class="ae mq" href="https://docs.python.org/3/library/timeit.html#timeit.Timer.timeit" rel="noopener ugc nofollow" target="_blank">Time.timeit()</a></code> <a class="ae mq" href="https://docs.python.org/3/library/timeit.html#timeit.Timer.timeit" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="le lf lg"><p id="069b" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">时间<em class="in">数量</em>主语句的执行次数。这将执行 setup 语句一次，然后<strong class="jt io">返回多次执行 main 语句所花费的时间，以秒为单位，以浮点形式计算</strong>。参数是循环的次数，默认为一百万次。</p></blockquote><p id="e8fe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于<code class="fe mn mo mp ku b"><strong class="jt io">timeit</strong></code>模块的注意事项:</p><ul class=""><li id="cbd5" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated">在执行测试时，垃圾收集每次都被 time()函数禁用。</li><li id="fabd" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><strong class="jt io">timeit()</strong></code>根据您正在使用的操作系统，内部采用准确的时间。例如，它将为 Windows 操作系统使用 time.clock()，为 mac 和 Linux 使用 time.time()。</li><li id="668b" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><strong class="jt io">timeit</strong></code>还公开了一个<a class="ae mq" href="https://docs.python.org/3/library/timeit.html#command-line-interface" rel="noopener ugc nofollow" target="_blank">命令行接口</a>。</li></ul><h1 id="81b1" class="ll kz in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">cProfile 模块</h1><p id="d407" class="pw-post-body-paragraph jr js in jt b ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko ig bi translated">来自官方文件:</p><blockquote class="le lf lg"><p id="0ff1" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated"><code class="fe mn mo mp ku b"><a class="ae mq" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank">cProfile</a></code>推荐大多数用户使用；它是一个 C 扩展，具有合理的开销，适合于分析长时间运行的程序。</p></blockquote><p id="abc4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mn mo mp ku b">cProfile</code>模块揭示了执行特定函数需要多长时间，以及该函数在程序中被调用了多少次。一个例子:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="5408" class="ky kz in ku b be la lb l lc ld">import cProfile<br/>cProfile.run("run(multiples_of)")<br/><br/>print("\n\n")<br/><br/>cProfile.run("run(gen_multiples_of)")</span></pre><p id="9dc4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们得到类似如下的输出:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="8964" class="ky kz in ku b be la lb l lc ld">6 function calls in 0.119 seconds<br/><br/>Ordered by: standard name<br/><br/>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        1    0.000    0.000    0.119    0.119 &lt;string&gt;:1(&lt;module&gt;)<br/>        1    0.106    0.106    0.106    0.106 euler-1.py:12(&lt;listcomp&gt;)<br/>        1    0.013    0.013    0.119    0.119 euler-1.py:30(run)<br/>        1    0.000    0.000    0.106    0.106 euler-1.py:4(multiples_of)<br/>        1    0.000    0.000    0.119    0.119 {built-in method builtins.exec}<br/>        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}<br/><br/><br/><br/><br/><br/>333338 function calls in 0.415 seconds<br/><br/>Ordered by: standard name<br/><br/>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        1    0.000    0.000    0.415    0.415 &lt;string&gt;:1(&lt;module&gt;)<br/>   333334    0.266    0.000    0.266    0.000 euler-1.py:15(gen_multiples_of)<br/>        1    0.149    0.149    0.415    0.415 euler-1.py:30(run)<br/>        1    0.000    0.000    0.415    0.415 {built-in method builtins.exec}<br/>        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><p id="a6f8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这意味着什么(直接来自文档):</p><ul class=""><li id="79be" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">ncalls</em></code>:对于通话次数，</li><li id="e356" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">tottime</em></code>:给定函数花费的总时间(不包括调用子函数的时间)</li><li id="6004" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">percall</em></code>:是<code class="fe mn mo mp ku b">tottime</code>的商除以<code class="fe mn mo mp ku b">ncalls</code></li><li id="b804" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">cumtime</em></code>:该子功能和所有子功能的累计时间(从调用到退出)。这个数字对于递归函数来说是精确的<em class="lh">甚至</em>。</li><li id="272d" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">percall</em></code> : <em class="lh"> </em>是<code class="fe mn mo mp ku b">cumtime</code>除以原始调用的商</li><li id="9057" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe mn mo mp ku b"><em class="lh">filename</em></code> : lineno(function)提供各功能各自的数据以供识别。</li></ul><p id="2234" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从我们的结果来看，很明显，生成器函数本身并不需要很长时间来执行，但是因为它被调用了很多次(比<code class="fe mn mo mp ku b">10^5</code>更多)，所以整体执行相当慢。相比之下，我们只需调用一次迭代函数，就能在 50%的时间内完成。当我们处理相对较大的数据集时，如果我们有太多的值无法放入内存，我们仍然会使用生成器函数。这里的权衡变得很明显。</p><p id="452f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于 cProfile 需要注意的事项:</p><ul class=""><li id="7842" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated">您可以根据执行时间、函数名、调用次数等对分析结果进行排序。</li><li id="18d2" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">可以使用<code class="fe mn mo mp ku b"><a class="ae mq" href="https://docs.python.org/3/library/profile.html#the-stats-class" rel="noopener ugc nofollow" target="_blank"><em class="lh">pstats</em></a></code> <a class="ae mq" href="https://docs.python.org/3/library/profile.html#the-stats-class" rel="noopener ugc nofollow" target="_blank"> <em class="lh"> </em>包</a>对执行概要文件进行进一步分析。</li><li id="f9a3" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">cProfile 有一个<a class="ae mq" href="https://docs.python.org/3/library/profile.html#instant-user-s-manual" rel="noopener ugc nofollow" target="_blank">命令行接口</a> (CLI)以方便使用。</li></ul><h1 id="02bc" class="ll kz in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">可视化个人资料统计(SnakeViz)</h1><blockquote class="le lf lg"><p id="45c9" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">SnakeViz 是一个基于浏览器的图形查看器，用于 Python 的<a class="ae mq" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>模块的输出，是使用标准库<code class="fe mn mo mp ku b"><a class="ae mq" href="https://docs.python.org/3/library/profile.html#module-pstats" rel="noopener ugc nofollow" target="_blank">pstats</a></code> <a class="ae mq" href="https://docs.python.org/3/library/profile.html#module-pstats" rel="noopener ugc nofollow" target="_blank">模块</a>的替代方案。</p></blockquote><p id="789f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">开始安装 snakeviz</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="84c9" class="ky kz in ku b be la lb l lc ld">pip install snakeviz</span></pre><p id="d8e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">剖析您的代码并将统计数据转储到一个文件中</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="24a7" class="ky kz in ku b be la lb l lc ld">import cProfile<br/>pr = cProfile.Profile()<br/>pr.enable()<br/>run(multiples_of)<br/>pr.disable()<br/>pr.dump_stats("multiples_of.prof")<br/><br/>pr = cProfile.Profile()<br/>pr.enable()<br/>run(gen_multiples_of)<br/>pr.disable()<br/>pr.dump_stats("gen_multiples_of.prof")</span></pre><p id="7c9b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将在当前目录下创建两个新文件。您现在可以使用<code class="fe mn mo mp ku b"><strong class="jt io">snakeviz</strong></code>来查看结果。从你的终端运行这个</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="b46b" class="ky kz in ku b be la lb l lc ld">snakeviz multiples_of.prof</span></pre><p id="aab4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">SnakeViz 将生成一个 web 服务器(通常在<a class="ae mq" href="http://127.0.0.1:8080/snakeviz/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/SnakeViz/</a>)，以图表的形式显示您的个人资料结果。在函数中花费的时间部分由可视化元素的范围表示，可以是矩形的宽度，也可以是弧的角度范围，具体取决于您选择的可视化样式。</p><h1 id="2887" class="ll kz in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Yappi:分析并发和多线程程序</h1><p id="0bbd" class="pw-post-body-paragraph jr js in jt b ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko ig bi translated">标准的分析器不能很好地处理并发和多线程程序。一个示例程序:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="9526" class="ky kz in ku b be la lb l lc ld">import asyncio<br/><br/>async def waste_a_lot_time():<br/>    await asyncio.sleep(5)<br/><br/>async def do_something_else():<br/>    print("Hello")<br/>    <br/>async def main():<br/>    tasks = asyncio.gather(<br/>        waste_a_lot_time(),<br/>        do_something_else()<br/>        )<br/>    await tasks<br/>    <br/><br/>asyncio.run(main())</span></pre><p id="04f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们用 cProfile 来分析这段代码，它将不能识别出<code class="fe mn mo mp ku b">waste_a_lot_time</code>是一个瓶颈。没有一个标准的分析器是为了处理并发而构建的，除非开发人员进行一些模拟修补。这就是 Yappi 的用武之地</p><blockquote class="le lf lg"><p id="4ab1" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">yappi 1.2 版引入了<code class="fe mn mo mp ku b">coroutine profiling</code>的概念。使用<code class="fe mn mo mp ku b">coroutine-profiling</code>，你应该能够分析正确的墙/cpu 时间和协程的调用次数。(也包括花费在上下文切换上的时间)。你可以在这里看到细节<a class="ae mq" href="https://github.com/sumerc/yappi/blob/master/doc/coroutine-profiling.md" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="354b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">安装<code class="fe mn mo mp ku b"><strong class="jt io">yappi</strong></code>与</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="2497" class="ky kz in ku b be la lb l lc ld">pip install yappi</span></pre><p id="8423" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将修改之前的脚本:</p><pre class="kp kq kr ks gt kt ku kv bn kw kx bi"><span id="7e81" class="ky kz in ku b be la lb l lc ld">import yappi<br/>import asyncio<br/><br/>async def waste_a_lot_time():<br/>    await asyncio.sleep(5)<br/><br/>async def do_something_else():<br/>    print("Hello")<br/>    <br/>async def main():<br/>    tasks = asyncio.gather(<br/>        waste_a_lot_time(),<br/>        do_something_else()<br/>        )<br/>    await tasks<br/>    <br/>yappi.set_clock_type("wall") # Measure the absolute time taken<br/>yappi.start() # Start profiling/watching<br/><br/>asyncio.run(main())<br/><br/>stats = yappi.get_func_stats() # Get the stats for function calls<br/>stats.sort("ttot") # Sort it by total time<br/>stats.print_all() # Print it all out</span></pre><p id="c654" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">仔细观察，我们可以看到<code class="fe mn mo mp ku b"><strong class="jt io">main</strong></code>占用了很多时间，而<code class="fe mn mo mp ku b"><strong class="jt io">waste_a_lot_time</strong></code>就是负责这个的函数。</p><p id="92c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是这篇文章的全部内容。我们已经能够对 Python 脚本进行基准测试和剖析，并根据我们的结果做出业务决策。</p><blockquote class="nf"><p id="e4ce" class="ng nh in bd ni nj nk nl nm nn no ko dk translated">感谢阅读！敬请订阅更多🙂</p></blockquote><h1 id="b59f" class="ll kz in bd lm ln lo lp lq lr ls lt lu lv np lx ly lz nq mb mc md nr mf mg mh bi translated">额外资源</h1><p id="4450" class="pw-post-body-paragraph jr js in jt b ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko ig bi translated"><a class="ae mq" href="https://machinelearningmastery.com/profiling-python-code" rel="noopener ugc nofollow" target="_blank">https://machinelearningmastery.com/profiling-python-code</a></p><div class="ns nt gp gr nu nv"><a href="https://docs.python.org/3/library/timeit.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">time it——测量小代码片段的执行时间</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">源代码:Lib/timeit.py 这个模块提供了一种简单的方法来为小部分 Python 代码计时。它既有…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">docs.python.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://docs.python.org/3/library/profile.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">Python 分析器</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">源代码:Lib/profile.py 和 Lib/pstats.py，并提供 Python 程序的确定性分析。配置文件是一个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">docs.python.org</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://jiffyclub.github.io/snakeviz/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">SnakeViz</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">SnakeViz 是一个基于浏览器的图形查看器，用于 Python 的 cProfile 模块的输出，是使用…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">jiffyclub.github.io</p></div></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://github.com/sumerc/yappi/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">GitHub - sumerc/yappi:又一个 Python 分析器，但这次是多线程、asyncio 和…</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">一个支持多线程、asyncio 和 gevent 的跟踪分析器。快:Yappi 快。它完全是用 C 语言写的…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj jp nv"/></div></div></a></div></div></div>    
</body>
</html>