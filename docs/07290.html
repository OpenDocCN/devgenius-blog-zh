<html>
<head>
<title>Building Web Service with NodeJS — Part 4 (Connecting to Database)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 NodeJS 构建 Web 服务—第 4 部分(连接到数据库)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-web-service-with-nodejs-part-4-connecting-to-database-3daca3ff49ae?source=collection_archive---------5-----------------------#2022-03-12">https://blog.devgenius.io/building-web-service-with-nodejs-part-4-connecting-to-database-3daca3ff49ae?source=collection_archive---------5-----------------------#2022-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0d10ed5f29acf665a5bfe4ca2f368f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsfmWf-5fbyDUunWzqAb5A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">NodeJS</figcaption></figure><p id="a077" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">读者们好，感谢你们阅读我的教程故事，欢迎来到本教程的第 4 部分。在这一部分中，我们来讨论一下<strong class="kb io">将我们的数据保存在数据库</strong>中。正如我在本教程前面提到的，我们将使用<strong class="kb io"> MongoDB </strong>作为我们的应用程序。如果你错过了之前的第三部分，你可以在这里阅读<a class="ae kx" href="https://bitsizelearning.medium.com/building-web-service-with-nodejs-part-3-router-logging-error-handler-d62a054df27" rel="noopener">。如果想从上一部分的代码库继续，可以在这里</a>抓取代码<a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part3" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f2f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这一部分相当长，所以请耐心等待，如果您遇到任何问题，您可以随时在这里查看完整的代码<a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part4" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"/></a>。尽情享受吧！</p><h1 id="c94a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">MongoDB</h1><p id="c7e2" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">在前一部分中，我们为菜单资源创建了几个 API 端点。我们现在可以获取现有菜单并插入新菜单。然而，正如我前面提到的，数据仍然存储在内存中。如果我们重启应用程序，数据将会丢失。为了保持数据的完整性(使其持久化)，我们需要将数据存储在外部，web 服务服务器之外的某个地方。我们将把数据存储在数据库中。我们选择的数据库是 MongoDB。</p><p id="c07e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于那些还不熟悉 web 开发或任何类型的软件开发的人来说，<strong class="kb io">数据库</strong>基本上是存储数据的服务器。早期占主导地位的数据库是<strong class="kb io">关系数据库</strong>，它只存储结构化数据。相比之下，我们有 MongoDB，它是一个 NoSQL 数据库。NoSQL 数据库存储非结构化或半结构化数据。随着 web 应用程序的不断增长，NoSQL 数据库越来越受欢迎。现在，我们不打算在理论上深入讨论数据库或 MongoDB。相反，让我们跳到应用程序中的实际用法。然而，如果你想了解更多关于数据库的知识，你可以点击<a class="ae kx" href="https://www.oracle.com/database/what-is-database/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="57d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你没有安装我在<strong class="kb io">第 1 部分</strong>中提到的 MongoDB Compass，这是一个简单的提示。现在，是做这件事的最佳时机。只需前往<a class="ae kx" href="https://www.mongodb.com/try/download/compass" rel="noopener ugc nofollow" target="_blank">下载页面</a>，下载与您的操作系统兼容的安装程序并安装。MongoDB 应该和它的 GUI (MongoDB Compass)一起安装。默认情况下，MongoDB 将在 localhost:27017 上运行。</p><h2 id="8581" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">应用程序配置</h2><p id="c274" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">在我们的应用程序中进入数据库连接之前，我们将讨论一下应用程序配置，以及它如何对数据库连接有用。以前，在我们的 src/index.js 中，我们让我们的 express 应用程序监听端口 3000(这样我们就可以通过<a class="ae kx" href="http://localhost:3000)." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 访问 API)。</a>现在端口号<strong class="kb io"> 3000 </strong>在我们的应用中是<em class="mn">硬编码的</em>。比方说，如果我们想将应用程序更改为在另一个端口号上运行，我们需要更改 src/index.js 文件。在我们本地的计算机开发中，更改代码可能是小菜一碟。然而，当我们的应用程序部署到服务器上时，我们不能轻易更改代码。</p><p id="dcb4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么，我们如何解决这个问题呢？我们不需要在 src/index.js 中硬编码端口号 3000，而是需要将这个端口号放在一个配置文件中。这个配置文件也需要在我们的源代码(src 文件夹)之外。尤其是在 NodeJS 中，一种方法是使用名为<a class="ae kx" href="https://www.npmjs.com/package/config" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> config </strong> </a>的 npm 包。让我们用 npm 安装它。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="78fa" class="mb kz in mt b gy mx my l mz na">npm install --save config</span></pre><p id="e0b2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们在根文件夹上创建一个名为<strong class="kb io">配置</strong>的文件夹。然后，在其中创建一个<strong class="kb io"> development.json </strong>文件，并将我们的端口变量放入其中。</p><h2 id="fc0b" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">config/development.json</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3c23" class="mb kz in mt b gy mx my l mz na">{<br/>  "port": 3000<br/>}</span></pre><p id="2aa9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们回到 src/index.js 并导入配置库。然后，代替硬编码端口= 3000，我们可以使用 config.get(“端口”)来获得存储在 development.json 中的端口值</p><h2 id="16ba" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/index.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ae73" class="mb kz in mt b gy mx my l mz na">import config from 'config';</span><span id="26eb" class="mb kz in mt b gy nb my l mz na">...<br/>...</span><span id="1541" class="mb kz in mt b gy nb my l mz na">const port = config.get('port');</span><span id="9d40" class="mb kz in mt b gy nb my l mz na">...<br/>...</span></pre><p id="44ce" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">导入时，配置库将在我们的项目目录中寻找一个<strong class="kb io"> config </strong>文件夹。然后，它将寻找文件名与我们的<strong class="kb io"> NODE_ENV </strong>变量匹配的 JSON 或 js 文件。<strong class="kb io"> </strong>目前为止我们还没有遇到 NODE_ENV。NODE_ENV 是我们操作系统中的一个环境变量。通常这些值要么是<strong class="kb io">开发</strong>、<strong class="kb io">试运行</strong>、<strong class="kb io">生产</strong>，要么是<strong class="kb io">测试</strong>。到目前为止，我们只在开发环境中工作，因此我们创建了一个名为<strong class="kb io"> development </strong> .json 的配置文件。现在，我们需要将 NODE_ENV 值实际设置为<strong class="kb io"> development </strong>。</p><p id="3d35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们安装<a class="ae kx" href="https://www.npmjs.com/package/cross-env" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">跨环境</strong> </a>和<a class="ae kx" href="https://www.npmjs.com/package/copyfiles" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">拷贝文件</strong> </a> <strong class="kb io"> </strong>包来帮助我们实现这一点。由于它们不是我们的应用程序的依赖项(只需要运行或构建应用程序)，我们将其保存到 dev dependencies 中。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="acfa" class="mb kz in mt b gy mx my l mz na">npm install --save-dev cross-env copyfiles</span></pre><p id="2c98" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要更新 package.json 中的 npm 运行和构建脚本。</p><h2 id="65fb" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">package.json</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0937" class="mb kz in mt b gy mx my l mz na">{<br/>  ...</span><span id="8822" class="mb kz in mt b gy nb my l mz na">  ...</span><span id="8496" class="mb kz in mt b gy nb my l mz na">  "scripts": {<br/>    "build": "rimraf dist/ &amp;&amp; babel ./src --out-dir dist/ --ignore ./node_modules,./.babelrc,./nodemon.json,./package.json,./npm-debug.log --copy-files &amp;&amp; copyfiles -a config/* dist",<br/>    "start": "npm run build &amp;&amp; cross-env NODE_ENV=production node dist/index.js",<br/>    "start:dev": "cross-env NODE_ENV=development nodemon"<br/>  },</span><span id="eb27" class="mb kz in mt b gy nb my l mz na">  ...</span><span id="91b2" class="mb kz in mt b gy nb my l mz na">  ...<br/>}</span></pre><blockquote class="nc nd ne"><p id="3c7c" class="jz ka mn kb b kc kd ke kf kg kh ki kj nf kl km kn ng kp kq kr nh kt ku kv kw ig bi translated"><strong class="kb io"> cross-env </strong>允许我们设置环境变量，而<strong class="kb io"> copyfiles </strong>允许我们在任何终端上复制文件，而不考虑操作系统。</p></blockquote><p id="d893" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们运行 npm start:dev 脚本来确保 development.json 中的配置被读取，并且应用程序正在端口 3000 上运行。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/57ea5395d2c27dac4014f71fb08fa6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*7G-auRjrF53dOV8dUeOxqw.png"/></div></figure><p id="85e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">实际上，我刚想起来我们从来没有测试过我们的剧本。生产和开发脚本的区别在于，我们实际上是将源代码“编译”(或<strong class="kb io">构建</strong>)到<strong class="kb io"> dist </strong>文件夹中，然后在 dist 文件夹中运行应用程序。这正是在 package.json 中的 npm 运行启动脚本中发生的情况。在运行脚本之前，让我们创建 production.json 配置，这次让我们配置生产应用程序以在另一个端口上运行。</p><h2 id="fc95" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">配置/生产. json</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="37c4" class="mb kz in mt b gy mx my l mz na">{<br/>  "port": 4000<br/>}</span></pre><p id="68e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，运行生产脚本。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b784" class="mb kz in mt b gy mx my l mz na">npm run start</span></pre><p id="b823" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果一切顺利，您应该看到应用程序现在运行在端口 4000 而不是 3000。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/53eab7dd7147ebef5851ea3063a95982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*wo7tmwggavq3_52Unl3Qig.png"/></div></figure><p id="32e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好了，应用配置讨论到此结束。那么，为什么我们在连接到数据库之前需要它呢？正如我前面所说的，数据库是一个存储数据的服务器。这意味着它应该运行在与我们的应用程序分开的某个地方，并且有一个特定的<strong class="kb io">主机</strong> url、<strong class="kb io">端口</strong>，也许还有<strong class="kb io">授权</strong>信息。同样，在我们的本地计算机开发中，数据库可能运行在本地主机上，但是当我们将应用程序部署到服务器上时，我们可能需要一个运行在互联网上的数据库服务器。这就是为什么我们需要使数据库连接选项<strong class="kb io">可配置</strong>。</p><h1 id="187b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">正在连接到 MongoDB</h1><p id="1aed" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">为了将我们的 NodeJS 应用程序连接到 MongoDB，我们需要一些<strong class="kb io">驱动程序</strong>库来管理连接。它不仅适用于 MongoDB，我们还需要特定的驱动程序来连接到其他数据库。我们将使用<a class="ae kx" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">mongose</strong></a><strong class="kb io"/>来管理连接和<strong class="kb io">对象建模</strong>。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="903c" class="mb kz in mt b gy mx my l mz na">npm i --save mongoose</span></pre><p id="159c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<strong class="kb io"> src </strong>文件夹中创建一个名为<strong class="kb io"> db.js </strong>的文件。</p><h2 id="0fdc" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/db.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e006" class="mb kz in mt b gy mx my l mz na">import config from 'config';<br/>import mongoose from 'mongoose';<br/>import logger from './lib/logger';</span><span id="943a" class="mb kz in mt b gy nb my l mz na">const connectionString = config.get('mongodb');</span><span id="daef" class="mb kz in mt b gy nb my l mz na">export const initializeDB = () =&gt; {<br/>  mongoose.connect(connectionString, () =&gt; {<br/>    logger.info('Connected to MongoDB!!');<br/>  });<br/>};</span></pre><p id="8fa4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个文件包含一个简单的函数，它将应用程序连接到 MongoDB。为了连接，需要一根<strong class="kb io">连接管柱</strong> <strong class="kb io"> URI </strong>。一个简单的 MongoDB 连接字符串定义如下。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0b25" class="mb kz in mt b gy mx my l mz na">mongodb://&lt;username:password@&gt;&lt;host&gt;:&lt;port&gt;/&lt;databasename&gt;</span></pre><p id="aafa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您按照我的建议安装 MongoDB Compass，MongoDB 将在默认情况下运行 localhost:27017，无需任何授权。让我们将连接字符串添加到配置文件中。</p><blockquote class="nc nd ne"><p id="9685" class="jz ka mn kb b kc kd ke kf kg kh ki kj nf kl km kn ng kp kq kr nh kt ku kv kw ig bi translated"><strong class="kb io">快速提醒注意</strong> <br/>当我说“配置文件”的时候，通常指的是<strong class="kb io">config/development . JSON</strong>文件，除非我们在说部署的时候，大概指的是<strong class="kb io"> config/production.json </strong></p></blockquote><h2 id="5719" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">配置/开发. json</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3126" class="mb kz in mt b gy mx my l mz na">{<br/>  "port": 3000,<br/>  "mongodb": "mongodb://localhost:27017/icecreamstore"<br/>}</span></pre><p id="b5f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我将我的数据库命名为<strong class="kb io"> icecreamstore </strong>，但是你可以使用任何你想要的名字。由于默认情况下没有授权，我们可以跳过用户名:密码部分。下一步是在使用中间件之前调用 src/index.js 中的 initializeDb。</p><h2 id="7a8a" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/index.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1b55" class="mb kz in mt b gy mx my l mz na">import { initializeDB } from './db';</span><span id="8031" class="mb kz in mt b gy nb my l mz na">...</span><span id="8c69" class="mb kz in mt b gy nb my l mz na">initializeDB();</span><span id="4878" class="mb kz in mt b gy nb my l mz na">...</span></pre><p id="816b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">再次启动 app，如果连接成功，应该会得到<br/>“连接到 MongoDB”日志。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/52ba64c26322cd784d481e774e020102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4phHZp3a0DYEvAY9vJvbrA.png"/></div></div></figure><h1 id="dbc2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新菜单处理函数</h1><p id="f9e5" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们的下一个任务是实际利用 MongoDB 来读取和存储我们的菜单。首先，在<strong class="kb io"> src </strong>中创建一个文件夹，命名为<strong class="kb io"> models </strong>。在里面，创建一个名为<strong class="kb io"> menu.js </strong>的文件。</p><h2 id="5785" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/models/menu.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2f0f" class="mb kz in mt b gy mx my l mz na">import { Schema, model } from 'mongoose';</span><span id="99e7" class="mb kz in mt b gy nb my l mz na">const menuSchema = new Schema({<br/>  name: String,<br/>  description: String,<br/>});</span><span id="831d" class="mb kz in mt b gy nb my l mz na">export const Menu = model('menus', menuSchema);</span></pre><p id="0ae3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们定义了一个<strong class="kb io">菜单</strong>模型<strong class="kb io"> </strong>，它对应于 MongoDB 中的<strong class="kb io">菜单</strong>集合。模型基本上只是我们代码中的一个对象。MongoDB 集合是一组文档。同时，文档是类似 JSON 的(<strong class="kb io">BSON</strong>:JSON 的二进制表示)数据记录，存储在 MongoDB 中。注意，在<strong class="kb io">mongose</strong>中，集合的命名约定是复数形式的名词——因此是菜单。在这个菜单模型中，我们定义了两个字段，它们是名称和描述，都是字符串类型。</p><p id="0c1c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们更新我们的 POST 菜单 API 处理函数。要将文档插入 MongoDB，我们可以使用我们刚刚用<strong class="kb io"> Menu.create </strong>函数创建的菜单模型。注意<strong class="kb io">创建</strong>函数是一个异步函数。在使用 Menu.create 时，我们需要将<strong class="kb io"> async </strong>关键字添加到处理函数中，并将<strong class="kb io"> await </strong>关键字添加到处理函数中。让我们添加 try catch 包装器。</p><h2 id="16aa" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/routes/menu/index.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7c11" class="mb kz in mt b gy mx my l mz na">import { Menu } from '../../models/menu';</span><span id="bc79" class="mb kz in mt b gy nb my l mz na">...</span><span id="90dd" class="mb kz in mt b gy nb my l mz na">...</span><span id="da30" class="mb kz in mt b gy nb my l mz na">router.post('/', async (req, res, next) =&gt; {<br/>  try {<br/>    menus.push(req.body);<br/>    await Menu.create({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>    });<br/>    res.json({<br/>      message: 'Success!',<br/>    });<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><p id="c80c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们运行应用程序，并尝试通过 Postman 将我们的华尼拉·艾斯奶油菜单插入数据库。如果一切顺利，菜单将被创建。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/22cf3ac0c26d7e6e70e1caae5155b5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmANHC3GY229afWxbmS1hQ.png"/></div></div></figure><p id="2509" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">打开 MongoDB Compass 检查是否创建了菜单。您将被要求输入一个连接字符串。用我们在配置文件中使用的完全相同的字符串填充它，然后单击 Connect。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/94bcf344af1c6f0f351fc5390458cf23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6du0mTtMAqTMceAajy5Bg.png"/></div></div></figure><p id="a136" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在用户界面的左侧，查找您的数据库名称。点击它，你应该看到菜单集合。然后，单击菜单查看存储在里面的文档。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0733bae6d5517383cfb1175f9626f5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*c1av9QQCZz2-igJ8aVAeCg.png"/></div></figure><p id="fb3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在用户界面的右侧，您应该会看到我们刚刚作为文档插入的普通菜单。注意，MongoDB 会自动为我们生成<strong class="kb io"> _id </strong>和<strong class="kb io"> __v </strong>字段，分别是唯一标识符和版本号。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/197f90a795e51ee70ff06f20586f741d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ju8yVeKurV4x2WvnASUQyA.png"/></div></div></figure><p id="4eef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果一切顺利，那么我们将继续修改 GET 和 GET by id 处理函数以及 Menu.find 和 Menu.findOne 函数。findOne 函数将使用<strong class="kb io"> _id </strong>作为查询来获取一个具有特定 id 的文档。以下是全尺寸的更新菜单路线文件。</p><h2 id="78c8" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/routes/menu/index.js</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="efec" class="mb kz in mt b gy mx my l mz na">import { Router } from 'express';<br/>import { Menu } from '../../models/menu';</span><span id="955a" class="mb kz in mt b gy nb my l mz na">const router = Router();</span><span id="70f1" class="mb kz in mt b gy nb my l mz na">router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const menus = await Menu.find();<br/>    res.json({<br/>      data: menus,<br/>    });<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span><span id="573c" class="mb kz in mt b gy nb my l mz na">router.get('/:id', async (req, res, next) =&gt; {<br/>  try {<br/>    const id = req.params.id;<br/>    const menu = await Menu.findOne({ _id: id });<br/>    if (!menu) {<br/>      const err = new Error('Id Not Found');<br/>      err.status = 404;<br/>      throw err;<br/>    }<br/>    res.json({<br/>      data: menu,<br/>    });<br/>  } catch (err) {<br/>    next(err);<br/>  }<br/>});</span><span id="cda4" class="mb kz in mt b gy nb my l mz na">router.post('/', async (req, res, next) =&gt; {<br/>  try {<br/>    await Menu.create({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>    });<br/>    res.json({<br/>      message: 'Success!',<br/>    });<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span><span id="40a9" class="mb kz in mt b gy nb my l mz na">export default router;</span></pre><p id="5548" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，让我们试试通过 Postman 获取菜单 API。我们希望看到数据库中的香草冰淇淋作为响应数据。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/aacf2b31037a5a0273bbf5408cdcafff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdjuAKnyszUvpJ-QYpi7uw.png"/></div></div></figure><p id="407d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在数据响应中，我们应该看到带有字符串值的文档 id <strong class="kb io"> _id </strong>。要尝试通过 id API 获取菜单，请复制 _id 字符串值，然后将其用作 API URL 中的 id 参数，您应该会得到一个菜单文档作为响应。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/b5b7f809780985be3d4be9cee5426bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_jUtK5fls_2InIjY79fDQ.png"/></div></div></figure><p id="9ff0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">恭喜您，您的应用程序现在正在利用数据库！</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="5290" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第 4 部分写得很长。让我们在这一点上休息一下。在下一部分中，我们将再次重构代码，并向现有 API 添加更多选项。<a class="ae kx" href="https://bitsizelearning.medium.com/building-web-service-with-nodejs-part-5-pagination-data-transfer-object-c5fbf7bd21f1" rel="noopener"> <strong class="kb io">点击这里！</strong>T3】</a></p><p id="ddcf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以在我的公共 github 资源库中看到完整的第 4 部分代码。<br/> <a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part4" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">点击这里！</strong> </a></p><p id="383f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谢谢你，希望你喜欢阅读它。有没有什么错误或者是我没有解释清楚的地方？有什么我应该改进的吗？</p><p id="18ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你愿意的话，给作者留个便条和一些掌声来帮助频道发展。:)</p></div></div>    
</body>
</html>