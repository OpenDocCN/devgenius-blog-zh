<html>
<head>
<title>C# 9 Early Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 9 早期评审</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-9-early-review-5bcd88296c54?source=collection_archive---------2-----------------------#2020-06-17">https://blog.devgenius.io/c-9-early-review-5bcd88296c54?source=collection_archive---------2-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6de5f5e0575c907d739e64130e53dc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*W_s9ovknA123rfJb.jpeg"/></div></figure><h1 id="55f9" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">已经实施</h1><h2 id="707b" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">1.模式匹配改进</h2><p id="8413" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated"><strong class="lj ir"> 1.1 类型模式</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="706d" class="ks jv iq mh b gy ml mm l mn mo">void M(object o1, object o2)<br/>{<br/>    var t = (o1, o2);<br/>    if (t is (int, string)) {} // test if o1 is an int and o2 is a string<br/>    switch (o1) {<br/>        case int: break; // test if o1 is an int<br/>        case System.String: break; // test if o1 is a string<br/>    }<br/>}</span></pre><p id="4089" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated"><strong class="lj ir"> 1.2 圆括号图案</strong></p><p id="78d8" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">带括号的模式允许程序员在任何模式周围加上括号。这对于 C# 8.0 中的现有模式来说不是很有用，但是新的模式组合子引入了一个程序员可能想要覆盖的优先级。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1ad5" class="ks jv iq mh b gy ml mm l mn mo">primary_pattern<br/>    : parenthesized_pattern<br/>    ;<br/>parenthesized_pattern<br/>    : '(' pattern ')'<br/>    ;</span></pre><p id="ea50" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">1.3 关系模式</p><p id="0025" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">关系模式允许程序员表达输入值在与常数值比较时必须满足关系约束:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1422" class="ks jv iq mh b gy ml mm l mn mo">public static LifeStage LifeStageAtAge(int age) =&gt; age switch<br/>    {<br/>        &lt; 0 =&gt;  LiftStage.Prenatal,<br/>        &lt; 2 =&gt;  LifeStage.Infant,<br/>        &lt; 4 =&gt;  LifeStage.Toddler,<br/>        &lt; 6 =&gt;  LifeStage.EarlyChild,<br/>        &lt; 12 =&gt; LifeStage.MiddleChild,<br/>        &lt; 20 =&gt; LifeStage.Adolescent,<br/>        &lt; 40 =&gt; LifeStage.EarlyAdult,<br/>        &lt; 65 =&gt; LifeStage.MiddleAdult,<br/>        _ =&gt;    LifeStage.LateAdult,<br/>    };</span></pre><p id="eeff" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated"><strong class="lj ir"> 1.4 模式组合器</strong></p><p id="b598" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">三种新的模式形式</p><ol class=""><li id="5bbf" class="mu mv iq lj b lk mp lo mq kx mw la mx ld my mb mz na nb nc bi translated"><em class="nd">图案</em> <code class="fe ne nf ng mh b">and</code> <em class="nd">图案</em></li><li id="d3fc" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb mz na nb nc bi translated"><em class="nd">图案</em>图案<code class="fe ne nf ng mh b">or</code>图案<em class="nd">图案</em></li><li id="273a" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb mz na nb nc bi translated"><code class="fe ne nf ng mh b">not</code>图案<em class="nd">图案</em></li></ol><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b393" class="ks jv iq mh b gy ml mm l mn mo">//example 1<br/>bool IsLetter(char c) =&gt; c is (&gt;= 'a' and &lt;= 'z') or (&gt;= 'A' and &lt;= 'Z');</span><span id="3ee3" class="ks jv iq mh b gy nm mm l mn mo">//example 2<br/>switch (o)<br/>{<br/>    case 1 or 2:<br/>    case Point(0, 0) or null:<br/>    case Point(var x, var y) and var p:<br/>}</span></pre><h2 id="b1e6" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">2.目标类型的新</h2><p id="1c96" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">当类型已知时，不需要为构造函数指定类型。允许字段初始化而不复制类型。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5dfa" class="ks jv iq mh b gy ml mm l mn mo">Dictionary&lt;string, List&lt;int&gt;&gt; field = new() {<br/>    { "item1", new() { 1, 2, 3 } }<br/>};</span></pre><p id="99b9" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">当可以从用法中推断出类型时，允许省略该类型。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="95ca" class="ks jv iq mh b gy ml mm l mn mo">XmlReader.Create(reader, new() { IgnoreWhitespace = true });</span></pre><p id="483c" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">实例化一个对象，但不拼写其类型。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ff00" class="ks jv iq mh b gy ml mm l mn mo">private readonly static object s_syncObj = new();</span></pre><h2 id="6907" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">3.λ丢弃参数</h2><p id="5d6c" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">未使用的参数不需要命名。丢弃的目的很明确，即它们是未使用的/丢弃的。</p><p id="d56a" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">允许丢弃(<code class="fe ne nf ng mh b">_</code>)作为 lambdas 和匿名方法的参数。例如:</p><ul class=""><li id="7671" class="mu mv iq lj b lk mp lo mq kx mw la mx ld my mb nn na nb nc bi translated">兰达斯:<code class="fe ne nf ng mh b">(_, _) =&gt; 0</code>，<code class="fe ne nf ng mh b">(int _, int _) =&gt; 0</code></li><li id="df2d" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb nn na nb nc bi translated">匿名方法:<code class="fe ne nf ng mh b">delegate(int _, int _) { return 0; }</code></li></ul><h2 id="24ea" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">4.局部函数的属性</h2><p id="b7ea" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">现在属性可以成为局部函数声明的一部分。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0846" class="ks jv iq mh b gy ml mm l mn mo">class C<br/>{<br/>    void M()<br/>    {<br/>        int x;<br/>        local1();<br/>        Console.WriteLine(x);<br/> <br/>        [Conditional("DEBUG")]       <br/>        void local1()<br/>        {<br/>            x = 42;<br/>        }<br/>    }<br/>}</span></pre><h2 id="40f0" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">5.本地 int</h2><p id="7f45" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">标识符<code class="fe ne nf ng mh b">nint</code>和<code class="fe ne nf ng mh b">nuint</code>是新的上下文关键字，表示本地有符号和无符号整数类型。当名称查找在该程序位置没有找到可行的结果时，标识符仅被视为关键字。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1970" class="ks jv iq mh b gy ml mm l mn mo">nint x = 3;<br/>string y = nameof(nuint);<br/>_ = nint.Equals(x, 3);</span></pre><p id="7c6f" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">类型<code class="fe ne nf ng mh b">nint</code>和<code class="fe ne nf ng mh b">nuint</code>由底层类型<code class="fe ne nf ng mh b">System.IntPtr</code>和<code class="fe ne nf ng mh b">System.UIntPtr</code>表示，编译器将这些类型的额外转换和操作表现为本机 int。</p><h2 id="f91b" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">6.扩展部分</h2><p id="5307" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">语言将会改变，允许用一个显式的可访问性修饰符来注释<code class="fe ne nf ng mh b">partial</code>方法。这意味着它们可以被标记为<code class="fe ne nf ng mh b">private</code>、<code class="fe ne nf ng mh b">public</code>等...</p><p id="4be1" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">当一个<code class="fe ne nf ng mh b">partial</code>方法有一个显式的可访问性修饰符时，尽管语言会要求声明有一个匹配的定义，即使可访问性是<code class="fe ne nf ng mh b">private</code>:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6250" class="ks jv iq mh b gy ml mm l mn mo">partial class C<br/>{<br/>    // Okay because no definition is required here<br/>    partial void M1();</span><span id="678b" class="ks jv iq mh b gy nm mm l mn mo">// Okay because M2 has a definition<br/>    private partial void M2();</span><span id="3c54" class="ks jv iq mh b gy nm mm l mn mo">// Error: partial method M3 must have a definition<br/>    private partial void M3();<br/>}</span><span id="a25d" class="ks jv iq mh b gy nm mm l mn mo">partial class C<br/>{<br/>    private partial void M2() { }<br/>}</span></pre><p id="b8a4" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">此外，这种语言将取消对出现在具有显式可访问性的<code class="fe ne nf ng mh b">partial</code>方法上的内容的所有限制。这样的声明可以包含非 void 返回类型、<code class="fe ne nf ng mh b">ref</code>或<code class="fe ne nf ng mh b">out</code>参数、<code class="fe ne nf ng mh b">extern</code>修饰符等...这些签名将具有 C#语言的全部表达能力。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f6cd" class="ks jv iq mh b gy ml mm l mn mo">partial class D<br/>{<br/>    // Okay<br/>    internal partial bool TryParse(string s, out int i); <br/>}</span><span id="00f1" class="ks jv iq mh b gy nm mm l mn mo">partial class D<br/>{<br/>    internal partial bool TryParse(string s, out int i) { }<br/>}</span></pre><p id="deff" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">这明确地允许<code class="fe ne nf ng mh b">partial</code>方法参与<code class="fe ne nf ng mh b">overrides</code>和<code class="fe ne nf ng mh b">interface</code>实现:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fb97" class="ks jv iq mh b gy ml mm l mn mo">interface IStudent<br/>{<br/>    string GetName();<br/>}</span><span id="d8fb" class="ks jv iq mh b gy nm mm l mn mo">partial class C : IStudent<br/>{<br/>    public virtual partial string GetName(); <br/>}</span><span id="fb60" class="ks jv iq mh b gy nm mm l mn mo">partial class C<br/>{<br/>    public virtual partial string GetName() =&gt; "Jarde";<br/>}</span></pre><h2 id="d36a" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">7.函数指针</h2><p id="b3ce" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">这个特性提供了一些语言结构，这些结构暴露了当前不能被有效访问或者根本不能被访问的低级 IL 操作码:<code class="fe ne nf ng mh b">ldftn</code>、<code class="fe ne nf ng mh b">ldvirtftn</code>、<code class="fe ne nf ng mh b">ldtoken</code>和<code class="fe ne nf ng mh b">calli</code>。这些低级操作码在高性能代码中非常重要，开发人员需要一种有效的方法来访问它们。</p><h2 id="bbde" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">8.跳过本地初始化</h2><p id="0693" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">允许通过<code class="fe ne nf ng mh b">SkipLocalsInitAttribute</code>属性抑制<code class="fe ne nf ng mh b">localsinit</code>标志的发出。</p><h1 id="9d24" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在发展中</h1><h2 id="48de" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">1.记录</h2><p id="d1c0" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">如果您想使单个属性不可变，那么只有 Init 属性是很好的选择。如果您希望整个对象是不可变的，并且表现得像一个值，那么您应该考虑将它声明为一个<em class="nd">记录</em>:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="06db" class="ks jv iq mh b gy ml mm l mn mo">public data class Person<br/>{<br/>    public string FirstName { get; init; }<br/>    public string LastName { get; init; }<br/>}</span></pre><p id="001d" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">类声明上的<code class="fe ne nf ng mh b">data</code>关键字将其标记为记录。这给它注入了几个额外的类似价值的行为，我们将在下面深入探讨。一般来说，记录更应该被视为“价值”——数据！–而不是作为物品。它们不应该有可变的封装状态。相反，您通过创建表示新状态的新记录来表示随时间的变化。它们不是由它们的身份定义的，而是由它们的内容定义的。</p><p id="b2ba" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">为了帮助这种风格的编程，记录允许一种新的表达方式；<code class="fe ne nf ng mh b">with</code>-表情:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="245e" class="ks jv iq mh b gy ml mm l mn mo">var otherPerson = person with { LastName = "Hanselman" };</span></pre><p id="d979" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">简短声明:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d7bb" class="ks jv iq mh b gy ml mm l mn mo">public data class Person { string FirstName; string LastName; }</span><span id="abb3" class="ks jv iq mh b gy nm mm l mn mo">//<!-- -->Means exactly the same as the one we had before:</span><span id="32a1" class="ks jv iq mh b gy nm mm l mn mo">public data class Person<br/>{<br/>    public string FirstName { get; init; }<br/>    public string LastName { get; init; }<br/>}</span></pre><p id="0a8e" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">继承:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d0af" class="ks jv iq mh b gy ml mm l mn mo">public data class Person { string FirstName; string LastName; }<br/>public data class Student : Person { int ID; }</span></pre><h2 id="dc9a" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">2.参数零检查</h2><p id="91d7" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">这允许使用参数上的小注释来简化参数的标准<code class="fe ne nf ng mh b">null</code>验证:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a4d4" class="ks jv iq mh b gy ml mm l mn mo">// Before<br/>void Insert(string s) {<br/>  if (s is null)<br/>    throw new ArgumentNullException(nameof(s));</span><span id="2ab7" class="ks jv iq mh b gy nm mm l mn mo">  ...<br/>}</span><span id="662e" class="ks jv iq mh b gy nm mm l mn mo">// After<br/>void Insert(string s!) {<br/>  ...<br/>}</span></pre><h2 id="c916" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">3.协变收益</h2><p id="26f4" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">支持<em class="nd">协变返回类型</em>。具体来说，允许方法的重写返回比它重写的方法更派生的返回类型，同样，允许只读属性的重写返回更派生的返回类型。方法或属性的调用方将从调用中静态接收更精确的返回类型，并且出现在更多派生类型中的重写将被要求提供至少与其基类型中的重写一样具体的返回类型。<br/>举例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0c0e" class="ks jv iq mh b gy ml mm l mn mo">class Compilation ...<br/>{<br/>    virtual Compilation WithOptions(Options options)...<br/>}</span><span id="9eb2" class="ks jv iq mh b gy nm mm l mn mo">class CSharpCompilation : Compilation<br/>{<br/>    override CSharpCompilation WithOptions(Options options)...<br/>}</span></pre><h2 id="29cb" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">4.静态 lambdas</h2><p id="3adf" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">为了避免在为方法参数提供 lambda 函数时意外捕获任何局部状态，请在 lambda 声明前面加上 static 关键字。这使得 lambda 函数就像一个静态方法，没有捕获局部变量，也没有对这个或 base 的访问。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="81b3" class="ks jv iq mh b gy ml mm l mn mo">int y = 10;<br/>someMethod(x =&gt; x + y); // captures 'y', causing unintended allocation.</span></pre><p id="03c9" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">有了这个建议，你可以使用 static 关键字来避免这个错误。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5cf2" class="ks jv iq mh b gy ml mm l mn mo">int y = 10;<br/>someMethod(static x =&gt; x + y); // error!</span><span id="404e" class="ks jv iq mh b gy nm mm l mn mo">const int y = 10;<br/>someMethod(static x =&gt; x + y); // okay :-)</span></pre><h2 id="92cb" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">5.顶级语句</h2><p id="8a5c" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">允许一系列的<em class="nd">语句</em>出现在<em class="nd">编译单元</em>(即源文件)的<em class="nd">名称空间 _ 成员 _ 声明</em>之前。</p><p id="c9e1" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">示例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ae0e" class="ks jv iq mh b gy ml mm l mn mo">// Example #1<br/>await System.Threading.Tasks.Task.Delay(1000);<br/>System.Console.WriteLine("Hi!");</span><span id="f18a" class="ks jv iq mh b gy nm mm l mn mo">// would be converted to</span><span id="f912" class="ks jv iq mh b gy nm mm l mn mo">static class $Program<br/>{<br/>    static async Task $Main(string[] args)<br/>    {<br/>        await System.Threading.Tasks.Task.Delay(1000);<br/>        System.Console.WriteLine("Hi!");<br/>    }<br/>}</span><span id="ac16" class="ks jv iq mh b gy nm mm l mn mo">--------------------------------------------------------------------</span><span id="d3d9" class="ks jv iq mh b gy nm mm l mn mo">// Example #2<br/>await System.Threading.Tasks.Task.Delay(1000);<br/>System.Console.WriteLine("Hi!");<br/>return 0;</span><span id="dc59" class="ks jv iq mh b gy nm mm l mn mo">// would be converted to</span><span id="b40c" class="ks jv iq mh b gy nm mm l mn mo">static class $Program<br/>{<br/>    static async Task&lt;int&gt; $Main(string[] args)<br/>    {<br/>        await System.Threading.Tasks.Task.Delay(1000);<br/>        System.Console.WriteLine("Hi!");<br/>        return 0;<br/>    }<br/>}</span><span id="f23a" class="ks jv iq mh b gy nm mm l mn mo">--------------------------------------------------------------------</span><span id="02cd" class="ks jv iq mh b gy nm mm l mn mo">// Example #3<br/>System.Console.WriteLine("Hi!");<br/>return 2;</span><span id="ac1f" class="ks jv iq mh b gy nm mm l mn mo">// would be converted to</span><span id="c75f" class="ks jv iq mh b gy nm mm l mn mo">static class $Program<br/>{<br/>    static int $Main(string[] args)<br/>    {<br/>        System.Console.WriteLine("Hi!");<br/>        return 2;<br/>    }<br/>}</span></pre><h2 id="f0c3" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">6.目标类型条件</h2><p id="4fe9" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">对于条件表达式<code class="fe ne nf ng mh b">c ? e1 : e2</code>，当</p><ol class=""><li id="133b" class="mu mv iq lj b lk mp lo mq kx mw la mx ld my mb mz na nb nc bi translated"><code class="fe ne nf ng mh b">e1</code>和<code class="fe ne nf ng mh b">e2</code>没有通用类型，或者</li><li id="26e7" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb mz na nb nc bi translated">存在一个通用类型，但表达式<code class="fe ne nf ng mh b">e1</code>或<code class="fe ne nf ng mh b">e2</code>中的一个没有隐式转换为该类型</li></ol><p id="45b3" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">定义了一个新的隐式<em class="nd">条件表达式转换</em><em class="nd"/>，其允许从条件表达式到任何类型<code class="fe ne nf ng mh b">T</code>的隐式转换，其中存在从<code class="fe ne nf ng mh b">e1</code>到<code class="fe ne nf ng mh b">T</code>以及从<code class="fe ne nf ng mh b">e2</code>到<code class="fe ne nf ng mh b">T</code>的转换。如果条件表达式既没有<code class="fe ne nf ng mh b">e1</code>和<code class="fe ne nf ng mh b">e2</code>之间的通用类型，也不受<em class="nd">条件表达式转换</em>的约束，则为错误。</p><h2 id="3821" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">7.扩展 GetEnumerator</h2><p id="ce75" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">允许<code class="fe ne nf ng mh b">foreach</code>循环识别满足<code class="fe ne nf ng mh b">foreach</code>模式的扩展方法<code class="fe ne nf ng mh b">GetEnumerator</code>方法，并在表达式出错时循环该表达式。</p><h2 id="5fda" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">8.放松<code class="fe ne nf ng mh b">ref</code>和<code class="fe ne nf ng mh b">partial</code>修改器的顺序</h2><p id="80e2" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr kx ls lt lu la lv lw lx ld ly lz ma mb ij bi translated">目前，<code class="fe ne nf ng mh b">partial</code>必须直接出现在<code class="fe ne nf ng mh b">struct</code>、<code class="fe ne nf ng mh b">class</code>或其他类型声明关键字之前。如果类型是一个<code class="fe ne nf ng mh b">ref</code>结构，<code class="fe ne nf ng mh b">ref</code>必须紧接在<code class="fe ne nf ng mh b">partial</code>或<code class="fe ne nf ng mh b">struct</code>之前出现。似乎可以使用各种其他关键字来消除这些上下文修饰符的歧义，并允许我们放松对<code class="fe ne nf ng mh b">partial</code>和<code class="fe ne nf ng mh b">ref</code>在修饰符列表中出现位置的限制。</p><h2 id="a474" class="ks jv iq bd jw kt ku dn ka kv kw dp ke kx ky kz ki la lb lc km ld le lf kq lg bi translated">9.模块初始化器</h2><ul class=""><li id="cdbd" class="mu mv iq lj b lk ll lo lp kx no la np ld nq mb nn na nb nc bi translated">使库能够在加载时立即进行一次性初始化，开销最小，用户无需显式调用任何东西</li><li id="481d" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb nn na nb nc bi translated">当前<code class="fe ne nf ng mh b">static</code>构造函数方法的一个特别的痛点是，运行时必须对使用静态构造函数的类型进行额外的检查，以决定是否需要运行静态构造函数。这增加了可观的开销。</li><li id="ecf3" class="mu mv iq lj b lk nh lo ni kx nj la nk ld nl mb nn na nb nc bi translated">使源代码生成器能够运行一些全局初始化逻辑，而无需用户显式调用任何东西</li></ul><p id="c0ec" class="pw-post-body-paragraph lh li iq lj b lk mp lm ln lo mq lq lr kx mr lt lu la ms lw lx ld mt lz ma mb ij bi translated">附:在这里你可以阅读更多关于所有新功能的信息<a class="ae nr" href="https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md" rel="noopener ugc nofollow" target="_blank">https://github . com/dot net/roslyn/blob/master/docs/Language % 20 feature % 20 status . MD</a></p></div></div>    
</body>
</html>