<html>
<head>
<title>How Valhalla Rewrites Optional</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">瓦尔哈拉如何重写可选</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-valhalla-rewrites-optional-a8b4008c81af?source=collection_archive---------5-----------------------#2022-10-03">https://blog.devgenius.io/how-valhalla-rewrites-optional-a8b4008c81af?source=collection_archive---------5-----------------------#2022-10-03</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="4281" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Valhalla 进入 Java 后，Optional 会发生什么变化</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/f71aac8444bca88262bebde5bc3f03b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bTnV1sdILBPtjhQZ.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@niklas_hamann?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克拉斯·哈曼</a>在<a class="ae ks" href="https://unsplash.com/s/photos/lack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a34f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">“瓦尔哈拉将变可选。”</em></p><p id="768b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">确定，但有什么变化？</em> </strong></p><p id="efc2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你会在社区里发现这些，但是没有具体的证据表明发生了什么变化。</p><p id="15ca" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">我们需要抛弃可选吗？在当前代码使用可选的情况下，这怎么可能呢？Optional 仍然可以为空吗？</em></p><p id="8a33" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们深入研究并回答这些问题。</p><h1 id="5bef" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">手工特殊化的可选将毫无意义</h1><p id="e1a2" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">Valhalla 的目标之一是改进泛型。</p><p id="5f15" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以使用基本类型来代替装箱类型。这将比目前的方法带来更多的好处。对泛型使用装箱类型会影响性能。其中包括装箱转换、堆分配和内存间接寻址。</p><p id="3a80" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">即使在今天，你也可以看到泛型对原语的需求。Eclipse 集合在它们的地图中使用原语。并且从它们的类型到原生 Java 的转换不是现成的。</p><p id="c2b5" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以在<a class="ae ks" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/map/mutable/primitive/ByteIntHashMap.html" rel="noopener ugc nofollow" target="_blank">中查看他们对映射类型</a>的实现。还有转换到原生的问题<code class="fe mn mo mp mq b">Map&lt;byte, String&gt;</code>。更多关于这个问题的以下 SO 问题。</p><div class="mr ms gq gs mt mu"><a href="https://stackoverflow.com/questions/71349112/how-convert-adapt-byteobjecthashmap-to-a-jdk-map" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fp"><div class="mw ab mx cl cj my"><h2 class="bd is gz z fq mz fs ft na fv fx iq bi translated">如何将 ByteObjectHashMap 转换/调整为 JDK 地图？</h2><div class="nb l"><h3 class="bd b gz z fq mz fs ft na fv fx dk translated">目前，实现这一点最简单的方法是使用 forEachKeyValue 将 ByteObjectMap 的内容复制到一个映射中…</h3></div><div class="nc l"><p class="bd b dl z fq mz fs ft na fv fx dk translated">stackoverflow.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni km mu"/></div></div></a></div></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="34c5" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">改进的仿制药如何影响 Optional？</em></p><p id="7717" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们可以毫无问题地完成下面的转换。</p><ul class=""><li id="ce3f" class="nq nr ir kv b kw kx kz la lc ns lg nt lk nu lo nv nw nx ny bi translated"><code class="fe mn mo mp mq b">OptionalDouble</code>-&gt;-<code class="fe mn mo mp mq b">Optional&lt;double&gt;</code></li><li id="3d13" class="nq nr ir kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><code class="fe mn mo mp mq b">OptionalInt -&gt; Optional&lt;int&gt;</code></li></ul><p id="1c96" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所有的手工特殊化选项将变得毫无意义。您可以使用它们的专用泛型来代替 primitive。</p><p id="dab3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这将意味着手工专业课可能会被完全取消。<code class="fe mn mo mp mq b">OptionalInt</code>、<code class="fe mn mo mp mq b">OptionalDouble</code>等等。即便如此，为了保持向后兼容性，我会说它们会继续存在。</p><p id="e80d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所有这些变化都考虑到了扁平化。</p><p id="8115" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">参考类型和<code class="fe mn mo mp mq b">Optional</code>将启用扁平化。使用基元类型也将实现这一点，并增加空安全性。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="be3a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><a class="ae ks" href="https://openjdk.org/jeps/390#:~:text=The%20%22optional%22%20classes%20in%20java.util%3A%20Optional%2C%20OptionalInt%2C%20OptionalLong%2C%20and%20OptionalDouble%3B" rel="noopener ugc nofollow" target="_blank">手工专用选项都是基于价值的类别。</a></p><p id="0e0b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因此，这带来的变化是，你将被剥夺身份操作。参照性仍然存在。所以这使得实例仍然可以为空。</p><p id="cb58" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">此外，使用原语可以消除对盒子的需求。意思是<code class="fe mn mo mp mq b">OptionalInt</code>从<code class="fe mn mo mp mq b">int -&gt; Integer</code>增加了无用的转换。有了瓦尔哈拉，这将被移除。</p><p id="2171" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">为什么可选实例仍然可以为空？</em> </strong></p><p id="1ac2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">主要是为了不破坏现有的代码。即使如此，对于将来的代码，仍然可以选择将 Optional 声明为不可为 will。</p><h1 id="fda1" class="lq lr ir bd ls lt lu lv lw lx ly lz ma jx mb jy mc ka md kb me kd mf ke mg mh bi translated">旧的可选保持可空，Valhalla 可选可能不可空</h1><p id="1a53" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">让我们先来看看值类和原始类。</p><p id="0d90" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">有些值类可能是原始的。基本实例必须有默认值，并且不能为空。</em> </strong></p><p id="4e39" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以即使<code class="fe mn mo mp mq b">LocalDate</code>可能是原始的，也没有好的默认值候选。您可以设置一些值，但是这仍然会增加不确定性。</p><p id="56ad" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这让我想起了 proto 消息的默认值。例如，proto 消息中的 int 字段用默认值 0 填充。和今天的 Java 一样。但是对于其他复合值，默认值为 null。</p><p id="132e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我们知道<code class="fe mn mo mp mq b">Optional</code>是一个基于价值的类。尽管如此，原始类型的<code class="fe mn mo mp mq b">Optional</code>也是有可能的。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="f5e6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">那么如果</em> <code class="fe mn mo mp mq b"><em class="lp">Optional</em></code> <em class="lp">变成数值类会有什么变化呢？</em></p><p id="4fa2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有一点可以肯定<code class="fe mn mo mp mq b">Optional</code>不可能是原语类。作为引用类型有很多用法，客户希望这种用法永远存在。</p><p id="74e2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以我们需要参考投影。<strong class="kv is"> <em class="lp">这到底是什么意思？</em> </strong>一个<code class="fe mn mo mp mq b">Optional</code>实例将是原始的，但作为引用传递。</p><p id="e9c3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这个实现可以使这成为可能。</p><pre class="kh ki kj kk gu oe mq of og aw oh bi"><span id="1b7e" class="oi lr ir mq b gz oj ok l ol om">sealed interface Optional permits Optional.val {}</span><span id="6759" class="oi lr ir mq b gz on ok l ol om">primitive class Optional.val implements Optional {...}</span></pre><p id="ac22" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这意味着我们将不能拥有<code class="fe mn mo mp mq b">Optional.val</code>的可空实例。但是执行的结果可能是一个空值，因为这将退回到<code class="fe mn mo mp mq b">Optional</code>。</p><pre class="kh ki kj kk gu oe mq of og aw oh bi"><span id="828f" class="oi lr ir mq b gz oj ok l ol om">Optional v = findCustomer(); // could be nullable, in existing API even after Valhalla<br/>Optional.val v1 = Optional.of(customer); // not-nullable</span></pre><p id="b5b7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">在瓦尔哈拉登陆后，<code class="fe mn mo mp mq b">Optional</code>的未来实例可能是<code class="fe mn mo mp mq b">Optional.val</code>。这与 Valhalla 的口号非常吻合:<strong class="kv is"> <em class="lp">“代码像类一样工作就像 int。”</em> </strong>。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="b35b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">Optional</code>将成为引用类型。对于原始类型的<code class="fe mn mo mp mq b">Optional</code>，你可以使用<code class="fe mn mo mp mq b">Optional.val</code>。</p><p id="c664" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">有些人会认为<a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-dev/2021-April/008876.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe mn mo mp mq b"><a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-dev/2021-April/008876.html" rel="noopener ugc nofollow" target="_blank">Optional.val</a></code><a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-dev/2021-April/008876.html" rel="noopener ugc nofollow" target="_blank">是一个怪异的符号</a>。毕竟，我们可以将<code class="fe mn mo mp mq b">Optional</code>用于引用类型，将<code class="fe mn mo mp mq b">optional</code>用于原始类型的类。即便如此，这也会引起连锁反应，而且不会带来任何额外的好处。</p><p id="4ee3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">这种设计有什么好？</em> </strong></p><ul class=""><li id="fee5" class="nq nr ir kv b kw kx kz la lc ns lg nt lk nu lo nv nw nx ny bi translated"><em class="lp">不破坏现有代码</em></li><li id="135e" class="nq nr ir kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><em class="lp">所有可选实例都变成 ref-default，但也可以接受 val-default</em></li><li id="d6da" class="nq nr ir kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><em class="lp">此更改不会破坏现有代码，因为所有 ref-default 字段</em></li><li id="0412" class="nq nr ir kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><em class="lp">在堆上可展平，因为值类被剥离了身份</em></li><li id="0f77" class="nq nr ir kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><em class="lp">新的可选实例将</em> <code class="fe mn mo mp mq b"><em class="lp">Optional.val</em></code> <em class="lp">默认为</em></li></ul></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><h1 id="42fa" class="lq lr ir bd ls lt oo lv lw lx op lz ma jx oq jy mc ka or kb me kd os ke mg mh bi translated"><code class="fe mn mo mp mq b">ofNullable</code>会怎么样？</h1><p id="6b31" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">将<code class="fe mn mo mp mq b">null</code>传递给<code class="fe mn mo mp mq b">Optional#of</code>会抛出<code class="fe mn mo mp mq b">NullPointerException</code>。这就是为什么我们有<code class="fe mn mo mp mq b">Optional#ofNullable</code>。</p><p id="24b9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">当瓦尔哈拉登陆时，大多数人会求助于使用<code class="fe mn mo mp mq b">Optional</code>来包装原语。至少这将比包装盒装实例带来更多的好处。</p><p id="c691" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你宁愿用<code class="fe mn mo mp mq b">Optional&lt;int&gt;</code>而不是<code class="fe mn mo mp mq b">OptionalInt</code>或<code class="fe mn mo mp mq b">Optional&lt;Integer&gt;</code>。</p><p id="016f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以有了原语，<code class="fe mn mo mp mq b">ofNullable</code>就没有意义了。本质上，<code class="fe mn mo mp mq b">Optional#of</code>和<code class="fe mn mo mp mq b">Optional#ofNullable</code>都会抛出<code class="fe mn mo mp mq b">NullPointerException</code>。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="4ac8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">对于基本类型的选项，使用<code class="fe mn mo mp mq b">ofNullable</code>应该有一些区别。</p><p id="7b04" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">即使这将导致编译时问题，它也会令人困惑。<code class="fe mn mo mp mq b">Optional#ofNullable</code>不会接受<code class="fe mn mo mp mq b">null</code>的价值观。</p><p id="2c5b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">当我们得到新的泛型时，可能有一种方法来推断原语<code class="fe mn mo mp mq b">Optional</code>不可空。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><p id="4385" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所有这些改进应该会使<code class="fe mn mo mp mq b">Optional</code>更快，更容易使用。如果我们去掉身份运算，我们会得到平坦。如果我们移除引用，我们将移除堆分配，并移除可空性。</p></div><div class="ab cl nj nk hv nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ik il im in io"><h1 id="066a" class="lq lr ir bd ls lt oo lv lw lx op lz ma jx oq jy mc ka or kb me kd os ke mg mh bi translated">参考</h1><p id="ea91" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated"><a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-spec-experts/2021-December/001747.html" rel="noopener ugc nofollow" target="_blank">更新瓦尔哈拉状态文档</a> <br/> <a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-dev/2021-April/008872.html" rel="noopener ugc nofollow" target="_blank">新候选 JEP: 401:原始对象(预览)</a> <br/> <a class="ae ks" href="https://mail.openjdk.org/pipermail/valhalla-dev/2021-September/009536.html" rel="noopener ugc nofollow" target="_blank">引用偏向原始类堆分配</a></p></div></div>    
</body>
</html>