<html>
<head>
<title>OpenCV on Android — Tiny with Optimization Enabled</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的OpenCV小巧且支持优化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/opencv-on-android-tiny-with-optimization-enabled-932460acfe38?source=collection_archive---------0-----------------------#2018-12-20">https://blog.devgenius.io/opencv-on-android-tiny-with-optimization-enabled-932460acfe38?source=collection_archive---------0-----------------------#2018-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4d2b06fed8fb0efd8fa44ee1825271e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be9ivQ3MAvdrouZwfiHapA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Android上OpenCV的子集</figcaption></figure><blockquote class="jz ka kb"><p id="af78" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这篇文章也发表在<a class="ae lb" href="https://www.learnopencv.com/install-opencv-on-android-tiny-and-optimized/" rel="noopener ugc nofollow" target="_blank"> LearnOpenCV </a>上</p></blockquote><p id="2e19" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><em class="ke">我的OpenCV Android SDK = </em> <strong class="kf io"> <em class="ke">小尺寸</em> </strong> <em class="ke">库</em></p><p id="4d83" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">如果您选择OpenCV用于生产，您的主要目标是减小库的大小，并使其具有更好的性能。OpenCV是一个拥有大量算法的令人敬畏的库，但是你必须在你的应用程序中使用这些算法的一个非常小的子集，因此包含需要的而省略其余的是非常有意义的。</p><p id="2f9d" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><a class="ae lb" href="http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html" rel="noopener ugc nofollow" target="_blank">库</a>可以和你的应用代码一起静态编译，也可以在运行时动态链接，这完全是应用开发的决定。这里我们将创建共享对象(。所以)对于这个演示。</p><p id="cdc3" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">Android是一个多功能的操作系统，可以在多种硬件上运行，从手机到IOT设备，Raspberry Pi，再到各种单板计算机，因此对称为is a的特定计算机架构的代码进行交叉编译变得非常重要。因为我们正在为Android构建它，所以我们需要它的内置工具。Android的构建工具有一个好听的名字，叫做NDK(原生开发工具包)，但这正是我们所需要的。</p><p id="48bd" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">以下是我们将要使用的软件及其各自版本的列表:</p><ol class=""><li id="9a5c" class="lf lg in kf b kg kh kk kl lc lh ld li le lj la lk ll lm ln bi translated"><em class="ke"> cmake — 3.7.2 </em></li><li id="2281" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><em class="ke"> NDK — r14b </em></li><li id="4af2" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><em class="ke"> OpenCV — 3.4.1 </em></li><li id="ca88" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><em class="ke">主机— Ubuntu — 16.4 </em></li><li id="ae82" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><em class="ke">目标——ARM eabi-v7a(基于ARM)</em></li><li id="492c" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><em class="ke">Android SDK</em><a class="ae lb" href="https://dl.google.com/android/repository/tools_r25.2.5-linux.zip" rel="noopener ugc nofollow" target="_blank"><em class="ke">25 . 2 . 5工具</em> </a> <em class="ke">。</em></li></ol><h2 id="f5cb" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第一步:</h2><p id="6b15" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">下载NDK并解压到你的工作区。NDK有不同的版本，因此阅读发行说明并选择你的项目需要的版本是很重要的。但是在这个练习中，它的<a class="ae lb" href="https://dl.google.com/android/repository/android-ndk-r14b-linux-x86_64.zip" rel="noopener ugc nofollow" target="_blank"> Android NDK版本14b </a>在Docker容器中的Ubuntu上。但是这可以在任何Linux机器上。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f176" class="lt lu in mw b gy na nb l nc nd">root@dc:/opt/android-ndk-r14b# <strong class="mw io">ls</strong><br/>CHANGELOG.md ndk-build ndk-gdb ndk-which prebuilt shader-tools source.properties sysroot<br/>build ndk-depends ndk-stack platforms python-packages simpleperf sources toolchains</span></pre><p id="7bb6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我们将为OpenCV编译构建独立的工具链，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6c11" class="lt lu in mw b gy na nb l nc nd">root@dc:/opt/android-ndk-r14b# <strong class="mw io">./build/tools/make_standalone_toolchain.py \<br/>--arch arm \<br/>--api 23 \<br/>--install-dir /tmp/my-android-toolchain</strong></span></pre><p id="fae1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">该命令将基于我的项目所需的<code class="fe ne nf ng mw b">--arch</code>和<code class="fe ne nf ng mw b">--api</code>创建工具链，并将它们安装在<code class="fe ne nf ng mw b">/tmp/my-android-toolchain</code>目录中。</p><h2 id="c945" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第二步:</h2><p id="c951" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">通常，ANDROID_NDK路径被设置为预构建的工具链，它与NDK一起提供。但是我们将使用我们在上一步中构建的环境变量，我们需要让<code class="fe ne nf ng mw b">cmake</code>知道这个重要的事实，从而设置环境变量。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c11d" class="lt lu in mw b gy na nb l nc nd">$ export ANDROID_STANDALONE_TOOLCHAIN=/tmp/my-android-toolchain/</span></pre><p id="3c9f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这是我们的构建环境需要知道的，不需要其他变量。如果你已经有安卓_NDK设置，请取消设置。</p><h2 id="6be4" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第三步:</h2><p id="f041" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">为Android构建还需要几个重要的包，叫做Ninja和ant，我们也会安装它们:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1cb4" class="lt lu in mw b gy na nb l nc nd">$ sudo apt-get install ninja-build ant</span></pre><h2 id="60c8" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第四步:</h2><p id="af05" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">下载OpenCV，没有比Satya Mallick的博客更好的地方可以找到下载步骤了。你可以按照博客建议的方式编译，也可以下载所有的包，OpenCV repository，然后把它放在那里。因为我们正在为Android编译，所以我们可以跳过博客中提到的编译部分。如果你需要<code class="fe ne nf ng mw b">contrib</code>模块，为这篇文章下载它们，</p><p id="a9ab" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">不管怎样，让我们转到OpenCV目录。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b9e4" class="lt lu in mw b gy na nb l nc nd">$ cd opencv/<br/>$ mkdir build<br/>$ cd build<br/>$ cmake  \<br/>-DCMAKE_TOOLCHAIN_FILE=../platforms/android/android.toolchain.cmake\<br/>-DANDROID_STL=gnustl_shared \<br/>-DANDROID_NATIVE_API_LEVEL=23 ..</span></pre><p id="70b4" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><strong class="kf io"> <em class="ke">注意</em></strong><em class="ke">:OpenCV 3.0如果SDK高于25.2.5，则使失败。请确保您安装了合适的Android SDK。</em></p><p id="9bae" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">输出将显示此构建的配置，这是您可以更改您喜欢的配置的步骤。</p><p id="093a" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">对于基于ARM的设备，我通常使用以下方法进行优化:</p><ol class=""><li id="d327" class="lf lg in kf b kg kh kk kl lc lh ld li le lj la lk ll lm ln bi translated"><strong class="kf io">T21霓虹</strong></li><li id="6c35" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la lk ll lm ln bi translated"><strong class="kf io"> <em class="ke"> VFPV3 </em> </strong></li></ol><p id="07a5" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">查看<code class="fe ne nf ng mw b">platforms/android/android.toolchain.cmake</code>的序言，了解各种配置选项。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9e9d" class="lt lu in mw b gy na nb l nc nd">$ make -j $nproc</span></pre><h2 id="21f7" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第五步:</h2><p id="95f0" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">希望构建进展顺利，并且您已经准备好了<a class="ae lb" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="noopener ugc nofollow" target="_blank"> ELF </a>以<code class="fe ne nf ng mw b">.so</code>(共享对象)的形式输出，您也可以生成输出为<code class="fe ne nf ng mw b">.a</code>，为此，您需要在<code class="fe ne nf ng mw b">cmake</code>中启用适当的标志。输出如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4b72" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# ls<br/>libopencv_calib3d.a libopencv_flann.a <strong class="mw io">libopencv_java3.so</strong> libopencv_shape.a libopencv_video.a<br/>libopencv_core.a libopencv_highgui.a libopencv_ml.a libopencv_stitching.a libopencv_videoio.a<br/>libopencv_dnn.a libopencv_imgcodecs.a libopencv_objdetect.a libopencv_superres.a libopencv_videostab.a<br/>libopencv_features2d.a libopencv_imgproc.a libopencv_photo.a libopencv_ts.a</span></pre><p id="7831" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><code class="fe ne nf ng mw b">libopencv_java3.so</code>是你的android项目所需要的，但是如果你看看它的大小，它大约有<strong class="kf io"> 9.5MB </strong>:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c37a" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# du -h libopencv_java3.so<br/><strong class="mw io">9.4M</strong> libopencv_java3.so</span></pre><p id="77f9" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这是因为，它包含了所有的模块。要验证这一点，请运行以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6224" class="lt lu in mw b gy na nb l nc nd">$ strings -a libopencv_java3.so | grep .cpp</span></pre><h2 id="2934" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第六步:</h2><p id="59d7" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">让我们根据我们的需要修整图书馆。假设我们只需要两个模块<code class="fe ne nf ng mw b">core</code>和<code class="fe ne nf ng mw b">imageproc</code>:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2a7f" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# /tmp/my-android-toolchain/bin/arm-linux-androideabi-g++ \<br/>-shared -o <strong class="mw io">libopencv_tiny.so</strong> \<br/>--sysroot=/tmp/my-android-toolchain/sysroot/ \<br/>-Wl,--whole-archive <strong class="mw io">libopencv_core.a</strong> \<br/><strong class="mw io">libopencv_imgproc.a</strong> -Wl,--no-whole-archive</span></pre><p id="1660" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">现在检查<code class="fe ne nf ng mw b">libopencv_tiny.so</code>的文件类型和大小</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a629" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# file libopencv_tiny.so<br/>libopencv_tiny.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /system/bin/linker, <strong class="mw io">not stripped</strong></span><span id="3663" class="lt lu in mw b gy nh nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# du -h libopencv_tiny.so<br/><strong class="mw io">8.3M libopencv_tiny.so</strong></span></pre><p id="f2e6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这是<strong class="kf io"> <em class="ke">无条纹</em> </strong>，让我们把它剥开:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d962" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# /tmp/my-android-toolchain/bin/arm-linux-androideabi-strip --strip-unneeded libopencv_tiny.so</span><span id="c40f" class="lt lu in mw b gy nh nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# file libopencv_tiny.so<br/>libopencv_tiny.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /system/bin/linker, <strong class="mw io">stripped</strong></span><span id="8f05" class="lt lu in mw b gy nh nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# du -h libopencv_tiny.so<br/><strong class="mw io">3.4M libopencv_tiny.so</strong></span></pre><h2 id="f401" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">可选步骤:“奖励回合”</h2><p id="4980" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">您可以进一步向下钻取每个<code class="fe ne nf ng mw b">.o</code>文件，而不是<code class="fe ne nf ng mw b">.a</code>文件，这可以通过使用<code class="fe ne nf ng mw b">ar</code>工具来实现:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6f09" class="lt lu in mw b gy na nb l nc nd">$ /tmp/my-android-toolchain/bin/arm-linux-androideabi-ar x  libopencv_core.a</span></pre><p id="a1af" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><code class="fe ne nf ng mw b">ar</code>工具从<code class="fe ne nf ng mw b">.a</code>文件中提取所有的<code class="fe ne nf ng mw b">.o</code>，然后你可以用我们之前创建的方法从它们中创建<code class="fe ne nf ng mw b">.so</code>，命令如下:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="29c2" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# /tmp/my-android-toolchain/bin/arm-linux-androideabi-g++ \<br/>-shared -o <strong class="mw io">libopencv_tiny.so</strong> \<br/>--sysroot=/tmp/my-android-toolchain/sysroot/ \<br/>-Wl, — whole-archive <strong class="mw io">*.o</strong> -Wl, — no-whole-archive</span></pre><h2 id="6fa9" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">第七步:创建。所以对于您的应用程序</h2><p id="ba9c" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">联系是努力的终点，让我们也跨越这个里程碑。由于这是针对特定平台的交叉编译，所以在<code class="fe ne nf ng mw b">.so</code>中包含一些提取库是很重要的，这些额外的库完全是第三方的和特定于平台的。如果您不包括它们，您将得到一个链接错误，因此让我们这样做:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7afc" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# /tmp/my-android-toolchain/bin/arm-linux-androideabi-g++ -L /opencv/build/3rdparty/lib/armeabi-v7a  <strong class="mw io">-lz -llog -ljnigraphics -ltegra_hal -lcpufeatures -lm -lgnustl_shared</strong> -fexceptions -frtti -fpic  -shared -Wl,-soname,libopencv_java.so -o libopencv_java.so  -Wl,--whole-archive libopencv_core.a libopencv_imgproc.a  -Wl,--no-whole-archive</span></pre><p id="4dc0" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">依赖项应该如下所示，这些额外的库很少是<code class="fe ne nf ng mw b">.a</code>，所以它们不会出现在依赖项中。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="376c" class="lt lu in mw b gy na nb l nc nd">root@dc:/opencv/build/lib/armeabi-v7a# readelf -d libopencv_tiny.so</span><span id="5437" class="lt lu in mw b gy nh nb l nc nd">Dynamic section at offset 0x3615d8 contains 33 entries:<br/>  Tag        Type                         Name/Value<br/> 0x00000003 (PLTGOT)                     0x362b18<br/> 0x00000002 (PLTRELSZ)                   2488 (bytes)<br/> 0x00000017 (JMPREL)                     0x3f674<br/> 0x00000014 (PLTREL)                     REL<br/> 0x00000011 (REL)                        0x28cb4<br/> 0x00000012 (RELSZ)                      92608 (bytes)<br/> 0x00000013 (RELENT)                     8 (bytes)<br/> 0x6ffffffa (RELCOUNT)                   11570<br/> 0x00000006 (SYMTAB)                     0x148<br/> 0x0000000b (SYMENT)                     16 (bytes)<br/> 0x00000005 (STRTAB)                     0xaf78<br/> 0x0000000a (STRSZ)                      97135 (bytes)<br/> 0x00000004 (HASH)                       0x22ae8<br/> 0x00000001 (NEEDED)                     Shared library: [libz.so]<br/> 0x00000001 (NEEDED)                     Shared library: [liblog.so]<br/> 0x00000001 (NEEDED)                     Shared library: [libjnigraphics.so]<br/> 0x00000001 (NEEDED)                     Shared library: [libm.so]<br/> 0x00000001 (NEEDED)                     Shared library: [libc.so]<br/> 0x00000001 (NEEDED)                     Shared library: [libdl.so]<br/> 0x0000000e (SONAME)                     Library soname: [libopencv_tiny.so]<br/> 0x0000001a (FINI_ARRAY)                 0x35e7b4<br/> 0x0000001c (FINI_ARRAYSZ)               8 (bytes)<br/> 0x00000019 (INIT_ARRAY)                 0x362554<br/> 0x0000001b (INIT_ARRAYSZ)               132 (bytes)<br/> 0x00000010 (SYMBOLIC)                   0x0<br/> 0x0000001e (FLAGS)                      SYMBOLIC BIND_NOW<br/> 0x6ffffffb (FLAGS_1)                    Flags: NOW<br/> 0x6ffffff0 (VERSYM)                     0x27690<br/> 0x6ffffffc (VERDEF)                     0x28c58<br/> 0x6ffffffd (VERDEFNUM)                  1<br/> 0x6ffffffe (VERNEED)                    0x28c74<br/> 0x6fffffff (VERNEEDNUM)                 2<br/> 0x00000000 (NULL)                       0x0</span></pre><p id="d4d3" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">在检查尺寸之前，确保您新创建的<code class="fe ne nf ng mw b">.so</code><code class="fe ne nf ng mw b">strip</code>。</p><p id="9bfb" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">现在，您的共享对象(<code class="fe ne nf ng mw b">libopencv_tiny.so</code>)已经为android部署做好了准备。它通常被命名为<code class="fe ne nf ng mw b">libopencv_java3.so</code>，其中<code class="fe ne nf ng mw b">3</code>是版本，但不要担心它只是一个文件名，它仍然可以工作，或者使其符合android要求，并将其命名为<code class="fe ne nf ng mw b">libopencv_java3.so</code>。</p><h2 id="a531" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">步骤8:用示例代码链接</h2><p id="f9e9" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">假设我们在目录<code class="fe ne nf ng mw b">./demo</code>内的文件<code class="fe ne nf ng mw b">demo.cpp</code>中有下面的代码，您想要链接到创建的<code class="fe ne nf ng mw b">.so</code>:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3be9" class="lt lu in mw b gy na nb l nc nd">#include "opencv2/opencv.hpp"<br/>#include&lt;iostream&gt;</span><span id="a48f" class="lt lu in mw b gy nh nb l nc nd">int main()<br/>{<br/>    std::cout &lt;&lt; "OpenCV Version " &lt;&lt; CV_VERSION &lt;&lt; std::endl;<br/>}</span></pre><p id="874f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我们必须使用相同的工具链来编译和链接<code class="fe ne nf ng mw b">demo.cpp</code>，你能猜到为什么吗？</p><p id="43b1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">好吧！既然你在思考，让我快速开始编译:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="cebe" class="lt lu in mw b gy na nb l nc nd">root@dc: /tmp/my-android-toolchain/bin/arm-linux-androideabi-g++ -L/demo  -I /demo/include/ -Wall    -o demo demo.cpp -lopencv_tiny</span></pre><p id="89e1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我已经把生成的<code class="fe ne nf ng mw b">libopencv_tiny.so</code>移到了文件夹<code class="fe ne nf ng mw b">./demo</code>和所有的opencv <code class="fe ne nf ng mw b">includes</code>(我的意思是。hpp)，这只是为了证明我们是孤立的，没有使用<code class="fe ne nf ng mw b">/usr/local/include</code></p><blockquote class="jz ka kb"><p id="1f93" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">现在，回到我的问题，为什么是相同的工具链？</p></blockquote><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="44eb" class="lt lu in mw b gy na nb l nc nd">root@5c7fe9a72d74:/demo# readelf -h libopencv_tiny.so<br/>ELF Header:<br/>  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00<br/>  Class:                             ELF32<br/>  Data:                              2's complement, little endian<br/>  Version:                           1 (current)<br/>  OS/ABI:                            UNIX - System V<br/>  ABI Version:                       0<br/>  Type:                              DYN (Shared object file)<br/>  <strong class="mw io">Machine:                           ARM</strong><br/>  Version:                           0x1<br/>  Entry point address:               0x0<br/>  Start of program headers:          52 (bytes into file)<br/>  Start of section headers:          3561860 (bytes into file)<br/>  Flags:                             0x5000200, Version5 EABI, soft-float ABI<br/>  Size of this header:               52 (bytes)<br/>  Size of program headers:           32 (bytes)<br/>  Number of program headers:         8<br/>  Size of section headers:           40 (bytes)<br/>  Number of section headers:         27<br/>  Section header string table index: 26</span></pre><p id="e1a4" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">你拿到了吗？好吧，让我这么说:<code class="fe ne nf ng mw b">.so</code>是为一个特定的<code class="fe ne nf ng mw b">arch</code>类型交叉编译的，那就是<code class="fe ne nf ng mw b">ARM</code>，其中我们的主机是基于linux的<code class="fe ne nf ng mw b">x86</code>。这就是为什么，您只需要在相同的目标机器类型上运行可执行文件。</p><h2 id="d5e2" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">最后一步:</h2><p id="84eb" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">如果你在x86上构建它，你还必须告诉你的<code class="fe ne nf ng mw b">.so</code>驻留在哪里，你可以把它放在你喜欢的任何地方，我的意思是在你的项目或工作区的任何文件夹中，因为这个运行时链接，<code class="fe ne nf ng mw b">ld</code>应该能找到它。最好的方法是更新环境变量:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0d5e" class="lt lu in mw b gy na nb l nc nd">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;your .so path&gt;</span></pre><p id="320e" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">现在，说你变得很大方，想分享给系统上的每个人。为此你需要有<code class="fe ne nf ng mw b">root</code>权限。您需要它有两个原因:</p><ul class=""><li id="bd4d" class="lf lg in kf b kg kh kk kl lc lh ld li le lj la ni ll lm ln bi translated">将库放在标准的系统位置，可能是<code class="fe ne nf ng mw b">/usr/lib</code>或<code class="fe ne nf ng mw b">/usr/local/lib</code>，普通用户对其没有写权限。</li><li id="358f" class="lf lg in kf b kg lo kk lp lc lq ld lr le ls la ni ll lm ln bi translated">您需要修改<code class="fe ne nf ng mw b">ld.so</code>配置文件和缓存。如<code class="fe ne nf ng mw b">root</code>所示，执行以下操作:</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9b5f" class="lt lu in mw b gy na nb l nc nd">cp /demo/libopencv_tiny.so /usr/local/lib<br/>chmod 0755 /usr/local/lib/libopencv_tiny.so</span></pre><p id="a76f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我们需要通知<code class="fe ne nf ng mw b">ld</code>它可以使用了，因此让我们更新缓存:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6c33" class="lt lu in mw b gy na nb l nc nd">ldconfig</span></pre><p id="ec92" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">现在，我们不需要<code class="fe ne nf ng mw b">LD_LIBRARY_PATH</code>，所以让我们也清除它。注意:你只能从<code class="fe ne nf ng mw b">LD_LIBRARY_PATH</code>开始清除自己的路径。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5bf1" class="lt lu in mw b gy na nb l nc nd">unset LD_LIBRARY_PATH</span></pre><h2 id="b2c7" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me ld mf mg mh le mi mj mk ml bi translated">另一种选择:使用OpenCV Makefile编译</h2><p id="fdc5" class="pw-post-body-paragraph kc kd in kf b kg mm ki kj kk mn km kn lc mo kq kr ld mp ku kv le mq ky kz la ig bi translated">我在此附上由<a class="nj nk ep" href="https://medium.com/u/553a25b3deaf?source=post_page-----932460acfe38--------------------------------" rel="noopener" target="_blank"> Yk订单</a>建议的回复。使用OpenCV <code class="fe ne nf ng mw b">Makefile,</code>的好处是所有的依赖都被考虑到了，你需要为你的平台传递合适的构建工具。</p><p id="416f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">Android示例:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="22ec" class="lt lu in mw b gy na nb l nc nd">cmake -DCMAKE_TOOLCHAIN_FILE=../platforms/android/android.toolchain.cmake \<br/>-D ANDROID_ABI=arm64-v8a \<br/>-D CMAKE_BUILD_TYPE=Release \<br/>-D ANDROID_NATIVE_API_LEVEL=23 \<br/>-D WITH_CUDA=OFF \<br/>-D WITH_MATLAB=OFF \<br/>-D BUILD_ANDROID_EXAMPLES=OFF \<br/>-D BUILD_DOCS=OFF \<br/>-D BUILD_PERF_TESTS=OFF \<br/>-D BUILD_TESTS=OFF \<br/>-D ANDROID_STL=c++_shared \<br/>-D BUILD_SHARED_LIBS=ON \<br/>-D BUILD_opencv_objdetect=OFF \<br/>-D BUILD_opencv_video=OFF \<br/>-D BUILD_opencv_videoio=OFF \<br/>-D BUILD_opencv_features2d=OFF \<br/>-D BUILD_opencv_flann=OFF \<br/>-D BUILD_opencv_highgui=OFF \<br/>-D BUILD_opencv_ml=OFF \<br/>-D BUILD_opencv_photo=OFF \<br/>-D BUILD_opencv_python=OFF \<br/>-D BUILD_opencv_shape=OFF \<br/>-D BUILD_opencv_stitching=OFF \<br/>-D BUILD_opencv_superres=OFF \<br/>-D BUILD_opencv_ts=OFF \<br/>-D BUILD_opencv_videostab=OFF \<br/>..</span></pre><p id="924b" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">在您的Linux或MacOS上:(它将在构建中包含<code class="fe ne nf ng mw b">imgproc and highgui</code>模块)</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="02c7" class="lt lu in mw b gy na nb l nc nd">cmake<br/>-D CMAKE_BUILD_TYPE=Release \<br/>-D WITH_CUDA=OFF \<br/>-D WITH_MATLAB=OFF \<br/>-D BUILD_ANDROID_EXAMPLES=OFF \<br/>-D BUILD_DOCS=OFF \<br/>-D BUILD_PERF_TESTS=OFF \<br/>-D BUILD_TESTS=OFF \<br/>-D BUILD_SHARED_LIBS=ON \<br/>-D BUILD_opencv_objdetect=OFF \<br/>-D BUILD_opencv_video=OFF \<br/>-D BUILD_opencv_videoio=OFF \<br/>-D BUILD_opencv_features2d=OFF \<br/>-D BUILD_opencv_flann=OFF \<br/>-D BUILD_opencv_ml=OFF \<br/>-D BUILD_opencv_photo=OFF \<br/>-D BUILD_opencv_python=OFF \<br/>-D BUILD_opencv_shape=OFF \<br/>-D BUILD_opencv_stitching=OFF \<br/>-D BUILD_opencv_superres=OFF \<br/>-D BUILD_opencv_ts=OFF \<br/>-D BUILD_opencv_videostab=OFF \<br/>-D BUILD_opencv_highgui=ON \<br/>-D BUILD_opencv_imgproc=ON \<br/>..</span></pre><p id="16b5" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">你可以在最终版本中选择你需要的模块，事实上我可能漏掉了一些。</p><blockquote class="jz ka kb"><p id="69ef" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><em class="in">享受动态链接的力量！</em></p></blockquote><p id="fa56" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><strong class="kf io">你可以在|</strong><a class="ae lb" href="https://www.linkedin.com/in/mdeore/" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">LinkedIn</strong></a><strong class="kf io">|</strong><a class="ae lb" href="https://tomdeore.wixsite.com/epoch" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">网站</strong></a><strong class="kf io">|</strong><a class="ae lb" href="https://github.com/milinddeore" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">Github</strong></a><strong class="kf io">|</strong></p></div></div>    
</body>
</html>