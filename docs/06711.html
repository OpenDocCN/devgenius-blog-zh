<html>
<head>
<title>Docker — A Beginner’s guide to understanding Dockerfile with a sample project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker——用一个示例项目理解 Dockerfile 的初学者指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-a-beginners-guide-to-understanding-dockerfile-with-a-sample-project-f1a54eeedb0f?source=collection_archive---------3-----------------------#2022-01-27">https://blog.devgenius.io/docker-a-beginners-guide-to-understanding-dockerfile-with-a-sample-project-f1a54eeedb0f?source=collection_archive---------3-----------------------#2022-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f881" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理解 Dockerfile 文件的逐步指南</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aeeced314fe30385e25fb63126767f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*om98d4337n9eE1iWu0Zb8g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">通过 Dockerfile 自动创建 Docker 图像</strong></figcaption></figure><p id="3b92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Dockerfile 用于自动创建 Docker 映像。Docker 通过读取 docker 文件中的指令来构建映像。</p><p id="7a09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将通过构建一个示例项目来理解 Dockerfile 指令，为所有示例复制下面的 repo。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="10dc" class="le lf in la b gy lg lh l li lj">git clone <a class="ae lk" href="https://github.com/ahmedbhl/dockerfile-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/ahmedbhl/dockerfile-examples</a></span></pre><p id="5c6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是我们可以在<strong class="jm io">docker 文件</strong>中使用的所有命令。</p><ul class=""><li id="4fe2" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated"><strong class="jm io">评论</strong></li><li id="3ab4" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">来自</strong></li><li id="5dcb" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io"> CMD </strong></li><li id="71b8" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">入口点</strong></li><li id="d838" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">工作方向</strong></li><li id="be78" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">环境</strong></li><li id="ff3e" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">复制</strong></li><li id="00fe" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">标签</strong></li><li id="25a2" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">跑</strong></li><li id="c3d0" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">增加</strong></li><li id="7442" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">。dockerignore </strong></li><li id="5737" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io"> ARG </strong></li><li id="eb2c" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">揭露</strong></li><li id="048a" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">用户</strong></li><li id="9cef" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><strong class="jm io">卷</strong></li></ul><h1 id="c724" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">评论</h1><p id="ca0c" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">dockerfile 文件中的注释以<strong class="jm io"> # </strong>开头，您可以将这些注释放在任何地方。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="592d" class="le lf in la b gy lg lh l li lj"># from base image node</span></pre><h1 id="42d6" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">从</h1><p id="1e84" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">这是 Dockerfile 文件中的第一个命令。没有这个，我们就无法建立形象。我们可以用这个命令来构建图像。当我们仅使用<strong class="jm io"> FROM，</strong>构建时，无论何时实例化映像，我们实际上都在获取基础映像 CMD。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DockerFile 文件</figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="1365" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t first-dockerfile -f Dockerfile1 .</span><span id="15c6" class="le lf in la b gy nc lh l li lj">// list image<br/>docker images</span><span id="7f84" class="le lf in la b gy nc lh l li lj">// run the image<br/>docker run -it -d first-dockerfile</span><span id="bc32" class="le lf in la b gy nc lh l li lj">// use exec for interaction<br/>docker exec -it f1edbfca3eac bash</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/af28e2b370fa27f877a7c2c7dd0d7499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJIEnVgM4AeADvfsRO755A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b1fa1a0618bc9ba470d25725f2336716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1imlJ8FgTBcWL_BSMb0Zg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">用 FROM 命令构建 Docker 映像</strong></figcaption></figure><h1 id="a20a" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">煤矿管理局</h1><p id="b0f4" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated"><strong class="jm io"> CMD </strong>命令用于在镜像实例化时给出默认命令，它在构建阶段不执行。每个 docker 文件应该只有一个 CMD，您可以列出多个，但将执行最后一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">多个命令，但最后一个命令被执行</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="4bd2" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile2 -f Dockerfile2 .</span><span id="ad8b" class="le lf in la b gy nc lh l li lj">// list image<br/>docker images</span><span id="04cd" class="le lf in la b gy nc lh l li lj">// run the image<br/>docker run -it -d dockerfile2</span><span id="a8b1" class="le lf in la b gy nc lh l li lj">// use exec for interaction<br/>docker exec -it &lt;conatiner id&gt; bash</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/4e0c202b433e1a76c4555b547ab3e1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRUmVxuIXYGf3lXqstHJ1w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">构建映像并运行它</strong></figcaption></figure><p id="a3b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您注意到了，最后一个命令是在我们运行容器时执行的。这里有几点需要注意。</p><ul class=""><li id="be19" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated">如果我们在 ENTRYPOINT 中指定可执行文件，我们可以使用 CMD 向它传递默认参数(查看 ENTRYPOINT 部分)</li><li id="f32f" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated">如果没有，我们可以在 CMD 中指定可执行参数和默认参数。</li><li id="6f8e" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated">我们可以在运行容器时覆盖 CMD 中给出的默认命令</li></ul><h1 id="4217" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">入口点</h1><p id="fb7c" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">ENTRYPOINT 用作容器的可执行文件。让我们看看下面的例子</p><p id="1159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将 ENTRYPOINT 用于可执行命令，并使用 CMD 命令将一些默认命令传递给可执行文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">带有入口点的 Dockerfile 示例</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="6991" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile3 -f Dockerfile3 .</span><span id="5ce6" class="le lf in la b gy nc lh l li lj">// run the container<br/>docker run -it dockerfile3</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/abdfc40bcbfde9a9500946a4b4ec31f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cH4nxf7eMmKeV887GigsrA.png"/></div></div></figure><h1 id="f4dd" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">工作方向</h1><p id="078e" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated"><strong class="jm io">工作目录</strong>设置所有连续命令的工作目录。我们可以有多个<strong class="jm io"> WORKDIR </strong>命令，并将附加一个相对路径。考虑下面的例子，我们有两个<strong class="jm io"> WORKDIR </strong>命令导致<strong class="jm io"> /usr/node/app </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">工作目录的 Dockerfile】</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="fd4f" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile4 -f Dockerfile4 .</span><span id="0929" class="le lf in la b gy nc lh l li lj">// run the container<br/>docker run -it dockerfile4</span><span id="6fab" class="le lf in la b gy nc lh l li lj">// open in another terminal and do exec<br/>docker exec -it &lt;container id&gt; bash</span><span id="3fbb" class="le lf in la b gy nc lh l li lj">// see the current working directory<br/>pwd</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/8b10ef8c3d9d76fbf0eeb3da729fd299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbyFvSyOUY_FbqjDPP8Hkg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">在一个终端构建并运行镜像</strong></figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/21ddab86d6c6e54720c9cd65527c2f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vH-F1F48bTrdPGGhmekf5w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky"> exec 在另一个终端</strong></figcaption></figure><h1 id="b76f" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">包封/包围（动词 envelop 的简写）</h1><p id="2cc5" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">ENV 为构建阶段的后续指令设置环境变量。考虑下面的例子，我们定义了环境变量 workdirectory，并在后面的$中使用了它。有两种形式:单值和多值</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="02ad" class="le lf in la b gy lg lh l li lj">// form1<br/>ENV param value</span><span id="a454" class="le lf in la b gy nc lh l li lj">// form2<br/>ENV param1=value1,param2=value2</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">环境示例</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="91e8" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile5 -f Dockerfile5 .</span><span id="d086" class="le lf in la b gy nc lh l li lj">// run the container<br/>docker run -it dockerfile5</span><span id="0c87" class="le lf in la b gy nc lh l li lj">// open in another terminal and do exec<br/>docker exec -it &lt;container id&gt; bash</span><span id="490f" class="le lf in la b gy nc lh l li lj">// see the current working directory<br/>pwd</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/6048f706b82838788c58106231011ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qROkLMlwZeHQRfi77llOQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">环境在行动</strong></figcaption></figure><h1 id="2b2f" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">复制</h1><p id="18e0" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">拷贝用于将文件或目录从源主机文件系统拷贝到容器文件系统中的目标。考虑这个例子，我们将 package.json 从我们的系统复制到容器文件系统。我们可以用运行命令 ls -l 来验证这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">带有复制命令的 Dockerfile】</strong></figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/ae36b63e17dbcb3d3d8b8d95d56a62a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7GneJhAiK2igNDsKQkGWA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">运行 ls -l 命令列表 package.json </strong></figcaption></figure><h1 id="65cd" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">标签</h1><p id="ed7d" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">标签用于向图像添加一些元数据。如果我们使用与基础图像相同的标签并且应用最新的标签值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak"> Dockerfile 标签示例</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="06e8" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile7 -f Dockerfile7 .</span><span id="96ae" class="le lf in la b gy nc lh l li lj">// inspect the image<br/>docker image inspect dockerfile7</span></pre><h1 id="35fd" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">奔跑</h1><p id="67fe" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">RUN 在现有映像之上的新层中执行指令，并提交这些层，结果层将用于 docker 文件中的下一条指令。考虑这个例子，我们一次运行 npm install 和 ls -l 以避免任何额外的层。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="9398" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile8 -f Dockerfile8 .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/25e946d44e40a5b23e5b7628294a96e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9LOjHPKsqkSIBgXAegPIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky"> npm install 获取 package.json 并创建 package-lock.json </strong></figcaption></figure><h1 id="565c" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">注意缺陷障碍 (Attention Deficit Disorder)</h1><p id="5688" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">ADD 用于将 URL 中的文件或目录和远程文件从源主机文件系统添加到容器文件系统中的目标。考虑这个例子，我们将 index.js 从我们的系统添加到容器文件系统。我们可以用运行命令 ls -l 来验证这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">带有添加命令的 Dockerfile】</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="0e2f" class="le lf in la b gy lg lh l li lj">// build the image<br/>docker build -t dockerfile9 -f Dockerfile9 .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/dd2e7f97f68586e9fa7360e4541dc550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agqe-JFrlCaCHxVH1G2zng.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以在容器文件系统中看到 index.js 和其他文件</figcaption></figure><h1 id="1c20" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">。dockerignore</h1><p id="1256" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">每当我们在根级别构建映像时，整个上下文都会被发送到 Docker 守护进程。有时，我们不需要将所有内容发送到 Docker 守护进程，这些文件或目录应该添加到此。dockerignore 文件。</p><p id="1c1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们在上下文中有 node_modules，我们已经将它添加到。dockerignore 文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/571a03039b7a15d138ea8456c66a2e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m00LlNyAbmeZjvp33ziT1A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky"> node_modules 不应被发送到 Docker 守护进程</strong></figcaption></figure><h1 id="bbfc" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">银</h1><p id="1349" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">ARG 用于将一些参数传递给连续的指令，这是唯一可以在 FROM 之前使用的命令，而不是注释。我们可以在下面的文件中看到 ARG 的用法，也可以用 build 命令传递它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak"> ARG 示例 Dockerfile </strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="a768" class="le lf in la b gy lg lh l li lj">// build command<br/>docker build -t dockerfile10 -f Dockerfile10 .</span><span id="4e35" class="le lf in la b gy nc lh l li lj">// build-arg usage<br/>docker build -t dockerfile10 --build-arg NODE_VERSION=8.11.4  -f Dockerfile10 .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/dc4165c6c37fb349d940f35246973a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0sGFFx5RstbbWRjWUyLnA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky"> Dockerfile 正在通过取 ARG </strong>来构建</figcaption></figure><h1 id="2778" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">揭露</h1><p id="ce47" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">EXPOSE 用作端口的文档。这只是构建映像的人和运行容器的人之间的交流。除了记录之外，它没有任何其他用途。</p><p id="8e4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们在<strong class="jm io"> index.js </strong>文件中使用了端口<strong class="jm io"> 3070 </strong>。因此，我们通过使用 Dockerfile 文件中的<strong class="jm io"> EXPOSE </strong>指令让人们知道谁在运行容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="9573" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">用户</h1><p id="2a91" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">用户说明设置运行映像时使用的用户名和可选用户组，以及 docker 文件中该映像之后的任何说明</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">docker file 中用户的用法</strong></figcaption></figure><h1 id="a534" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">卷</h1><p id="bd15" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">卷用于创建具有指定名称的装载点。下面是 Dockerfile 和运行指令的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">docker 文件中的卷使用量</strong></figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="77e8" class="le lf in la b gy lg lh l li lj">// build command<br/>docker build -t dockerfile13 -f Dockerfile13 .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/ad938599e6685d27d331d8fb63c0a5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KATY2njviReioVxtloBzQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">卷目录在容器文件系统中列出</strong></figcaption></figure><h1 id="b668" class="lz lf in bd ky ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="50fd" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">我们用 Dockerfile 一步一步地构建项目，看了大部分说明。如果您需要更多信息，请查看 Docker 文档。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="d45d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="nw">感谢您的阅读，如果您发现这很有用，请为它鼓掌，并帮助其他人找到它。更多有趣的故事请关注我:)</em> </strong></p></div></div>    
</body>
</html>