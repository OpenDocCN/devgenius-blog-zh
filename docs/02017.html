<html>
<head>
<title>JavaScript Best Practices — Duplicates, Returns, Eval, and Built-in Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践—复制、返回、评估和内置原型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-duplicates-returns-eval-and-built-in-prototypes-aec55d5c4085?source=collection_archive---------28-----------------------#2020-07-16">https://blog.devgenius.io/javascript-best-practices-duplicates-returns-eval-and-built-in-prototypes-aec55d5c4085?source=collection_archive---------28-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a794fb8c063134c87455034ce88097b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HwzWZR74QNMtSygC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">帕斯卡尔·莫尔霍弗在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6a89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="65d9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在<code class="fe lz ma mb mc b">if-else-if</code>链中没有重复的条件</h1><p id="e538" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该在 if-else-if 链中有重复的条件。</p><p id="946f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有第一个会运行。</p><p id="a0f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="29c3" class="mq lc iq mc b gy mr ms l mt mu">if (isSomething(x)) {<br/>  foo();<br/>} else if (isSomething(x)) {<br/>  bar();<br/>}</span></pre><p id="09fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c8c9" class="mq lc iq mc b gy mr ms l mt mu">if (isSomething(x)) {<br/>  foo();<br/>} else if (isSomethingElse(x)) {<br/>  bar();<br/>}</span></pre><h1 id="a541" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文本中没有重复的键</h1><p id="9e3e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该在对象文本中有重复的键。</p><p id="b8fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的对象:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ff4f" class="mq lc iq mc b gy mr ms l mt mu">const foo = {<br/>  bar: "baz",<br/>  bar: "bar"<br/>};</span></pre><p id="c18f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a233" class="mq lc iq mc b gy mr ms l mt mu">const foo = {<br/>  bar: "baz"<br/>};</span></pre><h1 id="7c6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复的案例标签</h1><p id="cd6b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们的代码中不应该有重复的<code class="fe lz ma mb mc b">case</code>标签。</p><p id="7f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6a02" class="mq lc iq mc b gy mr ms l mt mu">switch (a) {<br/>  case 1:<br/>    break;<br/>  case 2:<br/>    break;<br/>  case 1:<br/>    break;<br/>  default:<br/>    break;<br/>}</span></pre><p id="5a3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="bfe7" class="mq lc iq mc b gy mr ms l mt mu">switch (a) {<br/>  case 1:<br/>    break;<br/>  case 2:<br/>    break;<br/>  default:<br/>    break;<br/>}</span></pre><h1 id="42c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复的导入</h1><p id="8e22" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该对一个模块使用多个<code class="fe lz ma mb mc b">import</code>语句。</p><p id="6e3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="efc4" class="mq lc iq mc b gy mr ms l mt mu">import { merge } from 'module';<br/>import something from 'foo';<br/>import { find } from 'module';</span></pre><p id="c5ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f717" class="mq lc iq mc b gy mr ms l mt mu">import { merge, find } from 'module';<br/>import something from 'foo';</span></pre><h1 id="c696" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在此之前不返回</h1><p id="58fc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们正在写一个<code class="fe lz ma mb mc b">return</code>语句，那么我们可以删除<code class="fe lz ma mb mc b">else</code></p><p id="708b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9a32" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  if (x) {<br/>    return y;<br/>  } <br/>  return z;  <br/>}</span></pre><p id="3a62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="40b4" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  if (x) {<br/>    return y;<br/>  } else {<br/>    return z;<br/>  }<br/>}</span></pre><h1 id="52a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空块语句</h1><p id="8cc8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">空的块不是很有用，所以我们应该用一些东西填充它们或者移除它们。</p><p id="65a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下内容并不十分有用:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a83b" class="mq lc iq mc b gy mr ms l mt mu">if (bar) {}</span><span id="c4dc" class="mq lc iq mc b gy mv ms l mt mu">while (bar) {}</span><span id="3797" class="mq lc iq mc b gy mv ms l mt mu">switch (bar) {}</span><span id="32f8" class="mq lc iq mc b gy mv ms l mt mu">try {<br/>  doSomething();<br/>} catch (ex) {</span><span id="6b69" class="mq lc iq mc b gy mv ms l mt mu">} finally {</span><span id="89a0" class="mq lc iq mc b gy mv ms l mt mu">}</span><span id="deef" class="mq lc iq mc b gy mv ms l mt mu">for (;;){}</span></pre><p id="c1dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们用一些东西填充它们。</p><h1 id="9ba9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正则表达式中的空字符类</h1><p id="87ec" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该在正则表达式中有空的字符类，因为它们不匹配任何东西。</p><p id="1542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该有这样的代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="12c2" class="mq lc iq mc b gy mr ms l mt mu">/^foo[]/.test("foobar");<br/>"foobar".match(/^foo[]/);</span></pre><p id="7a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该用一种模式来填充括号:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7fe9" class="mq lc iq mc b gy mr ms l mt mu">/^foo[a-z]/.test("foobar");<br/>"foobar".match(/^foo[a-z]/);</span></pre><h1 id="b949" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空函数</h1><p id="d1a1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们的代码中不应该有空函数。</p><p id="921d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们什么都不做。</p><p id="8d18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ab82" class="mq lc iq mc b gy mr ms l mt mu">function foo() {</span><span id="6f07" class="mq lc iq mc b gy mv ms l mt mu">}</span></pre><p id="c7fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="90d4" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  doSomething();<br/>}</span></pre><h1 id="b2f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空的析构模式</h1><p id="588b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">空的析构模式什么都不做，并且很容易被误认为默认值是空对象。</p><p id="759d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8d83" class="mq lc iq mc b gy mr ms l mt mu">const {a: {}} = foo;</span></pre><p id="b5a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很容易被误认为:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e2a2" class="mq lc iq mc b gy mr ms l mt mu">const {a = {}} = foo;</span></pre><p id="efed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一种是空的析构模式。</p><p id="27d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是使用空对象作为默认值。</p><h1 id="ed22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空值比较</h1><p id="4b6f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">由于数据类型强制，使用<code class="fe lz ma mb mc b">==</code>或<code class="fe lz ma mb mc b">!=</code>比较<code class="fe lz ma mb mc b">null</code>可能会产生意想不到的结果。</p><p id="9565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要用<code class="fe lz ma mb mc b">===</code>或者<code class="fe lz ma mb mc b">!==</code>来做比较。</p><p id="ad13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9b4c" class="mq lc iq mc b gy mr ms l mt mu">if (foo == null) {<br/>  bar();<br/>}</span><span id="f675" class="mq lc iq mc b gy mv ms l mt mu">while (qux != null) {<br/>  bar();<br/>}</span></pre><p id="1c3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2244" class="mq lc iq mc b gy mr ms l mt mu">if (foo === null) {<br/>  bar();<br/>}</span><span id="b147" class="mq lc iq mc b gy mv ms l mt mu">while (qux !== null) {<br/>  bar();<br/>}</span></pre><h1 id="5324" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有调用 eval()</h1><p id="42fd" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">eval</code>让我们从字符串中运行 JavaScript 代码。</p><p id="99c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们不应该使用它，因为从字符串运行代码是不安全的。</p><p id="daac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">性能优化也不能在字符串中的代码上进行。</p><p id="134e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5721" class="mq lc iq mc b gy mr ms l mt mu">eval("let a = 0");</span></pre><p id="f74c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4364" class="mq lc iq mc b gy mr ms l mt mu">let a = 0;</span></pre><h1 id="1779" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在<code class="fe lz ma mb mc b">catch</code>子句中没有重新分配异常</h1><p id="7b0d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该重新分配异常 ib <code class="fe lz ma mb mc b">catch</code>子句。</p><p id="e590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们这样做，那么我们会丢失异常中的数据。</p><p id="68eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写作；</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="515e" class="mq lc iq mc b gy mr ms l mt mu">try {<br/>  // code<br/>} catch (e) {<br/>  e = 10;<br/>}</span></pre><p id="839e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8510" class="mq lc iq mc b gy mr ms l mt mu">try {<br/>  // code<br/>} catch (e) {<br/>  const foo = 1;<br/>}</span></pre><h1 id="158c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要扩展本机对象</h1><p id="b932" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该扩展内置对象，即使我们被允许这样做。</p><p id="67da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该编写这样的代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f1dd" class="mq lc iq mc b gy mr ms l mt mu">Object.prototype.foo = 55;</span></pre><p id="5096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向内置构造函数添加属性。</p><p id="163b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lz ma mb mc b">defineProperty</code>也不好:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e3c7" class="mq lc iq mc b gy mr ms l mt mu">Object.defineProperty(Array.prototype, "bar", { value: 999 });</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7083aa816adfdcbe5407eab7e60ab5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ue9d0GWjiEqBFlKp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">劳伦·凯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d942" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bf97" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该有重复的条件、键或<code class="fe lz ma mb mc b">case</code>标签。</p><p id="d5e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们永远不应该使用<code class="fe lz ma mb mc b">eval</code>。</p><p id="0edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该扩展本地对象。</p><p id="b097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">空的析构模式也是无用的和欺骗性的。</p><p id="01a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要把<code class="fe lz ma mb mc b">null</code>和<code class="fe lz ma mb mc b">===</code>或者<code class="fe lz ma mb mc b">!==</code>进行比较。</p></div></div>    
</body>
</html>