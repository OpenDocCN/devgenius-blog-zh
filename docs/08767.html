<html>
<head>
<title>Spring Boot Externalised Configurations: 4 Things to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 外在化配置:要避免的 4 件事</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-externalised-configurations-4-things-to-avoid-7f045b2d721b?source=collection_archive---------0-----------------------#2022-07-09">https://blog.devgenius.io/spring-boot-externalised-configurations-4-things-to-avoid-7f045b2d721b?source=collection_archive---------0-----------------------#2022-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/99a7e902c86df1f7d0d87ada7a03da1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNOHoGXLiLz-FxBr03u5LQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@heftiba?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Toa Heftiba </a>在<a class="ae jd" href="https://unsplash.com/s/photos/furniture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="cfda" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">以及你能做些什么</h2></div><p id="2de5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">变更日志:<br/>2022 年 12 月 30 日—使用 Medium 的新代码块来突出显示语法</em></p><p id="6741" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 Spring Boot，配置可以很容易地外部化，这样我们就可以在不同的部署中使用相同的应用程序代码。</p><p id="b3aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，有一些地方你可能会因为你的设置而搬起石头砸自己的脚。</p><p id="64cf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将分享 4 件事，我们应该避免设置 Spring Boot 的外部化配置。我认为这是一篇相当固执己见的文章，因为我没有看到很多关于这方面的文章，但请随意分享您的观点。</p><p id="29cf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于本文，我将使用 Spring Boot 2.6.9 和科特林 1.6.21。至于外部配置，我将使用 YAML 文件和<code class="fe ls lt lu lv b">@ConfigurationProperties</code>限定符进行属性绑定。</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/57cfdfe53514f9bb9f4fa99438bb881f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mL5e1ireHj_Ib4LedKDpKg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">我的春季初始化设置。点击此处的<a class="ae jd" href="https://start.spring.io/#!type=gradle-project&amp;language=kotlin&amp;platformVersion=2.6.9&amp;packaging=jar&amp;jvmVersion=11&amp;groupId=com.example&amp;artifactId=demo&amp;name=demo&amp;description=Demo%20project%20for%20Spring%20Boot&amp;packageName=com.example.demo&amp;dependencies=native,lombok,configuration-processor,validation" rel="noopener ugc nofollow" target="_blank">按钮</a>获得与上述相同的设置。</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="0168" class="mi mj jg bd mk ml mm dn mn mo mp dp mq le mr ms mt li mu mv mw lm mx my mz na bi translated">内容</h2><ol class=""><li id="3f81" class="nb nc jg kx b ky nd lb ne le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae jd" href="#100f" rel="noopener ugc nofollow">弱 POJO 分型</a></li><li id="662f" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae jd" href="#b072" rel="noopener ugc nofollow">可变 POJO </a></li><li id="bd02" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae jd" href="#66e6" rel="noopener ugc nofollow">惰性初始化</a></li><li id="fa35" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><code class="fe ls lt lu lv b"><a class="ae jd" href="#c05b" rel="noopener ugc nofollow">@Value</a></code> <a class="ae jd" href="#c05b" rel="noopener ugc nofollow">注解</a></li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="100f" class="nr mj jg bd mk ns nt nu mn nv nw nx mq km ny kn mt kp nz kq mw ks oa kt mz ob bi translated">1.弱 POJO 分型</h1><p id="3d17" class="pw-post-body-paragraph kv kw jg kx b ky nd kh la lb ne kk ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">假设你有以下<code class="fe ls lt lu lv b">application.yml</code>:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="52bd" class="oj mj jg lv b be ok ol l om on">person:<br/>  name: raimi<br/>  age: 2O<br/>  website: https:///remykarem.medium.com<br/>  hobbies: swimming,drawing<br/>  email: hello@gmail.com</span></pre><p id="9497" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">绑定结构化属性的弱类型 POJO 的一个例子是这样的(注意所有的<code class="fe ls lt lu lv b">String</code>类型):</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="d318" class="oj mj jg lv b be ok ol l om on">@ConstructorBinding<br/>@ConfigurationProperties(prefix = "person")<br/>data class PersonProperties(<br/>  val name: String,<br/>  val age: String, <br/>  val website: String,<br/>  val hobbies: String,<br/>  val email: String,<br/>)</span></pre><p id="0fa8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">⚠️ <strong class="kx jh">有什么问题吗？</strong></p><p id="6552" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何属性都可以是<code class="fe ls lt lu lv b">String</code>类型，因为输入是一串字符。但是如果您打算在应用程序代码中使用一个属性作为另一种类型，那么<code class="fe ls lt lu lv b">String</code>类型可能不是绑定属性的最佳选择。原因如下:</p><ul class=""><li id="f6aa" class="nb nc jg kx b ky kz lb lc le oo li op lm oq lq or nj nk nl bi translated">财产类型(<code class="fe ls lt lu lv b">String</code>)可能是一个<strong class="kx jh">虚假陈述</strong>，并且不是自我记录的。例如，<code class="fe ls lt lu lv b">hobbies</code>最好用<code class="fe ls lt lu lv b">List&lt;*&gt;</code>来表示它是一个集合。</li><li id="5d7f" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq or nj nk nl bi translated"><strong class="kx jh">属性</strong>没有验证。例如，如果<code class="fe ls lt lu lv b">age</code>被定义为一个<code class="fe ls lt lu lv b">String</code>，而你将其定义为<code class="fe ls lt lu lv b">2O</code>而不是<code class="fe ls lt lu lv b">20</code>，你在启动时不会得到任何验证错误。(你注意到上面 YAML 文件中的错别字了吗😏？)</li><li id="0375" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq or nj nk nl bi translated">在代码中使用属性<strong class="kx jh">之前，必须对其进行转换。这意味着你需要将<code class="fe ls lt lu lv b">age</code>转换成<code class="fe ls lt lu lv b">Int</code>类型。为什么要自己经历转换的麻烦呢？</strong></li></ul><p id="d458" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">✅你能做什么？</p><ul class=""><li id="d120" class="nb nc jg kx b ky kz lb lc le oo li op lm oq lq or nj nk nl bi translated">使用您希望在代码中使用的类型。它可以是集合、枚举或嵌套的 POJO。如果不是原始类型，你很可能需要一个<a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.conversion" rel="noopener ugc nofollow" target="_blank">自定义</a> <code class="fe ls lt lu lv b"><a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.conversion" rel="noopener ugc nofollow" target="_blank">Converter</a></code>。在这里，我邀请您探索其他类型，如<code class="fe ls lt lu lv b">URL</code> ( <code class="fe ls lt lu lv b">java.net</code>)或<code class="fe ls lt lu lv b">Inet4Address</code> ( <code class="fe ls lt lu lv b">java.net</code>)。</li><li id="0bf6" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq or nj nk nl bi translated">如果你需要最终类型是一个<code class="fe ls lt lu lv b">String</code>，使用<code class="fe ls lt lu lv b">javax.validation</code>约束注释，比如<code class="fe ls lt lu lv b">@Email</code>和<code class="fe ls lt lu lv b">@Url</code>。</li></ul><p id="9771" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一种方法可以改进<code class="fe ls lt lu lv b">PersonProperties</code>的 POJO 类型:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="75c1" class="oj mj jg lv b be ok ol l om on">@Validated<br/>@ConstructorBinding<br/>@ConfigurationProperties(prefix = "person")<br/>data class PersonProperties(<br/>  val name: String,<br/>  val age: Int, <br/>  val website: URL,<br/>  val hobbies: List&lt;String&gt;,<br/>  @field:Email <br/>  val email: String,<br/>)</span></pre><p id="56ae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">📕阅读更多</strong></p><p id="564f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.validation" rel="noopener ugc nofollow" target="_blank">配置属性验证</a>，<a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.merging-complex-types" rel="noopener ugc nofollow" target="_blank">合并复杂类型</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="b072" class="nr mj jg bd mk ns nt nu mn nv nw nx mq km ny kn mt kp nz kq mw ks oa kt mz ob bi translated">2.可变 POJO</h1><p id="d995" class="pw-post-body-paragraph kv kw jg kx b ky nd kh la lb ne kk ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">假设你有以下<code class="fe ls lt lu lv b">application.yml</code>:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="4751" class="oj mj jg lv b be ok ol l om on">person:<br/>  name: raimi<br/>  website: https://remykarem.medium.com</span></pre><p id="2cd6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个没有只读访问权限的可变 POJO 的示例:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="c058" class="oj mj jg lv b be ok ol l om on">@Configuration<br/>@ConfigurationProperties(prefix = "person")<br/>class PersonProperties {<br/>  lateinit var name: String<br/>  lateinit var website: URL<br/>}</span></pre><p id="3979" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">⚠️ <strong class="kx jh">有什么问题吗？</strong></p><p id="5287" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">var</code>属性<code class="fe ls lt lu lv b">name</code>和<code class="fe ls lt lu lv b">website</code>可能会在代码库中的其他地方被意外更改，并且可能会被忽略。这种无意的(或有意的🤔)改动<strong class="kx jh">会造成整个 app 的副作用</strong>。</p><p id="2bde" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个应用的配置<strong class="kx jh">在其生命周期内不应该改变</strong>。如配置的<a class="ae jd" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank"> 12 因素应用<em class="lr"> </em>方法中所述，配置应仅在部署之间有所不同。</a></p><p id="9fcf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> ✅你能做什么？</strong></p><p id="e55a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Spring Boot 通过<a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.constructor-binding" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh">构造函数绑定方法</strong> </a>提供了一种定义 POJOs 的不可变方法。它结合了<code class="fe ls lt lu lv b">data class</code>、<code class="fe ls lt lu lv b">val</code>、<code class="fe ls lt lu lv b">@ConfigurationProperties</code>和<code class="fe ls lt lu lv b">@ConstructorBinding</code>关键字。</p><p id="bb34" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个改进 POJO 的方法。</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="2b4d" class="oj mj jg lv b be ok ol l om on">@ConstructorBinding<br/>@ConfigurationProperties(prefix = "person")<br/>data class PersonProperties(<br/>  val name: String,<br/>  val website: URL,<br/>)</span></pre><p id="29bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">📕阅读更多</strong></p><p id="c71b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.constructor-binding" rel="noopener ugc nofollow" target="_blank">类型安全配置属性:构造函数绑定</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="66e6" class="nr mj jg bd mk ns nt nu mn nv nw nx mq km ny kn mt kp nz kq mw ks oa kt mz ob bi translated">3.惰性初始化</h1><p id="e361" class="pw-post-body-paragraph kv kw jg kx b ky nd kh la lb ne kk ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">假设你有以下<code class="fe ls lt lu lv b">application.yml</code>:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="9fee" class="oj mj jg lv b be ok ol l om on">api-credentials:<br/>  private-key-string: MIIExBvr</span></pre><p id="76e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是相应的数据类，它包含一个从<code class="fe ls lt lu lv b">privateKeyString</code>派生的惰性属性<code class="fe ls lt lu lv b">privateKey</code>:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="fbf6" class="oj mj jg lv b be ok ol l om on">@ConstructorBinding<br/>@ConfigurationProperties(prefix = "person")<br/>data class ApiCredentialsProperties(<br/>  val privateKeyString: String<br/>) {<br/>  val privateKey: PrivateKey by lazy {<br/>    convertStringToPrivateKey(privateKeyString)<br/>  }<br/>}</span></pre><p id="4f31" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">⚠️ <strong class="kx jh">有什么问题吗？</strong></p><p id="9b8e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们看到，惰性初始化可能是克服从<code class="fe ls lt lu lv b">String</code>到<code class="fe ls lt lu lv b">PrivateKey</code>的转换问题所需要的。这个问题与上面关于<a class="ae jd" href="#100f" rel="noopener ugc nofollow">弱 POJO 类型化</a>的第一部分有关，在这里我们讨论了在属性被绑定后数据转换的需要。</p><p id="33a8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们看一下为什么惰性初始化不是最佳选择的两个原因:</p><ul class=""><li id="e5bd" class="nb nc jg kx b ky kz lb lc le oo li op lm oq lq or nj nk nl bi translated">惰性初始化是危险的，因为<strong class="kx jh">延迟反馈</strong>。如果在运行时初始化<code class="fe ls lt lu lv b">privateKey</code>属性有任何问题(特别是如果有一些逻辑的话)，你的应用程序可能会崩溃，并且要修复它已经太晚了。</li><li id="ba3b" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq or nj nk nl bi translated">这两个性质<strong class="kx jh">违反了干原理</strong>因为<code class="fe ls lt lu lv b">privateKey</code>的知识是重复的。参见<em class="lr">实用程序员</em>中的<em class="lr">干违数据</em>。</li></ul><p id="a5e4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> ✅你能做什么？</strong></p><p id="5e3c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将属性直接绑定到最终类型，并使用用<code class="fe ls lt lu lv b">@ConfigurationPropertiesBinding</code>限定的自定义<code class="fe ls lt lu lv b">Converter</code>。</p><p id="0511" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个改进<code class="fe ls lt lu lv b">ApiCredentialsProperties</code> POJO 的方法。</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="b818" class="oj mj jg lv b be ok ol l om on">@ConstructorBinding<br/>@ConfigurationProperties(prefix = "person")<br/>data class ApiCredentialsProperties(<br/>  val privateKey: PrivateKey<br/>)</span></pre><p id="ed17" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">及其相应的转换器:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="73ae" class="oj mj jg lv b be ok ol l om on">@ConfigurationPropertiesBinding<br/>class PrivateKeyConverter: Converter&lt;String, PrivateKey&gt; {<br/>  override fun convert(privateKeyString: String): PrivateKey {<br/>    return convertStringToPrivateKey(privateKeyString)<br/>  }<br/>}</span></pre><p id="366b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">📕阅读更多信息</strong></p><p id="8b89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.conversion" rel="noopener ugc nofollow" target="_blank">属性转换</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="c05b" class="nr mj jg bd mk ns nt nu mn nv nw nx mq km ny kn mt kp nz kq mw ks oa kt mz ob bi translated">4.@值注释</h1><p id="d119" class="pw-post-body-paragraph kv kw jg kx b ky nd kh la lb ne kk ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">假设你有以下<code class="fe ls lt lu lv b">application.yml</code>:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="054a" class="oj mj jg lv b be ok ol l om on">person:<br/>  name: raimi</span></pre><p id="21a5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以及下列使用此属性的服务:</p><pre class="lx ly lz ma gt of lv og bn oh oi bi"><span id="cb49" class="oj mj jg lv b be ok ol l om on">@Service<br/>class GreetingService(<br/>   @Value("\${person.name}")<br/>   private val name: String<br/>) {<br/>  ...<br/>}<br/><br/>@Service<br/>class UserInfoService(<br/>   @Value("\${person.name}")<br/>   private val name: String<br/>) {<br/>  ...<br/>}</span></pre><p id="e876" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">⚠️ <strong class="kx jh">有什么问题吗？</strong></p><ul class=""><li id="c074" class="nb nc jg kx b ky kz lb lc le oo li op lm oq lq or nj nk nl bi translated"><code class="fe ls lt lu lv b">@Value</code>-在较大的代码库中或者当数据是分层的时候，带注释的属性变得<strong class="kx jh">不太容易管理</strong>。一个例子是，在重构过程中，一些属性被意外遗漏了(可能是因为 IDE 没有发现这些属性)。Spring Boot 的文档中提到了这一点:<em class="lr">“使用</em> <code class="fe ls lt lu lv b"><em class="lr">@Value("${property}")</em></code> <em class="lr">注释来注入配置属性有时会很麻烦，尤其是当您处理多个属性或者您的数据本质上是分层的时候。”</em></li><li id="389e" class="nb nc jg kx b ky nm lb nn le no li np lm nq lq or nj nk nl bi translated">复制属性的类型违反了 DRY 原则。这里我们可以看到<code class="fe ls lt lu lv b">person.name</code>被用在两个服务中，每次都重新声明它的<code class="fe ls lt lu lv b">String</code>类型和表达式。</li></ul><p id="e2f5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">✅你能做什么？</p><p id="0020" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要使用<code class="fe ls lt lu lv b">@Value</code>注释。请改用类型安全的配置属性。这当然不适用于 OpenFeign 客户端。</p><p id="44bb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">📕阅读更多</strong></p><p id="fc85" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties" rel="noopener ugc nofollow" target="_blank">类型安全配置属性</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="661a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">伙计们，现在就到这里吧！欢迎在下面的评论中分享你的观点。</p><p id="53f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我发表关于人工智能、机器学习、编程语言、网络框架和生产力的文章。</p><p id="5aa0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">如果你喜欢阅读更多关于 web 框架的内容，你可以通过我的推荐链接</em> <a class="ae jd" href="https://remykarem.medium.com/subscribe" rel="noopener"> <em class="lr">订阅</em> </a> <em class="lr">随时接收更新或者</em> <a class="ae jd" href="https://remykarem.medium.com/membership" rel="noopener"> <em class="lr">注册</em> </a> <em class="lr">！请注意，您的会员费的一部分将作为介绍费分摊给我。</em></p></div></div>    
</body>
</html>