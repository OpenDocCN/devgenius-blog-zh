<html>
<head>
<title>Ruby: Object Lifecycle (2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby:对象生命周期(2)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-object-lifecycle-2-f906844d967b?source=collection_archive---------3-----------------------#2020-12-23">https://blog.devgenius.io/ruby-object-lifecycle-2-f906844d967b?source=collection_archive---------3-----------------------#2020-12-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c30fd3b753a00142d0be110f0cd39ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TNWAi0mP0I4aDp3M"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@jasondeblooisphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·D</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9a25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继续<a class="ae jz" href="https://lendeta.medium.com/ruby-object-lifecycle-1-a29a62615b97" rel="noopener">之前关于Ruby中对象生命周期的帖子</a>。我将从众多可用的方法中选择一种来讲解变量和对象的基本要点。</p><h1 id="3cd1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">变量</h1><p id="8391" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Ruby中有四种类型的变量:类、实例、局部和全局变量。为了简化它们之间的区别，我将分享这张图表，因为它帮助我理解了四种不同的类型。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/b0cb9043c90e3f4af3027a6382c2d340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4n2LZLZLf6DA1uJ_.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自:<a class="ae jz" href="https://www.javatpoint.com/ruby-variables" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/ruby-variables</a></figcaption></figure><p id="ea1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">跟踪任何变量的一种方法是将它们的行为存储在一个类变量中。如上所述，类变量可以被类中的所有后代访问和共享，并且在每个实例中都将被更改。它们有时也被称为静态变量或静态方法。实例变量也可以从方法中的类的任何实例访问，但只能有限地访问类的实例。</p><p id="1a45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">注意</em>当一个类变量或实例变量未初始化时，它将返回一个<strong class="kc io">错误</strong>或一个<strong class="kc io">空值</strong>。一定要确保你将在你的类中共享的变量已经初始化了！</p><h1 id="15ed" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">目标</h1><p id="3dfc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Ruby中的一切都是对象。甚至我们分配给一个对象的方法对所有类都是可用的(除非我们明确地告诉Ruby它不是)。一个对象甚至可以调用自己。在前一篇文章中，我们创建了一个对象的新实例，并赋予它独特的属性。在特定条件下，您也可以销毁对象的实例。为了证明这一点，让我们举一个例子:</p><pre class="mc md me mf gt mh mi mj mk aw ml bi"><span id="f91b" class="mm kz in mi b gy mn mo l mp mq">class Kirby<br/>attr_accessor :hp :damage</span><span id="6271" class="mm kz in mi b gy mr mo l mp mq">def initialize(hp, damage)<br/>  @hp = hp<br/>  @damage = damage<br/>end</span><span id="e837" class="mm kz in mi b gy mr mo l mp mq">def uses_smash_ultimate<br/>  puts self<br/> end <br/>end</span><span id="c18a" class="mm kz in mi b gy mr mo l mp mq">object = Kirby.new(HP=100, Damage=10)</span><span id="2d50" class="mm kz in mi b gy mr mo l mp mq">=&gt; :uses_smash_ultimate</span></pre><p id="74f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在销毁过程中会是什么样子？</p><pre class="mc md me mf gt mh mi mj mk aw ml bi"><span id="71e2" class="mm kz in mi b gy mn mo l mp mq">class Kirby<br/>attr_accessor :hp :damage</span><span id="0b16" class="mm kz in mi b gy mr mo l mp mq">def initialize(hp, damage)<br/>  @hp = hp<br/>  @damage = damage<br/> end</span><span id="e81d" class="mm kz in mi b gy mr mo l mp mq">def uses_smash_ultimate<br/>  puts self<br/> end</span><span id="a924" class="mm kz in mi b gy mr mo l mp mq">def kirby_is_still_alive<br/>  if self.hp &gt; 0<br/>  end <br/> end</span><span id="ac23" class="mm kz in mi b gy mr mo l mp mq">def ko<br/>  self.destroy<br/> end</span><span id="c848" class="mm kz in mi b gy mr mo l mp mq">def enemy_defeats_kirby<br/>  hp = 0<br/> end</span><span id="81bf" class="mm kz in mi b gy mr mo l mp mq">def kirby_loses<br/>  if enemy_defeats_kirby<br/>   ko<br/>  else <br/>   kirby_is_still_alive<br/>  end <br/> end</span><span id="b15c" class="mm kz in mi b gy mr mo l mp mq">end</span></pre><p id="7529" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，我们定义了Kirby的失败是有条件的。一个实例被摧毁，如果敌人通过留下0点生命来击败科比，否则他们仍然活着。</p><p id="0d31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以在Ruby中使用的方法之一是"。发送”。与call方法的区别在于，它不定义对象，只给它一个消息。然而，Send确实定义了一个对象，也可以在私有方法中使用。Ruby使用“.”将参数传递给这些方法变得很方便。发送”。此外，紧接在第一个参数之后发送的参数将成为传递给该方法的参数。</p><pre class="mc md me mf gt mh mi mj mk aw ml bi"><span id="30ee" class="mm kz in mi b gy mn mo l mp mq">class Unlockable<br/>attr_accessor :name</span><span id="7728" class="mm kz in mi b gy mr mo l mp mq">def initialize(unlockable, name)<br/>   @unlockable = unlockable<br/>   @name = name<br/> end</span><span id="e7c4" class="mm kz in mi b gy mr mo l mp mq">def completed_challenge(name)<br/>   "New challenger, #{name}!"<br/> end<br/> <br/> def unlocked(unlocked, argument = nil)<br/>   if unlockable == new_challenger<br/>    @unlockable.send(unlocked)<br/>   else<br/>    unlockable == nil <br/>   end <br/> end</span><span id="9c15" class="mm kz in mi b gy mr mo l mp mq">end</span></pre><p id="4adb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，所有方法都是公共的，除非你明确告诉Ruby它们是私有的。private之后的任何实例方法都成为私有方法。但是有了”。send "方法，我们可以访问私有方法。</p><pre class="mc md me mf gt mh mi mj mk aw ml bi"><span id="76dd" class="mm kz in mi b gy mn mo l mp mq">class Unlockable</span><span id="fac0" class="mm kz in mi b gy mr mo l mp mq">attr_accessor :name<br/>private :name</span><span id="8273" class="mm kz in mi b gy mr mo l mp mq">def initialize(unlockable, name)<br/>   @unlockable = unlockable<br/>   @name = name<br/> end</span><span id="b23d" class="mm kz in mi b gy mr mo l mp mq">def unlocked(unlocked, argument = nil)<br/>   if unlockable == completed_challenge<br/>    @unlockable.send(unlocked)<br/>   else<br/>    unlockable == nil <br/>   end <br/> end</span><span id="925c" class="mm kz in mi b gy mr mo l mp mq">private</span><span id="16c0" class="mm kz in mi b gy mr mo l mp mq">def completed_challenge(name)<br/>   "You got #{name}!"<br/> end</span><span id="f132" class="mm kz in mi b gy mr mo l mp mq">end</span><span id="207e" class="mm kz in mi b gy mr mo l mp mq">object1 = Unlockable.new("Challenger", "Sephiroth")</span><span id="fa4f" class="mm kz in mi b gy mr mo l mp mq"># "You got Sephiroth!"</span></pre><p id="ee90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然在可以通过“@”访问的私有方法中声明名称可能有些奇怪，但在以后修改它而不必替换类实例会很有用。</p><p id="e783" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这能帮助你更多的理解对象和变量。虽然我还没有涵盖大部分内容，但我将在未来继续撰写第3部分。度过一个美好的假期周末，继续编码！</p><p id="3a08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">_____________________________________________________________</p><h1 id="e2ed" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">社会联系</h1><p id="1b31" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://www.linkedin.com/in/shirlend" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p><p id="c019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.github.com/Ro5hi" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="8566" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.twitter.com/len_deta" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="63d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.instagram.com/_sceptral_" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p><p id="9d28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.youtube.com/channel/UC_0nik4oj1T1Q160XVr0ZlA?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p></div></div>    
</body>
</html>