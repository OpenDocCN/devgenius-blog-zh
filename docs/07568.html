<html>
<head>
<title>Django admin dynamic Inline positioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django admin 动态内联定位</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-admin-dynamic-inline-positioning-7208596479ce?source=collection_archive---------4-----------------------#2022-04-06">https://blog.devgenius.io/django-admin-dynamic-inline-positioning-7208596479ce?source=collection_archive---------4-----------------------#2022-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c0740fbb0a746ae04d6af657c35c689d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rp7UPeRsZqBkRtH3B_Qm5Q.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">智能快速的解决方案</figcaption></figure><p id="3c57" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最近，我收到了一个客户关于我们 Django 项目的有趣请求。<br/>他问是否可以在 Django 管理面板的其他字段上方显示一个内嵌组件。</p><p id="4e26" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一开始我想，这应该没有任何问题。<br/>尽管除了在项目中安装另一个电池之外没有简单的解决方案。我的直觉告诉我，有另一种方法可以解决这个问题。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="13fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我找到的第一个<a class="ae le" href="https://linevi.ch/en/django-inline-in-fieldset.html" rel="noopener ugc nofollow" target="_blank">解</a>是 2017 年的。对于这么简单的任务来说，它的代码太多了。</p><p id="86eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的首席执行程序员马克西姆·达尼洛夫找到了一个非常简单的解决方案。大约一个月前，他用俄语在网上发表了他的作品。</p><p id="ecf1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我想与说英语的 Django 社区分享这些想法，以帮助其他人简化他们的代码。对于这样一个乍看起来“简单”的问题，它可能会派上用场。</p><p id="8ff1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">长话短说，让我们深入代码:</p><p id="07ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设您正在构建一个电子商务项目。您有一个与<code class="fe lf lg lh li b">ImageModel</code>有 O2M 关系的<code class="fe lf lg lh li b">ProductModel</code>。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">models.py</figcaption></figure><p id="1d2e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于给定的模型，您还需要<code class="fe lf lg lh li b">ModelAdmins</code>。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">管理. py</figcaption></figure><p id="1a7f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们创建一个简单的内联来放入我们的<code class="fe lf lg lh li b">ProductModelAdmin</code>。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">管理. py</figcaption></figure><p id="812f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">到目前为止，我们有两个简单的模型和基本的带 T5 的 T4。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/830b0ccfbcab22157407f786b66b2c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*XMpNJ9QOlnhvh0iuUCwAlg.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带内嵌的普通管理表单</figcaption></figure><p id="91d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们应该如何在<code class="fe lf lg lh li b">ProductModelAdmin</code>的两个字段之上或之间挤压内联？</p><p id="d9d0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我想，你对<code class="fe lf lg lh li b">ModelAdminForm</code>中<a class="ae le" href="https://docs.djangoproject.com/en/4.0/ref/contrib/admin/#django.contrib.admin.ModelAdmin.readonly_fields" rel="noopener ugc nofollow" target="_blank">增加字段</a>的概念很熟悉。您可以在<code class="fe lf lg lh li b">ModelAdmin</code>中创建一个方法，将表单中方法的响应显示为只读字段。<br/>记住，<code class="fe lf lg lh li b">ModelAdmin</code>的渲染顺序会先创建<code class="fe lf lg lh li b">InlineModels</code>，然后渲染<code class="fe lf lg lh li b">AdminForm</code>，再渲染<code class="fe lf lg lh li b">InlineForms</code>。</p><p id="fa27" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以用它来重新排列内联和字段的顺序。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">管理. py</figcaption></figure><p id="fa43" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们使用<code class="fe lf lg lh li b">render_change_form</code>来获得对象<code class="fe lf lg lh li b">request</code>和<code class="fe lf lg lh li b">response</code>。<br/>我们使用<code class="fe lf lg lh li b">image_inline</code>方法中的那些对象从<code class="fe lf lg lh li b">inline_admin_formsets</code>列表中取出一个还未处理的<code class="fe lf lg lh li b">inline_formset</code>，并渲染<code class="fe lf lg lh li b">InlineFormset</code>。</p><p id="46a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<code class="fe lf lg lh li b">change_form</code>渲染之后，剩余的<code class="fe lf lg lh li b">inline_admin_formsets</code>将被渲染，如果<code class="fe lf lg lh li b">ModelAdmin</code>还有一些的话。</p><p id="6bb2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们可以用方法<code class="fe lf lg lh li b">image_inline</code>来确定我们的<code class="fe lf lg lh li b">InlineFormset</code>的位置。代码片段在上面时，内联元素将被放置在所有其他字段之上。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/74462ddc4770b9a67f4314073d5d0813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*muQtF-XXUcXq1F0brcCADA.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">顶部嵌入</figcaption></figure><p id="85dd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们以这种方式重新排列字段时，行内显示在字段之间:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">管理. py</figcaption></figure><p id="c289" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当然，Django admin 在方法名称的内联前面添加了一个标签，但是这可以通过简单的 CSS 在<code class="fe lf lg lh li b">ProductModelAdmin</code>的<code class="fe lf lg lh li b">Media</code>属性中删除。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/e563833863d1ea9934d95398c4f33e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*rSbtlOPokkOeURpzDjhAKA.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">模型字段之间的内联</figcaption></figure><blockquote class="lr ls lt"><p id="40c8" class="jz ka lu kb b kc kd ke kf kg kh ki kj lv kl km kn lw kp kq kr lx kt ku kv kw ig bi translated">这个解决方案有一个致命的错误！每个 Django ModelAdmin 都是 singelton，这就是为什么我们不能在 <code class="fe lf lg lh li b"><strong class="kb io">render_change_form</strong></code> <strong class="kb io">中使用 ModelAdmin.self 作为容器！</strong></p></blockquote><p id="6634" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">可以用 Mixin 改变 ModelAdmins singleton 的行为，保持与 Djangos GCBV 的概念一致。在我的下一篇文章中，我们将进一步研究它。</p><p id="07cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这仅仅意味着，我们不能使用<code class="fe lf lg lh li b">ModelAdmin</code>的实例作为容器来保存我们的<code class="fe lf lg lh li b">request</code>和<code class="fe lf lg lh li b">response</code>。<br/>解决方案是将这些对象保存在<code class="fe lf lg lh li b">AdminForm</code>实例中。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">如果您没有解决 ModelAdmin singleton 问题，这个代码片段是有效的。</figcaption></figure><p id="a9db" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">参数<code class="fe lf lg lh li b">obj</code>并不总是在<code class="fe lf lg lh li b">render_change_form</code>中给出(即添加新对象)。这就是为什么我们必须从<code class="fe lf lg lh li b">ModelForm</code>中获取它，它被包裹在<code class="fe lf lg lh li b">AdminForm</code>中。</p><p id="ee88" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们可以将请求和响应设置为<code class="fe lf lg lh li b">ModelForm</code>实例的属性，并在<code class="fe lf lg lh li b">image_inline</code>中使用它们。</p><h2 id="a9d4" class="ly lz in bd ma mb mc dn md me mf dp mg kk mh mi mj ko mk ml mm ks mn mo mp mq bi translated">综上所述:你不必为了解决一个简单的问题而在你的项目中安装另一个电池。有时候你需要深入挖掘你所使用的框架，找到一个简单、快捷的解决方案。</h2></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="7862" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我要感谢 wPsoft 的实习生 Martin Achenrainer 对本文的贡献和翻译。</p></div></div>    
</body>
</html>