<html>
<head>
<title>Tech Blog #5: Automatically sync multiple repositories versions using GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">技术博客#5:使用 GitHub 动作自动同步多个存储库版本</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tech-blog-5-automatically-sync-multiple-repositories-versions-using-github-actions-ec070cf908ea?source=collection_archive---------3-----------------------#2022-12-09">https://blog.devgenius.io/tech-blog-5-automatically-sync-multiple-repositories-versions-using-github-actions-ec070cf908ea?source=collection_archive---------3-----------------------#2022-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bc37" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Coner Murphy，开发团队 Salable</h2></div><p id="a689" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 Salable 中，我们有一个定制的 JavaScript 库用于我们的价格表，在一个高层次上，这个 JS 库负责在用户网站上显示产品的各种价格表。这个库被版本化并发布到我们的 CDN 上，以在我们维护的各种框架/库包装包中使用，比如我们的<a class="ae ky" href="https://www.npmjs.com/package/@salable/pricing-table-react" rel="noopener ugc nofollow" target="_blank"> React one。</a>然后，这些包装包就可以在使用各自技术的用户应用程序中使用。</p><p id="92e5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后包装软件包被单独版本化并发布到 NPM 供人们安装。为了确保包装包始终使用核心库的最新 CDN 版本，我们在每次核心库版本升级时都会发布每个包装包的新版本，以确保它们保持一致。</p><p id="cb3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这并不太麻烦，因为我们已经在核心库和包装器包中配置了<code class="fe kz la lb lc b">semantic-release</code>包。<code class="fe kz la lb lc b">semantic-release</code>为我们处理所有版本控制和发布工作流程；我们需要做的唯一手动部分是更新包装包中正在使用的 CDN 版本，并将其 PR 到主分支中，以触发使用最新 CDN 版本的新版本包装包发布。</p><p id="8dac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我说这不是太多的麻烦，但我们是开发人员，开发人员天生懒惰，喜欢自动化的东西。而且，由于这种情况是自动化的首要条件，我们决定将其自动化。但是撇开懒惰不谈，有很好的理由来自动化这个工作流程。</p><ol class=""><li id="0bdb" class="ld le in ke b kf kg ki kj kl lf kp lg kt lh kx li lj lk ll bi translated">我们希望扩展包装器包的数量，从一个(React)扩展到包括其他大型库/框架，这样随着我们的扩展，手动更新所有这些将花费越来越多的时间——这些时间可以花在其他更有价值的活动上。</li><li id="cc4c" class="ld le in ke b kf lm ki ln kl lo kp lp kt lq kx li lj lk ll bi translated">人类会犯错误，我们可能会忘记在更新时删除包装包，或者在维护多个包装包时完全忽略其中一个。</li></ol><p id="60ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，对这类工作的人为干预越少，对每个人都越好。</p><h1 id="fc2c" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">这个计划</h1><p id="c1fe" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">我拟定了一个计划，使用 GitHub Actions 自动检查 GitHub 上核心库的最新发布版本，并将其与运行该动作的包装包的<code class="fe kz la lb lc b">main</code>分支上当前使用的库版本进行比较。</p><p id="f3b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果版本匹配，我们什么也不做。但是，如果最新的核心库发布版本高于在最新的包装包中使用的版本，那么我们需要更新包装包并触发到 NPM 的新版本。</p><p id="8ea2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的包装器包中，我们有一个根<code class="fe kz la lb lc b">constant.ts</code>文件，它包含我们使用的核心库包版本。它保存在一个单独的文件中，以便在 GitHub 操作中使用 bash 命令进行编辑。</p><p id="162f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我意识到这可能有点罗嗦和复杂，所以这里有一个流程图，解释了在每个包装器包库中的 CRON 作业上运行 GitHub 动作时发生的事情。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/16f1fc484b1741b4a9b66add0fdc0c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PEYbR5_XCpjlpxktHkNxZw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">包装包装流程</figcaption></figure><p id="176d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们需要做的就是添加我们的 GitHub 动作！下面是我们 GitHub 操作的全部代码，以及解释每个步骤的注释。我们将这段代码添加到<code class="fe kz la lb lc b">./.github/workflows/update-version.yml</code>文件中，并将其写入<code class="fe kz la lb lc b">main</code>分支。</p><pre class="mp mq mr ms gt ne lc nf bn ng nh bi"><span id="c349" class="ni ls in lc b be nj nk l nl nm">name: Update Version<br/><br/># Run this action every hour on the hour.<br/>on:<br/>  schedule:<br/>    - cron: "0 * * * *"<br/><br/>jobs:<br/>  update-version:<br/>    name: Update Version<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    <br/>      # Check out the latest code on `main`<br/>      - uses: actions/checkout@v2<br/>        with:<br/>          token: ${{ secrets.GH_TOKEN }}<br/>          fetch-depth: 0<br/><br/>      # Fetch the latest GitHub release of the core library repository<br/>      - name: Get latest release<br/>        uses: rez0n/actions-github-release@main<br/>        id: version<br/>        env:<br/>          token: ${{ secrets.GH_TOKEN }}<br/>          repository: "Salable/pricing-table-js-lib"<br/>          type: "latest"<br/><br/>      # Format the latest release version from above into 'x.x.x' format<br/>      - name: Format latest version<br/>        id: latest<br/>        run: "version='${{ steps.version.outputs.release }}' &amp;&amp; echo ::set-output name=version::${version/'v'/''} &amp;&amp; mkdir params &amp;&amp; echo ${version/'v'/''} &gt; params/VERSION"<br/><br/>      # Get the current version used in the wrapper package from the root file containing it.<br/>      - name: Read currentVersion from constants.ts file<br/>        id: currentVersion<br/>        run: echo "::set-output name=version::$(head -1 ./constants.ts | awk '{ print $5; }' | sed "s/'//g" | sed 's/.$//')"<br/><br/>      # Compare the versions and update the constants file to the new version if required.<br/>      - name: Compare versions<br/>        if: steps.latest.outputs.version &gt; steps.currentVersion.outputs.version<br/>        run: echo "$(sed -i -e 's/${{steps.currentVersion.outputs.version}}/${{steps.latest.outputs.version}}/g' ./constants.ts)"<br/><br/>      # Commit the change and push to `main` if version has changed.<br/>      - name: Push changes<br/>        if: steps.latest.outputs.version &gt; steps.currentVersion.outputs.version<br/>        run: |<br/>          git config --global user.name 'github-actions'<br/>          git config --global user.email 'github-actions@github.com'<br/>          git commit -am "feat: bumped core library version to ${{steps.latest.outputs.version}}"<br/>          git push</span></pre><p id="1607" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在动作合并到了<code class="fe kz la lb lc b">main</code>分支中，它将由 CRON 作业每小时触发一次，以检查最新版本是否相互偏离，如果是，更新包装器包的常量文件以使用核心库的最新版本。</p><p id="eb16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我们讨论了为什么你可能想要使用 GitHub 动作来保持两个库同步，以及如何使用定制的 GitHub 动作工作流来做到这一点。我希望这篇文章对你有所帮助。</p></div></div>    
</body>
</html>