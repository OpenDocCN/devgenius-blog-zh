<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/python-detailed-explanation-of-variables-a0d7e9392484?source=collection_archive---------40-----------------------#2020-06-14">https://blog.devgenius.io/python-detailed-explanation-of-variables-a0d7e9392484?source=collection_archive---------40-----------------------#2020-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d82678d946038ba01aa0de8c2c4507ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4JkrYLvL1bohQYdK.png"/></div></div></figure><p id="9582" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们都知道Python是一种非常灵活的语言，如果它不是你第一次学习的编程语言，你会发现它总是给你各种惊喜。</p><p id="fb0c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我以前是一名Java程序员，当我学习Python的时候，每当我取得一点进步，我总有一种新的世界正在为我打开大门的感觉。</p><p id="2050" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">今天我要分享一些Python中变量的基本语法。</p><h2 id="1f6a" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">解包元组/列表</h2><p id="326d" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">首先，Python允许我们同时给几个值赋值。比如在C++或者Java中，如果我们要交换两个变量。我们必须使用第三个变量作为媒介。代码是这样的:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="de89" class="jv jw iy ky b gy lc ld l le lf"># swap a, b<br/>c = a<br/>a = b<br/>b = c</span></pre><p id="7ee6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果不使用第三个变量，当我们把b赋给a时，a会失去原点值，b得不到。所以我们需要先将它的值存储在一个“缓存”中。因为Python允许多变量赋值，所以我们可以在一行代码中完成:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1c1c" class="jv jw iy ky b gy lc ld l le lf">a, b = b, a</span></pre><p id="7d11" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python解释器会确保结果的正确性，此外，Python还支持元组和列表的解包操作。</p><p id="9a2e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">例如，假设我们有一个列表:[1，2]。获取这些值的常用方法如下:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4d1a" class="jv jw iy ky b gy lc ld l le lf">l = [1, 2]<br/>a, b = l[0], l[1]</span></pre><p id="ba18" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">实际上，这是不必要的，因为当Python在右侧找到一个list/tuple时，它会自动解包并将元素分配给左侧的变量。上面的代码可以简化为:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2f3a" class="jv jw iy ky b gy lc ld l le lf">l = [1, 2]<br/>a, b = l</span></pre><p id="72cd" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以在for循环中解包一个列表。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="bd23" class="jv jw iy ky b gy lc ld l le lf">l = [[1, 2], [3, 4], [5, 6]]<br/>for i, j in l:<br/>    print(i, j)</span></pre><p id="d3cb" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">下面代码的打印结果是什么？</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a804" class="jv jw iy ky b gy lc ld l le lf">a, b, c = 1, 3, (4, 5)<br/>print(c)</span></pre><p id="8ccf" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们会得到一个错误，还是只有一个4？不，我们将得到(4，5)。</p><p id="932d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">另外一种方式，Python会把整个tuple赋给c，而且，像这样的情况，Python也能给出正确的结果。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="673f" class="jv jw iy ky b gy lc ld l le lf">a, b, (c, d), e = 1, 3, (4, 5), 7<br/>print(c, d)</span></pre><h2 id="31c2" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">强调</h2><p id="2a9e" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">当我们使用Python解析复杂数据时，经常会在源数据中发现一些无用的字段。为了避免删除未使用的变量来匹配它们，我们可以使用下划线符号作为占位符，然后对应的字段将被跳过。</p><p id="3b34" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">例如，假设源数据的格式为:1，3，(4，5)，7。但是我们只需要中间的元组，我们可以这样接收它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4ad3" class="jv jw iy ky b gy lc ld l le lf">_, _, (c, d), _ = 1, 3, (4, 5), 7</span></pre><p id="5489" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当我们迭代一个字典时，我们可能不关心字典的键，只需要值。我们也可以使用下划线来跳过键。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7251" class="jv jw iy ky b gy lc ld l le lf">a = {}<br/>for _, v in a.items():<br/>    print(v)</span></pre><h2 id="594e" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">压缩变量</h2><p id="0e05" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">变量可以解压缩，也可以压缩。想象一个场景，你有一批衡量产品的数据。除了产品的大小，我们还有产品的名称，生产日期和其他一些属性。</p><p id="8741" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">假设现在我们想要解析这些数据，并将产品尺寸特性存储到数组中。我们能做什么？</p><p id="cb01" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">例如，有一行数据:车轮，工厂，1，3，4，5，6，2020–02–02</p><p id="a6c9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python给出了一个解决方案，使用解压缩符号*。我们可以这样解析数据:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="764b" class="jv jw iy ky b gy lc ld l le lf">data = ['wheel', 'factory1', 3, 4, 5, 6, '2020-02-02']<br/>name, factory, *inch, date = data<br/>print(inch)</span></pre><p id="f39d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">最后，我们打印出inch=[3，4，5，6]，这意味着通过使用*，我们成功地将中间部分分配给了一个数组。这个操作非常重要，因为我们可能有不同数量的尺寸特征。如果我们实现了这个函数，处理这个问题就不容易了。当使用' * '符号时，我们可以很容易地解决它。</p><h2 id="a7c4" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">将它们结合在一起</h2><p id="c92f" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">到目前为止，我们已经介绍了下划线和压缩符号的用法。我们能把这两种记法结合起来得到任意数量的缺失值吗？</p><p id="f5c8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当然可以。让我们使用之前的例子，我们稍微修改一下代码，跳过数据中的所有大小特征。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="3c08" class="jv jw iy ky b gy lc ld l le lf">data = ['wheel', 'factory1', 3, 4, 5, 6, '2020-02-02']<br/>name, factory, *_, date = data</span></pre><p id="5f55" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">你可以自己试一下，也可以打印存储在' _ '中的值。</p><h2 id="f18a" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">其他用法</h2><p id="68d3" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">在Python中，我们可以使用' * <em class="lg"> args '和'</em> *kw '来获取函数中的各种参数。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="410d" class="jv jw iy ky b gy lc ld l le lf">def func(*args, **kw):<br/>    pass</span></pre><p id="b9c5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在代码中，“args”意味着一个参数数组，而“kw”意味着一个参数字典。除了' args '前的'【T2 '，' kw '前的' * '表示解压符号。</p><p id="1d71" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以用它们来解压数组和字典。让我们看看其他例子。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="813b" class="jv jw iy ky b gy lc ld l le lf">a = [1, 3, 5]</span></pre><p id="d194" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这里来了一个问题，运行' print(a)'和' print(*a)'有什么区别？</p><p id="155d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果你试一试，你会发现‘print(a)’的结果是[1，3，5]，‘print(* a)’的结果是1，3，5。换句话说，在前面的用法中，“a”被视为一个数组，而在后面的用法中，数组“a”已经被解压缩，Python会单独打印其中的元素。</p><p id="5df9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">所以我们也可以用' **kw '来解压字典。但是如果你尝试它，你会得到一个错误。因为该操作只允许传递参数。</p><p id="b5ef" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">现在很容易理解为什么我们可以通过使用' *args '和' **kw '来传递任何类型的参数。因为前一个表示位置参数，后一个表示关键字参数。Python规定关键字参数后面必须跟位置参数，这就是为什么我们可以使用' *args '和' **kw '来传递任何类型的参数。</p><p id="93e7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">今天的文章到此为止，内容简单但必要，如果你熟悉它，它将帮助你做好编码。</p><p id="20d2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">祝您Python之旅愉快。</p></div></div>    
</body>
</html>