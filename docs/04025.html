<html>
<head>
<title>Spring Boot CRUD Application Example with MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB的Spring Boot CRUD应用示例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-crud-application-example-with-mongodb-7ae133da8ad0?source=collection_archive---------2-----------------------#2021-01-17">https://blog.devgenius.io/spring-boot-crud-application-example-with-mongodb-7ae133da8ad0?source=collection_archive---------2-----------------------#2021-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/78a988b5f9c179a949ebd414f26f1058.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*56N7nxi1d8Ve-A4u"/></div></figure><h1 id="1ebd" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">介绍</h1><p id="e05a" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在这篇文章中，我将展示如何使用Spring Boot通过MongoDB构建一个简单的CRUD REST应用程序示例。我知道你的第一个问题会是什么是MongoDB？</p><h1 id="046a" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">什么是MongoDB？</h1><p id="fdb0" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">MongoDB是一个NoSQL文档数据库。在这个数据库中，记录是行为很像JSON对象的文档。所以大多是键值对。</p><p id="326a" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">使用MongoDB作为数据库的主要优势是:</p><ul class=""><li id="8e14" class="lt lu in kr b ks lo kw lp la lv le lw li lx lm ly lz ma mb bi translated">MongoDB是一个无模式文档数据库。一个集合包含不同的文档。</li><li id="af85" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">单个对象的结构是清楚的。</li><li id="f7f7" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">没有复杂的连接</li><li id="1763" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">深度查询能力。</li><li id="e3ef" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">易于横向扩展</li></ul><p id="7bcb" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">以下是在企业应用程序中使用MongoDB或类似的NoSQL数据库的几个原因:</p><ul class=""><li id="bdc3" class="lt lu in kr b ks lo kw lp la lv le lw li lx lm ly lz ma mb bi translated">如果您需要更快的JSON风格的数据检索</li><li id="e79d" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">很容易在属性上添加索引</li><li id="25f7" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">出于<a class="ae ln" href="https://blog.yugabyte.com/how-data-sharding-works-in-a-distributed-sql-database/#:~:text=Sharding%20is%20the%20process%20of,portion%20of%20the%20overall%20workload." rel="noopener ugc nofollow" target="_blank">分片</a>的目的，分片是跨多台机器存储数据记录的过程。当跨多台机器存储时，您通常会根据一些标准对这些数据进行分区。</li><li id="e384" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">快速就地更新</li><li id="b73a" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">更容易查询</li></ul><h1 id="6597" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">先决条件</h1><p id="a44a" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">要创建这个示例应用程序，您需要:</p><ul class=""><li id="6059" class="lt lu in kr b ks lo kw lp la lv le lw li lx lm ly lz ma mb bi translated">Spring Boot版本2.4.1</li><li id="4bc4" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">MongoDB</li><li id="6ffb" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">格拉德勒</li><li id="9929" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">Java版本8</li></ul><h1 id="3fd0" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Spring Boot CRUD应用程序</h1><p id="820b" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">作为这篇文章的一部分，我将构建一个REST CRUD应用程序。这包括</p><ul class=""><li id="c641" class="lt lu in kr b ks lo kw lp la lv le lw li lx lm ly lz ma mb bi translated">一个图书馆——我们将在我们的MongoDB数据库中创建一个收藏库<code class="fe mh mi mj mk b">library</code>。</li><li id="acaf" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">我们将按作者存放书籍的图书馆</li><li id="58b1" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">用户可以调用REST API按作者检索图书</li><li id="cc54" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">用户可以调用REST API来检索图书馆中的所有书籍</li><li id="70b9" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">POST — /v1/mongodbapp/books —将图书添加到库中</li><li id="d8e3" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">GET — /v1/mongodbapp/books —从库中检索所有的书籍</li><li id="e057" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">GET — /v1/mongodbapp/books/id —检索特定的图书</li><li id="07da" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">DELETE—/v1/mongodbapp/books/id—从库中删除一本书</li></ul><h1 id="d4ce" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">如何在MongoDB中使用Spring Boot CRUD</h1><p id="a730" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">为了开始创建这个应用程序，我们将使用gradle来处理我们的依赖项并构建这个应用程序。在我们的Spring Boot应用程序中添加以下依赖项:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a38b" class="mt js in mk b gy mu mv l mw mx">implementation 'org.springframework.boot:spring-boot-starter-data-mongodb' <br/>implementation 'org.springframework.boot:spring-boot-starter-web'</span></pre><p id="d455" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">一旦我们有了这些依赖项，我们将能够连接到mongo db数据库。但是我们仍然需要添加数据库的位置。我们将在<code class="fe mh mi mj mk b">application.properties</code>文件中添加所需的属性，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="03bb" class="mt js in mk b gy mu mv l mw mx">spring.data.mongodb.host = localhost <br/>spring.data.mongodb.port=27017 <br/>spring.data.mongodb.database=library</span></pre><p id="7cb2" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">这将允许我们在端口<code class="fe mh mi mj mk b">27017</code>上连接到运行在主机<code class="fe mh mi mj mk b">localhost</code>上的MongoDB数据库，数据库模式是<code class="fe mh mi mj mk b">library</code>。</p><h1 id="82be" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">定义数据模型</h1><p id="934d" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">作为图书馆的一部分，我们需要书籍。所以我们的主要数据对象是书。这个数据模型将包括书名、作者和ISBN。这将如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1af6" class="mt js in mk b gy mu mv l mw mx">package com.betterjavacode.mongodbdemo.mongodbapp.models; </span><span id="f83e" class="mt js in mk b gy my mv l mw mx">import org.springframework.data.annotation.Id; <br/>import org.springframework.data.mongodb.core.mapping.Document; </span><span id="a147" class="mt js in mk b gy my mv l mw mx">@Document(collection = "books") <br/>public class Book { <br/>@Id <br/>private String id; <br/>private String title; <br/>private String author; <br/>private String isbn; <br/>public Book() { } <br/>public Book(String title, String author, String isbn) <br/>{ <br/>    this.title = title; <br/>    this.author = author;  <br/>    this.isbn = isbn; <br/>} </span><span id="f270" class="mt js in mk b gy my mv l mw mx">public String getId () <br/>{ <br/>  return id; <br/>} </span><span id="9884" class="mt js in mk b gy my mv l mw mx">public void setId (String id) <br/>{ <br/>   this.id = id; <br/>} </span><span id="b364" class="mt js in mk b gy my mv l mw mx">public String getTitle () <br/>{ <br/>  return title; <br/>} </span><span id="4ad8" class="mt js in mk b gy my mv l mw mx">public void setTitle (String title) <br/>{ <br/>   this.title = title; <br/>} </span><span id="0367" class="mt js in mk b gy my mv l mw mx">public String getAuthor () <br/>{ <br/>   return author; <br/>} </span><span id="da28" class="mt js in mk b gy my mv l mw mx">public void setAuthor (String author) <br/>{ <br/>  this.author = author; <br/>} </span><span id="66f2" class="mt js in mk b gy my mv l mw mx">public String getIsbn () <br/>{ <br/>  return isbn; <br/>} </span><span id="dbbd" class="mt js in mk b gy my mv l mw mx">public void setIsbn (String isbn) <br/>{ <br/>  this.isbn = isbn; <br/>} <br/>}</span></pre><p id="c085" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">由于我们使用的是MongoDB，<code class="fe mh mi mj mk b">@Document</code>注释覆盖了集合<code class="fe mh mi mj mk b">books</code>。</p><h1 id="c221" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">添加存储库接口</h1><p id="6411" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们需要一个存储库接口来获取、保存或删除我们的book对象。在<code class="fe mh mi mj mk b">repositories</code>包中，我们将增加<code class="fe mh mi mj mk b">BookRepository</code>接口</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="17e0" class="mt js in mk b gy mu mv l mw mx">package com.betterjavacode.mongodbdemo.mongodbapp.repositories; </span><span id="a8d3" class="mt js in mk b gy my mv l mw mx">import com.betterjavacode.mongodbdemo.mongodbapp.models.Book; <br/>import org.springframework.data.mongodb.repository.MongoRepository; import java.util.List; </span><span id="c75b" class="mt js in mk b gy my mv l mw mx">public interface BookRepository extends MongoRepository&lt;Book, String&gt; <br/>{ <br/>   List findByTitleContaining(String title); <br/>   List findByAuthor(String name); <br/>}</span></pre><p id="b4d0" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">这个存储库有两种方法来按书名或作者名获取图书列表。</p><h1 id="9030" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">添加Spring REST API控制器</h1><p id="b4a0" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，为了让我们的应用程序REST CRUD，我们将添加一个REST控制器。该控制器将包含<code class="fe mh mi mj mk b">POST</code>、<code class="fe mh mi mj mk b">PUT</code>、<code class="fe mh mi mj mk b">GET</code>和<code class="fe mh mi mj mk b">DELETE</code>API。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f00a" class="mt js in mk b gy mu mv l mw mx">package com.betterjavacode.mongodbdemo.mongodbapp.controller; </span><span id="7c22" class="mt js in mk b gy my mv l mw mx">import com.betterjavacode.mongodbdemo.mongodbapp.models.Book; <br/>import com.betterjavacode.mongodbdemo.mongodbapp.repositories.BookRepository; <br/>import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; <br/>import org.springframework.http.ResponseEntity; <br/>import org.springframework.web.bind.annotation.*; <br/>import java.util.ArrayList; import java.util.List; <br/>import java.util.Optional; </span><span id="7a87" class="mt js in mk b gy my mv l mw mx">@CrossOrigin("http://localhost:8080") <br/>@RestController <br/>@RequestMapping("/v1/mongodbapp") <br/>public class BookController <br/>{ <br/>   @Autowired <br/>   BookRepository bookRepository; </span><span id="6553" class="mt js in mk b gy my mv l mw mx">   @GetMapping("/books") <br/>   public ResponseEntity&lt;List&gt; getAllBooks(@RequestParam(required = false) String bookTitle) <br/>   { <br/>      try <br/>      { <br/>         List listOfBooks = new ArrayList&lt;&gt;(); <br/>         if(bookTitle == null || bookTitle.isEmpty()) <br/>         { <br/>           bookRepository.findAll().forEach(listOfBooks::add); <br/>         } <br/>         else <br/>         {<br/>            <br/>bookRepository.findByTitleContaining(bookTitle).forEach(listOfBooks::add);   } <br/>         if(listOfBooks.isEmpty()) <br/>         { <br/>           return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); <br/>         } <br/>         return new ResponseEntity&lt;&gt;(listOfBooks, HttpStatus.OK); <br/>       } <br/>       catch (Exception e) <br/>       { <br/>          return new ResponseEntity&lt;&gt;(null, HttpStatus.INTERNAL_SERVER_ERROR); <br/>       } <br/>   } <br/>  <br/>   @GetMapping("/books/{id}") <br/>   public ResponseEntity getBookById(@PathVariable("id") String id) <br/>   { <br/>      try<br/>      { <br/>         Optional bookOptional = bookRepository.findById(id); <br/>         return new ResponseEntity&lt;&gt;(bookOptional.get(), HttpStatus.OK); <br/>      } <br/>      catch (Exception e) <br/>      { <br/>        return new ResponseEntity&lt;&gt;(null, HttpStatus.INTERNAL_SERVER_ERROR); <br/>      } <br/>    } <br/>   <br/>    @PostMapping("/books") <br/>     public ResponseEntity addABookToLibrary(@RequestBody Book book)<br/>     { <br/>        try <br/>        { <br/>          Book createdBook = bookRepository.save(new Book(book.getTitle(), book.getAuthor(), book.getIsbn())); <br/>          return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.CREATED); <br/>        } <br/>        catch (Exception e) <br/>        { <br/>          return new ResponseEntity&lt;&gt;(null, HttpStatus.INTERNAL_SERVER_ERROR); <br/>        } <br/>     } </span><span id="60d8" class="mt js in mk b gy my mv l mw mx">     @PutMapping("/books/{id}") <br/>     public ResponseEntity updateABook(@PathVariable("id") String id, @RequestBody Book book) <br/>     { <br/>       Optional bookOptional = bookRepository.findById(id); <br/>       if(bookOptional.isPresent()) <br/>       { <br/>          Book updatedBook = bookOptional.get(); <br/>          updatedBook.setTitle(book.getTitle()); <br/>          updatedBook.setAuthor(book.getAuthor()); <br/>          updatedBook.setIsbn(book.getIsbn()); <br/>          return new ResponseEntity&lt;&gt;(bookRepository.save(updatedBook), HttpStatus.OK); <br/>       } <br/>       else <br/>       { <br/>          return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); <br/>       } <br/>     } </span><span id="2380" class="mt js in mk b gy my mv l mw mx">     @DeleteMapping("/books/{id}") <br/>     public ResponseEntity deleteABook(@PathVariable("id") String id)  <br/>     { <br/>        try <br/>        { <br/>          bookRepository.deleteById(id); <br/>          return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); <br/>        } <br/>        catch (Exception e) <br/>        { <br/>          return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); <br/>        } <br/>      } <br/>}</span></pre><p id="879b" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">“BookController”是我们的REST控制器类。它包括</p><ul class=""><li id="1e5e" class="lt lu in kr b ks lo kw lp la lv le lw li lx lm ly lz ma mb bi translated"><code class="fe mh mi mj mk b">@RestController</code> -将此标记为休息控制器。</li><li id="1c3f" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated"><code class="fe mh mi mj mk b">@CrossOrigin</code> -该注释允许跨来源资源共享(CORS)。这将在REST响应中添加CORS访问控制报头。这些头是必要的，因为它允许服务器不仅指定谁可以访问资源，还可以指定如何访问资源。</li><li id="d552" class="lt lu in kr b ks mc kw md la me le mf li mg lm ly lz ma mb bi translated">我们添加了不同的方法— <code class="fe mh mi mj mk b">addABookToLibrary</code>将图书添加到数据库中，<code class="fe mh mi mj mk b">getAllBooks</code>从数据库中检索图书。</li></ul><h1 id="c44f" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">完整的演示</h1><p id="cbe2" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在我们已经添加了REST控制器、存储库方法，我们将构建并运行这个应用程序。作为演示的一部分，我将使用POSTMAN来访问API。</p><p id="d6eb" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">您可以从命令行或正在使用的代码编辑器中构建应用程序。我更喜欢命令行，所以我已经构建了应用程序。构建完成后，您可以按如下方式运行程序:</p><p id="70ba" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated"><code class="fe mh mi mj mk b">java -jar mongodbapp-0.0.1-SNAPSHOT.jar</code>。</p><p id="d6a1" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">让我们用邮递员给我们的图书馆添加书籍。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ac954e280458c4835544e949f48475dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*TK_bDb9w45nGUmB9"/></div></figure><p id="29af" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">如上所示，我们添加了一本书，响应显示数据库中添加了一本书。</p><p id="2a79" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">下面的API是一个GET API，用于从数据库中获取所有的书籍。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f0651fe9a0db3cdc4190695b440ae5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*iDlzi5MAWDEsnyaA"/></div></figure><p id="394d" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">现在，为了显示从库中删除图书，我们将使用DELETE API。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a300eba028f6f5635c12dc66d174c549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*5B-9LK2nKr4_KqGW"/></div></figure><p id="3b06" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">这个示例应用程序的代码可以在我的<a class="ae ln" href="https://github.com/yogsma/mongodbapp" rel="noopener ugc nofollow" target="_blank"> github资源库</a>中找到。</p><p id="b306" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">如果想在MongoDB数据库中看到这些数据，可以访问MongoDB compass工具，访问图书馆数据库中的馆藏书籍。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/980cc70c6ca011fbb5d3bda8ec731c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*BFNoW7Ge4ZHiPqgB"/></div></figure><h1 id="a659" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="7a98" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在这篇文章中，我展示了如何在使用MongoDB数据库的同时使用Spring Boot创建REST API。我们使用的方法与我们使用常规SQL数据库的方法非常相似。使用NoSQL数据库时，我们必须添加一些更改。如果你觉得这篇文章有用，或者有任何我可以帮助你的问题，你可以在这里订阅我的博客<a class="ae ln" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9691" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated"><em class="na">原载于2021年1月17日</em><a class="ae ln" href="https://betterjavacode.com/spring-boot/spring-boot-crud-application-example-with-mongodb" rel="noopener ugc nofollow" target="_blank"><em class="na">【https://betterjavacode.com】</em></a><em class="na">。</em></p></div></div>    
</body>
</html>