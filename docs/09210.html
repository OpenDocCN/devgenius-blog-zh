<html>
<head>
<title>Achieving efficiency with “singleflight” in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过围棋中的“单飞”提高效率</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/achieving-efficiency-with-singleflight-in-go-4daf668e48d?source=collection_archive---------0-----------------------#2022-08-07">https://blog.devgenius.io/achieving-efficiency-with-singleflight-in-go-4daf668e48d?source=collection_archive---------0-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/aa1ef96e9190390e9aaf81b423ac959d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*AC-w5Lw8RobWAETN"/></div></figure><p id="3f0b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你已经浏览了 Go 生态系统一段时间，你可能会看到一些前缀为<code class="fe kp kq kr ks b">golang.org/x</code>的包。"这些包是 Go 项目的一部分，但是在主 Go 树之外."这些年来，这些包中的一些功能被转移到 Go 标准库中，反之亦然。在这篇文章中，我将写一个叫做<code class="fe kp kq kr ks b">singleflight</code>的外部包。<code class="fe kp kq kr ks b">singleflight</code>防止类似的函数同时调用。这是通过允许第二次调用等待第一次调用完成来实现的。一旦完成，第一次调用的结果将与第二次共享。我将演示它是如何工作的，并向您展示如何为您的程序塑造它。</p><h1 id="9be3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个基本例子</h1><p id="e7f0" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated"><code class="fe kp kq kr ks b">singleflight</code>有一种类型叫群。Group 有一个方法叫做<code class="fe kp kq kr ks b">Do</code>，这个方法将执行提供的函数并返回结果。以下是该函数的签名:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="04df" class="me ku in ks b gy mf mg l mh mi">func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool)</span></pre><p id="23b5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">参数<code class="fe kp kq kr ks b">key</code>是一个组如何知道我试图调用同一个函数。第二个参数<code class="fe kp kq kr ks b">fn</code>将保存我的函数代码。返回的变量之一是<code class="fe kp kq kr ks b">shared</code>，该变量指示调用是否等待前一个调用完成。可以把它想象成一个存在于函数调用生命周期中的缓存。对于我的用例，我将定义一个函数来模拟一个耗时的任务。该函数的代码如下:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="d1a6" class="me ku in ks b gy mf mg l mh mi">func timeConsumingFunction() string {</span><span id="de97" class="me ku in ks b gy mj mg l mh mi">  time.Sleep(10 * time.Second)<br/>  return "Hello"<br/>}</span></pre><p id="7df7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我将在主线程和 Goroutine 上执行一个函数。我这样做是为了确保两个调用同时运行。对于每次调用，我将记录结果和变量<code class="fe kp kq kr ks b">shared</code>。以下是执行此操作的代码块:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="5802" class="me ku in ks b gy mf mg l mh mi">func main(){</span><span id="a934" class="me ku in ks b gy mj mg l mh mi">  var g <strong class="ks io">singleflight.Group</strong></span><span id="74f2" class="me ku in ks b gy mj mg l mh mi">  <strong class="ks io">go func</strong>(){<br/>     <strong class="ks io">v</strong>, _, <strong class="ks io">shared</strong> := g.Do("key", func() (interface{}, error) {</span><span id="504f" class="me ku in ks b gy mj mg l mh mi">       s := <strong class="ks io">timeConsumingFunction</strong>()<br/>       return s,nil <br/>     })<br/>     fmt.Println("Goroutine result : ", v, shared)<br/>  }()</span><span id="cdd5" class="me ku in ks b gy mj mg l mh mi">  <strong class="ks io">time.Sleep(2 * time.Second)</strong><br/><br/>  <strong class="ks io">v</strong>, _, <strong class="ks io">shared</strong> := g.Do("key", func() (interface{}, error) {</span><span id="2b29" class="me ku in ks b gy mj mg l mh mi">    s := <strong class="ks io">timeConsumingFunction</strong>()<br/>    return s,nil <br/>  })</span><span id="56fb" class="me ku in ks b gy mj mg l mh mi">  <strong class="ks io">fmt.Printf("%v %v\n", v, shared)</strong></span><span id="118e" class="me ku in ks b gy mj mg l mh mi">}</span></pre><p id="8f3d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">之前定义的代码应该运行 12 秒？将这一时间缩短到仅仅 10 秒。使线程休眠后进行的调用返回的结果与从 goroutine 进行的调用返回的结果相同。说明这一点的最佳方式是使用 gif。以下是终端上的命令，两个控制台日志同时出现(需要 10 秒钟) :</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d06ccddcc6dbdc260610b8c23bb736e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*MccG4Kh0gYoB7bvv.gif"/></div></figure><p id="d9ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这和现实世界有什么关系？为了这篇文章，假设你工作的组织仍然使用 CSV 作为他们 web 服务器的数据源。现在，假设您有一个加载 CSV 并将其返回给用户的函数。优化的一种方法是缓存结果，对吗？是的，但是服务器会使用更多的内存。在某些情况下，开发人员没有根据需要使用 ram 的自由，因此缓存可能不是一个可行的选择。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/e1b24907fae88d4707b234cd9cad929a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fhmdl0R95Oj8rPm1.jpg"/></div></div></figure><h1 id="33ec" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">抽象 Do 方法。</h1><p id="08f1" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">方法<code class="fe kp kq kr ks b">Do</code>是有限的，因为它返回一个接口、错误和布尔值。我将提出抽象作为绕过这一限制的解决方案。我要做的第一步是定义我的基本函数:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="bd72" class="me ku in ks b gy mf mg l mh mi">func SayHello() string {<br/>  return "Hello"<br/>}</span></pre><p id="57cb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下一步我将添加函数<code class="fe kp kq kr ks b">Do</code>并使用一个内嵌函数作为参数<code class="fe kp kq kr ks b">fn</code>。下面是该函数之后的样子:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="8287" class="me ku in ks b gy mf mg l mh mi">type <strong class="ks io">App</strong> struct {</span><span id="c8bf" class="me ku in ks b gy mj mg l mh mi">   G singleflight.Group<br/>}</span><span id="ed92" class="me ku in ks b gy mj mg l mh mi">func (s * <strong class="ks io">App</strong>) SayHello() string {</span><span id="ae1b" class="me ku in ks b gy mj mg l mh mi">  v, _, _ := s.G.Do("SayHello", func() (interface{}, error) {<br/>     return "Hello",nil <br/>  })<br/>  return v<strong class="ks io">.(string)</strong><br/>}</span></pre><p id="52ed" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">还有一个问题，我如何传递变量 g？一种方法是定义一个定制的结构类型，并将<code class="fe kp kq kr ks b">singleflight.Group</code>作为一个字段。如果你注意到了，我将变量<code class="fe kp kq kr ks b">v</code>转换为字符串类型，这是因为 Do 将返回一个接口。同样，这可以用泛型来进一步完善。下面是修改后的代码:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="0d55" class="me ku in ks b gy mf mg l mh mi">func (s * App) SayHello[<strong class="ks io">T any</strong>](fn func() (interface{}, error)) <strong class="ks io">T </strong>{</span><span id="9eb3" class="me ku in ks b gy mj mg l mh mi">  v, _, _ := s.G.Do("SayHello", <strong class="ks io">fn</strong>)<br/>  return <strong class="ks io">v.(T)</strong><br/>}</span></pre><p id="7001" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有了这个修改后的函数，我可以实现<code class="fe kp kq kr ks b">Do</code>函数，而不用担心它返回的接口。下面是 SayHello 函数的调用，它自动断言 int 的接口:</p><pre class="lw lx ly lz gt ma ks mb mc aw md bi"><span id="eb93" class="me ku in ks b gy mf mg l mh mi">SayHello[<strong class="ks io">int</strong>](func() (interface{}, error){<br/>  return 20,nil<br/>})</span></pre><h1 id="5142" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="4800" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">通过强制一个函数的所有后续调用等待第一个调用完成，消除了同时运行重复函数的低效率。与缓存不同，只有同时调用函数时，结果才会被共享。它充当一个相当短命的缓存，不需要被无效或设置时间限制。然而，我不喜欢它返回一个<code class="fe kp kq kr ks b">interface{}</code>类型，但是这可以用泛型来纠正。我不建议在生产中使用它，因为它仍然在外部存储库中可能有一个很好的原因。在文章的底部有一个链接指向这篇文章中使用的全部源代码。</p><div class="mq mr gp gr ms mt"><a href="https://pkg.go.dev/golang.org/x" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">子存储库</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">子库是 Go 项目的一部分，但是在主 Go 树之外。它们是在更宽松的兼容性下开发的…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">pkg.go.dev</p></div></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://github.com/cheikhshift/medium_examples/tree/main/efficient" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">medium _ examples/main cheikh shift/medium _ examples 的效率</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jp mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://pkg.go.dev/golang.org/x/sync@v0.0.0-20220722155255-886fb9371eb4/singleflight" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">单程航班</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Package singleflight 提供了一种重复函数调用抑制机制。此部分是空的。这一节是…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">pkg.go.dev</p></div></div></div></a></div></div></div>    
</body>
</html>