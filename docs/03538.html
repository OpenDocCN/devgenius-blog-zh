<html>
<head>
<title>Object-Oriented JavaScript — Class Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript —类继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-class-inheritance-5c5cf7dcdf8f?source=collection_archive---------10-----------------------#2020-11-15">https://blog.devgenius.io/object-oriented-javascript-class-inheritance-5c5cf7dcdf8f?source=collection_archive---------10-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dead80a7c6663f7bd84d4af0b967cc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u8joRFGKMROso7tj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@matmaphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Matteo Maretto </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript子类、混合和多重继承。</p><h1 id="56f5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类</h1><p id="2ba3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以从JavaScript类创建子类。</p><p id="b7df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e23e" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="ad6a" class="mn lc iq mj b gy ms mp l mq mr">  speak() {<br/>    console.log(`${this.name} speaks`);<br/>  }<br/>}</span><span id="cc5a" class="mn lc iq mj b gy ms mp l mq mr">class Dog extends Animal {<br/>  speak() {<br/>    console.log(`${this.name} woofs`);<br/>  }<br/>}</span><span id="b777" class="mn lc iq mj b gy ms mp l mq mr">const mary = new Dog('mary');</span></pre><p id="66d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建<code class="fe mt mu mv mj b">Animal</code>类。</p><p id="1394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">speak</code>方法在<code class="fe mt mu mv mj b">Animal</code>类中。</p><p id="143c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个名为<code class="fe mt mu mv mj b">Dog</code>的<code class="fe mt mu mv mj b">Animal</code>的子类，它也有<code class="fe mt mu mv mj b">speak</code>方法。</p><p id="ffc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们创建一个<code class="fe mt mu mv mj b">Dog</code>实例，那么将使用<code class="fe mt mu mv mj b">Dog</code>中的<code class="fe mt mu mv mj b">speak</code>方法。</p><p id="3e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="85c0" class="mn lc iq mj b gy mo mp l mq mr">mary.speak();</span></pre><p id="d75d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f01c" class="mn lc iq mj b gy mo mp l mq mr">mary woofs</span></pre><p id="bc0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以访问一个类的超类。</p><p id="e6ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调用<code class="fe mt mu mv mj b">super()</code>调用超类，传入父构造函数的参数。</p><p id="d860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以调用<code class="fe mt mu mv mj b">super.&lt;parentClassMethod&gt;</code>来调用父类的方法。</p><p id="a261" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">super.&lt;parentClassProp&gt;</code>让我们访问父类属性。</p><p id="1aca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a772" class="mn lc iq mj b gy mo mp l mq mr">class Parent {}</span><span id="d2e9" class="mn lc iq mj b gy ms mp l mq mr">class Child extends Parent {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="0c35" class="mn lc iq mj b gy ms mp l mq mr">const child = new Child('james')</span></pre><p id="87de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到错误:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4350" class="mn lc iq mj b gy mo mp l mq mr">Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span></pre><p id="2543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们需要先调用<code class="fe mt mu mv mj b">super</code>来调用父构造函数，然后才能设置<code class="fe mt mu mv mj b">this</code>的属性。</p><p id="bc9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们省略<code class="fe mt mu mv mj b">Child</code>中的<code class="fe mt mu mv mj b">constructor</code>，这可以隐式完成。</p><p id="1413" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0584" class="mn lc iq mj b gy mo mp l mq mr">class Parent {}</span><span id="a062" class="mn lc iq mj b gy ms mp l mq mr">class Child extends Parent {}</span><span id="84fc" class="mn lc iq mj b gy ms mp l mq mr">const child = new Child()</span></pre><p id="45a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们不会得到一个错误，因为提供了一个默认的构造函数。</p><p id="56ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认值为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ac01" class="mn lc iq mj b gy mo mp l mq mr">constructor(...args) {<br/>  super(...args);<br/>}</span></pre><h1 id="86ef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">混合蛋白</h1><p id="1674" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript只支持单一继承，所以我们不能使用标准的JavaScript语法从多个类继承属性。</p><p id="510c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们必须用函数将多个类组合成一个类。</p><p id="4665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5872" class="mn lc iq mj b gy mo mp l mq mr">class Person {}</span><span id="b078" class="mn lc iq mj b gy ms mp l mq mr">const BackgroundCheck = Tools =&gt; class extends Tools {<br/>  check() {}<br/>};</span><span id="045b" class="mn lc iq mj b gy ms mp l mq mr">const Onboard = Tools =&gt; class extends Tools {<br/>  createEmail() {}<br/>};</span><span id="6822" class="mn lc iq mj b gy ms mp l mq mr">class Employee extends BackgroundCheck(Onboard(Person)) {}</span></pre><p id="2385" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有返回<code class="fe mt mu mv mj b">Tools</code>类的子类的<code class="fe mt mu mv mj b">BackgroundCheck</code>类。</p><p id="c7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe mt mu mv mj b">Person</code>是<code class="fe mt mu mv mj b">Onboard</code>函数中的<code class="fe mt mu mv mj b">Tools</code>。</p><p id="82cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe mt mu mv mj b">Onboard(Person)</code>是<code class="fe mt mu mv mj b">BackgroundCheck</code>功能中的<code class="fe mt mu mv mj b">Tools</code>。</p><p id="050b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们返回一个既有<code class="fe mt mu mv mj b">check</code>又有<code class="fe mt mu mv mj b">createEmail</code>方法的类，我们可以使用得到的类来创建<code class="fe mt mu mv mj b">Employee</code>子类。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/39f89ee6b6cd7fa7f1fbcc1323682276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x7XXXcld3oFfKsXr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@s1winner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Viacheslav Bublyk </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="21d2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="df9b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">extends</code>关键字创建子类。</p><p id="0c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以创建返回一个类的函数并组合它们，这样我们就可以从多个类继承。</p></div></div>    
</body>
</html>