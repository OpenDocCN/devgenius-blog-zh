<html>
<head>
<title>Node.js Tips — Change Directory with exec, Move Files, and Nested Schemas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—使用exec、移动文件和嵌套模式更改目录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-change-directory-with-exec-move-files-and-nested-schemas-fdae01f8338?source=collection_archive---------2-----------------------#2020-07-21">https://blog.devgenius.io/node-js-tips-change-directory-with-exec-move-files-and-nested-schemas-fdae01f8338?source=collection_archive---------2-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8deadb5c45762d1afd6589d68d8dbba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-y0GFyQ7nmD5Qcac"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">瑞安·斯通在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="d8a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将文件移动到Node.js中的不同分区或设备</h1><p id="412c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过指定写入流的目标路径，我们可以将文件移动到不同的分区或设备。</p><p id="a1f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将文件读入一个读流，并通过管道将其传输到一个写流。</p><p id="7be5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="32bb" class="mn lc iq mj b gy mo mp l mq mr">const fs = require('fs');</span><span id="3490" class="mn lc iq mj b gy ms mp l mq mr">const rs = fs.createReadStream('source/file');<br/>const ws = fs.createWriteStream('destination/file');</span><span id="6630" class="mn lc iq mj b gy ms mp l mq mr">rs.pipe(ws);<br/>rs.on('end', () =&gt; {<br/>  fs.unlinkSync('source/file');<br/>});</span></pre><p id="4c96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用源文件路径调用<code class="fe mt mu mv mj b">createReadStream</code>从流中读取文件。</p><p id="855b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe mt mu mv mj b">createWriteStream</code>来创建带有目标路径的写流。</p><p id="ed50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在读取流上调用<code class="fe mt mu mv mj b">pipe</code>,将写入流作为参数，将读取流传输到写入流。</p><p id="dc18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将把文件从源位置复制到目标位置。</p><p id="9591" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦复制完成，我们调用<code class="fe mt mu mv mj b">unlinkSync</code>从源路径中删除文件。</p><p id="c0b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当发出<code class="fe mt mu mv mj b">end</code>事件时，我们知道复制何时完成。</p><p id="de8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们的生活更容易，我们可以使用<code class="fe mt mu mv mj b">fs.extra</code>模块的<code class="fe mt mu mv mj b">move</code>方法。</p><p id="d39f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过运行以下命令来安装它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a62f" class="mn lc iq mj b gy mo mp l mq mr">npm install fs.extra</span></pre><p id="3e20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过指定源路径和目的路径来使用<code class="fe mt mu mv mj b">move</code>方法。</p><p id="d77d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19de" class="mn lc iq mj b gy mo mp l mq mr">const fs = require('fs.extra');<br/>fs.move('foo.txt', 'bar.txt', (err) =&gt; {<br/>  if (err) {<br/>    throw err;<br/>  }<br/>  console.log("success");<br/>});</span></pre><p id="bc19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用源文件路径作为第一个参数调用了<code class="fe mt mu mv mj b">fs.move</code>。</p><p id="be6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是目标路径。</p><p id="4bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个是在移动操作完成时运行的回调。</p><h1 id="4d26" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查找弃用警告</h1><p id="dcb3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们运行我们的应用程序时，我们可以通过使用<code class="fe mt mu mv mj b">--trace-deprecation</code>或<code class="fe mt mu mv mj b">--throw-deprecation</code>选项找到弃用警告。</p><p id="9f28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="28e4" class="mn lc iq mj b gy mo mp l mq mr">node --trace-deprecation app.js</span></pre><p id="d762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d596" class="mn lc iq mj b gy mo mp l mq mr">node --throw-deprecation app.js</span></pre><p id="6576" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">— trace-deprecation</code>记录堆栈跟踪，<code class="fe mt mu mv mj b">--throw-deprecation</code>抛出错误。</p><p id="a892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还应该确保在异步方法中包含一个回调函数，如果我们得到如下结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="49f2" class="mn lc iq mj b gy mo mp l mq mr">(node:4346) DeprecationWarning: Calling an asynchronous function without callback is deprecated.</span></pre><p id="d379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用没有回调的异步函数是一个很大的不推荐的特性。</p><p id="015f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff5e" class="mn lc iq mj b gy mo mp l mq mr">const fs = require('fs');<br/>//...</span><span id="33d7" class="mn lc iq mj b gy ms mp l mq mr">fs.writeFile('foo.txt', data, 'utf8', (error) =&gt; {<br/>  // ...<br/>});</span></pre><p id="1db6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四个参数是回调函数。</p><h1 id="9f2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js exec不支持“CD”Shell命令</h1><p id="4f44" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个命令都在自己的shell中用<code class="fe mt mu mv mj b">exec</code>运行，所以使用<code class="fe mt mu mv mj b">cd</code>只会影响运行<code class="fe mt mu mv mj b">cd</code>的shell进程。</p><p id="d4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想改变当前的工作目录，我们必须设置<code class="fe mt mu mv mj b">cwd</code>选项。</p><p id="2f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4dac" class="mn lc iq mj b gy mo mp l mq mr">exec('git status', {<br/>  cwd: '/repo/folder'<br/>}, (error, stdout, stderr) =&gt; {<br/>  if (error) {<br/>    console.error(error);<br/>    return;<br/>  }<br/>  console.log(stdout);<br/>  console.error(stderr);<br/>});</span></pre><p id="7d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过在作为第二个参数传入的对象中设置<code class="fe mt mu mv mj b">cwd</code>选项来切换到<code class="fe mt mu mv mj b">/repo/folder</code>目录。</p><p id="0eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在<code class="fe mt mu mv mj b">/repo/folder</code>上运行<code class="fe mt mu mv mj b">git status</code>，而不是应用程序运行的目录。</p><h1 id="5c8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有Mongoose的模式中的模式</h1><p id="cd05" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Mongoose在模式中定义一个模式。</p><p id="5fbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以用它存储关系数据。</p><p id="ffe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="05cf" class="mn lc iq mj b gy mo mp l mq mr">const UserSchema = new Schema({<br/>  name: String,<br/>  tasks: [{<br/>    type: Schema.ObjectId,<br/>    ref: 'Task'<br/>  }]<br/>});</span><span id="80a8" class="mn lc iq mj b gy ms mp l mq mr">const TaskSchema = new Schema({<br/>  name: String,<br/>  user: {<br/>    type: Schema.ObjectId,<br/>    ref: 'User'<br/>  }<br/>});</span></pre><p id="91b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个相互引用的模式。</p><p id="74f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">tasks</code>数组在<code class="fe mt mu mv mj b">UserSchema</code>和<code class="fe mt mu mv mj b">TaskSchema</code>之间创建了一个一对多的关系。</p><p id="2d2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">ref</code>指定了我们想要访问的模式。</p><p id="499d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组表示一对多。</p><p id="4a17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在<code class="fe mt mu mv mj b">TaskSchema</code>中，我们定义了<code class="fe mt mu mv mj b">user</code>字段，它创建了与<code class="fe mt mu mv mj b">User</code>的隶属关系。</p><p id="3f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">'User’</code>指定一个对象作为<code class="fe mt mu mv mj b">ref</code>的值。</p><p id="23cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们查询一个用户时，我们可以通过使用<code class="fe mt mu mv mj b">populate</code>方法获得它的所有任务:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2c90" class="mn lc iq mj b gy mo mp l mq mr">User.find({}).populate('tasks').run((err, users) =&gt; {<br/>  //...<br/>});</span></pre><p id="923b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入想要访问的子字段，即<code class="fe mt mu mv mj b">tasks</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/150d629c459477ccd5aa557a26fa636d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qlmJ_bJHtCYVSoRE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">西蒙·斯霍尔滕在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="939d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9b27" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Mongoose定义嵌套模式来创建关系。</p><p id="745a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以移动文件。</p><p id="4717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以运行带有一些选项的<code class="fe mt mu mv mj b">node</code>来查找弃用警告。</p><p id="ab8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要用<code class="fe mt mu mv mj b">exec</code>改变当前工作目录，我们可以设置<code class="fe mt mu mv mj b">cwd</code>属性。</p></div></div>    
</body>
</html>