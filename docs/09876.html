<html>
<head>
<title>Variable Scope in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby 中的变量作用域</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/variable-scope-in-ruby-7b344bef16c?source=collection_archive---------10-----------------------#2022-09-19">https://blog.devgenius.io/variable-scope-in-ruby-7b344bef16c?source=collection_archive---------10-----------------------#2022-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/47985acf06fcbcfe2c95796e9ac3a786.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*-86IA20thd4JMZnnrEiJ6g.png"/></div></figure><p id="c71e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所有 Ruby 开发人员都必须理解作用域的概念。为什么？因为这是许多错误消息和混乱的原因。范围到底是什么？变量的范围指的是在任何给定的时间什么变量是可用的。各种类型的变量有不同的范围。范围可以很窄(局部变量)，也可以很宽(全局变量)。为了避免状态突变和名称冲突的问题，您应该使用尽可能窄的范围。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="3f6c" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">局部变量范围</h1><p id="4740" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">局部变量的范围最有限。特别是，方法返回后，方法中定义的局部变量将不再存在。</p><h2 id="4348" class="lz kx in bd ky ma mb dn lc mc md dp lg kc me mf lk kg mg mh lo kk mi mj ls mk bi translated">示例 1</h2><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ca35" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你期望<code class="fe mr ms mt mu b">apple </code>打印什么？</p><p id="80be" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解决方法如下:当你调用<code class="fe mr ms mt mu b">apple</code>时，它总是打印<code class="fe mr ms mt mu b">100</code>。</p><p id="ba4f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">an 在方法外被定义为 50 对方法内的<code class="fe mr ms mt mu b">a </code>变量没有影响。它们是截然不同的变量。</p><p id="6d8b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">把作用域想象成一个气泡… <br/>当你调用一个方法，任何方法，你进入一个新的空气泡。在第一个<code class="fe mr ms mt mu b">a = 50</code>之后，你进入到方法的“气泡”中，你对<code class="fe mr ms mt mu b">a</code>所做的任何改变都不会反映到气泡之外。即使我们在方法的“气泡”内部创建了一个新变量，也不能从方法外部访问它。</p><p id="ec7d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当这种方法结束时……泡沫破裂了。气泡内的变量消失了，再也无法访问。这就是局部变量的工作方式。</p><blockquote class="mv mw mx"><p id="48fd" class="jr js my jt b ju jv jw jx jy jz ka kb mz kd ke kf na kh ki kj nb kl km kn ko ig bi translated"><em class="in">局部变量的范围是首次定义该变量的块、方法定义或程序(以较小者为准)。</em></p></blockquote><p id="25fb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当有疑问时，记住上面的咒语来帮助你确定一个给定的局部变量存在于哪个“气泡”中。</p><h1 id="5247" class="kw kx in bd ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp ng lr ls lt bi translated">实例变量范围</h1><p id="ba0c" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">实例变量的范围更广。它们专门用于 Ruby 对象中的数据共享。</p><h2 id="684c" class="lz kx in bd ky ma mb dn lc mc md dp lg kc me mf lk kg mg mh lo kk mi mj ls mk bi translated">示例 2</h2><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="99b9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mr ms mt mu b">@quantity</code>在这个例子中对于<code class="fe mr ms mt mu b">more_juice </code>和<code class="fe mr ms mt mu b">less_juice </code>方法是相同的变量。这是所有方法共享的值。但是，在这个类之外，甚至在不同的<code class="fe mr ms mt mu b">Fruit </code>对象上，<code class="fe mr ms mt mu b">@quantity</code>会有所不同。</p><h2 id="73d6" class="lz kx in bd ky ma mb dn lc mc md dp lg kc me mf lk kg mg mh lo kk mi mj ls mk bi translated">示例 3</h2><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9836" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">每个对象的实例变量都是唯一的。在本例中，orange 的<code class="fe mr ms mt mu b">@quantity</code>为 100，apple 的<code class="fe mr ms mt mu b">@quantity</code>为 50。就像不同的人有不同的名字，年龄，国家等等。</p><h1 id="ca77" class="kw kx in bd ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp ng lr ls lt bi translated">块中的可变范围</h1><p id="df43" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">说到范围，块是非常有趣的。按照我们的泡沫类比，一个块从当前的泡沫带来局部变量。你可以接触并控制它们。在程序级定义的块存在于与程序级局部变量相同的气泡中，而在方法定义中定义的块存在于方法的气泡中。积木还会在这个外部气泡中产生一个较小的气泡。</p><h2 id="20fa" class="lz kx in bd ky ma mb dn lc mc md dp lg kc me mf lk kg mg mh lo kk mi mj ls mk bi translated">实例 4</h2><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2d18" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是，气泡仍然会弹出，删除块中创建的任何新的局部变量。这难道不令人着迷吗？</p><h2 id="b655" class="lz kx in bd ky ma mb dn lc mc md dp lg kc me mf lk kg mg mh lo kk mi mj ls mk bi translated">实例 5</h2><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="77ca" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不仅如此，积木还会带着它们被创造出来时的气泡。这意味着该气泡中定义的所有变量都可以从块中访问。这就是所谓的“终结”请记住，这个“气泡”是在源代码中的特定点可以访问的所有变量的集合。它是封装为对象的作用域。在 Ruby 中，这被称为绑定。</p><h1 id="73ae" class="kw kx in bd ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp ng lr ls lt bi translated">结论</h1><p id="91c0" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">我们已经看到，变量有不同的作用域，这取决于它们在 Ruby 代码中的定义方式。局部变量只能从创建它们的“气泡”中访问，例如，在一个方法中创建一个变量意味着在该方法之外不能访问它，但是块可以访问初始化它们的气泡中的变量。另一方面，实例变量在它们的类“bubble”中的任何地方都是可访问的，但是一个类的每个实例可能有它自己的与一个实例变量相关联的值。最后，块固有的“气泡”是在其中创建的，它们可以改变气泡内的变量，但是在块本身内创建的任何变量在它运行后都会被删除。</p></div></div>    
</body>
</html>