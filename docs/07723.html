<html>
<head>
<title>Why Props in components and not Context API?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么道具在组件中而不是在上下文 API 中？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-props-in-components-and-not-context-api-7749b6a9450a?source=collection_archive---------12-----------------------#2022-04-18">https://blog.devgenius.io/why-props-in-components-and-not-context-api-7749b6a9450a?source=collection_archive---------12-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1087d6d5f6c13cfa4bb865b24fa19288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxJCAHFwIwHUx6OuXNxsgg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">道具 vs 上下文 API</figcaption></figure><p id="2b35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi kx translated">首先，我想提供一些关于这篇文章内容的信息。本文的目的不是详细解释什么是上下文 api 或 props。</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/9958336bd1acf6d828cdac5f50d04688.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*LbtOWH46WJ6xZfkjT_YSqw.gif"/></div></figure><p id="8007" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我将只寻找这个问题的答案:在什么地方，什么时候，我们应该更喜欢他们而不是其他人。但我会更侧重于为什么在组件中使用道具，而不是上下文 api。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="643d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为什么我们应该在组件中选择 props 或 context api，这个问题让我们独自思考它是好是坏，就像在其他事情中一样。</p><p id="6eb2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种情况下，我们做出的决定有时对我们的工作非常重要。一如既往，在回答“是好还是另一个好”这个问题之前，我想指出许多因素是重要的。比如何时何地的问题是我们选择哪些的重要因素。</p><p id="aa7f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你愿意，首先从 React 自己的文档中简单解释了什么是 context api 和 props 之后，我们再来寻找这些问题的答案，回答为什么 props 优先于 context api。</p><p id="d02c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">什么是上下文 API？</strong></p><blockquote class="ls lt lu"><p id="047e" class="jz ka lv kb b kc kd ke kf kg kh ki kj lw kl km kn lx kp kq kr ly kt ku kv kw ig bi translated">上下文提供了一种通过组件树传递数据的方式，而不必手动遍历每一层的属性。</p></blockquote><p id="95ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">什么是道具？</strong></p><blockquote class="ls lt lu"><p id="7896" class="jz ka lv kb b kc kd ke kf kg kh ki kj lw kl km kn lx kp kq kr ly kt ku kv kw ig bi translated">从概念上讲，组件就像 JavaScript 函数。组件可选地接受称为“props”的输入，并使用这些 props 返回要在屏幕上显示的 React 元素。</p></blockquote><p id="5b63" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，如果我们已经简单地记住了它们是什么，我们就可以继续讨论哪一个在何时何地使用的问题。</p><p id="63e7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">道具在何时何地使用？</strong></p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/ebbb35daade9bdf472a2d3297e8bc7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*JBsdL5yXFUvg4_hfJ8DjkA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">道具-父母对子女</figcaption></figure><p id="37b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们从解释道具的使用地点和时间开始。正如定义中所述，props 是一种结构，它覆盖了 react 中组件架构中从父节点传输到子节点的数据。有了这个结构，我们可以将数据从父节点传递到子节点。但是，我们的 react 应用程序主要由多个组件之间的通信组成。</p><pre class="lh li lj lk gt ma mb mc md aw me bi"><span id="6b27" class="mf mg in mb b gy mh mi l mj mk">function Welcome(props) {  <br/>  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br/>}<br/><br/>const element = &lt;Welcome name="Sara" /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="23be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们只能通过其子组件将数据从一个组件传递到另一个组件。我们不能从一个父母转移到另一个。所以我们只有在父子之间有数据流的时候才使用 props。这种情况也叫道具钻。因此，我们学会了何时何地使用道具。</p><p id="91c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们来看看为什么要用 props 而不是 context api。</p><ul class=""><li id="f6eb" class="ml mm in kb b kc kd kg kh kk mn ko mo ks mp kw mq mr ms mt bi translated">如果我们的 react 应用程序由少量组件组成，并且这些组件不包含很多子组件。</li><li id="2b84" class="ml mm in kb b kc mu kg mv kk mw ko mx ks my kw mq mr ms mt bi translated">我们有很多组件，但是这些组件是相互独立的，道具结构应该是首选的。因为相互独立的组件很少有相互覆盖的结构。</li></ul><p id="4451" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，当我们想要只将数据传输到一个组件时，我们可以在 props 的帮助下轻松地传输它。</p><p id="9f92" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，至于什么地方什么时候不应该用。当情况与我上面提到的情况相反时，即；</p><ul class=""><li id="7d61" class="ml mm in kb b kc kd kg kh kk mn ko mo ks mp kw mq mr ms mt bi translated">如果我们的应用程序有许多子组件。</li><li id="5d2b" class="ml mm in kb b kc mu kg mv kk mw ko mx ks my kw mq mr ms mt bi translated">这些组件相互依赖。</li></ul><p id="3f40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种情况下，如果我们更喜欢 props 结构，那么 React 应用程序的时间成本和工作量都会增加。</p><p id="95c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上下文 API 在何时何地使用？</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/b28bcf7cb03cdaf45507fbb233307e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRyG71lMnIeDtXL3SbOREQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">context API-包装所有组件</figcaption></figure><p id="baf3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我上面提到的案例中，在不应该首选道具的情况下，会根据应用的规模使用不同的方式。这些方法的例子有 Redux 或上下文 API。我将在这里解释上下文 API 的方式。</p><p id="3287" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，正如上下文 api 的定义中提到的，通过使用这种结构，我们可以从应用程序中的任何地方访问我们想要的数据。换句话说，它有一个可以从任何地方访问的使用结构。在此之前，创建一个上下文，我们希望组件到达的数据和功能保存在那里。然后，通过用这个上下文包装我们的应用程序，我们可以从任何地方访问我们的数据。</p><pre class="lh li lj lk gt ma mb mc md aw me bi"><span id="97c8" class="mf mg in mb b gy mh mi l mj mk">const ThemeContext = React.createContext('light');</span><span id="260a" class="mf mg in mb b gy na mi l mj mk">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ThemeContext.Provider value="dark"&gt;<br/>        &lt;ThemedButton/&gt;<br/>      &lt;/ThemeContext.Provider&gt;<br/>    );<br/>  }<br/>}<br/><br/>class ThemedButton extends React.Component {<br/>  static contextType = ThemeContext;<br/>  render() {<br/>    return &lt;Button theme={this.context} /&gt;;<br/>  }<br/>}</span></pre><p id="1cdd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种结构通常用于:</p><ul class=""><li id="4898" class="ml mm in kb b kc kd kg kh kk mn ko mo ks mp kw mq mr ms mt bi translated">有很多成分。</li><li id="63be" class="ml mm in kb b kc mu kg mv kk mw ko mx ks my kw mq mr ms mt bi translated">有许多相互连接的父组件和子组件。</li></ul><p id="83c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是这种结构也有一些缺点。正如我在开头所说的，有些东西不可能在任何地方和任何时候都是最好的。它的缺点之一；</p><ul class=""><li id="4bc0" class="ml mm in kb b kc kd kg kh kk mn ko mo ks mp kw mq mr ms mt bi translated">当成分数量增加时，语境结构变得非常复杂。</li><li id="3035" class="ml mm in kb b kc mu kg mv kk mw ko mx ks my kw mq mr ms mt bi translated">我们想要传输到组件的数据数量增加了。</li></ul><p id="fa40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这与我们编写代码的困难和我们称之为干净代码的结构相反，但它也造成了我们应用程序中的时间和性能损失。因此，在上下文 api 不够的情况下，我们需要求助于更高级的结构。像 Redux 之类的…</p><p id="464c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">结果，</strong> <br/>是的，现在我想我们有了一点点关于何时何地上下文 api 和道具应该首选的信息。因此，我们理解了为什么在组件中 props 比 context api 更受欢迎。除了我在这里提到的一些信息之外，还有许多更详细的信息。当然，我们没有人能知道所有的要点，</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/48870d88ca1db6eceb737ed6596520eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*8sM7ANyaBQK4jBd18M1A7Q.gif"/></div></figure><p id="88ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是我们可以自己决定什么最有效。😉</p><p id="7cdc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望这篇文章对你何时何地应该首选 props 和 context api 有用。或者至少它为你提供了一个基础。另外，如果你想获得更多关于上下文 api 和 props 的技术信息，你可以在这里找到 React 自己的文档<a class="ae nc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4d6d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我的下一篇文章中再见👋</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="496b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">参考文献</strong></p><ol class=""><li id="e975" class="ml mm in kb b kc kd kg kh kk mn ko mo ks mp kw nd mr ms mt bi translated">React Docs| <a class="ae nc" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a></li><li id="0961" class="ml mm in kb b kc mu kg mv kk mw ko mx ks my kw nd mr ms mt bi translated">React Docs| <a class="ae nc" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">组件和道具</a></li></ol></div></div>    
</body>
</html>