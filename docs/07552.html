<html>
<head>
<title>NestJS with dynamic module loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有动态模块加载的 NestJS</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nestjs-with-dynamic-module-loading-6391baf94f43?source=collection_archive---------1-----------------------#2022-04-05">https://blog.devgenius.io/nestjs-with-dynamic-module-loading-6391baf94f43?source=collection_archive---------1-----------------------#2022-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/084a56171ddb5b7997ae6c8d6a752d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JYtLFIdhluP6fqmI.png"/></div></div></figure><h2 id="329c" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">描述</h2><p id="3677" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><a class="ae lm" href="https://github.com/nestjs/nest" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> NestJS </strong> </a>是一个构建良好的服务器端类型脚本框架，它实现了重要的设计模式，如<a class="ae lm" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io">依赖注入原则</strong> </a>。</p><p id="df08" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">NestJS 集中了使用 Nodejs 构建一致的微服务或整体服务器所需的所有技术。</p><p id="2ef8" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">NestJS 使用三个主要构建块来构成应用程序:</p><ul class=""><li id="26dc" class="ls lt in kt b ku ln ky lo ke lu ki lv km lw ll lx ly lz ma bi translated">控制器</li><li id="4c13" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated">提供者</li><li id="e835" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated">模块</li></ul><blockquote class="mg mh mi"><p id="e019" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated">NestJS 中的控制器负责处理任何传入的请求，并将响应返回给应用程序的客户端。</p><p id="0afe" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated"><strong class="kt io">提供者</strong>(也称为服务)可以被创建并注入控制器或其他提供者。提供者旨在抽象任何形式的复杂性和逻辑。</p><p id="ca43" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated"><strong class="kt io">模块</strong>让你分组相关文件。通过模块引用提供者和控制器。在 NestJS 中，默认情况下，模块封装提供者。换句话说，不可能将不是模块的一部分或从另一个模块导出的提供程序注入到模块中。模块可以导入其他模块——基本上，这允许跨模块共享提供者。</p></blockquote><p id="55c3" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">下图说明了 NestJS 中模块的概念。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/71e2779c238c43e678c7b1bd24905a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/0*03nZwZ5laHdTDngq.png"/></div></figure><p id="160d" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">如您所见，每个应用程序至少有一个根模块(应用程序模块)。<strong class="kt io">根模块</strong>基本上是 NestJS 用来构建<strong class="kt io">应用图</strong>的起点。</p><p id="99bc" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">在 nestjs 中，模块被定义为带有@Module decorator 的类，该类将一个对象作为输入，该对象具有用于创建模块、提供者和控制器之间的关系的部分(属性):</p><blockquote class="mg mh mi"><p id="3dee" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated"><strong class="kt io">提供者</strong>它接受一个提供者列表作为输入。这些提供者将由 NestJS 注入器实例化。默认情况下，属于某个模块的提供程序将在该模块中可用。</p><p id="5c1b" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated">控制器这个数组指定了模块中控制器的集合。基本上，NestJS 会在启动时自动实例化它们。</p><p id="6157" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated"><strong class="kt io">导入</strong>在这个部分，我们可以指定导入模块的列表。基本上，这允许跨模块共享提供者</p><p id="220c" class="kr ks mj kt b ku ln kw kx ky lo la lb mk lp ld le ml lq lg lh mm lr lj lk ll ig bi translated"><strong class="kt io"> Exports </strong>指定该模块提供的提供者。换句话说，我们指定由这个模块导出的提供者。</p></blockquote><h2 id="7390" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h2><p id="c973" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们假设您的系统上安装了<strong class="kt io"> git cli </strong>、<strong class="kt io"> nodejs </strong>和<strong class="kt io"> nestjs cli </strong>。本教程是在一个<strong class="kt io"> <em class="mj"> linux 环境</em> </strong>中运行的，但是你可以很容易地为你喜欢的操作系统进行调整。</p><h2 id="24f8" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">简单的 NestJS 应用程序</h2><p id="2501" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们将创建两个版本的 API 来访问伪数据库中两个实体(表)的内容——只是通过 id 查找条目。</p><p id="a239" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">第一个版本采用传统格式，我们将把封装实体的两个模块分别导入到 appmodule 中。</p><p id="bc61" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">第二个版本将动态导入/src/db/entity 子目录中的所有模块</p><p id="7c99" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">这很酷，就好像你为这个子目录中的新实体创建了新的模块，这些模块将被动态地导入，而不需要你引用它们。您只需创建它们，它们就会自动成为系统的一部分</p><p id="2d27" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">这样，我们的系统将具有以下格式:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/9cef20edadc316b0e24bc97719231479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*lbij5YkaorQCTfCp.png"/></div></figure><h2 id="34ae" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">实体单元</h2><p id="f36c" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">对于每个实体，我们将有一个响应 HTTP 请求的控制器、一个对实体数据执行搜索的服务(由控制器使用)以及一个引用相应控制器和服务的模块(如上图所示，我们有对应于实体<strong class="kt io"> Book </strong>和<strong class="kt io"> Movie </strong>的单元)。</p><h2 id="32bd" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">无动态模块加载的版本<strong class="ak"/></h2><p id="4b3f" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">理论讲够了，让我们把面团投入工作吧！</p><p id="180e" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">下面是 API 应用程序的子目录:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f7454b613a46a60ba8371a6eac395d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*cCBbil36crOL8pzC.png"/></div></figure><p id="508b" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">让我们检查最相关的源代码</p><h2 id="f224" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">T17】app . module . tsT19】</strong></h2><p id="89b8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">根模块<strong class="kt io"><em class="mj">app . module . ts</em></strong>只是将图书和电影实体模块导入到系统中。</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="3c36" class="jv jw in mw b gy na nb l nc nd">import { Module } from '@nestjs/common';<br/>import { BookModule } from './db/entity/book/book.module';<br/>import { MovieModule } from './db/entity/movie/movie.module';<br/><br/>@Module({<br/>  imports: [BookModule, MovieModule],<br/>})<br/>export class AppModule {}</span></pre><p id="78c3" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">db/entity 子目录包含实体列表(书籍和电影)及其各自的模块、提供程序和控制器文件。由于相似性，我们将只检查图书实体的源代码。</p><h2 id="b784" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">T25】book . module . tsT27】</strong></h2><p id="257b" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">模块<strong class="kt io"><em class="mj">book . module . ts</em></strong>也很简单。只需加载控制器<strong class="kt io"><em class="mj">book . controller . ts</em></strong>并使提供者<strong class="kt io"><em class="mj">book . service . ts</em></strong>可用。</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="5c9d" class="jv jw in mw b gy na nb l nc nd">import { Module } from '@nestjs/common';<br/>import { BookService } from './book.service';<br/>import { BookController } from './book.controller';<br/><br/>@Module({<br/>  controllers: [BookController],<br/>  providers: [BookService],<br/>})<br/>export class BookModule {}</span></pre><h2 id="277f" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"><em class="mu">book . controller . ts</em>T43】</strong></h2><p id="716a" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">控制器<strong class="kt io"><em class="mj">book . controller . ts</em></strong>响应路径<strong class="kt io"> /book </strong>上的 HTTP GET requenst，接受<strong class="kt io"> ID </strong>参数，只返回带有相应 ID 的书。</p><p id="ff86" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">控制器使用<strong class="kt io"> book.service.ts </strong>服务的 findById 方法搜索并返回与<strong class="kt io"> ID </strong>对应的图书。</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="3f5d" class="jv jw in mw b gy na nb l nc nd">import { Controller, Get, ParseIntPipe, Query } from '@nestjs/common';<br/>import { BookService, Book } from './book.service';<br/><br/>@Controller('book')<br/>export class BookController {<br/>  constructor(private readonly bookService: BookService) {}<br/><br/>  @Get()<br/>  getBook(@Query('id', ParseIntPipe) id: number): Book {<br/>    return this.bookService.findById(id);<br/>  }<br/>}</span></pre><h2 id="f5ec" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">T57】book . service . tsT59】</strong></h2><p id="9b73" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">最后，<strong class="kt io"> <em class="mj"> book.service.ts </em> </strong>服务简单地提供了<strong class="kt io"> findoById </strong>方法，该方法根据图书的<strong class="kt io"> ID </strong>从伪图书表中返回一本书。</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="340e" class="jv jw in mw b gy na nb l nc nd">import { Injectable } from '@nestjs/common';<br/><br/>export interface Book {<br/>  id: number;<br/>  title: string;<br/>}<br/><br/>@Injectable()<br/>export class BookService {<br/>  private static _books: Array&lt;Book&gt; = [<br/>    {<br/>      id: 1,<br/>      title: 'Nest.js: A Progressive Node.js Framework (English Edition)',<br/>    },<br/>    { id: 2, title: 'NestJS Build a RESTFul CRUD API' },<br/>    { id: 3, title: 'Pratical Nest.js' },<br/>  ];<br/><br/>  findById(id: number): Book {<br/>    return BookService._books.find((book) =&gt; book.id === id);<br/>  }<br/>}</span></pre><h2 id="3ba3" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">执行 API</h2><p id="2bf0" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">使用以下命令运行 API 时:</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="f5c9" class="jv jw in mw b gy na nb l nc nd"># Run the NestJS server application<br/>$ nest start</span></pre><p id="4a42" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">您将在控制台上看到以下消息:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/a612d558582e82a6b03d66881b609a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uw1euxx3fm8VNBwP.png"/></div></div></figure><p id="98a6" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">简单又干净。现在让我们把事情复杂化一点。</p><h2 id="0ee4" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">带动态模块加载的<strong class="ak">版本</strong></h2><p id="874d" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">NestJS 本身实现了模块<a class="ae lm" href="https://docs.nestjs.com/fundamentals/lazy-loading-modules" rel="noopener ugc nofollow" target="_blank"><strong class="kt io"/></a>的延迟加载，允许您在启动时不必加载所有模块。</p><p id="a59f" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">我们在这里提议的不是这个。我们在启动时加载它，但不需要手动加载每个模块。</p><p id="fabc" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">为了动态加载模块，我们使用<a class="ae lm" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> GLOBs </strong> </a>在某个子目录中查找模块，并使用本机函数<strong class="kt io"> <em class="mj"> import() </em> </strong>从相应的 JS 文件中加载并提取模块(记住，这是在运行时加载的，我们不再处于 TS 环境中)。</p><p id="21a0" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">更改原始项目后，我们有以下更改:</p><h2 id="9979" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">T23】app . module . tsT25】</strong></h2><p id="01e2" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">根模块<strong class="kt io"><em class="mj">app . module . ts</em></strong>的主要变化有:</p><ul class=""><li id="69ec" class="ls lt in kt b ku ln ky lo ke lu ki lv km lw ll lx ly lz ma bi translated">不再显式加载实体单元模块(书籍和电影)。</li><li id="5dce" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated">我们提供了一个<strong class="kt io"><em class="mj">app . service . ts</em></strong>只是为了在动态模块加载时接收一个事件，并显示在控制台中。</li><li id="d5dd" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated">我们使用我们的动态模块加载器(<strong class="kt io"><em class="mj">ModuleLoaderModule</em></strong>)的<strong class="kt io"> <em class="mj">寄存器</em> </strong>方法，通过指定一个选项参数，该参数带有关于在哪里动态加载模块的信息。</li></ul><p id="9ac2" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">我们有以下源代码:</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="edd4" class="jv jw in mw b gy na nb l nc nd">import { Module } from '@nestjs/common';<br/>import { EventEmitterModule } from '@nestjs/event-emitter';<br/>import * as path from 'path';<br/>import { AppService } from './app.service';<br/>import { ModuleLoaderModule } from './common/module-loader.module';<br/><br/>@Module({<br/>  imports: [<br/>    EventEmitterModule.forRoot({ wildcard: true }),<br/>    /**<br/>     * Load all entity unit modules in subdirectory /db/entity<br/>     */<br/>    ModuleLoaderModule.register({<br/>      name: 'db-entities',<br/>      /**<br/>       * Make sure the path resolves to the **DIST** subdirectory, (we are no longer in TS land but JS land!)<br/>       */<br/>      path: path.resolve(__dirname, './db/entity'),<br/>      fileSpec: '**/*.module.js',<br/>    }),<br/>  ],<br/>  providers: [AppService],<br/>})<br/>export class AppModule {}</span></pre><h2 id="4bfb" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">动态模块加载器</h2><p id="4c33" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">在<strong class="kt io"><em class="mj">/公共</em> </strong>子目录中，我们有三个新的源来执行动态加载服务:</p><ul class=""><li id="f783" class="ls lt in kt b ku ln ky lo ke lu ki lv km lw ll lx ly lz ma bi translated"><strong class="kt io"><em class="mj">module-loader-defs . ts</em></strong>—该文件包含动态加载模块使用的定义。</li><li id="3221" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated"><strong class="kt io"><em class="mj">module-loader . service . ts</em></strong>—只在模块动态加载结束时发出一个事件。</li><li id="3cb4" class="ls lt in kt b ku mb ky mc ke md ki me km mf ll lx ly lz ma bi translated"><strong class="kt io"><em class="mj">【module-loader . module . ts</em></strong>——实际上是做脏活的。</li></ul><h2 id="a97a" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">模块加载器定义</strong></h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="addc" class="jv jw in mw b gy na nb l nc nd">import { ModuleRef } from '@nestjs/core';<br/><br/>/**<br/> * Constants used in ModuleLoader implementation<br/> */<br/>export const MODULE_LOADER_OPTIONS = 'MODULE_LOADER_OPTIONS';<br/>export const MODULE_LOADER_NAMES = 'MODULE_LOADER_NAMES';<br/>export const MODULE_LOADER = 'MODULE_LOADER';<br/>export const EV_MODULE_DYN_LOADER = 'EV_MODULE_DYN_LOADER.';<br/><br/>/**<br/> * Options interface for ModuleLoaderModule.register<br/> */<br/>export interface IModuleLoaderOptions {<br/>  /**<br/>   * Name of modules<br/>   */<br/>  name: string;<br/>  /**<br/>   * Path's modules to load<br/>   */<br/>  path: string;<br/>  /**<br/>   * Depth to search modules inside of directories's path<br/>   * default: -1 (INFINITY) - searches in root path only<br/>   */<br/>  depht?: number;<br/>  /**<br/>   * File spec to match - accepts globs and list of globs/file names<br/>   * default: '*.module.ts'<br/>   */<br/>  fileSpec?: string | Array&lt;string&gt;;<br/>  /**<br/>   * File spec to ignore - accepts globs and list of globs/file names<br/>   */<br/>  ignoreSpec?: string | Array&lt;string&gt;;<br/>}<br/><br/>/**<br/> * Event type fired when modules are loaded<br/> */<br/>export interface IModuleDynLoaderEvent {<br/>  name: string;<br/>  moduleNames?: Array&lt;string&gt;;<br/>  error?: Error | string;<br/>}</span></pre><h2 id="eea3" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">module-loader . service . ts</strong></h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="1ccd" class="jv jw in mw b gy na nb l nc nd">import { Injectable, Inject, Scope, OnModuleInit } from '@nestjs/common';<br/>import {<br/>  MODULE_LOADER_OPTIONS,<br/>  MODULE_LOADER_NAMES,<br/>  EV_MODULE_DYN_LOADER,<br/>  IModuleLoaderOptions,<br/>} from './module-loader-defs';<br/>import { EventEmitter2 } from '@nestjs/event-emitter';<br/>import { nextTick } from 'process';<br/><br/>@Injectable({<br/>  scope: Scope.TRANSIENT,<br/>})<br/>export class ModuleLoaderService implements OnModuleInit {<br/>  constructor(<br/>    @Inject(MODULE_LOADER_OPTIONS) private _options: IModuleLoaderOptions,<br/>    @Inject(MODULE_LOADER_NAMES) private _moduleNames: Array&lt;string&gt;,<br/><br/>    private eventEmitter: EventEmitter2,<br/>  ) {}<br/><br/>  /**<br/>   * @description Emmits as events when modules are loaded<br/>   */<br/>  onModuleInit() {<br/>    nextTick(() =&gt; {<br/>      const eventName = EV_MODULE_DYN_LOADER + this._options.name;<br/>      this.eventEmitter.emit(eventName, {<br/>        name: this._options.name,<br/>        moduleNames: this._moduleNames,<br/>      });<br/>    });<br/>  }<br/>}</span></pre><h2 id="25ec" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">module-loader . service . ts</strong></h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="4622" class="jv jw in mw b gy na nb l nc nd">import { Logger, Module, DynamicModule } from '@nestjs/common';<br/>import * as fb from 'fast-glob';<br/>import * as path from 'path';<br/>import { ModuleLoaderService } from './module-loader.service';<br/>import {<br/>  MODULE_LOADER,<br/>  MODULE_LOADER_OPTIONS,<br/>  MODULE_LOADER_NAMES,<br/>  IModuleLoaderOptions,<br/>} from './module-loader-defs';<br/><br/>export const moduleLoaderFactory = {<br/>  provide: MODULE_LOADER,<br/>  useFactory: (moduleLoaderService: ModuleLoaderService) =&gt; {},<br/>  inject: [ModuleLoaderService],<br/>};<br/><br/>interface IModuleInfo {<br/>  name: string;<br/>  module: DynamicModule;<br/>}<br/><br/>/**<br/> * @description helper static class to load modules dynamically.<br/> */<br/>class InternalModuleLoader {<br/>  static readonly logger = new Logger(InternalModuleLoader.name);<br/><br/>  /**<br/>   * @param _options for GLOB searches<br/>   * @returns a Promise thats resolves to a list of name and module references based on _options filespec<br/>   */<br/>  static async loadModules(<br/>    _options: IModuleLoaderOptions,<br/>  ): Promise&lt;Array&lt;IModuleInfo&gt;&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      this.getModuleFileNames(_options).then((filePaths: Array&lt;string&gt;) =&gt; {<br/>        if (filePaths.length == 0) {<br/>          resolve([]);<br/>        } else {<br/>          const loadedModules: Array&lt;Promise&lt;any&gt;&gt; = filePaths.map((filePath) =&gt;<br/>            this.loadModule(filePath),<br/>          );<br/>          if (loadedModules.length === 0) {<br/>            resolve([]);<br/>          } else {<br/>            const moduleInfos: Array&lt;IModuleInfo&gt; = new Array();<br/>            Promise.all(loadedModules).then((modules: Array&lt;any&gt;) =&gt; {<br/>              for (let i = 0; i &lt; modules.length; i++) {<br/>                let module = modules[i];<br/>                const moduleField = Object.keys(module).find(<br/>                  (key) =&gt; key.indexOf('Module') &gt;= 0,<br/>                );<br/>                if (moduleField) {<br/>                  moduleInfos.push({<br/>                    name: moduleField,<br/>                    module: module[moduleField],<br/>                  });<br/>                }<br/>              }<br/>              resolve(moduleInfos);<br/>            });<br/>          }<br/>        }<br/>      });<br/>    });<br/>  }<br/><br/>  /**<br/>   * @description Uses native import() to dynamicly load a module<br/>   * @param modulePath<br/>   * @returns a Promise thats resolves to module loaded<br/>   */<br/>  private static async loadModule(modulePath: string): Promise&lt;any&gt; {<br/>    return import(modulePath);<br/>  }<br/><br/>  /**<br/>   * @description Uses FatsGlob to load the filenames for the modules<br/>   * @param _options for GLOB searches<br/>   * @returns a list of module's file paths<br/>   */<br/>  private static async getModuleFileNames(<br/>    _options: IModuleLoaderOptions,<br/>  ): Promise&lt;Array&lt;string&gt;&gt; {<br/>    const spec: Array&lt;string&gt; = (<br/>      typeof _options.fileSpec === 'string'<br/>        ? [_options.fileSpec]<br/>        : _options.fileSpec<br/>    ).map((fileSpec) =&gt; path.join(_options.path, fileSpec));<br/>    let options: fb.Options = {<br/>      onlyFiles: true,<br/>    };<br/>    if (_options.depht) {<br/>      options.deep = _options.depht &lt; 0 ? Infinity : _options.depht;<br/>    }<br/>    if (_options.ignoreSpec) {<br/>      options.ignore = Array.isArray(_options.ignoreSpec)<br/>        ? _options.ignoreSpec<br/>        : [_options.ignoreSpec];<br/>    }<br/>    this.logger.log(`**Module Loader FileSpec**: "${spec}"`);<br/><br/>    return fb(spec, options);<br/>  }<br/>}<br/><br/>@Module({})<br/>export class ModuleLoaderModule {<br/>  /**<br/>   * @description Load Modules dynamically via GLOBs and native import() function.<br/>   * @param moduleLoaderOptions options for GLOB searches<br/>   */<br/>  public static async register(<br/>    moduleLoaderOptions: IModuleLoaderOptions,<br/>  ): Promise&lt;DynamicModule&gt; {<br/>    const moduleInfos = await InternalModuleLoader.loadModules(<br/>      moduleLoaderOptions,<br/>    );<br/>    const modules = moduleInfos.map((moduleInfo) =&gt; moduleInfo.module);<br/>    const moduleNames = moduleInfos.map((moduleInfo) =&gt; moduleInfo.name);<br/><br/>    return {<br/>      module: ModuleLoaderModule,<br/>      imports: [...modules],<br/>      providers: [<br/>        {<br/>          provide: MODULE_LOADER_OPTIONS,<br/>          useValue: moduleLoaderOptions,<br/>        },<br/>        {<br/>          provide: MODULE_LOADER_NAMES,<br/>          useValue: moduleNames,<br/>        },<br/>        ModuleLoaderService,<br/>        moduleLoaderFactory,<br/>      ],<br/>    };<br/>  }<br/>}</span></pre><p id="0094" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">使用以下命令运行 API 时:</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="1860" class="jv jw in mw b gy na nb l nc nd"># Run the NestJS server application<br/>$ nest start</span></pre><p id="0e4f" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">您将在控制台上看到以下消息(<em class="mj">注意，图书和电影实体单元的模块被正确地动态加载了</em>):</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/227bc7a100878b3cf2534bba55f2002a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RC23VYicAQCmUoMr.png"/></div></div></figure><h2 id="e28d" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">运行本教程中的示例</h2><h2 id="51ef" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">装置</h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="a258" class="jv jw in mw b gy na nb l nc nd"># Clone tutorial repository<br/>$ git clone https://github.com/maceto2016/NestJSDynLoad<br/><br/># access the project folder through the terminal<br/>$ cd NestJSDynLoad<br/><br/># Install dependencies<br/>$ npm install</span></pre><h2 id="9906" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">运行应用程序(从 NestJSDynLoad 文件夹)</h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="1b6e" class="jv jw in mw b gy na nb l nc nd"># Run the NestJS server application<br/>$ nest start</span></pre><h2 id="b25a" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试应用程序</h2><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="637e" class="jv jw in mw b gy na nb l nc nd"># Get book with id = 1<br/>$ curl http://localhost:3000/book?id=1 | json_pp</span></pre><h2 id="8aea" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h2><p id="eae3" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">在本教程中，我们对构建良好的 NestJS 框架做了一个简单的介绍。</p><p id="85ea" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">我们演示了如何将给定子目录中的所有模块动态加载到您的 NestJS 应用程序中，而不需要您在代码中手动引用这些模块。这在某些情况下是可行的。</p><p id="ef33" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">本文中使用的原则允许各种实现，包括您自己版本的模块延迟加载。</p><p id="e4a4" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">您是否可以使用 NestJS ConfigService 来实现<strong class="kt io"> <em class="mj"> registerAsync </em> </strong>版本，以便从 env 文件中定义的 fileSpec 加载文件列表？</p><p id="8e42" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">由你决定！</p><p id="e1ba" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">感谢您的阅读。我很高兴听到你的反馈！</p></div></div>    
</body>
</html>