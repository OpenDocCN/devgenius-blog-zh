<html>
<head>
<title>JAVA 16 And 17: Evolutions and new features — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA 16 和 17:发展和新特性—第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-16-and-17-evolutions-and-new-features-part-1-d008e1d8f6de?source=collection_archive---------6-----------------------#2022-03-06">https://blog.devgenius.io/java-16-and-17-evolutions-and-new-features-part-1-d008e1d8f6de?source=collection_archive---------6-----------------------#2022-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bbc1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个 Java 开发者都应该知道的 Java 版本进化链。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/549383ff9041d10881d6cc104430df7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ka6U4If-bhPk47uWHGOAYA.png"/></div></div></figure><p id="f011" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“Java 17 已经来了！呃…我们又要迁徙了吗？选择哪个版本？迁移到 Java X 或者最新的 LTS 版本？”。</p><p id="5dcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，一段时间以来，Oracle 一直在加快发布 Java 更新的步伐，以便开发人员可以依靠可预测的发布时间表。为了不断提高语言的性能、稳定性和安全性，每六个月发布一个新版本。另一方面，开发人员必须跟上新语言的发展，以便作为 it 专业人员充分利用它。</p><p id="d1b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将介绍 JDK 16 &amp; 17 提供的新特性和语言改进。</p><blockquote class="ln lo lp"><p id="c7a0" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">如果你想对从 JAVA 9 到 JAVA 15 的演进有一个大概的了解，<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/from-java-9-to-java-15-evolutions-and-new-features-part-1-c249947b7513">你可以参考这篇文章</a>。</p></blockquote><h1 id="8815" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">JAVA 16:</h1><h2 id="1d53" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">1.Stream.toList()</h2><p id="6259" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">从 Java 8 开始，我们经常调用终端操作。collect(Collectors.toList())。这种相当常见的做法看起来像样板代码。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="27cd" class="mn lw iq nf b gy nj nk l nl nm">List&lt;String&gt; colors = Stream.of("Blue ", "Yellow", "RED")<br/>                            .map(String::toLowerCase)<br/>                            .filter(s -&gt; s.contains(" "))<br/>                            .collect(Collectors.toList());</span></pre><p id="19b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 Java 16 中，一个新的 toList()终端操作已被添加到流 API 中，这将允许我们替换前面的代码，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4599" class="mn lw iq nf b gy nj nk l nl nm">List&lt;String&gt; colors = Stream.of("Blue ", "Yellow", "RED")<br/>                            .map(String::toLowerCase)<br/>                            .filter(s -&gt; s.contains(" "))<br/>                            .toList();</span></pre><p id="8eff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，这里应该注意两种操作之间的区别:</p><p id="e209" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nf b">Stream.toList()</code>返回一个不可变的列表(不能改变，排序…)。该列表上的任何<code class="fe nn no np nf b">add()</code>、<code class="fe nn no np nf b">sort()</code> …类型操作返回<code class="fe nn no np nf b">java.lang.UnsupportedOperationException</code>。</p><p id="2dd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不像<code class="fe nn no np nf b">Stream.collect(Collectors.toList())</code>返回一个可变的数组列表(可以改变，排序…)。</p><h2 id="93b2" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">2.Stream.mapMulti()</h2><p id="3469" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated"><strong class="kt ir">Java 16 中引入的 mapMulti() </strong>，是一个中间流操作，允许用多个元素替换流中的元素。</p><p id="816e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nf b">&lt;R&gt; Stream&lt;R&gt; mapMulti(BiConsumer&lt;T, Consumer&lt;R&gt;&gt; mapper)</code></p><p id="0405" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个方法与<code class="fe nn no np nf b">Stream::flatMap</code>相似，它将一对多转换应用于流的元素，并将结果元素展平为一个新的流。</p><p id="1a5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在以下情况下，此方法优于<strong class="kt ir">平面图</strong>:</p><ul class=""><li id="36b5" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">当用少量(可能为零)元素替换每个流元素时。使用这种方法避免了为每组结果项创建新的<strong class="kt ir">流</strong>实例的开销，正如<strong class="kt ir">平面图</strong>所要求的。</li><li id="2c77" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">当使用命令式方法生成结果项比将它们作为<strong class="kt ir">流</strong>返回更容易时。</li></ul><p id="5807" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="dbba" class="mn lw iq nf b gy nj nk l nl nm">Stream.of("Lion", "Jaguar", "Tiger").mapMulti((dtr, consumer) -&gt; {<br/>consumer.accept(str.toUpperCase()); consumer.accept(str.toLowerCase());}).forEach(System.out::println);</span><span id="7abe" class="mn lw iq nf b gy oe nk l nl nm">Output:</span><span id="300e" class="mn lw iq nf b gy oe nk l nl nm">LION<br/>lion<br/>JAGUAR<br/>jaguar<br/>TIGER<br/>tiger</span></pre><h2 id="2533" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">3.记录</h2><p id="77bd" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">Java 16 合并了以前在 Java 14 的 preview 中引入的记录终结。java 中的记录(java.lang.Record)是一种特殊形式的类，只包含数据(类似于数据库中元组的概念)。</p><p id="e6c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记录是<strong class="kt ir">不可变的</strong>，并且没有类似 setter 的方法。一旦记录用某些值实例化，就不能修改。记录类是最终的，因此可以很好地模拟数据类</p><p id="bc7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3ca5" class="mn lw iq nf b gy nj nk l nl nm">public record Person(String name, int age, String gender) { }</span></pre><p id="097e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">创纪录的好处？一旦我们有了一个记录的声明，我们就得到了一个类，它有一个隐式的规范构造函数来接受记录的所有组成部分的值。我们自动获取 equals()、hashCode()和 toString()方法的实现，以及记录中每个组件的访问器方法(参考上面的例子:name()、age()、gender())。</em></strong></p><p id="05cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，记录可用于创建数据传输对象(<strong class="kt ir"> DTO </strong> s)，因为这些对象不需要任何身份或行为，只用于传输数据。</p><p id="5915" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">记录可以:</strong></p><ul class=""><li id="770d" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">重定义构造函数:紧凑规范，完全规范，自定义。</li><li id="4f50" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">重新定义 equals()和 hashCode()。</li><li id="18a5" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">对生成的方法有自己的实现(必须<br/>遵守不变量/规则)。</li><li id="ddc6" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">有额外的方法。</li><li id="2418" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">拥有静态字段和方法。</li><li id="cbde" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">实现接口。</li><li id="aac5" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">泛泛而谈。</li></ul><p id="bc4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">记录不能:</strong></p><ul class=""><li id="9686" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">从其他类继承或被扩展。</li><li id="7f3c" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">有 setters。</li><li id="428a" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">拥有“额外的”实例字段。</li><li id="9f88" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">具有“不太明显”的规范构造函数。</li><li id="9e31" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">声明本机方法。</li><li id="6541" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">在紧凑构造函数中分配组件。</li><li id="c43b" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">没有 copy()方法。</li></ul><h2 id="81fe" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">4.使用实例的模式匹配</h2><p id="70ed" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">JDK 16 特别为<code class="fe nn no np nf b">instanceof</code>操作符集成了模式匹配(模式过滤)的终结。</p><p id="b73e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们经常编写程序，将使用<code class="fe nn no np nf b">instanceof</code>操作符的测试与显式强制转换结合起来，以便对正在讨论的对象进行进一步的处理。</p><p id="eb54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fbb4" class="mn lw iq nf b gy nj nk l nl nm">if (object instanceof Integer){<br/>   Integer i = (Integer) object;<br/>   if (i % 2 == 0)<br/>    System.out.println(" You’re an even number");<br/>}</span></pre><p id="149d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生了三件事:一个测试(对象是整数吗？)、转换(对象转换为整数)以及新局部变量(整数)的声明，因此出现了 3 次整数类型。</p><p id="c81c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个模型不是最优的。为了解决这个问题，Java 像许多语言一样采用了模式匹配，从<strong class="kt ir"> Haskell </strong>到<strong class="kt ir"> C# </strong>都采用了模式匹配，这是因为它的简洁和安全。</p><p id="c9c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模式匹配用于简明地表达对象的期望“形状”(模式)，并用于各种语句和表达式，以对照其输入来测试该“形状”(匹配)。因此，我们称之为智能转换(同时进行测试、声明和转换)。</p><p id="8bfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这给出了我们的例子:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="da0b" class="mn lw iq nf b gy nj nk l nl nm">if (object instanceof Integer i){<br/>   if (i % 2 == 0)<br/>      System.out.println(" You’re an even number");<br/>}</span></pre><p id="c9d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2074" class="mn lw iq nf b gy nj nk l nl nm">if (object instanceof Integer i &amp;&amp; i % 2 == 0){<br/>   System.out.println(" You’re an even number");<br/>}</span></pre><h2 id="d1bc" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">5.基于值的类(折旧)</h2><p id="a65a" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">基于值的类是表示不可变对象的类，这些对象的身份与类的行为无关。因此，它们是按值(equals())而不是按标识(==)进行比较的。</p><blockquote class="ln lo lp"><p id="63af" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">示例:整数、双精度等的包装器。基元</p></blockquote><p id="d8fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 java 16 中，会为这些类生成警告，并且不推荐使用它们的构造函数来鼓励删除它们。这一改进是 Valhalla 项目的一部分，旨在预测基于值的某些类的迁移，在未来版本中成为原始类。这种未来迁移的候选对象是:</p><ul class=""><li id="ba98" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">包装:{字节，短整型，长整型，浮点型，双精度型，布尔型，字符}</li><li id="5f60" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">java.util 中的“可选”类:optional、OptionalInt、OptionalLong 和 OptionalDouble</li><li id="57ef" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">java.time.{Instant，ZonedDateTime，Duration，…}中的许多类</li><li id="e824" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">List.of()、List.copyOf()、Set.of()、…、Map.entry()的实现</li><li id="cbe2" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">任何具有 jdk.internal. <a class="ae lu" href="http://twitter.com/ValueBase" rel="noopener ugc nofollow" target="_blank"> @ValueBase </a>注释的类</li></ul><p id="df22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于值的类的客户通常不会受到基本类迁移的影响，除非他们违反了那些类的使用建议。特别是，当在迁移发生的未来 Java 版本上运行时:</p><ul class=""><li id="3521" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">这些相等的类的实例(通过<strong class="kt ir">等于</strong>)也可以被认为是相同的(通过<strong class="kt ir"> == </strong>)，这有破坏依赖于一个<strong class="kt ir">！= </strong>)正确行为的结果。</li><li id="7e13" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">尝试用新的整数、新的双精度数等创建包装类实例。，而不是隐式装箱或调用 valueOf factory 方法，将产生 LinkageErrors 类型的异常。</li><li id="1325" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">尝试同步这些类的实例也会产生异常。</li></ul><h2 id="11ce" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">6.内存管理改进</h2><p id="4784" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">为了进一步提高性能，JDK 16 中引入了以下功能:</p><ul class=""><li id="19a0" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><strong class="kt ir">弹性元空间</strong></li></ul><p id="d6f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">-XX:metaspacereakpolicy =(平衡|主动|无)</p><p id="09c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">引入这一新选项的目的是允许操作系统更快地返回未使用的热点内存(即元空间)，减少元空间占用空间，并简化该空间中的代码以降低维护成本。</p><ul class=""><li id="483c" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><strong class="kt ir"> ZGC 垃圾收集器:线程堆栈的同时处理</strong></li></ul><p id="2554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从 Java 16 开始，为了减少花费在<strong class="kt ir">安全点</strong>内的时间，ZGC 垃圾收集器将 GC 线程栈的处理从<strong class="kt ir">安全点</strong>转移到并发阶段。</p><p id="b5a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这项工作消除了并发堆栈处理的最后一个重要瓶颈。我们谈论的是标准机器在<strong class="kt ir"> ZGC 安全点</strong>上花费的时间不到 1 毫秒。</p><h2 id="9c10" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated"><strong class="ak"> 7。网络改进:UNIX 域套接字通道</strong></h2><p id="6d87" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">为了提高开发人员的灵活性和生产力，除了套接字通道和服务器套接字通道<strong class="kt ir">API</strong>之外，Java 16 还集成了所有的<strong class="kt ir"> Unix </strong>域套接字特性(Windows 和更大的 Unix 平台通用的)。在<code class="fe nn no np nf b">java.nio.channels</code>包里。此外，Unix 域套接字用于同一主机上的<strong class="kt ir">进程间通信</strong> ( <strong class="kt ir"> IPC </strong>)。</p><p id="0bd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们与<strong class="kt ir"> TCP/IP </strong>套接字非常相似，除了它们由文件系统路径名而不是<strong class="kt ir">互联网协议</strong> ( <strong class="kt ir"> IP </strong>)地址和端口号来寻址。</p><h2 id="9eaa" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">8.打包工具:<code class="fe nn no np nf b"><strong class="ak">jpackage</strong></code></h2><p id="c50e" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">工具<code class="fe nn no np nf b"><strong class="kt ir">jpackage</strong></code>，是一个打包自包含 Java 应用程序的工具。这意味着这个包包含了所有必要的依赖项以及一个 Java 运行时环境。应用程序可以作为常规<strong class="kt ir"> JAR </strong>文件的集合或者模块的集合来交付。支持的特定于平台的包格式有:</p><ul class=""><li id="1144" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated">Linux : <strong class="kt ir"> debetrpm </strong></li><li id="8305" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">macOS : <strong class="kt ir"> pkgetdmg </strong></li><li id="5a27" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">windows:<strong class="kt ir">msietex</strong></li></ul><p id="fdf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><p id="10d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用非模块化应用</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="21e6" class="mn lw iq nf b gy nj nk l nl nm">$ jpackage –name myapp –input lib –main-jar main.jar \ –main-class myapp.Main</span></pre><p id="8a3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用模块化应用</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9809" class="mn lw iq nf b gy nj nk l nl nm">$ jpackage –name myapp –module-path lib -m myapp/myapp.Main</span></pre><h2 id="a625" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">9.启用 C++14 语言</h2><p id="5073" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">该功能的目的是正式授权对<strong class="kt ir"> JDK </strong>中的<strong class="kt ir"> C++ </strong>源代码进行更改，以利用<strong class="kt ir"> C++14 </strong>语言功能，并提供关于如何在<strong class="kt ir">热点</strong>代码中使用这些功能的清晰说明。</p><p id="399a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在即将发表的第二篇文章中讨论<strong class="kt ir"> JAVA 17 </strong>的发展和新颖之处，订阅我们的时事通讯，当有新文章发布时我们会通知您。</p><p id="e1cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一部:<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/java-16-and-17-evolutions-and-new-features-part-2-f2eb30c89a80">第二部</a>。</p></div></div>    
</body>
</html>