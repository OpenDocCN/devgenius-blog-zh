<html>
<head>
<title>Moving Averages using Akka Streams - Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Akka流的移动平均线-第1部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/calculating-moving-averages-using-akka-streams-a9844acf9527?source=collection_archive---------6-----------------------#2021-12-04">https://blog.devgenius.io/calculating-moving-averages-using-akka-streams-a9844acf9527?source=collection_archive---------6-----------------------#2021-12-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="943c" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">数据工程</h2><div class=""/><div class=""><h2 id="02b1" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">流市场数据的移动平均线函数计算指南</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5d123e7ae06ac8505ff867054224682f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BEZq5DQcssarhEWi"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@m_____me?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> m. </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="6646" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">Akka Streams是一个非常强大的流数据处理工具。它有一个参与者模型，可以在大型企业环境中管理反压力。这就是为什么我决定开发一个功能堆栈，它能够以非常高效的内存使用来处理流式市场数据。现在，让我们言归正传。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="7fbf" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这不是关于如何将数据接收到我们的管道中。从众多的交流中有大量的API。</p><p id="ed28" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">重要的事情先来。我们一个接一个地得到报价器，所以在第一步，我们需要得到数据，并在某个地方积累它们，以计算下一步移动的移动平均线。它有点像缓冲区，但缓冲区不会是不可变的；所以我们必须使用一个功能相当的缓冲器。我的想法是用一个演员状态。这个状态可以保存并返回移动平均线所需的tickers。</p><p id="4efd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这个有状态的参与者应该响应两个请求:获取状态和设置状态。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="6f6c" class="mk ml in mg b gy mm mn l mo mp">case object GetState<br/>case class SetState(newTicker: Int)<br/><br/>class StateActor(interval: Int) extends Actor {<br/>  override def receive: Receive = {<br/>    case GetState =&gt; sender() ! <em class="mq">List</em>[Int]()<br/>    case <em class="mq">SetState</em>(newTicker) =&gt; <br/>      <em class="mq">context</em>.become(Stateful(<em class="mq">List</em>[Int](newTicker)))<br/>  }<br/><br/>  def Stateful(tickers: List[Int]): Receive = {<br/>    case GetState =&gt; sender() ! tickers<br/>    case <em class="mq">SetState</em>(newTicker) =&gt;<br/>      if (tickers.length &gt;= interval)<br/>        <em class="mq">context</em>.become(Stateful(tickers.tail :+ newTicker))<br/>      else<br/>        <em class="mq">context</em>.become(Stateful(tickers :+ newTicker))<br/>  }<br/>}</span></pre><p id="dbc5" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这个actor被另一个正在等待新节拍的actor调用。我已经将这两个参与者分开，这样我们就可以从<code class="fe mr ms mt mg b">stateActor</code>获得状态数据，并运行我们的Akka流图。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="0c13" class="mk ml in mg b gy mm mn l mo mp">case class Tick(ticker: Int)</span><span id="3015" class="mk ml in mg b gy mu mn l mo mp">class EventActor(stateActor: ActorRef, <br/>  graph: Graph[FlowShape[List[Int], Float], NotUsed])<br/>  extends Actor with ActorLogging {<br/>  override def receive: Receive = {<br/>    case <em class="mq">Tick</em>(ticker) =&gt;<br/>      stateActor ! <em class="mq">SetState</em>(ticker)<br/>      stateActor ! GetState<br/>    case tickers: List[Int] =&gt;<br/>      <em class="mq">Source</em>(<em class="mq">List</em>(tickers))<br/>        .via(graph)<br/>        .runWith(Sink<br/>          .<em class="mq">foreach</em>[Float](x =&gt; <em class="mq">println</em>(s"New MA: <strong class="mg ix">$</strong>x"))<br/>        )<br/>  }<br/>}</span></pre><p id="54d8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我已经创建了一个<code class="fe mr ms mt mg b">Tick</code> case类，所以我将把来自源代码的新tickers发送到我的<code class="fe mr ms mt mg b">eventActor</code>。每一个ticker都会发送到<code class="fe mr ms mt mg b">stateActor</code>并改变状态。</p><p id="fe74" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在得到我们的窗口数据后，我们把它输入到我们的Akka Streams管道中，这样我们就可以得到我们的移动平均值。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="5207" class="mk ml in mg b gy mm mn l mo mp">val graph = GraphDSL.create() { implicit builder =&gt;<br/>  val aggregatorShape = builder<br/>    .add(<em class="mq">Flow</em>[List[Int]].map(x =&gt; <em class="mq">average</em>(x)))<br/>  val filterShape = builder<br/>    .add(<em class="mq">Flow</em>[List[Int]].filter(x =&gt; x.length &gt;= interval))<br/>  val broadcast = builder.add(<em class="mq">Broadcast</em>[List[Int]](2))<br/>  val printerShape = builder<br/>    .add(Sink.<em class="mq">foreach</em>[List[Int]](x =&gt; <br/>      <em class="mq">println</em>(s"Tuple for <strong class="mg ix">$</strong>name MA<strong class="mg ix">$</strong>interval: <strong class="mg ix">$</strong>x")))<br/><br/>  import GraphDSL.Implicits._<br/>  filterShape ~&gt; broadcast ~&gt; aggregatorShape<br/>  broadcast ~&gt; printerShape<br/><br/>  <em class="mq">FlowShape</em>(filterShape.in, aggregatorShape.out)<br/>}</span></pre><p id="1711" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这个图表将把我们的数据打印到控制台上。</p><p id="5a8d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我将所有这些步骤包装在一个函数中，这样我们就可以重用它们。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="173a" class="mk ml in mg b gy mm mn l mo mp">def newSource(name: String, interval: Int): ActorRef = {</span><span id="5cf9" class="mk ml in mg b gy mu mn l mo mp">  // GRAPH DEFINITION HERE</span><span id="7496" class="mk ml in mg b gy mu mn l mo mp">  val stateActor = <em class="mq">system</em>.actorOf(<em class="mq">Props</em>(<br/>    new StateActor(interval)), s"state<strong class="mg ix">$</strong>name"<br/>  )<br/>  val eventActor = <em class="mq">system</em>.actorOf(<em class="mq">Props</em>(<br/>    new EventActor(stateActor, graph)), s"event<strong class="mg ix">$</strong>name"<br/>  )<br/>  eventActor<br/>}</span></pre><p id="f902" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这段代码消除了每次计算移动平均值时从Kafka(或其他排队服务)获取数据的需要。<code class="fe mr ms mt mg b">name</code>参数用于给我们的演员起独特的名字。从这个actor返回的<code class="fe mr ms mt mg b">eventActor</code>将被源actor用来发送tickers以触发整个管道。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/743e2e3664b958e8a84538346716b331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVlVBcChcZkr_71DI4SZow.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">程序的流程图</figcaption></figure><p id="dc53" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在这里，您可以看到谁给谁打电话，以及如何检索信息。</p><p id="ec22" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">数据源在调用<code class="fe mr ms mt mg b">eventActor</code>的主线程上，然后<code class="fe mr ms mt mg b">eventActor</code>调用<code class="fe mr ms mt mg b">stateActor</code>更新状态。Next向<code class="fe mr ms mt mg b">stateActor</code>请求一个新状态，并将这个新状态发送到我们的Akka流图来处理它。</p><p id="1682" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在这里阅读第2部分<a class="ae lb" href="https://medium.com/@ali.t.asl/calculating-moving-averages-using-akka-streams-part-2-c41bb1699feb" rel="noopener">。</a></p></div></div>    
</body>
</html>