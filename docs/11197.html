<html>
<head>
<title>Exploring DDL/DML/CLONE Operation Impact on Snowflake Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索 DDL/DML/CLONE 操作对雪花存储的影响</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/exploring-ddl-dml-clone-operation-impact-on-snowflake-storage-8f4804ae5c43?source=collection_archive---------7-----------------------#2022-12-24">https://blog.devgenius.io/exploring-ddl-dml-clone-operation-impact-on-snowflake-storage-8f4804ae5c43?source=collection_archive---------7-----------------------#2022-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c4fe18a954fb5f43efa74edf5dfc0d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xU7hP0k9nqdPC-ID"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@girlwithredhat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴红帽的女孩</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ab36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，我们将对普通表和克隆表进行各种 DDL 和 DML 操作，观察其对存储的影响，并尝试探索哪些操作会影响存储开销，以及在实际项目实施过程中需要注意哪些操作。这个博客更像是一个亲身实践的博客，而不是任何理论。希望这篇博客能帮助你理解我们的行动对雪花存储的影响。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="945e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">额外补贴</h1><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="75ca" class="mp lj iq ml b be mq mr l ms mt">ALTER ACCOUNT SET DATA_RETENTION_TIME_IN_DAYS=1;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/2f6e614e50b914845a40aaed375d9b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ackr0AQg0szd7O4hCnjaA.png"/></div></div></figure><h1 id="007d" class="li lj iq bd lk ll mv ln lo lp mw lr ls lt mx lv lw lx my lz ma mb mz md me mf bi translated">测试用例#1:创建测试设置</h1><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="eaa8" class="mp lj iq ml b be mq mr l ms mt">--Step 1 Create base table<br/><br/>CREATE  OR REPLACE TABLE EMPLOYEE (MEMBER_ID NUMBER, LASTNAME VARCHAR(50));<br/>INSERT INTO EMPLOYEE VALUES <br/>(1,'Choules' ),<br/>(2,'Aaronsohn'),<br/>(3,'Cotherill'),<br/>(4,'Grewer' ),<br/>(5,'Mammatt');<br/><br/><br/>--Step 2 : Create employee clone<br/><br/>Create table EMPLOYEE_CLONE1 clone EMPLOYEE;<br/><br/>--Step 3 : Create employee2 clone from clone EMPLOYEE_CLONE1<br/><br/>Create table EMPLOYEE_CLONE2 clone EMPLOYEE_CLONE1;<br/><br/>--Step 4: Create duplicate employee table without clone for insert test<br/><br/>CREATE  OR REPLACE TABLE EMPLOYEE_INSERT (MEMBER_ID NUMBER, LASTNAME VARCHAR(50));<br/>INSERT INTO EMPLOYEE_INSERT VALUES <br/>(1,'Choules' ),<br/>(2,'Aaronsohn'),<br/>(3,'Cotherill'),<br/>(4,'Grewer' ),<br/>(5,'Mammatt');<br/><br/>--Step 5: Create duplicate employee table without clone for update test<br/><br/>CREATE  OR REPLACE TABLE EMPLOYEE_UPD (MEMBER_ID NUMBER, LASTNAME VARCHAR(50));<br/>INSERT INTO EMPLOYEE_UPD VALUES <br/>(1,'Choules' ),<br/>(2,'Aaronsohn'),<br/>(3,'Cotherill'),<br/>(4,'Grewer' ),<br/>(5,'Mammatt');<br/></span></pre><pre class="na mk ml mm bn mn mo bi"><span id="f896" class="mp lj iq ml b be mq mr l ms mt">USE SCHEMA STORAGE_DEMO.DATA;<br/><br/>--This table take 30-45 min to start showing storage bytes<br/><br/>SELECT * FROM INFORMATION_SCHEMA.TABLE_STORAGE_METRICS <br/>WHERE TABLE_CATALOG='STORAGE_DEMO' <br/>AND CATALOG_DROPPED IS NULL  <br/>ORDER BY CLONE_GROUP_ID;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/ab6ec881e4c75da09bd28a1e5e531f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMib5lkYg-ualaDHp01zyg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图像 0</figcaption></figure><h2 id="a57a" class="nc lj iq bd lk nd ne dn lo nf ng dp ls ko nh ni lw ks nj nk ma kw nl nm me nn bi translated">观察:</h2><ol class=""><li id="90fe" class="no np iq kf b kg nq kk nr ko ns ks nt kw nu la nv nw nx ny bi translated">所有的表都有相同的 5 行，其中 2 个表是从 Employee 表克隆的，没有活动字节，因为它引用了 Employee 表分区。</li><li id="67e4" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">CLONE_GROUP_ID 列引用了两个克隆表 EMPLOYEE_CLONE1 和 EMPLOYEE_CLONE2 的员工表 ID，而不管它是从克隆表中克隆的。</li><li id="6267" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">目前，没有一个表在时间旅行或故障安全列中有任何存储字节。</li><li id="cf6c" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">员工的存储呈现将需要一些时间，因为填充此视图会有一些延迟。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="43ac" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">测试用例 2:表上的 DML/Drop 操作并测试输出</h1><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="c85a" class="mp lj iq ml b be mq mr l ms mt">--Create new clone3 from clone 2 table<br/>Create table EMPLOYEE_CLONE3 clone EMPLOYEE_CLONE2;<br/><br/>--Insert data into clone2 table<br/>INSERT INTO EMPLOYEE_CLONE2 VALUES <br/>(6,'New data' );<br/><br/>--Update 1 rows only first<br/>update EMPLOYEE_UPD<br/>set LASTNAME='x' where MEMBER_ID=5;<br/><br/>--Update all rows from EMPLOYEE_UPD<br/>update EMPLOYEE_UPD<br/>set LASTNAME='a';<br/><br/>--Delete all rows from EMPLOYEE_INSERT<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=5;<br/><br/>--Delete all rows from EMPLOYEE_INSERT<br/>Delete from EMPLOYEE_INSERT;<br/><br/>--DROP CLONE3<br/>DROP TABLE EMPLOYEE_CLONE3;</span></pre><pre class="na mk ml mm bn mn mo bi"><span id="9d41" class="mp lj iq ml b be mq mr l ms mt">USE SCHEMA STORAGE_DEMO.DATA;<br/><br/>--This table take some time render storage bytes, its not immediate<br/><br/>SELECT * FROM INFORMATION_SCHEMA.TABLE_STORAGE_METRICS <br/>WHERE TABLE_CATALOG='STORAGE_DEMO' <br/>AND CATALOG_DROPPED IS NULL  <br/>ORDER BY CLONE_GROUP_ID;</span></pre><h2 id="38fc" class="nc lj iq bd lk nd ne dn lo nf ng dp ls ko nh ni lw ks nj nk ma kw nl nm me nn bi translated">观察:</h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/545e3821128a9edde64d6dedc8670909.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*svrmOrE5SFC27yycLumgeQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片 1</figcaption></figure><ol class=""><li id="7449" class="no np iq kf b kg kh kk kl ko of ks og kw oh la nv nw nx ny bi translated">如上图 1 所示，员工&amp; EMPLOYEE_CLONE1 没有变化。EMPLOYEE_CLONE3 已删除。EMPLOYEE_CLONE2 又插入了 1 条记录。EMPLOYEE_INSERT 所有记录已被删除，EMPLOYEE_UPD 已用常数值更新了所有记录。</li></ol><p id="c51c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.下图 2 显示了上述 dml/drop 操作对存储的影响。未更改员工&amp; EMPLOYEE_CLONE1，其中 EMPLOYEE_CLONE1 仍然没有任何有效字节，因为它仍在参考基表。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/bc0698e99be5c16ba5965ac867bea5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qCeCl7TaDtGulFozFoKQg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片 2</figcaption></figure><p id="1ed0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.EMPLOYEE_CLONE2 克隆表现在有了新的分区，并在插入新记录后拥有了新的生命周期。因为它被插入了，所以你在时间旅行或自动防故障中还看不到任何字节。</p><p id="135a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.EMPLOYEE_CLONE3 表在经过 1 天的时间旅行后进入故障安全期。因为它没有任何自己的分区，所以您不会在任何列中看到任何字节。</p><p id="058d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.因为我们已经从 EMPLOYEE_INSERT 表中删除了所有数据，所以所有分区字节现在都已经从时间旅行转移到故障安全区。你可能会想，为什么在失效保护中看到的是双字节，而不是上面的活动字节。这是因为我首先删除了 1 行，然后删除了所有剩余的行。</p><p id="4ed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.自从我们更新了 EMPLOYEE_UPD 表，现在我们可以看到新分区的活动字节数，我们还可以看到旧分区现在已经从时间旅行转移到故障保护。你可能会想，为什么在失效保护中看到的是双字节，而不是上面的活动字节。这是因为我首先更新了 1 行，然后更新了所有剩余的行。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3385" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">测试用例 3:删除 EMPLOYEE &amp; EMPLOYEE_CLONE2 表并测试输出。</h1><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="7fa0" class="mp lj iq ml b be mq mr l ms mt">--Update the data retention for account to 0 days<br/><br/>ALTER ACCOUNT SET DATA_RETENTION_TIME_IN_DAYS=0;<br/><br/>SHOW PARAMETERS LIKE 'DATA_RETENTION_TIME_IN_DAYS' IN ACCOUNT;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/0d9c214d1f11b99204c8081ce52de271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QP6cj0U9-sNwHeFRufYgcg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 3</figcaption></figure><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="2b11" class="mp lj iq ml b be mq mr l ms mt">--Drop table.<br/><br/>DROP TABLE EMPLOYEE;<br/><br/>DROP TABLE EMPLOYEE_CLONE2;        </span></pre><pre class="na mk ml mm bn mn mo bi"><span id="e6e2" class="mp lj iq ml b be mq mr l ms mt">SELECT <br/>TABLE_NAME,<br/>ACTIVE_BYTES,<br/>TIME_TRAVEL_BYTES,<br/>FAILSAFE_BYTES,<br/>RETAINED_FOR_CLONE_BYTES,<br/>TABLE_DROPPED,<br/>TABLE_ENTERED_FAILSAFE,<br/>ID,<br/>CLONE_GROUP_ID<br/>FROM INFORMATION_SCHEMA.TABLE_STORAGE_METRICS <br/>WHERE TABLE_CATALOG='STORAGE_DEMO'<br/>AND CATALOG_DROPPED IS NULL  <br/>ORDER BY TABLE_NAME;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/4e6a960e44a15fcec40c3a4de53870d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQD5rzrrkffwSa09IWjuEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 4-渲染前分区移动。</figcaption></figure><p id="2e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> V/S </strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/d3133fd6e955fa262f756897a7c23e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WuuDrT9G1u3BD1PVv3-Fw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 5 —渲染后分区移动。</figcaption></figure><h2 id="e653" class="nc lj iq bd lk nd ne dn lo nf ng dp ls ko nh ni lw ks nj nk ma kw nl nm me nn bi translated">观察:</h2><ol class=""><li id="053a" class="no np iq kf b kg nq kk nr ko ns ks nt kw nu la nv nw nx ny bi translated">图 4 是元数据表查询的输出，它显示员工&amp; EMPLOYEE_CLONE2 都已被删除，但将存储字节呈现为故障安全需要时间。</li><li id="9543" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">图 5 是元数据表查询的输出，显示员工&amp; EMPLOYEE_CLONE2 都已被删除。</li><li id="4fad" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">EMPLOYEE_CLONE2 拥有的分区字节目前处于故障安全状态，不久(7 天)它将在雪花中不可恢复。</li><li id="464b" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">EMPLOYEE 表拥有的分区字节当前被保留用于克隆字节。employee 表拥有的(并向其开单的)字节，这些字节在删除后保留，因为它们被该表的一个或多个副本引用。</li></ol><h1 id="31c7" class="li lj iq bd lk ll mv ln lo lp mw lr ls lt mx lv lw lx my lz ma mb mz md me mf bi translated">测试案例#4:高流失率对存储的影响。</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/82d133442c2b3a04a92911404819ba79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Wf7JRilgfw0ra7QMXHebg.png"/></div></div></figure><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="a814" class="mp lj iq ml b be mq mr l ms mt">--Insert data into EMPLOYEE_INSERT table<br/>INSERT INTO EMPLOYEE_INSERT VALUES <br/>(1,'Choules' ),<br/>(2,'Aaronsohn'),<br/>(3,'Cotherill'),<br/>(4,'Grewer' ),<br/>(5,'Mammatt'),<br/>(6,'New data' );<br/><br/>--Delete 1 row at a time from EMPLOYEE_INSERT<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=1 ;<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=2 ;<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=3 ;<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=4 ;<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=5 ;<br/>Delete from EMPLOYEE_INSERT where MEMBER_ID=6 ;<br/><br/>--Update 1 row at a time from EMPLOYEE_UPD<br/>update EMPLOYEE_UPD set LASTNAME='adad' where MEMBER_ID=1 ;<br/>update EMPLOYEE_UPD set LASTNAME='nhnh' where MEMBER_ID=2 ;<br/>update EMPLOYEE_UPD set LASTNAME='zczc' where MEMBER_ID=3 ;<br/>update EMPLOYEE_UPD set LASTNAME='xxcc' where MEMBER_ID=4 ;<br/>update EMPLOYEE_UPD set LASTNAME='zxzs' where MEMBER_ID=5 ;<br/>update EMPLOYEE_UPD set LASTNAME='saas' where MEMBER_ID=6 ;<br/><br/>--Delete 1 row at a time from EMPLOYEE_UPD<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=1 ;<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=2 ;<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=3 ;<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=4 ;<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=5 ;<br/>Delete from EMPLOYEE_UPD where MEMBER_ID=6 ;<br/><br/>--Drop all table now<br/>DROP TABLE EMPLOYEE_INSERT;<br/><br/>DROP TABLE EMPLOYEE_UPD;<br/><br/>DROP TABLE EMPLOYEE_CLONE1;</span></pre><pre class="na mk ml mm bn mn mo bi"><span id="db53" class="mp lj iq ml b be mq mr l ms mt">SELECT <br/>TABLE_NAME,<br/>ACTIVE_BYTES,<br/>TIME_TRAVEL_BYTES,<br/>FAILSAFE_BYTES,<br/>RETAINED_FOR_CLONE_BYTES,<br/>TABLE_DROPPED,<br/>TABLE_ENTERED_FAILSAFE,<br/>ID,<br/>CLONE_GROUP_ID<br/>FROM INFORMATION_SCHEMA.TABLE_STORAGE_METRICS <br/>WHERE TABLE_CATALOG='STORAGE_DEMO'<br/>AND CATALOG_DROPPED IS NULL  <br/>ORDER BY TABLE_NAME;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/eb522242fd3e50ac3cbf5ae883c6165b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPMGsxFDuhK3lW7o7foijQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 6—渲染前分区移动。</figcaption></figure><p id="18b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> V/S </strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/f3cd4cb6ac4831977b2587c48bf62387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bv_dLrnukwXN9-KwxWlqZA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 7-渲染中的分区移动。</figcaption></figure><p id="ec68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> V/S </strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/a7343effc879c07405e8cdd96fbca34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpvem3lMCyAHYeocFtZ_YA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 8 —最终</figcaption></figure><h2 id="ef98" class="nc lj iq bd lk nd ne dn lo nf ng dp ls ko nh ni lw ks nj nk ma kw nl nm me nn bi translated">观察:</h2><ol class=""><li id="4815" class="no np iq kf b kg nq kk nr ko ns ks nt kw nu la nv nw nx ny bi translated">在<strong class="kf ir">图 6 —渲染前分区移动中，</strong>您将看到所有表都标记为删除，但字节的移动尚未开始。</li><li id="df1a" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">在<strong class="kf ir">图 7 —渲染中的分区移动中，</strong>您将会看到现在字节移动已经开始，并且正在进行中。虽然我们已经为我们的帐户设置了 0 天的数据保留期，但是您会看到，对于 EMPLOYEE _ INSERT&amp;EMPLOYEE _ UPD 表，我们可以看到来自时间旅行的 in-rendering 字节，很快它将被更新为故障保护字节，因为我们可以看到 TABLE _ ENTERED _ FAILSAFE 列的时间戳已经更新。</li><li id="627c" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><strong class="kf ir">在图 7 </strong>中，您将看到，由于 EMPLOYEE _ INSERT&amp;EMPLOYEE _ UPD 表上的高流失率(即多个 DML &amp; DDL 操作),实际的 1024 字节数据已被转换为其实际存储字节的 4 到 5 倍。</li><li id="56c0" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><strong class="kf ir">在图 7 中，</strong>您还会看到，1024 字节的 EMPLOYEE 表已从 RETAINED_FOR_CLONE_BYTES 列移到 FAILSAFE_BYTES 列。这是因为现在已经没有需要保留基表备份的克隆了，因为所有克隆都已删除。之前，它被保留用于 EMPLOYEE_CLONE1 表，我们在测试用例#4 中删除了该表。</li><li id="107e" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><strong class="kf ir">在图 8 中，</strong>您还会看到，最终所有的表分区都被转移到了防故障分区，并且很快(7 天后)它将移出雪花。没有 DML 操作的所有克隆表在任何桶中都没有字节，因此不会产生存储成本。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="b4aa" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">总结:</h1><ol class=""><li id="eb66" class="no np iq kf b kg nq kk nr ko ns ks nt kw nu la nv nw nx ny bi translated">创建克隆不会影响存储成本，但会产生计算成本，这与从中克隆克隆的表的大小直接相关。</li><li id="0125" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">当您对表执行 DML 操作时，克隆表就开始产生存储成本，并且它开始维护自己的分区生命周期。</li><li id="5b9f" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">如果从任何表中创建克隆，即使删除了基表，它的分区也会作为备份保留，以便在删除基表之前没有删除克隆表的情况下恢复克隆表。</li><li id="66cf" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">TABLE_STORAGE_METRICS 元数据表需要时间来呈现实际的存储字节移动，因此如果您没有看到字节立即从一个存储桶移动到另一个存储桶，请耐心等待，不要惊慌。这只是一个时间问题，这一点没有错。</li><li id="5daf" class="no np iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">对表进行的 DML 操作越多，就有越多的分区版本将经历生命周期的不同状态，最终会花费更多的存储成本。相应地规划你的桌子类型。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇演示博客能帮助您深入了解<strong class="kf ir">雪花克隆和其他 DML/DDL 操作及其对存储的影响</strong>。如果你对此有任何疑问，欢迎在评论区提问。如果你喜欢这个博客，请鼓掌。保持联系，看到更多这样的酷东西。谢谢你的支持。</p><p id="1dd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">你可以找到我:</strong></p><p id="4280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【https://www.youtube.com/c/RajivGuptaEverydayLearning】订阅我的 YouTube 频道:<a class="ae kc" href="https://www.youtube.com/c/RajivGuptaEverydayLearning" rel="noopener ugc nofollow" target="_blank"/></p><p id="f9c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">跟我上媒:</strong><a class="ae kc" href="https://rajivgupta780184.medium.com/" rel="noopener">https://rajivgupta780184.medium.com/</a></p><p id="9c1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">在推特上关注我:</strong><a class="ae kc" href="https://twitter.com/RAJIVGUPTA780" rel="noopener ugc nofollow" target="_blank">https://twitter.com/RAJIVGUPTA780</a></p><p id="bdb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">在 LinkedIn 上联系我:</strong><a class="ae kc" href="https://www.linkedin.com/in/rajiv-gupta-618b0228/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/rajiv-gupta-618b0228/</a></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2bcdd98de33d1c55b19dc962162de759.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*Pi1eIijZ2-qQh-sV.png"/></div></figure><p id="4791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">#继续学习#继续分享# RajivGupta everyday learning # SnowflakeDataSuperhero # RajivGupta</strong></p></div></div>    
</body>
</html>