<html>
<head>
<title>Linux — How to Simulate and Mitigate DDoS Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux——如何模拟和缓解 DDoS 攻击</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-how-to-simulate-and-mitigate-ddos-attacks-62a3cb2f5978?source=collection_archive---------3-----------------------#2022-03-09">https://blog.devgenius.io/linux-how-to-simulate-and-mitigate-ddos-attacks-62a3cb2f5978?source=collection_archive---------3-----------------------#2022-03-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="9910" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">减轻 DDoS 攻击的有用提示</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/eba0a5731ae033c0bdc00d170ec17345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63F3nD50CBHB1onBEWZP3Q.png"/></div></div></figure><p id="cade" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我的上一篇文章:“<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/linux-how-to-analyze-network-performance-73ab4e1d207d"> Linux —如何分析网络性能</a>”中，我谈到了如何使用<code class="fe kz la lb lc b">tcpdump</code>和<code class="fe kz la lb lc b">wireshark</code>，并带您看了几个用例。今天我们来看另一个常见问题，如何缓解 DDoS(分布式拒绝服务)造成的性能下降。</p><h1 id="c0d0" class="ld le ir bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是 DDoS</h1><p id="3c4d" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">DDoS 的前身是 DoS(拒绝服务)，即拒绝服务攻击，是指利用大量合理请求占用过多目标资源，使目标服务无法响应正常请求。</p><p id="d00d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">DDoS(分布式拒绝服务)采用基于 DoS 的分布式架构，使用多台主机同时攻击目标主机。这样，即使目标服务部署了网络防御设备，仍然无法应对大量的网络请求。</p><p id="e700" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">从攻击原理来说，DDoS 可以分为以下几种。</p><ul class=""><li id="6350" class="mg mh ir jq b jr js jv jw jz mi kd mj kh mk kl ml mm mn mo bi translated">“带宽用完”:无论是服务器还是路由器、交换机等网络设备，带宽都有固定的上限。当带宽耗尽时，出现网络拥塞，其他正常的网络数据包无法传输。</li><li id="aebb" class="mg mh ir jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">“耗尽 OS 资源”:网络服务的正常运行需要一定的系统资源，如 CPU、内存等物理资源，以及连接表等软件资源。一旦资源耗尽，系统就无法处理其他正常的网络连接。</li><li id="29e4" class="mg mh ir jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">“耗尽应用资源”:应用的运行通常还需要与其他资源或系统进行交互。如果应用程序一直忙于处理无效请求，也会导致正常请求的处理速度变慢，甚至得不到响应。</li></ul><p id="5d00" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">无论什么类型的 DDoS，危害都是巨大的。那么，如何才能发现系统遭受了 DDoS 攻击，如何应对这样的攻击呢？让我向您介绍一个真实的使用案例。</p><h1 id="b571" class="ld le ir bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">案例准备</h1><p id="e370" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">您需要遵循以下要求:</p><ul class=""><li id="f633" class="mg mh ir jq b jr js jv jw jz mi kd mj kh mk kl ml mm mn mo bi translated">3 台 Linux 主机:应用程序、攻击者、客户端</li><li id="aa16" class="mg mh ir jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">预装<code class="fe kz la lb lc b">docker</code>、<code class="fe kz la lb lc b">sar</code>、<code class="fe kz la lb lc b">hping3</code>、<code class="fe kz la lb lc b">tcpdump</code>、<code class="fe kz la lb lc b">curl</code>。</li></ul><h2 id="1ffb" class="mu le ir bd lf mv mw dn lj mx my dp ln jz mz na lr kd nb nc lv kh nd ne lz nf bi translated">应用服务器</h2><p id="ee76" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">让我们在应用程序主机上启动一个简单的<code class="fe kz la lb lc b">nginx</code>服务:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="aae3" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# docker run -itd --name=nginx --network=host nginx<br/>a8b3685d5eef0ffa2dead081b88d50d777db04bedbdb77ba886ca89b4bb690d2</span><span id="16e4" class="mu le ir lc b gz no nl l nm nn">[root@app ~]# docker ps<br/>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES<br/>a8b3685d5eef   nginx     "/docker-entrypoint.…"   24 seconds ago   Up 21 seconds             nginx</span></pre><h2 id="d3db" class="mu le ir bd lf mv mw dn lj mx my dp ln jz mz na lr kd nb nc lv kh nd ne lz nf bi translated">客户</h2><p id="45ce" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">然后，在客户端主机中，使用 curl 访问 Nginx 监听的端口，并确认 Nginx 正常启动:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="d377" class="mu le ir lc b gz nk nl l nm nn">[root@client ~]# curl -s -w 'Http code: %{http_code}\nTotal time:%{time_total}s\n' -o /dev/null <a class="ae ky" href="http://172.31.88.139" rel="noopener ugc nofollow" target="_blank">http://172.31.88.139</a><br/>Http code: 200<br/>Total time:0.002437s</span></pre><p id="9252" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">从这里可以看到，正常情况下，我们访问 Nginx 只需要 2ms (0.002s)。</p><h2 id="74fb" class="mu le ir bd lf mv mw dn lj mx my dp ln jz mz na lr kd nb nc lv kh nd ne lz nf bi translated">攻击者</h2><p id="c04a" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">现在，让我们从主机攻击者处运行<code class="fe kz la lb lc b">hping3</code>命令来模拟 Dos 攻击:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="39a3" class="mu le ir lc b gz nk nl l nm nn"># -S means set syn，-p means port 80<br/># -i u10 send a packet frame every 10 m-seconds<br/>$ hping3 -S -p 80 -i u10 --flood 192.168.0.30<br/>HPING 172.31.88.139 (eth0 172.31.88.139): S set, 40 headers + 0 data bytes<br/>hping in flood mode, no replies will be shown</span></pre><h2 id="a1bf" class="mu le ir bd lf mv mw dn lj mx my dp ln jz mz na lr kd nb nc lv kh nd ne lz nf bi translated">减轻</h2><p id="d184" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">现在让我们回到主机客户端，再次尝试<code class="fe kz la lb lc b">curl</code>命令:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="378f" class="mu le ir lc b gz nk nl l nm nn">[root@client ~]# curl -s -w 'Http code: %{http_code}\nTotal time:%{time_total}s\n' -o /dev/null <a class="ae ky" href="http://172.31.88.139" rel="noopener ugc nofollow" target="_blank">http://172.31.88.139</a><br/>Http code: 000<br/>Total time:10.001s<br/>curl: (28) Connection timed out after 10000 milliseconds</span></pre><p id="cdb7" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这次普通客户端的连接超时，没有收到 Nginx 服务的响应。</p><p id="b32c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这里发生了什么事？让我们返回到主机应用程序并检查网络状态:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="271e" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# sar -n DEV 1<br/>08:55:49        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br/>08:55:50      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br/>08:55:50         eth0  22274.00    629.00   1174.64     37.78      0.00      0.00      0.00      0.02<br/>08:55:50           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span></pre><p id="6f10" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">从这次<code class="fe kz la lb lc b">sar</code>的输出可以看到，网络收到的 PPS 达到了 2 万多个，但是 BPS 只有 1174 kB，所以每个包的大小只有 54B (1174*1024/22274=54)。</p><p id="b652" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">包大小不大，但这是什么包？让我们用<code class="fe kz la lb lc b">tcpdump</code>来捕捉:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="fc1c" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# tcpdump -i eth0 -n tcp port 80<br/>09:15:48.287047 IP 172.31.82.28.27095 &gt; 172.31.88.139: Flags [S], seq 1288268370, win 512, length 0<br/>09:15:48.287050 IP 172.31.82.28.27131 &gt; 172.31.88.139: Flags [S], seq 2084255254, win 512, length 0<br/>09:15:48.287052 IP 172.31.82.28.27116 &gt; 172.31.88.139: Flags [S], seq 677393791, win 512, length 0<br/>09:15:48.287055 IP 172.31.82.28.27141 &gt; 172.31.88.139: Flags [S], seq 1276451587, win 512, length 0<br/>09:15:48.287068 IP 172.31.82.28.27154 &gt; 172.31.88.139: Flags [S], seq 1851495339, win 512, length 0<br/>...</span></pre><p id="d80c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在此输出中，Flags [S]表示这是一个 SYN 数据包。大量的 SYN 数据包表明这是一次 SYN Flood 攻击。如果我们用 wireshark 来观察，可以更直观地看到 SYN Flood 的过程:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj np"><img src="../Images/2e2ddbf26bbc2423003ebad8646705a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sac89NdkZlgKUZVna85M2A.png"/></div></div></figure><p id="d337" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">其实 SYN Flood 是互联网上最经典的 DDoS 攻击。从上图也可以看出它的原理:</p><ul class=""><li id="9ca6" class="mg mh ir jq b jr js jv jw jz mi kd mj kh mk kl ml mm mn mo bi translated">客户端构造大量 SYN 包，请求建立 TCP 连接；</li><li id="1c22" class="mg mh ir jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">服务器收到包后，会向源 IP 发送一个 SYN+ACK 包，等待三次握手的最后一个 ACK 包，直到超时。</li></ul><p id="136d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这种等待状态的 TCP 连接通常也称为半开连接。由于连接表的大小有限，大量的半开连接会导致连接表很快填满，无法建立新的 TCP 连接。</p><p id="23b0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">参考下面的 TCP 状态图，可以看到此时服务器端的 TCP 连接将处于 SYN_RECEIVED 状态:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj nq"><img src="../Images/dcbc85fee428d9ac2b389640fc6dc839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HWqcMuE-jIw9Sai1.png"/></div></div><figcaption class="nr ns gk gi gj nt nu bd b be z dk translated">图片来自维基百科</figcaption></figure><p id="6c82" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们可以使用<code class="fe kz la lb lc b">netstat</code>来查看所有连接的状态，但是注意 SYN_REVEIVED 的状态通常缩写为 SYN_RECV。</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="e3f4" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# netstat -n -p | grep SYN_REC<br/>tcp        0      0 172.31.88.139:80          172.31.82.28:12503      SYN_RECV    -<br/>tcp        0      0 172.31.88.139:80          172.31.82.28:13502      SYN_RECV    -<br/>tcp        0      0 172.31.88.139:80          172.31.82.28:15256      SYN_RECV    -<br/>tcp        0      0 172.31.88.139:80          172.31.82.28:18117      SYN_RECV    -<br/>...</span></pre><p id="cd19" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">从结果中可以发现大量 SYN_RECV 状态的连接，源 IP 地址为 172.31.82.28。让我们统计一下<code class="fe kz la lb lc b">SYN_RECV</code>状态下的连接数:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="96c5" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# netstat -n -p | grep SYN_REC | wc -l<br/>193</span></pre><p id="f14c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">找出源 IP 后，要解决 SYN 攻击的问题，只需丢弃相关数据包即可。这时，<code class="fe kz la lb lc b">iptables</code>可以帮你完成这个任务:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="bd14" class="mu le ir lc b gz nk nl l nm nn">[root@app ~]# iptables -I INPUT -s 172.31.82.28 -p tcp -j REJECT</span></pre><p id="9441" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">注:塞尔班在评论中建议，在这种情况下，<code class="fe kz la lb lc b">DROP</code>比<code class="fe kz la lb lc b">REJECT</code>更好。</p><p id="7b2e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">实现上述命令后，让我们再次尝试从客户端主机执行<code class="fe kz la lb lc b">curl</code>:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="a7c5" class="mu le ir lc b gz nk nl l nm nn">$ curl -w 'Http code: %{http_code}\nTotal time:%{time_total}s\n'-o /dev/null--connect-timeout 10 http://172.31.88.139<br/>Http code: 200<br/>Total time:1.572171s</span></pre><p id="c705" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">但是，一般来说，SYN Flood 攻击中的源 IP 是不固定的。例如，您可以通过在<code class="fe kz la lb lc b">hping3</code>命令中添加<code class="fe kz la lb lc b">--rand-source</code>选项来随机化源 IP。但是，此时，刚才的方法并不适用。</p><p id="cd41" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">幸运的是，我们有许多其他方法来实现类似的目标。例如，我们可以通过两种方式限制 syn 数据包的速率:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="7af7" class="mu le ir lc b gz nk nl l nm nn"># Limit the number of syn concurrency to 1 per second<br/>$ iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT</span><span id="7696" class="mu le ir lc b gz no nl l nm nn">#Limit the number of newly established connections for a single IP in 60 seconds to 10<br/>$ iptables -I INPUT -p tcp --dport 80 --syn -m recent --name SYN_FLOOD --update --seconds 60 --hitcount 10 -j REJECT</span></pre><p id="f569" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">到目前为止，我们已经初步限制了 SYN Flood 攻击。但这还不够，因为我们的案例只是单一的攻击源。</p><p id="af1d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果多台机器同时发送 SYN Flood，这种方法可能直接无效。因为您可能无法通过 SSH 进入机器(SSH 也是基于 TCP 的)，更不用说执行上面所有的故障排除命令了。</p><h2 id="6075" class="mu le ir bd lf mv mw dn lj mx my dp ln jz mz na lr kd nb nc lv kh nd ne lz nf bi translated">TCP 优化</h2><p id="7bfe" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">为了减轻多机 SYN 泛滥，我们可以将半开连接容量从默认的 256 增加到 1024:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="f515" class="mu le ir lc b gz nk nl l nm nn">$ sysctl net.ipv4.tcp_max_syn_backlog<br/>net.ipv4.tcp_max_syn_backlog = 256</span><span id="add9" class="mu le ir lc b gz no nl l nm nn">$ sysctl -w net.ipv4.tcp_max_syn_backlog=1024net.ipv4.tcp_max_syn_backlog = 1024</span></pre><p id="d2d2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">另外，连接每个 SYN_RECV 时，如果失败，内核会自动重试，默认重试次数为 5 次。您可以通过执行以下命令将其减少到 1 倍:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="1008" class="mu le ir lc b gz nk nl l nm nn">$ sysctl -w net.ipv4.tcp_synack_retries=1<br/>net.ipv4.tcp_synack_retries = 1</span></pre><p id="45fd" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">此外，TCP SYN Cookies 也是防御 SYN Flood 攻击的一种特殊方法。SYN Cookies 根据连接信息(包括源地址、源端口、目的地址、目的端口等)计算一个哈希值(SHA1)。)和加密种子(如系统启动时间)。这个哈希值称为 cookie。启用 SYN Cookies 后，不需要维持半开连接状态，也没有半开连接数的限制。</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="5b53" class="mu le ir lc b gz nk nl l nm nn">$ sysctl -w net.ipv4.tcp_syncookies=1<br/>net.ipv4.tcp_syncookies = 1</span></pre><p id="f58b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">请注意，上述<code class="fe kz la lb lc b">sysctl</code>命令修改的配置是临时的，重启后将会丢失。您可以将它们添加到<code class="fe kz la lb lc b">/etc/sysctl.conf</code>文件中，使其永久保存。例如:</p><pre class="kn ko kp kq gu ng lc nh ni aw nj bi"><span id="c05b" class="mu le ir lc b gz nk nl l nm nn">$ cat /etc/sysctl.conf<br/>net.ipv4.tcp_syncookies = 1<br/>net.ipv4.tcp_synack_retries = 1<br/>net.ipv4.tcp_max_syn_backlog = 1024</span><span id="85c0" class="mu le ir lc b gz no nl l nm nn">$ sysctl -p</span></pre><h1 id="73a3" class="ld le ir bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="011b" class="pw-post-body-paragraph jo jp ir jq b jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl ik bi translated">今天，我讨论了分布式拒绝服务(DDoS)的缓解措施。DDoS 使用大量伪造的请求，使目标服务消耗大量资源来处理这些无效请求，进而无法正常响应正常用户请求。</p><p id="e11b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">由于 DDoS 分布广、流量大、难以跟踪等特点，目前没有办法完全防御 DDoS 带来的问题，只能减轻影响。</p></div></div>    
</body>
</html>