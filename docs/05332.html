<html>
<head>
<title>Toggling between parts of React applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 应用程序的各个部分之间切换</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/features-big-e-commerce-companies-i-worked-for-use-for-scaling-the-business-easily-f7ccce5600fa?source=collection_archive---------2-----------------------#2021-07-21">https://blog.devgenius.io/features-big-e-commerce-companies-i-worked-for-use-for-scaling-the-business-easily-f7ccce5600fa?source=collection_archive---------2-----------------------#2021-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bbfd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一些特性切换有益的用例</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ba470382c81cdd3905d38377884d7d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ra64YXCu5CVWlufq59SOg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">伊戈尔·米斯克在<a class="ae ks" href="https://unsplash.com/s/photos/ecommerce-website?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="667e" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">功能切换非常强大</h1><p id="6051" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">也被称为<em class="mh">特征标志</em>，这是我工作过的每一个堆栈的重要部分，对于许多用例来说，它非常方便和有用。它们基本上是设置为在两个或更多体验、行为甚至小 UI 组件之间有条件切换的<em class="mh"> cookies </em>。让我们列出几种类型的功能切换及其潜在的用例:</p><p id="f1c8" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">1- <strong class="ln io">服务器端特性切换:</strong>主要用于服务器端渲染代码，比如将 API 端点指向不同数据源的集成。我们可以依赖来自客户端的 cookie，或者根据期望的行为在 http 请求中启动 cookie。</p><p id="982b" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">看看下面的<a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" rel="noopener ugc nofollow" target="_blank"><em class="mh">NextJs getServerSideProps</em></a><em class="mh"/>例子，这段代码在服务器上执行，它正在访问来自客户端的 cookies，<em class="mh">除非它被代理拦截)</em>利用<a class="ae ks" href="https://www.npmjs.com/package/cookies" rel="noopener ugc nofollow" target="_blank"> <em class="mh">一个 npm 包</em> </a>:</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="2c62" class="ms ku in mo b gy mt mu l mv mw">import Cookies from "cookies";<br/>....</span><span id="796d" class="ms ku in mo b gy mx mu l mv mw">export async function getServerSideProps(ctx) {</span><span id="9008" class="ms ku in mo b gy mx mu l mv mw">const {req, res, ...rest} = ctx;<br/> const cookies = new Cookies(req, res);<br/> const shouldLoadDraftContent = cookies.get('draftContentEnabled');</span><span id="10e2" class="ms ku in mo b gy mx mu l mv mw"> if(shouldLoadDraftContent) {<br/>   // fetch draft content</span><span id="afaa" class="ms ku in mo b gy mx mu l mv mw"> }else {<br/>   // fetch published content <br/> }</span><span id="6bdc" class="ms ku in mo b gy mx mu l mv mw"> return { props: { ... some props } };</span><span id="5bd1" class="ms ku in mo b gy mx mu l mv mw">}</span></pre><p id="e81a" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">在上面的示例中，我们在决定加载草稿内容之前检查了 cookie<em class="mh">draftContentEnabled</em>值，这对于在发布之前测试内容的营销团队来说非常方便，尤其是当我们没有足够的环境来指向不同的端点时。</p><p id="731c" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">2- <strong class="ln io">客户端功能切换:</strong>通常用于不同行为或体验之间的切换。假设我们有一个新页面，您想只向特定类型的用户或特定地区的用户显示，假设您有一个支持所有地区/用户的源代码。以下示例将向您展示如何在路由器级别的 React 应用程序中实现这一点。这个例子假设您有一个<a class="ae ks" href="https://www.w3schools.com/js/js_cookies.asp" rel="noopener ugc nofollow" target="_blank"> cookie 管理访问器(getters 和 setter)</a>。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="8adc" class="ms ku in mo b gy mt mu l mv mw">import {getCookie} from './path/to/your/cookie/manager';<br/>const userRegion = getCookies('userRegion');<br/></span><span id="5610" class="ms ku in mo b gy mx mu l mv mw">return(&lt;Router&gt;<br/> &lt;Route&gt; ...route for a page&lt;/Route&gt;<br/> &lt;Route&gt; ...route for a page&lt;/Route&gt;<br/> &lt;Route&gt; ...route for a page&lt;/Route&gt;<br/> {userRegion === 'us" &amp;&amp; &lt;Route&gt;&lt;/Route&gt;}<br/>&lt;/Router&gt;);</span></pre><p id="8c7f" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">现在，设置“用户区域”可以基于 url 或某个服务器位置检测器来进行，该检测器向客户端提供该值。这也可以在一个<a class="ae ks" href="https://vwo.com/ab-testing/" rel="noopener ugc nofollow" target="_blank"> A/B 测试脚本</a>中设置，因此它是 100%自动地服务于您的客户端需求。</p><p id="46af" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">3- <a class="ae ks" href="https://www.techopedia.com/definition/4189/application-gateway" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">应用网关</strong> </a> <strong class="ln io">特性切换</strong>:这是我最喜欢的部分，因为它真正地分离了关注点——我将在下一节中对此进行更多的讨论。解释这一点的一个好方法是使用一个例子。让我们假设您有一个<a class="ae ks" href="https://www.shopify.com/" rel="noopener ugc nofollow" target="_blank"> Shopify 商店</a>，其中也包含一些静态页面。你决定将你的静态页面从 shopify 转移到另一个服务提供商或你的 S3 木桶中。</p><p id="2608" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">如何从不同的来源提供不同的页面？有很多方法可以实现这一点，但是快速使用像<a class="ae ks" href="https://www.fastly.com/" rel="noopener ugc nofollow" target="_blank">和</a>这样的应用网关是其中之一。</p><p id="2aa3" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">现在的问题是，您如何构建这些页面并增量发布新构建的页面？！</p><p id="0901" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">也就是说，在发布的第一天，你想要显示的新页面(来自你的 AWS)只占你流量的<em class="mh"> 10% </em>！！！其余的人可以看到遗留页面(shopify 页面)。你逐渐增加这个百分比。这样你就不会冒险让你的新服务器过载，甚至在新代码测试好之前就阻止你的大部分流量使用新代码！。</p><p id="2564" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">您可以在您的应用程序网关中添加一个功能开关，它可以执行以下操作:</p><p id="20da" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">*这里的语法是一个旧的<a class="ae ks" href="https://learn.hashicorp.com/terraform" rel="noopener ugc nofollow" target="_blank"> Terraform </a>语法，主要用于基础设施应用。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="ba83" class="ms ku in mo b gy mt mu l mv mw"># check if a previously decision was made - for returning customers to see consistent behaviour -</span><span id="55e9" class="ms ku in mo b gy mx mu l mv mw">if (!req.http.Cookie:enableNewStaticPages) {<br/>  # Select the backend based on variable%<br/>  if (randombool(10,100)) {<br/>   # add logic to point to AWS <br/>   set req.Cookie.enableNewStaticPages=true<br/>  } else {<br/>   # add logic to point to shopify<br/>   set req.Cookie.enableNewStaticPages=false<br/>  }<br/>} else {<br/> # keep the same behaviour<br/> if(req.http.Cookie:enableNewStaticPages === 'true) {<br/>  # add logic to point to AWS<br/> }else {<br/>  # add logic to point to shopify<br/> }<br/>}</span></pre><h1 id="b231" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">为什么这是我最喜欢的功能切换类型？</strong></h1><p id="a5a3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">基本上是因为它更干净<em class="mh">在大多数情况下</em>你可以将这些静态页面的代码放在一个单独的存储库中，并让你的服务器指向这些代码，而不是 Shopify。这使得你的代码更整洁，因为在前端不需要特性切换来控制行为。因为代码不会被执行，除非“enableNewStaticPages===true”。</p><h1 id="dbe9" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">在下一篇文章中:</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/2fbee1c660c386ea2ccbf7a319f0c7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZfXSLMmkoV6sg_UOI2n3Q.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com/@fazurrehman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法伊祖尔·拉赫曼</a>在<a class="ae ks" href="https://unsplash.com/s/photos/ui?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5ced" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><em class="mh">购物车/结账流程管理</em>:我将讨论这是一个非常重要的部分，该领域使用了哪些工具和功能来轻松扩展购物车集成，以及在构建购物车或将购物车集成到您的商店时需要考虑的一些事情。</p><p id="a37c" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">不要忘记关注<a class="ae ks" href="https://medium.com/@abdalla.ahmed.ksa/about" rel="noopener">我的账户</a>并添加您的电子邮件，以便在新帖子发布时得到通知。</p></div></div>    
</body>
</html>