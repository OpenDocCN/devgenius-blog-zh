<html>
<head>
<title>Adding Guardrails to your Kubernetes Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你的Kubernetes系列添加护栏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-1-29b7006b5085?source=collection_archive---------7-----------------------#2020-07-22">https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-1-29b7006b5085?source=collection_archive---------7-----------------------#2020-07-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8cd9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">资源限制和要求</h2></div><h2 id="146b" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">部署资源</h2><p id="5191" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">本系列将带您了解如何提高堆栈的整体弹性。在本节中，我们将通过提供资源需求，让Kubernetes (k8s)对资源消耗做出反应来实现这一点。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/1373d029624eb72829ceb9ae5719a8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLZG2dS6qcxaH4Wf"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">斯文·布兰德斯马在<a class="ae mh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="da17" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h2><p id="cc19" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">我经常注意到团队遇到稳定性问题，因为他们不知道Kubernetes (k8s)如何执行资源管理。由于很多k8s的资源管理功能不会在你不给它提供信息的时候踢它，k8s最后就瞎飞了。</p><p id="82d2" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">k8s管理资源主要有两种方式。首先是资源分配，这是经典的装箱问题。我如何把x，y，…卷的一样多的项目..第二个是资源利用率。k8s就是这样调整节点数量来满足当前的资源利用率的。如果集群缺乏，则向上扩展；如果有剩余，则向下扩展。这两个特性都需要容器配置中的资源定义才能工作。</p><p id="adef" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">Kubernetes不是一个神奇的系统。如果你不告诉它，它不知道你的应用需要多少资源。通过在您的部署/ pod上指定资源请求和限制，它可以帮助您的集群将您的应用程序正确地打包到节点上。<a class="ae mh" href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/" rel="noopener ugc nofollow" target="_blank">官方文件</a></p><h2 id="896c" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">资源请求:</h2><p id="1477" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">设置一个资源请求告诉k8s你的应用需要运行什么样的基线资源。这将告知k8s如何根据可用资源(节点上的可用资源≥应用请求的资源)在集群中打包应用。</p><p id="eb5c" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">示例(第21–24行):</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4cf4" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">1个vCPU/核等于1000m (m代表毫CPU)。CPU是由你获得多少CPU时间来定义的。默认情况下，它基于100ms(毫秒)的周期。因此，0.5 vCPU等于每100毫秒50毫秒的CPU时间。</p><p id="fd80" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">内存是以字节为单位定义的，用后缀表示:E，P，T，G，M，K或等价的2的幂:Ei，Pi，Ti，Gi，Mi，Ki</p><p id="d724" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">因此，在示例应用程序中，应用程序需要0.25的vCPU和500兆的内存。K8s将查看您的集群中的节点，并找到适合该应用程序的位置，并在那里安排它。</p><p id="5160" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">一旦在容器上指定了资源，就会启用四个非常重要特性。</p><p id="cf8a" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">1.K8s现在会根据资源可用性将您的应用程序适当地调度到节点中。每个节点都有有限的可分配CPU和内存，每个容器都消耗这些资源。如果没有资源请求或限制，k8s不知道每个应用程序需要什么资源，k8s可能会将太多的应用程序打包到一个节点上，导致节点不堪重负。</p><p id="2cc4" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">2.启用使用<a class="ae mh" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a> (HPA)的能力。Horizontal pod autoscaler是k8s社区提供的一个应用程序，用于根据特定资源的目标利用率来扩展pod。默认情况下，支持CPU和内存，但可以扩展到自定义指标。HPA还需要<a class="ae mh" href="https://github.com/kubernetes-sigs/metrics-server" rel="noopener ugc nofollow" target="_blank">一个度量服务器</a>来工作。这有助于您的应用程序向上和向下扩展，以便每个单元不会过度利用资源。</p><p id="d480" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">3.启用使用<a class="ae mh" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">集群自动缩放器</a>的能力。Cluster autoscaler也是k8s社区提供的应用。当集群中请求的资源大于集群的可用资源时，集群自动缩放器会启动并向集群添加节点。这通常发生在pod由于资源不足而陷入“待定”状态时。</p><p id="632a" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">4.工人节点储备受到重视。工作者节点预留的行为类似于部署请求，但针对的是kubelet和OS之类的工作者节点资源。K8s会将pod分配到一个节点上，直到没有剩余的可分配资源。如果您的pods没有使用请求，K8s不知道它是否过度分配，这会导致节点不稳定，因为工作节点资源可能会被您的应用程序消耗。</p><h2 id="da42" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">限制</h2><p id="1741" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">限制限定了应用程序可以消耗多少资源。内存限制的表现类似于您的计算机上只有x数量的内存。从应用程序的角度来看，可用内存量将是您在容器定义中设置的限制。除此之外，如果您的容器决定消耗超过部署中设置的限制，k8s将使您的pod成为内存不足杀死(OOM杀死)的候选对象。如前所述，CPU资源是基于时间片的，所以当你的应用程序在一个周期内需要的CPU超过CPU限制时，它将被限制到下一个周期。</p><p id="468a" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">对CPU的限制要非常小心。如果设置不当，CPU限制会影响您的应用程序。根据我的经验，大多数计量工具都不够精确，无法准确跟踪CPU消耗。因此，您的应用可能会因为您的限制而受到抑制，但这并没有反映在您的指标中。对于产生许多线程的应用程序来说，设置CPU限制也特别困难，比如大多数HTTP服务对每个传入请求都使用阻塞IO线程。例如，在一个有10个内核且应用程序运行10个线程的节点上，您将vCPU限制设置为0.5。这意味着如果产生10个线程，假设所有10个线程同时运行，每个线程将只获得0.5/10 vCPU的时间(50毫秒)。也就是说，在您耗尽应用程序的CPU之前，总处理时间为50毫秒。</p><p id="cc35" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">CPU限制很难，值得深入研究。我强烈推荐这篇文章，它对这个问题有更深入的解释:<a class="ae mh" href="https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b" rel="noopener">https://medium . com/@ betz . mark/understanding-resource-limits-in-kubernetes-CPU-time-9 eff 74d 3161 b</a></p><p id="2da1" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">示例(第21–24行):</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="618b" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">摘要</h2><p id="5822" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">在您的部署上设置请求和限制将为k8s提供基本信息，以适当地将您的应用程序放置在集群中，从而最大化效率并防止您的应用程序淹没节点。这将极大地提高您的集群对不稳定负载和过度消耗资源的错误应用程序的弹性。这也将迫使你更好地理解你的应用程序的资源需求。</p><p id="3292" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated"><a class="ae mh" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-2-2f2db4ff410d" rel="noopener">第2部分:Pod服务质量和优先级</a> <br/> <a class="ae mh" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-3-b260d45fe6e" rel="noopener">第3部分:滚动更新和Pod中断预算</a> <br/> <a class="ae mh" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-4-cc72b09b4557" rel="noopener">第4部分:水平Pod自动缩放和集群自动缩放</a></p></div></div>    
</body>
</html>