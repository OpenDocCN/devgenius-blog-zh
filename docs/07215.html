<html>
<head>
<title>JAVA 16 And 17: Evolutions and new features — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA 16 和 17:发展和新特性—第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-16-and-17-evolutions-and-new-features-part-2-f2eb30c89a80?source=collection_archive---------8-----------------------#2022-03-06">https://blog.devgenius.io/java-16-and-17-evolutions-and-new-features-part-2-f2eb30c89a80?source=collection_archive---------8-----------------------#2022-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bbc1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个 Java 开发者都应该知道的 Java 版本进化链。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0c015232072af34d20363355c281dcd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_awzGXF2-oXisQnqyTsx9g.png"/></div></div></figure><p id="7f49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一部:<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/java-16-and-17-evolutions-and-new-features-part-1-d008e1d8f6de">第一部</a></p><p id="2a85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文的第一部分中，我们解释了<strong class="kt ir"> JAVA 16 </strong>的变化和新特性。在第二部分中，我们将讨论<strong class="kt ir"> JAVA 17 </strong>的变化和新特性。</p><h1 id="9c80" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">JAVA 17</h1><h2 id="b7ae" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">1.交换机的模式匹配(在预览中)</h2><p id="5bec" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">这项功能在<strong class="kt ir"> JDK 17 </strong>的预览版中引入，将模式匹配集成到开关中。我们现在可以切换变量的类型(包括枚举、记录和数组)。<br/>除了模式匹配之外，该开关还被丰富为允许在<strong class="kt ir"> <em class="mx">案例</em> </strong>中包含一个条件，并管理一个特殊的空案例；请注意，在 java 17 之前，null switch 变量会导致一个<strong class="kt ir"> NullPointerException </strong>。</p><p id="34b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6e17" class="mg lp iq mz b gy nd ne l nf ng">switch(obj) {<br/>  case null -&gt; System.out.println("obj is null");<br/>  case Integer i -&gt; System.out.println("obj is an integer");<br/>  case String s -&gt; System.out.println("obj is a string");<br/>  case Car c &amp;&amp; c.getNoOfWindows() &gt; 4 -&gt; System.out.println("obj is a limousine");<br/>  case Car c -&gt; System.out.println("obj is a regular car");<br/>  default -&gt; System.out.println("obj is another data type");<br/>}</span></pre><h2 id="4be2" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">2.密封类</h2><p id="96d2" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir">密封类</strong>允许你控制你的继承层次。</p><p id="d127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这是<strong class="kt ir"> Java 16 </strong>中的<strong class="kt ir">预览</strong>特性，虽然在<strong class="kt ir"> Java 17 </strong>中已经定型(标准特性)。您必须在编译器调用和 JVM 调用上传递-enable-preview 选项，以便在 Java 16 中使用该特性。</p><p id="ea8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们想防止其他类从密封类继承，并且不想使用 final 关键字或降低类的可见性时，我们经常使用这个特性。只有在 permissions 关键字之后定义的类才允许扩展密封类。</p><p id="2b41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="542c" class="mg lp iq mz b gy nd ne l nf ng">sealed interface Vehicle permits Car, Motorbike {}</span><span id="e985" class="mg lp iq mz b gy nh ne l nf ng">record Car (String model, String vendor, String color, int price) implements Vehicle { }</span><span id="86ac" class="mg lp iq mz b gy nh ne l nf ng">record Motorbike (String model, String vendor, String color, int price) implements Vehicle { }</span></pre><p id="039e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许可列表意味着只有<code class="fe ni nj nk mz b">Car</code>和<code class="fe ni nj nk mz b">Motorbike</code>可以实现<code class="fe ni nj nk mz b">Vehicle</code>。任何其他试图扩展<code class="fe ni nj nk mz b">Vehicle</code>的类或接口都会收到一个编译时或运行时错误。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3996" class="mg lp iq mz b gy nd ne l nf ng">record Bus (String model, String vendor, String color, int price) implements Vehicle { } //this doesn’t work</span></pre><h2 id="04f7" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">3.伪随机数发生器</h2><p id="05a4" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">JDK 17 包括一个新的<strong class="kt ir"> RandomGenerator </strong>接口，和一个<strong class="kt ir"> RandomGeneratorFactory </strong>，它们提供了新的、更安全、更高效的随机数生成器实现(小心，它们不再是线程安全的)。旧的生成器如<strong class="kt ir"> Random </strong>、<strong class="kt ir"> SecureRandom </strong>、<strong class="kt ir"> SplittableRandom </strong>、<strong class="kt ir">threadlocalrrandom</strong>现在实现了这个接口，它还增加了对随机数流的访问(<em class="mx">Random generator::doubles()</em>、<em class="mx">Random generator::ints()</em>、…)。</p><h2 id="156e" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">4.JDK 内部类的严格封装</h2><p id="6d85" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">Java 9 中引入了一些内部模块和 API，以提供一种统一的方式来执行最常用的任务。为了阻止开发人员使用这些内部类，生成了非法访问类型的警告。</p><p id="cc57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还临时添加了命令行参数来规避这个<strong class="kt ir">"<em class="mx">–非法访问=许可"</em> </strong>限制。</p><p id="bb87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">具体来说，封装模式已经从 Java 15 中的<strong class="kt ir">–非法访问=允许</strong>变为 Java 16 中的<strong class="kt ir">–非法访问=拒绝</strong>，并且可以更改配置选项。在 Java 17 中，非法访问消失了，对内部 JDK 类(不包括 Unsafe)的访问也不再可能。</p><h2 id="1e41" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">5.贬值和删除</h2><ul class=""><li id="0fdf" class="nl nm iq kt b ku ms kx mt la nn le no li np lm nq nr ns nt bi translated"><strong class="kt ir"> Applet API 弃用:</strong></li></ul><p id="f590" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">过去，Applet API 允许开发人员将动画或 Java AWT/Swing 控件嵌入到网页中。除了现在没有现代浏览器支持这一点，这意味着小程序在过去的十年中基本上是不可访问的，因此不赞成删除 API。</p><ul class=""><li id="450c" class="nl nm iq kt b ku kv kx ky la nu le nv li nw lm nq nr ns nt bi translated"><strong class="kt ir">安全管理器弃用</strong></li></ul><p id="8a7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JDK 17 中最重要的贬值与自 Java 1.0 以来使用的安全管理器(security manager)有关，它限制 Java 可以在机器上本地做什么(访问网络、文件等)。).最初，创建它是为了保护 Applet，根据定义，Applet 运行不可信的代码，因此在不再包含 Applet API 的 JVM 中不再有意义。</p><ul class=""><li id="e917" class="nl nm iq kt b ku kv kx ky la nu le nv li nw lm nq nr ns nt bi translated"><strong class="kt ir">删除</strong></li><li id="fc0a" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">RMI 激活</li><li id="f95b" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">实验性 AOT 和 JIT 编译器</li><li id="cf84" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">javadoc 的更改</li><li id="c6b5" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">对 Oracle JDK 许可证的更改</li><li id="1cbc" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">每两年一次 LTS</li><li id="88bb" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">对 G1 和平行 GC 的更改</li><li id="7ee9" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">最终确定外部 API</li></ul><h2 id="ac51" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">6.矢量 API</h2><p id="0e74" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">孵化器模块 Vector API(dk . Incubator . Vector . Vector<e>及其子类)允许开发人员定义向量计算，然后 JIT 编译器会将其转换为与 JVM 运行的 CPU 架构兼容的向量指令，从而消除了在 JVM 中维护和编写多个特定于平台的实现的需要。</e></p><p id="fd16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个特性在 java 16 中引入，在 java 17 中继续，可以用于以下领域:机器学习、线性代数、密码学、金融和 JDK 本身。</p><h2 id="96c2" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">7.外部函数和内存 API(孵化)</h2><p id="fa3a" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">它是 Java 16 的另外两个孵化器模块的演化和融合，这两个模块是外来链接器 API ( <a class="ae ln" href="https://openjdk.java.net/jeps/389" rel="noopener ugc nofollow" target="_blank"> JEP 389 </a>)和外来内存访问 API 外来内存 API ( <a class="ae ln" href="https://openjdk.java.net/jeps/393" rel="noopener ugc nofollow" target="_blank"> JEP 393 </a>)。</p><p id="de84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">外部函数和内存 API:</p><ul class=""><li id="bb24" class="nl nm iq kt b ku kv kx ky la nu le nv li nw lm nq nr ns nt bi translated">提供对内存的访问，并允许直接访问地址、段、内存布局…</li><li id="308a" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated">允许从 java 调用本地语言，反之亦然。</li></ul><p id="064f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为 C 语言(x64 和 AArch64)提供支持，并有可能扩展(C++，x86，…)</p><h2 id="acf4" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">8.始终严格的浮点语义</h2><p id="8b97" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">默认情况下，对 double 或 float 类型的数字的计算是在类、接口或方法中以非严格方式执行的。</p><p id="ab3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使浮点运算始终严格，在 Java 17 中，在需要严格语义的类和方法中添加了<strong class="kt ir"> <em class="mx"> strictfp </em> </strong>关键字。这个关键字将使得控制浮点的行为成为可能，一旦它被放在类、接口或方法的声明前面…</p><ul class=""><li id="78cb" class="nl nm iq kt b ku kv kx ky la nu le nv li nw lm nq nr ns nt bi translated"><code class="fe ni nj nk mz b">strictfp class MyClass {...}</code></li><li id="53b3" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated"><code class="fe ni nj nk mz b">strictfp interface MyInterface {...}</code></li><li id="7d55" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated"><code class="fe ni nj nk mz b">strictfp type myMethod(){...}</code></li></ul><p id="b015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">各种类型的指令集也被引入到 CPU 中，以允许使用这些严格的语义。正因为如此，先前的默认语义被移除，所有浮点运算现在都被严格执行。然而，术语<strong class="kt ir">、T8】和、T10】仍然存在。但是，它没有效果，使用它会导致警告。</strong></p><h2 id="1832" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">9.macOS 和 AArch64 支持</h2><p id="6bb0" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">Java 17 特别引入了对在<strong class="kt ir"> <em class="mx">上的<em class="mx"> macOS </em>的改进支持，以及使用<a class="ae ln" href="https://openjdk.java.net/jeps/391" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> JEP 391 </strong> </a>的架构。相比之下，Java 9 增加了对 AArch64 架构的 Linux 平台支持，Java 16 增加了对<strong class="kt ir"> Windows/AArch64 </strong>的支持。</em></strong></p><h1 id="efd5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论:</h1><h2 id="05d1" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">LTS 概念:</h2><p id="1dee" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">用最新版本的 Java 更新几个应用程序或服务器有时会很复杂，尤其是在 2019 年底已经发布了 5 个应用程序或服务器的情况下。这就是为什么 LTS 的概念被创造出来。Java LTS(长期支持)版本是 Java 的一个版本，它将在几年内保持行业标准。</p><p id="b98b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，2014 年发布的 Java 8 将继续接收更新，直到 2020 年，扩展支持将在 2025 年结束。目前，唯一一个 LTS 版本的 Java 是 2018 年发布的 Java 11。</p><p id="4f70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不影响非 LTS 版本的稳定性，因为这些版本在不影响整体语言的情况下，改进了最新 LTS 版本中引入的一些或所有功能。</p><h2 id="52d6" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">迁移到 Java 17？</h2><p id="9698" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">迁移到 Java 17 肯定需要努力来充分利用新的 JVM 特性和改进。为了用最少的努力和时间轻松升级到 Java 17，可以使用<strong class="kt ir"> Docker </strong>来实现这个目的。开发人员将能够定义他们的<strong class="kt ir">连续集成/部署(CI/CD) </strong>管道，并在与 JDK 17 一起运行的<strong class="kt ir"> Docker 映像中运行所有内容。</strong></p><p id="692e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不影响使用旧版本 Java 的其他应用程序/团队。</p><h2 id="e672" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">迁移到 Java X 还是最新的 LTS 版本？</h2><p id="27f6" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">是的，总是建议升级到最新版本，但不是从第一天开始。您正在使用的软件和库可能没有更新到包括与 Java 17 的兼容性，最好等待一段时间，直到完成。因为这是一个长期维护版本，所以您的生产环境很可能最终会更新到 Java 17。</p><p id="6f64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您正在开始一个全新的项目，选择 Java 17 可能是最明智的选择，因为它降低了迁移成本。它还允许开发人员利用所有最新的特性，例如对 Java 上运行的容器的改进支持，以及新的低延迟垃圾收集实现。</p><p id="e739" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于非 LTS 版本，迁移始终是可能的。我们特别建议禁用<strong class="kt ir">预览</strong>功能，尤其是在生产中。这意味着这些特性必须在下一个版本中重新编译，但它允许为 java 团队提供更好的反馈，以便完善这些在 preview 中引入的特性，或者在未来的版本中取消它们。</p></div></div>    
</body>
</html>