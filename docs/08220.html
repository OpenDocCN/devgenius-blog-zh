<html>
<head>
<title>Python3: Everything is Object!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python3:一切都是对象！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python3-everything-is-object-220de0c3bf99?source=collection_archive---------4-----------------------#2022-05-27">https://blog.devgenius.io/python3-everything-is-object-220de0c3bf99?source=collection_archive---------4-----------------------#2022-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ba00f9eaa305aee074b0ff03accecbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6Sr91LSP10vjpP4m-lPLA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来源<a class="ae jz" href="https://medium.com/@bdov_?source=user_profile-------------------------------------" rel="noopener"> <strong class="bd ka">布伦南·D·巴拉班</strong> </a></figcaption></figure><p id="ace9" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">最近，我开始学习 Python。来自 C 编程语言，起初 Python 感觉超级简单。不再有半列、分段错误、内存分配和释放……不再有指针！！然后，我们开始学习对象、类、实例属性…这时候事情开始变得复杂起来。在这篇文章中，我想分享我到目前为止学到的东西，希望它能帮助所有现在和未来的 Python 学生——所以，让我们开始吧！</p><h1 id="dfaa" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python 的简单介绍</h1><blockquote class="lw"><p id="7023" class="lx ly in bd lz ma mb mc md me mf ky dk translated">Python 是一种解释性的、交互式的、面向对象的编程语言。它包含模块、异常、动态类型、非常高级的动态数据类型和类。— <a class="ae jz" href="https://docs.python.org/3/faq/general.html#general-information" rel="noopener ugc nofollow" target="_blank"> Python 软件基础常见问题解答</a></p></blockquote><p id="1c9e" class="pw-post-body-paragraph kb kc in kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ig bi translated">Python 由吉多·范·罗苏姆在 20 世纪 80 年代末开发，并于 1991 年首次发布。它是以英国广播公司的节目“巨蟒”命名的，而不是以这种动物命名的。🐍</p><p id="dbda" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Python 是当今最常用的编程语言之一。它以易用、易读和紧凑而闻名(Python 脚本通常比 C 语言短得多)。它也是可扩展的，可以用于各种各样的应用程序，从 web 和软件开发到数学和系统脚本等等。</p><p id="5fdd" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Python 的最新版本是 Python 3，这也是我将在这篇博客中使用的。</p><h1 id="c98c" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是面向对象编程语言？</h1><p id="4f81" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated"><strong class="kd io">面向对象编程(OOP)是一种计算机编程模型，其中软件设计是围绕数据或对象组织的，而不是围绕功能和逻辑。</strong></p><p id="b313" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在 OOP 中有 4 个构建块:</p><ul class=""><li id="4136" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">类——它们是由用户定义的数据类型，充当单个对象、属性和方法的蓝图。</li><li id="6da2" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">对象—它们是具有专门定义的数据的类的实例。</li><li id="72e8" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">方法——它们是在类内部定义的函数，描述对象的行为。</li><li id="bfb0" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">属性—它们是在类模板中创建的，代表对象的状态。</li></ul><p id="43a4" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">今天我们将把重点放在物品上。</p><h1 id="c4ee" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python 中的对象</h1><p id="06e8" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">在 Python 中，一切都被当作一个对象！Python 中的对象可以定义为具有唯一属性和行为的数据字段。如果类是一个想法，那么对象就是它的执行。</p><p id="ec5d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">每个对象都有三个属性:</p><ul class=""><li id="378a" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">身份(或 id) —它是对象在内存中的地址</li><li id="c885" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">类型—创建的对象的种类—例如整数、字符串、列表</li><li id="30e2" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">值-是对象存储的数据值。例如<code class="fe ne nf ng nh b">list = [1, 2, 3]</code>保存整数 1、2 和 3</li></ul><p id="d244" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">一旦创建了对象，就不能更改 Id 和类型。值可以更改，但只适用于可变对象。</p><h1 id="ed7a" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可变 vs 不可变<strong class="ak">对象</strong></h1><p id="a763" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">Python 中的对象要么是<strong class="kd io">可变的，要么是</strong>不可变的。</p><p id="7789" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">韦氏词典词典对这两个形容词的定义如下:</p><blockquote class="lw"><p id="f64c" class="lx ly in bd lz ma mb mc md me mf ky dk translated">易变——易于改变，能够改变或被改变，能够或易于突变</p><p id="0749" class="lx ly in bd lz ma mb mc md me mf ky dk translated">不可变——不能够或不容易改变</p></blockquote><p id="e472" class="pw-post-body-paragraph kb kc in kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ig bi translated">在 Python 的上下文中，可变是对象改变其值的能力。可变对象的值可以随着时间而改变。然而，不可变对象的值不能随时间改变。一旦创建，这些对象的值是永久的。</p><p id="a9bb" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">常见易变类型</strong>(几乎所有其他类型):</p><ul class=""><li id="d435" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">可变序列:<code class="fe ne nf ng nh b">list()</code>，<code class="fe ne nf ng nh b">bytearray()</code></li><li id="36e7" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">设定类型:<code class="fe ne nf ng nh b">set()</code></li><li id="b698" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">映射类型:<code class="fe ne nf ng nh b">dict()</code></li><li id="0601" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">类，类实例</li><li id="2ddd" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">等等(那几乎是其他的一切！)</li></ul><p id="bf82" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">普通不可变类型</strong>:</p><ul class=""><li id="1f5f" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">编号:<code class="fe ne nf ng nh b">int()</code>、<code class="fe ne nf ng nh b">float()</code>、<code class="fe ne nf ng nh b">complex()</code></li><li id="a94e" class="mq mr in kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">不可变序列:<code class="fe ne nf ng nh b">str()</code>、<code class="fe ne nf ng nh b">tuple()</code>、<code class="fe ne nf ng nh b">frozenset()</code>、<code class="fe ne nf ng nh b">bytes()</code></li></ul><p id="1d50" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">注意:元组和冻结集是特例，因为它们是不可变的，但是它们可以包含可变对象——后面会详细介绍！</p><h2 id="4997" class="ni la in bd ka nj nk dn le nl nm dp li km nn no lm kq np nq lq ku nr ns lu nt bi translated">你是什么类型的()？</h2><p id="0829" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">要检查变量的类型，可以使用内置函数<code class="fe ne nf ng nh b">type()</code></p><p id="9a53" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">内置函数<code class="fe ne nf ng nh b">type()</code>返回作为参数传递的变量(对象)的类类型。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="08a6" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; type(a)<br/>&lt;class ‘int’&gt;</span></pre><p id="ff1e" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">注意，还有另一个内置函数也检查对象的类型<code class="fe ne nf ng nh b">isinstance()</code>，它有两个参数，您想要检查的对象和您想要检查的类型。它相应地返回一个布尔值。另一个区别是<code class="fe ne nf ng nh b">isinstance()</code>另外检查子类，而<code class="fe ne nf ng nh b">type()</code>没有。</p><p id="e544" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">但是我们如何测试一个变量是可变的还是不可变的呢？为此，我们需要使用<code class="fe ne nf ng nh b">id()</code>内置函数和<code class="fe ne nf ng nh b">is</code>和<code class="fe ne nf ng nh b">is not</code>操作符。让我们看看它们是如何工作的。</p><h1 id="8a67" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">对象一样不一样？</h1><blockquote class="lw"><p id="6506" class="lx ly in bd lz ma mb mc md me mf ky dk translated">每个对象都有标识、类型和值。对象的标识一旦被创建就永远不会改变；你可以认为它是对象在内存中的地址。“is”运算符比较两个对象的标识；id()函数返回一个表示其身份的整数。Python 语言参考<a class="ae jz" href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noopener ugc nofollow" target="_blank">数据模型</a></p></blockquote><h2 id="0ea9" class="ni la in bd ka nj og dn le nl oh dp li km oi no lm kq oj nq lq ku ok ns lu nt bi translated">如何找到一个对象标识:id()</h2><p id="4948" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">在对象的生命周期中，对象的 id 是唯一的和不变的。生存期不重叠的两个对象可能具有相同的 id。每次运行程序时，对象的 id 都会不同。除了少数例外，我们将在博客的后面触及。</p><p id="2845" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">为了检查一个对象的 id，我们可以使用 Python 的<code class="fe ne nf ng nh b"><strong class="kd io">id()</strong></code>内置函数，它接受一个参数并返回一个表示对象身份的整数。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="c8bd" class="ni la in nh b gy oc od l oe of"> &gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; b = 2<br/>&gt;&gt;&gt; id(a)<br/>4373702960<br/>&gt;&gt;&gt; id(b)<br/>4373702992</span></pre><p id="aec4" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">你可以在上面的例子中看到<code class="fe ne nf ng nh b">a</code>和<code class="fe ne nf ng nh b">b</code>有不同的<code class="fe ne nf ng nh b">id</code>值。</p><h2 id="4af4" class="ni la in bd ka nj nk dn le nl nm dp li km nn no lm kq np nq lq ku nr ns lu nt bi translated">是还是不是——这是个问题！</h2><p id="eae3" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated"><code class="fe ne nf ng nh b">is </code>操作符将比较两个名字是否指向同一个对象，如果是，则返回 true(<code class="fe ne nf ng nh b">is not </code>将执行相反的操作。)</p><p id="fc5b" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在不可变对象的情况下，比如整数和字符串，Python 通过使引用同一个字符串值的两个名称引用同一个对象来优化资源。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="e355" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; b = 2<br/>&gt;&gt;&gt; a is b<br/>False<br/>&gt;&gt;&gt; id(a)<br/>4339826928<br/>&gt;&gt;&gt; id(b)<br/>4339826960</span><span id="0cda" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; b = 1<br/>&gt;&gt;&gt; a is b<br/>True<br/>&gt;&gt;&gt; id(a)<br/>4339826928<br/>&gt;&gt;&gt; id(a)<br/>4339826928</span><span id="7ea7" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; s_1 = "Hello"<br/>&gt;&gt;&gt; s_2 = "Hello"<br/>&gt;&gt;&gt; s_1 is s_2<br/>True<br/>&gt;&gt;&gt; id(s_1)<br/>4344344816<br/>&gt;&gt;&gt; id(s_2)<br/>4344344816</span></pre><p id="3a4e" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">重要信息——<code class="fe ne nf ng nh b">is</code>运算符不同于<code class="fe ne nf ng nh b">==</code>比较运算符。</p><p id="3c35" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe ne nf ng nh b">==</code>操作符只会检查对象是否有相同的值，而不会检查它们是否是同一个对象。如果它们有相同的值，它将返回 True，否则返回 False。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="194a" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; b = 2<br/>&gt;&gt;&gt; a == b<br/>False</span><span id="8d7d" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; b = 2<br/>&gt;&gt;&gt; a == b<br/>True<br/></span><span id="a8e2" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; s_1 = "Hello"<br/>&gt;&gt;&gt; s_2 = "Hello"<br/>&gt;&gt;&gt; s_1 == s_2<br/>True</span></pre><p id="e39f" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">从下面的例子可以看出，当<code class="fe ne nf ng nh b">==</code>操作符返回<code class="fe ne nf ng nh b">True</code>时，id 号也将是相同的。当它返回<code class="fe ne nf ng nh b">False</code>时，反之亦然</p><p id="7aed" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然而，列表的行为是不同的:list_a 和 list_b 具有相同的值，但是不引用同一个对象</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="df6e" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; list_a = [4, 5, 6]<br/>&gt;&gt;&gt; list_b = [4, 5, 6]<br/>&gt;&gt;&gt; list_a == list_b<br/>True<br/>&gt;&gt;&gt; list_a is list_b<br/>False</span></pre><h2 id="05ac" class="ni la in bd ka nj nk dn le nl nm dp li km nn no lm kq np nq lq ku nr ns lu nt bi translated">别名</h2><p id="6e14" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">当我们给同一个变量取另一个名字时，这就叫做别名。对一个别名的更改会影响另一个别名。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="ee40" class="ni la in nh b gy oc od l oe of"><strong class="nh io">&gt;&gt;&gt; </strong>a = [7, 8, 9]<br/><strong class="nh io">&gt;&gt;&gt; </strong>b = a<br/><strong class="nh io">&gt;&gt;&gt; </strong>a is b<br/>True</span></pre><p id="3cb8" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">注意:别名在处理不可变对象时很有用，但是在处理可变对象时最好避免，因为它可能会以意想不到的方式运行。</p><h1 id="0a7a" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不变性的例外</h1><p id="7ebc" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">每个规则都有例外！在这种护理中，他们是:</p><ul class=""><li id="44c6" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">介于-5 和 256(含)之间的整数。</li></ul><p id="78bb" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">它们有一个不变的唯一 id，因此它们总是指向内存中已经存在的同一个对象。更多信息，请看这篇文章<a class="ae jz" href="http://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers" rel="noopener ugc nofollow" target="_blank">堆栈溢出:“is”操作符对整数的行为出乎意料</a></p><ul class=""><li id="4497" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">一些字符串</li></ul><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="872c" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; a = "Python is cool!"<br/>&gt;&gt;&gt; b = "Python is cool!"<br/>&gt;&gt;&gt; a is b<br/>False</span></pre><p id="88c6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这是 Python 中<em class="om">字符串实习</em>工作方式的产物。字符串滞留是一种机制，在内存中只存储一个字符串值的副本，以便在比较值相同的字符串时节省内存空间和时间。简而言之，如果字符串“非常”长，Python 认为不需要节省时间来比较它，所以它会创建另一个副本。要了解更多关于字符串实习的知识，请查看<a class="ae jz" href="https://medium.com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster-9be71c7a5f3e#:~:text=What%20Is%20the%20String%20Interning,same%20object%20in%20the%20memory." rel="noopener">这篇非常有用的文章</a></p><ul class=""><li id="51a0" class="mq mr in kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">空元组</li></ul><p id="0248" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">元组是不可变类型，但包含可变对象！元组中的列表和其他可变对象可能会改变，但是它们的 id 总是相同的。所以元组即使有相同的值也会指向不同的对象。除了空元组将引用相同的对象。这是代码证明👇🏾</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="2c6b" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; a = (1, 2)<br/>&gt;&gt;&gt; b = (1, 2)<br/>&gt;&gt;&gt; a is b<br/>False</span><span id="065f" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; a = ()<br/>&gt;&gt;&gt; b = ()<br/>&gt;&gt;&gt; a is b<br/>True</span></pre><p id="8456" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">要了解更多关于元组行为的信息，这里有一篇由卢西亚诺·拉马尔霍撰写的精彩博文。</p><h1 id="a06d" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">=和+=运算符的区别</h1><h2 id="74ec" class="ni la in bd ka nj nk dn le nl nm dp li km nn no lm kq np nq lq ku nr ns lu nt bi translated">分配和引用</h2><p id="822c" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">让我们看看代码示例:</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="c780" class="ni la in nh b gy oc od l oe of">&gt;&gt;&gt; list_a = [0, 2, 4]<br/>&gt;&gt;&gt; id(list_a)<br/>4310781760<br/>&gt;&gt;&gt; list_a = list_a + [6]<br/>&gt;&gt;&gt; id(list_a)<br/>4310785408<br/>&gt;&gt;&gt; list_a<br/>[0, 2, 4, 6]</span><span id="50a9" class="ni la in nh b gy ol od l oe of">&gt;&gt;&gt; list_b = [1, 3, 5]<br/>&gt;&gt;&gt; id(list_b)<br/>4310763904<br/>&gt;&gt;&gt; list_b += [7]<br/>&gt;&gt;&gt; id(list_b)<br/>4310763904<br/>&gt;&gt;&gt; list_b<br/>[1, 3, 5, 7]</span></pre><p id="d85a" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">你看到刚才发生的事了吗？当我们使用运算符<code class="fe ne nf ng nh b">+ </code>给<code class="fe ne nf ng nh b">list_a</code>赋值时，我们创建了一个新对象，而当我们使用<code class="fe ne nf ng nh b">+=</code>时，对象保持不变！</p><p id="3132" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">为了理解为什么会发生这种情况，我们需要理解两个操作符之间的区别。</p><p id="6703" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe ne nf ng nh b">+</code>操作符调用了<code class="fe ne nf ng nh b">__add__</code>魔法方法，它不会修改任何一个参数。所以<code class="fe ne nf ng nh b">list_a + [6] </code>用值[0，2，4，6]创建了一个新对象，现在左手边的<code class="fe ne nf ng nh b">list_a</code>引用了这个值。*</p><p id="aafd" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然而，<code class="fe ne nf ng nh b">+=</code>操作符(相当于<code class="fe ne nf ng nh b">list_a.append(x)_ )</code>调用<code class="fe ne nf ng nh b">__iadd__</code>来就地修改参数。</p><p id="da38" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">*注意:与许多编程语言一样，<strong class="kd io">在赋值语句中，左边的名字与右边的值相关联。</strong>首先评估右侧。然后创建一个新对象或检索一个现有对象。只有在创建或检索对象后，才会为其分配名称。在 Python 中，我们说名称引用值，或者名称是对值的引用。</p><p id="8e79" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在结束这篇博客之前，我还想谈一件事，那就是…</p><h1 id="abb4" class="kz la in bd ka lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">传递可变和不可变对象</h1><p id="e587" class="pw-post-body-paragraph kb kc in kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky ig bi translated">您可能想知道参数是如何传递给函数的，这对可变和不可变对象意味着什么？Python 对待可变和不可变对象有什么不同？</p><p id="5908" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">不可变对象</strong></p><p id="1fb7" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们考虑下面这个例子:</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="f9d2" class="ni la in nh b gy oc od l oe of">def increment(n):<br/>    n += 1<br/><br/>a = 1<br/>increment(a)<br/>print(a)<br/>1</span></pre><p id="e3a7" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在这种情况下，我们有一个变量<code class="fe ne nf ng nh b"> a = 1.</code>函数 increment(n)有一个引用同一个对象的局部变量 n。然而，由于整数是不可变的，我们不能将 object 的值改为 2:我们必须创建一个值为 2 的新对象。这就是为什么调用<code class="fe ne nf ng nh b">increment()</code>后<code class="fe ne nf ng nh b"><em class="om">a</em></code>的值不变。</p><p id="0a4d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然而，我们可以通过向函数添加返回值来修改不可变对象的值:</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="0f7d" class="ni la in nh b gy oc od l oe of">def increment(n):<br/>    n += 1<br/>    return n</span><span id="2ea4" class="ni la in nh b gy ol od l oe of">a = 1<br/>increment(a)<br/>2</span></pre><p id="6a3b" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io">可变对象</strong></p><p id="cd22" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然而，可变对象，比如一个列表，可以被修改——这就是下面例子中的<code class="fe ne nf ng nh b">.append()</code>方法所做的。</p><pre class="nu nv nw nx gt ny nh nz oa aw ob bi"><span id="1e68" class="ni la in nh b gy oc od l oe of">def increment(n):<br/>    n.append(4)<br/><br/>list_a = [1, 2, 3]<br/>increment(list_a)<br/>print(list_a)<br/>[1, 2, 3, 4]</span></pre><p id="2ef1" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">没有创建新的对象，而是在对象的位置发生了变化——所以当打印<code class="fe ne nf ng nh b">list_a</code>时，我们得到了修改后的列表！</p><p id="e9f6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然后…就这样结束了！</p><figure class="nu nv nw nx gt jo"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">资料来源:Flat-icons.com<a class="ae jz" href="https://giphy.com/flaticons/" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="ff02" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我希望这篇文章对你有所帮助。如有任何问题、评论或你想打招呼，请通过 LinkedIn<a class="ae jz" href="https://www.linkedin.com/in/chiara-caprasi/" rel="noopener ugc nofollow" target="_blank">联系我，或通过 Medium 关注我。</a></p><p id="0635" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="om">保持快乐，继续编码！</em>👩🏻‍💻</p><p id="2478" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="om">有用的资源</em></p><div class="op oq gp gr or os"><a href="http://www.openbookproject.net/thinkcs/python/english2e/ch09.html#objects-and-values" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">9.列表——如何像计算机科学家一样思考:学习 Python 第二版文档</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">列表是一组有序的值，每个值由一个索引标识。组成列表的值是…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.openbookproject.net</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jt os"/></div></div></a></div><div class="op oq gp gr or os"><a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">理解 Python 变量和内存管理</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">你有没有注意到 Python 和 C 语言中变量的区别？例如，当你做一个像…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">foobarnbaz.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg jt os"/></div></div></a></div><div class="op oq gp gr or os"><a href="http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">Python 元组:不可变但可能变化</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">Python 元组有一个令人惊讶的特性:它们是不可变的，但是它们的值可能会改变。这可能发生在元组…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">radar.oreilly.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg jt os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://nedbatchelder.com/text/names.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">关于 Python 名称和价值的事实和神话</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">该页面也有土耳其语版本。Python 中名称和值的行为可能会令人困惑。像…的许多部分一样</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">nedbatchelder.com</p></div></div><div class="pb l"><div class="pj l pd pe pf pb pg jt os"/></div></div></a></div><p id="1bfd" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><a class="ae jz" href="https://medium.com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster-9be71c7a5f3e#:~:text=What%20Is%20the%20String%20Interning,same%20object%20in%20the%20memory" rel="noopener">https://medium . com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster 9 be 71 c 7 a5 f3e #:~:text = What % 20 is % 20 the % 20 string % 20 interning，same % 20 object % 20 in % 20 the % 20 memory</a>。</p></div></div>    
</body>
</html>