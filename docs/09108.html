<html>
<head>
<title>Elasticsearch custom sorting script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elasticsearch 自定义排序脚本</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elasticsearch-custom-sorting-script-7778fb661bf9?source=collection_archive---------1-----------------------#2022-07-30">https://blog.devgenius.io/elasticsearch-custom-sorting-script-7778fb661bf9?source=collection_archive---------1-----------------------#2022-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fcb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时候你会用 like 从 Elasticsearch 中检索或过滤一些东西。<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html#filter-context" rel="noopener ugc nofollow" target="_blank">在过滤上下文</a>中，查询可能不需要匹配的相关性分数，因为没有计算分数。<strong class="jm io">过滤器</strong>主要用于过滤结构化数据，如<code class="fe kj kk kl km b">status = published</code>、<code class="fe kj kk kl km b">expired_date &gt; now</code>等。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/55862436cde5448ed1787ebf78ec1d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5te8sP949V4CoxvN1XJdQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">弹性搜索以过滤内容。</figcaption></figure><h2 id="d8a9" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated"><strong class="ak">为什么要自定义排序？</strong></h2><p id="88cb" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在某些情况下，我们可能需要添加业务逻辑来对结果进行排序，例如，</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mb"><img src="../Images/11d0230870c2a0d0b44819ce83124185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KaFe146Hx3hCkzJs8tc7Pg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/scripts-and-search-speed.html?baymax=rec&amp;rogue=rec-1&amp;elektra=guide#_improving_search_speed" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/reference/7.13/scripts-and-search-speed . html</a></figcaption></figure><p id="3b3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，上述脚本可以在索引时执行或预定义，以提高搜索速度。所以在这里，我们将主要关注如何在排序字段中<strong class="jm io">使用外部上下文，因为它更适合我们的用例。</strong></p><p id="a809" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看它是如何工作的。例如，如果我们想要搜索文档 id 列表以及一些过滤器。对于这些 id，您可以为它们中的每一个定制分数，可能是 ML 模型中的<code class="fe kj kk kl km b">number_of_interactions</code>、<code class="fe kj kk kl km b">external_prices</code>，甚至是<code class="fe kj kk kl km b">prediction_scores</code>。</p><p id="7ce8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常的做法是首先查询它们，然后从代码中对结果进行排序。这意味着您不能对结果进行分页，因为 elasticsearch 不知道文档得分。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mc"><img src="../Images/b9e08846c350ea6a7c45c071078e511d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWFIYzSemwpVPIryKFU9tg.png"/></div></div></figure><p id="5949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在这里看到，订单结果与输入 id 不匹配。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="e880" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">解决方案:<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/sort-search-results.html#script-based-sorting" rel="noopener ugc nofollow" target="_blank">基于脚本的排序</a></h2><p id="f16a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">这允许使用<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-painless.html" rel="noopener ugc nofollow" target="_blank">无痛脚本语言基于定制脚本进行排序。</a>其中，<code class="fe kj kk kl km b">source</code>是脚本本身，<code class="fe kj kk kl km b">id</code>是存储的脚本，<code class="fe kj kk kl km b">params</code>是作为变量传入脚本的命名参数。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mk"><img src="../Images/67b6cb9c5241135a5e873189edc26f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwH0VKsa17AZrfdcXgdMAw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html#modules-scripting-using" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/reference/current/modules-scripting-using . html</a></figcaption></figure><p id="ecef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有来自外部环境的自定义分数，并希望将它们映射到排序脚本。下面是如何使用一个无痛脚本来完成它。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ml"><img src="../Images/944b6038f4ae8e9edbb46e499ca56e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FCC-uwlaBaxYbgOlBf3rw.png"/></div></div></figure><pre class="ko kp kq kr gt mm km mn mo aw mp bi"><span id="66c9" class="ld le in km b gy mq mr l ms mt">{<br/>  "query": {<br/>    "bool": {<br/>      "filter": [<br/>        { <br/>          "terms": { <br/>            "id": ["a", "b", "c"]<br/>          }    <br/>        }<br/>      ]<br/>    }<br/>  },<br/>  "sort": {<br/>      "_script": {<br/>         "type": "number",<br/>        "script": {<br/>        <strong class="km io">"lang": "painless",</strong><br/>        <strong class="km io">"source": """</strong><br/>          <strong class="km io">return params[doc['id'].value]</strong><br/>        <strong class="km io">""",</strong><br/>        <strong class="km io">"params": </strong>{ <br/>            "c": 30,<br/>            "a": 25,<br/>            "b": 10,<br/>        }<br/>      },<br/>      "order": "desc"<br/>    }<br/>  }<br/>}</span></pre><p id="46ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，所有的查询功能都可以在 elasticseach 内部完成，而无需在外部进行定制代码或在检索结果后进行后期处理。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="2a3d" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated"><strong class="ak">担忧？</strong></h2><p id="6244" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">正如文档中所描述的，<a class="ae ki" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html#prefer-params" rel="noopener ugc nofollow" target="_blank">在你的脚本中使用参数</a>。</p><blockquote class="mu mv mw"><p id="95aa" class="jk jl mx jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">Elasticsearch 第一次看到一个新脚本时，它会编译该脚本，并将编译后的版本存储在缓存中。编译可能是一个繁重的过程。与其在脚本中硬编码值，不如将它们命名为<code class="fe kj kk kl km b">params</code>进行传递。</p><p id="9b5d" class="jk jl mx jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">…如果你在短时间内编译了太多独特的脚本，Elasticsearch 会以一个<code class="fe kj kk kl km b">circuit_breaking_exception</code>错误拒绝新的动态脚本。</p></blockquote><p id="9f8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您可以首先根据您的用例规模来测试这个想法，然后进行相应的调整。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="1182" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">最终想法</h2><p id="6eff" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在将外部环境包括到排序字段中时，仍然有很大的改进空间，比如交互事件、来自 ML 的预测分数等。创建一个接收管道可能是另一种方法，但是也有一些权衡。</p><p id="f3f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有人以前遇到过这种情况或者有更好的建议。请随时留下您的评论，我很乐意收到您的来信。</p></div></div>    
</body>
</html>