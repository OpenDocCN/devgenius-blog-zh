<html>
<head>
<title>Golang Kafka 101: Extract and Calculate our Consumer Lag</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗·卡夫卡 101:提取并计算我们的消费滞后</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-kafka-101-extract-and-calculate-our-consumer-lag-40f902158948?source=collection_archive---------5-----------------------#2022-04-01">https://blog.devgenius.io/golang-kafka-101-extract-and-calculate-our-consumer-lag-40f902158948?source=collection_archive---------5-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="de8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<a class="ae kl" href="https://medium.com/@javiersotodev/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9" rel="noopener">系列</a>的第二部分，用最重要的自定义指标管理我们的 Golang Kafka 消费者:消费者滞后。在这里，我们将解释和展示代码部分，以计算和公开我们的服务的消费者滞后</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b3aa01dd69d0034f154b09ebcbeafeca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOgr0yiTSGI-XHtTQlatXA.png"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="5837" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a56b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">从本质上来说，代码就像一个本地计算器，用于运行特定的消费者实例，并为其分配特定的分区。我们计算最高偏移量(产生的最后一条消息)和消费者的当前偏移量之间的差值，这个差值就是我们所说的消费者延迟或积压。这些信息随后通过端点公开，以便动态访问。</p><h1 id="c801" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">介绍</h1><p id="654f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在这篇文章中，我将从技术上解释不同的方法和代码片段，这些方法和代码片段用于计算和暴露我们的消费者滞后，为我们未来的步骤做准备。</p><ol class=""><li id="c335" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated"><a class="ae kl" href="https://javiersotodev.medium.com/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9" rel="noopener">简介:管理 Golang Kafka 消费滞后</a></li><li id="0ce5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">提取并计算我们的消费者滞后</li><li id="89ee" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">构建和使用我们的定制 HPA</li><li id="fc53" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">深入了解我们的 Kubernetes 控制器</li></ol><h1 id="f446" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">戈朗卡夫卡消费者的问题</h1><p id="eb35" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在与 Golang 和它的 Confluence Kafka 软件包一起工作了几年之后，我可以肯定地说，毕竟它提供了令人惊奇的东西，而且实现起来又快又容易；它缺少 Java Kafka 消费者提供的开箱即用的基本要素之一:指标。</p><p id="8c68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有多种方法来聚集和导出这些指标，但是您确实需要对软件包有广泛的了解，以便针对具体情况。这是我为自己的用例所做的研究，这也是我与大家分享的原因。我们工程师互相帮助，使我们的生活更容易。</p><h1 id="f922" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">第一步</h1><p id="56ef" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">作为一个经验法则，每次我编码时，我组织我的初步模型并创建结构。我们将有两个简单的结构来表示我们所有的消费者滞后信息。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="ee5e" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">我们的“计算器”</h1><p id="9876" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们的计算器很简单，我们将创建一个名为“Backlog”的函数来计算我们的滞后，该函数将返回我们的“lag”对象，并在发生错误时返回一个错误。在我们的函数中，我们将执行一个两步过程:</p><ul class=""><li id="998d" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk nd mt mu mv bi translated">通过 Kafka 包中的方法获取我们的主题/分区信息</li><li id="b10e" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nd mt mu mv bi translated">从分配的分区获取水印偏移，使用产生的最高偏移(highOffset)和提交的最后偏移(offset)计算我们的滞后。我们将它保存到我们的结构中，并将每个分区的延迟添加到 totalLag 变量中</li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="fb62" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">暴露我们的度量</h1><p id="dcbb" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">太好了！我们已经为滞后计算器添加了逻辑，现在是时候使用它了。为此，我们将通过路由器暴露它。在这种情况下，我将<a class="ae kl" href="https://github.com/go-chi/chi" rel="noopener ugc nofollow" target="_blank">围棋</a>用于我们的路由器:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="3093" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">次要方法</h1><p id="ca0a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">另一种展示/可视化我们的度量的方法是通过卡夫卡事件。尽管这个方法不能手动触发，但是可以通过日志导出器以恒定的方式将其导出为 ELK 堆栈(这就是我们使用它的方式)。</p><p id="d447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，您需要稍微更改一下 Kafka 消费者的配置，并正确处理事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，我们通过从 stats 事件中检索的信息来计算延迟:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="1fb8" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">包扎</h1><p id="5be1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在这一点上，我们已经暴露了我们的消费者滞后，并准备好被利用，但是有一个问题，这将只显示消费者(或消费者组)的特定实例的消费者滞后。这意味着，如果您有 10 个 pods/consumer 实例在运行和阅读，您必须逐个点击它们并合计滞后，以获得该组的完整消费者滞后。你不要担心，因为我已经找到了一个解决方案，这将需要更多的设置与另一个服务:我们的 Kubernetes 控制器。</p><p id="71a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一篇文章将关注我们为 Golang Kafka 消费者定制的 HPA！(终于知道了)</p></div></div>    
</body>
</html>