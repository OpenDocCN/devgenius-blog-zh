<html>
<head>
<title>File-Driven API testing in Golang, the unconventional way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 中的文件驱动 API 测试，非常规方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/file-driven-api-testing-in-golang-the-unconventional-way-18577a586cdb?source=collection_archive---------11-----------------------#2022-02-21">https://blog.devgenius.io/file-driven-api-testing-in-golang-the-unconventional-way-18577a586cdb?source=collection_archive---------11-----------------------#2022-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="3ba4" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我如何在 Golang 中创建了一个函数来测试我所有的 API 端点。</p></blockquote><p id="cdce" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我个人从来不喜欢 Golang 的测试惯例。不得不为每个测试用例定义新的功能很快就会变得不和谐。因此，当我被告知为一项任务编写 API 测试时，我决定采用一种非常规的方式。</p><p id="5d62" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">让我们从一些基础开始，Golang 的运行时提供了一个<code class="fe kp kq kr ks b">testing</code>包，即使对初学者来说也相当容易使用。我不会在这篇博客中详细讨论<code class="fe kp kq kr ks b">testing</code>包。</p><p id="d471" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">这个包将所有以<code class="fe kp kq kr ks b">_test.go</code>结尾的文件识别为包含测试的文件，并在<code class="fe kp kq kr ks b">go test</code>命令运行时运行。</p><h2 id="9cac" class="kt ku in bd kv kw kx dn ky kz la dp lb km lc ld le kn lf lg lh ko li lj lk ll bi translated">表格驱动测试</h2><p id="9947" class="pw-post-body-paragraph jn jo in jq b jr lm jt ju jv ln jx jy km lo kb kc kn lp kf kg ko lq kj kk kl ig bi translated">表驱动测试减轻了为每个新测试用例编写新函数的负担。我们没有为每个测试用例编写新的函数，而是定义了一个新的<code class="fe kp kq kr ks b">struct</code>来保存所有的测试用例。</p><p id="d036" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">不打算过多讨论表驱动测试的细节，但是<a class="ae lr" href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">这里有一个</em> </strong> </a>的博客介绍它。</p><p id="3df7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">表驱动测试是可以的，但是为了添加一个新的测试用例，测试用例设计者必须具备 Golang 的知识。</p><h2 id="d4dd" class="kt ku in bd kv kw kx dn ky kz la dp lb km lc ld le kn lf lg lh ko li lj lk ll bi translated">文件驱动测试</h2><p id="e527" class="pw-post-body-paragraph jn jo in jq b jr lm jt ju jv ln jx jy km lo kb kc kn lp kf kg ko lq kj kk kl ig bi translated">进入文件驱动测试，它非常类似于表格驱动测试。然而，我们没有在<code class="fe kp kq kr ks b">_test.go</code>测试文件中定义测试用例，而是为测试用例创建了一个单独的文件。在我的例子中，我使用了<code class="fe kp kq kr ks b">json</code>来定义测试用例。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="de5b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">既然我们已经完成了基础部分。先说我做了什么奇怪的事。</p><p id="f8e1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">对于我创建的测试 API，我有 3 个模型:<code class="fe kp kq kr ks b">user</code>、<code class="fe kp kq kr ks b">product</code>和<code class="fe kp kq kr ks b">review</code></p><p id="3af6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated"><code class="fe kp kq kr ks b">GetUser</code>、<code class="fe kp kq kr ks b">CreateProduct</code>和<code class="fe kp kq kr ks b">CreateReview</code>需要用户验证。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="f5ab" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我在我的测试用例中使用了下面的<code class="fe kp kq kr ks b">json</code>结构。</p><pre class="lz ma mb mc gt md ks me mf aw mg bi"><span id="44af" class="kt ku in ks b gy mh mi l mj mk">{<br/>    "name": "",         // test case name<br/>    "endpoint": "",     // endpoint to make the request at<br/>    "method": "",       // the method to use to make the request<br/>    "handler": "",      // the handler to use to make the request<br/>    "inputHeaders": {}, // the headers to send with the request<br/>    "inputBody": {},    // the body to send with the request<br/>    "expected": {<br/>        "status": 0,    // the expected status code<br/>        "response": {}  // the expected response<br/>    }<br/>}</span></pre><p id="1ea9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">这是它在 Golang 的样子。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="138b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">现在，为了我的测试目的，我想创建一个单独的函数来测试和运行一切。听起来很简单，对吧？不完全是，至少在 Golang 不是。</p><p id="f55a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">这是因为 Golang 中的 API 测试不向服务器发出模拟请求(不像其他一些框架，如<code class="fe kp kq kr ks b">javascript</code>中的<code class="fe kp kq kr ks b">chai</code>)，相反，它只是用给定的请求和响应记录器调用处理程序。</p><p id="0846" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好的，但是我们如何从我们计划的单一方法中调用不同的处理函数呢？简单，用地图。(我希望这种行为在未来的 Golang 版本中会变得更好，我们可以改为向服务器发出实际的请求)。</p><p id="ed0b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">总之，这是我创建的地图。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b140" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">现在，为了初始化测试用例，我们需要数据库中一些现有的<code class="fe kp kq kr ks b">users</code>、<code class="fe kp kq kr ks b">products </code>和<code class="fe kp kq kr ks b">reviews</code>。在创建了模型的上述实例后，我将它们的<code class="fe kp kq kr ks b"><strong class="jq io"><em class="jp">id</em></strong></code>和<code class="fe kp kq kr ks b">user</code>中的<code class="fe kp kq kr ks b"><strong class="jq io"><em class="jp">jwtToken</em></strong></code> <strong class="jq io"> <em class="jp"> </em> </strong>存储起来以备将来之用。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="d948" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好了，现在我们已经设置了前提，让我们进入实际的测试函数。</p><p id="753b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">测试函数采用三个参数:<code class="fe kp kq kr ks b">t testing.T</code>、<code class="fe kp kq kr ks b">casesFile string</code>和<code class="fe kp kq kr ks b">func</code>来生成<code class="fe kp kq kr ks b">newRequest</code>，为什么是<strong class="jq io"> <em class="jp"> newRequest </em> </strong>？你以后会见到我的，我保证。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2c81" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">在这里，我们设置了<code class="fe kp kq kr ks b">test</code>数据库，并将测试用例文件解析成我们将用来运行测试的<code class="fe kp kq kr ks b">testCases</code>变量。</p><p id="fc6d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">现在，我们已经解析了，我们需要做的就是运行测试，对吗？似乎很容易，好吧，是的，有点。</p><p id="23d1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">为了正确地测试 API，我们需要发出请求，并将预期的响应与给定的响应体进行比较。我们使用作为参数传递的<code class="fe kp kq kr ks b">newRequest() func</code>生成请求，记录响应并比较输出。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a0e8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们预期的身体反应可能是<code class="fe kp kq kr ks b">Object</code>或<code class="fe kp kq kr ks b">Array</code>，因此我们需要考虑这两种数据类型。</p><p id="3f65" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">下面是我为这些用例编写的自定义<code class="fe kp kq kr ks b">Compare() func</code>。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f068" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">除了<code class="fe kp kq kr ks b">id</code>和<code class="fe kp kq kr ks b">token</code>对象之外，<code class="fe kp kq kr ks b">MatchMaps() func</code>比较给定的贴图是否相等，因为它们在每次运行中的值可能不同。</p><p id="1b66" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">现在，关于那个<code class="fe kp kq kr ks b">newRequest func()</code> …</p><p id="b844" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">对于我们当前的用例，我们需要用给定的<code class="fe kp kq kr ks b">method</code>、<code class="fe kp kq kr ks b">endpoint</code>和<code class="fe kp kq kr ks b">inputBody</code>用<code class="fe kp kq kr ks b">newRequest() func</code>来创建请求，并设置指定的<code class="fe kp kq kr ks b">headers</code>。(除了那个<code class="fe kp kq kr ks b">Authorization</code>头，我们将使用从我们的<code class="fe kp kq kr ks b">setUp() func</code>得到的<code class="fe kp kq kr ks b">jwtToken</code>作为令牌)</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1ef9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好吧，但是如果<code class="fe kp kq kr ks b">request</code>代只有这么多，为什么要分解成另一个函数呢？实际上不只是这么多，它可以根据个人的使用情况而变化。</p><p id="6a64" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们的<code class="fe kp kq kr ks b">CreateReview</code>端点看起来像<code class="fe kp kq kr ks b">POST /api/review/{productId}</code>。这是一个问题，因为仅仅生成请求本身并不会将<code class="fe kp kq kr ks b">productId</code>设置为请求上下文中的一个变量，但是它只特定于我们的<code class="fe kp kq kr ks b">review</code>模型端点，因此我将它分解为模块化的部分，并且<code class="fe kp kq kr ks b">review</code>模型测试人员可以在上下文中提供一个带有<code class="fe kp kq kr ks b">productId</code>的新请求。</p><p id="b483" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">这是它的样子…</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="94a0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我使用<code class="fe kp kq kr ks b">chi</code>进行路由，因此我的<code class="fe kp kq kr ks b">SetUrlParamInContext() func</code>看起来像这样。根据您使用的路由器，您的设置可能会有所不同。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9431" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好了，看起来我们差不多完成了。只剩下一些东西了。</p><p id="2f18" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">一旦我们的测试运行，我们需要删除数据库<code class="fe kp kq kr ks b">test</code>。我们把这个放在<code class="fe kp kq kr ks b">t.Cleanup</code> <strong class="jq io"> <em class="jp">下回调</em> </strong>功能</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f594" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">等等，最后一件事。如果我们也想用这些来测试中间件呢？那很简单</p><p id="cf47" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们只需修改<code class="fe kp kq kr ks b">handlersMap</code>来添加<strong class="jq io"> <em class="jp">中间件</em> </strong>即可。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9775" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">这将把<code class="fe kp kq kr ks b">AuthMiddleware</code>添加到给定的端点。</p><p id="9bbb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好了，现在我们终于完成了。这里有一个测试用例文件。</p><figure class="lz ma mb mc gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="681f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好了，就这样。我们最终可以通过只定义一个函数来运行所有的测试。</p><p id="74fc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">你可以在<a class="ae lr" href="https://github.com/ShauryaAg/ProductAPI" rel="noopener ugc nofollow" target="_blank">https://github.com/ShauryaAg/ProductAPI</a>看看最终的实现</p><p id="76f2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我很确定有更好的方法来做这些事情，但这就是我所做的，最重要的是，它有效。我真的希望 Golang 的后代能改变这一点，让它变得更容易。</p></div></div>    
</body>
</html>