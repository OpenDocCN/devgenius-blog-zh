<html>
<head>
<title>IoC Kata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">国际奥委会形</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ioc-kata-c4e99694412f?source=collection_archive---------2-----------------------#2020-10-21">https://blog.devgenius.io/ioc-kata-c4e99694412f?source=collection_archive---------2-----------------------#2020-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/74d5838a3c0b3abf725d9a9c08a3694b.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*9_4KTIQ1-aN298R1OyAThQ.png"/></div></figure><p id="5ef7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如今，我们经常认为理所当然的工具之一是控制反转(IoC)容器。IoC 使得遵循依赖倒置原则(SOLID 中的“D ”)相对简单，所以开发人员经常混淆这两者并不奇怪，但它们不是一回事。IoC 容器只是实现该原则的一种方式，它是将我们大部分现代工作结合在一起的粘合剂。尽管如此，对大多数开发人员来说，这仍然是一个黑匣子，他们不知道幕后的魔力是如何发生的。我发现真正理解某些东西的最好方法是自己构建一个，所以在这篇文章中，我们将介绍如何创建一个全功能的 IoC 容器来处理最常见的情况。</p><p id="31f0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将以编码形的形式建立一个 IoC，这种做法源于 90 年代中期的软件工艺运动。卡塔是简短的编码练习，旨在帮助强化和理解常见问题的解决方案，以便当它们出现在现实世界中时，您能够识别它们，并且已经熟悉了解决方案。您通过一系列小步骤编写了一个或多或少固定的解决方案，在这里添加一个特性，在那里重构，然后朝着一个常见业务问题的公认解决方案努力，或者实现一个简单的游戏。</p><p id="fa7e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对我来说，最有用的形总是那些能教会我一些东西的，或者它们本身就是有趣的。Guy Royse 的“ever craft Kata”不是我所说的热身运动，因为你可能会花很多时间来完成你的第一次练习。它不会产生一个你可以在商业场景中利用的成品，但是它<em class="kq">确实</em>帮助你开发了一种思考<em class="kq">在日常业务中出现的问题的方式，比如给现有的实体如用户或企业增加新的功能，而不在过程中关闭现有的系统。如果你从未完成过，我建议你在某个周末完成它。</em></p><p id="835b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在阅读了由<a class="ae kp" href="http://ayende.com/Blog/archive/2007/10/20/Building-an-IoC-container-in-15-lines-of-code.aspx" rel="noopener ugc nofollow" target="_blank">柳文欢·艾尼</a>和<a class="ae kp" href="http://www.kenegozi.com/Blog/2008/01/17/its-my-turn-to-build-an-ioc-container-in-15-minutes-and-33-lines.aspx" rel="noopener ugc nofollow" target="_blank">肯·埃戈齐</a>所做的一些微 IoC 实现后，我写了我的“Itty Bitty IoC”。我看到了国际奥委会是如何在幕后运作的，并决定建立自己的国际奥委会。从那时起，我把它发展成了一个编码形，因为它真的很容易理解和使用。我现在想给你演示一下这个形。我们将一次构建一个特性，遵循测试驱动的开发模式，首先编写一个测试来演示我们想要的行为，然后在进入下一个之前实现那个特性。</p><h1 id="5815" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">第 0 步——设置 dojo</h1><p id="f4cb" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">克隆<a class="ae kp" href="https://github.com/MelGrubb/IocKata" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，并确保您在“主”分支上。这里有一个用于 IoC 的空类，一个空的测试类，以及三个将在测试中使用的相互依赖的类 Foo、Bar 和 Baz。我将使用 NUnit，因为它是。Net 空间，但是您可以使用您最喜欢的测试库。存储库还包含每个已完成步骤的分支。</p><h1 id="ccd1" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">第一步—实例注册</h1><p id="63d4" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">第一种，也是最简单的一种注册，只不过是类型或接口的目录，以及这些类型的实例<em class="kq">。每当我们需要时，这将简单地把一个类的现有实例交还给我们。实质上，当我请求一个 IFoo 时，我希望 IoC 把我注册的 Foo 的具体实例还给我。</em></p><p id="e833" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">第一个测试验证了两件事:一个实例既可以注册也可以解析，并且后续的注册会覆盖之前的注册(即，后进先出)。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="78c7" class="md ks in lz b gy me mf l mg mh">using NUnit.Framework;</span><span id="cfee" class="md ks in lz b gy mi mf l mg mh">namespace IocKata<br/>{<br/>    [TestFixture]<br/>    public class Tests<br/>    {<br/>        [Test]<br/>        public void Step1_InstanceRegistration()<br/>        {<br/>            var instance1 = new Foo(new Bar(new Baz()));<br/>            IoC.Register&lt;IFoo&gt;(instance1);</span><span id="4f1e" class="md ks in lz b gy mi mf l mg mh">            var instance2 = new Foo(new Bar(new Baz()));<br/>            IoC.Register&lt;IFoo&gt;(instance2);</span><span id="4366" class="md ks in lz b gy mi mf l mg mh">            var value = IoC.Resolve&lt;IFoo&gt;();<br/>            Assert.AreSame(instance2, value);<br/>        }<br/>    }<br/>}</span></pre><p id="0e08" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了实现这个功能，我们需要一些东西。我们需要某种容器来存储依赖项，这些是我们要注册的类型。我们可以用一个简单的字典做到这一点，使用类型作为键，使用实例作为值。我们还需要一个方法将实例<em class="kq">添加到这个字典中，并需要另一个方法来检索它们。</em></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0f3f" class="md ks in lz b gy me mf l mg mh">using System;<br/>using System.Collections.Generic;</span><span id="465c" class="md ks in lz b gy mi mf l mg mh">namespace IocKata<br/>{<br/>    public static class IoC<br/>    {<br/>        private static readonly Dictionary&lt;Type, object&gt; Dependencies = new Dictionary&lt;Type, object&gt;();</span><span id="2d02" class="md ks in lz b gy mi mf l mg mh">        public static void Register&lt;T&gt;(T instance)<br/>        {<br/>            Dependencies[typeof(T)] = instance;<br/>        }</span><span id="04d8" class="md ks in lz b gy mi mf l mg mh">        public static T Resolve&lt;T&gt;()<br/>        {<br/>            return (T) Dependencies[typeof(T)];<br/>        }<br/>    }<br/>}</span></pre><p id="a5e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此时，测试应该通过了，我们准备进入下一步。</p><h1 id="af33" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">第二步—委托注册</h1><p id="d5ff" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">下一种注册只是稍微复杂一点。我们不会向 IoC 提供要返回的实际对象，而是会传入一个在依赖关系解决后执行的函数，本质上是告诉 IoC <em class="kq">如何</em>构建类型。这些功能甚至可以利用 IoC 作为其逻辑的一部分。用法应该类似于下面的测试。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9b86" class="md ks in lz b gy me mf l mg mh">[Test]<br/>public void Step2_DelegateRegistration()<br/>{<br/>    IoC.Register&lt;IBaz&gt;(() =&gt; new Baz());<br/>    IoC.Register&lt;IBar&gt;(() =&gt; new Bar(IoC.Resolve&lt;IBaz&gt;()));<br/>    IoC.Register&lt;IFoo&gt;(() =&gt; new Foo(IoC.Resolve&lt;IBar&gt;()));</span><span id="3fc1" class="md ks in lz b gy mi mf l mg mh">    var value = IoC.Resolve&lt;IFoo&gt;();<br/>    Assert.IsInstanceOf&lt;Foo&gt;(value);<br/>    Assert.IsInstanceOf&lt;Bar&gt;(value.Bar);<br/>    Assert.IsInstanceOf&lt;Baz&gt;(value.Bar.Baz);<br/>}</span></pre><p id="cf9f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们可以将函数存储在现有的字典中，因为函数可以被视为对象，但我们需要一种方法来记住条目是表示实例还是函数，因此我们将修改字典来存储包含对象或函数的元组，以及一个新的枚举值，该值表示它是哪种依赖关系。我们将使用 C# 7 中引入的新的元组语法，使其在后面更具可读性，即使声明有点罗嗦。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="35ae" class="md ks in lz b gy me mf l mg mh">private enum DependencyType<br/>{<br/>    Instance,<br/>    Delegate,<br/>}</span><span id="fd30" class="md ks in lz b gy mi mf l mg mh">private static readonly Dictionary&lt;Type, (object value, DependencyType dependencyType)&gt; Dependencies<br/>    = new Dictionary&lt;Type, (object value, DependencyType dependencyType)&gt;();</span></pre><p id="9292" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我们需要修改现有的实例注册方法，并添加新的委托注册函数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3b9d" class="md ks in lz b gy me mf l mg mh">public static void Register&lt;T&gt;(T instance)<br/>{<br/>    Dependencies[typeof(T)] = (instance, DependencyType.Instance);<br/>}</span><span id="bacf" class="md ks in lz b gy mi mf l mg mh">public static void Register&lt;T&gt;(Func&lt;object&gt; func)<br/>{<br/>    Dependencies[typeof(T)] = (func, DependencyType.Delegate);<br/>}</span></pre><p id="8a7d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，我们将扩展 Resolve 方法以涵盖新的注册类型</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b111" class="md ks in lz b gy me mf l mg mh">public static T Resolve&lt;T&gt;()<br/>{<br/>    var dependency = Dependencies[typeof(T)];</span><span id="eec3" class="md ks in lz b gy mi mf l mg mh">    if (dependency.dependencyType == DependencyType.Instance)<br/>    {<br/>        return (T) dependency.value;<br/>    }<br/>    else<br/>    {<br/>        return (T) ((Func&lt;object&gt;) dependency.value).Invoke();<br/>    }<br/>}</span></pre><h1 id="af0d" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">第三步——单身</h1><p id="8f76" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">通过一个小的调整，我们可以将实例和委托解析结合在一起，以便将对象构造为单件。也就是说，我们将在第一次被请求时创建一个新的依赖实例，但是在以后的每次调用中返回相同的实例。下一个测试展示了我们想要的行为。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="313c" class="md ks in lz b gy me mf l mg mh">[Test]<br/>public void Step3_SingletonDelegateRegistration()<br/>{<br/>    IoC.Register&lt;IBaz&gt;(() =&gt; new Baz(), isSingleton: false);<br/>    Assert.AreNotSame(IoC.Resolve&lt;IBaz&gt;(), IoC.Resolve&lt;IBaz&gt;());</span><span id="8d25" class="md ks in lz b gy mi mf l mg mh">    IoC.Register&lt;IBaz&gt;(() =&gt; new Baz(), isSingleton: true);<br/>    Assert.AreSame(IoC.Resolve&lt;IBaz&gt;(), IoC.Resolve&lt;IBaz&gt;());<br/>}</span></pre><p id="8190" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们需要再次更新字典，这一次向元组添加第三个值来指示注册是否应该是单例的，并更新现有的 Register 方法。对于实例注册来说，isSingleton 值不会有任何区别，但是根据定义，我认为它们是单例的，所以我将在第一个 Register 方法中将它设置为 true。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8505" class="md ks in lz b gy me mf l mg mh">private static readonly Dictionary&lt;Type, (object value, DependencyType dependencyType, bool isSingleton)&gt;<br/>    Dependencies = new Dictionary&lt;Type, (object value, DependencyType dependencyType, bool isSingleton)&gt;();</span><span id="eec5" class="md ks in lz b gy mi mf l mg mh">public static void Register&lt;T&gt;(T instance)<br/>{<br/>    Dependencies[typeof(T)] = (instance, DependencyType.Instance, true);<br/>}</span><span id="0740" class="md ks in lz b gy mi mf l mg mh">public static void Register&lt;T&gt;(Func&lt;object&gt; func, bool isSingleton = false)<br/>{<br/>    Dependencies[typeof(T)] = (func, DependencyType.Delegate, isSingleton);<br/>}</span></pre><p id="fb7e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，我们将像往常一样更新 Resolve 方法来创建依赖实例，但是当它应该是单例时，将其重新注册为一个实例。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="dc77" class="md ks in lz b gy me mf l mg mh">public static T Resolve&lt;T&gt;()<br/>{<br/>    var dependency = Dependencies[typeof(T)];</span><span id="8846" class="md ks in lz b gy mi mf l mg mh">    if (dependency.dependencyType == DependencyType.Instance)<br/>    {<br/>        return (T) dependency.value;<br/>    }<br/>    else<br/>    {<br/>        var value = (T) ((Func&lt;object&gt;) dependency.value).Invoke();<br/>        if (dependency.isSingleton)<br/>        {<br/>            Dependencies[typeof(T)] = (value, DependencyType.Instance, true);<br/>        }</span><span id="0cc3" class="md ks in lz b gy mi mf l mg mh">        return value;<br/>    }<br/>}</span></pre><p id="f735" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在这是一个可用的 IoC，除了你必须明确地告诉它如何构建所有东西。它还不知道如何自己解决任何问题…目前还不知道。</p><h1 id="d938" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">第四步—动态解析</h1><p id="6c0b" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">一个真正的国际奥委会的标志之一是它有能力自己解决一些事情。只要一个类型的依赖项也被注册，就不需要给它一个函数来完成这项工作。它应该知道该做什么。它的用法应该是这样的。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fe1d" class="md ks in lz b gy me mf l mg mh">[Test]<br/>public void Step4_AutomaticResolution()<br/>{<br/>    IoC.Register&lt;IBaz, Baz&gt;();<br/>    IoC.Register&lt;IBar, Bar&gt;(isSingleton: true);<br/>    IoC.Register&lt;IFoo, Foo&gt;();</span><span id="d3d5" class="md ks in lz b gy mi mf l mg mh">    var foo = IoC.Resolve&lt;IFoo&gt;();<br/>    Assert.IsInstanceOf&lt;Foo&gt;(foo);<br/>    Assert.IsInstanceOf&lt;Bar&gt;(foo.Bar);<br/>    Assert.IsInstanceOf&lt;Baz&gt;(foo.Bar.Baz);</span><span id="44f6" class="md ks in lz b gy mi mf l mg mh">    Assert.AreNotSame(foo, IoC.Resolve&lt;IFoo&gt;());<br/>    Assert.AreSame(foo.Bar, IoC.Resolve&lt;IBar&gt;());<br/>    Assert.AreNotSame(foo.Bar.Baz, IoC.Resolve&lt;IBaz&gt;());<br/>}</span></pre><p id="63cc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您会注意到，在这个测试中，我们不再提供委托函数。我们只是告诉 IoC，当我们要求注册接口时，我们想要什么具体的类。由 IoC 选择一个构造函数并调用它，解决任何具体类的依赖关系。这比听起来容易。我们将创建第三个枚举条目来表示这种情况，并添加一个新的 Register 方法。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="d4f3" class="md ks in lz b gy me mf l mg mh">private enum DependencyType<br/>{<br/>    Instance,<br/>    Delegate,<br/>    Dynamic,<br/>}</span><span id="a08e" class="md ks in lz b gy mi mf l mg mh">public static void Register&lt;T1, T2&gt;(bool isSingleton = false)<br/>{<br/>    Dependencies[typeof(T1)] = (typeof(T2), DependencyType.Dynamic, isSingleton);<br/>}</span></pre><p id="be16" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为泛型是编译时的东西，所以我们不能使用现有的泛型 Resolve 方法在运行时构建构造函数参数。因此，我们首先需要将 Resolve 方法的主要逻辑提取到一个私有的、非泛型的版本中，该版本只返回对象，并从现有的泛型 Resolve 方法中调用它。这将允许新提取的方法回调到自身中，以在运行时解析构造函数参数。因为这篇文章已经够长了，我不会在这里深入讨论新的 Resolve 分支的所有细节，也不打算作为反思的教程，但是要点是这样的。找到“最贪婪”的构造函数，即具有最多参数的构造函数，通过回调 resolve 方法来解析这些参数，然后使用这些参数来调用您最初尝试构建的类型的构造函数。这是完整的版本。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="095f" class="md ks in lz b gy me mf l mg mh">public static T Resolve&lt;T&gt;()<br/>{<br/>    return (T) Resolve(typeof(T));<br/>}</span><span id="01cf" class="md ks in lz b gy mi mf l mg mh">private static object Resolve(Type type)<br/>{<br/>    var dependency = Dependencies[type];</span><span id="cf0c" class="md ks in lz b gy mi mf l mg mh">    if (dependency.dependencyType == DependencyType.Instance)<br/>    {<br/>        return dependency.value;<br/>    }<br/>    else if (dependency.dependencyType == DependencyType.Delegate)<br/>    {<br/>        var value = ((Func&lt;object&gt;) dependency.value).Invoke();<br/>        if (dependency.isSingleton)<br/>        {<br/>            Dependencies[type] = (value, DependencyType.Instance, true);<br/>        }</span><span id="133a" class="md ks in lz b gy mi mf l mg mh">        return value;<br/>    }<br/>    else<br/>    {<br/>        var concreteType = (Type) dependency.value;<br/>        var constructorInfo = concreteType.GetConstructors()<br/>		    .OrderByDescending(o =&gt; (o.GetParameters().Length)).First();<br/>        var parameterInfos = constructorInfo.GetParameters();</span><span id="03c9" class="md ks in lz b gy mi mf l mg mh">        if (parameterInfos.Length == 0)<br/>        {<br/>            return Activator.CreateInstance((Type)dependency.value);<br/>        }<br/>        else<br/>        {<br/>            var parameters = new List&lt;object&gt;(parameterInfos.Length);<br/>            foreach (ParameterInfo parameterInfo in parameterInfos)<br/>            {<br/>                parameters.Add(Resolve(parameterInfo.ParameterType));<br/>            }<br/>            var value = constructorInfo.Invoke(parameters.ToArray());</span><span id="c278" class="md ks in lz b gy mi mf l mg mh">            if (dependency.isSingleton)<br/>            {<br/>                Dependencies[type] = (value, DependencyType.Instance, true);<br/>            }</span><span id="19b9" class="md ks in lz b gy mi mf l mg mh">            return value;<br/>        }<br/>    }<br/>}</span></pre><p id="cfb6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">仅此而已。我们有一个不到 100 行的完整 IoC。如果您通过从 Resolve 方法中删除“else ”,并从带有单个指令的分支中删除括号，从而牺牲一些可读性，那么您可以使它变得更小。您可以看到我为什么将其命名为 IttyBittyIoC，但是您还可以做更多的事情来使它变得更好。</p><h1 id="6c23" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">额外学分:</h1><ul class=""><li id="429b" class="mj mk in jt b ju lp jy lq kc ml kg mm kk mn ko mo mp mq mr bi translated">添加一个 InjectionConstructorAttribute 来手动标记希望 IoC 使用的构造函数。</li><li id="ba54" class="mj mk in jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">添加基于约定的程序集扫描，以匹配具有相似名称的类的接口(例如 IFoo/Foo)。</li></ul><p id="18f4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以查看<a class="ae kp" href="https://github.com/MelGrubb/IocKata" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中的 Step5 和 Step6 分支来了解我是如何实现这些特性的，Step7 可以查看完全重构的、极简的 68 行版本。</p><h2 id="1bbf" class="md ks in bd kt mx my dn kx mz na dp lb kc nb nc lf kg nd ne lj kk nf ng ln nh bi translated">-梅尔·格拉布，AWH 软件开发团队负责人</h2></div></div>    
</body>
</html>