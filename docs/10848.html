<html>
<head>
<title>Kotlin Programming Langauge The Complete Learning Guide [2022] 5/6 Object Oriented Programming (OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 编程语言完全学习指南[2022] 5/6 面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-programming-langauge-the-complete-learning-guide-2022-5-6-object-oriented-programming-ed87808963f3?source=collection_archive---------20-----------------------#2022-12-03">https://blog.devgenius.io/kotlin-programming-langauge-the-complete-learning-guide-2022-5-6-object-oriented-programming-ed87808963f3?source=collection_archive---------20-----------------------#2022-12-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/531c200c98a4960392b60ad8efb01f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6s43toH5qR4MwbksikbLg.png"/></div></div></figure><p id="f2a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">学习 Kotlin 这种最强大和最有用的编程语言之一，并准备好开始开发 powerfull 原生移动应用程序和其他平台开发</p><h1 id="1696" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">目录</strong></h1><blockquote class="lr ls lt"><p id="826b" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">面向对象的介绍</p><p id="ad7c" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">类别和对象</p><p id="b039" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">类和初始值设定项</p><p id="7ec7" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">范围和阴影</p><p id="66e0" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">成员变量函数和构造函数</p><p id="239b" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">Lateinit 设置器和获取器</p><p id="ffa6" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">数据类别</p><p id="eaa2" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">遗产</p><p id="fb8e" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">接口</p><p id="fafc" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">抽象类</p><p id="3b1d" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">铸字</p></blockquote><h1 id="7ed9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="5467" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">面向对象编程(OOP)是一种依赖于<strong class="jx io">类</strong>和<strong class="jx io">对象</strong>概念的编程方式。它用于将软件或程序构建成简单的、可重复使用的代码蓝图(通常称为<strong class="jx io">类</strong>)，这些代码蓝图用于创建对象的单个实例。有许多面向对象的编程语言，包括 JavaScript、C++、Java、Python、dart 和 Kotlin</p><p id="079c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<strong class="jx io">类</strong>是一个抽象的蓝图，用来创建更具体、更具体的对象。类通常代表广泛的类别，比如共享<strong class="jx io">属性的<code class="fe md me mf mg b">Human</code>，</strong>这个类定义了自己的属性或行为，比如<strong class="jx io">性别</strong></p><p id="1ae3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类也可以包含函数，称为<strong class="jx io">方法</strong>，只对该类型的对象可用。这些函数是在类中定义的，它帮助类做我们想让它做的任何事情</p><h1 id="132b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">面向对象的好处</h1><ul class=""><li id="96f9" class="mh mi in jx b jy ly kc lz kg mj kk mk ko ml ks mm mn mo mp bi translated">OOP 将复杂的事物建模为可复制的简单结构</li><li id="7055" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">可重用的 OOP 对象可以跨程序使用</li><li id="1d05" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">您可以在一个类中存储尽可能多的变量和数据</li></ul><h1 id="86b5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">班级</h1><p id="2fbf" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">就像我们说的它是对象的蓝图，更具体地说，让我们应用一些例子</p><p id="d9ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如人类→有它自己的属性和特征</p><p id="c96b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">性别、身高、体重、姓名等</strong></p><p id="b6e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那些我们称之为变量类成员的<strong class="jx io">人类</strong></p><p id="9fb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码中，我们可以这样定义这些变量</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="e886" class="nd ku in mg b be ne nf l ng nh">val height : Double = 180.2<br/>val weight : Double = 74.4<br/>val name : String = "Mohab"<br/>val isGender : Boolean =true </span></pre><p id="1b6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那些变量是人类的属性，也是<strong class="jx io">人类</strong>类<strong class="jx io">(也叫变量成员)</strong></p><p id="9438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">人类</strong>也，<strong class="jx io">走路、吃饭、喝水、呼吸、工作、睡觉……等等</strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4e43" class="nd ku in mg b be ne nf l ng nh">fun sleep (){}<br/>fun walk (){}<br/>fun eat(){}<br/>fun breathe(){}<br/>fun work(){}</span></pre><p id="d72a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些也可以是这个类<strong class="jx io">人类</strong>的成员方法</p><p id="c73c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要将这些变量和方法的成员应用到一个类<strong class="jx io"> Human </strong></p><p id="83a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要声明的<strong class="jx io">类</strong>我们使用关键字<strong class="jx io"> <em class="lu">类</em> </strong>然后我们给这个类起一个名字<strong class="jx io"> Human </strong>以大写字母开头然后我们关闭它<strong class="jx io"> {} </strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="8972" class="nd ku in mg b be ne nf l ng nh">class Human {<br/>    val height : Double = 180.2<br/>    val weight : Double = 74.4<br/>    val name : String = "Mohab"<br/>    val isGender : Boolean =true<br/>    fun sleep (){<br/>        println("Iam Sleeping ")}<br/>    fun walk (){<br/>        println("Iam Walking now ")}<br/>    fun eat(){}<br/>    fun breathe(){}<br/>    fun work(){}<br/>}</span></pre><p id="fda9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在为一个类创建了一个非常非常简单的例子</p><p id="4a5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们尝试访问并使用这个类</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="834c" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var h : Human = Human()<br/>h.sleep()<br/>} // output "Iam Sleeping</span></pre><p id="63af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们从类 Human 中创建了一个对象，命名为 h 并初始化它，在我们运行程序并执行方法后，我们现在可以创建任意多的对象，而不必一次又一次地编写或实现这些成员</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="7085" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var h : Human = Human()<br/>h.sleep()<br/>    val anotherHuman : Human = Human()<br/>    anotherHuman.walk()<br/>}//output Iam Walking now</span></pre><p id="fee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在好了，我们知道了如何创建一个对象并访问它的成员</p><p id="3cfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我想让每个人都有自己的数据呢，是的，这很有意义，因为整个想法是制造可重用的代码，</p><h1 id="3352" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构造器</h1><p id="a46a" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">从名字中我们可以看出它是一个构建某物(我的类)的东西</p><p id="48dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构造函数和类在一起，这是一个简单的函数，它可以初始化我的变量并给它们数据。</p><p id="a5ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以 java 为例</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="24b4" class="nd ku in mg b be ne nf l ng nh">public class Human {<br/>public double height ;<br/>public void Human(double height){<br/>this.height = height ; <br/>}<br/>}</span></pre><blockquote class="lr ls lt"><p id="f8f9" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意:在编程语言中，构造函数也使用它的类名，但是在 kotlin 中，我们将看到如何创建构造函数，这也不是强制性的，但是</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="3868" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var human : Human = Human()<br/>}<br/><br/>class Human constructor(name : String , height : Double ){<br/><br/>}</span></pre><p id="406a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们创建了一个类，并为它创建了构造函数，然后我们从它获取了一个对象，但是你会注意到编译器会报错，因为我们没有在构造函数中传递我们需要的数据</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="f144" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var human : Human = Human(name = "Mohab", height = 183.0)<br/><br/>}</span></pre><p id="b822" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，还有一个与 kotlin 类相关的东西叫做 init</p><p id="eb3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦类被实例化就调用的方法</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="434a" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var human : Human = Human(name = "Mohab", height = 183.0)<br/>}<br/><br/>class Human constructor(name : String , height : Double ){<br/>init {<br/>    println(" You Created an Object From Me Human Class")<br/>}<br/>}//You Created an Object From Me Human Class</span></pre><p id="f7e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，一旦你运行程序，你会注意到</p><p id="fc16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">“你从我的人类类中创建了一个对象”，</strong>那是因为我们在我们的类中调用了这个 init 方法中的 println()，一旦对象被创建，println 就会被执行</p><p id="1e38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，这个 init 方法与构造函数相关，你也可以称它为构造函数的主体，让我们看看我们如何只创建了类，却没有添加任何变量成员</p><p id="3119" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你试图用人类。并且使用了点运算符，除了与 kotlin 语言相关的方法，你什么也找不到</p><p id="e796" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你去<strong class="jx io"> init </strong>方法，并试图从那些你声明为参数的变量中调用某个变量，你会看到它接受它</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="7561" class="nd ku in mg b be ne nf l ng nh">class Human constructor(name : String , height : Double ){<br/>init {<br/>    println(" You Created an Object From Me Human Class and named $name")<br/>}<br/>}</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="a90a" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>var human : Human = Human(name = "Mohab", height = 183.0)<br/>}// You Created an Object From Me Human Class and named Mohab</span></pre><p id="98ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看，上面印着我们给的名字</p><blockquote class="lr ls lt"><p id="e5bd" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意:构造函数中的参数都是 Val(不能被重新赋值)，不仅在构造函数中，而且在任何传递参数的函数中，都不能给这个变量赋值，只能通过传递参数来赋值</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="8a56" class="nd ku in mg b be ne nf l ng nh">fun understandScope (name : String ){<br/>    name="Mohab"<br/>}</span></pre><p id="fce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您将注意到编译器的一个错误“Val 不能被重新分配”</p><p id="c47e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你只能做的如下</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="c891" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>    understandScope("Mohab")<br/>}// accepted </span></pre><p id="af69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">蔽</strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a5b7" class="nd ku in mg b be ne nf l ng nh">    fun main() {<br/>        understandScope("Messi")<br/>    }<br/><br/>fun understandScope (name : String ){<br/>    var name : String = "Mohab"<br/>    println(name)<br/>}//ouput "Mohab"</span></pre><p id="91e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们给了参数一个值“<strong class="jx io">梅西</strong>”，它现在应该打印“<strong class="jx io">梅西</strong>”的值</p><p id="29fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是输出是<strong class="jx io">“Mohab”</strong>我们在函数体内声明的名称变量..对吧</p><p id="7d16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为它被称为<strong class="jx io">作用域</strong>函数<strong class="jx io">只作用于<strong class="jx io">作用域</strong>内的变量，如果它在函数体中的话。也可以；除了这个褐藻糖胶，在任何地方都找不到</strong></p><p id="ac94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用遮蔽时的注意事项</strong></p><blockquote class="lr ls lt"><p id="c44d" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">你的代码变得难以阅读，因为两个不同的东西有相同的名字，你或你团队中的任何人可能会感到困惑。</p><p id="7360" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">您不能再在某个范围内访问原始变量。</p></blockquote><h1 id="a74d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">类的成员变量和方法</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="2c7d" class="nd ku in mg b be ne nf l ng nh">class Human (name : String ="Mohab",lastName : String = "Erabi"){<br/>var jobTitle : String ? = null <br/>init {<br/>println("Created an instance from me with ${name} ${lastName}")<br/>}<br/>}</span></pre><p id="4f09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变量 jobTitle 在这里被称为类的成员，我们使它可空，因为如果我们有很多人存储在数据库的某个地方，如果他们中的一个或多个没有 jobtitle，我们的应用程序也应该工作</p><blockquote class="lr ls lt"><p id="3a95" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">此外，类别可以有无限数量的成员</p></blockquote><h1 id="941a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">成员方法(函数)</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="c159" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>var h = Human()<br/>    h.jobTitle = "Programmer "<br/>h.printJobTitle()<br/>}<br/>class Human (name : String ="Mohab",lastName : String = "Erabi"){<br/>    var jobTitle : String ? = null<br/><br/>    init {<br/>        println("Created an instance from me with ${name} ${lastName}")<br/>    }<br/>    fun printJobTitle (){<br/>        println("You called me to tell people that your job is ${jobTitle}")<br/>    }<br/>}//output<br/>//Created an instance from me with Mohab Erabi<br/>//You called me to tell people that you job is Programmer </span></pre><pre class="ni mz mg na bn nb nc bi"><span id="b700" class="nd ku in mg b be ne nf l ng nh">(name : String ="Mohab",lastName : String = "Erabi"){}</span></pre><p id="6bb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这被称为类的主构造函数</p><blockquote class="lr ls lt"><p id="fb73" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意<strong class="jx io">构造函数</strong>也是这个类的成员</p></blockquote><p id="bd99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们还可以创建第二个构造函数</strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="7fd9" class="nd ku in mg b be ne nf l ng nh">class Human (name : String ="Mohab",lastName : String = "Erabi"){<br/>    var jobTitle : String ? = null<br/>    <br/>    <br/>    <br/>    <br/>constructor(name : String , lastName : String , jobTitle : String ):this (name , lastName ){<br/>    this.jobTitle = jobTitle<br/>}<br/>}</span></pre><p id="2361" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">this 关键字— &gt; this 引用当前类，因为它指向一个类，所以我们说<strong class="jx io"> this.jobTitle = jobTitle </strong>将被传递给构造函数</p><p id="60b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> : </strong>“那个列”表示我们为我们的类创建了一个二级构造函数，这个类已经有了一个主构造函数，还有一个变量需要初始化，所以我们也需要将这些参数传递给那个构造函数，这样我们就可以初始化人类类</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="1427" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>var h = Human()<br/>    h.jobTitle = "Programmer "<br/>h.printJobTitle()<br/>}<br/><br/><br/>class Human (name : String ="Mohab",lastName : String = "Erabi"){<br/>    var jobTitle : String ? = null<br/><br/>constructor(name : String , lastName : String , jobTitle : String ):this (name , lastName ){<br/>    this.jobTitle = jobTitle<br/>}<br/>    init {<br/>        println("Created an instance from me with ${name} ${lastName}")<br/>    }<br/>    fun printJobTitle (){<br/>        println("You called me to tell people that your job is ${jobTitle}")<br/>    }<br/>}</span></pre><p id="c3c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那个 seconadry 构造器的真正好处是什么？</p><p id="62c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我们说的 jobTitle，并不是我们数据库中的所有用户都在添加他们的 jobTitle</p><p id="23af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果我们现在创建了一个新的人类类的实例，下面我将删除默认值</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4bb5" class="nd ku in mg b be ne nf l ng nh">class Human (name : String ,lastName : String ,){<br/><br/>}</span></pre><p id="5cb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我将添加 jobtilte 变量作为类成员，并创建一个辅助构造函数</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="746f" class="nd ku in mg b be ne nf l ng nh">class Human (name : String ,lastName : String ,){<br/>var jobTitle : String ? = null<br/>}</span></pre><p id="c7a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建一个对象</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="0d65" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>var mohab = Human()<br/>}</span></pre><p id="fc25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您现在会注意到编译器抱怨缺少 name 和 lastname 的值，但是 jobTitle 呢？</p><p id="572c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，即使您在构造函数中需要它(“第二个”)</p><p id="acb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以随时添加它，只是这不是强制性的</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4ecc" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>var mohab = Human("Mohab","Erabi")<br/> var messi = Human ("Lionel" , "Messi", "Footballer")<br/>}</span></pre><p id="9535" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看，我只在“梅西”对象中添加了它，但在“莫哈布”中没有</p><blockquote class="lr ls lt"><p id="2fcd" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">请注意，这有点像方法重载，创建两个同名但参数列表不同的方法，如下所示“这也和创建多重构造函数一样”</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="6aa2" class="nd ku in mg b be ne nf l ng nh">fun iHaveSameName (name : String ){}<br/>fun iHaveSameName (){}<br/>fun iHaveSameName (age : Int ){}</span></pre><blockquote class="lr ls lt"><p id="3fff" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">“现在整个文件应该看起来像这样”</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4827" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/> var messi = Human ("Lionel" , "Messi", "Footballer")<br/>}<br/><br/><br/>class Human (name : String ,lastName : String ,){<br/>var jobTitle : String ? = null<br/>    constructor(name : String , lastName : String , jobTitle : String ):this (name , lastName ){<br/>    this.jobTitle = jobTitle<br/>        println(" called from the secondary constructor ${jobTitle}")<br/>}<br/>    init {<br/>    println("Created an instance from me with ${name} ${lastName}")<br/>}<br/>fun printJobTitle (){<br/>    println("You called me to tell people that your job is ${jobTitle}")<br/>}<br/>}<br/>//Created an instance from me with Lionel Messi<br/>// called from the secondary constructor Footballer</span></pre><p id="b02c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">init 方法在第二构造函数体之前被调用</p><p id="1658" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这需要记在心里</p><h1 id="3739" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Setters Getters 和 lateinit</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="82b5" class="nd ku in mg b be ne nf l ng nh">class Human (){<br/>var name : String <br/>}</span></pre><p id="8171" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们在类内部创建一个成员变量时，我们应该总是初始化它，就像我们在构造函数中看到的那样</p><p id="0537" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器会抱怨说</p><p id="2356" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">“属性必须初始化或者是抽象的”</strong></p><p id="1d1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以 lateinit 的功能来了“这个关键字只是告诉编译器等等，我稍后会初始化它”</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="3aa2" class="nd ku in mg b be ne nf l ng nh">class Human ( ){<br/>lateinit var name : String<br/>}</span></pre><p id="f01c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在编译器从不抱怨</p><p id="4f37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们必须初始化这个 lateinit，否则我们会有一个错误，因为它不能为空</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a862" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/><br/>    var mohab = Human()<br/>    mohab.name<br/>}<br/><br/><br/>class Human ( ){<br/>lateinit var name : String<br/>}</span></pre><p id="ee00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">线程“main”kot Lin 中出现异常。uniinitializedpropertyaccessexception:late init 属性名尚未初始化<br/>在 Human.getName(Main.kt:9) <br/>在 MainKt.main(Main.kt:4) </strong></p><p id="1fcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个异常，所以我们必须总是初始化 lateinits</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="b8fa" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/><br/>    var mohab = Human()<br/>println(    mohab.name)<br/>}<br/><br/><br/>class Human ( ){<br/>lateinit var name : String<br/>init {<br/>    name = "Mohab"<br/>}<br/>}// output <br/>//Mohab</span></pre><p id="22e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们来谈谈 getters 和 setters</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="92fd" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    var mohab = Human()<br/>println(    mohab.name)<br/>    println(mohab.age)<br/>}<br/><br/><br/>class Human ( ){<br/>lateinit var name : String<br/><br/>val  age  = 24<br/>    get() {<br/>     return  field/2<br/>    }<br/>init {<br/>    name = "Mohab"<br/>}<br/>}// output <br/>//Mohab<br/>// 12 </span></pre><p id="6476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里做了什么，get 方法对前面的行变量做了一个动作，但只是一个动作</p><p id="2719" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们创建了一个值为 24 的年龄变量，我希望 getter 返回除以 2 的值，这样每当我打印这个变量时，我都会看到“12”</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4a9d" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    var mohab = Human()<br/>println(    mohab.name)<br/>    println(mohab.age)<br/>}<br/><br/><br/>class Human ( ){<br/>lateinit var name : String<br/><br/>val  age  = 24<br/>    val myAge = 30 <br/>    get() {<br/>     return  field/2<br/>    }<br/>init {<br/>    name = "Mohab"<br/>}<br/>}// output <br/>// mohab <br/>// 24 </span></pre><p id="ec99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们所说的，它只对前面的行变量应用一个动作，因为现在我得到了 age = 24，因为我在类内部声明了它</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="3409" class="nd ku in mg b be ne nf l ng nh">println(mohab.myAge) // output 15 </span></pre><p id="41d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是字段关键字？字段指的是最后一个变量，下面代码看起来是编译器转换的</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="0755" class="nd ku in mg b be ne nf l ng nh">val myAge = 30 <br/>get ()= field <br/>set (value){<br/>field = value <br/>}</span></pre><p id="035b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到“自动”下面的一个</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a3d4" class="nd ku in mg b be ne nf l ng nh">val myAge = 30 <br/>get (){<br/>return filed/2}</span></pre><p id="4e0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是 setters。set →设置值，get →获取值</p><h1 id="7541" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">作曲者</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="ada1" class="nd ku in mg b be ne nf l ng nh">var myAge = 24</span></pre><h1 id="e067" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">吸气剂</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="36f0" class="nd ku in mg b be ne nf l ng nh">println(myAge)</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="602c" class="nd ku in mg b be ne nf l ng nh">class Human ( ){<br/><br/>val  age  = 24<br/>    set(value){}<br/><br/>}</span></pre><p id="40f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们把这个时代视为一个价值，所以它不是不可改变的</p><p id="db49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器应报错<strong class="jx io">“一个‘val’属性不能有 setter”</strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="2a1e" class="nd ku in mg b be ne nf l ng nh">class Human ( ){<br/><br/>var   age  = 24<br/>    set(value){}<br/><br/>}</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="da07" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    var mohab = Human()<br/>mohab.age = 23<br/>print(mohab.age)<br/>}<br/><br/><br/>class Human ( ){<br/><br/>var   age  = 24<br/>    set(value){<br/>        field = value<br/>    }<br/><br/>}// otuput <br/>//23</span></pre><p id="2591" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以在这个 setter 中做任何我们想做的事情</p><p id="834d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我们可以有自己的条件一样，我们可以让这个年龄永远不等于 0，或者永远不小于 0，因为没有人的年龄等于或小于 0</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="3d7d" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    var mohab = Human()<br/>mohab.age = 0<br/>print(mohab.age)<br/>}<br/><br/><br/>class Human ( ){<br/><br/>var   age  = 24<br/>    set(value){<br/>        if (value &gt;0){<br/>            field = value<br/>        }else {<br/>            throw IllegalArgumentException("No Human have age less than 0 or equal to ")<br/>        }<br/>    }<br/><br/>}</span></pre><p id="e797" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">线程“main”Java . lang . illegalargumentexception 出现异常:在 Human.setAge(Main.kt:17) <br/>在 MainKt.main(Main.kt:5) </strong>没有年龄小于 0 或等于<br/>的人</p><p id="bd3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我不想让任何人在我的课之外改变我的变量值呢</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="e529" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/> var mohab = Human()<br/>mohab.age = 23<br/>}<br/><br/><br/>class Human ( ){<br/><br/>var   age  = 24<br/>    private  set<br/><br/>}</span></pre><p id="67dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器抱怨<strong class="jx io">不能赋值给“age”:setter 在“Human”中是私有的</strong></p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="ca7e" class="nd ku in mg b be ne nf l ng nh">//mohab.age = 23<br/>    print(mohab.age)</span></pre><p id="e24c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是 getter 不是，所以我们可以得到值而不是改变它</p><h1 id="d750" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数据类别</h1><p id="b130" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">用于保存数据的特定类型的类不能是抽象的、密封的甚至是内部的，我们将很快讨论这些类型的类，但是现在记住它们</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="e26c" class="nd ku in mg b be ne nf l ng nh">data class User()</span></pre><p id="4fea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类必须至少有一个参数才能声明</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a421" class="nd ku in mg b be ne nf l ng nh">data class User(val email : String ,val password : String ){}</span></pre><p id="7f05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时电子邮件和密码可以改变，这样我们就可以；不要将这些变量保留为 val，我们需要将它们改为 var，以便我们可以更改它们的值</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="8a9c" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>    user.email = "Mohab@gmail.com"<br/>}<br/>data class User(var  email : String ,var password : String ){<br/>}</span></pre><p id="e1ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类有许多有用的方法，复制，等于，转换字符串…</p><p id="b2eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">托斯提林()</strong></p><p id="e0a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将整个类对象打印为字符串</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="2c48" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>    user.email = "Mohab@gmail.com"<br/><br/>    println(user.toString())<br/>    <br/>}//User(email=Mohab@gmail.com, password=12345678)</span></pre><p id="8bd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">复制()</strong></p><p id="3ec5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">克隆对象并将其复制到另一个相同类型的对象</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="2c8b" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>    user.email = "Mohab@gmail.com"<br/><br/>    val copied = user.copy()<br/>    print(copied.toString())<br/><br/>}<br/>//User(email=Mohab@gmail.com, password=12345678)<br/>//User(email=Mohab@gmail.com, password=12345678)</span></pre><p id="4a94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以重新赋值</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="8521" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>    user.email = "Mohab@gmail.com"<br/><br/>    println(user.toString())<br/>    val copied = user.copy("Messi","00000000")<br/>    print(copied.toString())<br/><br/>}//User(email=Mohab@gmail.com, password=12345678)<br/>//User(email=Messi, password=00000000)</span></pre><p id="fb3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">组件()</strong></p><p id="7c51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打印 n 参数的值，就像我们在第一个参数列表中有“email ”,所以如果我们只需要打印它，我们将使用<strong class="jx io"> componnet1() </strong>等等</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="383c" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>println(user.component1())<br/>}//Mohab@yahoo.com</span></pre><p id="8525" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解构</strong></p><p id="a525" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将对象成员拼接到变量中</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="b155" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/><br/>val (email , pass)  = user<br/>    print(pass)<br/>}</span></pre><p id="5da6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这和我们创造的一样</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="f076" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>val user = User("Mohab@yahoo.com","12345678")<br/>val email = user.email<br/>val pass = user.password<br/>}</span></pre><h1 id="c039" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">遗产</h1><p id="1ee9" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">OOP 中非常重要的一点，允许类从另一个类继承数据</p><blockquote class="lr ls lt"><p id="586a" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">继承了另一个类特性的类称为<strong class="jx io">子类</strong>、<strong class="jx io">子类</strong>或<strong class="jx io">派生类</strong></p><p id="f745" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">另一个类继承自的类称为<strong class="jx io">超类</strong>、<strong class="jx io">父类</strong>或<strong class="jx io">基类</strong></p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="1900" class="nd ku in mg b be ne nf l ng nh">class Device {}<br/>class Computer : Device() {}</span></pre><p id="79b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们愿意创建一个类<strong class="jx io"> Device </strong>来继承另一个类<strong class="jx io"> Computer </strong>，这个语法允许我们这样做，但是我们遗漏了一些东西<strong class="jx io">“kot Lin 类”</strong>都是<strong class="jx io"> final </strong>默认情况下不允许继承，所以我们需要在基类中添加关键字<strong class="jx io">“open”</strong>来允许继承，同时添加调用构造函数()</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4de4" class="nd ku in mg b be ne nf l ng nh">open class Device {}<br/>class Computer : Device() {}<br/>class Phone: Device (){}</span></pre><p id="97b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子类也可以是另一个类的父类</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="fafd" class="nd ku in mg b be ne nf l ng nh">open class Device {}<br/>class Computer : Device() {}<br/>open class Phone: Device (){}<br/><br/>class SmartPhone : Phone(){}</span></pre><p id="505b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们最小化并看看继承</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="dcc8" class="nd ku in mg b be ne nf l ng nh">open class Phone (){}<br/>class SmartPhone :Phone(){}</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="9cbf" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){}<br/><br/>class SmartPhone :Phone(){}</span></pre><p id="e4db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你会注意到一个错误，所以我们也必须在基类中添加相同的参数</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="7ace" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){}<br/><br/>class SmartPhone(brand : String , model : String, batteryLife : Double  ) :Phone(brand , model,batteryLife){}</span></pre><p id="5115" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子类也可能有它自己的特征和数据，例如智能手机有照相机</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a866" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){}<br/><br/>class SmartPhone(brand : String , model : String, batteryLife : Double , cameras : Int  ) :Phone(brand , model,batteryLife){}</span></pre><p id="51c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以所有的手机都可以保存号码，是的，当然</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="23b0" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){<br/>    var contact = ""<br/>    fun addToContacts (contact : String ){<br/>        this.contact = contact<br/>    }<br/><br/>}</span></pre><p id="91a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以打开/关闭它们</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="5b24" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){<br/>    var contact = ""<br/>    fun addToContact (contact : String ){<br/>        this.contact = contact<br/>    }<br/>    var isOn = true<br/>    fun switchOff (){<br/>        this.isOn = !this.isOn<br/>        if (isOn){<br/>            print("Phone is now On")<br/>        }else {<br/>            print("Phone is now Off")<br/><br/>        }<br/>    }<br/><br/>}</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="dfef" class="nd ku in mg b be ne nf l ng nh">open class Phone (val brand : String , val  model : String , val batteryLife : Double ){<br/>    var contact = ""<br/>    fun addToContact (contact : String ){<br/>        this.contact = contact<br/>    }<br/>    init {<br/>        switchOff()<br/>    }<br/>    var isOn = true<br/>    fun switchOff (){<br/>        this.isOn = !this.isOn<br/>        if (isOn){<br/>            println("your ${brand}  is now On")<br/>        }else {<br/>            println(" your ${brand}  is now Off")<br/><br/>        }<br/>    }<br/><br/>}</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="f163" class="nd ku in mg b be ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    var myPhone = Phone("Nokia ","3310",98.0)<br/>    var iPhone = SmartPhone("Iphone","13",50.0,4)<br/>}//output <br/>//your Nokia   is now On<br/>//your Iphone  is now On</span></pre><blockquote class="lr ls lt"><p id="e64a" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意，任何类都是从“任何”类继承的，所以我们总是可以找到 hashcode，toString，equals …</p></blockquote><p id="5248" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以覆盖超类的成员</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="bc26" class="nd ku in mg b be ne nf l ng nh">class SmartPhone(brand : String , model : String, batteryLife : Double , cameras : Int  ) :Phone(brand , model,batteryLife){<br/>override var isOn = false}</span></pre><p id="0087" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你还会注意到一个错误“这是最终版本，我们需要打开它”</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="a8e9" class="nd ku in mg b be ne nf l ng nh">open var isOn = true</span></pre><pre class="ni mz mg na bn nb nc bi"><span id="e18a" class="nd ku in mg b be ne nf l ng nh">class SmartPhone(brand : String , model : String, batteryLife : Double , cameras : Int  ) :Phone(brand , model,batteryLife){<br/>override var isOn = false<br/>    override fun switchOff() {<br/><br/>        if (this.isOn){<br/>            println("once you overriden this method it will not work like in the super class but i will tell you that your ${brand} is now ON")<br/>        }else {<br/>            println("once you overriden this method it will not work like in the super class but i will tell you that your ${brand} is now OFF")<br/>        }<br/>    }<br/>}<br/>//output <br/>//your Nokia   is now On<br/>//once you overriden this method it will not work like in the super class but i will tell you that your Iphone is now OFF</span></pre><p id="615c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们覆盖了这个方法，它的行为就不同了，而不是在超类和变量 isOn 中</p><h1 id="f45c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">接口</h1><p id="84c7" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">你可以认为它是一个类，但它不是，它也有自己的成员，可以有默认的实现，也可以没有，对于某些成员或所有成员，扩展接口的类必须覆盖没有实现的成员，也可以覆盖有实现的成员</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="9d58" class="nd ku in mg b be ne nf l ng nh">interface Phone {<br/>    val batteryLife : Double<br/>    fun call ()<br/>    fun SwitchOff ()<br/>    fun addToContact (){<br/>        println("Added to contacts")<br/>    }<br/>}</span></pre><p id="4fc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们来看这个接口，它有一个 memebers，batterylife 变量没有值，编译器没有抱怨，call()，switchOff()也没有。主体编译器也没有抱怨…这就是我们所说的</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="f8ae" class="nd ku in mg b be ne nf l ng nh">interface Phone {<br/>    val batteryLife : Double<br/>    fun call ()<br/>    fun SwitchOf ()<br/>    fun addToContact (){<br/>        println("Added to contacts")<br/>    }<br/>}<br/>class SmartPhone ():Phone{}</span></pre><p id="7a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器现在会抱怨<strong class="jx io">“类‘smart Phone’不是抽象的，并且不实现抽象成员公共抽象 val batteryLife:在 Phone 中双重定义”</strong></p><p id="8b40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着我们必须覆盖该接口的所有成员，但只覆盖那些没有实现的成员</p><p id="dbcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以点击类名旁边黄色灯</p><p id="f6f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现这些抽象方法，并将 bateerylife 添加到您的构造函数中</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="6ad8" class="nd ku in mg b be ne nf l ng nh">class SmartPhone (override val batteryLife: Double):Phone{<br/>    override fun call() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun SwitchOf() {<br/>        TODO("Not yet implemented")<br/>    }<br/>}</span></pre><p id="0425" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我们看到它只覆盖了没有实现的方法和变量</p><p id="4396" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是<strong class="jx io"> addToContact() </strong>是具体的，有它的实现，所以实现是可选的</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="bb1b" class="nd ku in mg b be ne nf l ng nh">class SmartPhone (override val batteryLife: Double):Phone{<br/>    override fun call() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun SwitchOf() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun addToContact() {<br/>        super.addToContact()<br/>    }<br/>}</span></pre><p id="f16f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得我们谈到方法重载时，我们创建了多个同名但结构不同的方法吗</p><p id="ddfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们尝试在这里应用它，我将在调用方法中添加一个参数，这样它的结构就不同了</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="edcf" class="nd ku in mg b be ne nf l ng nh">class SmartPhone (override val batteryLife: Double):Phone{<br/>    override fun call(contact : String ) {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun SwitchOf() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun addToContact() {<br/>        super.addToContact()<br/>    }<br/>}</span></pre><p id="6766" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译器抛出了之前抛出的相同错误</p><p id="3538" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">类“SmartPhone”不是抽象的，并且不实现抽象成员 public abstract fun call():在 Phone 中定义的单元</strong></p><p id="c011" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在需要再次实现这个方法 call()，并从我们的 concreted 方法中删除 override 关键字</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="51f4" class="nd ku in mg b be ne nf l ng nh">class SmartPhone (override val batteryLife: Double):Phone{<br/>     fun call(contact : String ) {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun call() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun SwitchOf() {<br/>        TODO("Not yet implemented")<br/>    }<br/><br/>    override fun addToContact() {<br/>        super.addToContact()<br/>    }<br/>}</span></pre><p id="46ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看，现在工作正常</p><blockquote class="lr ls lt"><p id="f140" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">请注意，接口只是抽象的，不能被实例化，也不能从</p></blockquote><h1 id="c727" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">抽象类</h1><p id="1768" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">它有点类似于接口，但有一些变化，它也不能被初始化，甚至不能创建一个对象，但不同的是，它是一个方法，不能是抽象的，除非我们声明它是抽象的</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="31f0" class="nd ku in mg b be ne nf l ng nh">abstract class Device (){<br/>abstract    fun turnOff ()<br/>}<br/><br/>class Phone ():Device (){<br/>    override fun turnOff() {<br/>        TODO("Not yet implemented")<br/>    }<br/>}</span></pre><h1 id="d70d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">铸字</h1><p id="3e8b" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">让我们先简单地讨论一下列表，因为我们可能知道它是一个数据集合</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="4065" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>    val players: List&lt;String&gt; = listOf("Mohab","Messi","Neymar")<br/>}</span></pre><p id="b047" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们创建了一个字符串列表，它只能保存字符串类型的变量</p><p id="7cb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们也可以创建混合数据类型的列表</p><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="5335" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>    val players: List&lt;String&gt; = listOf("Mohab","Messi","Neymar")<br/>    val myList :List&lt;Any&gt;  =listOf ("Mohab",false , 20.09,20000,12,'m')<br/>}</span></pre><p id="a7ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这和类型转换有什么关系呢，类型转换是将一个数据类型的变量转换成另一个数据类型的过程，</p><blockquote class="lr ls lt"><p id="7aac" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">现在，如果我们不知道我们创建的列表中元素的类型，因为它包含任何元素，我们希望将它们转换为另一种数据类型，我们应该首先知道元素类型，就像下面使用的 for 循环“我们之前讨论过的”</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="c505" class="nd ku in mg b be ne nf l ng nh">fun main() {<br/>    val players: List&lt;String&gt; = listOf("Mohab","Messi","Neymar")<br/>    val myList :List&lt;Any&gt;  =listOf ("Mohab",false , 20.09,20000,12,'m')<br/><br/>for (i in myList){<br/><br/>    if (  i is Int ){<br/>        println("iam $i of type Int ")<br/>    }else if ( i is Boolean){<br/>        println("iam $i of type boolean ")<br/><br/>    }else if (i is String ){<br/>        println("iam $i of type string  ")<br/><br/>    }else if (i is Double ){<br/>        println("iam $i of type double ")<br/><br/>    } else if (i is Char){<br/>        println("iam $i of type char ")<br/><br/>    } else {<br/>        println("iam $i and i do not know who actually iam  ")<br/><br/>    }<br/>}<br/><br/><br/>}// output <br/>//iam Mohab of type string  <br/>//iam false of type boolean <br/>//iam 20.09 of type double <br/>//iam 20000 of type Int <br/>//iam 12 of type Int <br/>//iam m of type char </span></pre><p id="194c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以使用我们之前讨论过的 when 表达式，因为它比嵌套 if 要好</p><h1 id="9f1d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">智能铸造</h1><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="7e2f" class="nd ku in mg b be ne nf l ng nh">var unKnwon : Any ="mohab"<br/>    if (unKnwon is String ){<br/>        println("your object is a string of having a value of $unKnwon and it's converted to ${unKnwon.uppercase()} ")<br/>    }else {<br/>        println("It's not a string ")<br/>    }<br/>}// output <br/>//your object is a string of having a value of mohab and it's converted to //MOHAB </span></pre><p id="109a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看，我们不想只把一个字符串转换成大写，但是如果我们把它应用到一个不是字符串的对象上，可能会导致错误，所以我们首先检查它是否是一个字符串，然后把它转换成大写()</p><h1 id="fbea" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">显式造型</h1><blockquote class="lr ls lt"><p id="9c40" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">为了说明这一点，让我们想象一个外部变量，我们想把它的值赋给应用程序中的一个变量，如下所示。</p></blockquote><pre class="mv mw mx my gt mz mg na bn nb nc bi"><span id="fc65" class="nd ku in mg b be ne nf l ng nh">   var anyVariable : Any = "Mohab"<br/>    var myVar : Int = anyVariable as Int<br/>    myVar +=10<br/>     println(myVar)</span></pre><p id="2d53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它导致了一个大错误<strong class="jx io">ot output———→线程“main”Java . lang . classcastexception 中的异常:类 java.lang.String 不能被强制转换为类 java.lang.Integer(Java . lang . string 和 Java . lang . integer 在 loader 'bootstrap') <br/>在 MainKt.main(Main.kt:41) <br/>在 MainKt.main(Main.kt) </strong></p><blockquote class="lr ls lt"><p id="14ad" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">这是因为我们要求我们的变量被处理成一个 int，但实际上它是一个字符串，所以它抛出这个异常</p><p id="18f1" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">结论:这种铸造方法不安全</strong></p></blockquote><p id="757b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这部分到此为止，等待下一部分</strong></p><p id="96e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果这篇文章真的对你有帮助，请为我鼓掌</strong></p><p id="61b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">感谢阅读，等待您的评论和回复…</strong></p></div></div>    
</body>
</html>