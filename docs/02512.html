<html>
<head>
<title>JavaScript.Linked Lists. Remove or Insert Node with provided index.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript。链接列表。使用提供的索引删除或插入节点。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-linked-lists-remove-or-insert-node-with-provided-index-4b4b5469bab4?source=collection_archive---------4-----------------------#2020-08-09">https://blog.devgenius.io/javascript-linked-lists-remove-or-insert-node-with-provided-index-4b4b5469bab4?source=collection_archive---------4-----------------------#2020-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6c262f57ec1e2603151a085c0fd74938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*InkBd-7avZ3F9Vev"/></div></div></figure><p id="1a9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">欢迎回来。让我们继续学习不同的方法，并在我们的列表中添加新的方法。今天，我们将讨论如何在链表中通过索引实现Remove和Insert方法。我相信你已经知道很多了。或许，你可以编码并创建你自己的算法，但是让我们检查一下如何解决它的其他选项。我希望你用前面的方法多练习，并且已经烂熟于心。好的，在我看来是时候开始了，我只是想提醒那些刚刚开始关注我们的人，我们有第一个博客，你可以从课程开始和上一课开始。了解前面课程中的内容非常重要，因为我们将使用这些课程中的方法。</p><p id="81ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上一个:</p><div class="kt ku gp gr kv kw"><a href="https://medium.com/dev-genius/javascript-linked-lists-remove-first-element-remove-last-element-dfa8adce432" rel="noopener follow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">JavaScript。链接列表。拆下第一个元件。删除最后一个元素。</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">欢迎回到关于链表及其特性的长期博客会议。我真的很乐意分享我的经历…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div><p id="90b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先:</p><div class="kt ku gp gr kv kw"><a href="https://medium.com/dev-genius/javascript-linked-lists-what-is-linked-lists-create-a-node-class-api-9aa0fa460075" rel="noopener follow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">JavaScript。链接列表。什么是“链表”？创建节点类API</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">新读者们你们好，欢迎回到我身边。只是想提一下，我已经不再写关于…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">medium.com</p></div></div><div class="lf l"><div class="ll l lh li lj lf lk jt kw"/></div></div></a></div><h1 id="ad83" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">移除具有所提供索引的节点</h1><p id="3b1d" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated"><strong class="jx io">函数→“remove at(integer)”</strong></p><h1 id="dcf0" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">方向</h1><p id="b870" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">移除提供的索引处的节点。</p><h1 id="2cda" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">例子</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8415" class="my ln in mu b gy mz na l nb nc">const list = new List();<br/>list.insertFirst('a');<br/>list.insertFirst('b');<br/>list.insertFirst('c');<br/>list.removeAt(1);<br/>list.getAt(1); //returns node with data 'a'</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="3af6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从模式示例开始，我们将包括所有选项，什么可能发生，以及我们将使用哪个算法来使它工作。</p><p id="c7cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.首先，我们有三个相互连接的节点。我们的“头”连接到索引为0的绿色节点。绿色与蓝色相关(索引1)，蓝色与红色相关(2)。我们希望创建所有不破坏我们代码的选项，并包括不同的条件来避免这种情况。</p><p id="68ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk"> —如果‘head’为‘null’，我们将不返回任何内容。</em></p><p id="bb09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk"> —如果我们只有一个索引为0的元素(当在链表中只有一个元素‘绿色’时)，我们指向空值。</em></p><p id="2cb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">— <em class="nk">当我们放置removeAt(12)时包含条件，但是我们只有三个元素。我们不能删除索引为12的元素，因为它不存在。</em></p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/517f8ad93d9c68b3613a70b0d7f3271b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJEAmEvvriAQQT0665rZmg.png"/></div></div></figure><p id="148f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.例如，我们想删除索引为1的元素。在我看来，用我们之前的方法“getAt()”是个不错的选择。我们将找到我们想要删除的元素。该算法的主要目标是找到前一个元素(在我们的例子中是“绿色”)并指向索引为2的元素(“红色”元素)。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/467589c65db7b05c14b985c32cb7b5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SW9ntt0oayX8Aj-IshCo2w.png"/></div></div></figure><p id="c77e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.我们将创建变量“previous”来指示我们要删除的元素中的前一个元素。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/ef9f672fba63df5db862b7eb7f1711e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDGW-S4B1PfVLj6QRA4tig.png"/></div></div></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h2 id="47b1" class="my ln in bd lo no np dn ls nq nr dp lw kg ns nt ma kk nu nv me ko nw nx mi ny bi translated">代码解决方案</h2><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b2433c20b483c38ce66fcb58d4b1bafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*TXi4wBf2DMZTOfdI4PgNdA.png"/></div></figure><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7374ff3fdf243e92113e109a56e58456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*0-HmcBJ3vP4M59V2Wt_sKQ.png"/></div></figure><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/06464f186cd3bb9f1145ccea5bbaef92.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*C2K8B9YhgrZV-LLhGSXwjA.png"/></div></figure><h1 id="98d0" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用提供的索引插入节点</h1><p id="edfa" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated"><strong class="jx io">函数→“insertAt(Data，integer)”</strong></p><h1 id="3137" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">方向</h1><p id="5279" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">创建一个在提供的索引处插入新节点的。如果索引超出界限，则将节点添加到列表的末尾。</p><h1 id="9fef" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">例子</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b3fb" class="my ln in mu b gy mz na l nb nc">const list = new List();<br/>list.insertFirst('a');<br/>list.insertFirst('b');<br/>list.insertFirst('c');<br/>list.insertAt("hi",2);<br/>list.getAt(1); //returns node with data 'Hi'</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="770f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们再次从模式开始，并提及我们案例中的所有条件。</p><ol class=""><li id="86c3" class="oc od in jx b jy jz kc kd kg oe kk of ko og ks oh oi oj ok bi translated">同样，我们创建了3个节点，并希望再插入一个元素“橙色”。</li></ol><p id="c28d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—如果列表为空，我们需要将此元素作为列表中的第一个元素插入。</p><p id="76fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—如果我们想将此元素作为第一个元素(索引为0)推送，我们需要将头指向新元素，新元素指向过去的第一个元素。</p><p id="5cb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—如果我们想插入索引比我们的列表高的元素，我们应该把它推到列表的末尾。例如，我们有三个元素，但我们说，让我们把指数=12。它不存在，所以我们将作为最后一个元素推进。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/004418e537d8af82ae3788697d96198a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjDFtK-VqJ1JWBXzyCA6JA.png"/></div></div></figure><p id="fe6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.正如您提到的，我们通过索引2添加了“橙色”元素。所以“蓝色”元素指向橙色而不是“红色”，橙色开始指向“红色”元素。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi om"><img src="../Images/88eb96669870b50bbb099c7d637af841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBSsMPs4Goc_Ulht1pJcBQ.png"/></div></div></figure><h2 id="391a" class="my ln in bd lo no np dn ls nq nr dp lw kg ns nt ma kk nu nv me ko nw nx mi ny bi translated">代码解决方案</h2><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi on"><img src="../Images/90a808537c426232a61321fa1c89e2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*lj9GXWNPOEMoJjf9ANZ6bw.png"/></div></figure><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oo"><img src="../Images/06aadc308c9e3758482cf4f115694749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIqfel70yFOhCaU_sJImyw.png"/></div></div></figure><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/70827efa8bfb62fb0880315f8394a263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJBgDcwqSvIyZh0knN3OIg.png"/></div></div></figure><h2 id="bd4a" class="my ln in bd lo no np dn ls nq nr dp lw kg ns nt ma kk nu nv me ko nw nx mi ny bi translated">完整代码:</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d2cb" class="my ln in mu b gy mz na l nb nc">class Node {<br/>  constructor(data, next = null) {<br/>   this.data = data;<br/>   this.next = next;<br/>  }<br/>}class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>  }insertFirst(data) {<br/>    const node = new Node(data, this.head);<br/>    this.head = node;<br/>  }<br/>  <br/>  size() {<br/>    let counter = 0;<br/>    let node = this.head;<br/>    while (node) {<br/>     counter++;<br/>     node = node.next;<br/>    }<br/>    return counter;<br/>  }<br/>  <br/>  getFirst() {<br/>    return this.head.data;<br/>  }<br/>  <br/>  getLast() {<br/>    if (!this.head) {<br/>      return null;<br/>    }<br/>    let node = this.head;<br/>    while (node) {<br/>     if (!node.next) {<br/>      return node;<br/>     }<br/>     node = node.next;<br/>    }<br/>  }<br/>  <br/>  clear() {<br/>    this.head = null;<br/>  } <br/>  <br/>  removeFirst() { <br/>    if (!this.head) {<br/>     return;<br/>    }<br/>    this.head = this.head.next;<br/>   }removeLast() {<br/>    if (!this.head) {<br/>      return;<br/>    }<br/>   <br/>    if (!this.head.next) {<br/>     this.head = null;<br/>    }<br/>   <br/>    let previous = this.head;<br/>    let node = this.head.next;<br/>   <br/>    while (node.next) {<br/>      previous = node;<br/>      node = node.next;<br/>    }<br/>    <br/>    previous.next = null;<br/>   }   insertLast(data) {<br/>    const last = this.getLast();<br/>    if (last) {<br/>     last.next = new Node(data);<br/>    } else {<br/>      this.head = new Node(data);<br/>    }<br/>   }<br/>  <br/>   getAt(index) {<br/>    let counter = 0;<br/>    let node = this.head;<br/>    while (node) {<br/>     if (counter === index) {<br/>      return node;<br/>     }<br/>     counter++;<br/>     node = node.next;<br/>    }<br/>   return null;<br/>  }</span><span id="6016" class="my ln in mu b gy oq na l nb nc"> removeAt(index) {<br/>  if (!this.head) {<br/>    return;<br/>  }</span><span id="81e6" class="my ln in mu b gy oq na l nb nc">  if (index === 0) {<br/>    this.head = this.head.next;<br/>    return;<br/>  }<br/>  <br/>  const previous = this.getAt(index - 1);<br/>  if (!previous || !previous.next) {<br/>    return;<br/>  }<br/>  previous.next = previous.next.next;<br/> }</span><span id="b5d0" class="my ln in mu b gy oq na l nb nc"> insertAt(data, index) {<br/>   if (!this.head) {<br/>    this.head = new Node(data);<br/>    return;<br/>   }<br/>   if (index === 0) {<br/>    this.head = new Node(data, this.head);<br/>    return;<br/>   }<br/>  const previous = this.getAt(index - 1) || this.getLast();<br/>  const node = new Node(data, previous.next);<br/>  previous.next = node; <br/> }<br/>}</span></pre></div></div>    
</body>
</html>