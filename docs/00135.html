<html>
<head>
<title>JWT: Symmetic and Asymmetic Key Authentication In ASP.NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET 核心中的 JWT 对称和非对称密钥认证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/jwt-authentication-in-asp-net-core-e67dca9ae3e8?source=collection_archive---------0-----------------------#2020-03-24">https://blog.devgenius.io/jwt-authentication-in-asp-net-core-e67dca9ae3e8?source=collection_archive---------0-----------------------#2020-03-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/41a2207a8527c6eb4a0bfcb3a369a4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzVd5KDGwtqATl0FUsxT3w.jpeg"/></div></div></figure><div class=""/><p id="cb27" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我们将会看到</p><p id="e61e" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">👉<strong class="kb jd"> JWT 用对称密钥签名</strong></p><p id="c684" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">👉<strong class="kb jd"> JWT 用 RSA 非对称私钥签名</strong></p><p id="41e7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">在 ASP.NET 核心中对用户进行身份验证时，通常会使用<code class="fe kx ky kz la b">AddCookie()</code>或任何一种<code class="fe kx ky kz la b">AddSomeSocialMedia()</code>方法将他们签入默认方案。将用户注册到一个方案中基本上意味着向他们的浏览器发送一个身份验证 cookie，该 cookie 会在每个后续请求中被传递和验证。</p><p id="89f6" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">然而，这与 jwt 不同。JWT 通常不存储为 cookie——相反，它在“授权”头中，并且应该在您想要授权的每个请求上传递。</p><p id="0f3c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">🔔<a class="ae lb" href="https://nmillard.medium.com/subscribe" rel="noopener">想要更多这样的文章？在这里签名。</a></p><h1 id="7e4e" class="lc ld jc bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">🔑使用 dotnet 用户机密存储您的机密</h1><p id="ba6c" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">我们需要对称密钥和非对称私钥使用的秘密。对于本地开发，我们将总是使用<code class="fe kx ky kz la b">dotnet user-secrets</code>,而不是错误地将 appsettings.json 中的秘密检查到源代码中。</p><p id="c078" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">让你的 appsettings.json 列出你的应用程序将需要的所有必需的配置设置是一个好习惯，即使你从 KeyVault 或 secrets manager 加载设置。</p><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><p id="4e4f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">让我们设置 Jwt:Symmetric:Key 和 Jwt:Asymmetric:PrivateKey。</p><p id="9ed8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">使用终端将目录更改为 ASP.NET 核心 web 客户端项目，并运行以下命令。</p><p id="833b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><code class="fe kx ky kz la b">dotnet user-secrets init</code></p><p id="bd63" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><code class="fe kx ky kz la b">dotnet user-secrets set “Jwt:Symmetric:Key" "1234567890123456"</code></p><p id="e664" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><code class="fe kx ky kz la b">dotnet user-secrets set “Jwt:Asymmetric:Key" "some_private_rsa_key"</code></p><h2 id="c08d" class="ml ld jc bd le mm mn dn li mo mp dp lm kk mq mr lq ko ms mt lu ks mu mv ly mw bi translated">如何生成 RSA 密钥</h2><p id="78d7" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">您可以使用下面的代码片段生成 RSA 私钥和公钥。</p><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><h1 id="9cd2" class="lc ld jc bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> JWT 用对称密钥签名</strong></h1><h2 id="0445" class="ml ld jc bd le mm mn dn li mo mp dp lm kk mq mr lq ko ms mt lu ks mu mv ly mw bi translated">在 Startup.cs 中配置承载认证</h2><p id="5586" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">首先，将<code class="fe kx ky kz la b">Microsoft.AspNetCore.Authentication.JwtBearer</code>添加到 ASP.NET 核心 web 客户端项目中。</p><p id="de92" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">其次，配置<code class="fe kx ky kz la b">ConfigureServices()</code>使用<code class="fe kx ky kz la b">AddJwtBearer</code>，就像代码片段中那样。</p><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><p id="dbf7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">🔔想要更多这样的文章吗？在这里签名。</p><h2 id="a6f5" class="ml ld jc bd le mm mn dn li mo mp dp lm kk mq mr lq ko ms mt lu ks mu mv ly mw bi translated">在控制器动作中生成和验证</h2><p id="3fcd" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">生成对称签名的 jwt 只是一个简单的问题:</p><ol class=""><li id="7ac8" class="mx my jc kb b kc kd kg kh kk mz ko na ks nb kw nc nd ne nf bi translated">使用对称密钥创建签名凭据</li><li id="669a" class="mx my jc kb b kc ng kg nh kk ni ko nj ks nk kw nc nd ne nf bi translated">用您希望它包含的任何声明来编写令牌</li><li id="22eb" class="mx my jc kb b kc ng kg nh kk ni ko nj ks nk kw nc nd ne nf bi translated">在令牌上签名</li></ol><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><p id="3943" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">HTTP GET 端点<code class="fe kx ky kz la b">/api/authorization/generatetoken</code>`返回一个签名的令牌。</p><p id="43f3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">调用<code class="fe kx ky kz la b">/api/authorization/validatetoken</code>`将 JWT 传入<code class="fe kx ky kz la b">authorization: Bearer &lt;jwt&gt;</code>`你将得到 200 OK 响应。</p><p id="8b14" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">📢记住签名和验证的<code class="fe kx ky kz la b">SymmetricSecurityKey</code>必须基于同一个秘密。</p><h1 id="ffa3" class="lc ld jc bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用非对称 RSA 密钥对的 JWT</h1><p id="bb43" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">设置 json web 令牌的非对称签名和验证与对称签名非常相似。</p><h2 id="a779" class="ml ld jc bd le mm mn dn li mo mp dp lm kk mq mr lq ko ms mt lu ks mu mv ly mw bi translated">在 Startup.cs 中配置承载认证</h2><p id="b770" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">主要的区别在于，您需要向您的依赖框架注册 RSA 安全密钥的创建。否则，你会遇到一些欺骗性的 401 未经授权的反应。</p><p id="c398" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">在我的例子中，你会看到我使用了一个不同的方案“非对称”来验证非对称签名的令牌。考虑到这一点，您将使用“非对称”方案以同样的方式保护您的资源。</p><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><h2 id="a9fc" class="ml ld jc bd le mm mn dn li mo mp dp lm kk mq mr lq ko ms mt lu ks mu mv ly mw bi translated">在控制器动作中生成和验证</h2><p id="a626" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated">请注意，我使用私钥对令牌进行签名。通过这样做，您可以创建一个可以生成密钥的服务，并且能够发布您的公钥，让其他服务验证用您的私钥签名的密钥。</p><p id="2f3c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">🔔<a class="ae lb" href="https://nmillard.medium.com/subscribe" rel="noopener">想要更多这样的文章？在这里签名。</a></p><figure class="mf mg mh mi gu it"><div class="bz fq l di"><div class="mj mk l"/></div></figure><h1 id="54fe" class="lc ld jc bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">让我们保持联系！</h1><p id="ccf7" class="pw-post-body-paragraph jz ka jc kb b kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw ik bi translated"><a class="ae lb" href="https://nmillard.medium.com/subscribe" rel="noopener">通过在此</a>注册时事通讯获得类似文章的通知，并查看<a class="ae lb" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"> <em class="nl"> YouTube 频道(@Nicklas Millard) </em> </a> <em class="nl">。</em></p><p id="37b0" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><a class="ae lb" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上连接</a>。</p></div></div>    
</body>
</html>