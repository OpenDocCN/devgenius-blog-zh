<html>
<head>
<title>Understanding Automatic batching in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 React 18 中的自动批处理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-automatic-batching-in-react-18-fb5b8fdf062d?source=collection_archive---------2-----------------------#2022-05-27">https://blog.devgenius.io/understanding-automatic-batching-in-react-18-fb5b8fdf062d?source=collection_archive---------2-----------------------#2022-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a1f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们将了解每个人都在谈论的 react 18 中的自动批处理，然后在后面的文章中，我们将讨论 react 18 中的一些其他功能，如新的 API 和新的流媒体服务器渲染器。</p><p id="2e84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要理解这一点，我们首先要知道 react 17 在这方面的问题。</p><h2 id="1b20" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">react 17 中的问题:</h2><p id="d0ea" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">为了理解这一点，我们将首先在 react 17 中创建一个 react 应用程序。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/8d7ef576f91bb69a51dcb43eb617b078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIvvw_A-57N1u2fHRUVtsg.png"/></div></div></figure><p id="c38a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是用好的老 ReactDOM.render API 定义 app 的根的 app。</p><p id="a3ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在带有一些基本边框样式的<strong class="jm io"> App </strong>组件中，我们将创建一个新组件(comp1)。<br/>我们将初始化组件“”中的两个状态。</p><p id="3aca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个是跟踪计数器，另一个是布尔值。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/1eac33df5eaeba22c84497b3cef56309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*ftTDv3wpXp_bMbnIYx7w5A.png"/></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lt"><img src="../Images/63c589e7ee6b793c94322bdea48d0c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0e55k_UG1NSeco-VMBtdhw.png"/></div></div></figure><p id="8281" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码将为我们提供这样一个用户界面:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lu"><img src="../Images/3951547a413f3c7f77f5ce30bd137382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVzmqEfU2CQ_T_u_zjTz_Q.png"/></div></div></figure><p id="a6b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将在 comp1 组件中添加一个 useEffect 钩子，它将在每次组件渲染时记录控制台日志。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/3d2e7c92f1071f6983feb80c9b0b9b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*hF_2hHWRoLFgSeRUCrzHJA.png"/></div></figure><p id="20b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在 comp1 ' <em class="lw"> handleCounter </em>'函数中，您可以看到我们正在一个接一个地更新两个状态变量，并且我们知道每次更新一个状态时都会呈现一个 react 组件。但是在这种情况下，react 知道我们在同一个函数中更新状态。所以它会自动批处理两个状态更新，并且只重新呈现组件一次。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lx"><img src="../Images/ec971342e67aca1151c18cd5514c16cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtnfO2p30u0l_q7SGqQttA.png"/></div></div></figure><p id="6c7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果我们必须在'<em class="lw"> handleCounter </em>'函数中使用一些 web APIs 和接口，如 setTimeout 或事件侦听器，或者我们从 API 中获取一些数据，因此在'<em class="lw"> handleCounter </em>'函数中使用了 Promise，在这种情况下，react 17 不会批量处理状态更新，因此会为每个状态更新重新呈现组件。</p><p id="2d93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了演示这一点，我们必须对我们的'<em class="lw"> handleCounter </em>'函数进行一些更改。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0071fb6365fcb98906e85bc9f46f1405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*Go8r5XKmhfdkAuCR_rAnlA.png"/></div></figure><p id="5eb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们用 0 毫秒的延迟将状态更新包装在 setTimeout 中。</p><p id="2e86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们看看这一变化的影响。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lu"><img src="../Images/0f9e457e81cc078b5777c59c5dc152cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Hgbah5kJZKjckX63tIBcw.png"/></div></div></figure><p id="3217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你明白我们现在面临的问题。</p><p id="f7c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 react 17 的情况下，为了解决这个问题，我们必须手动将我们想要批处理的状态更新包装在 react-dom 提供的'<em class="lw">unstable _ batched updates</em>' API 的回调函数中。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/3995913c93308cc5af23bf5c87a03c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*e1lyaa-QDXPI7USTs4EkPQ.png"/></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lu"><img src="../Images/0f9e457e81cc078b5777c59c5dc152cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Hgbah5kJZKjckX63tIBcw.png"/></div></div></figure><h2 id="1044" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">我们在 React 18 中得到什么:</h2><p id="061c" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我们将首先在 react 18 中创建一个 react 应用程序。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ma"><img src="../Images/bdcbd2ca267fc675bc0006c1bbadc291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiw-lRNbaMYzs0jwTsPYpQ.png"/></div></div></figure><p id="1151" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 react 18 中，我们使用'<em class="lw">react DOM . create root</em>' API，它会自动为我们批量更新所有状态。</p><p id="3eaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们可以去掉'<em class="lw"> React。strict mode</em>’。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mb"><img src="../Images/ee400fed968d19f5e9c08d3d3289aecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7_sFZmWH6kSkU0DVBg_xw.png"/></div></div></figure><p id="ebcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们可以使用与上面相同的 App 和 comp1 组件继续前进。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/cb6edd1fa2c38883e67d3791e2da3861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*jH3VsDOiIHri_HciEjYidQ.png"/></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a4956325d380cf9e5d09caccd085e755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*IZUrYLXvLSRlX-XVxvQW4A.png"/></div></figure><p id="1b59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是结果…</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lu"><img src="../Images/31183d8249674c7038608e0234230447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MylpUj8IzuBdKFa1kRxOw.png"/></div></div></figure><p id="4c8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们可以看到 react 18 可以自动批处理应用程序中的每个状态更新，这意味着更少的渲染和更多的优化。</p><p id="0d92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果我们不想批量更新，我们可以使用由 react-dom 提供的 API。我们只需将我们的状态更新(一次一个)包装在 flushSync 的回调函数中，就这样，我们的状态更新现在不进行批处理。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi me"><img src="../Images/d93a0ac9a8b65b426e4dfc56c01de264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NJwBjHXBctywAnpsNHE3A.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mf"><img src="../Images/f5358192a6f9b4ed0647aa609d67427e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIzC9MuXMfMTMHU1BamzWg.png"/></div></div></figure><h2 id="9828" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">结论:</h2><p id="093c" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">通过所有这些讨论，我们可以总结出，react 18 将为我们批量处理状态更新，无论它是包含多个状态更新的简单函数，还是包含多个状态更新的 web API 和接口，如 setTimeout、fetch 或 promise。</p><p id="a298" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你的时间😄</p></div></div>    
</body>
</html>