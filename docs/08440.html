<html>
<head>
<title>React Turbo — the ultimate solution to optimize React performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Turbo —优化 React 性能的终极解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-turbo-the-ultimate-solution-to-optimize-react-performance-b666ca9db0b5?source=collection_archive---------0-----------------------#2022-06-15">https://blog.devgenius.io/react-turbo-the-ultimate-solution-to-optimize-react-performance-b666ca9db0b5?source=collection_archive---------0-----------------------#2022-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="8362" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我在脸书做前端工程师，创建了大约 4000 颗星星<a class="ae km" href="https://github.com/react-native-webrtc/react-native-webrtc" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><h1 id="5d58" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="9e8e" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated"><a class="ae km" href="https://github.com/oney/react-turbo" rel="noopener ugc nofollow" target="_blank"> React Turbo </a>在编译时自动优化 React 性能，所以<strong class="jq io">开发者不需要手动做优化。</strong></p><h1 id="35e3" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">反应的痛苦</h1><p id="f323" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">反应是可爱的发展。JSX 比模板好。钩子对于业务逻辑的隔离和组合是非常强大的。</p><p id="35db" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">React 几乎拥有最好的开发者体验(DX)，除了一点:性能优化。</p><h2 id="1d43" class="lt ko in bd kp lu lv dn kt lw lx dp kx ln ly lz lb lp ma mb lf lr mc md lj me bi translated">变化检测/反应</h2><p id="56f0" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">我们不得不承认<a class="ae km" href="https://twitter.com/johnlindquist/status/1109498707475488768" rel="noopener ugc nofollow" target="_blank">反应是<em class="jp">从不</em>反应</a>。React 的<em class="jp">变化检测(或反应性)</em>策略基于<strong class="jq io"> diff(值比较)</strong>。相比之下，Vue、Angular 和 Svelte 基于<strong class="jq io">价值观察/订阅</strong>。</p><h2 id="50d9" class="lt ko in bd kp lu lv dn kt lw lx dp kx ln ly lz lb lp ma mb lf lr mc md lj me bi translated">价值比较</h2><p id="4721" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated"><em class="jp">值比较</em>表示:</p><ol class=""><li id="b019" class="mf mg in jq b jr js jv jw ln mh lp mi lr mj kl mk ml mm mn bi translated">我们需要<em class="jp">记忆并稳定</em>到<strong class="jq io">的值，避免<em class="jp">不相关的</em>重新计算</strong>；道具<strong class="jq io">避免<em class="jp">无关</em>重新渲染</strong>。</li><li id="3b7e" class="mf mg in jq b jr mo jv mp ln mq lp mr lr ms kl mk ml mm mn bi translated">我们无法自动实现<strong class="jq io">细粒度的反应性</strong>，因为 React 中的<em class="jp">最小级别的反应性</em>是组件(不是值或元素)。</li></ol><p id="57d2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">问题 1。就是为什么我们需要<code class="fe mt mu mv mw b">useMemo</code>、<code class="fe mt mu mv mw b">useCallback</code>、<code class="fe mt mu mv mw b">React.memo</code>甚至是不可变的数据。我们修复问题 2。通过订阅容器，如<a class="ae km" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank">的<code class="fe mt mu mv mw b">&lt;Controller render={( =&gt; /&gt;</code>反应-挂钩形式</a>。</p><p id="7aaf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">所以，当我们遇到以上 2 个性能问题时，我们不得不添加<code class="fe mt mu mv mw b">useMemo</code>、<code class="fe mt mu mv mw b">useCallback</code>或者手动用<code class="fe mt mu mv mw b">&lt;Controller /&gt;</code>、<strong class="jq io">包裹</strong>。那太可怕了。</p><h1 id="8507" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">反应涡轮增压</h1><p id="4801" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated"><a class="ae km" href="https://github.com/oney/react-turbo" rel="noopener ugc nofollow" target="_blank"> React Turbo </a>是一个 babel 插件，在<strong class="jq io">编译时</strong>将您的 React 组件<strong class="jq io"> <em class="jp">的变更检测策略从值比较转换为值订阅</em> </strong>。所以变成细粒度的反应性，缓存所有值，避免不必要的重新计算和重新渲染。</p><p id="e36f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">安装 React Turbo 后，不需要写任何<code class="fe mt mu mv mw b">useMemo</code>、<code class="fe mt mu mv mw b">useCallback</code>甚至可以用 Redux 用<a class="ae km" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重选</a>。实际上，您不必修改/编写任何代码来优化性能。</p><h2 id="d487" class="lt ko in bd kp lu lv dn kt lw lx dp kx ln ly lz lb lp ma mb lf lr mc md lj me bi translated">装置</h2><p id="8936" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">请查看 React Turbo repo 中的<a class="ae km" href="https://github.com/oney/react-turbo" rel="noopener ugc nofollow" target="_blank">安装说明。</a></p><h1 id="06dd" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">vs .反应忘记</h1><p id="2b37" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">听起来像是<a class="ae km" href="https://www.youtube.com/watch?v=lGEMwh32soc" rel="noopener ugc nofollow" target="_blank">反应过来忘了</a>，嗯？</p><p id="4bbc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">不同的是，遗忘仍然是基于价值观的比较。</p><p id="9fcb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">React Turbo 是 V<em class="jp">value Subscription</em>，可以在<strong class="jq io">值计算和元素渲染</strong>中实现<em class="jp">细粒度的反应性</em>。<br/>和 React 忘记仍然不能实现细粒度的反应性。它能回忆起一切。举个例子:</p><h2 id="9984" class="lt ko in bd kp lu lv dn kt lw lx dp kx ln ly lz lb lp ma mb lf lr mc md lj me bi translated">价值比较与价值订阅</h2><p id="e680" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">假设你在组件 A 中有一个值<code class="fe mt mu mv mw b">text</code>，你把<code class="fe mt mu mv mw b">text</code>从 A 传递给组件 B，B 传递给 C，C 传递给 D，…，最后 Y 传递给 Z，然后，Z 中的一个<code class="fe mt mu mv mw b">&lt;input value={text}/&gt;</code>使用<code class="fe mt mu mv mw b">text</code>。</p><p id="2a82" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">当<code class="fe mt mu mv mw b">text</code>改变时，即使使用 React Forget，组件 A，B，C，…和 Z 都会重新渲染。<br/>这意味着组件 A 到 Z 中的所有变量和 React 元素都被<strong class="jq io">重新初始化并重新创建以进行比较</strong>，即使大部分值是相同的(因为只有<code class="fe mt mu mv mw b">text</code>改变)。</p><h2 id="182a" class="lt ko in bd kp lu lv dn kt lw lx dp kx ln ly lz lb lp ma mb lf lr mc md lj me bi translated">开销</h2><p id="28a0" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">重建和比较的<strong class="jq io">开销</strong>(例如，Vdom diff、useMemo、React.memo 或 create selector of re select<strong class="jq io">)</strong>相同值的变量和 React 元素当你有一个像脸书广告管理器网站这样的大型应用程序时，会损害性能(是的，我曾在那个代码库上工作过，这很痛苦，也很愉快😉).</p><p id="5276" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">特别是当<code class="fe mt mu mv mw b">text</code>这样的值频繁变化时，例如每次输入 100-200 毫秒，甚至每次拖动滑块(<code class="fe mt mu mv mw b">&lt;input type="range"/&gt;</code>)和颜色选择器 33 毫秒，用户会感觉到滞后。</p><p id="9129" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">使用 React Turbo 即价值订阅，当<code class="fe mt mu mv mw b">text</code>改变时，只有 Z 中的<code class="fe mt mu mv mw b">&lt;input/&gt;</code>重新渲染(Z 不会重新渲染)，因为只有那个<code class="fe mt mu mv mw b">&lt;input/&gt;</code> <strong class="jq io">订阅</strong> <code class="fe mt mu mv mw b">text</code>。</p><p id="457e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated"><strong class="jq io">不进行比较。</strong></p><p id="2dff" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">这就是我们所说的<strong class="jq io">细粒度反应性</strong>。</p><h1 id="2d21" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">它是如何工作的</h1><p id="5425" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">基本上，它将<em class="jp">状态</em> <em class="jp"> ( </em>值来自<code class="fe mt mu mv mw b">useState</code> <em class="jp"> ) </em>从普通的 JavaScript 值转换成可观察/可订阅的信号/原子，如<a class="ae km" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>、<a class="ae km" href="https://github.com/pmndrs/zustand" rel="noopener ugc nofollow" target="_blank"> zustand </a>和<a class="ae km" href="https://effector.dev/" rel="noopener ugc nofollow" target="_blank">效应器</a>。</p><p id="609b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">然后自动收集组件中<em class="jp">变量声明</em>的依赖关系，生成计算原子(比如<code class="fe mt mu mv mw b">useMemo</code>，其中 linters 提示缺少依赖关系)。</p><p id="52c8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">它还用订阅容器<em class="jp">及其依赖关系</em>包装每个<code class="fe mt mu mv mw b">React.createElement</code><em class="jp">(以实现对<strong class="jq io">元素</strong>的细粒度反应)。</em></p><p id="4635" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">所有这些都在编译时被转换。</p><h1 id="2c46" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">对比 MobX</h1><p id="abfc" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">不同之处在于 MobX 的值是可变的，订阅在运行时发生并决定<strong class="jq io">。</strong></p><p id="e5bd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ln ka kb kc lp ke kf kg lr ki kj kk kl ig bi translated">React Turbo 的值仍然是不可变的，它在并发模式下工作，值订阅在编译时决定。</p><h1 id="7e24" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">将来的</h1><p id="b4cd" class="pw-post-body-paragraph jn jo in jq b jr ll jt ju jv lm jx jy ln lo kb kc lp lq kf kg lr ls kj kk kl ig bi translated">React Forget 是在编译时优化性能的伟大举措，但值订阅绝对比值比较有更小的开销和更好的性能。所以我希望 React 核心团队能够采用 React Turbo 的理念。</p><h1 id="8f87" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">注意</h1><ol class=""><li id="3caf" class="mf mg in jq b jr ll jv lm ln mx lp my lr mz kl mk ml mm mn bi translated">React Turbo 编译的组件/钩子可以与 React Turbo 编译的<strong class="jq io">而不是</strong>的组件/钩子一起工作。所以我们不需要编译任何第三方库来运行 React Turbo 应用。</li><li id="e6ba" class="mf mg in jq b jr mo jv mp ln mq lp mr lr ms kl mk ml mm mn bi translated">React Turbo 应用的捆绑包大小不会呈指数级增长。通常情况下，它只会增加 10-20%，就像您通过添加<code class="fe mt mu mv mw b">useMemo</code>、<code class="fe mt mu mv mw b">useCallback</code>手动优化一样。</li><li id="1775" class="mf mg in jq b jr mo jv mp ln mq lp mr lr ms kl mk ml mm mn bi translated">React Turbo 中的可观测原子现在是基于<a class="ae km" href="https://effector.dev/" rel="noopener ugc nofollow" target="_blank">效应器</a>的。</li><li id="dab2" class="mf mg in jq b jr mo jv mp ln mq lp mr lr ms kl mk ml mm mn bi translated">React Turbo 可以轻松解决<code class="fe mt mu mv mw b">useEvent</code>想要解决的性能问题。React Turbo 的回调仍然会改变并导致订阅组件重新渲染，但是<strong class="jq io">因为它是细粒度的</strong>，所以不会影响性能。</li></ol></div></div>    
</body>
</html>