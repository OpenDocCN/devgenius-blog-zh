<html>
<head>
<title>Node.js Tips — Test File Uploads, App-Wide headers, Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—测试文件上传、应用程序范围的头、缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-test-file-uploads-app-wide-headers-caching-749cd5c07dfd?source=collection_archive---------13-----------------------#2020-07-27">https://blog.devgenius.io/node-js-tips-test-file-uploads-app-wide-headers-caching-749cd5c07dfd?source=collection_archive---------13-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/daba0284a4ef823ab4ec36902cf69934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xq6HxaZi1bvJ4soe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯蒂娜·安妮·科斯特洛在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="9b68" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">以编程方式停止并重新启动Express服务器以更改端口</h1><p id="b41a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过写入以下命令来停止并重新启动服务器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a044" class="mn lc iq mj b gy mo mp l mq mr">server.on('close', () =&gt; {<br/>  server.listen(3000);<br/>});</span><span id="5519" class="mn lc iq mj b gy ms mp l mq mr">server.listen(8000, () =&gt; {<br/>  server.close();<br/>});</span></pre><p id="3f58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为服务器关闭时运行的close事件添加了一个侦听器。</p><p id="41c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用端口调用<code class="fe mt mu mv mj b">listen</code>。</p><p id="1f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个回调函数，它调用触发关闭事件的<code class="fe mt mu mv mj b">close</code>方法。</p><p id="6372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们传递给<code class="fe mt mu mv mj b">server.on</code>的回调将会运行。</p><h1 id="1eaa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动为每个“呈现”响应添加标题</h1><p id="d8f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建自己的中间件来添加响应头，从而为每个<code class="fe mt mu mv mj b">render</code>响应添加一个头。</p><p id="b1fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="900b" class="mn lc iq mj b gy mo mp l mq mr">app.get('/*', (req, res, next) =&gt; {<br/>  res.header('X-XSS-Protection' , 0);<br/>  next();<br/>});</span></pre><p id="d14c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了值为0的<code class="fe mt mu mv mj b">X-XSS-Protection</code>自定义响应头。</p><p id="740e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码使中间件在应用程序范围内运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d2a3" class="mn lc iq mj b gy mo mp l mq mr">app.use((req, res, next) =&gt; {<br/>  res.set('X-XSS-Protection', 0);<br/>  next();<br/>});</span></pre><p id="65a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过运行以下命令安装Mocha和hipper包来添加一个测试:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b011" class="mn lc iq mj b gy mo mp l mq mr">npm install --save-dev mocha hippie</span></pre><p id="6fb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下内容来测试:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f92" class="mn lc iq mj b gy mo mp l mq mr">describe('Response Headers', () =&gt; {<br/>  it('responds with header X-XSS-Protection with value 0', (done) =&gt; {<br/>    hippie(app)<br/>      .get('/foo')<br/>      .expectHeader('X-XSS-Protection', 0)<br/>      .end(done);<br/>  });<br/>});</span></pre><p id="a6e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入前面例子中的<code class="fe mt mu mv mj b">app</code>对象。</p><p id="660f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它传递给<code class="fe mt mu mv mj b">hippie</code>并调用一个路由，然后调用<code class="fe mt mu mv mj b">expectHeader</code>来检查报头是否返回。</p><p id="5ed5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe mt mu mv mj b">done</code>调用<code class="fe mt mu mv mj b">end</code>来完成测试。</p><h1 id="6725" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为动态数据快车设置高速缓存控制头</h1><p id="f6aa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自己的值设置<code class="fe mt mu mv mj b">Cache-Control</code>头。</p><p id="d169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="094b" class="mn lc iq mj b gy mo mp l mq mr">res.set('Cache-Control', 'public, max-age=86400');</span></pre><p id="be45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将<code class="fe mt mu mv mj b">Cache-Control</code>头设置为一天，即86400秒。</p><p id="1fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码在中间件中使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cc5d" class="mn lc iq mj b gy mo mp l mq mr">app.use((req, res, next) =&gt; {<br/>  res.set('Cache-Control', 'public, max-age=86400');<br/>  next();<br/>})</span></pre><p id="7ed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是把线放进去，调用<code class="fe mt mu mv mj b">next</code>来调用下一个中间件。</p><h1 id="6694" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">相对于父目录的快速服务静态文件夹</h1><p id="a14d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">path.join</code>把一个文件夹作为一个相对于目录的静态文件夹。</p><p id="8418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba73" class="mn lc iq mj b gy mo mp l mq mr">const path = require('path');<br/>const express = require('express');<br/>const app = express();</span><span id="18a6" class="mn lc iq mj b gy ms mp l mq mr">app.use(express.static(path.join(__dirname, '../public')));</span></pre><p id="52f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">express.static</code>将当前文件夹上一级的<code class="fe mt mu mv mj b">public</code>文件夹设置为服务静态文件的文件夹。</p><h1 id="36a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在一个路由中发送多个响应块</h1><p id="0a34" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果需要分块发送我们的响应，我们可以使用<code class="fe mt mu mv mj b">response.write</code>方法。</p><p id="4b12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b22b" class="mn lc iq mj b gy mo mp l mq mr">response.write("foo");<br/>response.write("bar");<br/>response.end();</span></pre><p id="a5d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用了两次<code class="fe mt mu mv mj b">response.write</code>来发送响应的不同部分，</p><p id="6dc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe mt mu mv mj b">response.end</code>来完成响应的发送。</p><h1 id="9acd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Mocha中带有文件上传的单元测试</h1><p id="d524" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过编写以下代码来测试文件上传:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="613c" class="mn lc iq mj b gy mo mp l mq mr">const should = require('should');<br/>const supertest = require('supertest');<br/>const request = supertest('localhost:3000');</span><span id="51d1" class="mn lc iq mj b gy ms mp l mq mr">describe('upload', () =&gt; {<br/>  it('a file', (done) =&gt; {<br/>    request<br/>      .post('/upload')<br/>      .field('foo', 'bar')<br/>      .attach('image', 'pic.jpg')<br/>      .end((err, res) =&gt; {<br/>        res.should.have.status(200);<br/>        done();<br/>      });<br/>  });<br/>});</span></pre><p id="1568" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向<code class="fe mt mu mv mj b">supertest</code>发出POST请求，并调用<code class="fe mt mu mv mj b">attach</code>以给定的名称附加文件。</p><p id="a333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">field</code>有文本字段，我们想提交的文件上传。</p><p id="caa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查回调的响应是200。</p><p id="1482" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以附加多个字段或文件附件。</p><h1 id="b91e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express应用程序中监听socket.io错误</h1><p id="8f3d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将<code class="fe mt mu mv mj b">listen</code>返回的服务器对象传入<code class="fe mt mu mv mj b">socket.io</code>函数来监听Express app中的socket.io。</p><p id="0852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f603" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');<br/>const app = express();<br/>const server = app.listen(port);<br/>const io = require('socket.io')(server);</span></pre><p id="d34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">server</code>传递给<code class="fe mt mu mv mj b">socket.io</code>包返回的函数。</p><p id="fd53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="31d6" class="mn lc iq mj b gy mo mp l mq mr">const http = require('http');<br/>const express = require('express');<br/>const app = express();</span><span id="159f" class="mn lc iq mj b gy ms mp l mq mr">const server = http.createServer(app);<br/>consr io = require('socket.io').listen(server);<br/>server.listen(80);</span></pre><p id="8cdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从<code class="fe mt mu mv mj b">http</code>模块返回的<code class="fe mt mu mv mj b">server</code>传递给<code class="fe mt mu mv mj b">listen</code>方法。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ae89745f38cff556fb28f7b624e54c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N9I1d8JAag41XxLK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@joepix?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔·史密斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d8ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bd11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe mt mu mv mj b">res.header</code>方法设置表头。</p><p id="025d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有多种方法可以在Express应用程序中监听来自socket.io的错误。</p><p id="ee88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用Supertest测试文件上传。</p></div></div>    
</body>
</html>