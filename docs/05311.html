<html>
<head>
<title>An Overview of Cache and Its Policy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存及其策略概述</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-overview-of-cache-and-its-policy-542bc40a8cbf?source=collection_archive---------1-----------------------#2021-07-17">https://blog.devgenius.io/an-overview-of-cache-and-its-policy-542bc40a8cbf?source=collection_archive---------1-----------------------#2021-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95f8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">缓存和最流行的缓存回收策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/40c6c480e156a649e7018a39618bf393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YfSoAWEo5PWzqFUE"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@vmokry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vladimir Mokry </a>拍摄的照片</figcaption></figure><p id="1e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存意味着将频繁的数据放在更近的地方以便访问。这有助于流程更快地访问这些数据。随处缓存被广泛使用。你会发现几乎没有大公司不使用缓存。了解这些会对你有很大帮助。</p><h1 id="9f07" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们有一个想法</h1><p id="8503" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设你带着一个特定的想法在做研究，为此，你从许多书中获得帮助。所有的书都在你家的图书馆里。每次你需要一本书的时候，你需要去图书馆然后把它带来。这既费时又麻烦。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/5e2cf60d908767bbb1994baf3772be65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jYdsB6xagVQaASUJUVsCA.png"/></div></div></figure><p id="c098" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你知道这种研究可能需要这些特定的书，那么你可以一次把它们都带来，放在你的桌子上。这样你就不需要一次又一次地去图书馆了。现在你的进程比以前快多了。</p><p id="55a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是缓存的作用。您只是缓存了您经常需要的东西来加快您的进程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/f0fbdb5f45d262eb562b5238fa3f86e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WIR6O6VbR8piCcCZ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@hudsoncrafted?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="cef2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">缓存回收策略</h1><p id="8d27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能会想，为什么我应该替换缓存中的东西？事实上，缓存太贵了。显然你有一个极限。整个数据不能存储在高速缓冲存储器中。</p><p id="bece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的缓存有 100 个数据的容量，而您刚刚超过了您的限制。缓存会自动删除一个。你最好定义规则。还有更多的既定政策。一些受欢迎的政策是</p><ul class=""><li id="ca35" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">先进先出</li><li id="6246" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">后进先出法</li><li id="193d" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">最近最少使用(LRU)</li><li id="c198" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">时间感知最近最少使用(TLRU)</li><li id="8731" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">最近使用的(MRU)</li></ul><h1 id="6472" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先进先出</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/2472d98c58ee8eac64bb4c67aab2d1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r1agKxyTQTeDf8-e"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@levidjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Levi Jones </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">FIFO 的行为与我们在数据结构中使用的 FIFO 相同。先进先出我们的方法是，当缓存已满时，先来的人必须先走。缓存按照块添加的顺序驱逐块。没有其他优先权在这里不适用。数据有多重要或者数据被使用的频率有多高并不重要。</p><p id="15bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是 C++中管理 FIFO 的代码部分。请看一看。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="39d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这不是缓存管理中使用策略。有时候这是有用的。取决于你的需要。</p><h1 id="1d66" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后进先出法</h1><p id="2990" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这和 FIFO 正好相反。这个也是熟悉数据结构知识的。当缓存已满时，最后来的人将先走。这不是一个流行的缓存策略。想想现实生活中的问题。我们不需要像往常一样使用后进先出法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/371244d6b1c1b85f1b1e75be32e1f663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TVQgkh_GAJ70zjtznj7bA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://de.wikipedia.org/w/index.php?title=Datei:Lifo.svg&amp;filetimestamp=20090108115010&amp;" rel="noopener ugc nofollow" target="_blank"> Wiki </a></figcaption></figure><p id="c0c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一段 C++代码。请看一看</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="aa13" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最近最少使用(LRU)</h1><p id="35c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">LRU 策略首先弹出最近最少使用的项目。该算法始终跟踪数据使用情况，并保留最近最少使用的数据。下面是一个例子。假设我们有一个 701203042303212 的序列。这是一个接一个的数据序列。</p><h2 id="1139" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">页面错误</h2><p id="69b4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果数字不在数据容器中，则发生页面错误。我们在数据容器中将其标记为红色，还有一个页面错误列，表示页面错误发生在哪个阶段。</p><h2 id="bd58" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">页面点击量</h2><p id="3e95" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果该数字已经在数据容器中，则发生页面点击。当页面点击发生时，我们把它们变成绿色。</p><h2 id="8e9a" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">页面的其余部分</h2><p id="ec36" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们为剩下的页面设置了浅蓝色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2feb60259ec725fda784a085f682ba4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*pQnxMwnUsJVdufsmIGbAFA.png"/></div></figure><p id="ce9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是颜色的定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/40bcc313387b8e730cf3790b7c631b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*Kl4vmkxuIduu_nwE-c668g.png"/></div></figure><p id="7370" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LRU 是缓存管理中使用最广泛的驱逐策略之一。</p><h1 id="aa5b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">时间感知最近最少使用(TLRU)</h1><p id="50af" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">TLRU 是 LRU 的另一种变体。不同的是，数据有一个有效的生命周期，另一方面，LRU 没有这样的条件。TLRU 主要用于网络缓存系统，如信息中心网络(ICN)、内容交付网络(cdn)和一般的分布式网络。</p><h1 id="6f2c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">其他人</h1><p id="e096" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你还会发现更多的驱逐政策。首先，找出你需要什么，然后选择符合你要求的驱逐政策。如今，大型知名公司会问很多关于缓存及其政策的问题。这些知识也会对你有所帮助。</p><h1 id="4301" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包裹</h1><p id="511a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这里，我们可以找到缓存的基础知识及其一些策略。知道这些对你以后会有帮助。感谢您的阅读。</p><p id="a7a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考:【https://en.wikipedia.org/wiki/Cache_replacement_policies T4】</p></div></div>    
</body>
</html>