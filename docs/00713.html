<html>
<head>
<title>JavaScript Basics — Parameters and Function Considerations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础—参数和函数考虑事项</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-basics-parameters-and-function-considerations-b27cfba7bea?source=collection_archive---------45-----------------------#2020-06-14">https://blog.devgenius.io/javascript-basics-parameters-and-function-considerations-b27cfba7bea?source=collection_archive---------45-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0477ae070c63244d747593f37c4ded45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oT2RKThfkgN7wQB1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@amandakariella?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿曼达·卡里拉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ddf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究函数参数、闭包、副作用和递归。</p><h1 id="0ab8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">默认参数</h1><p id="d570" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有带参数的函数，但我们调用它们时没有足够的参数来填充参数，那么它们将被设置为<code class="fe me mf mg mh b">undefined</code>。</p><p id="a916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使函数调用更安全，我们可以为参数设置默认值。</p><p id="8db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d26e" class="mq lc iq mh b gy mr ms l mt mu">const add = (a = 0, b = 0) =&gt; {<br/>  return a + b;<br/>}</span></pre><p id="b865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>都设置为默认值0。</p><p id="38d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">=</code>表示当没有值传入时，我们给参数分配一个默认值。</p><p id="f186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="21b5" class="mq lc iq mh b gy mr ms l mt mu">const sum = add();</span></pre><p id="ee46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">sum</code>得0。</p><p id="fa55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ca31" class="mq lc iq mh b gy mr ms l mt mu">const sum = add(1);</span></pre><p id="71a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe me mf mg mh b">a</code>是1而<code class="fe me mf mg mh b">b</code>是0。</p><h1 id="24c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="5a0a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为我们可以使用JavaScript函数作为值，所以我们可以将它们嵌套在函数中。</p><p id="a2cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以返回能够访问函数内部变量的函数，而这些变量从外部是不可用的。</p><p id="977f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="61b5" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  let x = 1;<br/>  return () =&gt; x;<br/>}</span></pre><p id="3e50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个函数，它返回一个只在<code class="fe me mf mg mh b">foo</code>函数中可用的<code class="fe me mf mg mh b">x</code>变量。</p><p id="d91a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个函数调用都会创建局部变量，所以不同的函数调用不会互相践踏变量。</p><p id="e417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">能够引用封闭范围的局部变量的特定实例的能力称为闭包。</p><p id="f5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就可以在本地访问变量，而不会暴露在外部。</p><p id="078c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="12cd" class="mq lc iq mh b gy mr ms l mt mu">const bar = foo()();</span></pre><p id="2549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">bar</code>就是1。</p><h1 id="c80e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">递归</h1><p id="6fd6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数可以调用它自己，只要我们不调用它太多次以至于溢出调用堆栈。</p><p id="97c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用自身的函数称为递归函数。</p><p id="2008" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06e0" class="mq lc iq mh b gy mr ms l mt mu">const factorial = x =&gt; {<br/>  if (x === 1) {<br/>    return 1;<br/>  }<br/>  return x * factorial(x - 1);<br/>}</span></pre><p id="868d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个带参数<code class="fe me mf mg mh b">x</code>的<code class="fe me mf mg mh b">factorial</code>函数。</p><p id="25e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">x</code>是1，那么我们返回1。</p><p id="9d62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们返回<code class="fe me mf mg mh b">x</code>乘以用<code class="fe me mf mg mh b">x — 1</code>调用的<code class="fe me mf mg mh b">factorial</code>的返回结果。</p><p id="8b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次我们调用<code class="fe me mf mg mh b">factorial</code>时，参数都会下降，直到1。</p><p id="62f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样就不会永远调用它，溢出调用栈。</p><h1 id="b76b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">增长函数</h1><p id="eb12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们创建一个新函数有几个原因。</p><p id="6f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能已经多次编写了一段代码。为了防止这种情况，我们将所有重复的代码放入一个函数中。</p><p id="b53f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们引入函数的另一个原因是为了添加我们还没有编写的功能，这些功能应该有自己的函数。</p><p id="bf02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们命名函数并编写函数体。</p><p id="180a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想在函数创建后添加更多的功能时，我们会在函数体中添加更多的代码。</p><p id="3872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不断增加它，直到它变成一个怪物。</p><p id="3713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样不好，因为很难阅读和理解。</p><p id="f9fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该有增长的功能。相反，我们应该把它们分成小块。</p><p id="1727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有更多的功能，那么创建一个新的功能，而不是添加到现有的功能。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/e25f8258fac7da6806849bb9a22d2c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1xtf9FKW_1zSucL0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@meadowmariee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅多·玛丽</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c0f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">副作用</h1><p id="c33e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">副作用是函数体中的代码，除了用于计算返回值之外，它还执行其他操作。</p><p id="79d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们将一些东西记录到控制台，那么这就是副作用。</p><p id="2b33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回值的函数比不产生副作用的函数更容易组合。</p><p id="6685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">纯函数是一种没有副作用的特定的返回值函数。</p><p id="a295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且它们也不依赖于其他代码的副作用。</p><p id="13f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将使测试更容易，因为我们可以替换返回值，而不是调用函数本身。</p><p id="b58c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这减少了对模拟副作用的脚手架的需求。</p><h1 id="2088" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cb17" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript函数可以有默认参数。我们可以利用这一点来降低没有传递参数的风险。</p><p id="8e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包让函数中的函数访问外部函数中的变量。</p><p id="33b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">增长失控的功能应该被分解成更小的功能。</p><p id="552f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们能避免副作用，就不应该犯。</p></div></div>    
</body>
</html>