<html>
<head>
<title>In-Memory and Distributed cache (.NET Core)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存中和分布式缓存(。网络核心)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/in-memory-and-distributed-cache-net-core-9be16bec34d7?source=collection_archive---------1-----------------------#2021-12-10">https://blog.devgenius.io/in-memory-and-distributed-cache-net-core-9be16bec34d7?source=collection_archive---------1-----------------------#2021-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/58b6e9e98a8f9df80f73c83261a3e40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VtyF6FT9_QNDDLSe7QKkg.png"/></div></div></figure><p id="ad8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你好，我们来谈谈缓存，缓存有哪些类型，以及如何在中使用它们。网络核心</p><h1 id="b66b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是缓存？</h1><p id="ff29" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">缓存是将数据存储在一个特殊的地方，以便将来更快地访问。通过显著减少对数据源(如数据库)的调用次数，应用缓存可以显著提高任何应用程序的性能。</p><p id="84ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当网页上的一些元素的数据很少改变或者在一段时间后改变时，缓存特别有效。</p><h1 id="7d3a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">中的缓存类型。网络核心</h1><p id="e97d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">内存缓存— </strong>缓存存储并接收来自运行应用程序的服务器的缓存数据的结果。</p><p id="e5d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种类型的缓存适用于只包含一台服务器的中小型应用程序。</p><p id="9563" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内存缓存有缺点，如果服务器重启或崩溃，数据会怎么样？显然它们会消失:)当然，这在开发阶段可能是有用的，但在生产中这种行为是不可接受的。</p><p id="23c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这种类型的缓存，还会出现另一个问题，如何从另一个服务器访问数据？因为一个应用程序可以有多个服务器，也可以是 web 场的一部分。</p><p id="9343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内存缓存有一种技术——<strong class="jx io">粘性会话。</strong>粘滞会话意味着一个会话总是去往负载均衡器后面的一个特定服务器。</p><p id="4a30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有分布式缓存来解决下一个问题:当服务器重启或崩溃时缓存丢失，服务器之间的缓存共享。</p><p id="9660" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">分布式缓存— </strong>缓存不包含在特定服务器的内存中，而是可以使用其他一些节点来存储缓存的数据。因此，每台服务器都可以访问缓存，即使服务器重启或崩溃，缓存的数据也不会丢失。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/2bc0429a26543f0605777403d80e7524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBbp4CJSVyTkFIcrkBf5nQ.png"/></div></div></figure><p id="47b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">存储分布式缓存的节点示例:<a class="ae mb" href="https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> SQL Server 数据库</a>、<a class="ae mb" href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-overview" rel="noopener ugc nofollow" target="_blank"> Azure Redis 缓存</a>、<a class="ae mb" href="http://www.alachisoft.com/ncache/aspnet-core-idistributedcache-ncache.html" rel="noopener ugc nofollow" target="_blank"> NCache </a>等。</p><h1 id="6ea6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何在？网芯？</h1><p id="f608" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">首先，让我们创建一个 API 项目。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/b2e02f075876c4a5e08d9e2cf1e9b79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcRiQxL622tt9t12gSIzPw.png"/></div></div></figure><p id="ba7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们需要在 Startup.cs 中将内存缓存添加到依赖项中</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4168" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在我们可以在我们的解决方案中使用<code class="fe mf mg mh mi b">IMemoryCache</code>。</p><p id="8ac6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过<code class="fe mf mg mh mi b">IMemoryCache</code>,我们可以向缓存中添加新值，或者检查和检索缓存中已经存在的值。</p><p id="8619" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本方法:</p><ul class=""><li id="9d42" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">TryGetValue —检查给定键是否存在任何值</li><li id="c179" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">设置—设置给定键的值</li></ul><p id="158d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将在我称为<code class="fe mf mg mh mi b">EmployeeController</code>的新控制器中注入<code class="fe mf mg mh mi b">IMemoryCache</code>接口。</p><p id="6da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面我提供了带有注释的代码<code class="fe mf mg mh mi b">EmployeeController</code>。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经注意到，我已经设置了缓存选项来设置到期日期。这种到期可以是滑动的或绝对的。在上面的例子中，我设置了滑动。</p><h2 id="8621" class="mx ku in bd kv my mz dn kz na nb dp ld kg nc nd lh kk ne nf ll ko ng nh lp ni bi translated">过期。滑动 vs 绝对</h2><p id="5895" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">随着时间的推移，每个缓存对象都可能变得过时和不相关，当缓存对象过期时，应用程序不会返回缓存结果，而是请求再次获取数据，然后进行缓存。</p><p id="c04b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为开发人员，我们可以设置缓存对象的到期日期——绝对到期日期或滑动到期日期。</p><p id="a5b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">绝对</strong>过期意味着缓存将在给定时间后过期。</p><p id="57fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，我们设置 60 秒，正好 60 秒后，不管调用它的次数是多少，这个对象都将过期。</p><p id="0518" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">滑动</strong>到期允许你删除给定时间内未被访问的项目。</p><p id="40e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，我们设定 60 秒。如果 60 秒内没有电话，那么它将被删除。如果对象被检索，那么这 60 秒将再次被覆盖。</p><p id="be99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我可以使用绝对选项滑动吗？</strong></p><p id="dbd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，因为如果一个项目被访问的频率总是超过它的滑动过期时间，那么这个项目就有可能永远不会过期。</p><p id="2498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免这种情况，我们可以将这两个选项结合起来，在这种情况下，使用逻辑 OR 来决定某个项目是否应该标记为过期。如果过期参数之一超时，则从缓存中删除该对象。</p><p id="8696" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="26d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">试着想象一下上面例子中的结果是什么，缓存什么时候会被清空，或者只是在本地调试:)</p><h1 id="c30c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">分布式缓存</h1><p id="8af9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">IDistributedCache —中央接口。NET Core 的分布式缓存实现。</p><p id="0b3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该接口期望任何分布式缓存实现的基本方法都应该提供:</p><ul class=""><li id="cc4c" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">Get，GetAsync 通过键从缓存中获取项目。</li><li id="21bb" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">Set，SetAsync —通过键在缓存中添加新项目</li><li id="37a1" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">Refresh，RefreshAsync —根据项目的字符串关键字刷新项目，并重置其滑动过期超时</li><li id="378a" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">Remove，RemoveAsync —通过键从 cash 中移除项目。</li></ul><p id="758e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，该接口有 4 种实现方式:</p><ul class=""><li id="b987" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">分布式 SQL Server 缓存</li><li id="7d4f" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">分布式 Redis 缓存</li><li id="fb14" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">分布式 NCache 缓存</li><li id="cbd5" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated"><strong class="jx io">分布式内存缓存</strong></li></ul><p id="6c14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您当然可以编写自己的 IDistributedCache 实现。</p><p id="44a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你仔细阅读，你可能会注意到我将<strong class="jx io">分布式内存缓存</strong>表示为分布式缓存的一个实现。如果我们更深入地研究文档，我们会发现事实上这不是真正的分布式缓存，它使用 web 服务器的内存作为缓存存储。就像上面我们看到的<code class="fe mf mg mh mi b">IMemoryCache</code>一样。</p><h2 id="ed2f" class="mx ku in bd kv my mz dn kz na nb dp ld kg nc nd lh kk ne nf ll ko ng nh lp ni bi translated">那么，我们为什么需要分布式内存缓存呢？</h2><p id="7e62" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在分布式缓存开发的早期，这可能是一个有用的工具。当一个新的应用程序开发开始时，我们可以设置内存分布式缓存，然后使用 IDistributedCache 接口与缓存存储进行交互。</p><p id="88de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们只需在启动时更改配置，就可以用另一个真正的实现(Redis、NCache、SQL Server Cache)来替换它。</p><h2 id="f858" class="mx ku in bd kv my mz dn kz na nb dp ld kg nc nd lh kk ne nf ll ko ng nh lp ni bi translated">密码</h2><p id="8134" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了演示如何使用分布式缓存，我将使用相同的解决方案，但是我将在<code class="fe mf mg mh mi b">Startup.cs</code>中添加<code class="fe mf mg mh mi b">AddDistributedMemoryCache()</code>而不是<code class="fe mf mg mh mi b">AddMemoryCache()</code></p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ce8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">带有解释注释的代码:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a671" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链接到知识库—<a class="ae mb" href="https://github.com/stasoz1/CacheExamples" rel="noopener ugc nofollow" target="_blank">https://github.com/stasoz1/CacheExamples</a>T5】快乐编码😁</p><h1 id="7601" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">学到了新东西？</h1><p id="2f8c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你喜欢这篇文章，可以<a class="ae mb" href="https://www.buymeacoffee.com/stasoz" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">给我买杯咖啡</strong> </a>我写下一篇文章的时候再喝:)</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/stasoz"><div class="gh gi nj"><img src="../Images/cf79c871f5a738ec15a7f5802d80017f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lviQAsrtgJB0dMiercB9ig.png"/></div></a></figure></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="4924" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nr">更多内容尽在</em><a class="ae mb" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="nr">blog . dev genius . io</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>