<html>
<head>
<title>How I Added Authentication to a Flask API With Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用 Decorators 向 Flask API 添加身份验证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/man-how-i-added-authentication-to-a-flask-api-with-decorators-8ad82d92240c?source=collection_archive---------4-----------------------#2022-02-10">https://blog.devgenius.io/man-how-i-added-authentication-to-a-flask-api-with-decorators-8ad82d92240c?source=collection_archive---------4-----------------------#2022-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/182fd6ddedbe989235fbfbf1ed0f5b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcVtascFIXTgqceXYRXQmw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Emmanuel Ikwuegbu 在<a class="ae jz" href="https://unsplash.com/s/photos/handyman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7ab3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近我一直在做一个 Flask API，这周我们需要添加一些有特殊权限的新路径。基本上，问题是在执行这些请求之前，在用户的令牌上运行一些额外的身份验证。</p><p id="f077" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起初，我们尝试使用 Flask 自己的<code class="fe ky kz la lb b">before_request</code> decorator 来扩展认证过程，但是没有成功，因为它不应该在每个请求上运行，而只是那些需要额外认证的请求。我的下一个尝试是创建一个方法并在控制器上调用它，但是它变得很混乱。</p><p id="fc3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最终的解决方案是使用 decorators，他们允许我集中授权代码，同时保持代码的整洁和可读性。</p><h1 id="083c" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">装修工到底是什么？</h1><p id="ea7a" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">装饰器是向现有函数添加功能的一种方式。它们是接收另一个函数并返回该函数(扩展或不扩展)的函数。</p><p id="191f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用例子会更容易理解，那我们来做点编码吧。首先，我们创建一个基本函数:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0aa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 Python 中，函数是对象，这允许我们传递，甚至从另一个函数返回。我们可以做这样奇怪的事情:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d6e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也是我们能够创造装饰者的原因。我们的 decorator 将接收一个函数，扩展它并返回。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="be01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，我们只是简单地将函数名传递给<code class="fe ky kz la lb b">hello()</code>，并在<code class="fe ky kz la lb b">hello()</code>的内部函数中调用它。因为当我们调用<code class="fe ky kz la lb b">obj</code>时<code class="fe ky kz la lb b">hello()</code>返回<code class="fe ky kz la lb b">inner()</code>，它将执行<code class="fe ky kz la lb b">inner</code>并打印“Hello ”,然后调用<code class="fe ky kz la lb b">name()</code>。</p><h1 id="6f34" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">合成糖</h1><p id="2dd1" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">当然，上面的代码不是很 Python 化，Python 为我们提供了一个更好的方法来在我们的函数上使用 decorators，那就是使用 then 和<code class="fe ky kz la lb b">@</code>符号:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="bc42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将为我们提供与之前相同的输出，但不那么冗长。Python 解释器会理解<code class="fe ky kz la lb b">@hello</code>的意思是取这个函数，在返回之前把它传递给<code class="fe ky kz la lb b">hello()</code>。</p><p id="2671" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以这样做多个装饰器:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="11a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，最上面的装饰器也将是最后调用的。</p><h1 id="a3c7" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">争论</h1><p id="438e" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">有时你需要使用参数，你也可以在你的装饰器上使用。假设您有一个对两个数字求和的函数:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="81b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按原样展示给用户有点干巴巴的，所以让我们用一个装饰器来装饰输出(看我怎么做的？).</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="615a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没那么复杂，对吧？到目前为止，我们基本上在做同样的事情，但是现在<code class="fe ky kz la lb b">inner</code>将接收<code class="fe ky kz la lb b">sum_two_numbers</code>的参数。</p><p id="8fb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以为更多的功能使用同一个装饰器。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="7363" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">更现实的例子</h1><p id="3cb9" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">假设您想测量函数执行需要多长时间。也许你在寻找优化机会，或者比较算法。</p><p id="ef4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以创建一个装饰函数来包装我们的函数，并返回运行时间。我们从测试一个函数开始:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cc22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行<code class="fe ky kz la lb b">slow_function</code>需要 t 秒。为了度量它，我们编写装饰器并包装它。完整示例如下:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5c03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以测量处理我们的函数需要多长时间！</p><h1 id="fe21" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">装饰者的认证</h1><p id="6c25" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在这篇文章的开始，我说我的问题是用户权限的认证，解决方案最终是这样的(出于明显的原因，有些部分被隐藏了，抱歉):</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b3b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Flask 将负责在管理控制器上调用<code class="fe ky kz la lb b">get</code>方法。每当进行这个调用时，它将首先执行装饰器上的代码，并验证用户是否是管理员，如果不是，则返回状态代码 401。</p><h1 id="bd2b" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="7744" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">装饰器是向代码中添加一些元编程的好方法。他们可以扩展您已经拥有的功能，然后添加新的功能。</p><p id="73f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它们在一些框架中被大量使用，作为一种让开发人员在保持代码整洁的同时更容易实现通用功能的方法。</p></div></div>    
</body>
</html>