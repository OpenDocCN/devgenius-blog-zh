<html>
<head>
<title>Part 2: Smart Contract and Angular Service Interaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分:智能合同和角度服务交互</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/part-2-smart-contract-and-angular-service-interaction-5862f6ec3f48?source=collection_archive---------4-----------------------#2022-01-20">https://blog.devgenius.io/part-2-smart-contract-and-angular-service-interaction-5862f6ec3f48?source=collection_archive---------4-----------------------#2022-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c6e2ceb824e9d66d26714ccb72d9a907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8jvWSRvhSt26LHXgBiUQA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="9232" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">如何在我们的角度应用程序中向区块链读写数据。</h2></div><p id="369b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在<a class="ae lj" href="https://medium.com/p/ace1c60b2523" rel="noopener">第 1 部分</a>中，我们对这个<a class="ae lj" href="https://github.com/pguso/angular-hardhat-starter-dapp" rel="noopener ugc nofollow" target="_blank">存储库</a>进行了大致的了解，您可以将它作为使用 Angular 开发您的 DApps 的起点。</p><p id="6a9e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这一部分，我们想看一下我们用来与用 Solidity 编写的智能合同交互的服务。</p><p id="d93b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是将存储和读取区块链图像的智能合同:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e207" class="lt lu iy lp b gy lv lw l lx ly">// SPDX-License-Identifier: MIT<br/>pragma solidity &gt;=0.7.0 &lt;0.9.0;<br/><br/>contract Gallery {<br/>  Image[] private images;<br/>  mapping(address =&gt; Image[]) private authorToImages;<br/><br/>  struct Image {<br/>    string title;<br/>    string imageMetaDataUrl;<br/>  }<br/><br/>  function store(string memory title, string memory imageMetaDataUrl) public {<br/>    Image memory image = Image(title, imageMetaDataUrl);<br/><br/>    images.push(image);<br/>    authorToImages[msg.sender].push(image);<br/>  }<br/><br/>  function retrieveAllImages() public view returns (Image[] memory) {<br/>    return images;<br/>  }<br/><br/>  function retrieveImagesByAuthor() public view returns (Image[] memory) {<br/>    return authorToImages[msg.sender];<br/>  }<br/>}</span></pre><p id="6c91" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们一步一步来。</p><p id="7d4d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这里，我们将所有上传的图像存储在一个数组中:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="733c" class="lt lu iy lp b gy lv lw l lx ly">Image[] private images;</span></pre><p id="86bd" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这里，我们将作者的地址映射到他们上传的图像。我们使用一个映射作为引用，就像数组和结构一样。</p><blockquote class="lz ma mb"><p id="84a5" class="kn ko mc kp b kq kr jz ks kt ku kc kv md kx ky kz me lb lc ld mf lf lg lh li ig bi translated">映射可以被看作是虚拟初始化的<a class="ae lj" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>，使得每个可能的键都存在，并且被映射到一个字节表示全为零的值:类型的<a class="ae lj" href="https://docs.soliditylang.org/en/v0.4.21/control-structures.html#default-value" rel="noopener ugc nofollow" target="_blank">默认值</a>。</p></blockquote><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2a62" class="lt lu iy lp b gy lv lw l lx ly">mapping(address =&gt; Image[]) private authorToImages;</span></pre><p id="b99d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这里使用了一个结构，它就像一个对象，我们也可以在元数据中存储图像的标题，我想展示如何使用结构。参数 imageMetaDataUrl 将保存 IPFS 到 JSON 对象的 Url，JSON 对象保存图像和描述的 URL。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="dee7" class="lt lu iy lp b gy lv lw l lx ly">struct Image {<br/>  string title;<br/>  string imageMetaDataUrl;<br/>}</span></pre><p id="f7e0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们将标题和 imageMetaDataUrl()作为字符串传递给存储函数，该函数将初始化的结构 Image()推送到 images 数组和 authorToImages()映射。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a040" class="lt lu iy lp b gy lv lw l lx ly">function store(string memory title, string memory imageMetaDataUrl) public {<br/>  Image memory image = Image(title, imageMetaDataUrl);<br/><br/>  images.push(image);<br/>  authorToImages[msg.sender].push(image);<br/>}</span></pre><p id="7875" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">retrieveAllImages()是一个简单的 getter 方法，它将返回所有图像。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="60c5" class="lt lu iy lp b gy lv lw l lx ly">function retrieveAllImages() public view returns (Image[] memory) {<br/>  return images;<br/>}</span></pre><p id="35ea" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">通过 retrieveImagesByAuthor()方法，我们将通过 msg.sender(发件人的地址)获得通过该地址上传的所有图像。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2fe0" class="lt lu iy lp b gy lv lw l lx ly">function retrieveImagesByAuthor() public view returns (Image[] memory) {<br/>  return authorToImages[msg.sender];<br/>}</span></pre><p id="d07f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，我们来看看将与部署的智能合同交互的角度服务。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="0022" class="lt lu iy lp b gy lv lw l lx ly">import { Injectable<strong class="lp iz"><em class="mc"> </em></strong>} from '@angular/core';<br/>import { ethers<strong class="lp iz"><em class="mc"> </em></strong>} from "ethers";<br/>import { environment<strong class="lp iz"><em class="mc"> </em></strong>} from "../../environments/environment";<br/>import Gallery from '../../../artifacts/contracts/Gallery.sol/Gallery.json'<br/>import detectEthereumProvider from "@metamask/detect-provider";<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class GalleryService {<br/>  public async getAllImages(): Promise&lt;any[]&gt; {<br/>    const contract = await GalleryService.<em class="mc">getContract</em>()<br/><br/>    return await contract['retrieveAllImages']()<br/>  }<br/><br/>  public async getImagesByAuthor(): Promise&lt;any[]&gt; {<br/>    const contract = await GalleryService.<em class="mc">getContract</em>(true)<br/><br/>    return await contract['retrieveImagesByAuthor']()<br/>  }<br/><br/>  public async addImage(title: string, fileUrl: string): Promise&lt;boolean&gt; {<br/>    const contract = await GalleryService.<em class="mc">getContract</em>(true)<br/>    const transaction = await contract['store'](<br/>      title,<br/>      fileUrl<br/>    )<br/>    const tx = await transaction.wait()<br/><br/>    return tx.status === 1<br/>  }<br/><br/>  private static async getContract(bySigner=false) {<br/>    const provider = await GalleryService.<em class="mc">getWebProvider</em>()<br/>    const signer = provider.getSigner()<br/><br/>    return new ethers.Contract(<br/>      environment.contractAddress,<br/>      Gallery.abi,<br/>      bySigner ? signer : provider,<br/>    )<br/>  }<br/><br/>  private static async getWebProvider(requestAccounts = true) {<br/>    const provider: any = await detectEthereumProvider()<br/><br/>    if (requestAccounts) {<br/>      await provider.request({ method: 'eth_requestAccounts' })<br/>    }<br/><br/>    return new ethers.providers.Web3Provider(provider)<br/>  }<br/>}</span></pre><p id="cf39" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们进口商品中最有趣的部分是我们画廊合同的细节。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="0579" class="lt lu iy lp b gy lv lw l lx ly">import Gallery from '../../../artifacts/contracts/Gallery.sol/Gallery.json'</span></pre><p id="1ae3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们的服务 getWebProvider()底部有两个助手方法，将应用程序连接到元掩码。我们使用 npm 包来检测提供方。</p><blockquote class="lz ma mb"><p id="e62a" class="kn ko mc kp b kq kr jz ks kt ku kc kv md kx ky kz me lb lc ld mf lf lg lh li ig bi translated">一个用于检测元掩码以太网提供程序或在<code class="fe mg mh mi lp b">window.ethereum</code>注入的任何提供程序的小实用程序。</p></blockquote><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8f3d" class="lt lu iy lp b gy lv lw l lx ly">private static async getWebProvider(requestAccounts = true) {<br/>  const provider: any = await detectEthereumProvider()<br/><br/>  if (requestAccounts) {<br/>    await provider.request({ method: 'eth_requestAccounts' })<br/>  }<br/><br/>  return new ethers.providers.Web3Provider(provider)<br/>}</span></pre><p id="aa7a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们的另一个助手方法 getContract()返回我们的合同实例。如果 bySigner 设置为 true，我们将为合同提供用户(帐户)的上下文。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9be7" class="lt lu iy lp b gy lv lw l lx ly">private static async getContract(bySigner=false) {<br/>  const provider = await GalleryService.getWebProvider()<br/>  const signer = provider.getSigner()<br/><br/>  return new ethers.Contract(<br/>   environment.contractAddress,<br/>  Gallery.abi,<br/>  bySigner ? signer : provider,<br/> )<br/>}</span></pre><p id="4d19" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在 getAllImages()中，我们获取了智能合同的一个实例，并在其上调用 retrieveAllImages()方法来获取所有上传的图像。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="5363" class="lt lu iy lp b gy lv lw l lx ly">public async getAllImages(): Promise&lt;any[]&gt; {<br/>  const contract = await GalleryService.getContract()<br/><br/>  return await contract['retrieveAllImages']()<br/>}</span></pre><p id="16f1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在 getImagesByAuthor()中，我们通过签名者(登录用户)获取合同，并调用合同的 retrieveImagesByAuthor()方法。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="68e7" class="lt lu iy lp b gy lv lw l lx ly">public async getImagesByAuthor(): Promise&lt;any[]&gt; {<br/>  const contract = await GalleryService.getContract(true)<br/><br/>  return await contract['retrieveImagesByAuthor']()<br/>}</span></pre><p id="d557" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">addImage()方法是将数据保存到区块链的唯一方法。它将接收标题和图像元数据的 IPFS URL，由签名者获取合同，调用智能合同的存储方法，并将参数传递给将保存到区块链的合同。</p><p id="1763" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">最后，我们将等待事务完成，数据保存到区块链，如果事务成功，将返回数据。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e7ed" class="lt lu iy lp b gy lv lw l lx ly">public async addImage(title: string, fileUrl: string): Promise&lt;boolean&gt; {<br/>  const contract = await GalleryService.getContract(true)<br/>  const transaction = await contract['store'](<br/>    title,<br/>    fileUrl<br/>  )<br/>  const tx = await transaction.wait()<br/><br/>  return tx.status === 1<br/>}</span></pre><p id="e63d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，让我们看看如何将图像和数据保存到 IPFS。这是我们用来联系 IPFS 的角度服务。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4a9f" class="lt lu iy lp b gy lv lw l lx ly">import { Injectable<strong class="lp iz"><em class="mc"> </em></strong>} from "@angular/core"<br/>import { create } from "ipfs-http-client"<br/>import { environment<strong class="lp iz"><em class="mc"> </em></strong>} from "../../environments/environment"<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class IpfsService {<br/>  public async uploadFile(data: any): Promise&lt;string&gt; {<br/>    let url = ''<br/>    const client = IpfsService.<em class="mc">getClient</em>()<br/><br/>    try {<br/>      const added = await client.add(data)<br/>      url = `${environment.ipfs}/ipfs/${added.path}`<br/>    } catch (error) {<br/>      console.log(error)<br/>    }<br/><br/>    return url<br/>  }<br/><br/>  private static getClient(): any {<br/>    // @ts-ignore<br/>    return create(`${environment.ipfs}:5001/api/v0`)<br/>  }<br/>}</span></pre><p id="300c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们在服务的底部有一个助手方法 getClient()，它将返回 HTTP API 客户端的一个实例，该实例解析为 IPFS HTTP API 的一个运行实例。我们使用一个 Infura 节点<a class="ae lj" href="https://ipfs.infura.io" rel="noopener ugc nofollow" target="_blank">https://ipfs . in fura . io</a>:5001/API/v 0，但是你也可以使用你自己的节点。</p><p id="c7ee" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">uploadFile()方法接收一个图像或数据对象的 URL，并用 client.add()将它上传到 IPFS，client . add()返回一个散列，在下一行中，我们返回上传资产的完整 URL。</p><p id="4f48" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我们的组件中，我们只需要用我们想要上传的文件(图像)或 JSON 数据对象调用 uploadFile()方法。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9f6e" class="lt lu iy lp b gy lv lw l lx ly">const fileUrl = await this.ipfs.uploadFile(eventTarget.files[0])</span><span id="6362" class="lt lu iy lp b gy mj lw l lx ly">// or</span><span id="74b0" class="lt lu iy lp b gy mj lw l lx ly">const metaDataUrl = await this.ipfs.uploadFile(JSON.stringify({<br/>  fileUrl,<br/>  description<br/>}))</span></pre><p id="24d7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我希望这给你一个很好的总结，用 Angular 构建你自己的 DApps。如果我不能回答你的所有问题，欢迎你添加评论。</p></div></div>    
</body>
</html>