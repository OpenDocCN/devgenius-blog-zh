# Golang 记忆逃逸深度解析

> 原文：<https://blog.devgenius.io/in-depth-analysis-of-golang-memory-escape-edfbfb856913?source=collection_archive---------0----------------------->

你必须掌握 Golang 记忆逃生知识点

![](img/8cc307793f5323096f5f5a50191eafed.png)

照片由 [Alesia Kazantceva](https://unsplash.com/@alesiaskaz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

最近一个朋友正在学习 Golang，他说他遇到了一个问题，下面的代码居然不报错，以他写 C 语言的经验，这个代码应该不会被编译。

这段代码对于 Golang 来说真的没问题，下面我们来看看 C 代码。

当我们执行`gcc demo.c`时，将会返回一个警告。

```
demo.c:6:13: warning: address of stack memory associated with local variable 'data' returned [-Wreturn-stack-address]return &data;1 warning generated.
```

提示说返回一个堆栈内存，这是不允许的。朋友很好奇为什么 Golang 中允许这种行为，这就引出了我们今天要分析的问题: **Golang 的内存逃逸行为**。

程序中的内存分为两个区域，一个用于堆栈，一个用于堆。堆栈区有特定的结构和寻址方法，寻址速度很快，开销很小。另一方面，堆是一个没有特定结构和固定大小的内存区域，可以根据需要进行调整。

全局变量、占用大量内存的局部变量以及在函数调用后不能立即回收的局部变量都存储在堆中。在堆上分配和回收变量的开销比在堆栈上多得多。

简单地说，函数调用中请求的内存存储在堆栈中，在函数结束时，这些内存会立即返回给系统。

在上面的例子中，函数内部应用的变量`data`会在函数结束后被回收，不会持久。它们都存储在堆栈区。因为存在时间短，栈区分配速度快，编译器会确认这是最佳选择。

让我们看另一个例子。

在上面的例子中，变量`data`在函数结束后不会被释放，因为返回的是指向该变量的指针，编译器会认为该变量在函数结束后被用在了别处，所以会保留这个内存，同时，应用到堆中，因为堆中的内存不会被立即回收，栈中的内存会被立即回收。

我们使用`go tool compile -m`来分析初始代码:

```
$ go tool compile -m demo.godemo.go:3:6: can inline demoFunctiondemo.go:8:6: can inline maindemo.go:9:31: inlining call to demoFunctiondemo.go:4:9: moved to heap: data
```

根据分析结果，我们可以看到，`moved to heap: data`表示`datathe` 变量已经转义到堆内存中。

Golang 官网 FAQ 上有关于变量赋值问题的说明:

> 从正确性的角度来看，你不需要知道。Go 中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。
> 
> 存储位置确实对编写高效的程序有影响。如果可能的话，Go 编译器会在函数的堆栈框架中分配函数的局部变量。
> 
> 但是，如果编译器无法证明函数返回后变量未被引用，则编译器必须在垃圾回收堆上分配变量，以避免悬空指针错误。此外，如果局部变量非常大，将其存储在堆中可能比存储在堆栈中更有意义。
> 
> 在当前的编译器中，如果一个变量的地址被占用，那么这个变量就是堆上分配的候选变量。然而，一个基本的逸出分析认识到，在某些情况下，这样的变量不能活过函数的返回，而是可以驻留在堆栈上。

总结一下:如果一个变量被取地址，那么它可能被分配在堆上。但是，这些只能在对变量执行转义分析操作后才能确认。如果函数返回后变量不再被引用，它将被分配到堆栈中。

让我们来看看内存逃逸的场景。

**1。指针转义**

变量`p`是局部变量，但是因为是引用返回的，所以会转义到堆内存。查看编译分析，如下所示:

```
$ go tool compile -m person.goperson.go:7:6: can inline SetPersonperson.go:13:6: can inline mainperson.go:14:11: inlining call to SetPersonperson.go:7:16: leaking param: nameperson.go:8:10: new(Person) escapes to heap // [Escape happens here]person.go:14:11: new(Person) does not escape
```

**2。堆栈空间不足，无法转义**

分析执行如下:

```
$ go tool compile -m index.goindex.go:4:11: make([]int, 10000, 10000) escapes to heap
```

**3。动态类型转义**

有很多函数的参数类型是`interface`类型，在编译时很难确定参数的具体类型，这种类型的情况也会产生转义。例如内置函数`Println`方法。

分析执行如下:

```
$ go tool compile -m hello.gohello.go:5:6: can inline mainhello.go:6:13: inlining call to fmt.Printlnhello.go:6:14: "hello golang" escapes to heap // [Escape happens here]hello.go:6:13: []interface {}{...} does not escape<autogenerated>:1: leaking param content: .this
```

程序编译时会有内存逸出分析，内存逸出分析有 2 个好处:

*   经过转义分析，可以确认具体变量是分配在堆内存还是堆栈内存，提高了程序性能。
*   降低 GC 压力，没有逸出的变量可以及时回收。

最终总结:

*   对于小数据，使用按值传递而不是指针
*   避免热数据长度不确定的`slice`
*   避免将参数传递给`interface`，尽量使用显式类型
*   在逸出分析之后，变量的分配被确认。Golang 官方确定了这一切，以便开发人员可以专注于业务逻辑本身，而不必过于关注内存。

感谢您阅读本文，如果您发现文章中有任何错误，请随时发表评论。

祝你有愉快的一天。