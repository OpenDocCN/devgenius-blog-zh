<html>
<head>
<title>SFINAE What is and how to use it with modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SFINAE 是什么以及如何在现代 C++中使用它</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sfinae-what-is-and-how-to-use-it-with-modern-c-bb3edfb0d2f8?source=collection_archive---------6-----------------------#2022-12-30">https://blog.devgenius.io/sfinae-what-is-and-how-to-use-it-with-modern-c-bb3edfb0d2f8?source=collection_archive---------6-----------------------#2022-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/1e0b846cccdb9474df8677339a95e941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tb9Sg0ZM8d3sOLmJxeGbwg.jpeg"/></div></div></figure><div class=""/><figure class="gl gn jw jx jy ip gh gi paragraph-image"><div class="gh gi jv"><img src="../Images/63d0164d79be493fe65b9150b75fb1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*I33dmloMlATw0bs38Jkp6Q.png"/></div></figure><p id="7882" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">乍一看，你可能会对这个概念感到困惑，所以这里需要澄清一些事情。</p><h1 id="1946" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">检测习语:</h1><p id="d2b8" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在 C++中，检测习语允许编译时类型自省。使用检测习语，我们可以检查类型是否有适合特定接口的方法、类型别名或成员。这允许库作者创建更具表现力的元编程工具。用户可以将他喜欢的任何类型插入到元函数中，只要它符合所需的接口。<br/>检测习语的所有当前迭代都依赖于 SFINAE，那么 S <em class="ma"> FINAE </em>是什么？</p><h1 id="1f3b" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">替换失败不是错误</h1><p id="ee1a" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">从<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/sfinae" rel="noopener ugc nofollow" target="_blank"> cppreference </a></p><blockquote class="mc md me"><p id="4eb1" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">该规则适用于函数模板的重载解析:当<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/function_template#Template_argument_substitution" rel="noopener ugc nofollow" target="_blank">用</a>替换模板参数的显式指定类型或<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction" rel="noopener ugc nofollow" target="_blank">推导出的类型</a>失败时，专门化将从<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/overload_resolution" rel="noopener ugc nofollow" target="_blank">重载集合</a>中被丢弃，而不会导致编译错误。</p><p id="8eec" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">该特性用于模板元编程。</p></blockquote><p id="732a" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们考虑这个例子:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="e089" class="mr ky iy mn b be ms mt l mu mv">template&lt;typename T&gt;<br/>struct hasActive<br/>{<br/>  T active;<br/>  using activeType = T;<br/>};<br/><br/>struct noActive<br/>{<br/>};<br/>template&lt;typename T&gt;<br/>typename T::activeType printActive(const T&amp; t)<br/>{<br/>  return t.active;<br/>}<br/><br/>int main()<br/>{<br/>    printActive(hasActive&lt;int&gt;{});<br/>    printActive(noActive{});<br/>}</span></pre><p id="c69e" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">代码将无法编译。第一次调用<em class="ma">print active(hasActive&lt;int&gt;{ })</em>是正确的构造，但是第二次调用产生了以下错误(GCC):</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="ee19" class="mr ky iy mn b be ms mt l mu mv">no matching function for call to 'printActive(noActive)'<br/>   20 |     printActive(noActive{});<br/>      |     ~~~~~~~~~~~^~~~~~~~~~~~<br/>prog.cc:12:24: note: candidate: 'template&lt;class T&gt; typename T::activeType printActive(const T&amp;)'<br/>   12 | typename T::activeType printActive(const T&amp; t)<br/>      |                        ^~~~~~~~~~~<br/>prog.cc:12:24: note:   template argument deduction/substitution failed:<br/>prog.cc: In substitution of 'template&lt;class T&gt; typename T::activeType printActive(const T&amp;) [with T = noActive]':<br/>prog.cc:20:16:   required from here</span></pre><p id="b671" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解决这个问题，您可能需要为<code class="fe mw mx my mn b">noActive </code>类型<code class="fe mw mx my mn b">void printActive(const noActive&amp; ){}</code>添加一个合适的函数。这样，编译器可以找到一个合适的匹配，并注入代码。<br/>所以我们需要了解重载决策。</p><h1 id="3941" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">过载分辨率</h1><p id="4874" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">来自<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/overload_resolution" rel="noopener ugc nofollow" target="_blank"> cppreference </a></p><blockquote class="mc md me"><p id="c1f3" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">为了编译一个函数调用，编译器必须首先执行<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/lookup" rel="noopener ugc nofollow" target="_blank">名称查找</a>，对于函数，这可能涉及<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/adl" rel="noopener ugc nofollow" target="_blank">参数相关的查找</a>，对于函数模板，后面可能是<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction" rel="noopener ugc nofollow" target="_blank">模板参数推导</a>。如果这些步骤产生了一个以上的<em class="iy">候选函数</em>，则执行<em class="iy">过载解决</em>来选择实际将被调用的函数。</p><p id="8e13" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">通常，参数与实参最匹配的候选函数就是被调用的函数。</p><p id="90db" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">对于其他可能出现重载函数名的上下文，参见<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/overloaded_address" rel="noopener ugc nofollow" target="_blank">重载函数的地址</a>。</p><p id="60e8" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">如果重载决策不能选择一个函数(例如，它是一个<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/templates#Templated_entity" rel="noopener ugc nofollow" target="_blank">模板实体</a>，带有一个失败的<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/constraints" rel="noopener ugc nofollow" target="_blank">约束</a>，它不能被命名或以其他方式使用。</p></blockquote><p id="baa5" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们看看如何让 SFINAE 具有模板专门化</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="cbe1" class="mr ky iy mn b be ms mt l mu mv">#include &lt;type_traits&gt;<br/>template &lt;typename T, typename Enable = void&gt; //allow SFINAE with template specialization<br/><br/>struct has_active : std::false_type<br/>{<br/>};<br/>struct has_active&lt;T, std::enable_if_t&lt;std::is_same&lt;int, decltype(std::declval&lt;T&gt;().active)&gt;::value&gt;&gt; : std::true_type<br/>{<br/>};</span></pre><p id="dce0" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种方法用于将值 false 和 true 表示为类型。</p><p id="28c4" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这在类型特征中很有用，在类型特征中，根据模板参数满足的某些条件，您可以让类模板继承不同(部分)专门化的<code class="fe mw mx my mn b">std::false_type</code>或<code class="fe mw mx my mn b">std::true_type</code>。</p><p id="ad28" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这样做允许测试给定类型是否满足类型特征的条件，并通过访问静态值成员获得指示结果的编译时常数值，该静态值成员是通过使用转换运算符转换类型特征的实例从<code class="fe mw mx my mn b">std::false_type</code>或<code class="fe mw mx my mn b">std::true_type</code>或替代继承的。在上面的例子中，我们做了以下事情:</p><ul class=""><li id="c2dc" class="mz na iy kb b kc kd kg kh kk nb ko nc ks nd kw ne nf ng nh bi translated">我们继承了两个结构，第一个将在我们的类型没有<code class="fe mw mx my mn b">active</code>成员时使用，第二个将检查我们的类型是否有<code class="fe mw mx my mn b">active</code>成员并且它的类型是 int。</li><li id="86b1" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated"><code class="fe mw mx my mn b">std::is_same&lt;T, U&gt;</code>将检查<code class="fe mw mx my mn b">T</code>和<code class="fe mw mx my mn b">U</code>是否命名相同的类型(考虑 const/volatile 资格)，提供等于 true 的成员常量<code class="fe mw mx my mn b">value</code>。否则，<code class="fe mw mx my mn b">value</code>就是假的。</li><li id="115a" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated"><code class="fe mw mx my mn b">std::enable_if&lt;condition,T&gt;</code>是一种在 C++20 的<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/constraints" rel="noopener ugc nofollow" target="_blank">概念</a>之前利用 SFINAE 的便捷方式(我们将在后面看到概念的用法)，特别是基于类型特征有条件地从<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/overload_resolution" rel="noopener ugc nofollow" target="_blank">候选集</a>中删除函数，允许基于那些不同类型特征的独立函数重载或专门化。<br/> <strong class="kb iz"> std::enable_if </strong>可以以多种形式使用，包括:<br/> -作为附加函数实参(不适用于运算符重载)<br/> -作为返回类型(不适用于构造函数和析构函数)<br/> -作为类模板或函数模板形参</li></ul><p id="ce87" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为<code class="fe mw mx my mn b">enable_if</code>添加专门化的程序的行为是未定义的。<br/> <code class="fe mw mx my mn b">std::enable_if_t</code>是 c++14 的一个特性，它是<em class="ma"> typename enable_if &lt; B，T&gt;:</em>type 的别名；</p><p id="d982" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下一步是实现一个演示函数，它应该适用于这两种类型的结构。</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="570f" class="mr ky iy mn b be ms mt l mu mv">#include &lt;iostream&gt;<br/> <br/>template &lt;typename T&gt;<br/>std::enable_if_t&lt;!has_active&lt;T&gt;::value&gt; printActive(const T &amp;)<br/>{<br/>    std::cout &lt;&lt; "no active\n";<br/>}<br/> <br/>template &lt;typename T&gt;<br/>std::enable_if_t&lt;has_active&lt;T&gt;::value&gt; printActive(const T &amp;t) { std::cout &lt;&lt; "active: " &lt;&lt; t.active &lt;&lt; "\n"; }</span></pre><p id="645e" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们解释一下上面的例子:<br/>第一个重载应该处理没有活动成员的类型，所以编译器会对<code class="fe mw mx my mn b">hasActive</code>求值，从而实例化<code class="fe mw mx my mn b">T</code>。如果<code class="fe mw mx my mn b">T</code>没有活动成员，<code class="fe mw mx my mn b">has_active&lt;T&gt;::value</code>将被评估为假，并且因为我们否定了语句== &gt;，所以该函数将是那些没有活动成员的类型的适当匹配。<br/>同样的事情发生在第二次过载。<br/>现在在主函数中我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="3251" class="mr ky iy mn b be ms mt l mu mv">struct SActive<br/>{<br/>    int active;<br/>};<br/>struct SNoActive<br/>{<br/>};<br/> <br/>int main()<br/>{<br/>    printActive(SActive{42}); // 42<br/>    printActive(SActive{0}); // 0<br/>    printActive(SNoActive{}); // no active<br/>    printActive(int{}); // no active<br/>}</span></pre><p id="3b5f" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将编译并运行。很好不是吗！但不是那种超级好看的表情。有其他选择吗？是的，我们可以使用标签调度、编译时 if 和 C++20 概念！</p><h1 id="6b25" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">标签分发</h1><p id="fe31" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">标签调度使编译器能够根据类型特征选择函数。这个决定发生在编译时，基于特征。是对<code class="fe mw mx my mn b">enable_if</code>的有益补充。<br/>也可以配合拖尾返回式和<code class="fe mw mx my mn b">decltype</code>使用。<br/>当同一个函数有多个重载，并且它们都有何时可以被调用的条件时，这是最有用的。使用 enable_if，您不仅要测试重载条件，还要测试所有其他重载条件的否定，以免您得到重载模糊性。标签分派将有助于减少混乱，因此让我们修改我们的示例:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="f67b" class="mr ky iy mn b be ms mt l mu mv">template&lt;typename T&gt;<br/>void printActive(const T&amp; t, std::true_type)<br/>{<br/>    std::cout &lt;&lt; "active: " &lt;&lt; t.active &lt;&lt; "\n"; <br/>}<br/><br/>template&lt;typename T&gt;<br/>void printActive(const T&amp;,std::false_type)<br/>{<br/>    std::cout &lt;&lt; "no active\n";<br/>}</span></pre><h1 id="ceee" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编译时 if</h1><p id="b1a1" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">从 C++17 开始，我们在语言中有了一个新的特性，允许我们在编译时检查条件，而不需要编写复杂的模板代码。这是一个<code class="fe mw mx my mn b">constexper if</code>。这使它能够有条件地编译源代码，也可以在编译时使用。让我们再次修改我们的示例:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="dc1a" class="mr ky iy mn b be ms mt l mu mv">template&lt;typename T&gt;<br/>void printActive(const T&amp; t)<br/>{<br/> if constexpr (has_active&lt;T&gt;{})<br/> {<br/>   std::cout &lt;&lt; "active: " &lt;&lt; t.active &lt;&lt; "\n";<br/> }<br/> else<br/> {<br/>   std::cout &lt;&lt; "no active\n"; <br/> }<br/> <br/>}</span></pre><h1 id="4ae8" class="kx ky iy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概念</h1><p id="b736" class="pw-post-body-paragraph jz ka iy kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">类模板、函数模板和非模板函数(通常是类模板的成员)可能与一个<em class="ma">约束</em>相关联，该约束指定了对模板参数的要求，模板参数可用于选择最合适的函数重载和模板专门化。</p><p id="a9c1" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些需求的命名集合被称为<em class="ma">概念</em>。每个概念都是一个谓词，在编译时进行计算，并成为模板接口的一部分，在模板中用作约束。</p><p id="d06d" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个特性是从 c++ 20 开始引入的。概念的定义具有以下形式:</p><p id="5231" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mw mx my mn b"><strong class="kb iz">template &lt;</strong></code> <em class="ma">模板-参数-列表</em> <code class="fe mw mx my mn b"><strong class="kb iz">&gt;</strong></code></p><p id="2749" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mw mx my mn b"><strong class="kb iz">concept</strong></code> <em class="ma">概念-名称属性</em>(可选)<code class="fe mw mx my mn b"><strong class="kb iz">=</strong></code> <em class="ma">约束-表达式</em><strong class="kb iz">；。<br/> </strong>再次，让我们修改我们的例子:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="4d95" class="mr ky iy mn b be ms mt l mu mv">template&lt;typename T&gt;<br/>concept HasActive = std::is_same&lt;int, decltype(std::declval&lt;T&gt;().active)&gt;::value;<br/><br/>template&lt;typename T&gt;<br/>concept NoActive = not HasActive&lt;T&gt;;<br/><br/><br/>template&lt;HasActive T&gt;<br/>void f(const T&amp; t)<br/>{<br/>    std::cout &lt;&lt; "active: " &lt;&lt; t.active &lt;&lt; "\n"; <br/>}<br/><br/>template&lt;NoActive T&gt;<br/>void f(const T&amp;)<br/>{<br/>    std::cout &lt;&lt; "no active\n";   <br/>}<br/><br/>struct s_active<br/>{<br/>    int active;<br/>};<br/>struct s_no_active<br/>{<br/>};<br/><br/>int main()<br/>{<br/>    f(s_active{42}); // active: 42<br/>    f(s_active{0}); // active: 0<br/>    f(s_no_active{}); // no active<br/>}</span></pre><blockquote class="mc md me"><p id="abeb" class="jz ka ma kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated"><strong class="kb iz"> <em class="iy">记住:</em> </strong> <em class="iy"> <br/> SFINAE </em>发生在</p></blockquote><ul class=""><li id="67fb" class="mz na iy kb b kc kd kg kh kk nb ko nc ks nd kw ne nf ng nh bi translated">函数类型中使用的所有类型(包括返回类型和所有参数的类型)</li><li id="7513" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated">模板参数声明中使用的所有类型</li><li id="5612" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated">函数类型中使用的所有表达式</li><li id="b7ec" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated">模板参数声明中使用的所有表达式(从 C++11 开始)</li><li id="9bfb" class="mz na iy kb b kc ni kg nj kk nk ko nl ks nm kw ne nf ng nh bi translated">在<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/explicit" rel="noopener ugc nofollow" target="_blank">显式说明符</a>中使用的所有表达式(从 C++20 开始)</li></ul><p id="a1d0" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您还可以看到<a class="ae mb" href="https://github.com/Pharap/CppExplanations/blob/master/SFINAE.md#which-errors-are-substitution-errors" rel="noopener ugc nofollow" target="_blank">哪些错误是替换错误</a>。</p><p id="f3ff" class="pw-post-body-paragraph jz ka iy kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我列出了一些关于 SFINAE 的信息。有了这种技术和类型特征，我们就可以创建专门的函数来处理类型的子集，并始终保持学习。</p></div></div>    
</body>
</html>