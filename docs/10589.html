<html>
<head>
<title>Spark Architecture 101 | Concepts &amp; Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark 架构 101 |概念和应用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spark-architecture-101-concepts-application-f5260783ac9d?source=collection_archive---------2-----------------------#2022-11-14">https://blog.devgenius.io/spark-architecture-101-concepts-application-f5260783ac9d?source=collection_archive---------2-----------------------#2022-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a0fd2f3c1f41213a4a35651f1fa2af42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ujD9drLEQp9gJ-LR.png"/></div></div></figure><p id="42f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated"><span class="l ku kv kw bm kx ky kz la lb di">在</span>这篇博文中，我们将了解 Apache spark 的架构。本文将帮助您全面理解 apache spark 是如何工作的。我们将涵盖所有关于 spark 架构的基本主题。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="0ac1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">本博客涵盖的主题:</h1><ol class=""><li id="f1cd" class="mh mi in jx b jy mj kc mk kg ml kk mm ko mn ks mo mp mq mr bi translated">火花介绍</li><li id="d98a" class="mh mi in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">火花部件</li><li id="6368" class="mh mi in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">阶段</li><li id="bd5d" class="mh mi in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">洗牌</li><li id="78ea" class="mh mi in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">Spark 生命周期。</li></ol></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="3792" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">火花介绍:</h1><p id="3c75" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">Spark 是跨集群并行处理的统一计算引擎。可以把 spark 想象成一种类似 python 或 java 的编程语言，它允许我们在不同的 CPU 之间划分进程。也就是说，Spark 支持多种广泛使用的编程语言(Python、Java、Scala 和 R)，包括从 SQL 到流和机器学习等各种任务的库，可以在从笔记本电脑到数千个服务器的集群的任何地方运行。</p><p id="22d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">类比:</strong>为了更好地理解 Spark 架构的细节，我们将使用一个类比。假设你经营一家餐馆，有一袋子苹果，你的任务是把它们切成小块。假设袋子里有 10 个苹果，一个人可以在 10 分钟内切开袋子里的苹果。如果有 100 个这样的袋子，切完所有的苹果需要 1000 分钟(16.6 小时)。因此，我们需要将这项工作分配给更多的人，让他们平行地切苹果，这样你就可以准备美味的沙拉了。这正是 spark 所做的。</p><h1 id="1fad" class="lj lk in bd ll lm na lo lp lq nb ls lt lu nc lw lx ly nd ma mb mc ne me mf mg bi translated"><strong class="ak">火花元件:</strong></h1><p id="eee4" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">理解了类比之后，让我们用同样的想法来理解 spark 组件。</p><p id="91e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">司机:将司机视为餐厅的主厨/经理，他将工作分配给其他厨师。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7ec40f9ac906bf60cfc5991a9148551d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*3I6ib_cBbBlifGtCxqdAkw.png"/></div></figure><p id="3c40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 spark 中，驱动程序负责将<strong class="jx io">任务</strong>分配给<strong class="jx io"> </strong>执行器。从数据工程师的角度来看，如果我们想要过滤一个包含 1000 行的表，这些行将被<strong class="jx io">驱动程序划分并分布在执行器上。</strong>注意，不允许驾驶员查看数据。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f49492d185d6c274937fe90e0fba9f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*OFD9zrBljyRYdxTp"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">驱动程序和执行器架构(来源:<a class="ae no" href="https://datacadamia.com/db/spark/cluster/core" rel="noopener ugc nofollow" target="_blank">数据学院</a></figcaption></figure><p id="1b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">执行者</strong>:把执行者看成是厨师执行任务(切苹果)的工作站/案板。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/d3e1c80fc4b917d168ab153cfe2b8e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZ89uYWXORYq10PHpKFX_g.png"/></div></div></figure><p id="1a50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 spark 中，执行器是执行任务的 Java 虚拟机。执行者负责运行单个任务，并将结果发送给驱动程序。</p><p id="6eae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">槽/核:</strong>槽或核是指执行切苹果任务的厨师。执行器由核心/插槽组成。一个执行器(工作站)可以由一个或多个核心/插槽组成。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d1c2a1eb1599f954491efaaea7d58fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*3pdKefyydJ7lnYMLKaN2DQ.png"/></div></figure><p id="fb62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 spark 中，核心/插槽是执行实际任务的 CPU。存在的核心总数负责并行执行更多的任务。</p><p id="f187" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">作业、任务、数据集、分区:</strong></p><p id="7b92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">数据集</strong>是篮子里苹果的集合。</p><p id="abeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">分区</strong>是将数据集分割成更小部分的过程。分区是由驱动程序完成的。</p><p id="7b9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">任务</strong>通常是需要处理的分区总数，例如，如果我们有 4 个篮子，每个篮子中有 3 个苹果，那么我们有 12 个苹果(数据集)要切。这被驱动程序分成 12 个分区，因此总共需要执行 12 个任务。每个任务由每个内核执行。因此，如果我们有 3 个执行器，每个执行器有 2 个内核，那么我们总共有 6 个内核，因此最多只能有 6 个任务可以并行执行。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/1d2ec721ac44f9a4a0a2b953ae8f185e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pnjy6CoDbl-9cBpLSSEBHw.png"/></div></div></figure><p id="f560" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">作业</strong>是驾驶员接受的总体指令。在这种情况下，我们需要切 4 篮苹果，每篮 3 个。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/1eb47de0d82712b4585b7202e13f9496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOSAYVR5Ng3CqizcB1gbAw@2x.png"/></div></div></figure><h1 id="29dc" class="lj lk in bd ll lm na lo lp lq nb ls lt lu nc lw lx ly nd ma mb mc ne me mf mg bi translated">阶段:</h1><p id="ad7e" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">Spark 中的阶段表示可以在多台机器上一起执行以计算相同操作的任务组。我们已经知道不允许驱动程序查看数据集，那么您是否想知道驱动程序如何知道数据集或我们示例中的苹果的总行数？Spark 通过在执行者之间分发数据集并向他们询问计数来解决这个问题。让我们通过两个阶段来了解整个过程。</p><p id="8a01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阶段 1: </strong>在这个阶段中，驱动程序对数据集进行划分，并将它们分配给一组执行器。驱动程序现在要求执行器计算数据集中的行数。在这个阶段，执行者的工作是找出每个篮子里苹果的数量。现在，计数存储在磁盘上的每个执行器中，以供稍后阶段使用，这也称为<strong class="jx io">混洗数据</strong>。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/80af526d5b814eb61a2341bd06652f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPIllYDr2pyw8gpadKQL0g.png"/></div></div></figure><p id="def6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二阶段:</strong>即使是现在每个执行者也不能直接把结果给司机，让它算总数。因此，将来自每个执行者的苹果计数相加的过程是由另一个执行者执行的，最后将总数交给驱动程序。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/05848019ccc2cf04f7c55ebe67e578f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nrUWxonMQBi7yqzTkUnZIw.png"/></div></div></figure><p id="2c3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于一个执行者需要从所有其他执行者那里收集信息，这些操作被称为<strong class="jx io">宽转换。转换</strong>是 spark 给出的指令，用于从现有数据帧产生新的数据帧。</p><p id="594d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当执行者之间有数据交换时，我们就有一个宽转换，如果没有数据交换，那么它被称为<strong class="jx io">窄转换。</strong>更多改造细节可以在这里<a class="ae no" href="https://sparkbyexamples.com/apache-spark-rdd/spark-rdd-transformations/" rel="noopener ugc nofollow" target="_blank">找到。</a></p><p id="3b60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在这两个阶段完成后，我们现在总共有 12 个苹果。现在司机完全知道如何在其他厨师中分配这些苹果。现在让我们把我们的理解转化为阶段。</p><p id="479d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一阶段:</strong>将篮子分给执行者<br/> <strong class="jx io">第二阶段:</strong>统计总数并将结果交给执行者<br/> <strong class="jx io">第三阶段:</strong>司机将苹果分给执行者，执行者将苹果切成片。<br/> <strong class="jx io">阶段 4: </strong>指派一个执行者从其他执行者那里收集所有的碎片，并将结果交付给驱动程序。</p><h1 id="0402" class="lj lk in bd ll lm na lo lp lq nb ls lt lu nc lw lx ly nd ma mb mc ne me mf mg bi translated">洗牌:</h1><p id="b960" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">洗牌是指在不同阶段之间重新排列群集中的数据的过程。为了更好地理解 shuffle，我们将举一个例子，现在我们的任务是计算篮子中不同的()水果类型。和以前一样，现在这个任务分两个阶段完成。</p><p id="abd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阶段 1: </strong>篮子分发给遗嘱执行人。现在每个执行者都在数篮子里不同的水果。这些数据现在存储在每个执行器的磁盘中。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/eca1a630efea1f557abb707baf05aa9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGiRKYctK6Zl8lIlVtt2oA.png"/></div></div></figure><p id="e0ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阶段 2: </strong>现在，每个执行程序读取存储在另一个执行程序中的数据，以找到所有不同的结果。这个在执行者之间共享数据的过程被称为<strong class="jx io">洗牌</strong>。就架构而言，洗牌是一个昂贵的过程。因此，最好尽可能减少宽转换的数量。大多数情况下，spark 自己完成，这个过程被称为<strong class="jx io">流水线</strong>。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/03d7d70e9e00b0b8fba881f907ba8617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1yYQLZWZ1m2ZEuEwZMNZQ.png"/></div></div></figure><h1 id="ba2f" class="lj lk in bd ll lm na lo lp lq nb ls lt lu nc lw lx ly nd ma mb mc ne me mf mg bi translated">Spark 生命周期:</h1><p id="f704" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">现在我们已经了解了 Spark 的重要概念，让我们了解一下它的整个生命周期。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/afde587281ce3d826aa7b549a74dc53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*EzZs4uEuO30lV51KV07_RA.png"/></div></figure><p id="95b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">集群管理器</strong>负责维护驱动程序和执行器。目前，有三个可用的集群管理器独立集群管理器，Apache Mesos 和 Hadoop YARN。</p><p id="1a1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步:</strong>用户将提交一个 spark 应用程序。这里，我们请求集群管理器接受我们的请求，并为我们的应用程序分配资源。你可以在这里找到更多关于如何编写 spark-submit 应用程序的例子<a class="ae no" href="https://sparkbyexamples.com/spark/spark-submit-command/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="774d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">步骤 2: 现在你的应用程序应该创建一个<strong class="jx io"> SparkSession </strong>。这将初始化集群中的驱动程序和执行器。SparkSession 随后将与集群管理器通信，请求它在集群中启动 Spark executor 进程。执行器的数量及其相关配置由用户通过最初的<strong class="jx io"> spark-submit </strong>调用中的命令行参数来设置。</p><p id="a171" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 3: </strong>现在代码的实际执行开始了。让我们通过在数据帧上运行一个简单的计数操作来理解它。</p><p id="cadd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建数据帧:</p><pre class="ng nh ni nj gt ny nz oa bn ob oc bi"><span id="ac80" class="od lk in nz b be oe of l og oh">orders_df=spark.read.csv('dbfs:/FileStore/tables/Data/orders/part_00000',schema="""order_id INT,order_date DATE,order_customer_id INT,order_status STRING""")</span></pre><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/7cc4dae7c07523cab1df1a5c44e9e825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpPVYCfRtzn8jkZnFfHFaA.png"/></div></div></figure><p id="57a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里计数操作分两个阶段完成。</p><p id="3138" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阶段 1: </strong>本地统计记录数量。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f68175cb9846d8dfe451edd0315d5896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3NO684kiTXduBcq5N8ubgA.png"/></div></figure><p id="9291" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阶段 2: </strong>洗牌阶段，洗牌发生。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ed126fa3f9ff6c04c0405b954af2b165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*dsbipdi9vTERoMGzZn82cw.png"/></div></figure><blockquote class="ol om on"><p id="042e" class="jv jw oo jx b jy jz ka kb kc kd ke kf op kh ki kj oq kl km kn or kp kq kr ks ig bi translated">这个执行计划是一个转换的有向无环图(DAG ),每个转换产生一个新的不可变数据帧，我们在其上调用一个动作来产生一个结果。</p></blockquote><h1 id="df98" class="lj lk in bd ll lm na lo lp lq nb ls lt lu nc lw lx ly nd ma mb mc ne me mf mg bi translated"><strong class="ak">结论:</strong></h1><p id="5fc0" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">我希望在阅读完这篇文章后，您会对 apache spark 的工作原理以及我们运行 spark 应用程序时会发生什么有一个基本的了解。在<a class="ae no" href="https://medium.com/@sidharth.ramalingam" rel="noopener"> medium </a>上关注我，了解更多关于 spark 和数据工程的东西。如有任何问题，请随时通过 LinkedIn 与我联系。</p></div></div>    
</body>
</html>