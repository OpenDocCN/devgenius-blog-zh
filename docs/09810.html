<html>
<head>
<title>Basic ETL using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandas 的基本 ETL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/basic-etl-using-pandas-23729ae4e05e?source=collection_archive---------0-----------------------#2022-09-15">https://blog.devgenius.io/basic-etl-using-pandas-23729ae4e05e?source=collection_archive---------0-----------------------#2022-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f779" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们将使用 Pandas 来执行 ETL 操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/debce2938e9ac8f2f912e7fcb7610980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*4APuAzNdPHM13EDzxDZ6Ag.png"/></div></figure><p id="adf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用两种类型的源，MySQL 作为数据库，CSV 文件作为文件系统。<br/>我们把代码分成三大部分:<br/> 1。摘录<br/> 2。变换<br/> 3。加载。</p><blockquote class="kq kr ks"><p id="f2f9" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><em class="in">我们总共有 3 个数据源——两个表 CITY，COUNTRY 和一个 csv 文件 COUNTRY_LANGUAGE.csv </em></p></blockquote><p id="6b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将创建 4 个 python 文件。</p><p id="67d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kt"> job.py </em> </strong> —逐步执行 ETL 操作(提取转换和加载)<br/><strong class="jm io"><em class="kt">constant . py</em></strong>—存储所有的常量细节，如列、数据库连接和与连接相关的列。<br/><strong class="jm io"><em class="kt">Extract . py</em></strong>—通过创建 dataframe 提取源数据。<br/><strong class="jm io"><em class="kt">transform . py</em></strong>—所有的转换逻辑都在这里。我们将使用提取的数据帧来完成所有的转换。<br/><strong class="jm io"><em class="kt">load . py</em></strong>—将清理后的数据存储到数据库或文件系统中。</p><p id="163e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将提取所有数据并创建一个熊猫数据帧，然后我们将在这些数据帧上应用转换。</p><p id="70dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先在<strong class="jm io"> <em class="kt"> constant.py </em> </strong>下创建函数<strong class="jm io"> <em class="kt"> connection() </em> </strong>进行数据库连接。每当我们需要一个数据库连接时，我们可以调用<strong class="jm io"> <em class="kt"> connection() </em> </strong>函数。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="55f1" class="lc ld in ky b be le lf l lg lh">from sqlalchemy import create_engine<br/><br/># Database connection details --Note: Dont do like this in production code<br/>def connection():<br/>    mydb = create_engine("mysql://root:root@localhost/world")<br/>    return mydb</span></pre><p id="c5d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将使用 extract.py 文件提取源数据，在该文件中我们创建了 extract 函数。在此之下，我们将为不同的数据源创建数据框架。</p><p id="98cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从不同的源读取数据，以确定我们使用的是哪个源，我们必须创建一个<strong class="jm io"> <em class="kt">类型</em> </strong>参数来标识源，即数据库或文件系统，并基于此创建数据帧。MySQL 的“<strong class="jm io"> db </strong>”和文件系统的“<strong class="jm io"> csv </strong>”。</p><blockquote class="kq kr ks"><p id="5e73" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">注意:如果无法导入其他 py 文件，请使用以下方法。<br/> </em> </strong> <em class="in">假设说我在</em> <strong class="jm io"> <em class="in">下有</em><strong class="jm io"><em class="in">constant . py</em></strong><em class="in">文件 ETL _ pandas \ metadata</em></strong><em class="in">但是无法使用</em> <strong class="jm io"> <em class="in">从 etl_pandas.metadata.constant 导入连接</em> </strong></p><p id="061e" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">你可以用下面的方法来实现同样的</em> </strong></p><p id="4f26" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><em class="in">从常量导入连接</em>导入 sys <br/> sys.path.insert(1，' etl_pandas\metadata') <br/></p></blockquote><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="3a25" class="lc ld in ky b be le lf l lg lh">#extract.py<br/><br/>import sys<br/><br/># If you are not able to import constant py file use below code<br/>sys.path.insert(1, 'etl_pandas\metadata')<br/><br/>from constant import connection<br/>import pandas as pd<br/><br/>def extract(type: str, source: str):<br/>    # Read data from mysql database<br/>    if type=="db":<br/>       output_df = pd.read_sql(f'SELECT * FROM {source}', con=connection())<br/>    if type=="csv":<br/>    # read data from filesystem<br/>       output_df = pd.read_csv(source)<br/>    return output_df</span></pre><p id="fe40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是创建的数据框架的模式和列。</p><p id="80c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">城市</strong> <br/>城市 _id : int64 <br/>城市 _ 名称:对象<br/>国家 _ 代码:对象<br/>城市 _ 地区:对象<br/>城市 _ 人口:int64</p><p id="9bbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">国家</strong> <br/>国家 _ 代码:对象<br/>国家 _ 名称:对象<br/>大陆:对象<br/>地区:对象<br/>表面 _ 面积:浮动 64 <br/>独立 _ 年份:浮动 64 <br/>国家 _ 人口:int64 <br/>预期寿命:浮动 64 <br/>国民生产总值:浮动 64 <br/>旧 _ 国民生产总值:浮动 64 <br/>地方 _ 名称:对象<br/>政府 _ 形式</p><p id="0899" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">国家 _ 语言</strong> <br/>国家 _ 代码:对象<br/>语言:对象<br/>is _ 官方 _ 语言:对象<br/>语言 _ 百分比:浮动 64</p><p id="bb2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们必须转换这些数据，在此之前我们需要列细节，来声明那些我们使用的<strong class="jm io"> <em class="kt"> constant.py </em> </strong>文件。</p><p id="0efb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在转换中，我们将重命名列，我们必须映射旧列名和新列名，为此，我们将使用字典，因为它具有键-值对，我们将使用键作为旧列名，使用值作为新列名。下面我们已经声明了基于所有三个来源的所有新旧列。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="f239" class="lc ld in ky b be le lf l lg lh"># constant.py<br/><br/>CITY_COL_DICT={<br/>     "ID": "city_id",<br/>     "Name": "city_name",<br/>     "CountryCode": "country_code",<br/>     "District": "city_district",<br/>     "Population": "city_population"<br/>}<br/>COUNTRY_COL_DICT={<br/>     "Code": "country_code",<br/>     "Name": "country_name",<br/>     "Continent": "continent",<br/>     "Region": "region",<br/>     "SurfaceArea": "surface_area",<br/>     "IndepYear": "independence_year",<br/>     "Population": "country_population",<br/>     "LifeExpectancy": "life_expectancy",<br/>     "GNP": "gross_national_product",<br/>     "GNPOld": "old_gross_national_product",<br/>     "LocalName": "local_name",<br/>     "GovernmentForm": "government_form",<br/>     "HeadOfState": "head_of_state",<br/>     "Capital": "capital",<br/>     "Code2": "country_code_2"<br/>}<br/>COUNTRY_LANGUAGE_COL_DICT={<br/>     "CountryCode": "country_code",<br/>     "Language": "language",<br/>     "IsOfficial": "is_official_language",<br/>     "Percentage": "language_percentage"<br/>}</span></pre><p id="a531" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的,“country_code”在所有数据帧中都很常见，我们将使用该列进行连接操作，之后，我们将只选择必需的列，而不是所有列。所以我们也声明一下。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="e95f" class="lc ld in ky b be le lf l lg lh"># constant.py<br/><br/>JOIN_ON_COLUMNS=['country_code']<br/>JOIN_TYPE="left"<br/>SPEC_COLS=[<br/>     "country_code",<br/>     "country_name",<br/>     "region",<br/>     "surface_area",<br/>     "independence_year",<br/>     "country_population",<br/>     "life_expectancy",<br/>     "local_name",<br/>     "head_of_state",<br/>     "capital",<br/>     "country_code_2",<br/>     "city_id",<br/>     "city_name",<br/>     "city_district",<br/>     "city_population",<br/>     "language",<br/>     "is_official_language",<br/>     "language_percentage"<br/>]</span></pre><p id="88c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面我们在 transform.py 中添加转换逻辑，如下图。</p><ol class=""><li id="7444" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">rename _ cols 重命名所有列。</li><li id="d80e" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">specific_cols —仅提取所需的列。</li><li id="7ab9" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">join _ df 基于“国家代码”连接数据框架</li></ol><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="1f01" class="lc ld in ky b be le lf l lg lh"># transform.py<br/><br/>from pandas import DataFrame<br/><br/><br/>def rename_cols(df: DataFrame, mapping_dict: dict) -&gt;DataFrame:<br/>    # Rename all the columns<br/>    '''<br/>    :param df: input dataframe<br/>    :param mapping_dict: dict of columns names<br/>    :return: ouput dataframe<br/>    '''<br/><br/>    df.rename(columns=mapping_dict,inplace=True)<br/>    return df<br/><br/><br/><br/>def specific_cols(df: DataFrame, specific_cols: list):<br/>    # get specific cols df<br/>    '''<br/>    :param df: input dataframe<br/>    :param specific_cols: list of columns names<br/>    :return: ouput dataframe<br/>    '''<br/>    return df[specific_cols]<br/><br/><br/><br/>def join_df(left_df: DataFrame, right_df: DataFrame, ON_COLUMNS:list, JOIN_TYPE: str)-&gt;DataFrame:<br/>    # Join two dataframes<br/>    '''<br/>    :param left_df: input dataframe<br/>    :param right_df: input dataframe<br/>    :param ON_COLUMNS: list of columns to perform join<br/>    :param JOIN_TYPE: Join type<br/>    :return: ouput dataframe<br/>    '''<br/>    output_df=left_df.merge(right_df, on=ON_COLUMNS, how=JOIN_TYPE)<br/>    return output_df</span></pre><p id="8aa3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们创建 load.py 文件，并编写代码将清理后的数据存储到 MySQL 和文件系统中。</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="4bf7" class="lc ld in ky b be le lf l lg lh"># load.py<br/><br/>from pandas import DataFrame<br/>import pandas as pd<br/>import sys<br/><br/># If you are not able to import constant py file use below code<br/>sys.path.insert(1, 'etl_pandas\metadata')<br/>from constant import connection<br/><br/><br/><br/>def load(type: str, df: DataFrame, target: str):<br/>    # Load the data based on type<br/>    '''<br/>    :param type: Input Storage type (db|csv) Based on type data stored in MySQL or FileSystem<br/>    :param df: Input Dataframe<br/>    :param target: Input target -For filesystem - Location where to store the data           <br/>                                -For MySQL - table name<br/>    '''<br/><br/>    # Write data on mysql database with table name<br/>    if type=="db":<br/>       df.to_sql(target, con=connection(), if_exists='replace', index=False)<br/>       print("Data succesfully loaded to MySQL Database !!")<br/><br/>     if type=="csv":<br/>     # Write data on filesystem<br/>        df.to_csv(target, index=False)<br/>        print("Data succesfully loaded to filesystem !!")</span></pre><p id="edac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在 ETL 步骤中执行代码，我们将使用<strong class="jm io"> <em class="kt"> job.py </em> </strong>文件执行所有函数。我们将把所有的模块(extract.py，transform.py，load.py)和常量变量(constant.py)导入到 job.py 中</p><pre class="kj kk kl km gt kx ky kz bn la lb bi"><span id="535c" class="lc ld in ky b be le lf l lg lh"># job.py<br/><br/># Imported required libraries and modules<br/>import sys<br/>import pandas as pd<br/><br/># If you are not able to import constant py file use below code<br/>sys.path.insert(1, 'etl_pandas\metadata')<br/>from constant import connection, CITY_COL_DICT, COUNTRY_LANGUAGE_COL_DICT, COUNTRY_COL_DICT, \<br/>JOIN_TYPE,JOIN_ON_COLUMNS, SPEC_COLS<br/>from extract import extract<br/>from transform import rename_cols, join_df, specific_cols<br/>from load import load<br/><br/><br/>#### ----- Extract ----- ####<br/><br/># Extracting CITY and COUNTRY data from MYSQL<br/>city_df = extract("db","city")<br/>country_df = extract("db","country")<br/><br/># Extracting COUNTRYLANGUAGE data from FileSystem<br/>country_language_df = extract("csv","etl_pandas\data\countrylanguage.csv")<br/><br/>print(city_df.dtypes)<br/>print(country_df.dtypes)<br/>print(country_language_df.dtypes)<br/><br/><br/>#### ----- Transformation ----- ####<br/><br/># 1. Rename Columns<br/>city_df = rename_cols(city_df, CITY_COL_DICT)<br/>country_df = rename_cols(country_df, COUNTRY_COL_DICT)<br/>country_language_df = rename_cols(country_language_df, COUNTRY_LANGUAGE_COL_DICT)<br/><br/># 2. Join DF with common column "country_code"<br/>country_city_df=join_df(country_df, city_df, JOIN_ON_COLUMNS, JOIN_TYPE)<br/>country_city_language_df= join_df(country_city_df, country_language_df, JOIN_ON_COLUMNS, JOIN_TYPE)<br/><br/># 3. Get specific cols<br/>country_city_language_df = specific_cols(country_city_language_df, SPEC_COLS)<br/><br/><br/>#### ----- Load Data ----- ####<br/><br/># MySQL<br/>load("db",country_city_language_df, "countrycitylanguage")<br/><br/># FileSystem<br/>load("csv",country_city_language_df, "etl_pandas/output/countrycitylanguage.csv")</span></pre><p id="7304" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您的数据将作为 CSV 文件存储在 MySQL 数据库和文件系统中。</p><p id="e6ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码库:-<a class="ae lw" href="https://github.com/rohitrsp898/Basic_ETL_using_pandas" rel="noopener ugc nofollow" target="_blank">https://github.com/rohitrsp898/Basic_ETL_using_pandas</a></p><p id="bdf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以使用 PySpark 来检查基本 ETL。</p><p id="3d5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>