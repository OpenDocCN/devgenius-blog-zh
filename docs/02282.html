<html>
<head>
<title>Applying Curiously Recurring Template Pattern in Day-To-Day C++ Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在日常 C++编码中应用奇怪的重复模板模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/applying-curiously-recurring-template-pattern-in-day-to-day-c-coding-4e4136dbc10c?source=collection_archive---------14-----------------------#2020-07-26">https://blog.devgenius.io/applying-curiously-recurring-template-pattern-in-day-to-day-c-coding-4e4136dbc10c?source=collection_archive---------14-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1c65fa5f14b693a51e6724763769a014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZ0SitM4T8Kas1D_b0PTJg.png"/></div></div></figure><p id="a926" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">奇怪的是，C++中重复出现的模板模式(CRTP)绝对是一种强大的技术&amp;虚函数的静态替代。但与此同时，一开始学习它可能会显得有点怪异。如果你和我一样挣扎着想要一口气抓住任何东西。那么这篇文章可能会帮助你提供一个思考过程，让你知道 CRTP 在日常编码中的位置。而且，如果你是一名嵌入式程序员，你可能会更经常地遇到 CRTP。虽然，<code class="fe kw kx ky kz b">std::variant</code> + <code class="fe kw kx ky kz b">std::visit</code>也会有所帮助，但是 90%的嵌入式处理器编译器要么不是最新的标准，要么是哑的。</p><blockquote class="la lb lc"><p id="122a" class="jy jz ld ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq"> /！\:这篇文章最初发表在我的博客上。如果你有兴趣接收我的最新文章，</em> <a class="ae lh" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请注册我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="9135" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 CRTP 有各种各样关于“如何做”和“做什么”的材料。因此，我不会把重点放在 CRTP 适用性的“在哪里”部分。</p><h1 id="f94e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++中的 CRTP 和静态多态</h1><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="0282" class="mo lj iq kz b gy mp mq l mr ms">template&lt;typename specific_animal&gt;<br/>struct animal {<br/>    void who() { static_cast&lt;specific_animal*&gt;(this)-&gt;who(); }<br/>};</span><span id="f466" class="mo lj iq kz b gy mt mq l mr ms">struct dog : animal&lt;dog&gt; {<br/>    void who() { cout &lt;&lt; "dog" &lt;&lt; endl; }<br/>};</span><span id="52e1" class="mo lj iq kz b gy mt mq l mr ms">struct cat : animal&lt;cat&gt; {<br/>    void who() { cout &lt;&lt; "cat" &lt;&lt; endl; }<br/>};</span><span id="08ca" class="mo lj iq kz b gy mt mq l mr ms">template&lt;typename specific_animal&gt;<br/>void who_am_i(animal&lt;specific_animal&gt; &amp;animal) {<br/>    animal.who();<br/>}</span><span id="d0ca" class="mo lj iq kz b gy mt mq l mr ms">cat c;<br/>who_am_i(c); // prints `cat`</span><span id="216c" class="mo lj iq kz b gy mt mq l mr ms">dog d;<br/>who_am_i(d); // prints `dog`</span></pre><ul class=""><li id="8895" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated"><strong class="ka ir"> <em class="ld">奇怪的是，重复出现的模板模式被广泛用于静态多态</em> </strong>而不承担虚拟调度机制的成本。考虑到上面的代码，我们没有使用虚拟关键字&amp;仍然实现了多态性的功能。</li><li id="7136" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">它是如何工作的不是本文的主题。所以，我让你来想办法。</li></ul><h1 id="6348" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用 CRTP 限制对象计数</h1><ul class=""><li id="ca5b" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated">有时，您必须使用单个或预定义的对象计数来管理关键资源。对此我们有<a class="ae lh" href="http://www.vishalchovatiya.com/singleton-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">单例&amp;单调设计模式</a>。但是，只要对象数量较少，这种方法就有效。</li><li id="c687" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><strong class="ka ir"> <em class="ld">当你想用任意数量的实例来限制任意类型时</em> </strong>。CRTP 会来救援的:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="b58c" class="mo lj iq kz b gy mp mq l mr ms">template &lt;class ToBeLimited, uint32_t maxInstance&gt;<br/>struct LimitNoOfInstances {<br/>    static atomic&lt;uint32_t&gt; cnt;</span><span id="a963" class="mo lj iq kz b gy mt mq l mr ms">    LimitNoOfInstances() {<br/>        if (cnt &gt;= maxInstance)<br/>            throw logic_error{"Too Many Instances"};<br/>        ++cnt;<br/>    }<br/>    ~LimitNoOfInstances() { --cnt; }<br/>}; // Copy, move &amp; other sanity checks to be complete</span><span id="ffb0" class="mo lj iq kz b gy mt mq l mr ms">struct One : LimitNoOfInstances&lt;One, 1&gt; {};<br/>struct Two : LimitNoOfInstances&lt;Two, 2&gt; {};</span><span id="333b" class="mo lj iq kz b gy mt mq l mr ms">template &lt;class T, uint32_t maxNoOfInstace&gt;<br/>atomic&lt;uint32_t&gt; LimitNoOfInstances&lt;T, maxNoOfInstace&gt;::cnt(0);<br/></span><span id="c6db" class="mo lj iq kz b gy mt mq l mr ms">void use_case() {<br/>    Two _2_0, _2_1;</span><span id="f180" class="mo lj iq kz b gy mt mq l mr ms">    try {<br/>        One _1_0, _1_1;<br/>    } catch (exception &amp;e) {<br/>        cout &lt;&lt; e.what() &lt;&lt; endl;<br/>    }<br/>}</span></pre><ul class=""><li id="9868" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">你可能想知道，如果模板参数<code class="fe kw kx ky kz b">ToBeLimited</code>没有被使用，它有什么意义。在这种情况下，你应该温习一下你的<a class="ae lh" href="http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/" rel="noopener ugc nofollow" target="_blank"> C++模板</a>基础或者使用<a class="ae lh" href="https://cppinsights.io/" rel="noopener ugc nofollow" target="_blank"> cppinsights.io </a>。因为它不是没用的。</li></ul><h1 id="fdb5" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">CRTP 避免代码重复</h1><ul class=""><li id="030b" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated">假设您有一组支持函数<code class="fe kw kx ky kz b">begin()</code> &amp; <code class="fe kw kx ky kz b">end()</code>的容器。但是，标准库对容器的要求需要更多的功能，如<code class="fe kw kx ky kz b">front()</code>、<code class="fe kw kx ky kz b">back()</code>、<code class="fe kw kx ky kz b">size()</code>等。</li><li id="0743" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">我们可以用一个<strong class="ka ir"> <em class="ld"> CRTP 基类来设计这样的功能，该基类仅基于派生类成员函数</em> </strong>来提供公共实用程序，即在我们的例子中的<code class="fe kw kx ky kz b">begin()</code> &amp; <code class="fe kw kx ky kz b">end()</code>:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="455c" class="mo lj iq kz b gy mp mq l mr ms">template &lt;typename T&gt;<br/>class Container {<br/>    T &amp;actual() { return *static_cast&lt;T *&gt;(this); }<br/>    T const &amp;actual() const { return *static_cast&lt;T const *&gt;(this); }</span><span id="7ce3" class="mo lj iq kz b gy mt mq l mr ms">public:<br/>    decltype(auto) front() { return *actual().begin(); }<br/>    decltype(auto) back() { return *std::prev(actual().end()); }<br/>    decltype(auto) size() const { return std::distance(actual().begin(), actual().end()); }<br/>    decltype(auto) operator[](size_t i) { return *std::next(actual().begin(), i); }<br/>};</span></pre><ul class=""><li id="a112" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">上面的类为任何有<code class="fe kw kx ky kz b">begin()</code> &amp; <code class="fe kw kx ky kz b">end()</code>的子类提供了<code class="fe kw kx ky kz b">front()</code>、<code class="fe kw kx ky kz b">back()</code>、<code class="fe kw kx ky kz b">size()</code>和<code class="fe kw kx ky kz b">operator[ ]</code>的函数。</li><li id="f768" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">例如，子类可以是一个简单的动态分配数组，如下所示:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="71e1" class="mo lj iq kz b gy mp mq l mr ms">template &lt;typename T&gt;<br/>class DynArray : public Container&lt;DynArray&lt;T&gt;&gt; {<br/>    size_t m_size;<br/>    unique_ptr&lt;T[]&gt; m_data;</span><span id="3b3f" class="mo lj iq kz b gy mt mq l mr ms">  public:<br/>    DynArray(size_t s) : m_size{s}, m_data{make_unique&lt;T[]&gt;(s)} {}</span><span id="0893" class="mo lj iq kz b gy mt mq l mr ms">    T *begin() { return m_data.get(); }<br/>    const T *begin() const { return m_data.get(); }</span><span id="0092" class="mo lj iq kz b gy mt mq l mr ms">    T *end() { return m_data.get() + m_size; }<br/>    const T *end() const { return m_data.get() + m_size; }<br/>};</span><span id="7a91" class="mo lj iq kz b gy mt mq l mr ms">DynArray&lt;int&gt; arr(10);<br/>arr.front() = 2;<br/>arr[2]        = 5;<br/>asssert(arr.size() == 10);</span></pre><h1 id="d7cd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">利用 CRTP 的现代 C++复合设计模式</h1><ul class=""><li id="0856" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated"><a class="ae lh" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">复合设计模式</a>声明我们应该<strong class="ka ir"> <em class="ld">像对待单个对象</em> </strong>一样对待一组对象。为了实现这种模式，我们可以利用 CRTP。</li><li id="1f52" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">例如，作为机器学习的一部分，我们必须处理<code class="fe kw kx ky kz b">Neuron</code>，为简单起见，它定义为:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="433e" class="mo lj iq kz b gy mp mq l mr ms">struct Neuron {<br/>    vector&lt;Neuron*&gt;     in, out;    // Stores the input-output connnections to other Neurons<br/>    uint32_t            id;</span><span id="30e9" class="mo lj iq kz b gy mt mq l mr ms">    Neuron() {<br/>        static int id = 1;<br/>        this-&gt;id = id++;<br/>    }</span><span id="ef1b" class="mo lj iq kz b gy mt mq l mr ms">    void connect_to(Neuron &amp;other) {<br/>        out.push_back(&amp;other);<br/>        other.in.push_back(this);<br/>    }</span><span id="815c" class="mo lj iq kz b gy mt mq l mr ms">    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Neuron &amp;obj) {<br/>        for (Neuron *n : obj.in)<br/>            os &lt;&lt; n-&gt;id &lt;&lt; "\t--&gt;\t[" &lt;&lt; obj.id &lt;&lt; "]" &lt;&lt; endl;</span><span id="a8f0" class="mo lj iq kz b gy mt mq l mr ms">        for (Neuron *n : obj.out)<br/>            os &lt;&lt; "[" &lt;&lt; obj.id &lt;&lt; "]\t--&gt;\t" &lt;&lt; n-&gt;id &lt;&lt; endl;</span><span id="034a" class="mo lj iq kz b gy mt mq l mr ms">        return os;<br/>    }<br/>};</span><span id="aaec" class="mo lj iq kz b gy mt mq l mr ms">Neuron n1, n2;<br/>n1.connect_to(n2);<br/>cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; endl;</span><span id="45fb" class="mo lj iq kz b gy mt mq l mr ms">/* Output<br/>[1]    --&gt;    2<br/>1    --&gt;    [2]<br/>*/</span></pre><ul class=""><li id="f556" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">还有一个<code class="fe kw kx ky kz b">NeuronLayer</code>，即<code class="fe kw kx ky kz b">Neuron</code>的集合，为简单起见，定义为:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="7f1c" class="mo lj iq kz b gy mp mq l mr ms">struct NeuronLayer : vector&lt;Neuron&gt; {<br/>    NeuronLayer(int count) {<br/>        while (count --&gt; 0)<br/>            emplace_back(Neuron{});<br/>    }</span><span id="8330" class="mo lj iq kz b gy mt mq l mr ms">    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, NeuronLayer &amp;obj) {<br/>        for (auto &amp;n : obj)<br/>            os &lt;&lt; n;<br/>        return os;<br/>    }<br/>};</span></pre><ul class=""><li id="657b" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">现在，如果你想连接<code class="fe kw kx ky kz b">Neuron</code>和<code class="fe kw kx ky kz b">NeuronLayer</code>，反之亦然。您总共将拥有四种不同的功能，如下所示:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="ed23" class="mo lj iq kz b gy mp mq l mr ms">Neuron::connect_to(Neuron&amp;)<br/>Neuron::connect_to(NeuronLayer&amp;)</span><span id="bcfc" class="mo lj iq kz b gy mt mq l mr ms">NeuronLayer::connect_to(NeuronLayer&amp;)<br/>NeuronLayer::connect_to(Neuron&amp;)</span></pre><ul class=""><li id="a180" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">你看这是状态空间爆炸(外行术语中的排列)问题，这不好。因为我们想要一个既能枚举层又能枚举单个神经元的函数。CRTP 在这里派上了用场:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="7730" class="mo lj iq kz b gy mp mq l mr ms">template &lt;typename Self&gt;<br/>struct SomeNeurons {<br/>    template &lt;typename T&gt;<br/>    void connect_to(T &amp;other);<br/>};</span><span id="df31" class="mo lj iq kz b gy mt mq l mr ms">struct Neuron : SomeNeurons&lt;Neuron&gt; {<br/>    vector&lt;Neuron*&gt;     in, out;<br/>    uint32_t            id;</span><span id="dfd5" class="mo lj iq kz b gy mt mq l mr ms">    Neuron() {<br/>        static int id = 1;<br/>        this-&gt;id = id++;<br/>    }</span><span id="c763" class="mo lj iq kz b gy mt mq l mr ms">    Neuron* begin() { return this; }<br/>    Neuron* end() { return this + 1; }<br/>};</span><span id="8516" class="mo lj iq kz b gy mt mq l mr ms">struct NeuronLayer : vector&lt;Neuron&gt;, SomeNeurons&lt;NeuronLayer&gt; {<br/>    NeuronLayer(int count) {<br/>        while (count-- &gt; 0)<br/>            emplace_back(Neuron{});<br/>    }<br/>};</span><span id="7fd4" class="mo lj iq kz b gy mt mq l mr ms">/* ----------------------------------------------------------------------- */<br/>template &lt;typename Self&gt;<br/>template &lt;typename T&gt;<br/>void SomeNeurons&lt;Self&gt;::connect_to(T &amp;other) {<br/>    for (Neuron &amp;from : *static_cast&lt;Self *&gt;(this)) {<br/>        for (Neuron &amp;to : other) {<br/>            from.out.push_back(&amp;to);<br/>            to.in.push_back(&amp;from);<br/>        }<br/>    }<br/>}<br/>/* ----------------------------------------------------------------------- */</span><span id="b9da" class="mo lj iq kz b gy mt mq l mr ms">template &lt;typename Self&gt;<br/>ostream &amp;operator&lt;&lt;(ostream &amp;os, SomeNeurons&lt;Self&gt; &amp;object) {<br/>    for (Neuron &amp;obj : *static_cast&lt;Self *&gt;(&amp;object)) {<br/>        for (Neuron *n : obj.in)<br/>            os &lt;&lt; n-&gt;id &lt;&lt; "\t--&gt;\t[" &lt;&lt; obj.id &lt;&lt; "]" &lt;&lt; endl;</span><span id="63d5" class="mo lj iq kz b gy mt mq l mr ms">        for (Neuron *n : obj.out)<br/>            os &lt;&lt; "[" &lt;&lt; obj.id &lt;&lt; "]\t--&gt;\t" &lt;&lt; n-&gt;id &lt;&lt; endl;<br/>    }<br/>    return os;<br/>}</span><span id="dc91" class="mo lj iq kz b gy mt mq l mr ms">int main() {<br/>    Neuron n1, n2;<br/>    NeuronLayer l1{1}, l2{2};</span><span id="00ed" class="mo lj iq kz b gy mt mq l mr ms">    n1.connect_to(l1); // Scenario 1: Neuron connects to Layer<br/>    l2.connect_to(n2); // Scenario 2: Layer connects to Neuron<br/>    l1.connect_to(l2); // Scenario 3: Layer connects to Layer<br/>    n1.connect_to(n2); // Scenario 4: Neuron connects to Neuron</span><span id="485e" class="mo lj iq kz b gy mt mq l mr ms">    cout &lt;&lt; "Neuron " &lt;&lt; n1.id &lt;&lt; endl &lt;&lt; n1 &lt;&lt; endl;<br/>    cout &lt;&lt; "Neuron " &lt;&lt; n2.id &lt;&lt; endl &lt;&lt; n2 &lt;&lt; endl;</span><span id="02a5" class="mo lj iq kz b gy mt mq l mr ms">    cout &lt;&lt; "Layer " &lt;&lt; endl &lt;&lt; l1 &lt;&lt; endl;<br/>    cout &lt;&lt; "Layer " &lt;&lt; endl &lt;&lt; l2 &lt;&lt; endl;</span><span id="2e29" class="mo lj iq kz b gy mt mq l mr ms">    return EXIT_SUCCESS;<br/>}<br/>/* Output<br/>Neuron 1<br/>[1]    --&gt;    3<br/>[1]    --&gt;    2</span><span id="71c1" class="mo lj iq kz b gy mt mq l mr ms">Neuron 2<br/>4    --&gt;    [2]<br/>5    --&gt;    [2]<br/>1    --&gt;    [2]</span><span id="13b0" class="mo lj iq kz b gy mt mq l mr ms">Layer <br/>1    --&gt;    [3]<br/>[3]    --&gt;    4<br/>[3]    --&gt;    5</span><span id="6815" class="mo lj iq kz b gy mt mq l mr ms">Layer <br/>3    --&gt;    [4]<br/>[4]    --&gt;    2<br/>3    --&gt;    [5]<br/>[5]    --&gt;    2<br/>*/</span></pre><ul class=""><li id="bffc" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">如你所见，我们已经用一个<code class="fe kw kx ky kz b">SomeNeurons::connect_to</code>方法涵盖了所有四种不同的置换场景。并且<code class="fe kw kx ky kz b">Neuron</code> &amp; <code class="fe kw kx ky kz b">NeuronLayer</code>都通过自己的模板化符合这个接口。</li></ul><h1 id="89b4" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++20 飞船操作员在 CRTP 的帮助下</h1><h1 id="4843" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题</h1><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="5d8f" class="mo lj iq kz b gy mp mq l mr ms">struct obj_type_1 {<br/>    bool operator&lt;(const value &amp;rhs) const { return m_x &lt; rhs.m_x; }<br/>    // bool operator==(const value &amp;rhs) const;<br/>    // bool operator!=(const value &amp;rhs) const;    <br/>    // List goes on. . . . . . . . . . . . . . . . . . . .<br/>private:<br/>    // data members to compare<br/>};</span><span id="9ab8" class="mo lj iq kz b gy mt mq l mr ms">struct obj_type_2 {<br/>    bool operator&lt;(const value &amp;rhs) const { return m_x &lt; rhs.m_x; }<br/>    // bool operator==(const value &amp;rhs) const;<br/>    // bool operator!=(const value &amp;rhs) const;    <br/>    // List goes on. . . . . . . . . . . . . . . . . . . .<br/>private:<br/>    // data members to compare<br/>};</span><span id="1f85" class="mo lj iq kz b gy mt mq l mr ms">struct obj_type_3 { ...<br/>struct obj_type_4 { ...<br/>// List goes on. . . . . . . . . . . . . . . . . . . .</span></pre><ul class=""><li id="1005" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">对于每个可比较的对象，您需要定义各自的比较运算符。这是多余的，因为如果我们有一个<code class="fe kw kx ky kz b">operator &lt;</code>，我们可以在它的基础上重载其他操作符。</li><li id="d4f2" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">因此，<code class="fe kw kx ky kz b">operator &lt;</code>是唯一一个具有类型信息的操作符，出于可重用性的目的，可以使其他操作符与类型无关。</li></ul><h1 id="460c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决方案直到 C++17 与 CRTP</h1><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="d135" class="mo lj iq kz b gy mp mq l mr ms">template &lt;class derived&gt;<br/>struct compare {};</span><span id="8bb1" class="mo lj iq kz b gy mt mq l mr ms">struct value : compare&lt;value&gt; {<br/>    int m_x;<br/>    value(int x) : m_x(x) {}<br/>    bool operator &lt; (const value &amp;rhs) const { return m_x &lt; rhs.m_x; }<br/>};</span><span id="0c4b" class="mo lj iq kz b gy mt mq l mr ms">template &lt;class derived&gt;<br/>bool operator &gt; (const compare&lt;derived&gt; &amp;lhs, const compare&lt;derived&gt; &amp;rhs) {<br/>    // static_assert(std::is_base_of_v&lt;compare&lt;derived&gt;, derived&gt;); // Compile time safety measures<br/>    return (static_cast&lt;const derived&amp;&gt;(rhs) &lt; static_cast&lt;const derived&amp;&gt;(lhs));<br/>}</span><span id="9a0d" class="mo lj iq kz b gy mt mq l mr ms">/*  Same goes with other operators<br/>    == :: returns !(lhs &lt; rhs) and !(rhs &lt; lhs)<br/>    != :: returns !(lhs == rhs)<br/>    &gt;= :: returns (rhs &lt; lhs) or (rhs == lhs)<br/>    &lt;= :: returns (lhs &lt; rhs) or (rhs == lhs) <br/>*/</span><span id="b3c7" class="mo lj iq kz b gy mt mq l mr ms">int main() {   <br/>    value v1{5}, v2{10};<br/>    cout &lt;&lt; boolalpha &lt;&lt; "v1 &gt; v2: " &lt;&lt; (v1 &gt; v2) &lt;&lt; '\n';<br/>    return EXIT_SUCCESS;<br/>}<br/>// Now no need to write comparator operators for all the classes, <br/>// Write only type dependent `operator &lt;` &amp; inherit with `compare&lt;T&gt;`</span></pre><h1 id="d7dd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++20 解决方案:宇宙飞船操作员</h1><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="a506" class="mo lj iq kz b gy mp mq l mr ms">struct value{<br/>    int m_x;<br/>    value(int x) : m_x(x) {}<br/>    auto operator&lt;=&gt;(const value &amp;rhs) const = default;<br/>};<br/>// Defaulted equality comparisons<br/>// More Info: <a class="ae lh" href="https://en.cppreference.com/w/cpp/language/default_comparisons" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/default_comparisons</a></span></pre><h1 id="60f8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">启用多态方法链接</h1><ul class=""><li id="aaa6" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated"><em class="ld">方法链接</em>是一种常见的语法，用于连续调用单个对象上的多个方法。这也是在一条语句中完成的，不需要变量来存储中间结果。例如:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="3286" class="mo lj iq kz b gy mp mq l mr ms">class Printer {<br/>    ostream &amp;m_stream;<br/>public:<br/>    Printer(ostream &amp;s) : m_stream(s) { }</span><span id="bd35" class="mo lj iq kz b gy mt mq l mr ms">    Printer &amp;print(auto &amp;&amp;t) {<br/>        m_stream &lt;&lt; t;<br/>        return *this;<br/>    }</span><span id="e1ea" class="mo lj iq kz b gy mt mq l mr ms">    Printer &amp;println(auto &amp;&amp;t) {<br/>        m_stream &lt;&lt; t &lt;&lt; endl;<br/>        return *this;<br/>    }<br/>};</span><span id="2817" class="mo lj iq kz b gy mt mq l mr ms">Printer{cout}.println("hello").println(500);     // Method Chaining</span></pre><ul class=""><li id="0714" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">但是，当方法链应用于对象层次结构时，事情可能会出错。例如:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="2ac7" class="mo lj iq kz b gy mp mq l mr ms">struct ColorPrinter : Printer {<br/>    enum Color{red, blue, green};<br/>    ColorPrinter(ostream &amp;s) : Printer(s) {}</span><span id="79e8" class="mo lj iq kz b gy mt mq l mr ms">    ColorPrinter &amp;SetConsoleColor(Color c) {<br/>        // ...<br/>        return *this;<br/>    }<br/>};</span><span id="71db" class="mo lj iq kz b gy mt mq l mr ms">ColorPrinter(cout).print("Hello ").SetConsoleColor(ColorPrinter::Color::red).println("Printer!"); // Not OK</span></pre><ul class=""><li id="910d" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">编译上面的代码会提示您以下错误:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="50fb" class="mo lj iq kz b gy mp mq l mr ms">error: 'class Printer' has no member named 'SetConsoleColor'<br/>     ColorPrinter(cout).print("Hello ").SetConsoleColor(ColorPrinter::Color::red).println("Printer!");<br/>                                        ^<br/>                                        |______________ We have a 'Printer' here, not a 'ColorPrinter'</span></pre><ul class=""><li id="b99b" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">这是因为我们一调用基类的函数就“失去”了具体的类。</li><li id="8368" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">CRTP 有助于避免此类问题，并支持多态方法链接。</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="8c2e" class="mo lj iq kz b gy mp mq l mr ms">template &lt;typename ConcretePrinter&gt;<br/>class Printer {<br/>    ostream &amp;m_stream;<br/>public:<br/>    Printer(ostream &amp;s) : m_stream(s) { }</span><span id="8f83" class="mo lj iq kz b gy mt mq l mr ms">    ConcretePrinter &amp;print(auto &amp;&amp;t) {<br/>        m_stream &lt;&lt; t;<br/>        return static_cast&lt;ConcretePrinter &amp;&gt;(*this);<br/>    }</span><span id="bdd0" class="mo lj iq kz b gy mt mq l mr ms">    ConcretePrinter &amp;println(auto &amp;&amp;t) {<br/>        m_stream &lt;&lt; t &lt;&lt; endl;<br/>        return static_cast&lt;ConcretePrinter &amp;&gt;(*this);<br/>    }<br/>};</span><span id="00d1" class="mo lj iq kz b gy mt mq l mr ms">struct ColorPrinter : Printer&lt;ColorPrinter&gt; {<br/>    enum Color { red, blue, green };<br/>    ColorPrinter(ostream &amp;s) : Printer(s) {}</span><span id="37df" class="mo lj iq kz b gy mt mq l mr ms">    ColorPrinter &amp;SetConsoleColor(Color c) {<br/>        // ...<br/>        return *this;<br/>    }<br/>};</span><span id="27dc" class="mo lj iq kz b gy mt mq l mr ms">int main() {<br/>    ColorPrinter(cout).print("Hello ").SetConsoleColor(ColorPrinter::Color::red).println("Printer!");<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="7199" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用 CRTP 在 C++中实现多态副本构造</h1><h1 id="6199" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题</h1><ul class=""><li id="cab1" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated">C++使用基类的<a class="ae lh" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>支持多态对象析构。但是，由于с++不支持虚拟构造函数/ <a class="ae lh" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a>，因此缺少对对象创建和复制的等效支持。</li><li id="f27f" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">此外，除非知道对象的静态类型，否则无法创建对象，因为编译器必须知道它需要分配的空间量。出于同样的原因，复制一个对象也需要在编译时知道它的类型。</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="584c" class="mo lj iq kz b gy mp mq l mr ms">struct animal {  virtual ~animal(){ cout &lt;&lt; "~animal\n"; } };</span><span id="b81d" class="mo lj iq kz b gy mt mq l mr ms">struct dog : animal  { ~dog(){ cout &lt;&lt; "~dog\n"; } };<br/>struct cat : animal  { ~cat(){ cout &lt;&lt; "~cat\n"; } };</span><span id="8843" class="mo lj iq kz b gy mt mq l mr ms">void who_am_i(animal *who) { // not sure whether `dog` would be passed here or `cat`</span><span id="3495" class="mo lj iq kz b gy mt mq l mr ms">    // How to `copy` object of the same type i.e. pointed by who?</span><span id="a576" class="mo lj iq kz b gy mt mq l mr ms">    delete who; // you can delete object pointed by who<br/>}</span></pre><h1 id="4ac9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决方案 1:动态多态性</h1><ul class=""><li id="d658" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated">顾名思义，我们将使用虚拟方法来委托对象的复制(和/或创建)动作，如下所示:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="3b0e" class="mo lj iq kz b gy mp mq l mr ms">struct animal {<br/>    virtual unique_ptr&lt;animal&gt; clone() = 0;<br/>};</span><span id="1ae2" class="mo lj iq kz b gy mt mq l mr ms">struct dog : animal {<br/>    unique_ptr&lt;animal&gt; clone() override { return make_unique&lt;dog&gt;(*this); }<br/>};</span><span id="791f" class="mo lj iq kz b gy mt mq l mr ms">struct cat : animal {<br/>    unique_ptr&lt;animal&gt; clone() override { return make_unique&lt;cat&gt;(*this); }<br/>};</span><span id="c10c" class="mo lj iq kz b gy mt mq l mr ms">void who_am_i(animal *who) {<br/>    auto duplicate_who = who-&gt;clone(); // `copy` object of same type i.e. pointed by who ?    <br/>}</span></pre><h1 id="3038" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决方案 2:静态多态性</h1><ul class=""><li id="79fe" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated">同样的事情可以用 CRTP 来完成，如下所示:</li></ul><pre class="mg mh mi mj gt mk kz ml mm aw mn bi"><span id="4e46" class="mo lj iq kz b gy mp mq l mr ms">template &lt;class specific&gt;<br/>struct animal {<br/>    unique_ptr&lt;animal&gt; clone() {<br/>        return make_unique&lt;specific&gt;(static_cast&lt;specific &amp;&gt;(*this));<br/>    }</span><span id="73c4" class="mo lj iq kz b gy mt mq l mr ms">protected: // Forcing animal class to be inherited<br/>    animal(const animal &amp;) = default;<br/>};</span><span id="8cad" class="mo lj iq kz b gy mt mq l mr ms">struct dog : animal&lt;dog&gt; {<br/>    dog(const dog &amp;) { cout &lt;&lt; "copied dog" &lt;&lt; endl; }<br/>};</span><span id="628a" class="mo lj iq kz b gy mt mq l mr ms">struct cat : animal&lt;cat&gt; {<br/>    cat(const cat &amp;) { cout &lt;&lt; "copied cat" &lt;&lt; endl; }<br/>};</span><span id="7971" class="mo lj iq kz b gy mt mq l mr ms">template &lt;class specific&gt;<br/>void who_am_i(animal&lt;specific&gt; *who) {<br/>    auto duplicate_who = who-&gt;clone(); // `copy` object of same type i.e. pointed by who ?<br/>}</span></pre><h1 id="23a7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结束语</h1><p id="1ec5" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">每样东西都有它自己的价格。CRTP 也不例外。例如，如果您使用 CRTP 创建运行时对象，您的代码可能会表现得很奇怪。此外，</p><ul class=""><li id="6754" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">由于基类是模板化的，所以不能用基类指针指向派生类对象。</li><li id="8580" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">此外，您不能创建类似于<code class="fe kw kx ky kz b">std::vector&lt;animal*&gt;</code>的通用容器，因为<code class="fe kw kx ky kz b">animal</code>不是一个类，而是一个需要专门化的模板。定义为<code class="fe kw kx ky kz b">std::vector&lt;animal&lt;dog&gt;*&gt;</code>的容器只能存储<code class="fe kw kx ky kz b">dog</code> s，而不能存储<code class="fe kw kx ky kz b">cat</code> s。这是因为从 CRTP 基类<code class="fe kw kx ky kz b">animal</code>派生的每个类都是唯一的类型。这个问题的一个常见解决方案是增加一个间接层，即带有虚拟析构函数的抽象类，如<code class="fe kw kx ky kz b">abstract_animal</code> &amp;继承<code class="fe kw kx ky kz b">animal</code>类，允许创建<code class="fe kw kx ky kz b">std::vector&lt;abstract_animal*&gt;</code>。</li></ul><p id="b6fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CRTP 还有其他有用应用。如果你认为我错过了什么重要的事情，或者有什么建议，你可以通过这里的联系我。</p><h1 id="1dbe" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">参考</h1><ul class=""><li id="1935" class="mu mv iq ka b kb ni kf nj kj nk kn nl kr nm kv mz na nb nc bi translated"><a class="ae lh" href="https://www.wikiwand.com/en/Curiously_recurring_template_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="a2b7" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae lh" href="https://books.goalkicker.com/CPlusPlusBook/" rel="noopener ugc nofollow" target="_blank">面向专业人士的 C++注释堆栈溢出文档</a></li><li id="6b5d" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae lh" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know/" rel="noopener ugc nofollow" target="_blank">高级 C++概念</a></li></ul></div></div>    
</body>
</html>