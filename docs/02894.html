<html>
<head>
<title>ZSH: How to Create Dynamic Aliases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ZSH:如何创建动态别名</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/zsh-how-to-create-dynamic-aliases-c4b1cbc057b2?source=collection_archive---------4-----------------------#2020-09-09">https://blog.devgenius.io/zsh-how-to-create-dynamic-aliases-c4b1cbc057b2?source=collection_archive---------4-----------------------#2020-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e470638455a51eb13836d0ad00b8d4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u0DkjkMk4ka6fMGx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ec4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是不是经常说“Devops”不是工作，是一种文化和心态的转变。Devops的主要租户之一是“自动化一切”。这个租户不应该只适用于你写的代码和你放在一起的解决方案；理想情况下，它应该适用于你工作的方方面面。</p><p id="3994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，这意味着我喜欢在我的工作笔记本电脑上自动完成一些事情，并且再也不用去想它们了。例如，我有一个脚本，可以在几分钟内将一台全新的笔记本电脑设置为工作状态。我也是化名的超级粉丝！它节省了我的打字时间，也意味着我不必记住每个开关来使命令工作。我使用“OhMyZSH ”,默认情况下它提供了很多别名(git、kubectl等等),但是我也创建了自己的别名。</p><p id="d3f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我笔记本电脑上的一组别名用于与我们内部创建的跑步者进行交互。跑步者允许我们跑地形。kubectl，以及我们所有环境中的许多定制工具。最近，我们更新了跑步者的工作方式，更新打破了我现有的所有别名。我没有更新所有损坏的别名，而是决定创建动态别名，这样，如果我不得不再次更改它们，只需更改一行。</p><p id="72a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我如何设置动态别名。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="5e76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的环境被定义为文件系统中的单个文件夹。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a6de" class="lr ls iq ln b gy lt lu l lv lw">ls -h ~/infra-envs<br/>env1 <br/>env2 <br/>env3 <br/>enva <br/>envb <br/>envc</span></pre><p id="2279" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想为每个env创建一组别名，我希望这是动态的。这意味着如果添加了一个新的env，我将自动获得一组新的别名。</p><p id="8098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在<code class="fe lx ly lz ln b">~/.zshrc</code>中做的第一件事是创建一个for循环，遍历我所有的env。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6bb8" class="lr ls iq ln b gy lt lu l lv lw">for directory in ~/infra-**/*<br/>do<br/> something</span><span id="3694" class="lr ls iq ln b gy ma lu l lv lw">done</span></pre><p id="4a62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">~/infra-**/*</code> —告诉ZSH匹配任何以<code class="fe lx ly lz ln b">infra-</code>开头的目录，并返回这些目录中的对象。</p><p id="41f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的查询返回绝对路径(例如<code class="fe lx ly lz ln b">/User/ken/infra-envs/env1)</code>，我只想要目录的基本名称(例如<code class="fe lx ly lz ln b">env1</code>)。下一步是只删除我想要的组件的路径。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a3d0" class="lr ls iq ln b gy lt lu l lv lw">basedir=$(echo $directory| xargs -n 1 basename)</span><span id="cc5e" class="lr ls iq ln b gy ma lu l lv lw">if [[ "$basedir" == "undesired-dir" ||  "$basedir" == "undesired-dir2" ]]<br/>then<br/>   continue<br/>fi</span></pre><p id="efcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还借此机会排除了我不需要的目录。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="ad00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，我们有了一个想要迭代的env的格式化列表。由于我们采取的方法，将来任何新的env都将自动包含在内。现在来看看实际的混叠。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8bf2" class="lr ls iq ln b gy lt lu l lv lw">for action in command_1 command_2 command_3 tf_plan tf_apply<br/>    do<br/>        tempalias="alias runner-$basedir-$action='bash  ~/runner.sh $basedir $action'"<br/>        eval $tempalias<br/>    done</span></pre><p id="7cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这一节，我想在解释之前先展示代码。对于env，我遍历一个“命令”列表，并以<code class="fe lx ly lz ln b">runner-$ENV-$CMD</code>的格式创建一个匹配的别名。在决定命名结构时，我希望命名是唯一的，易于预测，并且易于制表完成。</p><p id="c416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在向您展示最终结果之前，这里是我的<code class="fe lx ly lz ln b">~/.zshrc</code>的完整代码片段。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="d2dd" class="lr ls iq ln b gy lt lu l lv lw">for directory in ~/infra-**/*<br/>do<br/>    basedir=$(echo $directory| xargs -n 1 basename)</span><span id="8deb" class="lr ls iq ln b gy ma lu l lv lw">if [[ "$basedir" == "undesired-dir" ||  "$basedir" == "undesired-dir2" ]]<br/>    then<br/>        continue<br/>    fi</span><span id="726c" class="lr ls iq ln b gy ma lu l lv lw">for action in command_1 command_2 command_3 tf_plan tf_apply<br/>    do<br/>        tempalias="alias runner-$basedir-$action='bash  ~/runner.sh $basedir $action'"<br/>        eval $tempalias<br/>    done<br/>done</span></pre><p id="c433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，这段代码位于<code class="fe lx ly lz ln b">~/.zshrc</code>中。这意味着每次你加载一个新的终端窗口，这段代码都会被执行。在现有的终端窗口上，您可以运行<code class="fe lx ly lz ln b">source ~/.zshrc</code>来强制手动执行。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="3ecc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是最终结果！如果我输入<code class="fe lx ly lz ln b">runner-env</code>，然后按tab键完成，我会返回:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5d44" class="lr ls iq ln b gy lt lu l lv lw">➜  ~ runner-env<br/>runner-env1-command_1 <br/>runner-env1-command_2<br/>runner-env1-command_3  <br/>runner-env1-tf_plan     <br/>runner-env1-tf_apply</span><span id="2881" class="lr ls iq ln b gy ma lu l lv lw">runner-env2-command_1<br/>runner-env2-command_2  <br/>runner-env2-command_3  <br/>runner-env2-tf_plan  <br/>runner-env2-tf_apply   </span><span id="0e37" class="lr ls iq ln b gy ma lu l lv lw">{TRUNCATED}</span><span id="a3ca" class="lr ls iq ln b gy ma lu l lv lw">runner-envc-command_1  <br/>runner-envc-command_2<br/>runner-envc-command_3  <br/>runner-envc-tf_plan<br/>runner-envc-tf_apply</span></pre><p id="c259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查其中一个别名，我们可以看到它被设置为所需的值。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="856f" class="lr ls iq ln b gy lt lu l lv lw">➜  ~ alias | grep "runner-env1-tf_pl"<br/>runner-env1-tf_plan='bash  ~/runner.sh env1 tf_plan'</span></pre><p id="2e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，启动跑步者就像输入<code class="fe lx ly lz ln b">runner</code>一样简单，选择env，然后点击完成想要的任务！</p><h1 id="6051" class="mb ls iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="8102" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如上所述，我非常喜欢化名。自动化/动态别名甚至更好！我不必花时间键入命令、记住开关或循环浏览我的历史记录。</p><p id="56c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览你的历史，看看是否有你可以创造的别名，以节省时间，并把脑力用在其他地方！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="c979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">为了获得无限的故事，你也可以考虑</em> <a class="ae kc" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"> <em class="nd">注册</em> </a> <em class="nd">成为中等会员，只需5美元。如果您使用</em> <a class="ae kc" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"> <em class="nd">我的链接</em> </a> <em class="nd">注册，我会收到一小笔佣金(无需额外付费)。</em></p></div></div>    
</body>
</html>