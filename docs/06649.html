<html>
<head>
<title>C# Simple Interfaces: Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#简单接口:服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-simple-interfaces-service-d9d1921912e4?source=collection_archive---------4-----------------------#2022-01-23">https://blog.devgenius.io/c-simple-interfaces-service-d9d1921912e4?source=collection_archive---------4-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bff7f4ffa33bca2389e54ae0073f9cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9epMPEqWOJ4zBb-Sgr3rtA.png"/></div></div></figure><p id="3a70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">软件在很多方面都是一种艺术形式。有 100 种方法可以解决完全相同的问题，每种方法都有自己的优缺点。然而，随着时间的推移，你学会了不同的方法来简化你的生活，同时当未来发生变化时，打开你的选择。在我看来，在为应用程序构建架构时，简单接口是一个重要的概念。</p><h1 id="0a24" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">服务接口</h1><p id="3ca7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我在这篇文章中特别谈到了服务接口。一种接口，其唯一目的是执行某项任务或一组任务。相比之下，有保存信息的数据接口(想想<code class="fe lz ma mb mc b">IServiceCollection</code>)。我们下次再讨论这个问题。</p><p id="100f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为一个接口就是一个契约，所以尽可能保持契约的最小化有助于获得最大的收益。如果界面拥有您可能需要的所有必要功能，这一点尤其正确。然而，我发现开发人员倾向于首先关注业务规则，并以非常字面的方式围绕这些规则设计这些接口。这本身并没有什么错，但是随着时间的推移，接口扩展得越多(功能的增加)，您就可能把自己堵在角落里。</p><p id="6d61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我过去见过的一个库存服务接口的例子。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="78ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这是自然创造。但是我们都知道，当您开始实现这个服务时，您会发现自己在每个方法中添加了许多重复的逻辑和检查。当然，您可以创建私有函数来减轻这种痛苦，但是我们可以重新设计这个接口来提供更好的内聚性，而不会失去方法签名本身的友好性。</p><p id="562e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们修改界面，使其看起来更像下面这样。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><blockquote class="mj mk ml"><p id="d1a8" class="jy jz mm ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">现在，我想在这里为任何新的开发人员做一个记录。即使您不更改<code class="fe lz ma mb mc b">public interface IInventoryService { ... }</code>代码本身，更改<code class="fe lz ma mb mc b">InventoryRecord</code>或<code class="fe lz ma mb mc b">InventoryQueryModel</code>也会有效地更改代码中已有的契约。尽管在基于类的参数模型中添加参数更容易，但这与直接改变参数是一样的(从契约的角度来看)。修改合同的任何部分都要小心。</p></blockquote><p id="6e94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在使用这个新服务实际上更难了，在我看来，至少是直接的。但是我们已经将方法的数量从 7 个减少到 2 个。我们怎样才能找回原始契约的好的方法签名呢？</p><p id="6587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是 C#中扩展的美妙之处。</p><blockquote class="mj mk ml"><p id="7fb1" class="jy jz mm ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">扩展有效地允许您向现有类型“添加”方法，而无需创建新的派生类型或修改原始类型。</p></blockquote><p id="197f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一组扩展，它们恢复了原始接口的优点。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这要好得多。然而，乍看之下，这个值似乎很小。在某些方面，这段代码可能在实现本身中，这并不重要。</p><p id="1533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你开始使用这个契约的多个实现时，真正的价值就来了。例如，我喜欢首先构建服务的内存版本，以计算出逻辑，并将这些实例用于单元测试目的。当我解决了所有的逻辑问题后，我会将这些前提条件、后条件和查询适当地转换为 SQL 语句。</p><p id="e0d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能还需要在单个代码库中处理多个连接器类型(即 SQL Server 和 MySql)。同样，这些扩展防止了为每个实现添加一堆样板的需要。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但我们可以说，您并不关心有多个核心实现，甚至内存版本。如果开始出现一些性能问题，您可能会决定在何时开始缓存通用查询。可以创建一个缓存实现来装饰核心服务类。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="92dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使在这种情况下，除了我们定义的 2 个方法之外，我们也不必实现其他 5 个方法。</p><p id="0bd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了绑定到接口的扩展，而不是任何单个实现，我们就能够将这些方法用于将来创建的装饰器或实现的任何组合，从而最大限度地减少代码随时间的变化。</p><h1 id="a68b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="4770" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">扩展方法是你的朋友。虽然，并不是所有的东西都可以或者应该是扩展方法，但它们确实可以为各种交叉关注点和实现细节节省时间。这些“助手”有效地扩展了您编写干净代码的能力，而不会破坏您的原始合约。这使得开发干净的软件变得容易和直观。</p><p id="9706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应该注意的是，扩展方法的一个主要缺点是利用服务的能力。如果特定的方法需要一些未公开的内部注入服务，您将无法利用这种技术。可以通过将字段范围设置为<code class="fe lz ma mb mc b">internal</code>来强制执行，但之后我们开始创建代码气味。如果你发现你有重要的逻辑不能从核心接口方法中处理，可能最好是简单地把它放在契约开始。</p><p id="9fce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码长和 Prosper！</p></div></div>    
</body>
</html>