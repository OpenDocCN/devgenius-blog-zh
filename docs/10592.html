<html>
<head>
<title>Creating custom hooks using Apollo in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 中使用 Apollo 创建自定义挂钩</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-custom-hooks-using-apollo-in-react-c93ca13cd0c3?source=collection_archive---------5-----------------------#2022-11-14">https://blog.devgenius.io/creating-custom-hooks-using-apollo-in-react-c93ca13cd0c3?source=collection_archive---------5-----------------------#2022-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8a8ada3668eaf85924d547f1ae68c7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzk0Uxec63aHLX5jItmgxw.png"/></div></div></figure><p id="8a5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你如何从后端获取数据到前端？你用 GraphQL 吗？我一直在频繁地使用 Apollo，并且非常兴奋地分享我所学到的东西。用 Apollo 钩子在 React 中获取 GraphQL 数据可以简化前端的数据管理。</p><p id="3d8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我想解释一下<code class="fe ku kv kw kx b">useQuery</code>和<code class="fe ku kv kw kx b">useLazyQuery</code>的区别，以及如何使用这两种钩子创建自定义钩子。</p><p id="3cef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">概述:</strong></p><ol class=""><li id="912c" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks ld le lf lg bi translated"><strong class="jx io">阿波罗钩子</strong></li><li id="347e" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io">使用查询 vs 使用无效查询</strong></li><li id="2465" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io">使用查询</strong></li><li id="40cf" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io">无用查询</strong></li><li id="afa0" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io">总结</strong></li></ol><p id="114a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为题外话，我在这篇文章中分享了我是如何为 Apollo customed hook 创建测试的:</p><div class="lm ln gp gr lo lp"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-test-custom-react-apollo-hook-using-jest-mock-beb410671539"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">如何使用 Jest Mock 测试自定义的 React Apollo 钩子</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">我坚信编写好的测试是交付高质量产品的关键组成部分，并且我已经了解到它…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">blog.devgenius.io</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md jt lp"/></div></div></a></div><p id="f048" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以随意查看！</p><h1 id="40f2" class="me mf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">1.阿波罗胡克！</h1><p id="5ed1" class="pw-post-body-paragraph jv jw in jx b jy nc ka kb kc nd ke kf kg ne ki kj kk nf km kn ko ng kq kr ks ig bi translated">钩子是一种函数。在 React 中，一个钩子允许我们，开发者，从一个组件中提取<strong class="jx io">有状态逻辑</strong>，以便<strong class="jx io">重用和独立测试而不改变组件层次</strong>。</p><p id="ea96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个 Apollo 钩子在 React 应用程序中执行 GraphQL 查询。我认为它是一个方便的工具，因为它加载状态并跟踪错误。</p><h1 id="a3e4" class="me mf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">2.useQuery vs useLazyQuery</h1><p id="a173" class="pw-post-body-paragraph jv jw in jx b jy nc ka kb kc nd ke kf kg ne ki kj kk nf km kn ko ng kq kr ks ig bi translated">这两个钩子的主要区别在于钩子是否立即执行。<code class="fe ku kv kw kx b">useQuery</code>组件渲染时运行并获取数据。另一方面，当组件挂载时，<code class="fe ku kv kw kx b">useLazyQuery</code>不会运行，也不会获取数据。它在结果元组中的查询函数被调用时运行。</p><p id="133e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您的组件呈现时，<code class="fe ku kv kw kx b">useQuery</code>从 Apollo 客户端返回一个包含<code class="fe ku kv kw kx b">loading</code>、<code class="fe ku kv kw kx b">error</code>和<code class="fe ku kv kw kx b">data</code>属性的对象。<code class="fe ku kv kw kx b">useLazyQUery</code>也返回该数据，但作为其结果元组的第二个元素。</p><div class="lm ln gp gr lo lp"><a href="https://www.apollographql.com/docs/react/data/queries" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">问题</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">本文展示了如何使用 useQuery 钩子在 React 中获取 GraphQL 数据，并将结果附加到您的 UI 中。你会…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">www.apollographql.com</p></div></div><div class="ly l"><div class="nh l ma mb mc ly md jt lp"/></div></div></a></div><h1 id="5c1f" class="me mf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">3.使用查询</h1><p id="29a7" class="pw-post-body-paragraph jv jw in jx b jy nc ka kb kc nd ke kf kg ne ki kj kk nf km kn ko ng kq kr ks ig bi translated">让我们来看看这个定制挂钩:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dfa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个定制钩子<code class="fe ku kv kw kx b">yourFunction</code>使用 Apollo 的<code class="fe ku kv kw kx b">useQuery</code>并返回一个值为<code class="fe ku kv kw kx b">loading</code>、<code class="fe ku kv kw kx b">error</code>和<code class="fe ku kv kw kx b">data</code>的对象。第一次呈现<code class="fe ku kv kw kx b">loading</code>会返回<code class="fe ku kv kw kx b">true</code>。然后它再次运行以返回获取的<code class="fe ku kv kw kx b">data</code>，然后<code class="fe ku kv kw kx b">loading</code>将返回<code class="fe ku kv kw kx b">false</code>。</p><p id="351a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我没有返回<code class="fe ku kv kw kx b">loading</code>、<code class="fe ku kv kw kx b">error</code>和<code class="fe ku kv kw kx b">data</code>的值，而是自定义<code class="fe ku kv kw kx b">yourFunction</code>返回<code class="fe ku kv kw kx b">loading</code>、<code class="fe ku kv kw kx b">error</code>、<code class="fe ku kv kw kx b">isName</code>。</p><p id="fc0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">isName</code>是从我们从第 18 行的<code class="fe ku kv kw kx b">useQuery</code>返回的数据中返回<code class="fe ku kv kw kx b">name</code>的字符串值。</p><h1 id="907a" class="me mf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">4.无用查询</h1><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0870" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ku kv kw kx b">useLazyQuery</code>的返回元组中，第一个元素是查询函数，我将其命名为<code class="fe ku kv kw kx b">getNyName</code>。第二个元素<code class="fe ku kv kw kx b">nameResult</code>，是由<code class="fe ku kv kw kx b">useQuery</code> — <code class="fe ku kv kw kx b">loading</code>、<code class="fe ku kv kw kx b">error</code>和<code class="fe ku kv kw kx b">data</code>返回的同一个结果对象。</p><p id="4265" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在钩子中异步调用<code class="fe ku kv kw kx b">myName</code>查询函数，我们可以避免使用<code class="fe ku kv kw kx b">useEffect</code>。</p><h1 id="3da6" class="me mf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">5.摘要</h1><p id="0b37" class="pw-post-body-paragraph jv jw in jx b jy nc ka kb kc nd ke kf kg ne ki kj kk nf km kn ko ng kq kr ks ig bi translated">这两个钩子的主要区别在于<code class="fe ku kv kw kx b">useQuery</code>会立即执行，而<code class="fe ku kv kw kx b">useLazyQuery</code>不会。理解了这种差异之后，我们回顾了使用 Apollo 创建定制钩子的方法。</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="0a0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你鼓掌时👏我的帖子和订阅，你支持我的科技之旅，我将不胜感激:)</p><p id="2aff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢，祝编码愉快！</p></div></div>    
</body>
</html>