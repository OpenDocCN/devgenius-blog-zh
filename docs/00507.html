<html>
<head>
<title>Minimum “Hello, World!” Program for WPF on .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最低“你好，世界！”WPF的节目在。网络核心</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/minimum-hello-world-program-for-wpf-on-net-core-af448fa5e51f?source=collection_archive---------11-----------------------#2020-06-09">https://blog.devgenius.io/minimum-hello-world-program-for-wpf-on-net-core-af448fa5e51f?source=collection_archive---------11-----------------------#2020-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这对于平台上的任何语言来说都是一个太老的话题了。</p><p id="1db2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我想从几个不同的角度来探索它，因为它不再是简单的编程语言了。WPF是建立在托管代码系统上的。NET平台上运行。还有更多的涉及。对于我们的任务，我们将使用C#和。NET Core 3.x或。NET 5.0。</p><p id="43e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，用一种特定的语言来说很简单，那就是“你好，世界！”程序，它通常只显示一行文本“Hello，World！”在控制台上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0f69e4fcac6ad1654c3b212b484e298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InsgQwZy5mBbYVkETIDj3A.png"/></div></div></figure><p id="fd02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，WPF是一个现代的Windows UI设计范例，它由两类组件组成:XAML和代码，其中XAML只是一种标记语言，以更好的UI表示来组织支持的类型，代码部分通常被称为动作和状态更改的代码隐藏，以支持XAML设计和其他任务。对于XAML纯粹主义者来说，他们希望将他们的设计尽可能多地推向XAML，而那些刚从WinForms之类的网站搬到WPF的人，只要有代码来完成手头的任务，就会感觉很自在。</p><h2 id="4762" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">目标</h2><p id="e043" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">因为我们试图减少我们的“你好，世界！”WPF计划，我们应该在深入设计之前设定指导方针的目标，看看我们将在哪里着陆:</p><p id="fddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.我们应该使用。NET SDK尽可能多，而不是试图推倒重来；</p><p id="2837" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.一种语言只有“你好，世界！”是在控制台上显示一个文本行，但是对于我们的设计来说，更重要的是在屏幕上显示一个设计窗口或视觉部分，不管它有多简单，它应该隐含地向世界展示问候。如果我们坚持在屏幕上显示窗口中的文本，这不应该被认为是有任何意义的，而是一个窗口一旦显示的琐碎任务。</p><p id="24db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.XAML和代码隐藏都使用WPF支持的类型。它们应该是可互换的，因此我们将把它推向两个不同的方向，以产生我们项目设计的两个版本:</p><ul class=""><li id="0ea2" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">WPF·XAML只说了一句“你好，世界！”</li><li id="c19d" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">WPF电码只有“你好，世界！”</li></ul><h2 id="61d1" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">设置</h2><p id="eea9" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们假设您已经安装了。NET Core 3.x或。NET 5.0，在这里我们将坚持使用。NET SDK 5.0.100-preview.4</p><p id="839a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果运行dotnet:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="6e6b" class="ku kv in mh b gy ml mm l mn mo">$dotnet — version</span><span id="7b41" class="ku kv in mh b gy mp mm l mn mo">5.0.100-preview.4.20258.7</span></pre><p id="b839" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并得到结果显示它是。NET Core 3.x或。NET 5，你已经准备好了。</p><h2 id="8367" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">设计</h2><p id="a708" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们将创建两个框架项目，一个仅用于XAML，另一个仅用于代码:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ac8e" class="ku kv in mh b gy ml mm l mn mo">$mkdir c:\projects\wpf</span><span id="deff" class="ku kv in mh b gy mp mm l mn mo">$cd c:\projects\wpf</span><span id="f4b4" class="ku kv in mh b gy mp mm l mn mo">$dotnet new wpf -n xamlmin</span><span id="948c" class="ku kv in mh b gy mp mm l mn mo">$dotnet new wpf -n codemin</span></pre><p id="9cd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。XAML只有“你好，世界！”项目</strong></p><p id="b60b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们先从XAML唯一的程序开始，我们的目标是摆脱一切”。cs”文件以及其他文件，以最小化每个文件的项目组件和内容。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="6109" class="ku kv in mh b gy ml mm l mn mo">$cd c:\projects\wpf\xamlmin</span><span id="f0bc" class="ku kv in mh b gy mp mm l mn mo">$dir</span><span id="b830" class="ku kv in mh b gy mp mm l mn mo">368 App.xaml</span><span id="fd4a" class="ku kv in mh b gy mp mm l mn mo">340 App.xaml.cs</span><span id="e64b" class="ku kv in mh b gy mp mm l mn mo">604 AssemblyInfo.cs</span><span id="bf63" class="ku kv in mh b gy mp mm l mn mo">493 MainWindow.xaml</span><span id="b013" class="ku kv in mh b gy mp mm l mn mo">659 MainWindow.xaml.cs</span><span id="f81e" class="ku kv in mh b gy mp mm l mn mo">&lt;DIR&gt; obj</span><span id="8b56" class="ku kv in mh b gy mp mm l mn mo">224 xamlmin.csproj</span><span id="6d60" class="ku kv in mh b gy mp mm l mn mo">6 File(s)    2,688 bytes</span></pre><ul class=""><li id="264f" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">我们有6个文件和一个目录</li><li id="dcbd" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">“obj”目录是保存构建过程的临时文件，我们可以去掉它</li><li id="9de8" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">“AssemblyInfo.cs”是用于ThemeInfo的，这不是必需的，我们也可以删除它</li><li id="3952" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我们现在有两个XAML文件，两个C#文件和一个项目文件。我们希望去掉两个C#文件，简化两个XAML文件，如果可能的话，甚至尝试合并它们。我们需要项目文件来构建和运行我们的程序，所以有必要保留它；</li><li id="dcaf" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我们来看看“App.xaml.cs”文件:</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="cffc" class="ku kv in mh b gy ml mm l mn mo">using System;</span><span id="1125" class="ku kv in mh b gy mp mm l mn mo">using System.Collections.Generic;</span><span id="0911" class="ku kv in mh b gy mp mm l mn mo">using System.Configuration;</span><span id="0884" class="ku kv in mh b gy mp mm l mn mo">using System.Data;</span><span id="36fb" class="ku kv in mh b gy mp mm l mn mo">using System.Linq;</span><span id="b6ae" class="ku kv in mh b gy mp mm l mn mo">using System.Threading.Tasks;</span><span id="b26d" class="ku kv in mh b gy mp mm l mn mo">using System.Windows;</span><span id="e87d" class="ku kv in mh b gy mp mm l mn mo">namespace xamlmin</span><span id="2274" class="ku kv in mh b gy mp mm l mn mo">{</span><span id="423e" class="ku kv in mh b gy mp mm l mn mo">   /// &lt;summary&gt;</span><span id="237a" class="ku kv in mh b gy mp mm l mn mo">   /// Interaction logic for App.xaml</span><span id="c704" class="ku kv in mh b gy mp mm l mn mo">   /// &lt;/summary&gt;</span><span id="4a73" class="ku kv in mh b gy mp mm l mn mo">   public partial class App : Application</span><span id="bba2" class="ku kv in mh b gy mp mm l mn mo">   {</span><span id="7cd8" class="ku kv in mh b gy mp mm l mn mo">   }</span><span id="d17a" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><p id="a42e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，只是包含了一个空的部分类App需要填充。在“App.xaml”中，应用程序已准备好进行实例化。所以，我们可以摆脱它。</p><ul class=""><li id="2938" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">我们现在在哪里？完成上述步骤后，项目文件夹中还剩下4个文件:</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="d11b" class="ku kv in mh b gy ml mm l mn mo">$dir</span><span id="8b51" class="ku kv in mh b gy mp mm l mn mo">368 App.xaml</span><span id="2c97" class="ku kv in mh b gy mp mm l mn mo">493 MainWindow.xaml</span><span id="1e8c" class="ku kv in mh b gy mp mm l mn mo">659 MainWindow.xaml.cs</span><span id="b9ef" class="ku kv in mh b gy mp mm l mn mo">224 xamlmin.csproj</span><span id="ca33" class="ku kv in mh b gy mp mm l mn mo">4 File(s)    1,744 bytes</span></pre><ul class=""><li id="be99" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">有了上面的文件，还运行吗？让我们试一试:</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2886" class="ku kv in mh b gy ml mm l mn mo">$dotnet run</span></pre><p id="7d07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非常好！它仍然运行，你应该看到一个空白的WPF窗口显示在你的屏幕上。</p><ul class=""><li id="f3c2" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">我们的项目中仍然有一个C#文件“MainWindow.xaml.cs ”,我们能否以某种方式删除它，程序仍然运行？让我们来看看:</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="878c" class="ku kv in mh b gy ml mm l mn mo">using System;</span><span id="3f38" class="ku kv in mh b gy mp mm l mn mo">using System.Collections.Generic;</span><span id="22b6" class="ku kv in mh b gy mp mm l mn mo">using System.Linq;</span><span id="47db" class="ku kv in mh b gy mp mm l mn mo">using System.Text;</span><span id="7117" class="ku kv in mh b gy mp mm l mn mo">using System.Threading.Tasks;</span><span id="4ab7" class="ku kv in mh b gy mp mm l mn mo">using System.Windows;</span><span id="72bc" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Controls;</span><span id="2bc3" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Data;</span><span id="8fef" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Documents;</span><span id="1c8c" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Input;</span><span id="04f3" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Media;</span><span id="23c7" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Media.Imaging;</span><span id="2204" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Navigation;</span><span id="d9c8" class="ku kv in mh b gy mp mm l mn mo">using System.Windows.Shapes;</span><span id="c906" class="ku kv in mh b gy mp mm l mn mo">namespace xamlmin</span><span id="4261" class="ku kv in mh b gy mp mm l mn mo">{</span><span id="da57" class="ku kv in mh b gy mp mm l mn mo">    /// &lt;summary&gt;</span><span id="0c54" class="ku kv in mh b gy mp mm l mn mo">    /// Interaction logic for MainWindow.xaml</span><span id="d602" class="ku kv in mh b gy mp mm l mn mo">    /// &lt;/summary&gt;</span><span id="e182" class="ku kv in mh b gy mp mm l mn mo">    public partial class MainWindow : Window</span><span id="df02" class="ku kv in mh b gy mp mm l mn mo">    {</span><span id="37e4" class="ku kv in mh b gy mp mm l mn mo">        public MainWindow()</span><span id="6be3" class="ku kv in mh b gy mp mm l mn mo">        {</span><span id="0db2" class="ku kv in mh b gy mp mm l mn mo">            InitializeComponent();</span><span id="1a42" class="ku kv in mh b gy mp mm l mn mo">        }</span><span id="e7b5" class="ku kv in mh b gy mp mm l mn mo">    }</span><span id="fa6d" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><p id="9330" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个从Window类派生的分部类MainWindow，并且在构造函数中只有一行代码。我们知道“MainWindow.xaml”已经准备好实例化“MainWindow”类，现在的问题是，我们是完全删除代码，还是将代码移到xaml文件中的某个位置。</p><p id="1e94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们真的不能去掉代码，因为程序需要被触发才能运行。幸运的是，我们知道XAML文件可以有内联代码，尽管这是有限的，也不鼓励这样做。但出于我们的目的，我们将尽一切努力来实现我们的设计目标。</p><p id="5c97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将内联代码插入“MainWindow.xaml”并删除“MainWindow.xaml.cs”文件:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="8b30" class="ku kv in mh b gy ml mm l mn mo">&lt;Window x:Class="xamlmin.MainWindow"</span><span id="dcd5" class="ku kv in mh b gy mp mm l mn mo">  </span><span id="b238" class="ku kv in mh b gy mp mm l mn mo">  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</span><span id="a918" class="ku kv in mh b gy mp mm l mn mo">  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"</span><span id="ff2d" class="ku kv in mh b gy mp mm l mn mo">  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"</span><span id="c760" class="ku kv in mh b gy mp mm l mn mo">  xmlns:local="clr-namespace:xamlmin"</span><span id="9825" class="ku kv in mh b gy mp mm l mn mo">  mc:Ignorable="d"</span><span id="3f1d" class="ku kv in mh b gy mp mm l mn mo">  Title="MainWindow" Height="450" Width="800"&gt;</span><span id="f041" class="ku kv in mh b gy mp mm l mn mo">  &lt;Grid&gt;</span><span id="cba5" class="ku kv in mh b gy mp mm l mn mo">  &lt;/Grid&gt;<br/></span><span id="0343" class="ku kv in mh b gy mp mm l mn mo">  &lt;x:Code&gt;&lt;![CDATA[</span><span id="3063" class="ku kv in mh b gy mp mm l mn mo">    public MainWindow()</span><span id="d258" class="ku kv in mh b gy mp mm l mn mo">    {</span><span id="c603" class="ku kv in mh b gy mp mm l mn mo">      InitializeComponent();</span><span id="a3fa" class="ku kv in mh b gy mp mm l mn mo">    }</span><span id="60dd" class="ku kv in mh b gy mp mm l mn mo">  ]]&gt;&lt;/x:Code&gt;</span><span id="2df5" class="ku kv in mh b gy mp mm l mn mo">&lt;/Window&gt;</span></pre><p id="801f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，让我们试一试:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ef55" class="ku kv in mh b gy ml mm l mn mo">$del mainwindow.xaml.cs</span><span id="0083" class="ku kv in mh b gy mp mm l mn mo">$dir</span><span id="0e19" class="ku kv in mh b gy mp mm l mn mo">368 App.xaml</span><span id="a22b" class="ku kv in mh b gy mp mm l mn mo">595 MainWindow.xaml</span><span id="2b45" class="ku kv in mh b gy mp mm l mn mo">224 xamlmin.csproj</span><span id="258f" class="ku kv in mh b gy mp mm l mn mo">3 File(s)    1,187 bytes</span><span id="631b" class="ku kv in mh b gy mp mm l mn mo">$dotnet run</span></pre><p id="4f32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看到屏幕上弹出的空白窗口了吗？如果你做到了，恭喜你！</p><ul class=""><li id="a1c6" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">我们的下一个问题是:“两个XAML文件可以合并吗？”不幸的是，答案是“不”。[1]微软公司在“WPF XAML概况”一文中指出:</li></ul><blockquote class="mq mr ms"><p id="a911" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">XAML文件必须只有一个根元素，才能既是格式良好的XML文件，又是有效的XAML文件</p></blockquote><p id="e7e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的程序需要两个类:窗口和应用程序。他们将不得不分别生活在自己的XAML文件中。</p><ul class=""><li id="c2f0" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">现在，我们只有3个文件用于XAML项目:App.xaml、MainWindow.xaml和xamlmin.csproj，这是我们构建和运行程序的最低要求。</li><li id="3034" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我们最后的工作是修剪3个文件，看看我们能压缩多少。</li></ul><p id="bd5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于“xamlmin.csproj”:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a444" class="ku kv in mh b gy ml mm l mn mo">&lt;Project Sdk="Microsoft.NET.Sdk.WindowsDesktop"&gt;</span><span id="c77a" class="ku kv in mh b gy mp mm l mn mo">  &lt;PropertyGroup&gt;</span><span id="386a" class="ku kv in mh b gy mp mm l mn mo">    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;</span><span id="435b" class="ku kv in mh b gy mp mm l mn mo">    &lt;TargetFramework&gt;netcoreapp5.0&lt;/TargetFramework&gt;</span><span id="292b" class="ku kv in mh b gy mp mm l mn mo">    &lt;UseWPF&gt;true&lt;/UseWPF&gt;</span><span id="b665" class="ku kv in mh b gy mp mm l mn mo">  &lt;/PropertyGroup&gt;</span><span id="a2ba" class="ku kv in mh b gy mp mm l mn mo">&lt;/Project&gt;</span></pre><p id="ac32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你能碰的真的不多。每一行对于我们成功构建和运行程序都是必不可少的。你唯一能玩的就是把“netcoreapp5.0”换成“net5.0”，应该还能用。</p><p id="49f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于“App.xaml”:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="c91e" class="ku kv in mh b gy ml mm l mn mo">&lt;Application x:Class="xamlmin.App"</span><span id="e459" class="ku kv in mh b gy mp mm l mn mo">  </span><span id="931c" class="ku kv in mh b gy mp mm l mn mo">  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</span><span id="1ec2" class="ku kv in mh b gy mp mm l mn mo">  xmlns:local="clr-namespace:xamlmin"</span><span id="6aff" class="ku kv in mh b gy mp mm l mn mo">  Startup Uri="MainWindow.xaml"&gt;</span><span id="e2ba" class="ku kv in mh b gy mp mm l mn mo">  &lt;Application.Resources&gt;</span><span id="7565" class="ku kv in mh b gy mp mm l mn mo">  &lt;/Application.Resources&gt;</span><span id="3e6b" class="ku kv in mh b gy mp mm l mn mo">&lt;/Application&gt;</span></pre><p id="d1d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“应用程序”中是空的。我们可以摆脱的资源。我们还可以删除“xmlns:local”行。我们有了最终版本:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="fe2f" class="ku kv in mh b gy ml mm l mn mo">&lt;Application x:Class="xaml2009.App"</span><span id="731b" class="ku kv in mh b gy mp mm l mn mo">  </span><span id="1e2f" class="ku kv in mh b gy mp mm l mn mo">  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</span><span id="f4f4" class="ku kv in mh b gy mp mm l mn mo">  StartupUri="MainWindow.xaml"&gt;</span><span id="f4a1" class="ku kv in mh b gy mp mm l mn mo">&lt;/Application&gt;</span></pre><p id="4029" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于“MainWindow.xaml ”,我们可以删除<Grid> </Grid>,因为它是空的。我们也可以删除“标题”行，因为程序将不带标题运行。在删除了另外3行之后，我们得到了“MainWindow.xaml”的最终版本，如下所示:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="d81c" class="ku kv in mh b gy ml mm l mn mo">&lt;Window x:Class="xaml2009.MainWindow"</span><span id="c2e4" class="ku kv in mh b gy mp mm l mn mo">  </span><span id="11d4" class="ku kv in mh b gy mp mm l mn mo">  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;</span><span id="64cc" class="ku kv in mh b gy mp mm l mn mo">  &lt;x:Code&gt;&lt;![CDATA[</span><span id="8674" class="ku kv in mh b gy mp mm l mn mo">    public MainWindow()</span><span id="74a9" class="ku kv in mh b gy mp mm l mn mo">    {</span><span id="a903" class="ku kv in mh b gy mp mm l mn mo">      InitializeComponent();</span><span id="433a" class="ku kv in mh b gy mp mm l mn mo">    }</span><span id="8a73" class="ku kv in mh b gy mp mm l mn mo">  ]]&gt;&lt;/x:Code&gt;</span><span id="226b" class="ku kv in mh b gy mp mm l mn mo">&lt;/Window&gt;</span></pre><p id="8f50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，在这里你有它:3个文件在我们的XAML只有WPF“你好，世界！”程序。</p><ul class=""><li id="01c0" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">如果你坚持，我们可以加“<TextBlock>你好，世界！”</TextBlock>"要么在内联代码上面，要么在下面，运行它，我们会看到:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/0c63c4b952faef76b557e865c3a0e692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZOPlEyXJlW-kFcTkMYQzA.png"/></div></div></figure><p id="4892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。代码只有“你好，世界！”</strong></p><ul class=""><li id="5a61" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">由于我们只处理WPF的代码，我们可以删除XMAL文件和“obj”目录。</li><li id="fb26" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">有了以上更详细的分析，我们还可以删除“AssemblyInfo.cs”和“MainWindow.xaml.cs”:</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ba06" class="ku kv in mh b gy ml mm l mn mo">$cd c:\projects\wpf\codemin</span><span id="24ce" class="ku kv in mh b gy mp mm l mn mo">$del *.xaml AssemblyInfo.cs MainWindow.xaml.cs</span><span id="efed" class="ku kv in mh b gy mp mm l mn mo">$rmdir /q/s obj</span><span id="9c5c" class="ku kv in mh b gy mp mm l mn mo">$dir</span><span id="4397" class="ku kv in mh b gy mp mm l mn mo">340 App.xaml.cs</span><span id="1dac" class="ku kv in mh b gy mp mm l mn mo">224 codemin.csproj</span><span id="5e77" class="ku kv in mh b gy mp mm l mn mo">2 File(s)   564 bytes</span></pre><p id="8279" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看“App.xaml.cs”文件:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="61c1" class="ku kv in mh b gy ml mm l mn mo">using System;</span><span id="06da" class="ku kv in mh b gy mp mm l mn mo">using System.Collections.Generic;</span><span id="db6a" class="ku kv in mh b gy mp mm l mn mo">using System.Configuration;</span><span id="5d64" class="ku kv in mh b gy mp mm l mn mo">using System.Data;</span><span id="ccff" class="ku kv in mh b gy mp mm l mn mo">using System.Linq;</span><span id="77d6" class="ku kv in mh b gy mp mm l mn mo">using System.Threading.Tasks;</span><span id="3856" class="ku kv in mh b gy mp mm l mn mo">using System.Windows;</span><span id="bae2" class="ku kv in mh b gy mp mm l mn mo">namespace codemin</span><span id="9899" class="ku kv in mh b gy mp mm l mn mo">{</span><span id="d496" class="ku kv in mh b gy mp mm l mn mo">   /// &lt;summary&gt;</span><span id="9655" class="ku kv in mh b gy mp mm l mn mo">   /// Interaction logic for App.xaml</span><span id="b209" class="ku kv in mh b gy mp mm l mn mo">   /// &lt;/summary&gt;</span><span id="6b44" class="ku kv in mh b gy mp mm l mn mo">   public partial class App : Application</span><span id="6ebe" class="ku kv in mh b gy mp mm l mn mo">   {</span><span id="2c1c" class="ku kv in mh b gy mp mm l mn mo">   }</span><span id="2b77" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><p id="7e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的应用程序是从应用程序类派生的，因为我们删除了窗口类及其初始化，所以我们需要引入程序入口点并创建一个窗口对象。</p><p id="fd35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将以下代码添加到C#文件中:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="4ad1" class="ku kv in mh b gy ml mm l mn mo">public static void Main() {</span><span id="195c" class="ku kv in mh b gy mp mm l mn mo">  var win = new Window();</span><span id="1860" class="ku kv in mh b gy mp mm l mn mo">  win.Show();</span><span id="2773" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><p id="0738" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和修剪“使用”列表，然后我们有:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f0b3" class="ku kv in mh b gy ml mm l mn mo">using System;</span><span id="12f6" class="ku kv in mh b gy mp mm l mn mo">using System.Windows;</span><span id="d311" class="ku kv in mh b gy mp mm l mn mo">namespace codemin</span><span id="b88f" class="ku kv in mh b gy mp mm l mn mo">{</span><span id="89e4" class="ku kv in mh b gy mp mm l mn mo">  /// &lt;summary&gt;</span><span id="25d4" class="ku kv in mh b gy mp mm l mn mo">  /// Interaction logic for App.xaml</span><span id="a6a3" class="ku kv in mh b gy mp mm l mn mo">  /// &lt;/summary&gt;</span><span id="bd13" class="ku kv in mh b gy mp mm l mn mo">  public partial class App : Application</span><span id="daf8" class="ku kv in mh b gy mp mm l mn mo">  {</span><span id="cc9b" class="ku kv in mh b gy mp mm l mn mo">    public static void Main() {</span><span id="2d9e" class="ku kv in mh b gy mp mm l mn mo">      var win = new Window();</span><span id="8e51" class="ku kv in mh b gy mp mm l mn mo">      win.Show();</span><span id="a994" class="ku kv in mh b gy mp mm l mn mo">    }</span><span id="5163" class="ku kv in mh b gy mp mm l mn mo">  }</span><span id="5a9d" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><p id="4b41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们运行项目时:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2e15" class="ku kv in mh b gy ml mm l mn mo">$dotnet run</span></pre><p id="ccf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么也没有发生，也没有错误或警告！让我们来构建项目:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ed5d" class="ku kv in mh b gy ml mm l mn mo">$dotnet build</span><span id="75a9" class="ku kv in mh b gy mp mm l mn mo">Microsoft (R) Build Engine version 16.7.0-preview-20220-01+80e487bff for .NET Core</span><span id="6e11" class="ku kv in mh b gy mp mm l mn mo">Copyright (C) Microsoft Corporation. All rights reserved.</span><span id="1ccc" class="ku kv in mh b gy mp mm l mn mo">Determining projects to restore...</span><span id="ae28" class="ku kv in mh b gy mp mm l mn mo">All projects are up-to-date for restore.</span><span id="8552" class="ku kv in mh b gy mp mm l mn mo">You are using a preview version of .NET. See: https://aka.ms/dotnet-core-preview</span><span id="592b" class="ku kv in mh b gy mp mm l mn mo">codemin -&gt; C:\projects\codemin\bin\Debug\netcoreapp5.0\codemin.dll</span><span id="5db9" class="ku kv in mh b gy mp mm l mn mo">Build succeeded.</span><span id="cd03" class="ku kv in mh b gy mp mm l mn mo">0 Warning(s)</span><span id="f588" class="ku kv in mh b gy mp mm l mn mo">0 Error(s)</span><span id="f54c" class="ku kv in mh b gy mp mm l mn mo">Time Elapsed 00:00:00.71</span></pre><p id="6bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一切都构建成功。这是怎么回事？</p><p id="7c3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原来，微软决定在他们最初的设计决策中为WPF使用“单线程”模型:[2]</p><blockquote class="mq mr ms"><p id="d402" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">“最终，WPF的线程模型与现有的User32线程模型保持同步，该模型支持线程关联的单线程执行。”</p></blockquote><p id="bdcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们需要在Main()方法上设置属性[STAThread]。</p><ul class=""><li id="9212" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">现在我们可以运行程序了。然而，你需要非常仔细地观察你的屏幕，看一个空白的窗口闪烁然后消失。</li><li id="edba" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">为了让程序持续运行，我们需要为应用程序添加几行代码来连接窗口并循环运行。</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f19b" class="ku kv in mh b gy ml mm l mn mo">using System;</span><span id="9954" class="ku kv in mh b gy mp mm l mn mo">using System.Windows;</span><span id="9184" class="ku kv in mh b gy mp mm l mn mo">namespace codemin</span><span id="5a2c" class="ku kv in mh b gy mp mm l mn mo">{</span><span id="9aef" class="ku kv in mh b gy mp mm l mn mo">  /// &lt;summary&gt;</span><span id="7dc2" class="ku kv in mh b gy mp mm l mn mo">  /// Interaction logic for App.xaml</span><span id="6879" class="ku kv in mh b gy mp mm l mn mo">  /// &lt;/summary&gt;</span><span id="66af" class="ku kv in mh b gy mp mm l mn mo">  public partial class App : Application</span><span id="39e3" class="ku kv in mh b gy mp mm l mn mo">  {</span><span id="f6bc" class="ku kv in mh b gy mp mm l mn mo">    [STAThread]</span><span id="f00a" class="ku kv in mh b gy mp mm l mn mo">    public static void Main() {</span><span id="03cf" class="ku kv in mh b gy mp mm l mn mo">      var app = new App();</span><span id="d916" class="ku kv in mh b gy mp mm l mn mo">      var win = new Window();</span><span id="abe0" class="ku kv in mh b gy mp mm l mn mo">      win.Show();</span><span id="1f93" class="ku kv in mh b gy mp mm l mn mo">      app.MainWindow = win;</span><span id="b7fe" class="ku kv in mh b gy mp mm l mn mo">      app.Run();</span><span id="d857" class="ku kv in mh b gy mp mm l mn mo">    }</span><span id="b022" class="ku kv in mh b gy mp mm l mn mo">  }</span><span id="7692" class="ku kv in mh b gy mp mm l mn mo">}</span></pre><ul class=""><li id="c3c6" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">如果你真的想看到问候:“你好，世界！”在窗口中，请在“赢”之前添加以下三行。Show()":</li></ul><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="e9c9" class="ku kv in mh b gy ml mm l mn mo">var tb = new TextBlock();</span><span id="3efa" class="ku kv in mh b gy mp mm l mn mo">tb.Text="Hello, World!";</span><span id="1a62" class="ku kv in mh b gy mp mm l mn mo">win.Content = tb;</span></pre><p id="0a22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f765" class="ku kv in mh b gy ml mm l mn mo">using System.Windows.Controls;</span></pre><p id="263c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在程序的顶部。</p><p id="63ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有许多其他的方式来显示它。</p><p id="d70b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅此而已。</p><p id="b295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们并不提倡纯粹用XMAL或代码来设计，我们只是想通过这个练习更好地理解WPF。</p><p id="005b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在现实世界中，最好的方法是同时使用XAML和代码来设计最优的产品。</p><p id="822d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的项目代码可以从[3]下载</p><h1 id="6566" class="my kv in bd kw mz na nb kz nc nd ne lc nf ng nh lf ni nj nk li nl nm nn ll no bi translated"><strong class="ak">参考</strong></h1><p id="d039" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">[1]<a class="ae np" href="https://docs.microsoft.com/en-us/dotnet/desktop-wpf/fundamentals/xaml" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/desktop-wpf/fundamentals/xaml</a></p><p id="5a92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[2]<a class="ae np" href="https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/wpf-architecture" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/framework/wpf/advanced/wpf-architecture</a></p><p id="c7b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae np" href="https://github.com/huobur/MinWPFProgram" rel="noopener ugc nofollow" target="_blank">https://github.com/huobur/MinWPFProgram</a></p></div></div>    
</body>
</html>