<html>
<head>
<title>Spring WebFlux Security OTP Email with MongoDB and Flutter 2/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring WebFlux 安全 OTP 电子邮件与 MongoDB 和 Flutter 2/2</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-webflux-security-otp-email-with-mongodb-and-flutter-2-2-6be473576f16?source=collection_archive---------9-----------------------#2022-06-15">https://blog.devgenius.io/spring-webflux-security-otp-email-with-mongodb-and-flutter-2-2-6be473576f16?source=collection_archive---------9-----------------------#2022-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/spring-webflux-security-otp-email-with-mongodb-and-flutter-1-2-f73e1d94ec7a">之前的故事</a>中，我们用 Spring Security Webflux 覆盖了 OTP 代码。我们在用户登录时向其发送了 OTP 代码。在这个故事中，我们将使用 Flutter 实现移动应用程序的登录过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ko"><img src="../Images/b4da9c304ac0f894e19ab16e958567af.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jQB_Q0dMlP2Y4FM1vMkGiQ.png"/></div></figure><h1 id="80d5" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">先决条件</h1><p id="5fa2" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">这是遵循第 2 部分的所有先决条件的列表:</p><ul class=""><li id="82c0" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">颤动 3.0.0</li><li id="178c" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">Dart 2.17.0</li><li id="23d4" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">Android Studio 或 Visual Studio 代码</li><li id="8e1c" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">运行第 1 部分的后端</li></ul><h1 id="9bc6" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">概观</h1><p id="2804" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">我们将使用 Cubit/Bloc 来使用我们的后端 API，以及如何在 Flutter 应用程序中使用它。</p><h2 id="0e6f" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">什么是阻塞？</h2><blockquote class="mu mv mw"><p id="ebde" class="jk jl mx jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">业务逻辑组件(BLoC)允许您将业务逻辑与 UI 分离开来。以块的形式编写代码使得编写和重用测试更加容易。</p></blockquote><h2 id="c952" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">集团架构</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/6dabbc88a1c5d24a482e443eb26d47ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lRzsnSo7Ujuytlui.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">bloclibrary.dev</figcaption></figure><p id="7f91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 bloc 库允许我们将应用程序分成三层:</p><ul class=""><li id="0677" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">介绍会；展示会</li><li id="01ae" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">业务逻辑</li><li id="b706" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">数据(存储库、数据提供者)</li></ul><h2 id="bea8" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">肘</h2><p id="5dc0" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated"><code class="fe nk nl nm nn b"><strong class="jm io">Cubit</strong></code>是一个扩展了<code class="fe nk nl nm nn b"><strong class="jm io">BlocBase</strong></code>的类，可以扩展到管理任何类型的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/4337eb1ae7315df6bf56104dcc780209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5CBqB7n6oo8VkjJ-.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">bloclibrary.dev</figcaption></figure><p id="a5ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面的图表中看到的，在 Cubit 中，我们不再有事件，取而代之的是函数。这些函数将触发一个更新 UI 的状态变化。</p><h1 id="9b9c" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">入门指南</h1><p id="cdce" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">现在我们开始创建一个新的 flutter 项目。在终端中键入以下命令:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="7a9f" class="mi ks in nn b gy ns nt l nu nv">flutter create flutter_otp</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nw"><img src="../Images/82ef4558d731addc08f48fa3222fd1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhLf2BIah4qg_FaDgGiiHg.png"/></div></div></figure><h2 id="3b30" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">添加依赖关系</h2><p id="8437" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">首先，您需要将以下依赖项添加到<code class="fe nk nl nm nn b">pubspec.yaml</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="d520" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated"><strong class="jm io"> http </strong>包从 web 服务中获取数据。</li><li id="2528" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><strong class="jm io"> flutter_bloc </strong>用于使块和肘易于集成</li><li id="0c2b" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><strong class="jm io">等价的</strong>能够比较<code class="fe nk nl nm nn b">Dart</code>中的对象</li></ul><h2 id="e25b" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">项目结构</h2><p id="9d95" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">我们的项目结构将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/493379edcbbd62395d7c9a5753e0c188.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*HV_bdZQTEksjMYVd8Gr6XA.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">项目结构</figcaption></figure><ul class=""><li id="0559" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">核心包:管理所有项目层共享的所有工具类和组件</li><li id="dd89" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><strong class="jm io">数据</strong>包:它包含领域包(负责创建数据模型类、枚举和 dto)，存储库(负责创建和操作数据。存储库层是一个包装器，包装一个或多个数据提供者(Bloc 层与之通信)和提供者(负责提供数据)。数据提供者必须是通用的。</li><li id="c89c" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><strong class="jm io">逻辑</strong>包:负责管理业务逻辑。这一层可以依赖一个或多个存储库来检索构建应用程序状态所需的数据。</li><li id="38e7" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><strong class="jm io"> ui </strong>包:负责 ui 设计。它应该处理用户输入和应用程序生命周期事件。</li></ul><p id="c958" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从数据层开始，这是最低级别的层，我们的工作方式到表示层。</p><p id="aaee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得我们在本故事的第 1 部分中描述的认证流程吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6236bb12110b28c4235945761c717334.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*et2vpAm_EX9hMPSA.png"/></div></figure><h2 id="521a" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">数据提供者</h2><p id="7708" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">让我们创建我们的第一个提供者类<code class="fe nk nl nm nn b">AuthProvider</code>。这个类与 HTTP 请求交互，以使用我们的 REST API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="40cc" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">贮藏室ˌ仓库</h2><p id="2252" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">转换是在该层中由数据提供者返回的原始数据上完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="926b" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated">业务逻辑层</h2><p id="9ba2" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">现在让我们使用 Bloc/Cubit 将数据发送到 UI。我们需要创建保存我们的<code class="fe nk nl nm nn b">AuthCubit</code>和<code class="fe nk nl nm nn b">AuthState</code>类的文件。</p><ul class=""><li id="be93" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated"><strong class="jm io">认证状态</strong></li></ul><p id="c9db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">UI 将根据它从 Bloc 收到的状态进行更新。</p><blockquote class="mu mv mw"><p id="7d44" class="jk jl mx jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">auth initial—<em class="in">S</em>state 将指示用户尚未采取任何操作，我们应该显示初始 UI <br/> AuthLoading —将显示进度指示器<br/> AuthNetworkError —将显示网络错误消息<br/>AuthError—将显示出错的错误消息<br/>auth success—将显示成功的数据加载指示器<br/> AuthSubmit — <em class="in"> </em>将显示成功提交消息</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="6020" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated"><strong class="jm io"> AuthCubit </strong></li></ul><p id="97da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们实现 AuthCubit，它将运行 AuthRepository 逻辑并发出状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="cdb1" class="mi ks in bd kt mj mk dn kx ml mm dp lb jv mn mo lf jz mp mq lj kd mr ms ln mt bi translated"><strong class="ak">演讲</strong></h2><p id="8e23" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">现在是完成表示层的时候了。我们首先需要为 router 类中的 AuthCubit 提供一个<code class="fe nk nl nm nn b">BlocProvider</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4711" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> login_screen.dart </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ob"><img src="../Images/ffe2045b70a52610bc2590c25dd5b9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmDX_UBKg9dEoWlS7ShtMg.png"/></div></div></figure><p id="6537" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用 BlocListener，它是一个 Flutter 小部件，接受一个 BlocWidgetListener 和一个可选的块，并在块的状态改变时调用侦听器。</p><h1 id="527d" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">决赛成绩</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6858a0168ea78cb371f0201ec99d41bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/1*dym6s-MozB8uVlcp8mObcw.gif"/></div></figure><p id="7e56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这篇文章，请给它一些掌声支持。</p><p id="39ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个项目的代码上传到 Github <a class="ae ki" href="https://github.com/anicetkeric/webflux-otp/tree/main/flutter_otp" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="afc2" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">参考</h1><ul class=""><li id="6bd4" class="lu lv in jm b jn lp jr lq jv od jz oe kd of kh lz ma mb mc bi translated"><a class="ae ki" href="https://bloclibrary.dev/#/" rel="noopener ugc nofollow" target="_blank">https://bloclibrary.dev/#/</a></li><li id="98dd" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><a class="ae ki" href="https://resocoder.com/2020/08/04/flutter-bloc-cubit-tutorial/" rel="noopener ugc nofollow" target="_blank">https://resocoder . com/2020/08/04/flutter-bloc-cubit-tutorial/</a></li></ul></div></div>    
</body>
</html>