<html>
<head>
<title>How to Deploy Spring Boot Application on AWS ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 AWS ECS 上部署 Spring Boot 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-deploy-spring-boot-application-on-aws-ecs-375e8da81a36?source=collection_archive---------3-----------------------#2021-03-21">https://blog.devgenius.io/how-to-deploy-spring-boot-application-on-aws-ecs-375e8da81a36?source=collection_archive---------3-----------------------#2021-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9212" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示如何在 AWS ECS(弹性容器服务)上部署一个 spring boot 应用程序。ECS 是 amazon web 服务之一，主要用于运行应用程序。另一种方法是直接使用 EC2 实例。</p><h1 id="04dc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是 ECS？</h1><p id="346c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">ECS 是一个容器编排服务。ECS 允许您运行您的容器。您还可以使用<a class="ae ll" href="https://aws.amazon.com/ecs" rel="noopener ugc nofollow" target="_blank"> AWS Farget </a>轻松构建 ECS 集群。Farget 消除了供应和管理服务器的需要。使用 ECS 的优势在于，您不必决定使用哪个服务器 EC2 实例，服务会为您决定。它还通过应用程序隔离提高了安全性。</p><p id="d930" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为演示的一部分，我将一步一步地展示如何使用 AWS Fargate 在 ECS 集群上部署 spring boot 应用程序。</p><h1 id="ceb5" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Spring Boot 应用</h1><p id="75b4" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我不会向你展示如何构建一个 Spring Boot 应用程序，但是你可以访问我关于它的其他<a class="ae ll" href="https://betterjavacode.com/programming/spring-boot-application-keycloak" rel="noopener ugc nofollow" target="_blank">帖子</a>。在这个应用程序中，我们将有一个显示待办事项列表的控制器。我们还将使用 MySQL 数据库进行基于表单的身份验证。安全配置中的<code class="fe lm ln lo lp b">config</code>方法如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="a59e" class="ly kj in lp b gy lz ma l mb mc">@Override <br/>protected void configure(HttpSecurity httpSecurity) throws Exception { <br/>     httpSecurity .authorizeRequests() <br/>              .antMatchers("/js/**","/css/**","/img/**").permitAll() <br/>              .antMatchers("/signup","/forgotpassword") .permitAll() <br/>              .anyRequest().authenticated() .and() .formLogin() <br/>              .loginPage("/login") .permitAll() .and() .logout() <br/>              .logoutUrl("/logout") <br/>              .logoutSuccessHandler(logoutSuccessHandler) <br/>              .deleteCookies("JSESSIONID").permitAll().and().csrf(); </span><span id="f3b1" class="ly kj in lp b gy md ma l mb mc">}</span></pre><p id="18ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，正如你在上面看到的，我们将允许任何人访问<code class="fe lm ln lo lp b">signup</code>和<code class="fe lm ln lo lp b">forgotpassword</code>页面。同样，任何人都可以访问登录页面。我们将使用位于登录页面的自定义登录表单。</p><p id="6c2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果用户成功登录，用户将看到一个显示待办事项列表的静态待办事项列表页面。</p><p id="4c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为演示的一部分，我们还将在 AWS RDS 中创建一个 MySQL 数据库。我们在 AWS Fargate ECS 集群中运行的应用程序将访问这个 MySQL 数据库来存储用户和用户验证。</p><h1 id="e50b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">为 Spring Boot 应用程序构建 docker 容器</h1><p id="46fe" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们将创建一个 docker 文件。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="f9f9" class="ly kj in lp b gy lz ma l mb mc">FROM openjdk:8-jdk-alpine COPY ./build/libs/todolist-0.0.1-SNAPSHOT.war todolist-0.0.1-SNAPSHOT.war <br/>ENTRYPOINT ["java", "-jar","todolist-0.0.1-SNAPSHOT.war"]</span></pre><p id="90b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，我们提取 Java 8 映像，并将 war 文件从我们的项目复制到 docker 实例中。我们还定义了入口点。</p><p id="7148" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建 docker 映像的命令</p><p id="5f6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lm ln lo lp b">docker build -t todolist .</code></p><p id="7671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想通过 docker 在本地运行您的应用程序，您可以使用下面的命令:</p><p id="b00a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lm ln lo lp b">docker run -p 8743:8743 todolist</code></p><p id="2fa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，要在 ECS 上部署我们的应用程序，我们需要将这个 docker 映像推送到弹性容器存储库(ECR)。</p><p id="41a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常构建 docker 映像并将其推送到 ECR 都是 CI/CD 的一部分。在这篇文章中，我将不涉及 CI/CD。</p><p id="2a71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要将此 docker 图像推送到 ECR，</p><ol class=""><li id="bbce" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">你需要在你的机器上安装<code class="fe lm ln lo lp b">aws-cli</code> <a class="ae ll" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-windows.html" rel="noopener ugc nofollow" target="_blank">工具</a>。</li><li id="8f50" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">在 ECR 中创建存储库</li></ol><p id="ee05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在命令行上，执行以下命令将 docker 客户端认证到 ECR 存储库</p><p id="ede9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lm ln lo lp b">aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin XXXXXXX.dkr.ecr.us-east-1.amazonaws.com</code></p><p id="2072" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们通过身份验证，我们就可以标记 docker 图像并将其推送到 ECR 存储库。</p><ol class=""><li id="31ea" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">标记 docker 图像— <code class="fe lm ln lo lp b">docker tag IMAGEID XXXXXX.dkr.ecr.us-east-1.amazonaws.com/todolist</code></li><li id="f3f4" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">推送 docker 图像— <code class="fe lm ln lo lp b">docker push XXXXX.dkr.ecr.us-east-1.amazonaws.com/todolist</code></li></ol><p id="4a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们的 docker 图像在 ECR 中。</p><h1 id="d448" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">在 ECS 中部署 docker 映像</h1><p id="2142" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在 ECS 中部署 docker 映像之前，我们必须执行三个步骤。</p><ol class=""><li id="bc1d" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">在 AWS RDS 中创建 MySQL 的数据库实例。创建该实例的配置如下所示:</li></ol><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/f3d1edc55ba8fc14c9c9388d693d454e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*7WPXIars5-cIbkbv"/></div></figure><p id="f278" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.创建数据库后，您将拥有可用的数据库实例服务器和端口，可以使用它们通过数据库管理 UI 或命令行连接到数据库服务器。创建数据库<code class="fe lm ln lo lp b">simplifyingspringsecurity</code>和数据库表<code class="fe lm ln lo lp b">users</code>。</p><p id="b381" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.现在让我们转到 ECS 服务，并为 AWS Fargate 创建一个任务定义。它看起来会像下面这样:</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/27aff73f725eba3e153665748bc4ed25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*DYgYdHwiDsWO-VSh"/></div></figure><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/ae2809a80e6ea8a012485b30ac9f05a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*fbciiy99qN_Ep0Ee"/></div></figure><p id="8a70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，记得事先创建一个 IAM 角色，它应该有一个权限策略“<a class="ae ll" href="https://console.aws.amazon.com/iam/home?region=us-east-1#/policies/arn%3Aaws%3Aiam%3A%3Aaws%3Apolicy%2Fservice-role%2FAmazonECSTaskExecutionRolePolicy" rel="noopener ugc nofollow" target="_blank">amazonectaskexecutionrolepolicy</a>”。在同一个任务定义中，我们必须添加我们的容器和这个容器的属性。它们将如下所示:</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8c1fdc63c82f713979ffae025e1e135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*IP9XAuAtRJ-_nAxX"/></div></figure><p id="2632" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经将主机的两个端口 8743 和 80 映射到容器。在同一个容器中，如果要覆盖数据源的属性，还需要添加环境属性。这些属性包括<code class="fe lm ln lo lp b">spring.datasource.url</code>、<code class="fe lm ln lo lp b">spring.datasource.username</code>、<code class="fe lm ln lo lp b">spring.datasource.password</code>、<code class="fe lm ln lo lp b">spring.datasource.driver-class-name</code>和<code class="fe lm ln lo lp b">spring.jpa.properties.hibernate.dialect</code>。这应该包括我们的任务配置。</p><p id="e886" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.最后，我们将创建一个 ECS 集群，用于运行我们的任务。</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8ecb76ec3ec8d1bfd0367ecfb573775a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*9czVNvl7QZnVLRAl"/></div></figure><p id="62d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，我们选择了基于 AWS Fargate 的集群。在下一步中，您为集群提供一个名称，然后单击“Create ”,这应该会创建一个集群。</p><p id="76d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.配置并运行群集后，我们可以转到“Tasks”选项卡，然后单击“Run new task”。在这里，我们将提供更多的配置，允许我们以某种方式运行我们的任务，以便一旦任务开始运行，我们就可以访问应用程序。</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ms"><img src="../Images/ae2c4b4790862b22dfa828526d4c6375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*rlg57rYT0Khe7UQe"/></div></div></figure><p id="1e36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在这里定义了安全组，但是它还提供了在运行时创建新安全组的选项。在这个安全组中，您应该选择允许访问的协议类型和端口。在这种情况下，我们希望我们的端口 8743 用于互联网和 TCP。现在，单击“运行任务”,这应该会启动任务。任务开始后，我们将能够看到来自云监控的日志，如下所示:</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/adb17bfec308440cc61fe50934682f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*3x7cizWQg45EB3CH"/></div></figure><p id="32b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此基础上，如果您查看日志，现在我们的应用程序正在端口 8743 上成功运行。现在我们可以使用 Fargate 任务提供的公共 IP 访问应用程序。</p><figure class="lq lr ls lt gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/70a7a3f14cf8d78e8991059536e12a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*yh0uv71KBgyMDi2X"/></div></figure><p id="ff51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开始吧，我们已经启动并运行了我们的应用程序。</p><h1 id="9e1b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">学习</h1><p id="4841" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">ECS 可能会因用户在部署应用程序时可以进行的配置数量而变得复杂。<strong class="jm io">为了保持这种简单，只需这样想 AWS Cloud - &gt; VPC - &gt;子网- &gt; ECS - &gt; Fargate - &gt;任务。</strong></p><h1 id="2bc2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="1d32" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这篇文章中，我展示了如何在 AWS ECS 上部署 Spring Boot 应用程序。虽然看起来很简单，但问题在于您可以在 AWS ECS 中进行的配置组合。一旦你理解了云是如何处理私有网络的，事情就变得简单了。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="2016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nh">原载于 2021 年 3 月 21 日</em><a class="ae ll" href="https://betterjavacode.com/aws/how-to-deploy-spring-boot-application-on-aws-ecs" rel="noopener ugc nofollow" target="_blank"><em class="nh">【https://betterjavacode.com】</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>