<html>
<head>
<title>The Decorator Pattern in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的装饰模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-decorator-pattern-in-unity-6791ab10b64?source=collection_archive---------2-----------------------#2022-04-30">https://blog.devgenius.io/the-decorator-pattern-in-unity-6791ab10b64?source=collection_archive---------2-----------------------#2022-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="34bb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">也称为包装</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9d3aab8d533158f72373ae5eaa77b4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*YuUh4CPyUQ7U0BsOuhamnA.png"/></div></div></figure><p id="f740" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看看能力系统，我可以通过添加一个延迟装饰器来使它更加模块化。装饰者将是一种能力，并且有它自己的使用实现。现在它不再重新实现火球术的代码或者继承火球术，而是使用合成来获得一个延迟的能力。所以我们可以延迟任何包含另一个延迟装饰器的能力。</p><p id="81e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我最后得到的是 Runner 指向 Delay Decorator 的一个实例的能力，该实例指向 Fire Ball 能力。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/898eba3f2b9494b56f2ca31d08aa474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*S12LfXYngx-Kj5JDMatTHA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">延迟装饰添加到混合</figcaption></figure><p id="847b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是所谓的装饰模式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/6971973b7da26da8e7c9fc8599bcc614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J7YGANw9kAus-ayXnA27hg.gif"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">作为装饰模式的延迟能力</figcaption></figure><h1 id="aaa4" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">装饰图案已定义</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/7f68a9c8c2767deb2f985bcac36cfb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*PCaDmk9EhFBKiejfyvM1Sw.jpeg"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">装饰图案</figcaption></figure><blockquote class="mj mk ml"><p id="3396" class="ko kp mm kq b kr ks jo kt ku kv jr kw mn ky kz la mo lc ld le mp lg lh li lj ig bi translated">在<a class="ae mq" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>中，<strong class="kq io">装饰模式</strong>是一种<a class="ae mq" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">设计模式</a>，它允许动态地将行为添加到单个<a class="ae mq" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">对象</a>，而不会影响来自同一<a class="ae mq" href="https://en.wikipedia.org/wiki/Class_(computer_science)" rel="noopener ugc nofollow" target="_blank">类</a>的其他对象的行为。<a class="ae mq" href="https://en.wikipedia.org/wiki/Decorator_pattern#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>decorator 模式通常对于遵守<a class="ae mq" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>非常有用，因为它允许在具有独特关注领域的类之间划分功能。装饰器的使用比子类化更有效，因为一个对象的行为可以在不定义一个全新的对象的情况下被增强。</p><p id="4496" class="ko kp mm kq b kr ks jo kt ku kv jr kw mn ky kz la mo lc ld le mp lg lh li lj ig bi translated">来源:<a class="ae mq" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Decorator_pattern</a></p></blockquote><p id="6989" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着它允许用户在不改变现有对象结构的情况下向其添加新功能。这种类型的模式属于结构化模式，因为这种模式充当现有类的包装器。它实现接口并将所有请求转发给它。它还在转发请求之前/之后执行附加功能。作为替代，它们也是适配器模式和门面模式，以它们自己的方式解决问题。装饰模式有时与外观模式结合使用。在 https://w3sdesign.com/?gr=s04<a class="ae mq" href="https://w3sdesign.com/?gr=s04&amp;ugr=struct#" rel="noopener ugc nofollow" target="_blank">的<a class="ae mq" href="https://w3sdesign.com/?gr=s04&amp;ugr=struct#" rel="noopener ugc nofollow" target="_blank"> w3sDesign </a>上阅读更多关于这种模式的内容&amp; ugr=struct# </a></p><p id="8203" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这允许我添加修改或者改变技能的工作方式。</p><h2 id="2b10" class="mr lr in bd ls ms mt dn lw mu mv dp ma kx mw mx mc lb my mz me lf na nb mg nc bi translated">作为抽象类的装饰者</h2><p id="c12c" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">有时候你会看到它是这样实现的。将 decorator 作为从接口继承的抽象类，然后具体的 Decorator 从接口继承。这在这里的例子中可以看到【https://en.wikipedia.org/wiki/Decorator_pattern#C# T4】</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/2619deb34eff3dc6f060319d9b4c0ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nROxYiupuE53JpYcKXFs7g.gif"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">混凝土装饰图案</figcaption></figure><h1 id="b1f1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">履行</h1><h2 id="9f89" class="mr lr in bd ls ms mt dn lw mu mv dp ma kx mw mx mc lb my mz me lf na nb mg nc bi translated">延迟能力</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/6971973b7da26da8e7c9fc8599bcc614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J7YGANw9kAus-ayXnA27hg.gif"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">装饰图案</figcaption></figure><p id="2ebe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我创建了延迟装饰器，让它使用 IAbilty 接口。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5139a01c324965e758582cf2c4b73b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*QGzmolHo42bwUyum3rIvJg.png"/></div></figure><p id="b0e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我让延迟的装饰包含一个责任</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bd3174d137ad2798736ded1ffaf9106d.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*i0W-wn5Ap6i80HNWsdAmrw.png"/></div></figure><p id="f3d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，我需要确保这个能力在构造函数中被设置。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d7c762e0a6d95d4f58086554b8c8102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*XydJIymXNBXAMI9NO0eTag.png"/></div></figure><p id="31eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我实现了可靠性接口。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/003ef82ac8231f8452909d01534ade2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*37bTC0I9UdyVoxSnNWrKxQ.png"/></div></figure><p id="68fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我现在有一个可以使用的延迟装饰能力。在我的能力跑者职业中，我把这个能力设置为火球术，而不是一个包含火球术的新的延迟装饰能力。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/88c6c55c2b69efece143c57843d8c13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*VgJ_4JWzbsxQf1cDIxfUnw.png"/></div></figure><p id="917c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在当我使用火球术的时候，我使用的是延迟术。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/d9f6decbb1481d034503f3b29674fb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VmVyfXSSnq74xthcrxnBDA.gif"/></div></div></figure><h2 id="23c2" class="mr lr in bd ls ms mt dn lw mu mv dp ma kx mw mx mc lb my mz me lf na nb mg nc bi translated">冷却能力</h2><p id="afbb" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">当然，装饰者也可以在能力之后运行代码。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/858fb06dbdb343659c5f0267622478ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*qbl6UCF63JlLsacoYz03CA.png"/></div></figure><p id="3157" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我的狂怒技能要冷却才能使用。</p><pre class="kd ke kf kg gt nq nr ns nt aw nu bi"><span id="6457" class="mr lr in nr b gy nv nw l nx ny">m_currentAbility = new CoolDownDecorator(new RageAbility())</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/ece8e653cf02f2097b7f1851257d6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oxGyDGgZK_KOVk_2unWrUw.gif"/></div></div></figure><h1 id="99cb" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">获取代码</h1><p id="f507" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">和往常一样，这方面的代码可以在我的 Git hub 上找到。</p><p id="fbe6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mq" href="https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-DecoratorPattern" rel="noopener ugc nofollow" target="_blank">https://github . com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-decorator pattern</a></p></div></div>    
</body>
</html>