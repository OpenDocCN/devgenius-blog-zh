<html>
<head>
<title>Article Review: Searching for Build Debt Experiences Managing Technical Debt at Google</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文章评论:搜索构建债务体验在谷歌管理技术债务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/article-review-searching-for-build-debt-experiences-managing-technical-debt-at-google-7851014563ab?source=collection_archive---------12-----------------------#2022-12-25">https://blog.devgenius.io/article-review-searching-for-build-debt-experiences-managing-technical-debt-at-google-7851014563ab?source=collection_archive---------12-----------------------#2022-12-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/1e47dd7e9959ee4e36b08ffa9404d096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aJvHqCsGnkpC5z_c"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">由<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ja" href="https://unsplash.com/es/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">absolute vision</a>拍摄</figcaption></figure><div class=""/><h1 id="8620" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="b326" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">谷歌是世界上最成功的公司之一，它的成功部分是基于它如何很好地利用其资源。在这篇文章评论中，我们将看到“搜索构建债务:在谷歌管理技术债务的经验”一文，作者在文中对他们在谷歌管理技术债务(更具体地说是构建债务)的研究中获得的经验、实践和教训进行了深入分析。我们将讨论这篇文章的发现和意义，以及它对其他组织的意义。</p><h1 id="c159" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是技术债？</h1><p id="68e4" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">技术债务是开发软件时与走捷径相关的成本。当开发人员急于满足最后期限时，或者当他们为了在短期内节省时间而做出可能导致长期问题的决策时，这些债务就会积累起来。作者指出，技术债务是“跨组织的普遍挑战”，并且是软件开发过程中的“必要之恶”。</p><h1 id="530f" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是构建债务？</h1><p id="7148" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在 Google 构建软件的规范被封装在构建文件中。构建文件定义代码模块(在库或二进制级别)，列出模块使用的源文件和依赖库，并包括有关构建项目的附加元数据。它们是手动维护的，这意味着随着时间的推移，这些文件可能会偏离构建、测试和执行软件的实际依赖关系。这些构建文件会导致一些其他问题，我们将进一步讨论这些问题。</p><h1 id="758b" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">谷歌“举债”的方法</h1><ol class=""><li id="88a6" class="lw lx jd la b lb lc lf lg lj ly ln lz lr ma lv mb mc md me bi translated">自动化。只要有可能，修复必须是自动化的</li><li id="6f6b" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">让做正确的事情变得容易。分析编辑、浏览或代码审查过程中的变化，以防止某些类型的债务</li><li id="ca96" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">让做错事变得困难。《出埃及记》防止人们获得不为他人所用的依赖。在编译过程中建立更严格的检查，使它们成为编译时错误</li></ol><p id="f9a0" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">该团队在谷歌没有任何软件或库。所以他们的解决方案是独立于领域的。</p><h1 id="3890" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">依赖债务</h1><p id="1971" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们这里有 3 个主要关键词:</p><ol class=""><li id="a22b" class="lw lx jd la b lb mk lf ml lj mp ln mq lr mr lv mb mc md me bi translated">过度声明的依赖项。这些是您不需要或不使用的依赖项。</li><li id="1f3f" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">未充分利用的依赖关系。这些是你很少用的。</li><li id="e798" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">未声明的依赖项。您正在使用其他依赖项来使用这些依赖项。</li></ol><p id="7a4c" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">让我们再多看看第三个。所以，你的项目名是 A，它依赖于 B and B，依赖于 C。你使用的是 C 中的一个类，但你是从项目 b 中导入的</p><p id="15d0" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">总有一天，项目 B 要依赖项目 C，你的项目就建不起来了！这使得你的项目更加脆弱。</p><figure class="mt mu mv mw gt ip gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/06afeca889e35b29cea573dc33725f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*zvm89udLeMarXzXk6rawbg.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">目标依赖关系</figcaption></figure><h1 id="0a59" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决抚养债务</h1><p id="0db3" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">首先，我们需要开始寻找声明不足的依赖项，并将它们添加为直接依赖项。在本文中，作者使用 javac 编译器通过获取加载类的类路径找到了这些依赖关系。</p><p id="098f" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">第二，我们将找到在第一步之后更容易找到的未使用的依赖项。</p><p id="6d78" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">最后，我们需要找到并消除未被充分利用的依赖项，但是我们不能自动做到这一点，因为一般来说，解决方案是将目标库划分成更小的库。为了解决这个问题，作者创造了一个叫做 Clipper 的工具。</p><h1 id="deb2" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">快速帆船</h1><p id="74e9" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">Clipper 是一个依赖重构助手。它查看依赖关系图，并建议可能成为良好清理候选对象的特定依赖关系。它使用一种排序算法来决定哪种依赖关系比其他的更容易。这些因素是:</p><ol class=""><li id="019f" class="lw lx jd la b lb mk lf ml lj mp ln mq lr mr lv mb mc md me bi translated">目标定义的符号数量:在目标系统或代码库中定义的符号(例如，变量、函数、类)越多，重构它所需的工作就越多。</li><li id="04ee" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">目标的依赖关系的传递闭包中的累积符号数:这是指由目标的依赖关系定义的符号数，以及那些依赖关系的依赖关系，等等。传递闭包中的符号越多，重构工作就可能越复杂。</li><li id="454d" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">符号的利用:如果目标及其依赖项定义的符号在代码库中被大量使用，那么在不破坏系统的情况下重构它们可能会更加困难。</li><li id="b551" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">依赖关系接近度或深度:这是指目标和它的依赖关系之间的“跳”或中间依赖关系的数量。跳跃点越多，重构工作可能就越复杂。</li><li id="b545" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">依赖关系互连性或密度:这是指导致依赖关系的路径总数。如果有许多路径通向一个依赖项，那么在不影响系统其余部分的情况下重构依赖项可能会更加困难。</li></ol><h1 id="fa38" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">僵尸目标</h1><p id="2e57" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">谷歌代码中的一些项目可以被放弃，被遗忘。但即使是这些项目，每个人都可以使用。当这些项目被活动的项目使用时，大多数时候工程师不得不修复无人维护的项目中的错误。为了找到这些僵尸目标，谷歌使用一个系统来寻找:</p><ol class=""><li id="2186" class="lw lx jd la b lb mk lf ml lj mp ln mq lr mr lv mb mc md me bi translated">上次成功构建此目标是什么时候</li><li id="18bd" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">上一次有人试图建立这个目标是什么时候</li></ol><p id="bc0a" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">如果一个目标在至少 90 天内构建失败，它将被声明为死亡，并从代码库中删除。</p><h1 id="2f0a" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">能见度债务</h1><p id="aa3f" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当您可以查看所有其他项目并将它们用作依赖项时，您可以依赖于一个尚未准备好共享或不打算与其他人共享的项目。如果一个项目依赖于你的项目，你不打破他们那边的东西，你是不会知道的。为了解决这个问题，团队决定将所有新项目的默认可见性设为私有，将所有旧项目的可见性设为“遗留公共”。如果一个团队想要使用另一个团队的代码，他们需要讨论并就 API 是否准备好共享以及在什么条件下共享达成一致。</p><p id="4934" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">这在谷歌内部引起了很大的轰动！“这不是谷歌的风格，”他们说。“这将导致大量代码重复，”他们说。“这将导致大范围的建筑损坏，”他们说。但这些都没有发生，他们以最小的戏剧性改变了能见度系统。</p><p id="baf9" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">有趣的事实:尽管有新的默认设置，但近一半的新文件开始时是公开可见的，这提醒了谷歌对开放的态度。</p><blockquote class="mx my mz"><p id="899d" class="ky kz na la b lb mk ld le lf ml lh li nb mm ll lm nc mn lp lq nd mo lt lu lv ig bi translated"><em class="jd">经验教训:任何变革总是会遭到某些人的反对，在一个大型组织中，重要的是要有一个独立的团队，该团队有权根据全球成本效益分析做出决策。</em></p><p id="eadf" class="ky kz na la b lb mk ld le lf ml lh li nb mm ll lm nc mn lp lq nd mo lt lu lv ig bi translated"><em class="jd"> —作者</em></p></blockquote><h1 id="84d1" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">死旗</h1><p id="77c0" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你知道，当你从终端使用 CLI 应用程序时，你使用的选项？当您想要使您的库更加可定制、测试某些东西或进行实验时，您可以添加一些标志。这会导致死代码被添加到库中，这些选项会保护它。有些标志可以删除，有些可以用常量替换。作者组织了一个修复日，工程师们从代码库中移除了 2300 个标志。结果，272，000 行代码也被删除了！</p><h1 id="68da" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="ccec" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">构建债务降低了工程师生产率，导致构建速度变慢，项目更加脆弱，以及维护损坏的库。它还增加了构建、运行和测试项目的成本。</p><p id="8d1d" class="pw-post-body-paragraph ky kz jd la b lb mk ld le lf ml lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">文章的最后建议是:</p><ol class=""><li id="fbb7" class="lw lx jd la b lb mk lf ml lj mp ln mq lr mr lv mb mc md me bi translated">由于许多工程师反对解决技术债务，因为这可能会降低他们的速度或导致代码重复，因此优先考虑和管理它不能总是留给单个团队。</li><li id="cd65" class="lw lx jd la b lb mf lf mg lj mh ln mi lr mj lv mb mc md me bi translated">随着代码库规模的增加，从技术债务中恢复的成本会非线性增加。因此，尽早关注这些债务并投资于工具、政策和流程是至关重要的，这些工具、政策和流程使组织意识到债务，并使其易于作为每个工程师的常规工作流程的一部分不断偿还/避免债务。</li></ol><h1 id="3556" class="ka kb jd bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">参考</h1><p id="fc6f" class="pw-post-body-paragraph ky kz jd la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">原文:<a class="ae ja" href="https://research.google/pubs/pub37755/" rel="noopener ugc nofollow" target="_blank">https://research.google/pubs/pub37755/</a></p></div></div>    
</body>
</html>