<html>
<head>
<title>HTML5 RSS Reader: the Rust API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML5 RSS 阅读器:Rust API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/html5-rss-reader-the-rust-api-15d8300fc034?source=collection_archive---------13-----------------------#2022-05-09">https://blog.devgenius.io/html5-rss-reader-the-rust-api-15d8300fc034?source=collection_archive---------13-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a69838a7539e43fc1384a200a9fa9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lx1OiiQRt5P9gPHN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/es/@julianhochgesang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Julian Hochgesang </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d9c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这个<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">教程</a>中做了很多:了解了原生<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-the-first-web-components-949eec88dbf9"> web 组件</a>，原生 Javascript <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-specialized-web-components-8c8a972e681a">模块导入</a>，CSS 导入和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-shadow-dom-of-an-html5-web-component-d99af7844192">阴影 DOM </a>。我们小心翼翼地创建了一个<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f">反应灵敏的 UI </a>，并赋予它合理的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-filtering-the-custom-list-component-c3ba366c08fd">特性</a>。今天，我们已经到了本系列的末尾，还剩下最后一件事:创建 Rust API 来加载和提供 RSS 内容。</p><p id="0248" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们又做了这个东西<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-threads-and-messages-to-load-data-in-a-gtk4-widget-5e1da3b0621d">在过去</a>对于 GTK4:我必须有一个加载和显示 RSS 内容的东西。设置几乎是一样的:我们向<code class="fe lb lc ld le b">Cargo.toml</code>添加一些依赖项，向<code class="fe lb lc ld le b">main.rs</code>添加 API 函数，我们创建一个 Javascript 服务来使用 Rust API 并在<code class="fe lb lc ld le b">index.js</code>中消费服务。我们走吧。</p><h2 id="b66d" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">在后端处理 RSS</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/0294287add2c6cc3e788fefc85adc6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uiWgH9jvYONNmg76j7gQUw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速浏览项目结构</figcaption></figure><p id="905c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们通过添加<code class="fe lb lc ld le b">rss</code>箱来更新<code class="fe lb lc ld le b">Cargo.toml</code>。我们还需要 JSON 序列化和反序列化，所以我们也包括了<code class="fe lb lc ld le b">serde</code>。我们将使用<code class="fe lb lc ld le b">reqwest</code>来调用 RSS URL，最后，为了简化我们的错误处理，我们将包含<code class="fe lb lc ld le b">anyhow</code>。</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="9ed9" class="lf lg iq le b gy mh mi l mj mk">[package]<br/>name = "html5-rss-reader"<br/>version = "0.1.0"<br/>edition = "2021"</span><span id="715b" class="lf lg iq le b gy ml mi l mj mk">[dependencies]<br/>actix-web = "*"<br/>actix-files = "*"<br/>actix-rt = "*"<br/>rss = "*"<br/>serde = {version = "*", features = ["derive"]}<br/>reqwest = "*"<br/>anyhow = "*"</span></pre><p id="a9bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust 中需要两个模型:一个 feed 模型(在<code class="fe lb lc ld le b">feed.rs</code>中)和一个 article 模型(在<code class="fe lb lc ld le b">article.rs</code>中)。这里是<code class="fe lb lc ld le b">feed.rs</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="edb2" class="lf lg iq le b gy mh mi l mj mk">use serde::{Deserialize, Serialize};</span><span id="fad4" class="lf lg iq le b gy ml mi l mj mk">#[derive(Serialize, Deserialize)]<br/>pub struct Feed {<br/>  pub name: String,<br/>  pub address: String,<br/>}</span><span id="1ada" class="lf lg iq le b gy ml mi l mj mk">impl Feed {<br/>  pub fn get_all() -&gt; Vec&lt;Self&gt; {<br/>    let result = vec![<br/>      Feed {<br/>        name: "The Verge".to_string(),<br/>        address: "https://www.theverge.com/rss/index.xml".to_string()},<br/>      Feed {<br/>        name: "Ars Technica".to_string(),<br/>        address: "https://feeds.arstechnica.com/arstechnica/features".to_string()},<br/>      Feed {<br/>        name: "Hacker News".to_string(),<br/>        address: "https://news.ycombinator.com/rss".to_string()},<br/>    ];</span><span id="775e" class="lf lg iq le b gy ml mi l mj mk">result<br/>  }<br/>}</span></pre><p id="c2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Feed</code>模型还通过<code class="fe lb lc ld le b">get_all</code>函数获取现有的提要。然后，这里是<code class="fe lb lc ld le b">article.rs</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="f146" class="lf lg iq le b gy mh mi l mj mk">use serde::{Deserialize, Serialize};<br/>use rss::Channel;<br/>use serde::{Deserialize, Serialize};</span><span id="cff6" class="lf lg iq le b gy ml mi l mj mk">#[derive(Serialize, Deserialize)]<br/>pub struct Article {<br/>  pub title: String,<br/>  pub summary: String,<br/>}</span><span id="abee" class="lf lg iq le b gy ml mi l mj mk">impl Article {<br/>  pub async fn get_all(address: &amp;str) -&gt; Result&lt;Vec&lt;Self&gt;&gt; {<br/>    let mut result = vec![];<br/>    let response = reqwest::get(address).await?;<br/>    let content = response.bytes().await?;<br/>    let rss = Channel::read_from(&amp;content[..])?;</span><span id="c87e" class="lf lg iq le b gy ml mi l mj mk">for item in rss.items() {<br/>      result.push(Article {<br/>        title: item.title()<br/>          .ok_or(format_err!("No title available"))?<br/>          .to_string(),<br/>        summary: item.description()<br/>          .ok_or(format_err!("No summary available"))?<br/>          .to_string(),<br/>      });<br/>    }<br/> <br/>    Ok(result)<br/>  }<br/>}</span></pre><p id="8669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Article</code>模型还使用<code class="fe lb lc ld le b">get_all</code>函数对提要地址进行<code class="fe lb lc ld le b">GET</code>调用，以获取现有的文章。然后我们在<code class="fe lb lc ld le b">main.rs</code>中构建 REST API 来获取提要和文章:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="f46c" class="lf lg iq le b gy mh mi l mj mk">pub async fn get_feeds() -&gt; Result&lt;HttpResponse&gt; {<br/>  let result = Feed::get_all();<br/>  Ok(HttpResponse::Ok().json(result))<br/>}</span><span id="fda8" class="lf lg iq le b gy ml mi l mj mk">pub async fn get_articles(info: Query&lt;Info&gt;) -&gt; Result&lt;HttpResponse&gt; {<br/>  let result = Article::get_all(&amp;info.feed_address).await<br/>    .or(Err(ErrorExpectationFailed("No address")))?;<br/>  Ok(HttpResponse::Ok().json(result))<br/>}</span></pre><p id="741e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">get_articles</code>函数需要一个<code class="fe lb lc ld le b">info</code>对象来获取我们需要的提要地址，所以让我们创建这个结构:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="a545" class="lf lg iq le b gy mh mi l mj mk">#[derive(Deserialize)]<br/>pub struct Info {<br/>  pub feed_address: String,<br/>}</span></pre><p id="f7f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们通过将 API 函数添加到<code class="fe lb lc ld le b">main</code>中的现有路由中，将它们注册到我们的应用程序路由中:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="718e" class="lf lg iq le b gy mh mi l mj mk">#[actix_rt::main]<br/>async fn main() -&gt; std::io::Result&lt;()&gt; {<br/>  return HttpServer::new(|| {<br/>    App::new()<br/>      .route("/feeds", get().to(get_feeds))<br/>      .route("/articles", get().to(get_articles))<br/>    ---------<br/>}</span></pre><h2 id="46b2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">在 Javascript 中使用 RSS API</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/93a06e06104510623292005393bb5516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2U49cW0JbE1WRHQSk-JNg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速查看前端结构</figcaption></figure><p id="a26c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 的变化更少:我们需要创建一个服务来委托 API 交互。我们将其命名为<code class="fe lb lc ld le b">services.js</code>，并将其放在<code class="fe lb lc ld le b">shared/scripts</code>文件夹中:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="5c46" class="lf lg iq le b gy mh mi l mj mk">export async function getFeeds() {<br/>  const request = await fetch("/feeds");<br/>  const result = await request.json();</span><span id="a67c" class="lf lg iq le b gy ml mi l mj mk">  return result;<br/>}</span><span id="0f6c" class="lf lg iq le b gy ml mi l mj mk">export async function getArticles(address) {<br/>  const request = await fetch(`/articles?feed_address=${address}`);<br/>  const result = await request.json();</span><span id="91c2" class="lf lg iq le b gy ml mi l mj mk">  return result;<br/>}</span></pre><p id="ec9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在<code class="fe lb lc ld le b">index.js</code>中，我们使用<code class="fe lb lc ld le b">services.js</code>来调用 Rust API 进行所有的 RSS 处理。所以我们用两个函数替换硬编码的值:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="724f" class="lf lg iq le b gy mh mi l mj mk">async function updateFeeds() {<br/>  const result = await getFeeds();<br/>  document.getElementById("feeds").setItems(result);<br/>}</span><span id="533d" class="lf lg iq le b gy ml mi l mj mk">async function updateArticles(address) {<br/>  const result = await getArticles(address);<br/>  document.getElementById("articles").setItems(result);<br/>}</span></pre><p id="67fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先调用<code class="fe lb lc ld le b">updateFeeds</code>在页面加载时加载提要，然后在每个提要选择时调用<code class="fe lb lc ld le b">updateArticles</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="81a3" class="lf lg iq le b gy mh mi l mj mk">document.getElementById("feeds").addEventListener("click", async (e) =&gt; {<br/>  document.body.classList.add("feed-selected");</span><span id="4bf4" class="lf lg iq le b gy ml mi l mj mk">  const selection = document.querySelector("#feeds li.selected");<br/>  if (selection) selection.classList.remove("selected");</span><span id="b71a" class="lf lg iq le b gy ml mi l mj mk">  e.target.closest("li").classList.add("selected");<br/>  await updateArticles<br/>    (encodeURIComponent(selection.dataset.address));<br/>});</span></pre><p id="d121" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意事件处理程序是如何在其签名中变成<code class="fe lb lc ld le b">async</code>的。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="e673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是全部了。不幸的是，The Verge 和 Ars Technica 不使用 RSS 作为联合内容系统，只使用黑客新闻。所以你会得到一个错误，只有黑客新闻可以工作。你可以随意使用任何你想要的提要，只要确定它们是 RSS。</p><p id="a18b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在 Github 上找到任何东西，但是我总是建议你写自己的代码，而不是克隆一个库。它让你学得更好，因为你拥有所有代码决策的全部所有权。此外，您在本教程中发现的只是一个建议的架构，请随意在您的项目中进行任何您喜欢的更改。感谢您的阅读，下一篇文章再见！</p></div></div>    
</body>
</html>