<html>
<head>
<title>Typescript optimizes the search of array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript 优化了数组的搜索</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-optimizes-the-search-of-array-98cdefb1b36?source=collection_archive---------6-----------------------#2022-11-12">https://blog.devgenius.io/typescript-optimizes-the-search-of-array-98cdefb1b36?source=collection_archive---------6-----------------------#2022-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1260" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是一些关于<strong class="jm io">在 Typescript 中包含</strong>操作符的想法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed68b80b1c39a3717519fb60eb1f535e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHlHzNesDQcMYOSagVHTqg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">70 年代汽车罕见的设计。蒙特威尔第 375</figcaption></figure><p id="88f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每天我都要面对不同的任务，这些任务都需要妥善解决。</p><p id="1cd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标:付款类型在服务中应该是唯一的。但是当它也出现在附加子服务的实现期间时，它应该被移除并且在主阵列中保持唯一。</p><p id="dfe5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举例来说，假设我们有一个针对不同服务付费的糟糕的算法。</p><p id="f44d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标:我们必须检查已经包含在和<strong class="jm io"> servicePayments 中的两个数组<strong class="jm io">之间可能的匹配。</strong>如果我们发现付款已经包含在主列表中，则将价格设置为 0。</strong></p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="99fb" class="ld le in kz b gy lf lg l lh li">export interface PriceAmount {<br/>  currentAmount: number;<br/>  originalAmount?: number;<br/>}<br/>export interface ServicePayment {<br/>  paymentType: PaymentType;<br/>  priceAmount: PriceAmount;<br/>}<br/>export enum PaymentType {<br/>  <em class="lj">_Visa </em>= "Visa",<br/>  <em class="lj">_Mastercard </em>= "MasterCard",<br/>  <em class="lj">_JSB </em>= "JSB",<br/>  <em class="lj">_MIR </em>= "MIR",<br/>  <em class="lj">_UnionPay </em>= "UnionPay"<br/>}<br/>export interface ChargeIncludedIn {<br/>  code: string;<br/>  paymentType: PaymentType[];<br/>}</span><span id="645e" class="ld le in kz b gy lk lg l lh li">const alreadyIncludedIn: ChargeIncludedIn =<br/> { code: "ABC", paymentType: [ "UnionPay" ]};<br/></span><span id="c9cc" class="ld le in kz b gy lk lg l lh li">private checkPaymentTypeIncluded(charge: ChargeGroup): ChargeGroup {</span><span id="ea0e" class="ld le in kz b gy lk lg l lh li">  if (!charge.alreadyIncludedIn) {<br/>    return charge;<br/>  }<br/>  const servicePayment: ServicePayment[] = <br/>    charge.servicePayments.<strong class="kz io">map</strong>(item =&gt; {<br/>      const { priceAmount } = item;<br/>      return { ...item, priceAmount: { ...priceAmount, curtAmount: 0 } };<br/>    });</span><span id="c338" class="ld le in kz b gy lk lg l lh li">  return { ...charge, servicePayment};<br/>}</span></pre><p id="92b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当前地图没有使用已经包含在数组值中的<strong class="jm io">的迭代。</strong></p><p id="0e44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加正确的逻辑。</p><p id="bd92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须检查已经包含在和<strong class="jm io"> servicePayments </strong>中的 2 个数组<strong class="jm io">之间的可能匹配，将<strong class="jm io"> return </strong>添加到所有<strong class="jm io"> </strong>匹配中是不正确的。</strong></p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="2594" class="ld le in kz b gy lf lg l lh li">    const servicePayment: ServicePayment[] = [];<br/>    for (const item of charge.servicePayments) {<br/>      charge.alreadyIncludedIn.paymentType.<strong class="kz io">map</strong>(includedIn =&gt; {<br/>        if (includedIn.paymentType === item) {<br/>          item.priceAmount.currentAmount = 0;<br/>        }<br/>      });<br/>      servicePayment.push(item);<br/>    }</span></pre><p id="deff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以优化现有数组的迭代算法，使用<strong class="jm io"> forEach </strong>运算符:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="13e8" class="ld le in kz b gy lf lg l lh li">    const servicePayment: ServicePayment[] = charge.servicePayments;<br/>    for (const item of charge.servicePayments) {<br/>      charge.alreadyIncludedIn.paymentType.<strong class="kz io">forEach</strong>(includedIn =&gt; {<br/>        if (includedIn.paymentType === item) {<br/>          item.priceAmount.currentAmount = 0;<br/>        }<br/>      });<br/>    }<br/>    return { ...charge, servicePayment };</span></pre><p id="5d04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将第二个循环和 if 子句结合起来会使代码更容易阅读</p><p id="cb4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">包含运算符的帮助下，可以像这样进行优化。</strong>它允许将数组迭代和条件检查结合在一起:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d27b" class="ld le in kz b gy lf lg l lh li">const servicePayment: ServicePayment[] = charge.servicePayments;<br/>for (const item of charge.servicePayments) {<br/>  if (charge.alreadyIncludedIn.paymentType.<strong class="kz io">includes</strong><br/>    (item.paymentType)) {<br/>    item.priceAmount.currentAmount = 0;<br/>  }<br/>}<br/>return { ...charge, servicePayment};</span></pre><p id="0fb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">包括</strong>是非常简单和有用的运算符，举例来说:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="7468" class="ld le in kz b gy lf lg l lh li">  getDataFromTheService(billiardValue: string): string {<br/>    const billiards = [ "Pool", "Snooker", "Pyramid", "Carom" ];<br/>    if (billiards.<strong class="kz io">includes</strong>(billiardValue)) {<br/>      return this.resolveService(billiardValue);<br/>    }<br/>    return billiardValue;<br/>  }</span></pre><p id="5c37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">箭头方法</strong></p><p id="a4cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种符号帮助我们在实现<code class="fe ll lm ln kz b">filter</code>、<code class="fe ll lm ln kz b">map</code>和其他数组迭代时不需要编写<code class="fe ll lm ln kz b">return</code>表达式。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8078" class="ld le in kz b gy lf lg l lh li">const sampleArray: number[] = [100, 200, 300];</span><span id="5afa" class="ld le in kz b gy lk lg l lh li">// use return and parenthesis for big long logic <br/>const rslt: number[] = sampleArray.map( (num: number) =&gt; {<br/>  return num * 2;<br/>})</span><span id="5e7a" class="ld le in kz b gy lk lg l lh li">// let's make it compact<br/>const result: number[] = sampleArray.map((num: number) =&gt; num * 2 );</span><span id="915a" class="ld le in kz b gy lk lg l lh li">// output: 200, 400, 600</span></pre><p id="72a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试按参数匹配时 if 条件的替代条件:</p><pre class="kj kk kl km gt ky kz lo bn lp lq bi"><span id="d71f" class="lr le in kz b be ls lt l lu li">const combiArray: any = {<br/>  a: [1,2,3],<br/>  b: [4,5],<br/>  c: [6]<br/>};<br/>const getItFor = (item: any) =&gt; combiArray[item] || [];<br/>const resultMatch = (item: any, variant: any) =&gt; getItFor(item).includes(variant);<br/>console.log(resultMatch('a', 1)); // true<br/>console.log(resultMatch('a', 5)); // false</span></pre><p id="8fc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="0ba0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有许多方法可以实现优化或进行重构来减少代码字符串的数量。</p></div></div>    
</body>
</html>