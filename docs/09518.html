<html>
<head>
<title>Unit Tests on Dotnet for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的 Dotnet 单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unit-tests-on-dotnet-for-beginners-5f37ffff86d7?source=collection_archive---------16-----------------------#2022-08-25">https://blog.devgenius.io/unit-tests-on-dotnet-for-beginners-5f37ffff86d7?source=collection_archive---------16-----------------------#2022-08-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b177" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，</p><p id="1aed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将尝试涵盖以下主题。介绍不要太长，开始学吧！</p><blockquote class="ki kj kk"><p id="36f4" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-什么是单元测试？</p><p id="c446" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-为什么我们要写单元测试？</p><p id="7ca9" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-为什么干净的代码对单元测试很重要？</p><p id="032a" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-什么是测试覆盖率？</p><p id="902a" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-什么是模仿？</p><p id="61a5" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-教程。</p></blockquote></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h2 id="a251" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">什么是单元测试？</h2><p id="e007" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">这是最小的测试类型。它有助于测试源代码中最小的一段代码<em class="kl">(最小单元)</em>。通过单元测试，开发人员可以验证源代码的每个单元都按预期工作。</p><p id="4ef1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">让我们看一个单元测试的例子。你有一台笔记本电脑。一个单元测试正在检查你的 type-c 端口是否按预期工作。此外，正在测试您可以将 type-c 端口连接到 type-c 电缆/设备，但不能连接 HDMI 或 VGA 或音频插孔。或者它可以测试您的 type-c 端口在有/没有电池的情况下是否如预期的那样工作。单元测试可以像这样检查你所有的笔记本电脑部件，帮助你的笔记本品牌提供更一致的产品。</em></p><h2 id="b7d6" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">我们为什么要编写单元测试？</h2><p id="8dae" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">编写单元测试是一种很难养成的习惯，一些开发人员不喜欢单元测试。他们大多认为单元测试只是浪费时间，但事实并非如此。单元测试有助于开发人员确保源代码已准备好投入生产。此外，他们对新团队成员也有好处。当一个新成员加入一个团队，并开始工作中的第一个项目时，单元测试有助于对新的变化感到安全。此外，他们还帮助当前团队确保他们在修复 bug 或开发新功能时没有破坏任何东西。最后，在团队中创建一些代码标准是有帮助的。</p><p id="577f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以向<strong class="jm io">构建管道</strong>添加单元测试，并在每次自动部署之前检查一切是否按预期工作。下面是来自构建管道的示例屏幕截图；</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/288ab7eb2f04b6c57f3e8e61dc5bc3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vi2sdKjV5Y71Avutdi2y7Q.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 1: </strong>来自 Azure Devops 的一个样本测试结果。</figcaption></figure><p id="5372" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">任务名称:</strong> VSTest@2</p><h2 id="d488" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">为什么干净的代码对单元测试很重要？</h2><p id="9055" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">干净的代码对于单元测试很重要，因为如果代码是意大利面条式的代码，就很难，有时甚至不可能编写测试用例。这意味着，为了能够编写单元测试，在第一次开发时应该遵循干净代码原则，或者应该重构源代码。</p><p id="6453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">例如，如果</em><strong class="jm io"><em class="kl">Http client</em></strong><em class="kl">类用于函数的 Http 请求，那么一个新的实例</em><strong class="jm io"><em class="kl">Http client</em></strong><em class="kl">对象应该在函数的流程中创建。这意味着，所有的对象都不能在测试文件中被模仿。在这种情况下，为了能够编写单元测试，</em><strong class="jm io"><em class="kl">IHttpClientFactory</em></strong><em class="kl">接口作为依赖注入在这里是正确的选择。</em></p><p id="e79b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着，如果你养成了写测试的习惯，你至少应该在写单元测试的时候重构上面的用法。</p><h2 id="5dd1" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">什么是测试覆盖率？</h2><p id="dd3b" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">测试覆盖率是一个统计数据，它向我们展示了当我们运行测试用例时，检查了多少代码。<em class="kl">例如；你有 2000 行代码，而你的测试用例只检查 500 行代码。这意味着你的测试覆盖率是 25%。更高的测试覆盖率增加了在生产之前发现错误的机会。</em></p><h2 id="8fd3" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated">什么是嘲弄？</h2><p id="ec43" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">单元测试只是测试一段孤立的代码。这意味着，一个单元测试没有调用任何内部的<em class="kl">方法/函数</em>或<em class="kl">第三方端点</em>，但仍然需要这些<em class="kl">方法/函数</em>和<em class="kl">第三方端点</em>。它使用一些<strong class="jm io">假的</strong>(示例)<em class="kl">请求/响应</em>对象在测试用例中使用，它们的名字是模拟对象。</p><p id="9800" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">例如；在下面的示例函数中，该函数从</em><strong class="jm io"><em class="kl">IServiceSample</em></strong><em class="kl">接口中调用</em><strong class="jm io"><em class="kl">Insert</em></strong><em class="kl">方法。但是在测试用例中，不可能调用它，因为单元测试只是试图验证函数的流程。这意味着，为了能够完成函数的流程，单元测试需要一个假调用。对于这种情况，将下面一行代码插入到测试类的构造函数中。这一行写着:如果我调用</em> <strong class="jm io"> <em class="kl">插入</em> </strong> <em class="kl">方法然后返回</em><strong class="jm io"><em class="kl">your-mock-object</em></strong><em class="kl">作为响应。这意味着单元测试实际上不会调用</em> <strong class="jm io"> <em class="kl">插入</em> </strong> <em class="kl">方法。测试假设该方法被函数调用，并返回</em><strong class="jm io"><em class="kl">your-mock-object</em></strong><em class="kl">作为响应。</em></p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="1a24" class="kw kx in ml b gy mp mq l mr ms">_serviceSample.Insert().Returns(<strong class="ml io">your-mock-object</strong>);</span></pre></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><p id="59ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过下面的测试项目来巩固一些主题。示例项目是一个 Azure function 项目，包含以下文件夹和文件。</p><blockquote class="ki kj kk"><p id="9ff0" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-Root/Abstraction/<strong class="jm io">iservicesample . cs</strong></p><p id="5809" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-Root/Services/<strong class="jm io">service sample . cs</strong></p><p id="e430" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-Root/Model/<strong class="jm io">samplefunctionrequest . cs</strong></p><p id="fae6" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">- Root/ <strong class="jm io"> SampleFunction.cs </strong></p></blockquote><p id="8b4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例函数是一个匿名的 HttpTriggered 函数。它通过<strong class="jm io"> IServiceSample.cs </strong>接口使用依赖注入。这些文件的详细信息如下:</p><p id="562d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> IServiceSample.cs </strong></p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="d7f3" class="kw kx in ml b gy mp mq l mr ms">using System.Threading.Tasks;</span><span id="a3ca" class="kw kx in ml b gy mt mq l mr ms">namespace <strong class="ml io">SampleProject.Abstraction</strong><br/>{<br/>   public interface <strong class="ml io">IServiceSample</strong><br/>   {<br/>      Task Insert();<br/>      Task Update();<br/>      Task Delete();<br/>   }<br/>}</span></pre><p id="1d5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提醒:</strong>该界面仅用于展示依赖注入和模仿样本。</p><p id="6a61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ServiceSample.cs </strong></p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="b63c" class="kw kx in ml b gy mp mq l mr ms">using System;<br/>using SampleProject.Abstraction;<br/>using System.Threading.Tasks;</span><span id="2f1d" class="kw kx in ml b gy mt mq l mr ms">namespace <strong class="ml io">SampleProject.Services</strong><br/>{<br/>   public class <strong class="ml io">ServiceSample : IServiceSample</strong><br/>   {<br/>      public async Task Delete()<br/>      {<br/>         throw new NotImplementedException();<br/>      }</span><span id="1e83" class="kw kx in ml b gy mt mq l mr ms">      public async Task Insert()<br/>      {<br/>         throw new NotImplementedException();<br/>      }</span><span id="0e54" class="kw kx in ml b gy mt mq l mr ms">      public async Task Update()<br/>      {<br/>         throw new NotImplementedException();<br/>      }<br/>   }<br/>}</span></pre><p id="15d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提醒:</strong>这个类只是用于测试接口实现。</p><p id="cb06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">samplefunctionrequest . cs</strong></p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="2c43" class="kw kx in ml b gy mp mq l mr ms">namespace <strong class="ml io">SampleProject.Model</strong><br/>{<br/>   public class <strong class="ml io">SampleFunctionRequest</strong><br/>   {<br/>      public string Field1 { get; set; }<br/>      public bool Field2 { get; set; }<br/>      public int Field3 { get; set; }<br/>   }<br/>}</span></pre><p id="3ba1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">samplefunctionrequest . cs</strong>是函数的请求对象。它将被用来通过这个模型模拟和编写一个测试用例。</p><p id="4e39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，示例函数如下所示。</p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="b383" class="kw kx in ml b gy mp mq l mr ms">using System;<br/>using System.IO;<br/>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Extensions.Http;<br/>using Microsoft.AspNetCore.Http;<br/>using Microsoft.Extensions.Logging;<br/>using Newtonsoft.Json;<br/>using SampleProject.Model;<br/>using SampleProject.Abstraction;</span><span id="164b" class="kw kx in ml b gy mt mq l mr ms">namespace <strong class="ml io">SampleProject</strong><br/>{<br/>   public class <strong class="ml io">SampleFunction</strong><br/>   {<br/>      private readonly <strong class="ml io">IServiceSample _serviceSample;</strong></span><span id="1ae0" class="kw kx in ml b gy mt mq l mr ms">      public SampleFunction(<strong class="ml io">IServiceSample serviceSample</strong>)<br/>      {<br/>         <strong class="ml io">_serviceSample = serviceSample;</strong><br/>      }</span><span id="dd88" class="kw kx in ml b gy mt mq l mr ms">   <strong class="ml io">[FunctionName(“SampleFunction”)]</strong><br/>   public async Task&lt;IActionResult&gt; Run(<br/>     <strong class="ml io">[HttpTrigger(AuthorizationLevel.Anonymous, “post”, Route =           “samplefunction”)]</strong><br/>     HttpRequest req,<br/>     ILogger log)<br/>   {<br/>      try<br/>      {<br/>         string stringRequest = await new   StreamReader(req.Body).ReadToEndAsync();<br/>         SampleFunctionRequest request = JsonConvert.DeserializeObject&lt;SampleFunctionRequest&gt;(stringRequest);</span><span id="4e36" class="kw kx in ml b gy mt mq l mr ms">         if (string.IsNullOrEmpty(request.Field1))<br/>         {<br/>            log.LogInformation(“Invalid request object”);<br/>            return new BadRequestResult();<br/>         }</span><span id="c913" class="kw kx in ml b gy mt mq l mr ms">         await _serviceSample.Insert();</span><span id="657c" class="kw kx in ml b gy mt mq l mr ms">         return new OkResult();<br/>      }<br/>      catch (Exception ex)<br/>      {<br/>         log.LogInformation($”Exception = {ex.Message}”);<br/>         return new StatusCodeResult(500);<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f8b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，除了依赖注入之外，一切都准备好测试了。如果函数/项目通过依赖注入有一个服务，该服务应该被添加到项目的启动文件中。欲了解更多信息，请访问此处。</p><p id="40ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> startup.cs </strong>文件如下:</p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="7461" class="kw kx in ml b gy mp mq l mr ms">using Microsoft.Azure.Functions.Extensions.DependencyInjection;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using SampleProject.Abstraction;<br/>using SampleProject.Services;</span><span id="7631" class="kw kx in ml b gy mt mq l mr ms"><strong class="ml io">[assembly: FunctionsStartup(typeof(SampleProject.Startup))]</strong><br/>namespace SampleProject<br/>{<br/>   public class Startup : <strong class="ml io">FunctionsStartup</strong><br/>   {<br/>      public override void Configure(IFunctionsHostBuilder builder)<br/>      {<br/>         <strong class="ml io">builder.Services.AddScoped&lt;IServiceSample, ServiceSample&gt;();</strong><br/>      }<br/>   }<br/>}</span></pre></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><p id="da6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，项目已经准备好接受测试了。此时，我们需要在同一个解决方案下增加一个项目，这个示例的项目类型是<strong class="jm io"> XUnit </strong>。在创建项目之后，应该为函数的测试用例创建一个新的类。在这个示例中，它的名称是<strong class="jm io"> SampleFunctionTests。这个类包括下列对象/接口/测试用例。</strong></p><blockquote class="ki kj kk"><p id="b62d" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-请求模型。<strong class="jm io">(样本函数请求)</strong></p><p id="c57f" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-注入服务。<strong class="jm io"> (IServiceSample) </strong></p><p id="a9d5" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">-日志对象。<strong class="jm io"> (ILogger) </strong></p></blockquote><p id="aa73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>在开始编写测试用例之前，应该将函数 app 作为依赖项添加到测试项目中。因为，嘲讽完一切，我们要从测试用例中调用函数。</p><p id="54f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>为了能够模拟方法/函数，测试项目应该有<strong class="jm io">n 替换</strong>库。可以使用替代库，但本文是基于<strong class="jm io"> NSubstitute。</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/448d6afe9a86a8e2b3220d76576c2f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*MslIdZC-T8yEdw1cwgEHCQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图二:</strong>依赖关系。</figcaption></figure><p id="f69f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在编写任何测试用例之前，应该在测试类中准备好所有的模拟对象。从下面的截图中可以看到这个函数的模拟对象。此外，从 GitHub 存储库中也可以看到它。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mw"><img src="../Images/4604dcf39ee14072f0562b396a44019b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NetKIqUivDurPHF8Do2jBA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 3: </strong>功能模拟图。</figcaption></figure><p id="c51f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在示例函数中，服务方法不返回任何响应。正因为如此，他们才返回<strong class="jm io">任务。Completed </strong>但是如果它们有方法的返回类型，就有可能在括号中添加一个模拟响应对象。它类似于:</p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="3981" class="kw kx in ml b gy mp mq l mr ms">_serviceSample.Insert().Returns(<strong class="ml io">your-mock-object</strong>);</span></pre><p id="cc8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，模仿具有一个/多个参数的函数；</p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="d99a" class="kw kx in ml b gy mp mq l mr ms">_serviceSample.Insert(<strong class="ml io"><em class="kl">Arg.Any&lt;string&gt;(), Arg.Any&lt;int&gt;()</em></strong>).Returns(<strong class="ml io">your-mock-object</strong>);</span></pre><p id="1c3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，单元测试需要一个假的<strong class="jm io"> HttpRequest </strong>对象。单元测试将在测试用例的函数调用中使用它。mock <strong class="jm io"> HttpRequest </strong>对象如下:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b43348b38f7f299658f224a900571d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*DKpopbkYiaVG27ogFCi_5w.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 4: </strong> HttpRequest mock 函数。</figcaption></figure><p id="35c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>我为 sample 函数创建了 3 个测试用例。此外，我在代码中添加了一些注释。我建议你也读一读。</p><p id="8901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个测试用例；</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi my"><img src="../Images/cc352375e888114de65933f42420f2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ublYc-Fg12CEaGXfIGjBrg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 5: </strong>第一个测试用例。</figcaption></figure><p id="3d5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个测试用例；</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mz"><img src="../Images/bdb0057be29b9386925a754d4a2d70dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRoS8ranUVJ1E3fQpJGk6w.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 6: </strong>第二个测试用例。</figcaption></figure><p id="9760" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三个测试案例；</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi na"><img src="../Images/ea718a220ef108d61cc4e92307d768f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*LNFx0YMhQy_RvAJw6_mZDw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 7: </strong>第三个测试用例。</figcaption></figure><p id="dcd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及测试用例是通过 Visual Studio/Visual Studio 代码还是通过以下命令运行；</p><pre class="lv lw lx ly gt mk ml mm mn aw mo bi"><span id="5366" class="kw kx in ml b gy mp mq l mr ms">dotnet test</span></pre><p id="7a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果如下图；</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nb"><img src="../Images/74635f98b94d73cad5d45fb896861917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8Vfw36OtchycI632JQ1OA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><strong class="bd ky">截图 8: </strong>测试结果。</figcaption></figure><p id="01c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使使用这个简单的测试函数，也可以创建更多的测试用例。如果我们通过测试覆盖了高比例的代码，我们就有很大的机会在生产之前发现 bug。但是它仍然不能保证产品没有错误。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><p id="0cc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读文章。要添加任何附加信息或通知我任何错误信息，请使用评论部分或 GitHub。</p><p id="add0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以从<a class="ae mu" href="https://github.com/cinarrtolga/ART-Unit-Tests-on-Dotnet-for-Beginners" rel="noopener ugc nofollow" target="_blank">这里</a>访问样本库。</p></div></div>    
</body>
</html>