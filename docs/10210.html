<html>
<head>
<title>Guide to No-SQL Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非 SQL 存储指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/guide-to-no-sql-storage-57abd2d63ca0?source=collection_archive---------5-----------------------#2022-10-15">https://blog.devgenius.io/guide-to-no-sql-storage-57abd2d63ca0?source=collection_archive---------5-----------------------#2022-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="528d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">LSM 树、SS 表和布隆过滤器</h2></div><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div class="ab gu cl kh"><img src="../Images/57e14235fc04d2998eb0e8691aec21c3.png" data-original-src="https://miro.medium.com/v2/0*TC74y5Ds0Mcp0ZOa"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:<a class="ae ko" href="https://unsplash.com/@robsonhmorgan" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@robsonhmorgan</a></figcaption></figure><p id="6304" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在传统数据库 SQL DB 中，数据以 B 树的形式存储。它使用聚集索引来提高效率。</p><p id="4cab" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这对于处理大量数据来说效率不高或不可扩展。所以没有 SQL DB 不能用。</p><p id="e36e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这些非 SQL 数据库使用的数据结构是日志结构的合并树。</p><h1 id="7182" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">存储的工作原理:</h1><ol class=""><li id="7a2c" class="md me in kr b ks mf kv mg ky mh lc mi lg mj lk mk ml mm mn bi translated">所有写入数据库的数据都被写入磁盘上的 WAL(预写日志)。这是只附加日志，所以它很快。这仅用于在数据库崩溃时恢复数据库。</li><li id="f59a" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">然后将数据添加到 Mem 表中。这是在内存表中-它有键值对。键可以是事务 id，值可以是 JSON、String、HyperlogLog、Geo-Spatial Index 等任何值。</li><li id="fada" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">数据会定期刷新到磁盘。在磁盘上，数据以排序字符串表(SS 表)的格式存储。</li><li id="f51f" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">SS 表根据关键字对数据进行排序。当存储密钥时，它也有时间戳。</li><li id="6c69" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">让我们假设一种情况，其中键值对被刷新到 SS 表 1。假设相同的键值再次出现，它再次刷新到磁盘— SS 表 2。</li><li id="a55a" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">现在我们有相同的关键是 SS 表 1 和 SS 表 2。这些表被周期性地合并以形成紧凑表。</li><li id="ef6f" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">在 MongoDB 和 Cassandra 等不同的数据库中，压缩以不同的方式发生。</li></ol><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0a806b1057fb8e49327cc9055ab30dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*GGWNOx2ofgDvwjWvQhzEeg.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">LST 树-记忆表和 SS 表</figcaption></figure><h1 id="ed17" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">阅读的工作原理:</h1><ol class=""><li id="96c9" class="md me in kr b ks mf kv mg ky mh lc mi lg mj lk mk ml mm mn bi translated">当读取请求到来时，它在 Mem 表中搜索数据。如果存在，则返回。这是超级快的，因为它是从内存中返回的。</li><li id="8882" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">如果不是，则在 SS 表中进行搜索。</li><li id="7491" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">由于键是 SS 表排序，二分搜索法可以使用。</li><li id="19c1" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">现在的问题是，相同的密钥可以被刷新到不同的 SS 表。所以我们需要搜索所有的 SS 表(参考上面的步骤 5 和 6)</li><li id="22cd" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">基于时间戳，可以返回 SS 表中的最新值。</li><li id="cfa9" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">然而，如果需要扫描许多 SS 表，它会减慢搜索速度。</li><li id="1f26" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">为了克服这个问题，每个 SS 表都有布隆过滤器。布隆过滤器是概率数据结构，下面解释。</li></ol><h1 id="67e0" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">布隆过滤器:</h1><p id="9c4d" class="pw-post-body-paragraph kp kq in kr b ks mf jo ku kv mg jr kx ky mu la lb lc mv le lf lg mw li lj lk ig bi translated">布隆过滤器是概率数据结构，具有以下特性</p><ul class=""><li id="87c7" class="md me in kr b ks kt kv kw ky mx lc my lg mz lk na ml mm mn bi translated">如果数据确实不存在，则返回 false。</li><li id="6d1c" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk na ml mm mn bi translated">它可以返回 true，其可能的数据可能存在，也可能不存在。</li></ul><h1 id="9efe" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">布鲁姆过滤器的工作原理:</h1><p id="38c5" class="pw-post-body-paragraph kp kq in kr b ks mf jo ku kv mg jr kx ky mu la lb lc mv le lf lg mw li lj lk ig bi translated">下面是布隆过滤器的简化工作。</p><ol class=""><li id="1f64" class="md me in kr b ks kt kv kw ky mx lc my lg mz lk mk ml mm mn bi translated">假设我们有一个布尔值列表—假设大小为 100。</li><li id="ba6b" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">假设有 4 个散列函数。</li><li id="63ce" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">现在，我们要搜索的键，将使用这些哈希函数进行哈希运算。</li><li id="8490" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">假设这个键被这些散列函数散列，这个散列的值是 10，12，70，81。</li><li id="78ed" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">这些布尔值(在布尔列表中这些索引处)的值将为正。</li><li id="11c7" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">现在让我们说，如果这个键被再次搜索，这个键将被散列为相同的值。</li><li id="7a24" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">假设另一个关键字(用于搜索)散列为 10，51，52，98。</li><li id="9799" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">当 10 存在且为正数时，布隆过滤器将返回数据存在(实际上并非如此)。所以全搜索将发生在这个 SS 表中。</li><li id="7f54" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">假设另一个关键字(用于搜索)散列为 11，71，81，95。</li><li id="c6de" class="md me in kr b ks mo kv mp ky mq lc mr lg ms lk mk ml mm mn bi translated">因为这些都不是正的，它将返回这个值肯定不存在。</li></ol><h1 id="106e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">为了进一步阅读</h1><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7733" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">对于系统设计，机器学习博客在介质上遵循</strong><a class="ae ko" href="https://smverma.medium.com/" rel="noopener"><strong class="kr io">anantech . ai</strong></a><strong class="kr io">。</strong></p></div></div>    
</body>
</html>