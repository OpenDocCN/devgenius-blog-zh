<html>
<head>
<title>Refactoring Redux Reducer with Immer’s Produce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Immer产品重构Redux Reducer</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/refactoring-redux-reducer-with-immers-produce-4d0ef5dc433d?source=collection_archive---------1-----------------------#2020-09-03">https://blog.devgenius.io/refactoring-redux-reducer-with-immers-produce-4d0ef5dc433d?source=collection_archive---------1-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/c68b087d84f1a7c654269fec06b308c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*CViqwsh5fELO2I9FqHI_nQ.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">伊默！</figcaption></figure><div class=""/><p id="1ba2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，这个星期我只是想分享Immer的生产功能，以及我们如何使用它来使我们的Redux减速器看起来更干净。</p><p id="e52c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你使用过Redux，我相信你已经在你的reducer中看到过这种语法…</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c7ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们想要修改一个嵌套的属性时，我们必须使用spread操作符来构造相同的状态，然后一旦我们到达嵌套的属性，在本例中是<code class="fe lc ld le lf b">players</code>，我们就可以进行我们需要的任何更改。</p><p id="d884" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们能像这样直接修改状态不是更好吗？</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c9f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，它会，但是我们不能这样做，因为React和Redux使用不可变的数据类型。基本上，不可变数据是不能改变或变异的数据。因此，每当我们想在React中更改数据时，我们只需给它分配一个全新的对象。</p><p id="ffa0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="cdee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用<code class="fe lc ld le lf b">this.setState</code>时也是如此。当我们在<code class="fe lc ld le lf b">useState</code>和<code class="fe lc ld le lf b">this.setState</code>中使用set函数时，我们正在为state分配一个新的对象。</p><p id="9b2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lg">React之所以使用不可变数据类型，是出于性能的考虑。</em>简单比较对象的引用，而不是比较同一个对象的每个属性，检测变化的效率要高得多。举个例子，如果我们有一个有1000个值的数组，我们直接改变这个数组。如果我们想要检测一个变化，我们必须将旧数组中的每个值与新数组进行比较。</p><p id="72fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们简单地利用不可变的数据类型，并用一个不同的值创建一个新的数组，我们可以很容易地比较对对象的引用，以确定相等或变化。</p><p id="0f93" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为Redux和React使用不可变的数据类型，所以上面我们直接改变状态的例子是行不通的。React不会检测到变化，因为我们直接修改了状态，而不是分配一个新的对象。</p><h1 id="9393" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Immer产品</h1><p id="b2f8" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">这就是为什么我们应该使用Immer的<code class="fe lc ld le lf b">produce</code>功能。<code class="fe lc ld le lf b">produce</code>使我们能够以一种非常干净的方式从一个旧对象创建一个新的变异对象。</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="1c3a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe lc ld le lf b">produce</code>的工作方式。它接受两个参数:第一个是我们想要修改的对象，第二个是“变异”对象的回调函数。产生的结果是一个新的对象，它等于原始对象加上“突变”。</p><p id="bb6e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用基本数组的示例</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="29cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个参数<code class="fe lc ld le lf b">draft =&gt; { draft[0] = 5 }</code>是一个函数，它接收我们传递给它的第一个对象。在函数体内是我们将要执行的突变。在这种情况下，我们只是给索引0赋值5。</p><p id="b1fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用produce，我们可以轻松地为我们的reducer编写case语句，而无需编写一堆嵌套的spread操作符。</p><h1 id="1c88" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">从@reduxjs/toolkit创建Reducer</h1><p id="a934" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">更进一步，我们还可以使用ReduxJS库中的<code class="fe lc ld le lf b">createReducer</code>函数来进一步重构我们的reducer。<code class="fe lc ld le lf b">createReducer</code>函数集成了Immer的<code class="fe lc ld le lf b">produce</code>，允许我们在reducer中直接写状态突变。</p><p id="9d6a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例子</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="1bf2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lc ld le lf b">createReducer</code></p><p id="24c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个参数是我们商店的初始状态。</p><p id="ec80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个参数是一个具有动作类型和匹配的产生函数的对象。</p><p id="4421" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样的，我们为<code class="fe lc ld le lf b">ADD_PLAYER</code>提供的函数很像<code class="fe lc ld le lf b">produce</code>中的回调函数。<code class="fe lc ld le lf b">createReducer</code>唯一不同的是我们还可以传入动作(见<code class="fe lc ld le lf b">ADD_PLAYER_USING_ACTION</code>)。然后在函数体中，我们可以直接突变状态。</p><p id="5438" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的减速器用<code class="fe lc ld le lf b">produce</code>和<code class="fe lc ld le lf b">createReducer</code>不是干净多了吗？</p><p id="a76b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这能对你有所帮助。祝您愉快！</p><h2 id="999b" class="mk li jb bd lj ml mm dn ln mn mo dp lr kj mp mq lv kn mr ms lz kr mt mu md mv bi translated">证明文件</h2><ul class=""><li id="6811" class="mw mx jb ka b kb mf kf mg kj my kn mz kr na kv nb nc nd ne bi translated"><a class="ae nf" href="https://immerjs.github.io/immer/docs/produce" rel="noopener ugc nofollow" target="_blank"> Immer生产</a></li><li id="f2d9" class="mw mx jb ka b kb ng kf nh kj ni kn nj kr nk kv nb nc nd ne bi translated"><a class="ae nf" href="https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns" rel="noopener ugc nofollow" target="_blank"> Redux:结构化Reducers </a>(在底部它讲述了使用@reduxjs/toolkit中的createReducer)</li></ul></div></div>    
</body>
</html>