<html>
<head>
<title>Performance Differences of Java Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 流的性能差异</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/performance-differences-of-java-streams-fdc5a22125cd?source=collection_archive---------0-----------------------#2022-07-18">https://blog.devgenius.io/performance-differences-of-java-streams-fdc5a22125cd?source=collection_archive---------0-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/77bca267759386d40857e2ed6fa7f8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVwN8DH-WYX1pKvv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">利奥·里瓦斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我在开发一个功能，我们最终得到了一个项目集合，每个项目都有一个状态，表明它们是否被成功处理。在应用程序的这个特定部分，我们需要对成功处理的项目执行某些操作，对失败的项目执行其他操作。原始代码如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/16eb86a5625f0e83894a90e897240dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6SY5aPtsp2AKJSj9Fa5RA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">原始解决方案</figcaption></figure><p id="bbac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个变更的<a class="ae kc" href="https://medium.com/geekculture/ideas-on-performing-high-value-code-reviews-385efb94d508" rel="noopener">代码审查</a>期间，讨论出现了关于我们是否仍然可以使用 Java 流，但是只遍历结果集合一次。这让我们写了一些东西，大致如下:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/811361ab3eb5c833775957f25f7c5c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTKqh-l1oRfo7Ja3oST-IA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">按实现分组</figcaption></figure><p id="6ff3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这无疑比最初的解决方案更简洁，并且确实达到了只在输入集合上流过一次的目的。我们也很确定它会更有性能。也就是说，我们认为性能的提高不值得 group by solution 带来的可读性成本。在我的大部分工作中，我几乎总是选择可读性而不是性能。尽管如此，我们对最终的性能差异感兴趣，因此我们决定针对不同集合大小的不同实现运行一个基准测试。结果相当有趣。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Java 11 比较吞吐量结果</figcaption></figure><p id="deef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，对于小集合，group by 实际上比流过列表两次要慢。从我们的测试来看，从双流到更高效的团队的转变发生在 1000 到 50000 个项目之间。知道我们的结果集将总是小于或等于 25，我们不仅决定可读性更好，而且我们给自己信心，我们的原始解决方案无论如何都比组更有性能。</p><p id="ca50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发现这很有趣，我们决定进一步挖掘，看看以前或更新版本的 Java 是否会有不同的结果。这些是我们的结果。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Java 8 和 Java 17 吞吐量结果</figcaption></figure><p id="3f7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这个里面可以扯出很多有趣的东西。首先，在 Java 8 中，group by 实现比双流解决方案更快。我在很多基准测试中看到，Java 8 往往比更高版本的 Java 要快。这感觉落后于我所期望的，但我期望这个故事有更多的内容。另一个有趣的事情是，在 Java 17 中，group by 超过 double stream 的时刻来得更快，因为我们甚至在 1000 个条目的集合中也看到了这一点。我还发现有趣的是，在 1，000，000 个项目的测试中，Java 17 最终在 group by 和 double stream 中获得了相同的性能。因此，在 Java 11 和 Java 17 之间，group by 功能似乎得到了改进。然而，看起来 Java 8 和 Java 11 之间可能会有一些降级。需要进行更多的调查。</p><p id="f20d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想运行的最后一个测试是另一个实现，它根本不使用流，而是只使用常规的旧循环，并在我们的代码中保持更多的控制。该实现如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/f62a88aabf9084c2bca8996177c436ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFA7BOdfkhxU_juwGxit8A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">非流解决方案</figcaption></figure><p id="f494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这仍然不需要太多的代码，但可能需要一些时间来处理它，以了解正在发生的事情。我确实喜欢 streams API，它更具声明性，因此很容易看到正在做什么。那么结果如何呢？</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用非流解决方案的操作/管理系统</figcaption></figure><p id="3e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们其他改进的 2 到 3 倍。内存分配要少得多，我们只循环一次，所以有很多方法这样更好。只是证明你不需要花里胡哨的代码就能让它变得高性能。虽然我发现第一个双系统系统可读性最强，但每个解决方案都有所取舍。你只需要决定什么样的权衡是你最满意的。</p><p id="7ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对代码进行基准测试时，有很多有趣的事情需要学习。虽然我认为人们在担心性能上花费的时间比他们应该花费的时间要多，但是拥有解决这些问题的工具和知识可以让你在工作中获得回报。</p><p id="4ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于测试的 JMH 测试可以在下面的报告中找到。</p><div class="li lj gp gr lk ll"><a href="https://github.com/kylec32/java-streams-groupby-performance-tests" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd ir gy z fp lq fr fs lr fu fw ip bi translated">GitHub-Kyle c32/Java-streams-group by-performance-tests</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz jw ll"/></div></div></a></div><p id="45c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对亚马逊科雷托 17.0.2、亚马逊科雷托 11.0.7 和亚马逊科雷托 8.252.09.2 进行了测试。您的结果可能会有所不同。</p></div></div>    
</body>
</html>