<html>
<head>
<title>Numpy Broadcasting: Looking under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 广播公司:寻找引擎盖下</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/numpy-broadcasting-looking-under-the-hood-64dcfd08cc8c?source=collection_archive---------23-----------------------#2020-07-05">https://blog.devgenius.io/numpy-broadcasting-looking-under-the-hood-64dcfd08cc8c?source=collection_archive---------23-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f2e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单介绍 Numpy 如何在不同大小的数组之间执行计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f17eaa94314e0fd0bd355f96cb0ff20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPPFImz5ZvafZXMgSQiJ8g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Alessandro Cerino 在<a class="ae ky" href="https://unsplash.com/s/photos/radio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8e29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就相同形状的 n 数组之间的算术运算而言，它是无缝的。但是，当我们遇到不同形状的阵列时，我们会陷入困境，了解屏幕后面到底是什么可以让我们免于大量的头脑风暴。</p><p id="b3ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个简短的解释中，我们将从相同形状之间的一些基本算术运算开始，然后是不同形状，然后我们将看到 Numpy 在广播其数组时遵循什么规则。</p><p id="c5cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先来了解一下 Numpy 上下文中的“广播”到底是什么意思。</p><p id="7aad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们想给数组的所有值加 1，那么我们可以用下面的方法来做</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="cde3" class="le lf in la b gy lg lh l li lj">[In]: arr = np.array([1,2,3,4,5])<br/>[In]: arr_ones = np.array([1,1,1,1,1])<br/>[In]: print (arr + arr_ones)</span><span id="f691" class="le lf in la b gy lk lh l li lj">[Out]:[2 3 4 5 6]</span></pre></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><pre class="kz la lb lc aw ld bi"><span id="68b3" class="le lf in la b gy ls lt lu lv lw lh l li lj">[In]: arr = np.array([1,2,3,4,5])<br/>[In]: print (arr + 1)</span><span id="aa94" class="le lf in la b gy lk lh l li lj">[Out]:[2 3 4 5 6]</span></pre><p id="a45b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在后一个示例中，我们在具有不同形状的 ndarrays 之间执行计算，这是通过特性<strong class="jm io">广播</strong>实现的。</p><p id="6320" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，基本上广播试图做的是匹配数组的形状(通过扩展更短的数组)来执行操作。让我们想象一种方式(不是 NumPy 做这件事的确切方式，只是为了更好地理解)—</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/15eafef38aaf63c49cdb33495473856d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*kOON00330dujE8Lv3NN_mQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:向阵列广播数字</figcaption></figure><p id="e8f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，当涉及多维数组之间的操作时，扩展一个较小的数组，直到它匹配较大的数组，就像这样—</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="9be0" class="le lf in la b gy lg lh l li lj">[In]:arr1 = np.array([[0,0,0],<br/>                     [1,1,1],<br/>                     [2,2,2],<br/>                     [3,3,3],<br/>                     [4,4,4]])<br/>[In]:arr2 = np.array([[1],<br/>                      [2],<br/>                      [3],<br/>                      [4],<br/>                      [5]]) <br/>[In]:print(arr1 + arr2)</span><span id="e3dd" class="le lf in la b gy lk lh l li lj">[Out]:[[1 1 1]<br/>       [3 3 3]<br/>       [5 5 5]<br/>       [7 7 7]<br/>       [9 9 9]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0c01951e601b956e529f7d6ae67109b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*6-S88LuaC8KDTHPzSch3yQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:水平广播</figcaption></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="8358" class="le lf in la b gy lg lh l li lj">[In]:arr1 = np.array([[1,2,3],<br/>                      [4,5,6],<br/>                      [7,8,9]])<br/>[In]:arr2 = np.array([[1, 2, 3]]) <br/>[In]:print(arr1 * arr2)</span><span id="5fbe" class="le lf in la b gy lk lh l li lj">[Out]:[[2 4 6]<br/>       [8 10 12]<br/>       [14 16 18]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/d5564f2d0f95bfae9d8720a3c8227634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*u287Az5yeM_ME4BGm-8KJw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:垂直广播</figcaption></figure><p id="0aa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当两个数组具有不同的形状时，上述技术是正确的，但是当元素的数量大致相同时，比如说，(3，1)和(1，3)，扩展两个数组，直到它们具有相同的形状。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="261e" class="le lf in la b gy lg lh l li lj">[In]:arr1 = np.array([[1],<br/>                      [4],<br/>                      [7]])<br/>[In]:arr2 = np.array([[2, 5, 8]]) <br/>[In]:print(arr1 +arr2)</span><span id="da82" class="le lf in la b gy lk lh l li lj">[Out]:[[3 6 9]<br/>       [6 9 12]<br/>       [9 12 15]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/32445829ba3d01a2ba95fa513ec295a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*0GRtMB7CHM4fIMkOGz85vQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:双向广播</figcaption></figure><p id="2912" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们看到的例子遵循一定的规则，这使得广播成为可能。让我们来看看这些规则，以及如果某些阵列不符合这些规则，可以采取什么措施—</p><p id="18ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">*如果数组具有不同的维数，例如(4，)&amp; (4，3)，则在维数较小的数组的左边加 1，在这种情况下，(4，)将变成(1，4)。</p><p id="5046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">*如果数组具有不同的长度，例如(1，4)和(4，3)，并且其中一个数组的长度为 1，则用另一个数组的长度替换 1。这里我们把(1，4)中的 1 换成 4(来自(4，3))得到(4，4)。</p><p id="97db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这两个步骤之后，如果两个数组没有相同的形状，那么我们会得到一个错误，比如(4，4)和(4，3)。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="f439" class="le lf in la b gy lg lh l li lj">[In]:x = np.array([1,2,3,4])<br/>[In]:y = np.array([[0,0,0],<br/>              [1,1,1],<br/>              [2,2,2],<br/>              [3,3,3]])<br/>[In]:x + y<br/>[out]:<br/>-------------------------------------------------------------------<br/>ValueError                    Traceback (most recent call last)<br/>&lt;ipython-input-16-cd60f97aa77f&gt; in &lt;module&gt;<br/>----&gt; 1 x + y<br/><br/>ValueError: operands could not be broadcast together with shapes (4,) (4,3)</span></pre><p id="53ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，这里有一个简单的解决方法-</p><p id="f9f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需转换较小数组的维数。在上面的例子中，(4，)在幕后被转换成(1，4)，但是相反，如果我们把它转换成(4，1)我们自己，并把下一步留给 Numpy 去把它转换成(4，3)(还记得步骤 2 吗？)，那么我们没有错误。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="89c3" class="le lf in la b gy lg lh l li lj">[In]:x = x.reshape(4,1)<br/>[In]:print(x + y)</span><span id="1a3c" class="le lf in la b gy lk lh l li lj">[Out]:[[1 1 1]<br/>       [3 3 3]<br/>       [5 5 5]<br/>       [7 7 7]]</span></pre><p id="8c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述规则可以应用于 ndarray 的任何维度。希望，这将有助于您下次在 Numpy 数组上执行任何操作时，想象屏幕后面的事情是如何进行的。</p><p id="887e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读。</p></div></div>    
</body>
</html>