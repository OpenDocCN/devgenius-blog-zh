<html>
<head>
<title>Is Rust ready for the web yet?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 为网络做好准备了吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/is-rust-ready-for-the-web-yet-9ec38c01dcaf?source=collection_archive---------0-----------------------#2020-12-16">https://blog.devgenius.io/is-rust-ready-for-the-web-yet-9ec38c01dcaf?source=collection_archive---------0-----------------------#2020-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ba8e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">技术构建</h2><div class=""/><div class=""><h2 id="86a5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">铁锈已经成熟 5 年了。但是它准备好构建 web 应用程序了吗？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0c728a4aaf4a11cd0d05e66f449a7fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IUx1MyV9-sIsOlqk"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@sunitalap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zsolt Palatinus </a>拍摄的照片</figcaption></figure><h1 id="427b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">为什么要用铁锈？</h1><blockquote class="lx ly lz"><p id="51bc" class="ma mb mc md b me mf ka mg mh mi kd mj mk ml mm mn mo mp mq mr ms mt mu mv mw ij bi translated">“鉴于我们对 Rust 的依赖，我们需要深入的内部 Rust 专业知识，就像我们对 Java 和其他基础技术一样，”AWS 的开源高管 Matt Asay 说。</p></blockquote><p id="826f" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">Rust 于 2015 年 5 月 15 日发布了第一个稳定版本，这是一种相对较新的编程语言。Rust 的语法与 C++类似，但它可以通过使用借用检查器来验证引用，从而保证内存安全。这意味着它不需要垃圾收集。</p><p id="7233" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">Rust 越来越受欢迎也值得注意。自 2016 年以来，Rust 每年都在 StackOverflow 开发者调查中被选为“最受欢迎的编程语言”。Rust 很快在微软、亚马逊网络服务(Amazon Web Services)和其他科技公司建立了粉丝群。</p><p id="e61a" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">有许多迹象表明 Rust 会继续存在，并帮助我们创造更好的软件和产品。但它准备好创建网络应用了吗？</p><h1 id="5de2" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">用 Rust 构建 API</h1><p id="cc1c" class="pw-post-body-paragraph ma mb iq md b me na ka mg mh nb kd mj mx nc mm mn my nd mq mr mz ne mu mv mw ij bi translated">在他们的网页中，Rust 说它带有命令行、web 汇编、网络和嵌入式内置。在本文中，我将继续讨论网络部分。我们将构建一个带有“Hello World”JSON 响应的简单 API 示例。</p><p id="3043" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">首先，我们需要安装 Rust。我们就跟着锈推荐<code class="fe nf ng nh ni b">rustup</code>。要安装 Rust，只需在 shell 中运行以下命令。如果已经有了就忽略！</p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="163c" class="nn lg iq ni b gy no np l nq nr">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</span></pre><p id="29d5" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">为了构建一个 web 服务器，经过一些研究，我选择使用“<code class="fe nf ng nh ni b">actix</code>”框架。Actix 是一个强大、实用、速度极快的 fast web 框架。鉴于这个描述看起来可能会解决我们的问题(建立一个 API)。用 cargo 创建一个新项目非常简单:</p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="91ba" class="nn lg iq ni b gy no np l nq nr">cargo new myapp<br/>cd myapp</span></pre><p id="5c71" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">在你的项目目录中，你应该有一个<code class="fe nf ng nh ni b">Cargo.toml</code>。这个文件就像 PHP 的<code class="fe nf ng nh ni b">composer.json</code>。这是一个清单，您可以在其中描述项目依赖关系。转到您的<code class="fe nf ng nh ni b">Cargo.toml</code>文件并添加<code class="fe nf ng nh ni b">actix</code>依赖项:</p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="7fcc" class="nn lg iq ni b gy no np l nq nr">[dependencies]<br/>actix-web = "3"</span></pre><p id="ce7e" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">为了检查是否一切正常，web 服务是否响应了我们的请求，让我们在 web 页面上打印经典的“hello-world ”:</p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="125e" class="nn lg iq ni b gy no np l nq nr"><strong class="ni ja">use</strong> actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};<br/><br/>#[get("/")]<br/>async <strong class="ni ja">fn</strong> hello() -&gt; <strong class="ni ja">impl</strong> Responder {<br/>    HttpResponse::Ok().body("Hello world!")<br/>}</span><span id="dab0" class="nn lg iq ni b gy ns np l nq nr">#[actix_web::main]<br/>async <strong class="ni ja">fn</strong> main() -&gt; <strong class="ni ja">std</strong>::io::Result&lt;()&gt; {<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .service(hello)<br/>    })<br/>    .bind("127.0.0.1:8080")?<br/>    .run()<br/>    .await<br/>}</span></pre><p id="ecac" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">在项目目录中找到你的终端，点击<code class="fe nf ng nh ni b">cargo run</code>。</p><p id="79e6" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">该命令将下载所有依赖项，并将代码编译成二进制文件。该应用程序将在端口 8080 上运行，等待请求到达。如果您转到<code class="fe nf ng nh ni b">127.0.0.1:8080</code>，您会在网络浏览器上看到“<code class="fe nf ng nh ni b">Hello world!</code>”。</p><p id="ac9d" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">我们的网络服务器正在工作。现在，正如我之前所说的，让我们得到一个带有相同消息的 JSON 响应。要使用 JSON，我们需要一个额外的依赖项。Serde 允许有效且通用地对 Rust 数据结构进行<em class="mc">序列化和<em class="mc"> de </em>序列化。在您的<code class="fe nf ng nh ni b">Cargo.toml</code>中追加到新的依赖项:</em></p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="e6d4" class="nn lg iq ni b gy no np l nq nr">serde = “1.0.118”</span></pre><p id="4ec3" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">下一步是更改我们的 hello 方法，用 JSON 代替纯文本进行响应:</p><pre class="kp kq kr ks gt nj ni nk nl aw nm bi"><span id="f39f" class="nn lg iq ni b gy no np l nq nr">use actix_web::{get, App, HttpResponse, HttpServer, Responder};<br/>use serde::{Deserialize, Serialize};</span><span id="28f2" class="nn lg iq ni b gy ns np l nq nr">#[derive(Serialize, Deserialize)]<br/>struct MyObj {<br/>    message: String,<br/>}</span><span id="b37d" class="nn lg iq ni b gy ns np l nq nr">#[get("/")]<br/>async fn hello() -&gt; impl Responder {<br/>    HttpResponse::Ok().json(MyObj {<br/>        message: String::from("Hello, world!"),<br/>    })<br/>}</span><span id="4bf3" class="nn lg iq ni b gy ns np l nq nr">#[actix_web::main]<br/>async <strong class="ni ja">fn</strong> main() -&gt; <strong class="ni ja">std</strong>::io::Result&lt;()&gt; {<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .service(hello)<br/>    })<br/>    .bind("127.0.0.1:8080")?<br/>    .run()<br/>    .await<br/>}</span></pre><p id="97d2" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">在这里，我们声明将被返回的 JSON (MyObj)结构，在响应中，我们组成 JSON。main 保持不变，因为它只负责路由和打印方法 hello 给出的响应。</p><h1 id="224a" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="4a02" class="pw-post-body-paragraph ma mb iq md b me na ka mg mh nb kd mj mx nc mm mn my nd mq mr mz ne mu mv mw ij bi translated">这是一个非常基本的例子，一点也不具有挑战性。并不能证明 Rust 适合 web 开发。但我相信这是构建网络应用的必要条件。我知道一些创业公司正在将一些以前用其他语言(PHP、node 等)编写的服务转移到 Rust 等更新的语言上。开始很容易。因为它是一种编译语言，而且是内存安全的，这使得它成为未来开发各种软件的一个很好的工具。</p><p id="3545" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">下次我会试着做一个真正的网络应用。像待办事项列表或类似的东西，使用数据库，post 和 get 请求。构建 web 应用程序所需的所有东西。使用 Rust 很有趣，将来在我的项目中会更频繁地使用它，我很高兴能学到更多。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="0c06" class="pw-post-body-paragraph ma mb iq md b me mf ka mg mh mi kd mj mx ml mm mn my mp mq mr mz mt mu mv mw ij bi translated">[1]<a class="ae le" href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted" rel="noopener ugc nofollow" target="_blank">https://insights . stack overflow . com/survey/2020 #最喜欢最害怕最想要的</a></p><div class="oa ob gp gr oc od"><a href="https://medium.com/dev-genius/building-a-crud-rest-api-with-rust-18e0bcf97d5e" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ja gy z fp oi fr fs oj fu fw iz bi translated">Rust:构建 CRUD REST API</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">了解如何使用 rust 为 CRUD 操作构建 REST API，以及它与其他 web 框架的比较</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ky od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://bargainzon.site" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ja gy z fp oi fr fs oj fu fw iz bi translated">亚马逊产品列表| BargainZon</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">2022 年 11 月 11 日【广泛兼容性】USB-C 转 USB-A 适配器连接 USB C 设备(USB C 线/记忆棒/…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">bargainzon.site</p></div></div><div class="om l"><div class="os l oo op oq om or ky od"/></div></div></a></div></div></div>    
</body>
</html>