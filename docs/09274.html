<html>
<head>
<title>SQL Practice questions — #1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 练习题— #1</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-practice-questions-1-800ed65d99b2?source=collection_archive---------3-----------------------#2022-08-11">https://blog.devgenius.io/sql-practice-questions-1-800ed65d99b2?source=collection_archive---------3-----------------------#2022-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="46bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SQL 练习题的第一部分</p><p id="ba9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决任何 SQL 问题的步骤:</p><ul class=""><li id="0b5a" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">将结果可视化，并反向工作以找到如何实现结果</li><li id="b03c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">分解成小问题(如果有意义，就用 CTE 来解决)</li><li id="28a2" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">记住执行顺序，并尽早过滤掉不需要的记录属性</li><li id="d3da" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">比起内部联接，更喜欢窗口函数。</li><li id="1b33" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">窗口函数非常方便</li></ul><p id="d84a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们解决一些问题。</p><p id="6196" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击此处查看<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-2-f1116b1f5402">第二部</a> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-3-9fd3d6e56058">第三部</a> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-4-e24a6bdb32d4">第四部</a> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-5-456cfb41757a">第五部</a></p><h2 id="77eb" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">问题 1</h2><p id="c71c" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">一家公司的高管感兴趣的是，看看公司各个部门中谁赚的钱最多。一个部门中的<strong class="jm io">高收入者</strong>是指其工资在该部门的<strong class="jm io">前三名中的员工。编写一个 SQL 查询来查找每个部门中的高收入者。以任意顺序返回结果表<strong class="jm io"/>。</strong></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="fdc1" class="kx ky in ma b gy me mf l mg mh"><strong class="ma io">Input:</strong> <br/>Employee table:<br/>+----+-------+--------+--------------+<br/>| id | name  | salary | departmentId |<br/>+----+-------+--------+--------------+<br/>| 1  | Joe   | 85000  | 1            |<br/>| 2  | Henry | 80000  | 2            |<br/>| 3  | Sam   | 60000  | 2            |<br/>| 4  | Max   | 90000  | 1            |<br/>| 5  | Janet | 69000  | 1            |<br/>| 6  | Randy | 85000  | 1            |<br/>| 7  | Will  | 70000  | 1            |<br/>+----+-------+--------+--------------+</span><span id="f3c8" class="kx ky in ma b gy mi mf l mg mh">Department table:<br/>+----+-------+<br/>| id | name  |<br/>+----+-------+<br/>| 1  | IT    |<br/>| 2  | Sales |<br/>+----+-------+</span><span id="3bfd" class="kx ky in ma b gy mi mf l mg mh"><strong class="ma io">Output:</strong> <br/>+------------+----------+--------+<br/>| Department | Employee | Salary |<br/>+------------+----------+--------+<br/>| IT         | Max      | 90000  |<br/>| IT         | Joe      | 85000  |<br/>| IT         | Randy    | 85000  |<br/>| IT         | Will     | 70000  |<br/>| Sales      | Henry    | 80000  |<br/>| Sales      | Sam      | 60000  |<br/>+------------+----------+--------+</span></pre><p id="f420" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>根据每个部门内的工资(从高到低)对员工记录进行排名。选择等级小于 4 的行。</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mj"><img src="../Images/f1fc3cc212741732ff91e960599deca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHe_jBXVUpqhfqVNcdeZpA.png"/></div></div></figure><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="36f1" class="kx ky in ma b gy me mf l mg mh">WITH agg as (<br/>    SELECT departmentId, name, salary, <br/>    DENSE_RANK() OVER (<br/>          PARTITION BY departmentId ORDER BY Salary desc<br/>        ) as r<br/>    FROM Employee<br/>) <br/>select d.Name as "Department", a.Name as "Employee", a.Salary as "Salary"<br/>from agg a <br/>join Department d on a.departmentId = d.Id<br/>where a.r &lt; 4</span></pre><h2 id="ebb8" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">问题 2</h2><p id="1edf" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">编写一个 SQL 查询来报告用户的 id，这些用户在任何一天的第一个和最后一个电话是与同一个人的<strong class="jm io">进行的。无论是打电话的人还是接听电话的人，电话都会被计算在内。返回<strong class="jm io">任意顺序</strong>中的结果表。</strong></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f9c6" class="kx ky in ma b gy me mf l mg mh"><strong class="ma io">Input:</strong> <br/>Calls table:<br/>+-----------+--------------+---------------------+<br/>| caller_id | recipient_id | call_time           |<br/>+-----------+--------------+---------------------+<br/>| 8         | 4            | 2021-08-24 17:46:07 |<br/>| 4         | 8            | 2021-08-24 19:57:13 |<br/>| 5         | 1            | 2021-08-11 05:28:44 |<br/>| 8         | 3            | 2021-08-17 04:04:15 |<br/>| 11        | 3            | 2021-08-17 13:07:00 |<br/>| 8         | 11           | 2021-08-17 22:22:22 |<br/>+-----------+--------------+---------------------+</span><span id="a80f" class="kx ky in ma b gy mi mf l mg mh"><strong class="ma io">Output:</strong> <br/>+---------+<br/>| user_id |<br/>+---------+<br/>| 1       |<br/>| 4       |<br/>| 5       |<br/>| 8       |<br/>+---------+</span><span id="a599" class="kx ky in ma b gy mi mf l mg mh"><strong class="ma io">Explanation:</strong> <br/>On 2021-08-24, the first and last call of this day for user 8 was with user 4. User 8 should be included in the answer.<br/>Similarly, user 4 on 2021-08-24 had their first and last call with user 8. User 4 should be included in the answer.<br/>On 2021-08-11, user 1 and 5 had a call. This call was the only call for both of them on this day. Since this call is the first and last call of the day for both of them, they should both be included in the answer.</span></pre><p id="4b3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>根据来电者和通话日期对表格进行分区。对于每个分区，检查第一行和最后一行是否有相同的接收者，然后该调用者应该在结果集中。在升序和降序中使用 FIRST_VAL 来查找所涉及的调用者的第一个和最后一个值。因为我们在这里进行配对，所以我们需要通过选择呼叫者和接收者的反序来进行配对。</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mr"><img src="../Images/206901f9c67eb1629feee414bfbda06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*485eljOgJdDc-qwZ7KBWEw.png"/></div></div></figure><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="95a8" class="kx ky in ma b gy me mf l mg mh">with cte as<br/>(<br/>    select user_id1,<br/>        first_value(user_id2) over (<br/>          partition by user_id1, date(call_time) order by call_time<br/>        ) as first_call_recp,<br/>        first_value(user_id2) over (<br/>          partition by user_id1, date(call_time) order by call_time desc<br/>        ) as last_call_recp<br/>    from<br/>        (<br/>        select caller_id as user_id1, recipient_id as user_id2, call_time<br/>        from Calls<br/>        union<br/>        select recipient_id as user_id1, caller_id as user_id2, call_time<br/>        from Calls<br/>    ) t<br/>)<br/>select distinct user_id1 as user_id<br/>from cte<br/>where first_call_recp = last_call_recp</span></pre><h2 id="4259" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated"><strong class="ak">问题三</strong></h2><p id="2176" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">编写一个 SQL 查询来报告每对不同的人<code class="fe ms mt mu ma b">(person1, person2)</code>之间的通话次数和总通话持续时间，其中<code class="fe ms mt mu ma b">person1 &lt; person2</code>。返回<strong class="jm io">任意顺序</strong>中的结果表。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="881b" class="kx ky in ma b gy me mf l mg mh"><strong class="ma io">Input:</strong> <br/>Calls table:<br/>+---------+-------+----------+<br/>| from_id | to_id | duration |<br/>+---------+-------+----------+<br/>| 1       | 2     | 59       |<br/>| 2       | 1     | 11       |<br/>| 1       | 3     | 20       |<br/>| 3       | 4     | 100      |<br/>| 3       | 4     | 200      |<br/>| 3       | 4     | 200      |<br/>| 4       | 3     | 499      |<br/>+---------+-------+----------+</span><span id="6694" class="kx ky in ma b gy mi mf l mg mh"><strong class="ma io">Output:</strong> <br/>+---------+---------+------------+----------------+<br/>| person1 | person2 | call_count | total_duration |<br/>+---------+---------+------------+----------------+<br/>| 1       | 2       | 2          | 70             |<br/>| 1       | 3       | 1          | 20             |<br/>| 3       | 4       | 4          | 999            |<br/>+---------+---------+------------+----------------+</span></pre><p id="47ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:因为我们想要对(1，2 == 2，1)求和，所以我们需要根据条件选择值。我们假设该对的第一个数字小于第二个数字。使用 CASE 语句也可以达到同样的效果。</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/34d6b3840399c962f56c33bdbe3462a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSMWSF_aIEwNG_MCBelp2w.png"/></div></div></figure><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2d7c" class="kx ky in ma b gy me mf l mg mh">with sorted_pair as (<br/> select case when from_id &lt; to_id then from_id else to_id end as from_id,<br/>     case when from_id &lt; to_id then to_id else from_id end as to_id,<br/>    duration<br/>FROM Calls<br/>)<br/>select from_id as person1, to_id as person2, <br/> count(1) as call_count, <br/>    SUM(duration) as total_duration <br/>from sorted_pair GROUP BY 1, 2</span></pre><h2 id="aa53" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">问题 4</h2><p id="87c3" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">树中的每个节点可以是以下三种类型之一:</p><ul class=""><li id="ee12" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io">“叶”</strong>:如果节点是叶节点。</li><li id="3a23" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><strong class="jm io">【根】</strong>:如果节点是树根。</li><li id="17ac" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><strong class="jm io">“内”</strong>:如果节点既不是叶节点也不是根节点。</li></ul><p id="3a2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个包含节点及其父节点的表，编写一个 SQL 查询来报告树中每个节点的类型。按升序返回由<code class="fe ms mt mu ma b">id</code> <strong class="jm io">排序</strong>的结果表<strong class="jm io">。</strong></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="276c" class="kx ky in ma b gy me mf l mg mh"><strong class="ma io">Input:</strong> <br/>Tree table:<br/>+----+------+<br/>| id | p_id |<br/>+----+------+<br/>| 1  | null |<br/>| 2  | 1    |<br/>| 3  | 1    |<br/>| 4  | 2    |<br/>| 5  | 2    |<br/>+----+------+</span><span id="5f88" class="kx ky in ma b gy mi mf l mg mh"><strong class="ma io">Output:</strong> <br/>+----+-------+<br/>| id | type  |<br/>+----+-------+<br/>| 1  | Root  |<br/>| 2  | Inner |<br/>| 3  | Leaf  |<br/>| 4  | Leaf  |<br/>| 5  | Leaf  |<br/>+----+-------+</span></pre><p id="38e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:我们使用<strong class="jm io"> CASE </strong>语句来查找类型。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="83e9" class="kx ky in ma b gy me mf l mg mh">SELECT Node, <br/>    case <br/>        WHEN P is NULL THEN 'Root' <br/>        WHEN N NOT IN (select P from tree_nodes GROUP BY P) THEN 'Leaf'<br/>        ELSE 'Inner'<br/>    END<br/>FROM tree_nodes</span></pre><p id="9ad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询愉快！！</p></div></div>    
</body>
</html>