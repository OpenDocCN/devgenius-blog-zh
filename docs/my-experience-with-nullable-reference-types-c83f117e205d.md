# 我使用可空引用类型的经验

> 原文：<https://blog.devgenius.io/my-experience-with-nullable-reference-types-c83f117e205d?source=collection_archive---------1----------------------->

![](img/bc9d5aa43ce720da9ed33e79c5d796b5.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

今天我想分享一下我对 c# 8 版本的一个新特性的想法。著名的“可空引用类型”我在测试中使用它们，现在，我已经有一年的经验了。嗯，我不得不说它们很棒，它们似乎是这个版本的主要创新。

如果您不知道参考类型是什么，请查看下面的[文章](https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/february/essential-net-csharp-8-0-and-nullable-reference-types)。

你想知道为什么我认为这是一个非常好的创新吗？这是因为“空引用”被称为十亿美元的错误:

东尼·霍尔在 2009 年 QCon 伦敦会议上做出如下道歉:

我称之为我的十亿美元错误。这是 1965 年零引用的发明。那时，我正在设计第一个面向对象语言(ALGOL W)的引用综合类型系统。我的目标是确保所有引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法抗拒放入空引用的诱惑，仅仅是因为它太容易实现了。这导致了数不清的错误、漏洞和系统崩溃，在过去的四十年里，这可能造成了数十亿美元的痛苦和损失。

现在，有了处理空引用异常的新工具，为了我们的后代，是时候摆脱这个噩梦了。我有点夸张了:)

## **我使用可空引用类型的经验**

**非真实类型！**

我觉得什么是最重要的？你必须记住，它不是一个真正的类型，就像“int？”或者“布尔？”。与其说是经典，不如说是信息标签。网络类型。这位语言作者的决定可能会导致，而且很可能会导致，一个危险的误解和隐藏的错误。

为什么？即使你声明一个属性为不可空，比如:

```
public string Name{get;set;}
```

。NET 运行库可以在此字段中设置 null。这通常发生在您的应用程序“跨越边界”的时候我的意思是，当你的程序需要离开. NET 的安全环境时。例如，它调用一个数据库，从 REST API 之类的外部世界接收数据，使用一个*旧的或坏的第三方库*。

使用不可空的值类型，可以很好地防范空值。然而，引用类型的情况并不令人满意。如果你有一个不可空的字符串，并且你从 API 收到一个空值，突然之间，空值会像病毒一样在你的系统中流动。通常，会发生一些可怕的事情。在这种情况下，C#运行时*不会像处理传统的不可空类型(int、bool 等)那样帮助你。)*

我相信这个问题会在库级别得到解决，但是现在我们必须更加小心，因为不能保证非空引用属性有时不会得到空值。

下面的代码描述了这个问题:

```
class Entity
{
   public string Name { get; set; }
}var obj = JsonConvert.DeserializeObject<Entity>(“{\”Name\”:null}”);
//after the deserialization you get obj.Name == null.
```

正如我提到的，不幸的是，这种行为与其他真正的可空类型不一致，比如“int？或者“布尔？”。实际上，这类似于使用打字稿。你的运行时不能确保你的代码停留在*安全的一边。*

**POCO 类**

在引入可空引用类型之后，我就如何更改我的 POCO 类进行了实验。通过反复试验，我的班级向这种形式靠拢:

```
class Company
{
   public string Name{get;set;} =String.Empty;
   public string AdditionalInformation {get;set;}=String.Empty;
   public ProjectManager? OptionalProjectManager;
   public Address[] Addresses {get;set;}= new Address[0];
}
```

**解释:**

*名称:*

名称是必需的，所以它总是被赋值为。甚至“字符串。空”是比 null 更合适、更好的值。

*附加信息*

尽管有可能将该属性标记为可空类型，但我确实为它们提供了一个值。它为我节省了几行代码和编写“if guard”的问题，并在将来处理一个潜在的空引用异常。

*可选项目经理:*

它是可选的。我没有一些公司的任何值，也没有合适的默认值。因此，我将它标记为可空类型，并保持原样。

*地址*

空数组几乎比空数组更好。为什么？这是另一篇博文的主题。长话短说——我相信提供一个“缺省”值可能会减少“如果”的数量，这不可避免地会增加*圈复杂度*并导致其他不好的事情。然而，正如我所说的，这个主题是巨大的，我将写另一篇纯粹与“空值”相关的博文。

*旁注—为什么我不使用构造函数*

您可能已经注意到，我没有为我的 POCO 类使用构造函数。是的，这不是一个错误；我很少使用构造函数。

事实上，自从我学会了这种语言结构，我就对它又爱又恨。我真的试着爱上建造者，我知道他们有很多优点，但是维护总是很费力。我花了很多时间和试验来寻找如何将构造函数应用于两个以上字段的类，但我总是放弃。

当我开始使用 ReSharper 的时候，我终于认为我明白了。有了构造函数的半自动生成体，我就可以在任何地方使用它了。然而，任何修改仍然是一种痛苦。

事实上，我曾经对自己使用构造函数的心态感到有点惭愧，它代表了 OOP 范例的一个支柱。尽管如此，我已经习惯了。:)

在空引用类型出现后，我尝试使用构造函数。然而，像往常一样，我没能再次喜欢上它。

相反，对象初始化(伴随我们很多年)是一个超级有用的技术，我很喜欢它。到目前为止，我最不乐意使用构造函数的地方是依赖注入。

## **失踪的霹雳符**

我非常想念声明字段中的 bang 操作符，比如在 Typescript 中。

看看这个例子:

```
class TypescriptClass
{
    requiredField!: string;
}
```

现在不允许在 C#中包含该类，例如:

```
class CSharpClass
{
   string! requiredField;
}
```

相反，您应该在“调用站点”使用 bang 运算符，如下所示:

```
var instance.requiredField!.ToLower();
```

我在 TS 中使用 bang 操作符有过很好的体验，在 C#中有点怀念。也许，在未来。

## **警告与错误**

对于非引用类型，您可以选择编译器指示违反规则的方式:警告或错误。到目前为止，我都是以此为戒。我没有任何确凿的数据，甚至没有强烈的观点。然而，这比一个错误更适合我。

此外，使用 pragma 来禁用空检查并不可耻。在我的一个项目中，我有一个与支付网关相关的代码。它只是由几个类和一个序列化机制组成。由于这是一个旧代码，我不得不花一整天的时间来删除所有的警告。相反，我使用 pragma 来禁用检查，每个人都很高兴。

## **单元测试**

我试图确定空引用类型是如何改变我的单元测试的。我相信它一定会对我的单元测试产生影响。然而，我什么也没发现。也许你有不一样的体验。但是现在，我看不出有什么不同。

## **暗示自己**

将引用类型标记为可空对编译器和我都有帮助。检查数据库中的某一列是否为空对我很有帮助。我知道这只是一个暗示，也许并不完全可靠。然而，它仍然是关于我的程序的少量信息，我能够在没有任何*额外成本*的情况下获得这些信息。

## **结论**

我发现这个新功能总体上很有用，尽管它的具体实现方式可能会引起争议*。可空引用类型非常有用。对于我来说，毫不奇怪，它减少了代码中的空引用异常的数量。毫无疑问，它提高了我的代码质量。*

*将来，我准备像现在一样广泛地使用它，如果你还没有尝试过，我建议你也尝试一下。*