<html>
<head>
<title>Investigating Machine Learning Techniques to Improve Spec Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">研究机器学习技术以改进规格测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/investigating-machine-learning-techniques-to-improve-spec-tests-40e426a571e0?source=collection_archive---------8-----------------------#2022-03-23">https://blog.devgenius.io/investigating-machine-learning-techniques-to-improve-spec-tests-40e426a571e0?source=collection_archive---------8-----------------------#2022-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/17fbc03cfebb425ef417cce88db76f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YtELf3jWeESY2BeP.jpg"/></div></div></figure><p id="1515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本周，我们将展示我们为一般测试目的实现机器学习模型的路线图。</p><p id="0a9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您对人工智能实施的背景或进展感兴趣，请访问以下链接:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h1 id="685b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">问题</h1><p id="3c21" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">当前的 Spec 测试有助于检查提取数据的存在和类型。但是，必须执行特殊测试来检查提取数据的质量。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="7bd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两个标题都存在，它们的出现会是一样的，而且都是<code class="fe mc md me mf b">String</code>类。因此需要对有问题的部分进行特殊的测试，以检查它是否在字符串中包含任何<code class="fe mc md me mf b">http</code>代码。更不用说，这个过程只有在有人注意到的情况下才会发生，而不是原本应该的原始规范。</p><h1 id="2f75" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">背景研究和可用的方法</h1><h2 id="1241" class="mg la in bd lb mh mi dn lf mj mk dp lj kg ml mm ln kk mn mo lr ko mp mq lv mr bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> KNN (k 近邻)算法</a></h2><p id="db85" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">这种算法自 1951 年以来一直存在，并被用于统计分类。它的有效性在于其优雅的简单性。如果你能以数学的方式表达数据的特征，你就能从这些数字中创建一个 n 维向量。</p><p id="e0f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个向量的末端代表 n 维空间中的一个点。这些点的接近程度将定义每个向量行为之间的数学相似性。因此，每一个相似的行为都给了我们将它们分类的机会。</p><p id="7950" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以使用相同的方法对这些点进行分类。对于我们的问题，我们想要利用的是更进一步，即检查各个提取的值是否以与过去提取的数据相同的方式表现。</p><h2 id="8d57" class="mg la in bd lb mh mi dn lf mj mk dp lj kg ml mm ln kk mn mo lr ko mp mq lv mr bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离公式</a></h2><p id="8034" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">这些公式也是很久以前，在 18 世纪通过在欧几里德和毕达哥拉斯的公式之间建立联系而推导出来的。它们在点与点之间的高维距离计算中是必不可少的。这是他们的备忘单:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2b174adc89bc75144bff815ce20fccfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mRG3ukFzydvifqhO.png"/></div></div></figure><p id="3a08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在读者感到困惑之前，让我解释一下这两个概念为什么以及如何重要。我们将为提取的数据覆盖的每个特征，无论是它的类别，还是长度，或者仅仅是它的字母索引；它们都将包含在笛卡尔平面的一维中。</p><p id="57a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个分解它的例子:</p><p id="3fe7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设键<code class="fe mc md me mf b">title</code>在大多数情况下由长度为 7-10 的字符串组成。如果标题是<code class="fe mc md me mf b">SerpApi</code>，向量将是<code class="fe mc md me mf b">[7]</code>。让我们设想一组我们为其训练了一个模型的单个键<code class="fe mc md me mf b">title</code>:</p><pre class="kt ku kv kw gt mt mf mu mv aw mw bi"><span id="ec31" class="mg la in mf b gy mx my l mz na">[<br/>  {<br/>    "title": "SerpApi",<br/>    "type": "API",<br/>    "place": "Austin"<br/>  },<br/>  ...<br/>  {<br/>    "title": "XCompany",<br/>    "type": "X",<br/>	"place": "XXX",<br/>  }<br/>]</span></pre><p id="4ec6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些值将创建一个数据表，例如:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="2d82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象<code class="fe mc md me mf b">Length</code>列中的条目是一行中的单个点。线是一维的。所以我们可以用:<br/> <code class="fe mc md me mf b">d(p,q)=|p-q|</code>。<br/>如果我们想要找到什么是<code class="fe mc md me mf b">XCompany</code>，而没有<code class="fe mc md me mf b">Key</code>列，我们将使用公式将这些值中的每一个与<code class="fe mc md me mf b">8</code>进行比较，取最小值(1-nn)，或 n 个最近邻居(k-nn)的多数情况，并将其分类为<code class="fe mc md me mf b">title</code>。</p><p id="9575" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们重新利用这种说法，并询问<code class="fe mc md me mf b">XCompany</code>是否是一个标题。但是要做到这一点，我们需要用<code class="fe mc md me mf b">not_title</code>重新排列数据表，让所有行的<code class="fe mc md me mf b">Key</code>列中有除<code class="fe mc md me mf b">title</code>以外的内容:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="e50a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们对这里的<code class="fe mc md me mf b">XCompany</code>使用相同的方法，距离最小的点将是<code class="fe mc md me mf b">SerpApi</code>，这表明我们的关键是标题。</p><h1 id="a456" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">加权聚类</h1><p id="b224" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">读者可能会问这将如何证明有用，因为字符串的长度在许多情况下几乎不是一个分类因素。这是机器学习过程发生的地方。</p><p id="1e53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些向量中的每一个都可以用它们的权重向量来调整，每个权重向量从向量 1 开始，并相应地用每个正确和不正确的猜测来调整，从而远离或接近比较向量。</p><p id="2b8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将创建不同的矢量簇，相似的矢量会更靠近，不相似的矢量最终会彼此远离。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3282b372645cb0ad8ee0c08b5c53be29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PT_aGS9yh3FVdmFh.png"/></div></div></figure><h1 id="fcb3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">假设</h1><p id="f63b" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">实现上述技术可用于测试提取数据的质量，并可用于<strong class="jx io">测试任何类型的 JSON 数据</strong>。该过程应按如下顺序进行:</p><ul class=""><li id="a8c6" class="nb nc in jx b jy jz kc kd kg nd kk ne ko nf ks ng nh ni nj bi translated"><strong class="jx io">用</strong>内部的键创建数据库(每个内部键都有其唯一的标识符)</li></ul><pre class="kt ku kv kw gt mt mf mu mv aw mw bi"><span id="1d13" class="mg la in mf b gy mx my l mz na">[<br/>  {<br/>    "title": "SerpApi",<br/>    "text": "Scrape Google Organic Results"<br/>    "usecases": {<br/>                  "text": "Scraping SERP Results"<br/>                  ...<br/>                 },<br/>    ...<br/>  }<br/>  ...<br/>]</span></pre><p id="917d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按键<code class="fe mc md me mf b">text</code>和按键<code class="fe mc md me mf b">usecases</code>-&gt;-<code class="fe mc md me mf b">text</code>将被区别对待:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><ul class=""><li id="a2d4" class="nb nc in jx b jy jz kc kd kg nd kk ne ko nf ks ng nh ni nj bi translated"><strong class="jx io">为每个键创建数据库</strong>(排除 inner_keys 中的相同键名)</li></ul><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="312b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，省略<code class="fe mc md me mf b">usecases__text</code>是为了避免建模混乱。由于我们正在测量该键是否包含已定义的<code class="fe mc md me mf b">text</code>，所以它不会影响整个模型的准确性。我们将对这一估计进行验证。</p><p id="9f56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为每个示例中的每个当前键创建单独的模型</strong>。这个过程应该是一个简单的 Rake 命令</p><p id="348a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">将这些模型整合到 Rspec </strong>内部。测试作为检查质量的改进部分，当整个示例中的<code class="fe mc md me mf b">false</code>响应达到某个统计阈值时，警告开发人员结果有问题，并指出错误确定性较高的有问题的模型。</p><ul class=""><li id="405d" class="nb nc in jx b jy jz kc kd kg nd kk ne ko nf ks ng nh ni nj bi translated">这里提到的统计阈值将通过不同的提取数据进行测试。我们将会看到它是否可以被一般化，或者它是否应该被建议用于每个不同的数据结构。</li></ul><h1 id="ce9c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试和分析结构</h1><ul class=""><li id="04ac" class="nb nc in jx b jy lx kc ly kg nk kk nl ko nm ks ng nh ni nj bi translated">单词级索引(N-gram)以及一般特征</li><li id="00c7" class="nb nc in jx b jy nn kc no kg np kk nq ko nr ks ng nh ni nj bi translated">字符级索引以及不同的一般特征，如提取值的类别、长度等。</li><li id="1376" class="nb nc in jx b jy nn kc no kg np kk nq ko nr ks ng nh ni nj bi translated">句子到字符级索引</li><li id="2f4a" class="nb nc in jx b jy nn kc no kg np kk nq ko nr ks ng nh ni nj bi translated">这个实现是否应该使用第三方库，比如<code class="fe mc md me mf b">Torch</code>(为了跨不同语言和栈的模块化)</li><li id="93a9" class="nb nc in jx b jy nn kc no kg np kk nq ko nr ks ng nh ni nj bi translated">在 Rspec 测试中增加误差的统计误差阈值应该是多少？</li><li id="c959" class="nb nc in jx b jy nn kc no kg np kk nq ko nr ks ng nh ni nj bi translated">在不同的结构化数据中，错误阈值是否应该不同？</li></ul><p id="10a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从将<strong class="jx io"> JSON 写入 CSV 数据表</strong> creator 开始。之后，使这个过程独立于库是很重要的。为此，我们将研究如何将单个模型存储在一个文件中。</p><p id="d999" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单词级索引将是检验这一假设的首选，因为它在以前的博客文章中提到的 ML-Hybrid 解析器中对我们很有价值。</p><h1 id="ee9f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="bda7" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">我要感谢用户的关注，感谢 SerpApi 的聪明人对我的支持。下周，我们将研究如何如上所述创建特定于键的模型。</p><p id="e26f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇博文有用，可以看看我的其他博文。</p><p id="65e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">加入我们的|<a class="ae ms" href="https://twitter.com/serp_api" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ms" href="https://www.youtube.com/channel/UCUgIHlYBOD3yA3yDIRhg_mg" rel="noopener ugc nofollow" target="_blank">YouTube</a>|<a class="ae ms" href="https://dev.to/serpapi/" rel="noopener ugc nofollow" target="_blank">dev . to</a>|<a class="ae ms" href="https://serpapi.hashnode.dev/" rel="noopener ugc nofollow" target="_blank">hash node</a>|<a class="ae ms" href="https://medium.com/serpapi" rel="noopener">ser papi Medium</a>|</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="c905" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nz">原载于 2022 年 3 月 23 日 https://serpapi.com</em><em class="nz">T21</em><a class="ae ms" href="https://serpapi.com/blog/use-machine-learning-to-improve-spec-tests/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>