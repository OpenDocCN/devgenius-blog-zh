<html>
<head>
<title>Angular: core.ts in detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:核心. ts 细节</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-core-ts-in-detail-3a6fc3c5dd7a?source=collection_archive---------11-----------------------#2022-04-25">https://blog.devgenius.io/angular-core-ts-in-detail-3a6fc3c5dd7a?source=collection_archive---------11-----------------------#2022-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5c24b88b0cb10ab876b158435a0d0cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMtMR8jWdqcWpapXg62lpA.png"/></div></div></figure><p id="91af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我正在开发一个具有深度嵌套组件的功能模块。我需要改进组件的渲染。</p><p id="c9ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我想我们开始调试吧。我知道 Angular 中的变化检测是如何工作的，但不确定这个关键字来自哪里，比如<strong class="jx io"> changeDetection、Input、Output、providers、host、selector、entrycomponents、encapsulation 等等..</strong>之后，我发现我们在角度组件中使用的所有这些关键字的定义都在<strong class="jx io"> core.ts </strong>中。</p><p id="b07e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个很常见的问题是<strong class="jx io">组件和指令之间到底有什么区别？</strong></p><p id="cc0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之:组件是一个包含模板的独立指令。</p><p id="bf18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将试图揭开它的神秘面纱，使它更有意义。</p><p id="30a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看 core.ts 中的指令声明</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/5a2ce3ae823c88542902e095d81a7ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*n9qEa4mh5wgZwr5Al2uYSQ.png"/></div></figure><p id="454d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，指令是一个带有输入、提供者、选择器等道具的接口。所以，这就是我们在创建组件装饰器时试图使用的东西。</p><p id="45e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们看看组件声明，如下图所示:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/c7ca5cee9054c25179ef0e04bb3e2dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ewlNeQWPkN6YMMSclESKA.png"/></div></div></figure><p id="e330" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看到组件声明，我们会看到它扩展了指令接口(但是属性是可选的)，这完全取决于用户想要使用哪些属性。</p><p id="8e4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们的组件声明有一个模板(内联 HTML)或 templateUrl(用作外部 HTML 文件)。样式(内联样式)和样式 URL(外部 CSS 文件)也是如此。</p><p id="48f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来是封装属性，它只是一个名为 ViewEncapsulation 的枚举。附上相同的图像。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/44e549406b1a2a84cfeabc3f5f166c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*_Jw80yNFPnbzsyxkvgcVzQ.png"/></div></figure><p id="5f91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后是 changeDetection，它的类型也是一个名为 ChangeDetectionStrategy 的枚举。附上相同的图像。</p><p id="2caa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变更检测本身是一个独立的主题，超出了本文的范围。</p><p id="53b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的一点是，如果你看到组件的定义，视图和组件是不同的，它们并不完全相同。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/44e549406b1a2a84cfeabc3f5f166c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*_Jw80yNFPnbzsyxkvgcVzQ.png"/></div></figure><p id="2ff7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 entry components 属性中，我们尝试处理动态组件，这些组件通常从特性模块中调用。(您可以直接从 Angular 9 Ivy 中的组件调用)，但是如果您已经将应用程序升级到 Angular 9.0 或更高版本，entrycomponents 属性现在已经过时。</p><p id="bccf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望下次有人问你这个问题时</p><p id="abb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们深入研究一下。</p><p id="75f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有没有想过装饰器背后是什么，比如组件、输入和输出？</p><p id="53bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">angular 中的 Decorator 是一个附加了@ like <a class="ae la" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank"> @Component </a>、<a class="ae la" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank"> @Input </a>、<a class="ae la" href="http://twitter.com/Output" rel="noopener ugc nofollow" target="_blank"> @Output </a>、<a class="ae la" href="http://twitter.com/Pipe" rel="noopener ugc nofollow" target="_blank"> @Pipe </a>、<a class="ae la" href="http://twitter.com/Directive" rel="noopener ugc nofollow" target="_blank"> @Directive </a>等的关键字。</p><p id="6952" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看一些装饰器的定义，比如组件、输入和输出(最常用的)。</p><p id="3d69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看到角度分量变化检测，它使用默认值，这意味着如果输入或浏览器事件中有任何变化，它将运行整个变化检测周期。附上相同的图像。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lb"><img src="../Images/b52551552721bf92a9322f42ee8d6b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOJ8YdFlXUrshI53AHutcg.png"/></div></div></figure><p id="dfd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望，在 Angular 的日常 web 开发中，它可以让装饰者的使用变得有意义。</p><p id="d6c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们进一步看看 core.ts 为我们提供了什么服务。</p><p id="0683" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看输入和输出装饰属性。</p><p id="1f12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输入</strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lc"><img src="../Images/1ad45f8b11a2450ef66fb659ace29dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAdLPflzVQhEsI83zzdV-Q.png"/></div></div></figure><p id="c535" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lc"><img src="../Images/1ad45f8b11a2450ef66fb659ace29dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAdLPflzVQhEsI83zzdV-Q.png"/></div></div></figure><p id="dbba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输入和输出装饰器用于组件之间的父子通信。当您的模块中有几个组件时，这是一个很好的实践。否则，建议使用 RxJS 主题，如(BehaviorSubjects，ReplaySubject，AsyncSubject，Subject)。</p><p id="521d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通常使用 HostBinding 和 HostListener 作为指令来监听一些事件并对它们做出反应。你有没有想过引擎盖下装的是什么？</p><p id="178b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">主机绑定&amp;主机监听</strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/62afaa109b3db128c3dc0f4ab0c3f69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_wuBl-1BVeNq2JLAGKuSw.png"/></div></div></figure><p id="2d68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<a class="ae la" href="http://twitter.com/HostBinding" rel="noopener ugc nofollow" target="_blank"> @HostBinding </a>装饰器来绑定元素周围的一些属性。先说一个边框样式，背景颜色等。</p><p id="b4c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦绑定完成，我们就考虑应该完成绑定的事件，这时<a class="ae la" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@ host listener</a>decorator 就出现了。附件是我们如何使用主机绑定和主机侦听器的图像。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/0b89cc9b4f050001e7eed4d3a909e3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*tCIk79F8fhNGhb3ZFP8qMQ.png"/></div></figure><p id="06f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续，让我们看看<a class="ae la" href="http://twitter.com/Pipe" rel="noopener ugc nofollow" target="_blank"> @Pipe </a>装饰师。</p><p id="6295" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">管道</strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/2bc99946c697f856f5e23d07416279e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnpXx0Ibeb_zC4PF31Cz1Q.png"/></div></div></figure><p id="fe89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">管道装饰器用于将转换应用于接收到的输入值。它有两个属性，叫做名字和纯粹。</p><p id="4874" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">pure 是布尔类型的。可以认为它是一个纯函数和不纯函数。这同样适用于 Angular。</p><p id="59ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">纯功能</strong></p><p id="398f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输入参数值决定了输出。就像每一个相同的输入，我们得到相同的输出。可以共享结果，而不会改变结果。</p><p id="424b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">不纯</strong></p><p id="93bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在不纯函数的情况下，不能提供相同的保证。内部状态可以从外部改变，这就是为什么我们不能分享它。</p><p id="d06c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们继续吧。</p><p id="62a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> NgModule </strong></p><p id="4c39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们都使用过根模块或特性模块，但是你看到了吗，所有的模块都提供了什么。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/89c25b191cc4a1dcc27588c71c6758c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4JoPxQwyU6yrJ8Krn8gEA.png"/></div></div></figure><p id="df5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看到 NgModule 声明，我们就有了注入服务的 prop 提供者和指令。</p><p id="df45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">声明属性，我们用它来添加组件。</p><p id="b699" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当试图处理 angular 中的动态组件时，entrycomponents 属性可以在组件级或模块级使用。</p><p id="4521" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，注射服务。让我们看看它在引擎盖下包含了什么。</p><p id="5394" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">服务</strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/d7bf5b03fa4ee5fbe60ae2ab146c8a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoL6YfgsEqkj8liiU03T_A.png"/></div></div></figure><p id="66be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">povidedIn prop，我们希望在此注入此服务。它有三个价值。</p><ol class=""><li id="329c" class="li lj in jx b jy jz kc kd kg lk kk ll ko lm ks ln lo lp lq bi translated">root:大多数 app 中的应用级注入器。该服务在整个应用程序中只有实例。</li><li id="49a3" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated">平台:页面上所有应用程序共享的特殊单例平台注入器。</li><li id="d211" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated">any:在每个延迟加载的模块中提供一个唯一的实例，而所有急切加载的模块共享一个实例</li></ol><p id="113a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看其他道具，如使用类，使用现有的，等等。</p><p id="43ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提供者的 prop 有两个名为 provide 和 useClass 的属性。如果我们有相同的名字，提供者充当一个简写。<br/>那么，问题是我们什么时候可以使用 useClass 或 useExisting。</p><p id="7e5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们知道不同的阶层可以提供相同的服务。让我们看看这个例子。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/a24f36327189971186fa3bcfea6722ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SzfiDU-UW8nMp7CZ4MC1w.png"/></div></div></figure><p id="f303" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图像描述是不言自明的。</p><p id="606c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设一个旧组件依赖于 OldLogger 类。OldLogger 和 NewLogger 有相同的接口，但是由于某种原因，你不能更新旧的组件来使用它。</p><p id="fc80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当旧组件用 OldLogger 记录消息时，您希望 NewLogger 的单例实例来处理它。在这种情况下，当一个组件请求新的或旧的记录器时，依赖注入器应该注入那个单例实例。OldLogger 应该是 NewLogger 的别名。</p><p id="6d1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你试图用<strong class="jx io"> useClass </strong>将 OldLogger 别名为 NewLogger，你的应用程序中会出现两个不同的 NewLogger 实例。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/ebbcda4ab8a4113e24e972b302b45f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcUsEnPwO7P2aXcybbXYsg.png"/></div></div></figure><p id="c326" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免这两种情况，我们可以使用现有的道具。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/9ed647be97a74c71a3f88bfb7e7d44f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NplUnT_wR3HQcxetISw9AA.png"/></div></div></figure><p id="258d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们都将 viewchild 或 contentchild 用于 DOM 操作，作为 HTML 元素上的引用，并使用它。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/77cca8652ee0860d97eb815c9d7b5e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZl0fEmK13AwYx42GscsTA.png"/></div></div></figure><p id="d4e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看到 ViewChild 使用查询接口，它使用单个元素引用，但是如果你想使用多个引用，我们使用 ViewChildren。</p><p id="737a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望，你可能知道更多关于 angular 中的 core.ts 的细节和它的用途。</p><p id="61b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要学习的领域很多。我刚刚介绍了在我们的日常开发中经常使用的 Angular。</p><p id="7162" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码。不断学习。继续探索。😊</p></div></div>    
</body>
</html>