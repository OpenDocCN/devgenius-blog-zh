<html>
<head>
<title>What do Redux Middlewares even do? What is Thunk doing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux 中间件到底是做什么的？Thunk 在做什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-do-redux-middlewares-even-do-what-is-thunk-doing-35bd3297659?source=collection_archive---------31-----------------------#2020-06-24">https://blog.devgenius.io/what-do-redux-middlewares-even-do-what-is-thunk-doing-35bd3297659?source=collection_archive---------31-----------------------#2020-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/2a5f9c78bd1d7d1213c55982e53cef37.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*VzqH0IpgdcBnOjobOUYPQg.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">Redux！</figcaption></figure><div class=""/><p id="3975" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想使用 Redux 完全控制应用程序的状态，您需要很好地理解 Redux 中间件。它们到底是如何工作的？如何创建自己的中间件来处理不同的操作？例如，如何创建一个中间件来处理 WebSocket 连接以及它从该连接接收的数据？为什么我们甚至需要中间件？例如，我们不能只写出组件中所有额外的逻辑吗？</p><p id="192b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博文中，我们将回答其中的一些问题。我们将(1)演示中间件到底做什么，以及(2)剖析 Thunk 是如何工作的。(Thunk 是一个中间件，它允许我们调度函数，而不是简单的对象。它通常用于处理异步逻辑。)</p><h2 id="7fbe" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">第一，Redux。</h2><p id="34a4" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">Redux 是一个 JS 包，用于管理应用程序的状态。Redux 将应用程序的状态组织到一个集中的地方，即 Redux store。React 组件可以连接到存储并将存储的状态“映射”到组件。为了用新信息更新商店的状态，我们“分派”动作。该动作被发送到缩减器，缩减器使用该动作来更新存储状态。更新后的状态会导致连接到存储的组件也进行更新。</p><p id="d4f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是常见的行动派遣:</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="005d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么中间件是做什么的呢？<strong class="jx iz">中间件让我们能够为商店的配送方式增加额外的功能。例如，Thunk 中间件允许我们分派一个函数而不是一个对象。在这个函数中，我们可以指定额外的逻辑，通常是异步逻辑。</strong></p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9f69" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们分派的动作不再仅仅是传递给 reducer 的简单对象。该操作将从 API 中获取一些数据，并使用这些数据来分派要减少的对象。有更多的逻辑需要处理。</p><h2 id="d951" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">那么 thunk 是如何允许我们分派函数的呢？中间件是做什么的？</h2><p id="85c0" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">中间件通过<strong class="jx iz">将 store.dispatch 方法设置为具有额外逻辑的新包装分派方法，从而允许额外的功能。</strong>当我们使用中间件包装分派功能的时候，<strong class="jx iz"> </strong>任何被分派的动作都“经过”中间件。</p><p id="68e6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们应用中间件时，这基本上会发生:</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ecc4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"><em class="lx">middleware 实际上接受存储，存储返回一个接受分派的函数。接受存储还允许我们访问中间件中的存储属性，如 store.getState()。</em>T9】</strong></p><p id="69d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些看起来就像这样:</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f745" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">所以，中间件只是一个接受商店和商店的调度函数(在嵌套函数中)并返回一个包装好的调度函数的函数！！！！！当我们应用中间件时，我们本质上是将商店的分派设置为等于中间件的包装分派功能。</strong></p><p id="3a87" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">(我描述的是 applyMiddleware 的‘猴子补丁’版本。在 Redux 文档中，applyMiddleware 不修改存储的分派方法，而是使用新的分派方法返回存储的副本。查看</em> <a class="ae ly" href="https://redux.js.org/advanced/middleware" rel="noopener ugc nofollow" target="_blank"> <em class="lx">文档</em> </a> <em class="lx">了解更多详情…) </em></p><h2 id="6e11" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">让我们看一个简单的中间件例子。</h2><p id="2456" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">对于每个被分派的动作，logger 中间件记录该动作，使用传递的分派调用 dispatch(action ),并且将新的状态记录到控制台。</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8195" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们调度一个操作时，它将调用包装的调度操作—它将 console.log 该操作，使用旧的调度将该操作减少到新的状态，console.log 更新的状态。</p><h2 id="c9ec" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">我们如何在 React 应用程序中实际应用中间件？</h2><p id="f056" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在我们的应用程序中，我们没有通过“猴子修补”store.dispatch 方法来应用我们的中间件。我们在商店创建期间使用 applyMiddleware()来应用我们的中间件。</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="91d4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> applyMiddleware()将使用中间件返回一个带有包装分派方法的新商店。</strong></p><p id="d9b6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住，store . dispatch = logger(store)(dispatch)不完全是 applyMiddleware 做的事情。有关 applyMiddleware 的更多详细信息，请查看文档。<a class="ae ly" href="https://redux.js.org/advanced/middleware" rel="noopener ugc nofollow" target="_blank">https://redux.js.org/advanced/middleware</a></p><h2 id="224c" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">应用多个中间件…</h2><p id="defd" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当我们应用多个中间件时，每个后续的中间件都被应用到来自前一个中间件的包装分派方法。<strong class="jx iz">每一个后继中间件都封装了前一个中间件返回的调度方法。</strong></p><p id="e844" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着，当我们分派任何动作时，该动作会通过每个中间件，直到被 reducer 处理。我们将添加另一个非常简单的中间件来演示中间件的“链接”。</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="43f0" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">中间件执行顺序与中间件应用程序顺序。</h2><p id="7946" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">中间件应用的顺序:<br/> 1。记录器包装 origDispatch = &gt;创建 wrappedDispatch <br/> 2。logger2 包装 wrappedDispatch = &gt;创建 wrappedDispatch2</p><p id="e5f9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:applyMiddleware()中的第一个参数在第二个参数之后应用。第一个参数是外部中间件。</p><p id="5386" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">中间件的执行:<br/> -当我们运行 store.dispatch(action)时，<strong class="jx iz"> action </strong>被传递给外部中间件<strong class="jx iz"> logger2 </strong>。<br/> -当<strong class="jx iz">记录器 2 </strong>调用<strong class="jx iz">下一个(动作)</strong>时，<strong class="jx iz">动作</strong>传递给<strong class="jx iz">记录器。</strong> <br/> -当<strong class="jx iz">记录器</strong>调用<strong class="jx iz">下一个(动作)</strong>时，<strong class="jx iz">动作</strong>被传递到<strong class="jx iz">存储器</strong>，减速器逻辑被执行。</p><p id="e4b6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个存储创建(applyMiddleware(logger2，logger))中，中间件参数的顺序表示中间件执行的顺序。</p><p id="e8d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调度一个动作的完整结果:<br/> 1。日志“我希望这个先启动。”<br/> 2。下一个(动作)= &gt;将动作传递给下一个中间件(记录器)<br/> 3。日志【调度】&lt;动作 _ 对象&gt; <br/> 4。旧调度(动作)触发— reducer 将动作和状态合并成新状态<br/> 5。日志“下一状态”&lt;状态 _ 对象&gt;</p><h1 id="b756" class="lz ku iy bd kv ma mb mc ky md me mf lb mg mh mi le mj mk ml lh mm mn mo lk mp bi translated">分解 Thunk:</h1><p id="e14e" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在我们已经了解了中间件的功能，我们可以看看 thunk 中间件，看看它是如何允许我们处理异步逻辑的。下面是 thunk 中间件的样子。(我去掉了一些不常用的多余论点。查看<a class="ae ly" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> repo 到实际 thunk 代码。</a>)</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a8ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">如果我们调度的动作是函数，则执行 store.dispatch 中传递的动作，如果动作不是函数，则将动作传递到下一个中间件</strong>或 reducer(如果 thunk 是最后一个中间件)。</p><p id="e74c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通用异步操作创建器:</p><figure class="lr ls lt lu gt ip"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c3a1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们调用 store.dispatch(fetchUsers())时，动作通过 thunk 中间件传递。动作是一个函数，所以会用 store.dispatch 调用动作，当我们的动作被执行时，它从我们的 API 获取用户，并调度一个普通的动作对象。当动作被分派时，它也通过 thunk 中间件。它不是一个函数，所以它被传递给存储，并被简化为状态。</p><p id="4758" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单，对吧？？</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h1 id="e0c4" class="lz ku iy bd kv ma mx mc ky md my mf lb mg mz mi le mj na ml lh mm nb mo lk mp bi translated">结论</h1><p id="0de9" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在我们已经完全理解了中间件的作用和 Thunk 的工作原理，我们可以创建我们自己的中间件了！查看<a class="ae ly" href="https://nmajor.com/posts/making-redux-middleware-for-websockets" rel="noopener ugc nofollow" target="_blank">这篇关于如何创建处理 action cable</a>(Rails web sockets 处理器)的中间件的文章。我发现将 ActionCable 集成到 Redux 商店非常有帮助。</p><p id="4e1f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们并没有真正讨论为什么我们需要中间件，但是我希望讨论中间件的作用和工作原理能让你更好地理解如何创建你自己的中间件。<a class="ae ly" href="https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60" rel="noopener">本文</a>非常详细地解释了 Thunk，以及为什么我们需要它来处理异步逻辑。</p><p id="501e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，请记住，简单地说，中间件接受商店的当前调度并返回一个新的包装调度函数。在中间件内部，我们可以指定额外的逻辑，比如将动作记录到控制台，在分派动作之前等待一段时间，甚至处理 WebSocket 连接。最后，当我们应用 middleware 时，我们只是用从中间件返回的新包装分派方法创建一个商店！</p><p id="20fa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:我们在这里使用的大部分代码并不是 Redux 和 thunk 文档中的精确代码。我使用简化版本来关注中间件的本质。查看 Redux middlewares 和 Thunk 的文档以获得准确的代码。</p></div></div>    
</body>
</html>