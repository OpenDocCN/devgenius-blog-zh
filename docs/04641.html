<html>
<head>
<title>Memory management in swift (Part -02)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift 中的内存管理(第二部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-in-swift-part-02-b5b5f9fbb12b?source=collection_archive---------3-----------------------#2021-04-14">https://blog.devgenius.io/memory-management-in-swift-part-02-b5b5f9fbb12b?source=collection_archive---------3-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9c6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">描述如何在 Swift 中使用自动引用计数来管理应用程序内存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b835364e10cb3e8e807555b3f197d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_DcKab9hOQSyXNrIgdRkQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳斯·斯维德拉斯通过<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="a0c8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">概观</h1><p id="05f7" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 iOS 开发中，ARC(自动引用计数)用来管理 app 内存。它跟踪初始化的引用、代码之间的关系，并在不再需要实例时自动释放它们。但有时清理过程会因某些原因而中断。在本教程中，我们将了解在委托和闭包的情况下，ARC 何时无法释放内存以及如何解决它。如果你想学习内存管理的基础知识，可以看看我的内存管理教程的第一部分<a class="ae ky" href="https://levelup.gitconnected.com/arc-memory-management-in-swift-165fd0329f16" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="mc md me"><p id="52ef" class="jk jl mf jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated"><em class="in">本教程使用</em> <strong class="jm io"> <em class="in"> Swift 5，Xcode 12.4 编写。</em>T11】</strong></p></blockquote><h1 id="0b62" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">委托保留周期</h1><p id="0680" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们经常使用委托在视图之间发送数据。假设我们使用委托在<strong class="jm io"> FirstVC </strong>和<strong class="jm io"> SecondVC </strong>之间传递数据。</p><p id="9876" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么我们声明一个名为<strong class="jm io"> SendDataDelegate </strong>的协议，并通过它连接<strong class="jm io"> FirstVC </strong>和<strong class="jm io"> SecondVC </strong>。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="5dbd" class="mo la in mk b gy mp mq l mr ms">protocol SendDataDelegate {}</span><span id="e953" class="mo la in mk b gy mt mq l mr ms">class FirstVC{<br/>    var delegate: SendDataDelegate?</span><span id="0f28" class="mo la in mk b gy mt mq l mr ms">    deinit{<br/>        print("Delegate ref removed from FirstVC")<br/>    }<br/>}</span><span id="a4c5" class="mo la in mk b gy mt mq l mr ms">class SecondVC: SendDataDelegate {<br/>    let vc = FirstVC()    <br/>    <br/>    init() { <br/>        vc.delegate = self<br/>    }</span><span id="a0a2" class="mo la in mk b gy mt mq l mr ms">    deinit{<br/>        print("Delegate ref removed from SecondVC")<br/>    }<br/>}</span><span id="1903" class="mo la in mk b gy mt mq l mr ms">var secondVC: SecondVC? = SecondVC()</span></pre><p id="d07d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过创建<strong class="jm io"> SecondVC </strong>的引用来触发 VC 之间的连接。我们在每个类中都编写了 deinit 方法来指示 ARC 何时释放内存。</p><p id="938d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个阶段，<strong class="jm io"> FirstVC </strong>和<strong class="jm io"> SecondVC </strong>相互之间有很强的引用关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/622988aa9d393bbf87768567fd2586dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*Tjd6oLfzcTNGbaHXfjySsw.png"/></div></figure><p id="d1d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望如果我们设置<strong class="jm io">变量 secondVC: SecondVC？随着<strong class="jm io"> nil </strong>的出现，ARC 有望通过移除未使用的引用来完成清理过程。但是等等，不是的。在您的代码中尝试一下，并检查控制台输出，实际上没有调用 deinit 方法。</strong></p><p id="48f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像我之前说的，将对象值设置为 nil 只是移除了引用，而没有销毁对象，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2327b59b41d4ed1cc34485ad49110a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*ngz3YCHXZ8c4Yu1mZ_u9FA.png"/></div></figure><p id="db54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你所要做的就是让委托引用变弱。它将创建从<strong class="jm io"> FirstVC </strong>到<strong class="jm io"> SecondVC </strong>的弱引用，从而解决了内存保留周期问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b85eb1c431acc1f3258a2837395493f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*NsEnfJt296BnLaY5Zj8Z2g.png"/></div></figure><p id="5192" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进行更改，运行您的代码并检查您的控制台。ARC 能够如你所愿清理你的记忆。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c68f" class="mo la in mk b gy mp mq l mr ms">protocol SendDataDelegate: class {}</span><span id="4ef6" class="mo la in mk b gy mt mq l mr ms">class FirstVC{<br/>    weak var delegate: SendDataDelegate?</span><span id="194f" class="mo la in mk b gy mt mq l mr ms">    deinit{<br/>        print("Delegate ref removed from FirstVC")<br/>    }<br/>}</span><span id="aa56" class="mo la in mk b gy mt mq l mr ms">class SecondVC: SendDataDelegate {<br/>    let vc = FirstVC()    <br/>    <br/>    init() { <br/>        vc.delegate = self<br/>    }</span><span id="a37b" class="mo la in mk b gy mt mq l mr ms">    deinit{<br/>        print("Delegate ref removed from SecondVC")<br/>    }<br/>}</span><span id="850d" class="mo la in mk b gy mt mq l mr ms">var secondVC: SecondVC? = SecondVC()<br/>secondVC = nil</span><span id="7977" class="mo la in mk b gy mt mq l mr ms"><strong class="mk io">Console Output: </strong></span><span id="0b64" class="mo la in mk b gy mt mq l mr ms">Delegate ref removed from SecondVC<br/>Delegate ref removed from FirstVC</span></pre><h1 id="05bd" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">闭合保持周期</h1><p id="5cfd" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">假设我们有一个名为<strong class="jm io"> Student </strong>的 swift 类，它有两个属性<strong class="jm io"> studentClosure </strong>和<strong class="jm io"> name </strong>。<strong class="jm io">学生</strong>类有一个<strong class="jm io">学生闭包</strong>的引用，因为它是该类的一个属性。</p><p id="deef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过创建一个<strong class="jm io">学生</strong>的对象，我们也创建了一个从闭包到<strong class="jm io">学生</strong>类的引用。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="a139" class="mo la in mk b gy mp mq l mr ms">class Student {<br/>var studentClosure: (() -&gt; ())?<br/>var name: String = "Amit"</span><span id="dbce" class="mo la in mk b gy mt mq l mr ms">    init() {<br/>        studentClosure = {<br/>        print("\(self.name) is a student")<br/>    }<br/>  }</span><span id="bf12" class="mo la in mk b gy mt mq l mr ms">    deinit{<br/>        print("Student gone")<br/>    }<br/>}</span><span id="9e1e" class="mo la in mk b gy mt mq l mr ms">var studentObj: Student? = Student()<br/>studentObj?.studentClosure!()</span></pre><p id="37e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个场景中，<strong class="jm io"> Student </strong> class 和<strong class="jm io"> studentClosure </strong>彼此都有一个反过来的强关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e4cbd3a87cd61cad1649768dc11d78ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*tPfKQcGhTv1Mcn7htGzdFA.png"/></div></figure><p id="a742" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们将 studentObj 的值设置为 0，我们希望 ARC 通过中断所有关系来为我们释放内存。但不幸的是，设置 nil 不能打破<strong class="jm io">学生</strong>类和闭包之间的保持循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/399326bb9569e1585466b6fe84120906.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*SJWanwUMgI9lL00FJVlL-w.png"/></div></figure><p id="e30f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过使用如下的<strong class="jm io">弱</strong>关键字来解决内存泄漏。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="da91" class="mo la in mk b gy mp mq l mr ms">init() {<br/>    studentClosure = { [weak self] in<br/>        guard let obj = self else {<br/>        return<br/>    }</span><span id="a032" class="mo la in mk b gy mt mq l mr ms">    print("\(obj.name) the Developer")<br/>  }<br/>}</span></pre><p id="f4c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">捕获<strong class="jm io">弱</strong>内闭合成为可选类型。<strong class="jm io">弱</strong>引用可以允许将引用对象设置为 nil。现在 ARC 可以像我们预期的那样释放我们的内存，并将调用 deinit()方法。</p><p id="c893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<strong class="jm io"> studentObj </strong>的值设置为<strong class="jm io">零</strong>并检查您的控制台。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c7ee" class="mo la in mk b gy mp mq l mr ms">import UIKit<br/>class Student {<br/>    var studentClosure: (() -&gt; ())?<br/>    var name: String = "Amit"<br/>    <br/>    init() {<br/>        studentClosure = { [weak self] in<br/>            guard let obj = self else {<br/>                return<br/>            }<br/>            <br/>            print("\(obj.name) the Developer")<br/>        }<br/>    }<br/>    <br/>    deinit{<br/>        print("Student gone")<br/>    }<br/>}</span><span id="6802" class="mo la in mk b gy mt mq l mr ms">var studentObj: Student? = Student()<br/>studentObj?.studentClosure!()<br/>studentObj = nil</span><span id="6c0e" class="mo la in mk b gy mt mq l mr ms"><strong class="mk io">Console Output:</strong></span><span id="19b0" class="mo la in mk b gy mt mq l mr ms">Amit the Developer<br/>Student gone</span></pre><p id="eb6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在闭包内捕获自己作为<strong class="jm io">无主</strong>，但是在使用它之前要确保你知道。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e801" class="mo la in mk b gy mp mq l mr ms">init() {<br/>    bobClosure = { [unowned self] in<br/>      print("\(self.name) the Developer")<br/>    }<br/>  }</span></pre><p id="5334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想现在您已经对使用 Swift 编程语言进行内存管理有了一些了解。您可以在 Swift 的官方文档中找到对它们的简短讨论。</p><p id="8a42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你觉得这篇文章有用，请分享并鼓掌👏👏👏<br/>在<a class="ae ky" href="https://medium.com/@arifulislam14" rel="noopener">媒体</a>上查看我的其他文章，在<a class="ae ky" href="https://www.linkedin.com/in/arifparvez14/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上给我连线。</p><p id="0a50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读&amp;快乐编码🙂</p></div></div>    
</body>
</html>