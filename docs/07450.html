<html>
<head>
<title>Deprecation Warning With GraphQL + NestJS Versionless API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL + NestJS 无版本 API 的弃用警告</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deprecation-warning-with-graphql-nestjs-versionless-api-badcba08cb1f?source=collection_archive---------3-----------------------#2022-03-26">https://blog.devgenius.io/deprecation-warning-with-graphql-nestjs-versionless-api-badcba08cb1f?source=collection_archive---------3-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/f06e4cfd5529b436fe430648482a146e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCzg-QlGLBsW0IH1Ct2-eg.jpeg"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk translated">src:<a class="ae kh" href="https://dev.to/3logy/signup-and-login-cqrs-pattern-with-nest-js-passport-and-graphql-32mj" rel="noopener ugc nofollow" target="_blank">https://dev . to/3 logy/sign up-and-log in-cqrs-pattern-with-nest-js-passport-and-graph QL-32mj</a></figcaption></figure><h1 id="fc22" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">GraphQL 作为无版本 API 协议</h1><p id="822f" class="pw-post-body-paragraph lg lh in li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md ig bi translated">GraphQL 已经被用作 API 协议，因为它在查询数据方面的灵活性以及创建<em class="me">无版本</em> API 的能力。</p><p id="995d" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">GraphQL 中的无版本 API 可以通过添加新字段而不移除未使用的字段来继续更新 API 来实现，而不是移除字段 GraphQL 发送已经由开发者确定的不赞成消息。</p><p id="2880" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">开发人员可以通过 GraphQL Schema 访问不赞成使用的消息，但这意味着使用 API 的开发人员必须手动查询不赞成使用的消息，或者使用 GraphQL Playground 或 Apollo Studio 等应用程序。这种方式使得不赞成的消息很容易被错过。因此，API 开发人员需要找到一种方法，在不干扰数据结果的情况下向客户端发送反对消息。</p><p id="cd16" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">GraphQL 响应由三个条目组成，关键字如下:数据、错误、扩展。关键数据和错误是不言自明的，扩展反而有点不同，GraphQL 开发人员没有明确定义它的功能和它的内容。</p><blockquote class="mk ml mm"><p id="cfa3" class="lg lh me li b lj mf ll lm ln mg lp lq mn mh lt lu mo mi lx ly mp mj mb mc md ig bi translated"><a class="ae kh" href="https://github.com/graphql/graphql-spec/blob/main/spec/Section%207%20--%20Response.md#response-format" rel="noopener ugc nofollow" target="_blank">响应图还可以包含带有关键字</a> <code class="fe mq mr ms mt b"><a class="ae kh" href="https://github.com/graphql/graphql-spec/blob/main/spec/Section%207%20--%20Response.md#response-format" rel="noopener ugc nofollow" target="_blank">extensions</a></code> <a class="ae kh" href="https://github.com/graphql/graphql-spec/blob/main/spec/Section%207%20--%20Response.md#response-format" rel="noopener ugc nofollow" target="_blank">的条目。如果设置了这个条目，它的值必须是 map。这个条目是为实现者保留的，以他们认为合适的方式扩展协议，因此对其内容没有额外的限制。</a></p></blockquote><p id="af7c" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">因此，我们可以利用 extensions 键来发送不赞成的消息，而不会干扰数据或错误。</p><p id="f5c7" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">在此之前，我希望您理解弃用消息对于构建<em class="me">无版本</em> API 的重要性，以及 GraphQL 响应上的键扩展的多用途性。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="8d31" class="ki kj in bd kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb my ld le lf bi translated">在 NestJS 和 GraphQL 上的实现</h1><p id="de7c" class="pw-post-body-paragraph lg lh in li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md ig bi translated">从这里开始，我假设您已经理解了如何用 NestJS 和 GraphQL 创建一个基本的 API。我将从称为 User 的基本对象类型开始。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/74c26986b6045cbf4fe65d7e46ae8aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*W7HC_CHdVP-lgv7jkLZLeA.png"/></div></figure><p id="4c30" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">该对象将返回如下响应</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi na"><img src="../Images/bbae1c8483a4f3610000666bd9f8bfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*vyXmuDS9ou-2ca3IbUvXpw.png"/></div></figure><p id="49c5" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">现在，我们将弃用状态字段，并添加弃用消息“状态已弃用，将于第 4 季度删除”。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nb"><img src="../Images/7eb3d09f0a552788904e57b90ebdb43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFdv5uIIRiz5OhmSKa1bOQ.png"/></div></div></figure><p id="9f64" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">该消息将显示在 GraphQL Playground 上，如下所示</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nc"><img src="../Images/10491003ed30441a362d9a6eafbd7d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vi6O8TiomgVJnLh9BJteQA.png"/></div></div></figure><p id="fafc" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">逐个悬停的必要性使得 API 的使用不是一个好的体验。因此，取而代之的是，只在模式中定义它，我们将向客户端发送一个响应，连同我们在键<strong class="li io">扩展</strong>上的<strong class="li io">数据</strong>。</p><p id="41be" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">我们将使用一个全局现场中间件来访问弃用消息，现场中间件也只适用于查询所请求的字段。这种方法只适用于代码优先的方法。</p><ol class=""><li id="a374" class="nd ne in li b lj mf ln mg lr nf lv ng lz nh md ni nj nk nl bi translated">定义一个字段中间件函数，比如说</li><li id="92d5" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">该函数将访问包含与客户端请求相关的数据的<strong class="li io">上下文</strong></li><li id="9266" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">在请求中，我们将能够访问模式和<strong class="li io">字段配置</strong></li><li id="d9a8" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">从现场配置中，我们将能够访问当前现场信息</li><li id="9687" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">如果该字段被弃用，我们将在上下文中添加一条信息</li><li id="c39d" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">最后，在 app.module 中导入 GraphQL 时，将这个中间件添加到 GraphQL 选项中</li></ol><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nr"><img src="../Images/dabc48721c070f4d3debb35043e60008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5q8uyCNNl-9WqqX0L6bzw.png"/></div></div></figure><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1d398af9bbad04191bf6b88669a7e105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*mAN5igqWZDW6GdTo8c_phw.png"/></div></figure><p id="e61c" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">因此，我们已经向我们的<strong class="li io"> <em class="me">请求</em> </strong>添加了一个反对警告，但是我们还没有将它发送给客户端。</p><p id="4b9a" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">我们需要修改 GraphQL 响应(数据、错误、扩展)，为此我们将使用名为<strong class="li io"> formatResponse </strong>的 GraphQL 选项。我们将能够在将最终响应发送给客户端之前对其进行更改。</p><ol class=""><li id="dcdf" class="nd ne in li b lj mf ln mg lr nf lv ng lz nh md ni nj nk nl bi translated">向 GraphQLModule 选项传递一个名为 formatResponse 的回调函数</li><li id="a018" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">该函数将有两个参数 response 和 requestContext</li><li id="daca" class="nd ne in li b lj nm ln nn lr no lv np lz nq md ni nj nk nl bi translated">我们将访问我们的弃用警告，将其添加到键<strong class="li io">扩展</strong>中，并最终将其发送给客户端。</li></ol><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nt"><img src="../Images/3f658455ace3d41eff2c1ed583ca2448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KMiVHHc8BBewmvPrF3N_g.png"/></div></div></figure><p id="7833" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated">我们成功地将反对警告添加到扩展中，现在让我们看看从 GraphQL Playground 查询时的结果。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nu"><img src="../Images/5d0d05a23c4481d2b2f96270320e2b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkM8gQ5kUryrjl1fJE0ijw.png"/></div></div></figure><p id="e058" class="pw-post-body-paragraph lg lh in li b lj mf ll lm ln mg lp lq lr mh lt lu lv mi lx ly lz mj mb mc md ig bi translated"><em class="me"> Asik </em>，我们已经完成了在每次客户查询时添加一个弃用警告。因此，我们的 API 用户将能够看到它，而不需要 GraphQL Playground 来轻松查看消息。</p></div></div>    
</body>
</html>