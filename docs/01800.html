<html>
<head>
<title>TypeScript — function overloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript —函数重载</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/types-function-overloading-43afc46ab3fa?source=collection_archive---------7-----------------------#2020-07-12">https://blog.devgenius.io/types-function-overloading-43afc46ab3fa?source=collection_archive---------7-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/08f57d33b44c5cc395e86095d3598f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aGJpzk68kDv30IuB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d7ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">人们会期望TypeScript为JS提供函数重载，就像任何其他编译语言一样，例如Java <em class="lb">和</em>它确实提供了函数重载，但是有些不同。</p><p id="0ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不同于任何传统的编译语言，因为它不支持具有相同函数名的函数的多种定义/实现。如果TS找到多个同名的函数实现，它将抛出一个编译时错误，如图所示👇</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="645c" class="ll lm iq lh b gy ln lo l lp lq">TS code:</span><span id="8ff2" class="ll lm iq lh b gy lr lo l lp lq">// ❌ TypeError: Duplicate function implementation.<br/>function isEmpty&lt;T&gt;(a1: T[], a3: T): boolean { ... };</span><span id="d4ab" class="ll lm iq lh b gy lr lo l lp lq">// ❌ TypeError: Duplicate function implementation.<br/>function isEmpty &lt;T&gt;(a1: T, a2: T): boolean { ... };</span><span id="7de0" class="ll lm iq lh b gy lr lo l lp lq">// ❌ TypeError: Duplicate function implementation.<br/>function isEmpty&lt;T&gt;(a1: AnyLike&lt;T&gt;, a2: AnyLike&lt;T&gt;): boolean {...};</span><span id="ad05" class="ll lm iq lh b gy lr lo l lp lq">Compiled JS code:</span><span id="8a73" class="ll lm iq lh b gy lr lo l lp lq">function isEmpty(a1, a3) { return false; };</span><span id="5d99" class="ll lm iq lh b gy lr lo l lp lq">function isEmpty(a1, a2) { return false; };</span><span id="d24a" class="ll lm iq lh b gy lr lo l lp lq">function isEmpty(a1, a2) { return false; };</span></pre><p id="6ce8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当TS将代码编译成JS时，它最终得到3个相同的函数，因为JS去掉了类型。TS防止这种情况发生。</p><p id="9804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，TS通过对参数进行类型检查来提供函数重载，并通过以下方式在代码中实现:</p><ul class=""><li id="097b" class="ls lt iq kf b kg kh kk kl ko lu ks lv kw lw la lx ly lz ma bi translated">函数应该具有相同的名称和相同数量的参数。</li><li id="8722" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">一个函数可以有多个函数声明，但只能有一个函数实现。</li><li id="ff47" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">实现的函数签名必须是其函数声明的超集/联合类型。</li></ul><p id="18fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:具有相同名称和不同参数数量的函数不会被ts理解为重载函数。</p><p id="1e7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子。</p><p id="2cd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了一个名为<code class="fe mg mh mi lh b">AnyLike</code>的类型，它是泛型类型<code class="fe mg mh mi lh b">T</code>和<code class="fe mg mh mi lh b">T[]</code>的并集。这里t可以是一个复杂的物体，也可以是一个原语。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e6ba" class="ll lm iq lh b gy ln lo l lp lq">// Union type of generic type T and Array of T.<br/>type AnyLike&lt;T&gt; = T[] | T;</span></pre><p id="6fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，考虑一个名为<code class="fe mg mh mi lh b">isEmpty</code>的函数，它接受两个参数并返回一个布尔值。参数的类型可以是<code class="fe mg mh mi lh b">T</code>或<code class="fe mg mh mi lh b">T[]</code>，分别如第1行和第2行所示。第三个是重载函数的实际实现，它接受类型为<code class="fe mg mh mi lh b">AnyLike&lt;T&gt;</code>的参数——它需要是<code class="fe mg mh mi lh b">T</code>和<code class="fe mg mh mi lh b">T[]</code>的联合类型。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="7c31" class="ll lm iq lh b gy ln lo l lp lq">//1<br/>function isEmpty &lt;T&gt;(a1: T[], a2: T[]): boolean;</span><span id="7424" class="ll lm iq lh b gy lr lo l lp lq">//2<br/>function isEmpty &lt;T&gt;(a1: T, a2: T): boolean;</span><span id="47fc" class="ll lm iq lh b gy lr lo l lp lq">// function implementation<br/>function isEmpty&lt;T&gt;(a1: AnyLike&lt;T&gt;, a2: AnyLike&lt;T&gt;): boolean {<br/>  // logic here<br/>  return false;<br/>}</span><span id="1c27" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;string&gt;("foo", "bar")); // ✅ compiled!</span><span id="0890" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;string&gt;(["foo"], ["bar"])); // ✅ compiled!</span><span id="9a79" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;{}&gt;({a: "foo"}, {b: "bar"})); // ✅ compiled!</span><span id="255e" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;string&gt;("foo", ["bar"])); // ❌ Oops!</span><span id="4fb8" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;string&gt;(["foo"], "bar")); // ❌ Oops!</span><span id="fc74" class="ll lm iq lh b gy lr lo l lp lq">console.log(isEmpty&lt;string&gt;(["foo"], "bar")); // ❌ Oops!</span></pre><p id="8cc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看函数重载的另一个例子——在一个类中。我们也使用我们在上面创建的相同的示例类型<code class="fe mg mh mi lh b">AnyLike</code>,</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d14b" class="ll lm iq lh b gy ln lo l lp lq">// overloaded function isEmpty<br/>interface IEmptyType&lt;T&gt; {<br/>  isEmpty(a1: T[], a2: T[]): boolean;</span><span id="52c5" class="ll lm iq lh b gy lr lo l lp lq">  isEmpty(a1: T, a2: T):  boolean;</span><span id="1771" class="ll lm iq lh b gy lr lo l lp lq">  isEmpty(a1: AnyLike&lt;T&gt;, a2: AnyLike&lt;T&gt;):boolean;<br/>}</span><span id="3db8" class="ll lm iq lh b gy lr lo l lp lq">class Empty&lt;T&gt; implements IEmptyType&lt;T&gt; {<br/>  //Function implementation<br/>  public isEmpty(a1: AnyLike&lt;T&gt;, a2: AnyLike&lt;T&gt;): boolean <br/>    return false;<br/>  }<br/>}<br/></span><span id="2a42" class="ll lm iq lh b gy lr lo l lp lq">const instance = new Empty&lt;String&gt;();</span><span id="43a7" class="ll lm iq lh b gy lr lo l lp lq">console.log(instance.isEmpty(["hi"], ["bye"]));  ✅ compiled!<br/>console.log(instance.isEmpty(["a"], <strong class="lh ir">[1,2]</strong>)); ❌ Oops! // TypeError</span></pre><h1 id="525f" class="mj lm iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">外卖食品</h1><p id="ca62" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">函数重载可以在TS中实现，如下所示:</p><ul class=""><li id="fea2" class="ls lt iq kf b kg kh kk kl ko lu ks lv kw lw la lx ly lz ma bi translated">具有相同数目参数的同名函数。</li><li id="e15b" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">函数参数可以有不同的类型和不同的返回类型。</li><li id="8007" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">函数实际实现的参数类型和返回类型必须是其函数声明的超集或联合类型。</li><li id="3304" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">方法重载可以被类似地实现，例如在一个类中或者在一个只有函数的类之外。</li></ul></div></div>    
</body>
</html>