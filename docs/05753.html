<html>
<head>
<title>How to generate self-signed SSL certificates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何生成自签名 SSL 证书</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-generate-self-signed-ssl-certificates-b85562830ab?source=collection_archive---------0-----------------------#2021-10-20">https://blog.devgenius.io/how-to-generate-self-signed-ssl-certificates-b85562830ab?source=collection_archive---------0-----------------------#2021-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9950" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何生成自签名根 CA、服务器和客户端 SSL 证书的初学者指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/4f7f32a6326504267e9e1cfa75c42e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*3KIypChEtb0rtAgGUD0ABA.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">SSL 证书在 web 服务器上启用 HTTPS</figcaption></figure><p id="821a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">SSL 证书是保护服务器和客户端通信的<a class="ae lk" href="https://www.thesslstore.com/blog/how-pki-works/" rel="noopener ugc nofollow" target="_blank">公钥基础设施(PKI)框架</a>的一部分。我们通常在 web 服务器上使用 SSL 证书来实现 HTTPS 通信。</p><p id="3301" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，要将 SSL 证书部署到托管“kahhoetan.com”的生产 web 服务器，您需要执行以下操作。</p><ol class=""><li id="ccad" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated">生成 RSA 私钥。</li><li id="74d5" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">使用“kahhoetan.com”上的 RSA 私钥生成证书签名请求(CSR)。</li><li id="3ec2" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">将 CSR 提交给可信的证书颁发机构(CA ),如 Sectigo 或 Comodo，并在“kahhoetan.com”域上提交某种形式的验证，以证明您拥有该域。您还需要向 CA 付款。</li><li id="2bcc" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">然后，CA 将签署 CSR，并向您发送“kahhoetan.com”域的新 SSL 证书。</li></ol><p id="3406" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由可信 CA 签署的生产级 SSL 证书的价格并不低。当然，你可以从 PositiveSSL 获得入门级加密级别证书，费用为每年 10 美元，但不建议在生产环境中使用，特别是电子商务相关网站。另一个流行的选择是 LetsEncrypt，这是一个可以免费签署 SSL 证书的可信 CA。</p><p id="024a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您仍然会遇到另一个问题:<strong class="kq io">受信任的 CA 无法签署本地主机域 SSL 证书</strong>。要为本地主机开发启用 HTTPS，您需要生成自签名证书。您可以根据需要在任何域或 IP 地址上生成任意数量的自签名证书，但是因为受信任的 CA 不对它们进行签名，所以如果您使用它们，浏览器或客户端应用程序将会遇到“不受信任的 CA”错误。这意味着您<strong class="kq io">应该只在开发环境</strong>中使用自签名证书。</p><p id="7567" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本指南中，我将与您分享生成自签名证书的步骤。本指南中的命令基于 macOS，但是 Linux 命令应该是相似的。</p><p id="3d07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">更新 2021–10–26</strong>:添加了关于使用 4096 位私钥以提高安全性的说明。感谢洛根·兰德的建议。</p><h1 id="a720" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">先决条件</h1><ol class=""><li id="bf73" class="ll lm in kq b kr mr ku ms kx mt lb mu lf mv lj lq lr ls lt bi translated">确保您已经安装了<code class="fe mw mx my mz b">openssl</code>系统。Linux 和 macOS 应该已经预装了<code class="fe mw mx my mz b">openssl</code>。如果没有，你可以在 macOS 上运行<code class="fe mw mx my mz b">brew install openssl</code>或者按照本<a class="ae lk" href="https://wiki.openssl.org/index.php/Compilation_and_Installation" rel="noopener ugc nofollow" target="_blank">指南</a>获取详细的安装步骤。</li><li id="a375" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">创建一个空目录来管理这些证书，以避免不必要的混乱。</li></ol><h1 id="5ee0" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">自签名 CA</h1><h2 id="2ec2" class="na ma in bd mb nb nc dn mf nd ne dp mj kx nf ng ml lb nh ni mn lf nj nk mp nl bi translated">配置文件</h2><p id="8870" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">第一步是生成自签名 CA 证书。您将创建自己的 CA 来签署您需要的证书，而不是让受信任的 CA 来签署您的证书。</p><p id="46f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">用以下配置创建一个<code class="fe mw mx my mz b">ca.cnf</code>配置文件。用您定制的详细信息更新<code class="fe mw mx my mz b">[ root_dn ]</code>部分。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="07db" class="na ma in mz b gy nt nu l nv nw">[ req ]<br/>encrypt_key = no<br/>utf8 = yes<br/>string_mask = utf8only<br/>prompt = no<br/>distinguished_name = root_dn<br/>x509_extensions = extensions</span><span id="1de2" class="na ma in mz b gy nx nu l nv nw">[ root_dn ]<br/>countryName = MY<br/>0.organizationName = KahHoe Tan<br/>commonName = Root CA</span><span id="4193" class="na ma in mz b gy nx nu l nv nw">[ extensions ]<br/>keyUsage = critical,keyCertSign,cRLSign<br/>basicConstraints = critical,CA:TRUE<br/>subjectKeyIdentifier = hash</span></pre><p id="6e2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看每一行，理解它的意思。</p><p id="821f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">[ req ]</code>:这意味着配置的这一部分处理<code class="fe mw mx my mz b">req</code>子命令，您将使用它来生成 CSR 或证书。</p><p id="6510" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">encrypt_key</code>:指定是否要加密密钥对。如果启用，您将需要输入密码/口令来访问私钥。</p><p id="5296" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">utf8</code>和<code class="fe mw mx my mz b">string_mask</code>:用 UTF8 编码证书。除非您的证书包含非 ASCII 字符，否则您不需要定义这些选项。</p><p id="c889" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">prompt</code>:设置“否”可防止提示输入证书值，并直接从配置文件中获取值。我个人倾向于在生成证书之前，首先在配置文件中定义所有参数。</p><p id="28c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">distinguished_name</code>:指定包含识别名字段的部分。</p><p id="6521" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">x509_extensions</code>:指定包含使用<code class="fe mw mx my mz b">-x509</code>子命令时要添加的扩展名列表的部分。</p><p id="810f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">countryName</code>:证件的两个字符国家代码。</p><p id="0464" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">0.organizationName</code>:代表证书的组织名称。从<code class="fe mw mx my mz b">0.</code>开始表示这是<code class="fe mw mx my mz b">organizationName</code>的第一个条目。因为它可以是多值字段，所以必须定义索引。</p><p id="0ea4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">commonName</code> aka CN:表示受 SSL 证书保护的服务器名称。在 web 服务器场景中，SSL 证书的 CN 必须与 web 服务器的域相匹配。因为我们正在生成一个自签名的 CA，所以您可以放入任何字符串。</p><p id="df5a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny"> CN 最多只能包含一个条目。</em> <a class="ae lk" href="https://support.dnsimple.com/articles/what-is-ssl-san" rel="noopener ugc nofollow" target="_blank"> <em class="ny">主题别名扩展</em> </a> <em class="ny">(也称为主题别名或 SAN)的引入解决了这一限制。SAN 允许发布多名称 SSL 证书。稍后我会给你看一个例子。</em></p><p id="77ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">具有<code class="fe mw mx my mz b">critical</code>值的<code class="fe mw mx my mz b">keyUsage</code>和<code class="fe mw mx my mz b">basicConstraints</code>表示这两个扩展为关键扩展。任何使用证书的系统如果遇到它无法识别的关键扩展或包含它无法处理的信息的关键扩展，都必须拒绝该证书。</p><p id="0555" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">keyCertSign</code>和<code class="fe mw mx my mz b">cRLSign</code>被指定为 CA 证书的标准用法:签署证书和发布<a class="ae lk" href="https://searchsecurity.techtarget.com/definition/Certificate-Revocation-List" rel="noopener ugc nofollow" target="_blank"> CRL </a>。</p><p id="e1c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">带有<code class="fe mw mx my mz b">CA:TRUE</code>值的<code class="fe mw mx my mz b">basicConstraints</code>表示该证书为 CA。</p><p id="3c45" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">subjectKeyIdentifier</code>与<code class="fe mw mx my mz b">hash</code>是与<a class="ae lk" href="https://www.rfc-editor.org/rfc/rfc3280#section-4.2.1.2" rel="noopener ugc nofollow" target="_blank">滑轨规格</a>相关的。如果您正在创建信任链，则需要填充此扩展。</p><h2 id="00fc" class="na ma in bd mb nb nc dn mf nd ne dp mj kx nf ng ml lb nh ni mn lf nj nk mp nl bi translated">生成 CA 证书和私钥</h2><p id="2b14" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">接下来，请运行以下命令来生成根证书及其私钥。</p><blockquote class="nz oa ob"><p id="088a" class="ko kp ny kq b kr ks jo kt ku kv jr kw oc ky kz la od lc ld le oe lg lh li lj ig bi translated"><strong class="kq io">提醒:不要让未经授权的人员获取您的私钥。</strong></p></blockquote><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="a2ff" class="na ma in mz b gy nt nu l nv nw">$ openssl req -x509 -sha256 -days 3650 -newkey rsa:2048 \<br/>  -config ca.cnf -keyout ca.key -out ca.crt</span></pre><p id="681e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">openssl req</code>:这个子命令主要用于为 CA 的签名生成 CSR，但是因为我们正在生成 CA 根证书，所以我们现在使用它来生成证书本身。稍后我还将向您展示如何使用<code class="fe mw mx my mz b">openssl req</code>命令来生成 CSR。</p><p id="60d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-x509</code>:输出证书而不是 CSR。</p><p id="4b56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-sha256</code>:指定此证书要用 SHA256 签名哈希签名。</p><p id="d7a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-days</code>:本证书有效期多少天。</p><p id="b5fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-newkey rsa:2048</code>:该命令还会生成一个新的 2048 位的 RSA 私钥。</p><p id="7a8d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny">注意:如果您打算保护敏感数据，而不仅仅是为了开发/测试目的，4096 位私钥可以提供更好的安全性，但代价是性能非常低。</em></p><p id="0dc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-config</code>:该命令将使用我们之前创建的配置文件，而不是默认的配置文件。</p><p id="3684" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-keyout</code>:输出私钥的路径。</p><p id="8716" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-out</code>:输出证书的路径。这个定义也适用于大多数其他子命令。</p><p id="f55d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您现在应该有两个文件:<code class="fe mw mx my mz b">ca.crt</code>作为 CA 证书，<code class="fe mw mx my mz b">ca.key</code>作为它的私钥。您可以运行此命令来检查您的证书。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="efd8" class="na ma in mz b gy nt nu l nv nw">$ openssl x509 -in ca.crt -text -noout</span></pre><p id="a9e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">openssl x509</code>:处理证书的子命令，如显示证书信息，签署证书，或将证书转换成各种格式。</p><p id="2547" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-in</code>:指定输入的证书文件。这个定义也适用于大多数其他子命令。</p><p id="2dfc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-text</code>:以文本形式打印出证书的全部内容。</p><p id="3790" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-noout</code>:阻止输出请求的编码版本，因为我们只检查证书。</p><p id="b7b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny">您将经常运行这个命令来检查 SSL 证书。好好记着！</em></p><h1 id="397d" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">服务器证书</h1><h2 id="28fc" class="na ma in bd mb nb nc dn mf nd ne dp mj kx nf ng ml lb nh ni mn lf nj nk mp nl bi translated">生成私钥</h2><p id="a906" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">要生成 SSL 证书，我们首先需要生成一个私钥。运行此命令生成私钥。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="eb1b" class="na ma in mz b gy nt nu l nv nw">$ openssl genrsa -out server.key 2048</span></pre><p id="415c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">openssl genrsa</code>:该子命令用于生成 RSA 私钥。</p><p id="0e08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">2048</code>:这表示要生成的私钥的大小，以位为单位，类似于前面生成 CA 证书时使用的<code class="fe mw mx my mz b">-newkey rsa:2048</code>参数。此参数必须是最后指定的选项。默认值也是 2048。我在这里指定它是为了提供信息。</p><p id="37c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny">注意:如果您打算保护敏感数据，而不仅仅是为了开发/测试目的，4096 位私钥可以提供更好的安全性，代价是性能非常低。</em></p><p id="a1ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您现在应该有了一个新的私钥<code class="fe mw mx my mz b">server.key</code>。</p><p id="3002" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以运行此命令来检查新生成的 RSA 私钥。该命令非常类似于检查证书时的命令，但带有<code class="fe mw mx my mz b">rsa</code>子命令。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="2769" class="na ma in mz b gy nt nu l nv nw">$ openssl rsa -in server.key -noout -text</span></pre><p id="d71c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny">也可以使用</em> <code class="fe mw mx my mz b"><em class="ny">-keyout</em></code> <em class="ny">和</em> <code class="fe mw mx my mz b"><em class="ny">-newkey</em></code> <em class="ny">参数，在同一个命令中生成 RSA 私钥和 CSR，类似于前面生成 CA 证书的命令。</em></p><h2 id="155f" class="na ma in bd mb nb nc dn mf nd ne dp mj kx nf ng ml lb nh ni mn lf nj nk mp nl bi translated">生成 CSR</h2><p id="911b" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">接下来，我们生成一个由我们自己的自签名 CA 证书签名的 CSR。</p><p id="0cb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">准备<code class="fe mw mx my mz b">server.cnf</code>配置文件，用域或 IP 地址更新<code class="fe mw mx my mz b">[ dn ]</code>和<code class="fe mw mx my mz b">[ san ]</code>部分。这个示例配置支持多个域或 IP 地址，根据我的经验，这对于 Kubernetes 环境是必要的，在 Kubernetes 环境中，一些应用程序需要接受不同 URL 上的内部和外部通信。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="86cf" class="na ma in mz b gy nt nu l nv nw">[ req ]<br/>distinguished_name = dn<br/>req_extensions = req_extensions<br/>prompt = no</span><span id="fc61" class="na ma in mz b gy nx nu l nv nw">[ dn ]<br/>countryName = MY<br/>0.organizationName = KahHoe Tan<br/>commonName = Test Site</span><span id="b5d6" class="na ma in mz b gy nx nu l nv nw">[ req_extensions ]<br/>basicConstraints = CA:FALSE<br/>keyUsage = nonRepudiation, digitalSignature, keyEncipherment<br/>subjectAltName = <a class="ae lk" href="http://twitter.com/san" rel="noopener ugc nofollow" target="_blank">@san</a></span><span id="4758" class="na ma in mz b gy nx nu l nv nw">[ san ]<br/>DNS.1 = localhost<br/>IP.1 = 127.0.0.1</span></pre><p id="5ced" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看一下前面几节中没有涉及到的配置。</p><p id="9de3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">req_extensions</code>:指定包含要添加到 CSR 的扩展列表的部分。</p><p id="1362" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">basicConstraints</code>:我们通过值<code class="fe mw mx my mz b">CA:FALSE</code>指定这不是一个 CA。</p><p id="1277" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">keyUsage</code>:指定证书的公钥用法。你可以在这里阅读不同的密钥使用扩展<a class="ae lk" href="https://help.hcltechsw.com/domino/11.0.0/conf_keyusageextensionsandextendedkeyusage_r.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5e1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">subjectAltName</code>:用于多域证书，参见<code class="fe mw mx my mz b">[ san ]</code>部分，带域和 IP 地址列表。</p><p id="c667" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，您可以使用之前使用该命令生成的配置文件和私钥来生成 CSR。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="ad44" class="na ma in mz b gy nt nu l nv nw">$ openssl req -new -key server.key -out server.csr \<br/>  -config server.cnf</span></pre><p id="b30b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">openssl req</code>:我们仍然使用<code class="fe mw mx my mz b">req</code>子命令，但是因为我们没有使用<code class="fe mw mx my mz b">-x509</code>开关，所以它生成 CSR 而不是证书。</p><p id="00d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-new</code>:生成新的 CSR。</p><p id="7769" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-key</code>:指定私钥文件路径。</p><p id="58a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您现在有了一个新的 CSR 文件<code class="fe mw mx my mz b">server.csr</code>。您可以使用这个命令检查 CSR。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="82e6" class="na ma in mz b gy nt nu l nv nw">$ openssl req -in server.csr -text -noout -verify</span></pre><p id="9e69" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">记下<code class="fe mw mx my mz b">-verify</code>参数。添加此参数还将验证 CSR 的签名。</p><h2 id="8162" class="na ma in bd mb nb nc dn mf nd ne dp mj kx nf ng ml lb nh ni mn lf nj nk mp nl bi translated">签署 CSR</h2><p id="f4cb" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">最后，使用这个命令让 CA 签署您的 CSR。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="0ae8" class="na ma in mz b gy nt nu l nv nw">$ openssl x509 -req -days 365 -in server.csr -CA ca.crt \<br/>  -CAkey ca.key -CAcreateserial -out server.crt \<br/>  -extensions req_extensions -extfile server.cnf -sha256</span></pre><p id="dd1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-req</code>:指定将 CSR 作为输入，而不是默认证书。</p><p id="4f59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-CA</code>:指定用于签名的 CA 证书。</p><p id="2cd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-CAkey</code>:指定用于签署证书的 CA 私钥。</p><p id="8b3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-CAcreateserial</code>:该命令将为同一个 CA 颁发的每个证书创建一个唯一的序列号。</p><p id="bc2e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-extfile</code>:指定包含扩展配置的文件。</p><p id="1284" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-sha256</code>:指定使用 SHA-256 签名算法的证书。</p><p id="38f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">证书现在准备好了！</p><p id="effd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，您可以运行这个命令来检查您新生成的证书。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="fb92" class="na ma in mz b gy nt nu l nv nw">$ openssl x509 -in server.crt -text -noout</span></pre><h1 id="a76a" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">客户证书</h1><p id="0b73" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">生成客户端证书的步骤类似，只是配置文件更简单。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="3a48" class="na ma in mz b gy nt nu l nv nw">[ req ]<br/>distinguished_name = dn<br/>req_extensions = req_extensions<br/>prompt = no</span><span id="be1c" class="na ma in mz b gy nx nu l nv nw">[ dn ]<br/>countryName = MY<br/>organizationalUnitName = KahHoe Tan<br/>commonName = Test Client</span><span id="5b58" class="na ma in mz b gy nx nu l nv nw">[ req_extensions ]<br/>basicConstraints = CA:FALSE<br/>keyUsage = digitalSignature<br/>extendedKeyUsage = clientAuth</span></pre><p id="58cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">主要区别是客户端认证的<code class="fe mw mx my mz b">extendedKeyUsage</code>被设置为<code class="fe mw mx my mz b">clientAuth</code>。</p><h1 id="301f" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">PFX 密钥库</h1><p id="6a84" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">如果您需要 PFX/PKCS#12 密钥库中的整个证书链，您可以运行此命令来生成包含任意数量证书的证书密钥库文件。根据我的经验。NET 应用程序需要 PFX 格式的证书文件来进行客户端身份验证。</p><pre class="kd ke kf kg gt np mz nq nr aw ns bi"><span id="16a0" class="na ma in mz b gy nt nu l nv nw">$ openssl pkcs12 -export -out client.pfx -inkey client.key \<br/>  -in client.crt -certfile ca.crt</span></pre><p id="3c51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">openssl pkcs12</code>:处理 PFX/PKCS#12 密钥库文件的子命令。</p><p id="5297" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-export</code>:指定要创建的新 PKCS#12 文件。</p><p id="7c76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-out</code>:结合<code class="fe mw mx my mz b">-export</code>使用时，指定输出 PKCS#12 文件的路径。</p><p id="3403" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-inkey</code>:指定输入私钥文件的路径。</p><p id="4517" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-in</code>:指定要包含在 PKCS#12 文件中的 PEM 证书的路径。</p><p id="76e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">-certfile</code>:指定要包含在 PKCS#12 文件中的任何附加证书文件。</p><h1 id="9604" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">摘要</h1><p id="93a2" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">生成 SSL 证书相对简单。希望以上我的经验对你有帮助。我欢迎任何反馈和问题。</p></div></div>    
</body>
</html>