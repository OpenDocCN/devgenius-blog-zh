<html>
<head>
<title>React Native Development Guidelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 本机开发指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-native-development-guidelines-eadb3268e0c7?source=collection_archive---------0-----------------------#2022-06-09">https://blog.devgenius.io/react-native-development-guidelines-eadb3268e0c7?source=collection_archive---------0-----------------------#2022-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f189" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">标准化对任何业务都有积极的影响。在软件行业也是如此，成功的软件开发需要特定的编码标准。对于大多数组织来说，软件程序的无缝运行对他们的成长至关重要。</p><p id="b822" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建高质量的软件、架构和代码并不容易。它需要软件开发团队的一致努力来满足可伸缩的代码质量目标，并遵循团队编程最佳实践来成功协作。这对于软件项目来说是非常重要的。当开发人员被要求在短时间内完成任务时，他们经常会回避质量标准。</p><p id="2450" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">任何新项目的首要任务是设计和构建一个可伸缩的架构，该架构可以轻松处理项目需求(中型到大型),而无需对项目的当前状态进行太多的更改。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="07a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一步一步地开始，在进一步进入其他步骤之前，先谈一谈 React Native</p><h1 id="2d61" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">反应自然</h1><p id="b429" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">React Native 基本上使用单一代码库(即 JavaScript)为 android 和 IOS 平台构建应用程序。</p><ul class=""><li id="8622" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">帮助您创建真实而令人兴奋的移动应用的开源框架</li><li id="54dc" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">由脸书于 2015 年开发</li><li id="cf52" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">使用 JavaScript 构建跨平台应用</li></ul><p id="45e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需学习一次，编码一次，然后 React 原生 apps 和 Android 平台都有。</p><h2 id="9ee0" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak">何时选择 React Native </strong></h2><ul class=""><li id="e11f" class="ls lt in jm b jn ln jr lo jv ms jz mt kd mu kh lx ly lz ma bi translated">当您的应用程序需要依赖于特定平台的本机外观和感觉时。</li><li id="316e" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">更加可扩展和复杂的应用程序。</li><li id="1a3e" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">大量的社区支持包可用于更快的开发。</li></ul><h2 id="bf9b" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak">在不选择的时候做出反应的土著</strong></h2><ul class=""><li id="6921" class="ls lt in jm b jn ln jr lo jv ms jz mt kd mu kh lx ly lz ma bi translated">涉及大量计算和动画的大型项目。</li><li id="e928" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">具有复杂用户界面的应用程序</li><li id="0b12" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">专为单一操作系统设计的应用</li><li id="8722" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">需要原生 API 的游戏和应用</li></ul><h1 id="3dec" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">项目设置架构</strong></h1><p id="5607" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">对于大型项目，我们应该创建两个不同的存储库</p><ul class=""><li id="1334" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">包含可重用组件的组件库(可在应用中使用的所有通用可重用组件的 UI 库)</li><li id="785e" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">主应用程序 Repo 将使用上述 UI 库来构建可扩展和一致的屏幕。</li><li id="154d" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">理想情况下，我们应该确保屏幕和组件的封装。</li><li id="fa5d" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">每个根级文件夹都有一个 index.js 文件，帮助我们缩短导入时间。</li><li id="19f6" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">文件夹中的所有内容都从相应目录的索引文件中导出。</li><li id="3ac4" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">文件名是用连字符连接的，就像这样</li><li id="c5d8" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">对于较短的导入，必须在每个目录中使用 index.js 文件</li><li id="5cf6" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">如果一个文件/关注点跨越多个文件，为它创建一个单独的目录</li></ul><h1 id="3cbf" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">设置主题指南:</strong></h1><p id="e11e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">没有一致的风格，很难得到最好的效果。设计系统是一组规则和原则，它们为应用程序的外观和感觉奠定了基础。使用设计系统时，你需要记住三件事。</p><ul class=""><li id="2152" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated"><strong class="jm io">间距</strong>:在使用跨平台应用程序时，屏幕上的不同组件之间的屏幕尺寸可能会有所不同，但要确保它们之间的间距一致，以获得一致的外观。</li><li id="f5ff" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">颜色</strong>:选择正确的颜色不仅是最重要的，你如何使用它们也很重要。一个很好的解决方案是使用调色板，您可以根据首选的命名约定来命名颜色，这增加了您的整体工作流程。</li><li id="742b" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">排版</strong>:我们经常忘记字体是如何改变应用程序在结果中的外观的。最好坚持使用有限的字体系列、字体粗细和字体大小，以获得令人愉悦的一致外观。</li></ul><h1 id="a74b" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">带 JS 的动态造型</strong></h1><p id="f372" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated"><a class="ae mv" href="https://www.npmjs.com/package/styled-components" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mw">Styled-components</em></strong></a>是一个 CSS-in-JS 样式框架，它使用 JavaScript 中的标记模板文字和 CSS 的强大功能来提供一个平台，允许您编写实际的 CSS 来样式化 React 组件。</p><p id="a6d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">样式化组件是用样式化组件库编写的易于制作的 React 组件，在样式化组件库中，您可以用 JavaScript 代码中的普通 CSS 来样式化组件</p><h1 id="b23a" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">响应式属性</strong></h1><p id="8ce2" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">定义一些可扩展的函数，帮助处理不同设备维度上的 UI。参考<a class="ae mv" href="https://www.npmjs.com/package/react-native-normalize" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mw">react-native-normalize</em></strong></a>进行参考</p><h1 id="5385" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">反应本地最佳编码实践</strong></h1><ul class=""><li id="d6d7" class="ls lt in jm b jn ln jr lo jv ms jz mt kd mu kh lx ly lz ma bi translated">组织导入，使所有库导入在文件顶部组合在一起，其余的导入随后进行</li><li id="be15" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">React 本机应用程序中的异常处理，对所有 API 块代码使用 try/catch 块。</li><li id="0c47" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">对所有对象属性进行排序。</li><li id="2a81" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">总是用分号结束属性。</li><li id="322b" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">尽可能多地使用无状态组件。</li><li id="7d08" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">避免默认导出，使用命名导出以获得更好的 IDE 支持。</li><li id="d011" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">没有隐性回报</li><li id="0bb6" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">空状态应该隐式实现。</li><li id="46e1" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">要使用任何包，应该优先考虑 react-native 社区。</li><li id="0f81" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">在代码中添加注释以消除歧义</li><li id="8479" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">要放在 storybook/stories 文件夹下的故事。</li><li id="bc67" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">使用特定于平台的样式</li><li id="f44c" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">始终为每个元素分配唯一的键</li><li id="0d35" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">删除不推荐的和不必要的注释代码。</li><li id="2dec" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">拆下控制台。</li><li id="fe27" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">不应该在 JSX 传递内联函数。</li><li id="142b" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">道具和样式应该在一个单独的文件中</li><li id="9baa" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">避免内嵌样式</li><li id="18ac" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">应该去掉重复的代码，遵循干的原则。</li><li id="0764" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">如果文件/组件太大，那么应该将它分成多个文件/组件。</li><li id="4089" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">应该遵循样式文件的样式指南..</li><li id="519a" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">代码有适当的单元测试，应该达到 80%以上的覆盖率。</li><li id="170f" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">测试是精心设计的</li><li id="1596" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">锁定依赖关系</li></ul><h1 id="b685" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">代码质量</strong></h1><h2 id="57a5" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak">在代码库中配置绝对相对路径</strong></h2><p id="317b" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">使用绝对导入来更好地组织 React 项目是一个很好的方法。相对导入在重构过程中很难遵循和打破。随着项目的增长，绝对导入更容易管理您的项目。</p><p id="0140" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">绝对进口有一些优势。</p><ul class=""><li id="10fb" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">没有../../../../见鬼。因此更容易打出进口。</li><li id="87ae" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">轻松地将导入的代码复制粘贴到项目的另一个文件中，而不必修改导入路径。</li><li id="02e4" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">它又短又甜</li></ul><h2 id="edf8" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak">林挺</strong></h2><p id="0bdf" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">使用 linter 使你的代码更容易被审查。遵循严格的林挺规则。这反过来有助于您编写干净、一致的代码。</p><p id="74e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">规则推荐:<a class="ae mv" href="https://www.npmjs.com/package/@react-native-community/eslint-config" rel="noopener ugc nofollow" target="_blank"> ESlint 社区规则</a></p><h1 id="b48b" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">一些推荐使用的库:</strong></h1><ul class=""><li id="fa45" class="ls lt in jm b jn ln jr lo jv ms jz mt kd mu kh lx ly lz ma bi translated"><strong class="jm io"> Redux </strong>(如果性能是一个问题，提高性能的最好方法是跳过不必要的重新渲染，这样组件只在它们的数据实际改变时才重新渲染。React Redux 在内部实现了许多性能优化，以便您自己的组件只在实际需要时才重新呈现。)</li><li id="ad65" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">样式化组件</strong>(样式化组件是使用样式化组件库编写的易于制作的 React 组件，在样式化组件库中，您可以在 JavaScript 代码中使用普通 CSS 来样式化组件)</li><li id="cf24" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> React Navigation </strong>(这是现场使用最广泛、开发最活跃的库之一。也是 React 原生团队推荐的解决方案之一。这是脸书推动最多的社区解决方案。)</li><li id="7a77" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> Reanimated </strong>(这是一个库，取代了 RN 的动画 API，提供了基于 JS 的动画 API，易于使用并在本机线程上运行(这需要开箱即用的性能)</li><li id="0848" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">社区挂钩</strong>(React Native API 变成了 React 挂钩，允许您直接在功能组件中访问异步 API，并提供了许多方便的挂钩供您使用)</li><li id="b8a0" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">Formik (它是 React 和 React Native 中用于构建表单的一小组 React 组件和挂钩。它有助于处理三个最烦人的部分:在表单状态中获取值和从表单状态中获取值。验证和错误消息。)</li><li id="9ff7" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> React 原生快速镜像</strong>(以极快的速度加载镜像，真的是一个很酷的库。来自 react-native-fast-image 的 FastImage 组件是对 SDWebImage (iOS)和 Glide (Android)的包装，它们是本地开发中非常强大的图像加载器</li><li id="5745" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> Axios </strong> (Axios 在一个小软件包中提供了一个简单易用的库，具有非常可扩展的接口)</li><li id="2610" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">React Native Firebase crash lytics</strong>(Firebase crash lytics 跟踪、区分优先级，&amp;修复影响应用质量的稳定性问题。通过强大的实时崩溃报告，快速查明崩溃的根本原因)</li></ul><h1 id="365a" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">性能优化</strong></h1><ul class=""><li id="1320" class="ls lt in jm b jn ln jr lo jv ms jz mt kd mu kh lx ly lz ma bi translated"><strong class="jm io">避免使用 ScrollView 渲染庞大的列表:</strong>为了处理列表格式的大量数据，React Native 提供了 FlatList。FlatList 中的项目是延迟加载的。因此，应用程序确实使用了过多或不一致的内存量-</li><li id="5ff8" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">避免将内联函数作为道具传递</strong>:不推荐这样做，因为每当父类重新呈现一个新的引用时，该函数都会被再次创建。这意味着即使道具根本没有改变，子组件也会重新渲染。解决方案是将函数声明为类方法或函数组件中的函数，这样引用就消除了任何交叉呈现的可能性。</li><li id="df73" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">利用 Hermes </strong> : Hermes 是一个开源的 JavaScript 引擎，专门针对移动应用进行了优化。适用于 React 原生版本 0.60.4 及以上的 Android 平台。也适用于 0.64-RC.0 及以上版本的 iOS。Hermes 有助于减少 APK 的下载大小、内存占用和消耗，以及应用程序变得可交互所需的时间(TTI-交互时间)。</li><li id="ef7d" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">memo ization using memo:</strong>memo ization 是 React 中的一个优化特性，如果用在正确的地方，可以提高程序的性能。React 为我们提供了 PureComponent 和 memo 来实现 memo 化。PureComponent 与类组件一起使用，memo 与函数组件一起使用。内存化通过在传递相同属性时存储函数的结果来提高性能，从而减少重新渲染的次数。但是，在没有性能问题的地方过度使用内存化会导致性能下降。</li></ul><h1 id="b384" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">安全</strong></h1><p id="5284" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">开发移动应用程序时的一个主要问题是数据安全性。</p><p id="41f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尤其是涉及到非常敏感的数据时，任何安全漏洞都可能导致不可挽回的损失。几乎所有的应用程序都包含用户的关键信息，因此应用程序安全性是最佳元素，尤其是在处理密码、touch ids、帐户名、信用卡信息等时</p><ul class=""><li id="b645" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated"><strong class="jm io">存储敏感信息</strong>:使用加密存储只是为了确保我们的应用安全。异步存储很棒，但它缺乏安全性。这在存储敏感数据(如访问令牌、支付信息等)时不太理想。</li><li id="548b" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><a class="ae mv" href="https://github.com/emeraldsanto/react-native-encrypted-storage" rel="noopener ugc nofollow" target="_blank"> Encrypted Storage Package </a>旨在解决这个问题，它提供了一个包装 Android 的 EncryptedSharedPreferences 和 iOS 的 Keychain 的包装器，以加密的格式保存您的信息，这样就不会被攻击者读取。</li><li id="3095" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><a class="ae mv" href="https://medium.com/simform-engineering/security-aspects-to-consider-for-a-react-native-application-95556f0e4244" rel="noopener">安全方面要考虑的</a></li></ul><h1 id="4523" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">测试</strong></h1><h2 id="801b" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak">单元&amp;快照测试(Jest) </strong></h2><p id="54de" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">根据 React-native 文档，React 组件负责渲染你的 app，用户会直接与其输出进行交互。即使你的应用程序的业务逻辑有很高的测试覆盖率并且是正确的，如果没有组件测试，你仍然可能向你的用户交付一个不完整的 UI。</p><p id="d8ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了测试 React 组件，您可能需要测试两件事情:</p><ul class=""><li id="f2b3" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated"><strong class="jm io">交互</strong>:确保组件在与用户交互时(如用户按下按钮时)行为正确</li><li id="3fb7" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io">渲染</strong>:确保 React 使用的组件渲染输出是正确的(例如，按钮在 UI 中的外观和位置)</li></ul><p id="b229" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果您有一个带有 onPress 侦听器的按钮，您希望测试该按钮是否正确显示，以及组件是否正确处理点击按钮。</p><p id="64af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于交互，我们正在执行组件测试以验证行为，比如按下事件和按下特定组件中的图标。对于渲染，我们正在编写一个快照测试来验证组件 UI 的外观和位置。</p><h2 id="6e35" class="mg kq in bd kr mh mi dn kv mj mk dp kz jv ml mm ld jz mn mo lh kd mp mq ll mr bi translated"><strong class="ak"> E2E 检测(排毒/Appium) </strong></h2><p id="8cd8" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">端到端测试是一种从头到尾测试整个软件产品的技术，以确保应用程序流按预期运行。它定义了产品的系统依赖关系，并确保所有集成部分按预期协同工作。</p><p id="82e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">端到端(E2E)测试的主要目的是通过模拟真实的用户场景，验证被测系统及其组件的集成和数据完整性，从最终用户的体验出发进行测试。</p><p id="43f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们建议使用<a class="ae mv" href="https://github.com/wix/Detox" rel="noopener ugc nofollow" target="_blank"> Detox </a>进行端到端测试。手机自动化测试最困难的部分是测试金字塔的顶端——e2e。E2E 测试的核心问题是剥落——测试通常是不确定的。通过从黑盒测试转向灰盒测试，Detox 正面解决了片状剥落问题。</p></div></div>    
</body>
</html>