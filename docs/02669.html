<html>
<head>
<title>Error handlers in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的错误处理器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/error-handlers-in-swift-dce7153d9fe7?source=collection_archive---------7-----------------------#2020-08-19">https://blog.devgenius.io/error-handlers-in-swift-dce7153d9fe7?source=collection_archive---------7-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/a0cb7def9dc6f7638bfb1f506b10a02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*eUZj5LQz02SGFV7VfxOWsw.jpeg"/></div></figure><div class=""/><p id="f7aa" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误处理对代码质量有很大的贡献。这也使得程序员意图更加明显。如今，Swift在传播和处理错误方面发展得更好。本文将讨论一些错误处理程序及其使用和影响。此外，在不同的配置模式下使用时会有所不同。</p><p id="63d1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误要么是程序员的错误，要么是OS/IDE的缺陷，响应或处理这种意外行为就是错误处理。简单！！<br/>让我们列出swift中一些可用的错误处理程序:</p><ol class=""><li id="77f8" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">扔，试着接住</li><li id="af1c" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">主张</li><li id="c820" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">前提</li><li id="7ca7" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">致命错误</li></ol><p id="ec31" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些错误更像是编程和运行时错误处理程序。编程错误是那些逻辑错误或未处理的情况。另一方面，由OS/IDE/API故障引起的运行时错误。</p><p id="e077" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了处理编程错误，swift提供了断言、前提条件和致命错误处理程序。另一方面，try-catch是处理运行时错误的传统而有效的方法。Swift允许throw方法帮助尝试捕捉技术。此外，swift还提供可选的<t>、结果<t>和try？(投掷的例子)。</t></t></p><p id="f4ad" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要更深入地了解基础知识，请查阅官方文档— <a class="ae lg" href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html" rel="noopener ugc nofollow" target="_blank">快速错误处理程序</a></p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="582c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy"> Throw，Try-Catch </strong>:处理错误的全时间成功方法，swift中也提出了Try-Catch方法与<em class="lo"> throw </em>。抛出产生一个类error错误实例。抛出错误表示期望中的异常发生，并打破正常流程以达到期望。它有这样的表达:</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lp"><img src="../Images/6f93a62fc72a2a96ed196dfe20cd5f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*U8iBqs5sOyaOu3yHhAXJjQ.png"/></div></div></figure><p id="11d4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">应该在函数定义中使用throws关键字作为后缀来定义预计会失败的方法。因此，在do-try-catch对的帮助下，可以很好地处理运行时错误！在这上面再加两分钱，<em class="lo"> Throw，try-catch </em>是可撤销的方法。</p><p id="dd36" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为什么，用在哪里？是的，应该考虑当-</p><ul class=""><li id="8e5b" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">错误不可能在方法内部处理。</li><li id="290d" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">需要改变控制流</li><li id="a631" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">在一个catch方法中必须处理多个错误</li></ul><p id="d88e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当应用程序期望来自不同实体的输入时，Throw总是有用的。谁可能导致不同类型的输入，空，数据转换问题预计会发生。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="b621" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">可选，尝试</strong>是处理小错误的另一种方式，或者在正常执行中避免空值。最佳做法是在以下情况下使用这些工具-</p><ul class=""><li id="5560" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">将变量转换为数据类型</li><li id="6719" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">解析API</li><li id="ce0d" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">只读计算属性</li><li id="1b5e" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">带投掷的计算函数</li></ul><p id="3590" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，我想在这里同意，使用可选的，尝试，强制包装是完全值得商榷的。每个开发人员都可以根据自己的理解来使用它。</p><p id="979f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">投掷，试抓可以用试来缩短吗？试试看。这里你最好知道。&amp; !。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="ad6b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">结果</strong>表示成功&amp;失败并出现错误。与Optional不同，它更有帮助，并提供导致失败的有用上下文。它与错误相关联，并且具有更多信息。它在以下情况下很有用—</p><ul class=""><li id="9414" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">异步完成处理程序中可能会出现错误。(回调、API调用等。)</li><li id="dec5" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">当成功和失败都被认为是预期的输出时。</li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="048b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">断言:</strong>它有助于处理编程错误和条件测试，这应该只发生在错误的逻辑或代码。例如:忘记设置storyboardId、单元格标识符等。断言仅对开发模式有效，在生产中会被跳过。<em class="lo">所以在生产中开发者肯定需要照顾回退</em>。</p><p id="4c10" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Assert是追踪编程错误的合适工具。这在没有关键问题且app具有除终止之外的替代证明动作的情况下是有用的。因为它只会在开发中崩溃的应用程序，所以应用程序必须在生产中添加失败的回退。为分析或崩溃报告添加代码可以帮助在即将到来的版本中修复/检测问题。让我们用例子来验证一下—</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lz"><img src="../Images/df2ddac18cd6f4fc693197955551fc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfT8LpGRx277lX-LYwKYMg.png"/></div></div></figure><p id="75b8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以在上面的例子中，学生必须有Id，并且为了验证我们已经在断言的帮助下添加了check。在上面的例子中，同样的事情被两种不同的方法处理，开发者可以使用其中的任何一种。此外，消息不是必需的，如果开发人员不传递它，它的默认值为空。再次提醒，这个断言在生产应用程序中不起作用，所以这里最好使用回退代码。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="5120" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">前置条件:这与断言is的行为相同。唯一的区别是前提条件将在开发和生产中终止应用程序。它也没有任何返回类型。如果你能把上面例子中的关键字“assert”替换成“precondition ”,那就完美了。</p><p id="957c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">前提条件在以下情况下很有用—</p><ul class=""><li id="ca08" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">函数需要参数来消费，脚本必须运行等。</li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="e99f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">致命错误</strong>:是的，顾名思义，这是应用程序的手榴弹。它会无条件终止应用程序。它应该只用于错误，使应用程序声明终止是唯一合理的行动。与其他处理程序不同的是，它的返回类型是“never ”,因此可以用在错误没有什么可返回的地方。</p><p id="1bf2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lo">因此，与其他处理程序相比，fatalError会将失败消息添加到崩溃报告中，而其他处理程序则不会。</em></p><p id="0cf9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">致命错误建议仅在以下情况下使用—</p><ul class=""><li id="ce62" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">错误至关重要</li><li id="0d0b" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">没什么可退的。</li></ul><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ma"><img src="../Images/dca513f8c2596f5ffd9eb2bdb86f4c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayuFJ7o4sR7CVvgOAKUwsw.png"/></div></div></figure><p id="c046" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的例子中，我已经展示了如何在代码中使用fatalError的两种方法。像这里一样，函数期望一个单元格返回，但是编程错误会导致没有单元格。所以返回和错误可以用fatalError来处理。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="d65a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">快速错误处理策略可以分为:</p><ul class=""><li id="bbee" class="ks kt ix jw b jx jy kb kc kf ku kj kv kn kw kr ly ky kz la bi translated">可恢复:<code class="fe mb mc md me b">Optional</code>、<code class="fe mb mc md me b">Result</code>、<code class="fe mb mc md me b">throw</code>；</li><li id="296e" class="ks kt ix jw b jx lb kb lc kf ld kj le kn lf kr ly ky kz la bi translated">以及不可恢复:<code class="fe mb mc md me b">assert()</code>、<code class="fe mb mc md me b">precondition()</code>、<code class="fe mb mc md me b">fatalError()</code>。</li></ul><p id="4093" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不可恢复策略通常更适合处理逻辑错误；可恢复是针对运行时错误的。选择最明智的策略有助于提高代码质量，并使程序员的意图更加清晰。</p><p id="903a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢反馈，任何在牛奶通道下的东西。</p><p id="de66" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">编码快乐！！！</p></div></div>    
</body>
</html>