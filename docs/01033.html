<html>
<head>
<title>C++ Template Story So Far(C++11 to C++20)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">到目前为止的C++模板故事(C++11到C++20)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-template-story-so-far-c-11-to-c-20-6c59a6944a71?source=collection_archive---------21-----------------------#2020-06-22">https://blog.devgenius.io/c-template-story-so-far-c-11-to-c-20-6c59a6944a71?source=collection_archive---------21-----------------------#2020-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c610f92aebf78042176b7b0a2cd082cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqiNIbOA8UJPnZ068dR_kQ.jpeg"/></div></div></figure><p id="9c0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道，我已经有一段时间没有在博客上发表对新手友好的东西了。主要原因是我的大多数读者要么是有经验的开发人员，要么是有C背景的人，对C++有一定的了解。但是用C++编程时，你需要完全不同的思维方式，因为C &amp; C++属于不同的编程范式。我总是努力向他们展示用C++做事情的更好的方法。无论如何，我发现这个主题很长，相当复杂(至少对我来说是这样)，对新手友好，对有经验的人有激励作用(如果添加了<a class="ae kt" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代C++ </a>术语，规则&amp;特性)，即C++模板。</p><blockquote class="ku kv kw"><p id="44c5" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kt" href="http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">。</em></p></blockquote><p id="1f07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将从一个简单的类/函数模板开始，随着我们的进展，将增加复杂性。还涵盖了高级主题，如<a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">可变模板</a>、嵌套模板、CRTP、模板与折叠表达式等。但是，是的！我们不会深入探讨，否则这将成为一本书，而不是一篇文章。</p><p id="cb1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">注:</em> </strong> <em class="kx">我会推荐你在任何你觉得困惑的地方使用</em><a class="ae kt" href="https://cppinsights.io/" rel="noopener ugc nofollow" target="_blank"><em class="kx">cppinsights</em></a><em class="kx">在线工具。它帮助你看到模板实例，模板参数演绎等。基本上，它帮助你从编译器的角度看代码。</em></p><h1 id="eddf" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">您可能面临的术语/行话/习语</h1><ul class=""><li id="cfb8" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io">模板实例化</strong>:针对模板参数的特定组合，从模板化的类/结构/联合/函数中生成具体的类/结构/联合/函数的过程。比如你用<code class="fe mk ml mm mn b">vector&lt;int&gt;</code> &amp; <code class="fe mk ml mm mn b">vector&lt;char&gt;</code>，编译时会创建两个不同的具体类。这个创建具体类的过程被称为模板实例化。</li><li id="b5b8" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated"><strong class="jx io">模板实例</strong>:模板实例化的结果是模板实例，即具体的类。</li><li id="de8d" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated"><strong class="jx io">显式模板实例化</strong>:通常在对象声明时进行模板实例化。但是，您也可以强制编译器实例化具有特定类型的类/结构/联合/函数，甚至无需创建对象。它可能出现在程序中模板定义之后的任何地方，并且用于给定的参数列表。将在本文后面看到这一点。</li><li id="1a07" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated"><strong class="jx io">模板实参vs模板形参</strong>:在表达式<code class="fe mk ml mm mn b">template&lt;typename <em class="kx">T</em>&gt; void print(<em class="kx">T a</em>){ };</code>中，调用<code class="fe mk ml mm mn b">print(5);</code>时<code class="fe mk ml mm mn b">T</code>是形参&amp;，类型为<code class="fe mk ml mm mn b">int</code>的<code class="fe mk ml mm mn b">5</code>是模板实参。这对于一些pip来说是微不足道的事情。但不适合非英语母语者或初学者。所以，这种模糊性必须明确。</li></ul><h1 id="5837" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++模板类型</h1><h1 id="f793" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类别模板</h1><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="9afc" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T1, typename T2&gt;<br/>class pair {<br/>public:<br/>    T1  first;<br/>    T2  second;<br/>};</span><span id="a501" class="nb lc in mn b gy ng nd l ne nf">pair&lt;int, char&gt; p1;<br/>pair&lt;float, float&gt; p2;</span></pre><ul class=""><li id="1c39" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">类模板的基本思想是模板参数，即<code class="fe mk ml mm mn b">T1</code> &amp; <code class="fe mk ml mm mn b">T2</code>在编译时被一个适当的推导类型所替代。结果是同一个类可以被多种类型重用。</li><li id="beeb" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">并且当声明该类的对象时，用户必须指定他们想要使用的类型。</li></ul><h1 id="128f" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能模板</h1><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="ca3c" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>T min(T a, T b) {<br/>    return a &lt; b ? a : b;<br/>}</span><span id="ce14" class="nb lc in mn b gy ng nd l ne nf">min&lt;int&gt;(4, 5);              // Case 1 <br/>min&lt;float&gt;(4.1f, 5.1f);      // Case 2</span></pre><ul class=""><li id="b082" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">在上述两种情况下，模板实参用来替换参数的类型即<code class="fe mk ml mm mn b">T</code>。</li><li id="7de9" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">模板函数的一个附加属性(与C++17之前的类模板不同)是，编译器可以根据传递给函数的参数来推断模板参数。所以，在函数名后传递<code class="fe mk ml mm mn b">&lt;int&gt;</code> &amp; <code class="fe mk ml mm mn b">&lt;float&gt;</code>是多余的。</li></ul><h1 id="3fe8" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">联合模板</h1><ul class=""><li id="21ac" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">是啊！联合也可以被模板化。事实上，标准库提供了一些实用程序，如<code class="fe mk ml mm mn b"><a class="ae kt" href="https://en.cppreference.com/w/cpp/utility/optional" rel="noopener ugc nofollow" target="_blank">std::optional</a></code>、<code class="fe mk ml mm mn b"><a class="ae kt" href="https://en.cppreference.com/w/cpp/utility/variant" rel="noopener ugc nofollow" target="_blank">std::variant</a></code>等。它直接或间接使用模板化联合。</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="609f" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>union test {<br/>    uint8_t     ch[sizeof(T)];<br/>    T           variable;<br/>};</span></pre><ul class=""><li id="6086" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">正如你在上面看到的，<strong class="jx io"> <em class="kx">模板化的联合对于将一个类型同时表示为一个字节数组</em> </strong>也特别有用。</li></ul><h1 id="050b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可变模板</h1><ul class=""><li id="b5e7" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">是啊！这可能有点索克。但是，<strong class="jx io"> <em class="kx">你也可以从C++14 </em> </strong>开始对变量进行模板化。</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="b775" class="nb lc in mn b gy nc nd l ne nf">template &lt;class T&gt;<br/>constexpr T pi = T(3.1415926535897932385L); // variable template</span><span id="5812" class="nb lc in mn b gy ng nd l ne nf">cout &lt;&lt; pi&lt;float&gt; &lt;&lt; endl; // 3.14159<br/>cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl;   // 3</span></pre><ul class=""><li id="f005" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">现在，你可能想知道模板化变量的意义。但是，请考虑以下示例:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="6d16" class="nb lc in mn b gy nc nd l ne nf">template &lt;uint32_t val&gt;<br/>constexpr auto fib = fib&lt;val - 1&gt; + fib&lt;val - 2&gt;;</span><span id="06ae" class="nb lc in mn b gy ng nd l ne nf">template &lt;&gt;<br/>constexpr auto fib&lt;0&gt; = 0;</span><span id="3ff9" class="nb lc in mn b gy ng nd l ne nf">template &lt;&gt;<br/>constexpr auto fib&lt;1&gt; = 1;</span><span id="3162" class="nb lc in mn b gy ng nd l ne nf">cout &lt;&lt; fib&lt;10&gt; &lt;&lt; endl;    // 55</span></pre><ul class=""><li id="af2e" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">以上代码在编译时给出了第10个斐波那契项，甚至没有创建类或函数。</li></ul><h1 id="4956" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++模板参数</h1><h1 id="9bd1" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">覆盖模板参数推导</h1><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="04ef" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>T min(T a, T b) {<br/>    cout &lt;&lt; typeid(T).name() &lt;&lt; endl; // T will be deduce as `int`<br/>    return a &lt; b ? a : b;<br/>}</span><span id="b8ff" class="nb lc in mn b gy ng nd l ne nf">min&lt;int&gt;(5.5f, 6.6f);     // Implicit conversion happens here</span></pre><h1 id="0947" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">默认模板参数</h1><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="9228" class="nb lc in mn b gy nc nd l ne nf">template &lt;class T, size_t N = 10&gt;<br/>struct array {<br/>    T arr[N];<br/>};</span><span id="3a3b" class="nb lc in mn b gy ng nd l ne nf">array&lt;int&gt; arr;</span></pre><ul class=""><li id="a5f6" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">就像函数参数一样，模板参数也可以有它们的默认值。</li><li id="afb4" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">所有带有默认值的模板参数都必须在模板参数列表的末尾声明。</li></ul><h1 id="562c" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模板参数演绎</h1><h2 id="a056" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">函数模板参数推导</h2><ul class=""><li id="b565" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">根据<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction" rel="noopener ugc nofollow" target="_blank">标准</a>中的规则，通过将函数参数的类型与函数参数进行比较来完成函数模板参数推导。这使得函数模板比其他情况下更加有用。例如，给定如下函数模板:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="9d6f" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename RanIt&gt; <br/>void sort(RanIt first, RanIt last){<br/>    // . . .<br/>}</span></pre><ul class=""><li id="9664" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">您可以并且应该对一个<code class="fe mk ml mm mn b">std::vector&lt;int&gt;</code>进行排序，而不需要明确指定<code class="fe mk ml mm mn b">RanIt</code>是<code class="fe mk ml mm mn b">std::vector&lt;int&gt;::iterator</code>。当编译器看到<code class="fe mk ml mm mn b">sort(v.begin(), v.end());</code>时，它知道<code class="fe mk ml mm mn b">v.begin()</code>和<code class="fe mk ml mm mn b">v.end()</code>的类型是什么，所以它可以确定<code class="fe mk ml mm mn b">RanIt</code>应该是什么。</li></ul><h2 id="905f" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">分类模板参数推导(CTAD)</h2><ul class=""><li id="e4db" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">在C++17之前，模板类不能像模板函数那样在初始化时应用类型演绎。例如</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="9f04" class="nb lc in mn b gy nc nd l ne nf">//...<br/>pair p4{1, 'A'};               // Not OK until C++17: Can't deduce type in initialization <br/>//...</span></pre><ul class=""><li id="968d" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">但是<strong class="jx io"> <em class="kx">从C++17开始，编译器就可以在class/struct初始化中推导出类型</em> </strong> &amp;要做到这一点，class/struct必须有一个合适的构造函数。但这个限制在C++20中也放宽了。所以从技术上来说<strong class="jx io"> <em class="kx">来自C++20，你可以用</em> </strong> <a class="ae kt" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kx">聚合初始化</em> </strong> </a> <strong class="jx io"> <em class="kx"> &amp;构造对象，而不用显式指定类型</em> </strong>。</li><li id="343c" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">直到C++17，该标准提供了一些<code class="fe mk ml mm mn b">std::make_</code>实用函数来应对如下情况。</li></ul><p id="ba90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">通过函数模板推断模板参数</strong></p><ul class=""><li id="ce9c" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">你可能见过很多像<code class="fe mk ml mm mn b">std::make_pair()</code>、<code class="fe mk ml mm mn b">std::make_unique()</code>、<code class="fe mk ml mm mn b">std::make_share()</code>等函数。这通常可以非物理地实现为:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="ea1c" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T1, typename T2&gt;<br/>pair&lt;T1, T2&gt; make_pair(T1&amp;&amp; t1, T2&amp;&amp; t2) {<br/>    return {forward&lt;T1&gt;(t1), forward&lt;T2&gt;(t2)};<br/>}</span></pre><ul class=""><li id="0153" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">但是你有没有想过为什么标准库中会有这些辅助函数？这有什么用？</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="4cbb" class="nb lc in mn b gy nc nd l ne nf">pair&lt;int, char&gt; p1{1, 'A'};          // Rather using this</span><span id="a03f" class="nb lc in mn b gy ng nd l ne nf">auto p2 = make_pair(1, 2);           // Use this instead<br/>auto p3 = make_pair&lt;float&gt;(1, 2.4f); // Or specify types explicitly</span></pre><ul class=""><li id="8aa9" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">您可以利用从函数模板推断模板参数的特性来构造对象，而不是显式地指定参数。在上面的例子中，模板参数推导是由效用函数<code class="fe mk ml mm mn b">make_pair</code>完成的。因此，我们创建了pair对象，而没有显式指定类型。</li><li id="634b" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">正如前面从C++17中讨论的，你甚至可以不用显式指定类型来构造对象，所以<code class="fe mk ml mm mn b">std::vector v{1,2,3,4};</code>是完全有效的语句。</li></ul><h1 id="e354" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模板参数转发</h1><h2 id="2287" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">C++模板引用折叠规则</h2><ul class=""><li id="240f" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">除了在模板参数中接受类型&amp;值。您可以启用模板来接受左值和右值引用。为此，您需要遵守引用折叠规则，如下所示:</li></ul><ol class=""><li id="9307" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">T&amp; &amp;</code>变成了<code class="fe mk ml mm mn b">T&amp;</code></li><li id="73ae" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">T&amp; &amp;&amp;</code>变成了<code class="fe mk ml mm mn b">T&amp;</code></li><li id="7409" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">T&amp;&amp; &amp;</code>变成了<code class="fe mk ml mm mn b">T&amp;</code></li><li id="90a0" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">T&amp;&amp; &amp;&amp;</code>变成了<code class="fe mk ml mm mn b">T&amp;&amp;</code></li></ol><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="06c8" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>void f(T &amp;&amp;t);</span></pre><ul class=""><li id="36c3" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">在上面的例子中，<code class="fe mk ml mm mn b">t</code>的真实类型取决于上下文。例如:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="3b3f" class="nb lc in mn b gy nc nd l ne nf">int x = 0;</span><span id="260f" class="nb lc in mn b gy ng nd l ne nf">f(0); // deduces as rvalue reference i.e. f(int&amp;&amp;)<br/>f(x); // deduces as lvalue reference i.e. f(int&amp;)</span></pre><ul class=""><li id="809f" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">在<code class="fe mk ml mm mn b">f(0);</code>的情况下，<code class="fe mk ml mm mn b">0</code>是<code class="fe mk ml mm mn b">int</code>类型的右值，因此<code class="fe mk ml mm mn b">T = int&amp;&amp;</code>，因此<code class="fe mk ml mm mn b">f(int&amp;&amp; &amp;&amp;t)</code>变成<code class="fe mk ml mm mn b">f(int&amp;&amp; t)</code>。</li><li id="c756" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">在<code class="fe mk ml mm mn b">f(x);</code>的情况下，<code class="fe mk ml mm mn b">x</code>是<code class="fe mk ml mm mn b">int</code>类型的左值，因此<code class="fe mk ml mm mn b">T = int&amp;</code>，从而<code class="fe mk ml mm mn b">f(int&amp; &amp;&amp;t)</code>变成<code class="fe mk ml mm mn b">f(int&amp; t)</code>。</li></ul><h2 id="7a61" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">完美转发|转发参考|通用参考</h2><ul class=""><li id="9425" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">为了将<code class="fe mk ml mm mn b">t</code>完美地转发到另一个功能，必须将<code class="fe mk ml mm mn b">std::forward</code>用作:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="e1d2" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>void func1(T &amp;&amp;t) {<br/>    func2(std::forward&lt;T&gt;(t));  // Forward appropriate lvalue or rvalue reference to another function<br/>}</span></pre><ul class=""><li id="8f23" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">转发引用也可以与可变模板一起使用:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="aa2b" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename... Args&gt;<br/>void func1(Args&amp;&amp;... args) {<br/>    func2(std::forward&lt;Args&gt;(args)...);<br/>}</span></pre><h2 id="d6c7" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">为什么我们首先需要转发参考？</h2><ul class=""><li id="2da9" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">这个问题的答案在于<a class="ae kt" href="http://www.vishalchovatiya.com/move-constructor-assignment-operator-with-shared-ptr/" rel="noopener ugc nofollow" target="_blank">移动语义</a>。不过，这个问题的简短回答是“根据值类别类型执行复制/移动”。</li></ul><h1 id="9795" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++模板类别</h1><h1 id="64d3" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">完全模板专门化</h1><ul class=""><li id="f794" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">模板具有为模板类/结构/联合/函数/方法的特定实例化定义实现的功能。</li></ul><h2 id="e9f9" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">函数模板专门化</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="69f1" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>T sqrt(T t) { /* Some generic implementation */ }</span><span id="f2b7" class="nb lc in mn b gy ng nd l ne nf">template&lt;&gt;<br/>int sqrt&lt;int&gt;(int i) { /* Highly optimized integer implementation */ }</span></pre><ul class=""><li id="0a45" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">在上面的例子中，编写<code class="fe mk ml mm mn b">sqrt(4.0)</code>的用户将获得通用实现，而<code class="fe mk ml mm mn b">sqrt(4)</code>将获得专用实现。</li></ul><h2 id="1476" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">类模板专门化</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="d0e4" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;       // Common case<br/>struct Vector {<br/>    void print() {}<br/>};</span><span id="b562" class="nb lc in mn b gy ng nd l ne nf">template &lt;&gt;                 // Special case<br/>struct Vector&lt;bool&gt; {<br/>    void print_bool() {}<br/>};</span><span id="9b16" class="nb lc in mn b gy ng nd l ne nf">Vector&lt;int&gt; v1;<br/>v1.print_bool();    // Not OK: Chose common case Vector&lt;T&gt;<br/>v1.print()          // OK</span><span id="8ae8" class="nb lc in mn b gy ng nd l ne nf">Vector&lt;bool&gt; v2;    // OK : Chose special case Vector&lt;bool&gt;</span></pre><h1 id="2aab" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">部分模板特化</h1><h2 id="72b3" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">分部类模板专门化</h2><ul class=""><li id="8050" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">与完全模板特殊化相反，你也可以部分特殊化模板，并修改现有模板的一些参数。部分模板专门化仅可用于模板类/结构/联合:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="983d" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T1, typename T2&gt;     // Common case<br/>struct Pair {<br/>    T1 first;<br/>    T2 second;</span><span id="4c2d" class="nb lc in mn b gy ng nd l ne nf">    void print_first() {}<br/>};</span><span id="81a2" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;    // Partial specialization on first argument as int<br/>struct Pair&lt;int, T&gt; {<br/>    void print() {}<br/>};</span><span id="2f19" class="nb lc in mn b gy ng nd l ne nf">// Use case 1 ----------------------------------------------------------<br/>Pair&lt;char, float&gt; p1;    // Chose common case<br/>p1.print_first();        // OK<br/>// p1.print();           // Not OK: p1 is common case &amp; it doesn't have print() method</span><span id="e53f" class="nb lc in mn b gy ng nd l ne nf">// Use case 2 ----------------------------------------------------------<br/>Pair&lt;int, float&gt; p2;     // Chose special case<br/>p2.print();              // OK<br/>// p2.print_first();     // Not OK: p2 is special case &amp; it does not have print_first()</span><span id="5413" class="nb lc in mn b gy ng nd l ne nf">// Use case 3 ----------------------------------------------------------<br/>// Pair&lt;int&gt; p3;         // Not OK: Number of argument should be same as Primary template</span></pre><h2 id="b030" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">部分函数模板专门化</h2><ul class=""><li id="c625" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io"> <em class="kx">不能部分专门化方法/函数</em> </strong>。函数模板只能是完全专门化的</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="5e1a" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T, typename U&gt;<br/>void foo(T t, U u) {<br/>    cout &lt;&lt; "Common case" &lt;&lt; endl;<br/>}</span><span id="e909" class="nb lc in mn b gy ng nd l ne nf">// OK.<br/>template &lt;&gt;<br/>void foo&lt;int, int&gt;(int a1, int a2) {<br/>    cout &lt;&lt; "Fully specialized case" &lt;&lt; endl;<br/>}</span><span id="70f7" class="nb lc in mn b gy ng nd l ne nf">// Compilation error: partial function specialization is not allowed.<br/>template &lt;typename U&gt;<br/>void foo&lt;string, U&gt;(string t, U u) {<br/>    cout &lt;&lt; "Partial specialized case" &lt;&lt; endl;<br/>}</span><span id="c6c8" class="nb lc in mn b gy ng nd l ne nf">foo(1, 2.1); // Common case<br/>foo(1, 2);   // Fully specialized case</span></pre><p id="b6aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">替代部分功能模板专门化</strong></p><ul class=""><li id="1860" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">正如我前面提到的，函数模板的部分专门化是不允许的。您可以使用<a class="ae kt" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know/" rel="noopener ugc nofollow" target="_blank"> SFINAE </a>和<code class="fe mk ml mm mn b">std::enable_if</code>进行如下操作:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="7960" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T, typename std::enable_if_t&lt;!std::is_pointer&lt;T&gt;::value&gt; * = nullptr&gt;<br/>void func(T val) {  <br/>    cout &lt;&lt; "Value" &lt;&lt; endl; <br/>}</span><span id="06a1" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T, typename std::enable_if_t&lt;std::is_pointer&lt;T&gt;::value&gt; * = nullptr&gt;<br/>void func(T val) {  // NOTE: function signature is NOT-MODIFIED<br/>    cout &lt;&lt; "Pointer" &lt;&lt; endl; <br/>}</span><span id="ed82" class="nb lc in mn b gy ng nd l ne nf">int a = 0;<br/>func(a);<br/>func(&amp;a);</span></pre><h1 id="53ca" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">非类型模板参数</h1><ul class=""><li id="5723" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">顾名思义，除了类型，还可以将模板参数声明为常量表达式，如地址、<a class="ae kt" href="http://www.vishalchovatiya.com/lvalue-rvalue-and-their-references-with-example-in-cpp/" rel="noopener ugc nofollow" target="_blank">引用</a>、积分、<a class="ae kt" href="http://www.vishalchovatiya.com/what-exactly-nullptr-is-in-cpp/" rel="noopener ugc nofollow" target="_blank"> std::nullptr_t </a>、枚举等。</li><li id="e705" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">像所有其他模板参数一样，非类型模板参数可以显式指定、默认或通过模板参数推导隐式派生。</li><li id="eec6" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">非类型模板的<strong class="jx io"> <em class="kx">更具体的用例是将一个普通数组传递给一个函数，而不显式指定它的大小</em> </strong>。一个更相关的例子是<code class="fe mk ml mm mn b">std::begin</code> &amp; <code class="fe mk ml mm mn b">std::end</code>标准库中数组文字的专门化:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="d022" class="nb lc in mn b gy nc nd l ne nf">template &lt;  class T, <br/>            size_t size&gt;     // Non Type Template<br/>T* begin(T (&amp;arr)[size]) {   // Array size deduced implicitly<br/>    return arr;<br/>}</span><span id="6cda" class="nb lc in mn b gy ng nd l ne nf">int arr[] = {1,2,3,4};<br/>begin(arr);                  // Do not have to pass size explicitly</span></pre><ul class=""><li id="bf73" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">非类型模板参数是实现模板递归的方法之一&amp;启用<a class="ae kt" href="https://en.wikipedia.org/wiki/Template_metaprogramming" rel="noopener ugc nofollow" target="_blank">模板元编程</a>。</li></ul><h1 id="555c" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嵌套模板:模板模板参数</h1><ul class=""><li id="4bed" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">有时我们必须将模板类型传递给另一个模板类型。在这种情况下，您不仅要考虑主模板类型，还要考虑嵌套模板类型。非常简单的模板-模板参数例子是:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="a148" class="nb lc in mn b gy nc nd l ne nf">template&lt;   <br/>            template &lt;typename&gt; class C, <br/>            typename T<br/>        &gt;<br/>void print_container(C&lt;T&gt; &amp;c) {<br/>    // . . .<br/>}</span><span id="eca2" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;<br/>class My_Type {<br/>    // . . .<br/>};</span><span id="d477" class="nb lc in mn b gy ng nd l ne nf">My_Type&lt;int&gt; t;<br/>print_container(t);</span></pre><h1 id="0a95" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可变模板</h1><ul class=""><li id="334f" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">定义接受可变数量和类型的参数的类/结构/联合/函数通常很有用。</li><li id="16ed" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">如果你已经使用过C，你会知道<code class="fe mk ml mm mn b">printf</code>函数可以接受任意数量的参数。这些功能完全通过宏或<a class="ae kt" href="https://stackoverflow.com/questions/3792761/what-is-ellipsis-operator-in-c" rel="noopener ugc nofollow" target="_blank">省略号运算符</a>实现。正因为如此，它有几个缺点，如<a class="ae kt" href="http://www.vishalchovatiya.com/cpp-type-casting-with-example-for-c-developers/" rel="noopener ugc nofollow" target="_blank">类型安全</a>，不能接受引用作为参数，等等。</li></ul><h2 id="9eb9" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">可变类模板</h2><h2 id="178c" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">实现简单的元组类(&gt; =C++14)</h2><ul class=""><li id="c4d2" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">因为C++11标准库引入了<code class="fe mk ml mm mn b"><a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>类，该类在编译时使用variadic模板接受可变数据成员。为了理解它的工作原理，我们将建立自己的ADT，就像<code class="fe mk ml mm mn b"><a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>一样</li><li id="84db" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">可变模板通常从通用(空)定义开始，这也是后面专门化中递归终止的基础:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="fa7a" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename... T&gt;<br/>struct Tuple { };</span></pre><ul class=""><li id="8b76" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">这已经允许我们定义一个空结构，即<code class="fe mk ml mm mn b">Tuple&lt;&gt; object;</code>，尽管这还不是很有用。接下来是递归案例专门化:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="8bd6" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            typename T, <br/>            typename... Rest<br/>        &gt;<br/>struct Tuple&lt;T, Rest...&gt; {<br/>    T               first;<br/>    Tuple&lt;Rest...&gt;  rest;</span><span id="3a51" class="nb lc in mn b gy ng nd l ne nf">    Tuple(const T&amp; f, const Rest&amp; ... r)<br/>        : first(f)<br/>        , rest(r...) {<br/>    }<br/>};</span><span id="3f44" class="nb lc in mn b gy ng nd l ne nf">Tuple&lt;bool&gt; t1(false);                      // Case 1<br/>Tuple&lt;int, char, string&gt; t2(1, 'a', "ABC"); // Case 2</span></pre><h2 id="1e2d" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">可变类模板是如何工作的？</h2><p id="eefc" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nw ki kj kk nx km kn ko ny kq kr ks ig bi translated">为了理解可变类模板，考虑上面的用例2，即<code class="fe mk ml mm mn b">Tuple&lt;int, char, string&gt; t2(1, 'a', "ABC");</code></p><ul class=""><li id="966d" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">声明首先匹配专门化，产生一个具有<code class="fe mk ml mm mn b">int first;</code>和<code class="fe mk ml mm mn b">Tuple&lt;char, string&gt; rest;</code>数据成员的结构。</li><li id="f8ba" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">rest定义再次与专门化相匹配，产生一个具有<code class="fe mk ml mm mn b">char first;</code>和<code class="fe mk ml mm mn b">Tuple&lt;string&gt; rest;</code>数据成员的结构。</li><li id="b62c" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">rest定义再次匹配这个专门化，创建自己的<code class="fe mk ml mm mn b">string first;</code>和<code class="fe mk ml mm mn b">Tuple&lt;&gt; rest;</code>成员。</li><li id="c29c" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">最后，这最后一个rest与基本用例定义相匹配，产生一个空结构。</li></ul><p id="c27a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以这样想象:</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="c702" class="nb lc in mn b gy nc nd l ne nf">Tuple&lt;int, char, string&gt;<br/>-&gt; int first<br/>-&gt; Tuple&lt;char, string&gt; rest<br/>    -&gt; char first<br/>    -&gt; Tuple&lt;string&gt; rest<br/>        -&gt; string first<br/>        -&gt; Tuple&lt;&gt; rest<br/>            -&gt; (empty)</span></pre><p id="bccc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对variadic temple更感兴趣，我已经写了一篇关于<a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">variatic Template c++:实现简单元组</a>的文章。</p><h2 id="6c38" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">可变函数模板</h2><ul class=""><li id="55b5" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">正如我们前面看到的，可变模板从空定义开始，即递归的基本情况。</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="db96" class="nb lc in mn b gy nc nd l ne nf">void print() {}</span></pre><ul class=""><li id="3edf" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">然后是递归案例专门化:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="4b65" class="nb lc in mn b gy nc nd l ne nf">template&lt;   <br/>            typename First, <br/>            typename... Rest                    // Template parameter pack<br/>        &gt;     <br/>void print(First first, Rest... rest) {         // Function parameter pack<br/>    cout &lt;&lt; first &lt;&lt; endl;<br/>    print(rest...);                             // Parameter pack expansion<br/>}</span></pre><ul class=""><li id="e98f" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">这就足以让我们使用变量数目和变量类型的打印函数了。例如:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="1a8d" class="nb lc in mn b gy nc nd l ne nf">print(500, 'a', "ABC");</span></pre><ul class=""><li id="14c5" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">您可以进一步优化打印功能与转发参考，<code class="fe mk ml mm mn b">if constexpr()</code> &amp; <code class="fe mk ml mm mn b">sizeof()</code>操作符为:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="d7cd" class="nb lc in mn b gy nc nd l ne nf">template&lt;   <br/>            typename First, <br/>            typename... Rest<br/>        &gt;     <br/>void print(First&amp;&amp; first, Rest&amp;&amp;... rest) {         <br/>    if constexpr(sizeof...(rest) &gt; 0) {             // Size of parameter pack<br/>        cout &lt;&lt; first &lt;&lt; endl;<br/>        print(std::forward&lt;Rest&gt;(rest)...);         // Forwarding reference<br/>    }<br/>    else {<br/>        cout &lt;&lt; first &lt;&lt; endl;<br/>    }<br/>}</span></pre><h2 id="dc67" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">可变函数模板是如何工作的？</h2><ul class=""><li id="8e9d" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">正如你所看到的，我们用三个参数调用了print，即<code class="fe mk ml mm mn b">print(500, 'a', "ABC");</code></li><li id="4dc4" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">在编译时编译器实例化3个不同的打印函数如下:</li></ul><ol class=""><li id="8e36" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">void print(int first, char __rest1, const char* __rest2)</code></li><li id="b84f" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">void print(char first, const char* __rest1)</code></li><li id="9877" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks nv mh mi mj bi translated"><code class="fe mk ml mm mn b">void print(const char* first)</code></li></ol><ul class=""><li id="7a66" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">将调用第一次打印(即接受3个参数)，打印第一个参数&amp; line <code class="fe mk ml mm mn b">print(rest…);</code>用第二次打印扩展(即接受2个参数)。这将继续下去，直到参数计数达到零。</li><li id="fcfd" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">这意味着每次调用print时，参数的数量都会减少一个&amp;其余的参数将由print的后续实例来处理。</li><li id="f7f4" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">因此，编译后print实例的数量等于参数的数量加上print的基本情况实例。因此，<strong class="jx io"> <em class="kx">可变模板也导致了更多的代码膨胀</em> </strong>。</li><li id="9667" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">如果你把上面的例子放到<a class="ae kt" href="https://cppinsights.io/" rel="noopener ugc nofollow" target="_blank"> cppinsights </a>中，你会得到更好的结果。并尝试理解所有的模板实例。</li></ul><h2 id="b495" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">折叠表达式与可变模板</h2><ul class=""><li id="cdb8" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">正如我们看到的，从C++11开始，变量模板是对C++模板的一个很好的补充。但是它有一些麻烦，比如你需要基本用例&amp;递归模板实现，等等。</li><li id="1ae8" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">所以，用<strong class="jx io"> <em class="kx"> C++17标准引入了一个新特性，命名为</em> </strong>。您可以将它与参数包一起使用，如下所示:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="ef13" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename... Args&gt;<br/>void print(Args &amp;&amp;... args) {<br/>    (void(cout &lt;&lt; std::forward&lt;Args&gt;(args) &lt;&lt; endl), ...);<br/>}</span></pre><ul class=""><li id="7e33" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">看，不需要神秘的样板。这个解决方案看起来不是更整洁吗？</li><li id="3ffd" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">总共有3种折叠方式:一元折叠、二元折叠和逗号折叠。这里我们已经完成了对逗号的左折叠。你可以在这里阅读更多关于折叠表达式<a class="ae kt" href="https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/fold-expressions" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><h1 id="cc4e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">混杂的</h1><h1 id="5ec0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++模板“typename”与“class”</h1><ul class=""><li id="db18" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><code class="fe mk ml mm mn b">typename</code>和<code class="fe mk ml mm mn b">class</code>在大多数情况下是可以互换的。</li><li id="737c" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">一般惯例是<code class="fe mk ml mm mn b">typename</code>用于具体类型(即，不依赖于进一步的模板参数),而<code class="fe mk ml mm mn b">class</code>用于依赖类型。</li><li id="c3d8" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">但是有些情况下<code class="fe mk ml mm mn b">typename</code>或者<code class="fe mk ml mm mn b">class</code>必须是确定的。例如</li></ul><h2 id="8f98" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">引用依赖类型</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="04b9" class="nb lc in mn b gy nc nd l ne nf">template&lt;typename container&gt;<br/>class Example {<br/>    using t1 = typename container::value_type; // value_type depends on template argument of container<br/>    using t2 = std::vector&lt;int&gt;::value_type;   // value_type is concrete type, so doesn't require typename<br/>};</span></pre><ul class=""><li id="0624" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">在引用依赖于模板参数的嵌套类型时，<code class="fe mk ml mm mn b">typename</code>是必需的。</li></ul><h2 id="d9db" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">要指定模板模板类型</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="b70e" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            template &lt;typename, typename&gt; class C, // `class` is must prior to C++17<br/>            typename T, <br/>            typename Allocator<br/>        &gt;<br/>void print_container(C&lt;T, Allocator&gt; container) {<br/>    for (const T&amp; v : container)<br/>        cout &lt;&lt; v &lt;&lt; endl;<br/>}</span><span id="3aac" class="nb lc in mn b gy ng nd l ne nf">vector&lt;int&gt; v;<br/>print_container(v);</span></pre><ul class=""><li id="1530" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">这在C++17中被纠正了，所以现在你也可以使用<code class="fe mk ml mm mn b">typename</code>了。</li></ul><h1 id="e521" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++11:模板类型别名</h1><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="b798" class="nb lc in mn b gy nc nd l ne nf">template&lt;typename T&gt; <br/>using pointer = T*;</span><span id="12b8" class="nb lc in mn b gy ng nd l ne nf">pointer&lt;int&gt; p = new int;   // Equivalent to: int* p = new int;<br/></span><span id="09f2" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;<br/>using v = vector&lt;T&gt;;</span><span id="cb5a" class="nb lc in mn b gy ng nd l ne nf">v&lt;int&gt; dynamic_arr;         // Equivalent to: vector&lt;int&gt; dynamic_arr;</span></pre><ul class=""><li id="d39a" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated"><code class="fe mk ml mm mn b">typedef</code>也能正常工作，但不会鼓励你使用。因为它不是现代C++的一部分。</li></ul><h1 id="0d52" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++14/17:模板和自动关键字</h1><ul class=""><li id="68c7" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io"> <em class="kx">从C++14开始，可以在函数实参</em> </strong>中使用  <code class="fe mk ml mm mn b"><strong class="jx io"><em class="kx">auto</em></strong></code> <strong class="jx io"> <em class="kx">。这是一种模板简写，如下所示:</em></strong></li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="bf2d" class="nb lc in mn b gy nc nd l ne nf">void print(auto &amp;c) { /*. . .*/ }</span><span id="2e46" class="nb lc in mn b gy ng nd l ne nf">// Equivalent to</span><span id="ecd1" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;<br/>void print(T &amp;c) { /*. . .*/ }</span></pre><ul class=""><li id="91da" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">虽然从C++11  开始支持函数return-type中的<code class="fe mk ml mm mn b"><strong class="jx io"><em class="kx">auto</em></strong></code> <strong class="jx io"> <em class="kx">。但是，你必须提到尾随返回类型。这是在C++14 &amp;中纠正的，现在返回类型是由编译器自动推导出来的。</em></strong></li><li id="faca" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated"><strong class="jx io"> <em class="kx">来自C++17，你也可以在非类型模板</em></strong><code class="fe mk ml mm mn b"><strong class="jx io"><em class="kx">auto</em></strong></code><strong class="jx io"><em class="kx">(我会在本文后面的部分涉及到这个)参数。</em></strong></li></ul><h1 id="f603" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++20:模板Lambda表达式</h1><ul class=""><li id="4452" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">从声明参数为<code class="fe mk ml mm mn b">auto</code>的C++14开始，支持<a class="ae kt" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">通用lambda表达式</a>。但是没有办法改变这个模板参数并使用真正的模板参数。例如:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="e0bf" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename T&gt;<br/>void f(std::vector&lt;T&gt;&amp;    vec) {<br/>    //. . .<br/>}</span></pre><ul class=""><li id="861c" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如何为上述函数编写lambda，该函数采用类型<code class="fe mk ml mm mn b">T</code>的<code class="fe mk ml mm mn b">std::vector</code>？这是C++17之前的限制，但在C++20中，<strong class="jx io"> <em class="kx">可以将lambda </em> </strong>模板化为:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="2541" class="nb lc in mn b gy nc nd l ne nf">auto f = []&lt;typename T&gt;(std::vector&lt;T&gt;&amp;  vec) {<br/>    // . . .<br/>};</span><span id="96f2" class="nb lc in mn b gy ng nd l ne nf">std::vector&lt;int&gt; v;<br/>f(v);</span></pre><h1 id="f70e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">显式模板实例化</h1><ul class=""><li id="a41b" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">显式实例化从模板中创建并声明具体的类/结构/联合/函数/变量，但还没有使用它。</li><li id="22d9" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">通常，您只需在头文件中实现模板。您不能将模板方法的实现/定义放在实现文件中(即cpp或。抄送)。如果这对你来说似乎是新的，那么考虑下面的极简主义例子:</li></ul><p id="16bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> value.hpp </strong></p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="0a98" class="nb lc in mn b gy nc nd l ne nf">#pragma once</span><span id="df8e" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;<br/>class value {<br/>    T val;<br/>public:<br/>    T get_value();<br/>};</span></pre><p id="820e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> value.cpp </strong></p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="fca1" class="nb lc in mn b gy nc nd l ne nf">#include "value.hpp"</span><span id="fd16" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename T&gt;<br/>T value&lt;T&gt;::get_value() { <br/>    return val; <br/>}</span></pre><p id="4f21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> main.cpp </strong></p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="3714" class="nb lc in mn b gy nc nd l ne nf">#include "value.hpp"</span><span id="00ec" class="nb lc in mn b gy ng nd l ne nf">int main() {<br/>    value&lt;int&gt; v1{9};<br/>    cout &lt;&lt; v1.get_value() &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><ul class=""><li id="ff10" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如果你编译上面的代码，你会得到下面的错误:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="42bf" class="nb lc in mn b gy nc nd l ne nf">/tmp/main-4b4bef.o: In function `main':<br/>main.cpp:(.text+0x1e): undefined reference to `value&lt;int&gt;::get_value()'<br/>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br/>compiler exit status 1</span></pre><ul class=""><li id="b7df" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如果进行显式初始化，即在<code class="fe mk ml mm mn b">value.cpp</code>的末尾添加<code class="fe mk ml mm mn b">template class value&lt;int&gt;;</code>行。然后编译成功。</li><li id="7da7" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">“模板类”命令使编译器显式地实例化模板类。在上面的例子中，编译器会在<code class="fe mk ml mm mn b">value.cpp</code>中去掉<code class="fe mk ml mm mn b">value&lt;int&gt;</code>。</li><li id="7d38" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">还有其他的解决方案。检查这个<a class="ae kt" href="https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" rel="noopener ugc nofollow" target="_blank">堆栈溢出链接</a>。</li></ul><h1 id="4d44" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++模板示例用例</h1><h1 id="2506" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奇怪的重复模板模式</h1><ul class=""><li id="3956" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know/#CRTP" rel="noopener ugc nofollow" target="_blank"> CRTP </a>广泛用于静态多态或代码重用，无需承担<a class="ae kt" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟调度机制</a>的成本。考虑以下代码:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="5933" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename specific_animal&gt;<br/>struct animal {<br/>    void who() { implementation().who(); }</span><span id="057a" class="nb lc in mn b gy ng nd l ne nf">private:<br/>    specific_animal &amp;implementation() { return *static_cast&lt;specific_animal *&gt;(this); }<br/>};</span><span id="18e5" class="nb lc in mn b gy ng nd l ne nf">struct dog : animal&lt;dog&gt; {<br/>    void who() { cout &lt;&lt; "dog" &lt;&lt; endl; }<br/>};</span><span id="3611" class="nb lc in mn b gy ng nd l ne nf">struct cat : animal&lt;cat&gt; {<br/>    void who() { cout &lt;&lt; "cat" &lt;&lt; endl; }<br/>};<br/></span><span id="783d" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename specific_animal&gt;<br/>void who_am_i(animal&lt;specific_animal&gt; *animal) {<br/>    animal-&gt;who();<br/>}<br/></span><span id="6e3e" class="nb lc in mn b gy ng nd l ne nf">who_am_i(new dog); // Prints `dog`<br/>who_am_i(new cat); // Prints `cat`</span></pre><ul class=""><li id="2dff" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">我们没有使用<a class="ae kt" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">虚拟关键字</a> &amp;仍然实现了多态性的功能(更确切地说是静态多态性)。</li><li id="7240" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">我已经写了一篇单独的文章，介绍了奇怪重复出现的模板模式的实例(CRTP)[TODO]。</li></ul><h1 id="419a" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将“std”容器作为C++模板参数传递</h1><ul class=""><li id="eca4" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">如果你想接受什么，然后再想办法解决，你可以这样写:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="914a" class="nb lc in mn b gy nc nd l ne nf">template &lt;typename C&gt;<br/>void print_container(const C &amp;container) {<br/>    for (const auto &amp;v : container)<br/>        cout &lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="3af9" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如果你传递标准容器之外的东西，这种简单的方法可能会失败，因为其他类型可能没有<code class="fe mk ml mm mn b">begin</code> &amp; <code class="fe mk ml mm mn b">end</code>迭代器。</li></ul><h1 id="72c7" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将std::vector传递给C++模板函数</h1><h2 id="e5eb" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">捕获容器值类型的简单方法</h2><ul class=""><li id="867a" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">但是假设，你想传递容器&amp;也想使用容器的存储类型。您可以:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="4cec" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            typename C, <br/>            typename T = typename C::value_type<br/>        &gt;<br/>void print_container(const C &amp;container) {<br/>    for (const T &amp;v : container)<br/>        cout &lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="8870" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">我们可以为我们的函数提供第二个类型参数，这个函数使用<a class="ae kt" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know/" rel="noopener ugc nofollow" target="_blank"> SFINAE </a>来验证这个东西实际上是一个容器。</li><li id="4db9" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated">所有标准容器都有一个名为<code class="fe mk ml mm mn b">value_type</code>的成员类型，它是容器内部事物的类型。我们寻找这种类型，如果不存在这种类型，那么<a class="ae kt" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know/" rel="noopener ugc nofollow" target="_blank"> SFINAE </a>就会出现，过载就不再考虑了。</li></ul><h2 id="f096" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">显式捕获容器的值类型</h2><ul class=""><li id="a176" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">但是如果你传递的vector类没有<code class="fe mk ml mm mn b">value_type</code>成员呢？</li><li id="bff9" class="lz ma in jx b jy mo kc mp kg mq kk mr ko ms ks mg mh mi mj bi translated"><code class="fe mk ml mm mn b">std::vector</code>的定义是:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="4034" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            class T,<br/>            class Allocator = std::allocator&lt;T&gt;<br/>        &gt; <br/>class vector;</span></pre><ul class=""><li id="2907" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">您可以显式地捕获<code class="fe mk ml mm mn b">std::vector</code>容器的两个模板参数，如下所示:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="7741" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            template &lt;typename, typename&gt; class C, <br/>            typename T, <br/>            typename Allocator<br/>        &gt;<br/>void print_container(C&lt;T, Allocator&gt; container) {<br/>    for (const T&amp; v : container)<br/>        cout &lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="f147" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如果要将容器传递给类/结构/联合，上述模板模式将是相同的。</li></ul><h1 id="1a70" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将任何容器传递给C++模板函数</h1><ul class=""><li id="cfe1" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">你看看你是否传递任何其他容器到上面的解决方案。没用的。所以为了使它通用，我们可以使用<a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">可变模板</a>:</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="69f9" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            template &lt;typename...&gt; class C, <br/>            typename... Args<br/>        &gt;<br/>void print_container(C&lt;Args...&gt; container) {<br/>    for (const auto &amp;v : container)<br/>        cout &lt;&lt; v &lt;&lt; endl;<br/>}</span><span id="c264" class="nb lc in mn b gy ng nd l ne nf">vector&lt;int&gt;     v{1, 2, 3, 4}; // takes total 2 template type argument<br/>print_container(v); </span><span id="24c2" class="nb lc in mn b gy ng nd l ne nf">set&lt;int&gt;        s{1, 2, 3, 4}; // takes total 3 template type argument<br/>print_container(s);</span></pre><h1 id="2cd7" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将容器中的容器/2D标准::向量作为C++模板参数传递</h1><ul class=""><li id="e1fc" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">这是嵌套模板的情况，即模板-模板参数。并且有以下解决方案:</li></ul><h2 id="c051" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">显式复杂解决方案</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="f45f" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            template &lt;typename, typename&gt; class C1,<br/>            template &lt;typename, typename&gt; class C2,<br/>            typename Alloc_C1, typename Alloc_C2,<br/>            typename T<br/>        &gt;<br/>void print_container(const C1&lt;C2&lt;T, Alloc_C2&gt;, Alloc_C1&gt; &amp;container) {<br/>    for (const C2&lt;T, Alloc_C2&gt; &amp;container_in : container)<br/>        for (const T &amp;v : container_in)<br/>            cout &lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="d261" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">我知道这是丑陋的，但似乎更明确。</li></ul><h2 id="a255" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">解决方案干净利落</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="823a" class="nb lc in mn b gy nc nd l ne nf">template&lt;   <br/>            typename T1,<br/>            typename T2 = typename T1::value_type,<br/>            typename T3 = typename T2::value_type<br/>        &gt;<br/>void print_container(const T1 &amp;container) {<br/>    for (const T2 &amp;e : container)<br/>        for (const T3 &amp;x : e)<br/>            cout &lt;&lt; x &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="cdc9" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">如前所述包括<a class="ae kt" href="http://www.vishalchovatiya.com/7-advance-cpp-concepts-idiom-examples-you-should-know" rel="noopener ugc nofollow" target="_blank"> SFINAE </a>。</li></ul><h2 id="6d30" class="nb lc in bd ld nk nl dn lh nm nn dp ll kg no np lp kk nq nr lt ko ns nt lx nu bi translated">通用解决方案:使用可变模板</h2><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="de35" class="nb lc in mn b gy nc nd l ne nf">template&lt;<br/>            template &lt;typename...&gt; class C, <br/>            typename... Args<br/>        &gt;<br/>void print_container(C&lt;Args...&gt; container) {<br/>    for (const auto &amp;container_2nd : container)<br/>        for (const auto &amp;v : container_2nd)<br/>            cout &lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="163b" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">这是我们使用可变模板的标准解决方案，适用于单个容器或任意数量的嵌套容器。</li></ul><h1 id="1341" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将函数传递给类模板参数</h1><ul class=""><li id="6407" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">将类/结构/联合作为模板参数传递给另一个类/结构/联合是常见的事情。但是将函数作为模板参数传递给类/结构/联合有点罕见。但是的确有可能。考虑使用<a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">可变类模板</a>的<a class="ae kt" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">函数装饰器</a>。</li></ul><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="1535" class="nb lc in mn b gy nc nd l ne nf">// Need partial specialization for this to work<br/>template &lt;typename T&gt;<br/>struct Logger;</span><span id="c783" class="nb lc in mn b gy ng nd l ne nf">// Return type and argument list<br/>template &lt;typename R, typename... Args&gt;<br/>struct Logger&lt;R(Args...)&gt; {<br/>    function&lt;R(Args...)&gt;    m_func;<br/>    string                  m_name;<br/>    Logger(function&lt;R(Args...)&gt; f, const string &amp;n) : m_func{f}, m_name{n} { }</span><span id="020d" class="nb lc in mn b gy ng nd l ne nf">    R operator()(Args... args) {<br/>        cout &lt;&lt; "Entering " &lt;&lt; m_name &lt;&lt; endl;<br/>        R result = m_func(args...);<br/>        cout &lt;&lt; "Exiting " &lt;&lt; m_name &lt;&lt; endl;<br/>        return result;<br/>    }<br/>};</span><span id="c3ce" class="nb lc in mn b gy ng nd l ne nf">template &lt;typename R, typename... Args&gt;<br/>auto make_logger(R (*func)(Args...), const string &amp;name) {<br/>    return Logger&lt;R(Args...)&gt;(function&lt;R(Args...)&gt;(func), name);<br/>}</span><span id="5ad9" class="nb lc in mn b gy ng nd l ne nf">double add(double a, double b) { return a + b; }</span><span id="989a" class="nb lc in mn b gy ng nd l ne nf">int main() {<br/>    auto logged_add = make_logger(add, "Add");<br/>    auto result = logged_add(2, 3);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="9fd3" class="lz ma in jx b jy jz kc kd kg nh kk ni ko nj ks mg mh mi mj bi translated">乍一看，上面的例子可能有点复杂。但是如果你对<a class="ae kt" href="http://www.vishalchovatiya.com/variadic-template-cpp-implementing-unsophisticated-tuple/" rel="noopener ugc nofollow" target="_blank">变异职业神殿</a>有清晰的理解，那么你不会花超过30秒的时间来理解这里发生的事情。</li></ul><h1 id="e92f" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fd42" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nw ki kj kk nx km kn ko ny kq kr ks ig bi translated">我希望我已经涵盖了C++模板的大部分主题。是的，这是一篇很长很激烈的文章。但是我敢打赌，如果你真的很好地掌握了C++模板，它真的会给你一个优势。也打开了C++子世界的一扇门，即模板元编程。</p><p id="b233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe mk ml mm mn b"><a class="ae kt" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kt" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>