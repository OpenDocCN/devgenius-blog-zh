<html>
<head>
<title>Distribute Volume in glusterfs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在glusterfs中分配体积</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/distribute-volume-in-glusterfs-de167af1d518?source=collection_archive---------5-----------------------#2020-07-21">https://blog.devgenius.io/distribute-volume-in-glusterfs-de167af1d518?source=collection_archive---------5-----------------------#2020-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bfa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事是关于glusterfs中一个简单的分发卷。如何创建它以及它与复制卷有何不同。这是上一个关于在glusterfs 中复制卷的故事的延续。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/db0a97f35ba8c6b9d16ef6202d67e51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*rFsU9Ee-TAuTpUa7TUGskw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在glusterfs中分配体积</figcaption></figure><p id="b0bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，使用复制卷将保证数据可靠性的基本水平。但这不是用户唯一关心的问题，对吗？</p><p id="e597" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对…如果我使用文件系统，我会期望可靠性，但同时，我不会仅仅在所有N个磁盘中创建N个数据副本。我也期待一些分配。所以这是一个分配和复制的平衡行为。(现在，我们还有地理复制和其他场景，但在本案例中，我们将假设我们只知道复制和分发卷。)</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="d3f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要展示一个基本的分布式设置。一台服务器足以展示该功能，但我们还是用一台服务器吧</p><p id="cab7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的设置有三个Fedora 32虚拟机，每个都有2个CPU、2 GB RAM、20 GB主磁盘和另外10 GB，我已经在xfs中格式化并挂载了这些虚拟机(用于构建块)。</p><p id="d5e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，正如最初的图片所示，我们有三个节点(或服务器)，当我说分发时，数据将在这些节点(服务器)之间分发。我们不会深入研究数据如何在节点之间分布的逻辑(咳咳DHT)，这需要它自己的故事。</p><p id="6763" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到步骤…我有三台虚拟机服务器a、服务器b和服务器c</p><p id="db3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用以下命令在所有虚拟机中启动glusterfs服务</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="8f6e" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# systemctl start glusterd</span></pre><p id="f250" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果还没有开始的话。</p><p id="1f8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦启动(您可以检查状态，并确保守护进程不会由于某些错误而终止。必须检查是否所有的初始配置都已正确完成。)，我们只需要创建一个可信的存储池(我们的集群)。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="6dae" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster peer probe serverb<br/>peer probe: success</span></pre><p id="02b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对第三台服务器重复相同的步骤。请记住，从已经是集群一部分的任何节点进行探测(这意味着在我的例子中，由于servera和serverb在集群中，我应该从这两个节点探测serverc，而不是从serverc探测这些对等节点)。</p><p id="9c18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成后，只需检查对等状态以确保一切正常。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="e72a" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster peer status<br/>Number of Peers: 2</span><span id="b6de" class="lh li in ld b gy ln lk l ll lm">Hostname: serverb<br/>Uuid: 6ae1884c-b2ee-4cae-b930-7a7124567cc0<br/>State: Peer in Cluster (Connected)</span><span id="e188" class="lh li in ld b gy ln lk l ll lm">Hostname: serverc<br/>Uuid: 8133a337-c622-4fad-b704-447a33ddc909<br/>State: Peer in Cluster (Connected)</span></pre><p id="e439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！</p><p id="7d9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续下一步，即卷创建。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="b0e4" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster vol create vol-1 \<br/>&gt; servera:/data/glusterfs/vol-1/brick \<br/>&gt; serverb:/data/glusterfs/vol-1/brick \<br/>&gt; serverc:/data/glusterfs/vol-1/brick<br/>volume create: vol-1: success: please start the volume to access <br/>data</span></pre><p id="4c7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，要检查创建的卷的信息，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="544d" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster vol info vol-1<br/> <br/>Volume Name: vol-1<br/>Type: Distribute<br/>Volume ID: fc00a6b7-970c-49b5-a4dd-45c2022edbc5<br/>Status: Created<br/>Snapshot Count: 0<br/>Number of Bricks: 3<br/>Transport-type: tcp<br/>Bricks:<br/>Brick1: severra:/data/glusterfs/vol-1/brick<br/>Brick2: serverb:/data/glusterfs/vol-1/brick<br/>Brick3: serverc:/data/glusterfs/vol-1/brick<br/>Options Reconfigured:<br/>storage.fips-mode-rchecksum: on<br/>transport.address-family: inet<br/>nfs.disable: on</span></pre><p id="4a76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以继续启动音量，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="0735" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster volume start vol-1<br/>volume start: vol-1: success</span></pre><p id="4b66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">启动后，我们可以看到状态，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="c0d9" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# gluster vol status vol-1<br/>Status of volume: vol-1<br/>Gluster process                             TCP Port  RDMA Port  Online  Pid<br/>------------------------------------------------------------------------------<br/>Brick severra:/data/glusterfs/vol-1/brick                    49152     0          Y       1881182<br/>Brick severrb:/data/glusterfs/vol-1/brick                    49152     0          Y       337724<br/>Brick severrc:/data/glusterfs/vol-1/brick                    49152     0          Y       248403<br/> <br/>Task Status of Volume vol-1<br/>------------------------------------------------------------------------------<br/>There are no active volume tasks</span></pre><p id="d587" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们的卷已经启动，我们可以挂载它并开始探索它。让我们在安装了glusterfs-client包后挂载它。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="0b92" class="lh li in ld b gy lj lk l ll lm">[root@serverd ~]# mount -t glusterfs servera:vol-1 /mnt/vol-1</span></pre><p id="d852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，一旦挂载完毕，让我们在挂载点内创建三个目录。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="6560" class="lh li in ld b gy lj lk l ll lm">[root@serverd vol-1]# mkdir dir{1..3}<br/>[root@serverd vol-1]# tree<br/>.<br/>├── dir1<br/>├── dir2<br/>└── dir3</span><span id="1a80" class="lh li in ld b gy ln lk l ll lm">3 directories, 0 files</span></pre><p id="8f14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看引擎盖下是什么，(技术上讲，砖里发生了什么。)</p><p id="3d6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们转到servera并导航到brick目录，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="ce3c" class="lh li in ld b gy lj lk l ll lm">[root@servera ~]# cd /data/glusterfs/vol-1/brick<br/>[root@servera brick]# tree<br/>.<br/>├── dir1<br/>├── dir2<br/>└── dir3</span><span id="a1b1" class="lh li in ld b gy ln lk l ll lm">3 directories, 0 files</span></pre><p id="16f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯…另外两个服务器的情况如何？</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="7270" class="lh li in ld b gy lj lk l ll lm">[root@serverb ~]# cd /data/glusterfs/vol-1/brick<br/>[root@serverb brick]# tree<br/>.<br/>├── dir1<br/>├── dir2<br/>└── dir3</span><span id="68f3" class="lh li in ld b gy ln lk l ll lm">3 directories, 0 files</span></pre><p id="5c26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而在serverc？</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="1342" class="lh li in ld b gy lj lk l ll lm">[root@serverc ~]# cd /data/glusterfs/vol-1/brick<br/>[root@serverc brick]# tree<br/>.<br/>├── dir1<br/>├── dir2<br/>└── dir3</span><span id="9951" class="lh li in ld b gy ln lk l ll lm">3 directories, 0 files</span></pre><p id="9c59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">等等，我们不是在用分布式卷吗？</p><p id="1adc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在得出结论之前，让我们先做一件小事。让我们在每个目录中创建10个文件，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="76c4" class="lh li in ld b gy lj lk l ll lm">[root@serverd vol-1]# touch dir{1..3}/file{1..10}<br/>[root@serverd vol-1]# tree<br/>.<br/>├── dir1<br/>│   ├── file1<br/>│   ├── file10<br/>│   ├── file2<br/>│   ├── file3<br/>│   ├── file4<br/>│   ├── file5<br/>│   ├── file6<br/>│   ├── file7<br/>│   ├── file8<br/>│   └── file9<br/>├── dir2<br/>│   ├── file1<br/>│   ├── file10<br/>│   ├── file2<br/>│   ├── file3<br/>│   ├── file4<br/>│   ├── file5<br/>│   ├── file6<br/>│   ├── file7<br/>│   ├── file8<br/>│   └── file9<br/>└── dir3<br/>    ├── file1<br/>    ├── file10<br/>    ├── file2<br/>    ├── file3<br/>    ├── file4<br/>    ├── file5<br/>    ├── file6<br/>    ├── file7<br/>    ├── file8<br/>    └── file9</span><span id="0c36" class="lh li in ld b gy ln lk l ll lm">3 directories, 30 files</span></pre><p id="50a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们看看每台服务器都有哪些模块…</p><p id="7aab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">servera，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="fc42" class="lh li in ld b gy lj lk l ll lm">[root@servera brick]# tree<br/>.<br/>├── dir1<br/>│   ├── file10<br/>│   ├── file3<br/>│   ├── file4<br/>│   ├── file7<br/>│   └── file9<br/>├── dir2<br/>│   ├── file5<br/>│   ├── file6<br/>│   └── file8<br/>└── dir3<br/>    ├── file5<br/>    ├── file6<br/>    └── file8</span><span id="fe35" class="lh li in ld b gy ln lk l ll lm">3 directories, 11 files</span></pre><p id="0a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务器b，</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="7838" class="lh li in ld b gy lj lk l ll lm">[root@serverb brick]# tree<br/>.<br/>├── dir1<br/>│   ├── file1<br/>│   └── file2<br/>├── dir2<br/>│   ├── file10<br/>│   ├── file3<br/>│   ├── file4<br/>│   ├── file7<br/>│   └── file9<br/>└── dir3<br/>    ├── file10<br/>    ├── file3<br/>    ├── file4<br/>    ├── file7<br/>    └── file9</span><span id="4542" class="lh li in ld b gy ln lk l ll lm">3 directories, 12 files</span></pre><p id="d5d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，服务器c</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="76a4" class="lh li in ld b gy lj lk l ll lm">[root@serverc brick]# tree<br/>.<br/>├── dir1<br/>│   ├── file5<br/>│   ├── file6<br/>│   └── file8<br/>├── dir2<br/>│   ├── file1<br/>│   └── file2<br/>└── dir3<br/>    ├── file1<br/>    └── file2</span><span id="c868" class="lh li in ld b gy ln lk l ll lm">3 directories, 7 files</span></pre><p id="0170" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您合计文件总数时，目录dir1、dir2和dir3。结果是10个(在每个目录中)。现在，用户仍然可以手动检查是否有任何文件重复，但是，正如其名称所示，这是一个分布式卷。</p><p id="7578" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在分布卷的情况下，分布的是挂载点内目录中的底层文件。目录不是。这些文件是。</p><p id="0b8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，一种试验方法是在挂载点内创建100K个目录，然后检查它是在所有节点中创建的还是分布式的。</p><p id="ad64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个简单分布式卷。现在，可能随着上述实验，人们也可以看到如何组合分布式和复制卷。</p></div></div>    
</body>
</html>