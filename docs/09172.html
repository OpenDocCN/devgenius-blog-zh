<html>
<head>
<title>Combine multiple csv/excel files into a single table (Python Pandas)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将多个 csv/excel 文件合并到一个表格中(Python Pandas)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/combine-multiple-csv-excel-files-into-a-single-table-python-pandas-18d2aaa10986?source=collection_archive---------12-----------------------#2022-08-03">https://blog.devgenius.io/combine-multiple-csv-excel-files-into-a-single-table-python-pandas-18d2aaa10986?source=collection_archive---------12-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/94b8b60ef5cb663bef45a8c035d189a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/0*nXYFLgkhBouKDg55"/></div></figure><h1 id="3710" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">读取文件</h1><p id="f3f6" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在我的<a class="ae ln" href="https://www.linkedin.com/pulse/turn-excel-pandas-data-frame-python-chee-chuan-foo" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我已经展示了如何将 excel 或 csv 文件转换成 pandas 数据框架。当你只有一个 excel 文件需要处理的时候，这将是非常有用的。实际上，许多公司每天/每周/每月/每年都将数据分离到一个 csv 文件中。在这种情况下，您可能希望将它们结合起来分析所有数据，比如说，全年的数据。</p><p id="6dc1" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">为简单起见，我们将使用 csv 文件，其中包含由股票代号和年份分隔的每年的月度股票价格。在这个<a class="ae ln" href="https://drive.google.com/uc?export=download&amp;id=1W3eI3EF_q3G1jTBuHOGIH2XhFJETBRHg" rel="noopener ugc nofollow" target="_blank">数据文件夹</a>中，我们有苹果、亚马逊和微软的股票价格。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/c073a01c91b8ab38baddb43e902c7fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/0*LPh_AhjbfaSQROl4"/></div></figure><h1 id="c534" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">读取文件夹中的文件</h1><p id="48d8" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">为了读取文件夹中的所有文件，让我们编写代码列出指定文件夹中的所有文件。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6571" class="md js in lz b gy me mf l mg mh"># List out files in 'writeCSV' folder</span><span id="b44a" class="md js in lz b gy mi mf l mg mh">import os<br/>data_files = os.listdir('writeCSV')<br/>data_files</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c0fe53acbfcbbf922a9955c46c3c3d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/0*A5fPPW1UY43bBMD7"/></div></figure><p id="9bd2" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">这里，我们列出了“writeCSV”文件夹中的所有文件**您可能希望引用您自己的文件路径* *现在我们应该读取这些文件中的所有数据并将它们合并到一个表中。</p><h1 id="5abf" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">循环所有数据</h1><p id="7abb" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">首先，我们将遍历所有数据。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="40bc" class="md js in lz b gy me mf l mg mh">import pandas as pd<br/>for filename in data_files:<br/>    # Read data from each file<br/>    df = pd.read_csv(f'writeCSV/{filename}')<br/>    print(df)</span></pre><p id="85e6" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">现在的问题是，我们不知道哪一行属于哪个 excel 文件。因此，我们将添加另一列来指示它来自哪个 excel 文件。因此，让我们向表中添加列来表明它们的来源。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5493" class="md js in lz b gy me mf l mg mh">import pandas as pd<br/>for filename in data_files:<br/>    # Read data from each file<br/>    df = pd.read_csv(f'writeCSV/{filename}')<br/>    # Get ticker &amp; year from filename<br/>    csvTicker = filename[0:4]<br/>    csvYear = filename[5:9]<br/>    # Add columns "Ticker" and "Year" to the table<br/>    df['Ticker'] = csvTicker<br/>    df['Year'] = csvYear<br/>    print(df)</span></pre><p id="466d" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">请注意，我们的 excel 文件名中有一个模式:“MSFT-2009-月度-股票价格. csv”，前 4 个字母和后面的 4 个字母告诉我们该数据属于哪只股票和哪一年。data_files 中的 filename 是 string(文件名)filename[0:4]表示我们取第一个 4 字符。注意，我们从 0 开始计数，以 4 结束计数。0 是第一个元素的索引，4 是第五个元素的索引，依此类推。等等，我们不是只对前 4 个字符感兴趣吗？那我们为什么取[0:4]而不是[0:3]？而索引从 0 开始，python 中的[a，b]表示从 a 到 b-1 也就是省略最后一个数字。因此，文件名[0:4]将只采用前 4 个字符，而不是 5 个字符。</p><p id="1231" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">实际上，您可能会看到类似的模式，例如:“20211123Sales.csv”。在这种情况下，我们可以将文件名[0:4]作为年，文件名[4:6]作为月，文件名[6:8]作为日。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/e8d6f1d9b65f318a66bb79fd8e0f6cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*clC9TTpJWTNvsTcx"/></div></div></figure><p id="4840" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">此时，我们一个接一个地打印每个表格，而不是将它们合并到一个表格中。这不是我们想要的。但是在此之前，让我们使用生成器重新创建这些单独的表。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8866" class="md js in lz b gy me mf l mg mh"># Generator<br/>def load_files(data_files):<br/>    for filename in data_files:<br/>        # Read data from each file<br/>        df = pd.read_csv(f'writeCSV/{filename}')<br/>        # Get ticker &amp; year from filename<br/>        csvTicker = filename[0:4]<br/>        csvYear = filename[5:9]<br/>        # Add columns "Ticker" and "Year" to the table<br/>        df['Ticker'] = csvTicker<br/>        df['Year'] = csvYear<br/>        yield df</span></pre><p id="de78" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">等等，发电机？那是什么？就像我们一直在一个接一个地打印表格一样，yield df 帮助我们‘生成’表格，正如它的名字所暗示的那样，而不是返回或打印它们。我们将“生成”这些表，并在生成另一个表后使用 concat()函数追加行。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c543" class="md js in lz b gy me mf l mg mh"># Generate a list of file names<br/>data = [x for x in data_files]<br/></span><span id="8c41" class="md js in lz b gy mi mf l mg mh"># load_files takes 1 argument (a list of file names)<br/>stockprice = pd.concat(load_files(data))<br/>stockprice</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mp"><img src="../Images/751c5ddce234b88bf5f78b4ff4fb1aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bjPm6JfbaAMp2-rr"/></div></div></figure><p id="9465" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">看，我们已经成功地将这些表合并成 1。然而，我们还没有接近完成，因为:1。行索引很奇怪(0，0，1，2，3，…，6，7，8，9，10)，而我们有 792 行。2.我们有一个额外的“未命名:0”列。</p><h1 id="7132" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">索引</h1><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mq"><img src="../Images/25bdfc31062e22520345dbf140a613f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ybgmtjpf1JZ-a6g6"/></div></div></figure><p id="6ef5" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">回想一下，这些最初是单独的表，每个文件有 12 行(除了第一行)。当我们使用 concat()合并表时，我们基本上是追加行(包括索引),因此即使在合并表之后，它仍然保持为 0–11。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="07d1" class="md js in lz b gy me mf l mg mh"># Generate a list of file names<br/>data = [x for x in data_files]<br/></span><span id="a68b" class="md js in lz b gy mi mf l mg mh"># load_files takes 1 argument (a list of file names)<br/>stockprice = pd.concat(load_files(data))<br/></span><span id="5906" class="md js in lz b gy mi mf l mg mh"># Reset index<br/>stockprice.reset_index(drop=True, inplace=True)<br/></span><span id="6873" class="md js in lz b gy mi mf l mg mh">stockprice</span></pre><p id="7698" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">我们需要使用 stock price . reset _ index(drop = True)来删除原来的索引，并使用新的索引。而 inplace=True 意味着修改后的表将被重新分配给 stockprice 变量，而不是定义一个新的变量。</p><h1 id="1719" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">未命名:0 列</h1><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mr"><img src="../Images/1ce118cd67d2687e4acaa767bfea720a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F1XlY50E5iPs4j82"/></div></div></figure><p id="e3c7" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">请注意 Unnamed: 0 列的顶部几行和底部几行之间的差异。对于苹果公司的股票，其价值是 NaN，而对于微软公司，其价值实际上是其原始指数。这告诉我们，对于微软的文件，数据中有一个索引列，而苹果没有。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ms"><img src="../Images/728964b3da09593c9a39790b79a64717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eret7wskE9TLcwbe"/></div></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mt"><img src="../Images/330961f052b18523b991db77645603df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRb31ledZKvTCTqI"/></div></div></figure><p id="5a0e" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">当我们使用 pd.concat()追加表时，pandas 将取出那个索引列，并将其重命名为 Unnamed: 0。对于没有该列的 excel 文件，这些值将为 null (NaN)。</p><p id="3533" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">如果所有文件都有那个索引列，我们可以使用 index_col=0 告诉 pandas，第一列实际上是索引列，我们不需要包含在我们的合并表中。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mu"><img src="../Images/6d5a9695297bc98b80edbdcf2669723c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*of1PVkXGmIxMP0pw"/></div></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/fd5c30e2078f61ecea25395147b22c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NKE6_1yJXNQ1Ieow"/></div></div></figure><p id="2e10" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">如图所示，在我们的例子中，我们不能使用 index_col=0，因为不是所有的文件都有那个索引列。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7801" class="md js in lz b gy me mf l mg mh"># Generate a list of file names<br/>data = [x for x in data_files]<br/></span><span id="dcf9" class="md js in lz b gy mi mf l mg mh"># load_files takes 1 argument (a list of file names)<br/>stockprice = pd.concat(load_files(data))<br/></span><span id="e2d0" class="md js in lz b gy mi mf l mg mh"># Reset index<br/>stockprice.reset_index(drop=True, inplace=True)<br/></span><span id="20dd" class="md js in lz b gy mi mf l mg mh"># Removes last column<br/>stockprice = stockprice.iloc[:,:-1]<br/></span><span id="fc38" class="md js in lz b gy mi mf l mg mh">stockprice</span></pre><p id="40e4" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">DataFrame.iloc[a:b，c:d]表示我们取 a+1 到 b-1 行(索引从 0 开始，省略最后一个数字)和 c+1 到 d-1 列。在我们的例子中，我们使用 iloc[:，:-1]。“a”和“b”未填写意味着我们将接受所有行。同样的想法也适用于‘c’(没有填写意味着 c=0)和 d = -1。index = -1 表示从后数的第一个索引，因此，我们将获取除最后一列之外的所有列(最后一个数字被省略)。</p><h1 id="9dd6" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">最终输出</h1><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mw"><img src="../Images/46d34f4485dd950ca79403abbb992501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YM2uLfdNtoMP1vpU"/></div></div></figure><p id="693c" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">这就是我们期望的组合表。让我们把这些代码放到一个函数中，这样我们就可以用一行代码来调用它。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0d63" class="md js in lz b gy me mf l mg mh">def read_data():<br/>    <br/>    # Generate a list of file names<br/>    data = [x for x in data_files]<br/>    <br/>    # Concatenate data frames<br/>    stockPrice = pd.concat(load_files(data))<br/>    <br/>    # Reset Index<br/>    stockPrice.reset_index(drop=True, inplace=True)<br/>    <br/>    # Removes last column<br/>    stockPrice = stockPrice.iloc[:,:-1]<br/>    <br/>    # Print Number of Files Loaded<br/>    print("Loaded",len(data),'files')<br/>    <br/>    # Print Number of Rows<br/>    print("Total Rows =",len(stockPrice))<br/>    <br/>    # Print Number of Columns<br/>    columns=[]<br/>    for column in stockPrice:<br/>        columns.append(column)<br/>    print("Total Columns =",len(columns))<br/>    return stockPrice</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mx"><img src="../Images/f56961c3d50e74556926fde42e3df250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1XoYiA2A1T4bauVF"/></div></div></figure><p id="f0b9" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">请注意，我们添加了代码来打印加载到表中的文件数、行数和列数，这样，当我们调用函数而不显示结果表时，我们就知道表已成功加载。</p><h1 id="9dc4" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">最终代码和输出(将所有文件合并到一个文件夹中)</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c792" class="md js in lz b gy me mf l mg mh"># Generator<br/>def load_files(data_files):<br/>    for filename in data_files:<br/>        # Read data from each file<br/>        df = pd.read_csv(f'writeCSV/{filename}')<br/>        # Get ticker &amp; year from filename<br/>        csvTicker = filename[0:4]<br/>        csvYear = filename[5:9]<br/>        # Add columns "Ticker" and "Year" to the table<br/>        df['Ticker'] = csvTicker<br/>        df['Year'] = csvYear<br/>        yield df       </span><span id="d9c2" class="md js in lz b gy mi mf l mg mh">def read_data():</span><span id="de79" class="md js in lz b gy mi mf l mg mh">    # Generate a list of file names<br/>    data = [x for x in data_files]<br/>    <br/>    # Concatenate data frames<br/>    stockPrice = pd.concat(load_files(data))<br/>    <br/>    # Reset Index<br/>    stockPrice.reset_index(drop=True, inplace=True)<br/>    <br/>    # Removes last column<br/>    stockPrice = stockPrice.iloc[:,:-1]<br/>    <br/>    # Print Number of Files Loaded<br/>    print("Loaded",len(data),'files')<br/>    <br/>    # Print Number of Rows<br/>    print("Total Rows =",len(stockPrice))<br/>    <br/>    # Print Number of Columns<br/>    columns=[]<br/>    for column in stockPrice:<br/>        columns.append(column)<br/>    print("Total Columns =",len(columns))<br/>    return stockPrice</span><span id="1cd3" class="md js in lz b gy mi mf l mg mh">read_data()</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mx"><img src="../Images/4fc69c96370da0f66b6af8be9ee804c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*veOzi1SOGai6I5QN"/></div></div></figure><p id="e82f" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">如果你需要的是读取一个文件夹中的所有文件，你可以就此打住。在某些情况下，您可能不想合并所有文件，而是根据文件名选择要合并的文件。</p><p id="0180" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">为了声明模式，我们将使用 re.compile</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="884a" class="md js in lz b gy me mf l mg mh">import re<br/># Define a pattern we want<br/>pattern = re.compile(f'^....-....-Monthly-Stock-Price')<br/># in data_files list, loop through all elements and return elements that match our pattern<br/>data = [x for x in data_files if pattern.match(x)]<br/>data</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/24065b93463e0ad7edea297160c04f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/0*oGf5bOjm8zpcg5Ik"/></div></figure><p id="9dc9" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">re 代表正则表达式。当我们想要定义一个模式，而不是写所有匹配该模式的名字时，通常使用它。查看<a class="ae ln" href="https://www.debuggex.com/cheatsheet/regex/python" rel="noopener ugc nofollow" target="_blank">正则表达式备忘单</a>了解更多正则表达式符号及其用法。</p><p id="92a8" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">在这里，我们使用^….-….-告诉 python 我们希望任何文件名以任何 4 个字符开头，后面跟一个'-'，任何 4 个字符，在“Monthly-Stock-Price.csv”前再跟一个'-'。如果我们想指定一个股票，我们可以替换…股票代码像 MSFT。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="74e9" class="md js in lz b gy me mf l mg mh">import re<br/># Define a pattern we want<br/>pattern = re.compile(f'^MSFT-....-Monthly-Stock-Price')<br/># in data_files list, loop through all elements and return elements that match our pattern<br/>data = [x for x in data_files if pattern.match(x)]<br/>data</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mz"><img src="../Images/9681721b8047f42eaebb5d40d199ca64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D2959PM61xAKtIvR"/></div></div></figure><p id="9494" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">把这个放到我们的函数中:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9cff" class="md js in lz b gy me mf l mg mh">def read_data():<br/>    # Define a pattern we want<br/>    pattern = re.compile(f'^MSFT-....-Monthly-Stock-Price')<br/>    <br/>    # in data_files list, loop through all elements and return elements that match our pattern<br/>    data = [x for x in data_files if pattern.match(x)]<br/>    <br/>    # Concatenate data frames<br/>    stockPrice = pd.concat(load_files(data))<br/>    <br/>    # Reset Index<br/>    stockPrice.reset_index(drop=True, inplace=True)<br/>    <br/>    # Removes last column<br/>    stockPrice = stockPrice.iloc[:,:-1]<br/>    <br/>    # Print Number of Files Loaded<br/>    print("Loaded",len(data),'files')<br/>    <br/>    # Print Number of Rows<br/>    print("Total Rows =",len(stockPrice))<br/>    <br/>    # Print Number of Columns<br/>    columns=[]<br/>    for column in stockPrice:<br/>        columns.append(column)<br/>    print("Total Columns =",len(columns))<br/>    return stockPrice</span></pre><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/0ffd203f451e09279fe5ee374de2bd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*upgOwBf0p6ie-AYV"/></div></div></figure><p id="3d42" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">最终代码(带正则表达式)</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4a3f" class="md js in lz b gy me mf l mg mh"># Generator<br/>def load_files(data_files):<br/>    for filename in data_files:<br/>        # Read data from each file<br/>        df = pd.read_csv(f'writeCSV/{filename}')<br/>        # Get ticker &amp; year from filename<br/>        csvTicker = filename[0:4]<br/>        csvYear = filename[5:9]<br/>        # Add columns "Ticker" and "Year" to the table<br/>        df['Ticker'] = csvTicker<br/>        df['Year'] = csvYear<br/>        yield df       </span><span id="1b14" class="md js in lz b gy mi mf l mg mh">def read_data():<br/>    # Define a pattern we want<br/>    pattern = re.compile(f'^MSFT-....-Monthly-Stock-Price')<br/>    <br/>    # in data_files list, loop through all elements and return elements that match our pattern<br/>    data = [x for x in data_files if pattern.match(x)]<br/>    <br/>    # Concatenate data frames<br/>    stockPrice = pd.concat(load_files(data))<br/>    <br/>    # Reset Index<br/>    stockPrice.reset_index(drop=True, inplace=True)<br/>    <br/>    # Removes last column<br/>    stockPrice = stockPrice.iloc[:,:-1]<br/>    <br/>    # Print Number of Files Loaded<br/>    print("Loaded",len(data),'files')<br/>    <br/>    # Print Number of Rows<br/>    print("Total Rows =",len(stockPrice))<br/>    <br/>    # Print Number of Columns<br/>    columns=[]<br/>    for column in stockPrice:<br/>        columns.append(column)<br/>    print("Total Columns =",len(columns))<br/>    return stockPrice</span></pre><p id="9789" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">最终输出</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/66ab14ec50ca473c3d1ad5366066c01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uzfNsNeP9iAYHo38"/></div></div></figure><p id="8e63" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">本文最初发表在我的<a class="ae ln" href="https://www.linkedin.com/pulse/combine-multiple-csvexcel-files-single-table-python-pandas-foo/" rel="noopener ugc nofollow" target="_blank"> linkedin 个人资料</a>上。如果你喜欢读这篇文章，请随时关注我！</p><p id="0ebc" class="pw-post-body-paragraph kp kq in kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ig bi translated">感谢您的阅读！下一篇文章再见:)</p></div></div>    
</body>
</html>