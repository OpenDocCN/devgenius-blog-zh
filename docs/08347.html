<html>
<head>
<title>How to Test Time and Increase Code Quality as an Experienced Java Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一名有经验的 Java 开发人员，如何测试时间和提高代码质量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-test-time-and-increase-code-quality-as-an-experienced-java-developer-75e79402d191?source=collection_archive---------7-----------------------#2022-06-07">https://blog.devgenius.io/how-to-test-time-and-increase-code-quality-as-an-experienced-java-developer-75e79402d191?source=collection_archive---------7-----------------------#2022-06-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="94dd" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><em class="kg">这里有一个关于使用 InstantSource 进行时间旅行测试的深入教程</em></h2></div><figure class="ki kj kk kl gu km gi gj paragraph-image"><div class="gi gj kh"><img src="../Images/26a9265fe4949634329b45379d26678e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a9S9hGbsaL-7TPHo.jpeg"/></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk translated">图片由<a class="ae kt" href="https://www.pexels.com/@rethaferguson?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> RF 提供。_.来自<a class="ae kt" href="https://www.pexels.com/photo/crop-focused-repairman-fixing-graphics-card-on-computer-3825582/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的工作室</a></figcaption></figure><p id="53a2" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">大部分 Java 开发者都不测试时间。尽管它可以清除很多 bug。</em>T13】</strong></p><p id="0d9b" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">他们避免时间测试。或者他们硬编码日期。反过来时间虫穿越。</p><p id="402c" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">不要硬编码日期。</em> </strong></p><p id="91a7" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">有些人甚至在测试中使用硬编码日期。这在某些情况下可能行得通。尽管如此，你还是会得到很多时间常数和难以维护的测试。</p><p id="fa11" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">硬编码的日期会产生<em class="lq">测试定时炸弹。测试定时炸弹在硬编码日期后爆炸。更多的测试依赖于同一天，更多的维护麻烦。</em></p><p id="f1f2" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">此外，你对硬编码日期的控制也很差。</em> </strong></p><p id="81ab" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">你需要改变很多常量。或者您需要为不同的日期创建新的。所以你不能动态控制日期。</p><p id="63ad" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">你能做些什么来代替呢？如何控制考试时间？如何创建质量更好的时间测试？</p><p id="3ba1" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">让我们试着解决这个问题。</p></div><div class="ab cl lr ls hv lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ik il im in io"><p id="4b96" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">假设我们需要测试下面的代码。这个代码来源于<a class="ae kt" href="https://mateuszjarzyna.github.io/posts/how-to-test-time-improve-code-quality-pt-1/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">这个例子</em> </a>，重点是<code class="fe ly lz ma mb b">Instant</code>时间。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure><p id="3e0b" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">进行测试的一种方法是使用</em> </strong> <code class="fe ly lz ma mb b"><strong class="kw is"><em class="lq">@VisibleForTesting</em></strong></code> <strong class="kw is"> <em class="lq">。</em> </strong></p><p id="7334" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">将<code class="fe ly lz ma mb b">instantSource.instant()</code>提取到一个单独的方法中。这个方法将是包私有的，并且对于测试是可见的。然后在测试中提供测试数据。</p><pre class="ki kj kk kl gu me mb mf mg aw mh bi"><span id="ab53" class="mi mj ir mb b gz mk ml l mm mn">@VisibleForTesting  <br/>Instant getInstant() {  <br/>    return Instant.now();  <br/>}</span><span id="3752" class="mi mj ir mb b gz mo ml l mm mn">// Test.java</span><span id="b525" class="mi mj ir mb b gz mo ml l mm mn">when(service.getInstant()).thenReturn(Instant.now().plus(20, ChronoUnit.DAYS));</span><span id="538a" class="mi mj ir mb b gz mo ml l mm mn">// or create the test Instance</span><span id="a404" class="mi mj ir mb b gz mo ml l mm mn">ResetPasswordService r = new ResetPasswordService() {  <br/>    Instant getInstant() {  <br/>        return Instant.now();  <br/>    }  <br/>};</span></pre><p id="0971" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">你不会得到所需的时间控制。</em> </strong></p><p id="9726" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">由于你除了<code class="fe ly lz ma mb b">getInstant</code>之外没有其他方法，所以你受到了限制。您可以偏移时间和其他时间操作。即便如此，测试中还是会加入很多逻辑。</p><p id="3571" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">测试会变得比需要的更加冗长。T47】</p><p id="4dcd" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">另一个问题是集成测试。您需要再次为此方法提供响应。</p><p id="0893" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">你可以提取代<code class="fe ly lz ma mb b">TokenEntity</code>来分离类。那么<code class="fe ly lz ma mb b">@VisibleForTesting</code>将会工作，你将不需要额外的<br/>依赖。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure></div><div class="ab cl lr ls hv lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ik il im in io"><p id="cafc" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">另一个解决方案是分离的构造函数。 </p><p id="c40d" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">我们会忽略一个事实，即<code class="fe ly lz ma mb b">Token</code>一代并不适合<code class="fe ly lz ma mb b">ResetPasswordService</code>。我们将添加一些新的构造函数，以支持测试。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure><p id="e8de" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">我们需要为 DI 标记构造函数，并为测试目的创建一个单独的。我们添加了<code class="fe ly lz ma mb b">@Autowired</code>注释，这样 Spring 就知道对 DI 使用哪个了。<code class="fe ly lz ma mb b">@VisibleForTesting</code>是我们将在测试中使用的。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure><p id="cce8" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">这样我们可以避免额外的依赖。</p><p id="b026" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">即便如此，我们也会失去时间控制。我们不能在时间中前进或后退。所以如果这是你需要的，那么这就是解决方案。</p></div><div class="ab cl lr ls hv lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ik il im in io"><p id="fd4f" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">如果您使用的是较低版本的 Java，以前的解决方案是可行的。或者您不想添加额外的依赖项。</p><p id="622b" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">你不能用这种方法进行时间旅行。您将供应商硬编码到一个<code class="fe ly lz ma mb b">Instant</code>供应商。虽然您可以为供应商创建一个 setter，但是有一个更好的方法可以做到这一点。</p><p id="6677" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">有了 Java 17，我们现在有了<code class="fe ly lz ma mb b">InstantSource</code>。有了这个类，我们不再需要创建工作区，我们也获得了<code class="fe ly lz ma mb b">Clock</code>类的好处。</p></div><div class="ab cl lr ls hv lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ik il im in io"><p id="f841" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><code class="fe ly lz ma mb b"><a class="ae kt" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/InstantSource.html" rel="noopener ugc nofollow" target="_blank"><em class="lq">InstantSource</em></a></code>是瞬间工厂。此外，您可以提供存根<code class="fe ly lz ma mb b">Clocks</code>作为<code class="fe ly lz ma mb b">InstantSource</code>。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure><p id="bfa0" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">为什么这是一个更好的解决方案？想进<code class="fe ly lz ma mb b">Clocks</code>就进。<code class="fe ly lz ma mb b">OffsetClock</code>、<code class="fe ly lz ma mb b">TickClock</code>或其他。或者您可以切换时区并进行测试。这样你就能得到所需的时间控制。</p><p id="d825" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">这是测试。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure><p id="91f1" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">我已经添加了 InstantSource 的一个单独的实例，<code class="fe ly lz ma mb b">TestInstantSource</code>。这是因为<code class="fe ly lz ma mb b">Clock</code>中的每个方法都会创建一个新的<code class="fe ly lz ma mb b">Clock</code>实例。所以你需要一个包装器来存放新的时钟。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mc md l"/></div></figure></div><div class="ab cl lr ls hv lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ik il im in io"><p id="3691" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">使用<code class="fe ly lz ma mb b">InstantSource</code>使生活变得更容易，因为你没有任何变通办法。<code class="fe ly lz ma mb b">Clock</code>实例可以放成<code class="fe ly lz ma mb b">InstantSource</code>，这样包装器，比如<code class="fe ly lz ma mb b">TestInstantSource</code>，这样就可以控制时间。</p><p id="65e1" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><code class="fe ly lz ma mb b">InstantSource</code>提供一个轻量级的即时发生器。因为大多数时候，你只需要一个<code class="fe ly lz ma mb b">Instant</code>的供应商。相反，使用<code class="fe ly lz ma mb b">Clock</code>会增加更多的开销，而且大多数时候是没用的。</p></div></div>    
</body>
</html>