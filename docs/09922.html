<html>
<head>
<title>OpenTelemetry for Python: Manual Configuration &amp; Context Propagation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的 OpenTelemetry:手动配置和上下文传播</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/opentelemetry-for-python-the-hard-way-aa3507b87343?source=collection_archive---------4-----------------------#2022-09-23">https://blog.devgenius.io/opentelemetry-for-python-the-hard-way-aa3507b87343?source=collection_archive---------4-----------------------#2022-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e29477c968eb29f514477f431e29fa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Lca7zZ3wgAGSsFZF-IHzg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">渥太华里多运河船闸的开关装置。Adri Villela 的照片。</figcaption></figure><p id="c010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的<a class="ae jz" href="https://lightstep.com/blog/auto-instrumentation-is-magic-using-opentelemetry-python-with-lightstep" rel="noopener ugc nofollow" target="_blank">上一篇博文</a>中，我向你们展示了如何用<a class="ae jz" href="https://lightstep.com/blog/opentelemetry.io" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry (OTel) </a>，à la <a class="ae jz" href="https://lightstep.com/blog/auto-instrumentation-is-magic-using-opentelemetry-python-with-lightstep#automatic-instrumentation--python" rel="noopener ugc nofollow" target="_blank">自动检测</a>来检测 Python 代码。您可能还记得，在那篇文章中，我<a class="ae jz" href="https://lightstep.com/blog/auto-instrumentation-is-magic-using-opentelemetry-python-with-lightstep#should-i-always-use-the-auto-instrumentation-agent" rel="noopener ugc nofollow" target="_blank">建议使用 Python 自动插装二进制文件</a>，即使对于非自动插装的库也是如此，因为它很好地抽象了所有讨厌的 OTel 配置内容。当您使用它，以及任何适用的 Python auto<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-python-contrib/tree/main/instrumentation" rel="noopener ugc nofollow" target="_blank">-instrumentation 库</a>(由<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-python-contrib/tree/main/opentelemetry-instrumentation#opentelemetry-bootstrap" rel="noopener ugc nofollow" target="_blank">open telemetry-bootstrap</a>安装)时，它会为您处理相关服务间的上下文传播。</p><p id="7b7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，它让我们的生活变得美好而简单！</p><p id="ce5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，今天，我的朋友们，我们要折磨一下自己，因为我们要把自动检测二进制放在一边，取而代之的是深入研究 Python 的超级人工 OpenTelemetry 检测。由于我们没有自动仪器作为我们的安全保障，我们将不得不学习如何做以下事情:</p><ul class=""><li id="d21b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">配置 OpenTelemetry for Python，将测量数据发送到支持<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md" rel="noopener ugc nofollow" target="_blank"> OTLP </a>的可观测性后端。剧透:我们将使用<a class="ae jz" href="http://app.lightstep.com" rel="noopener ugc nofollow" target="_blank"> Lightstep </a>作为我们的观测后端。✅</li><li id="b852" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">跨相关服务传播上下文，以便它们显示为同一跟踪✅的一部分</li></ul><blockquote class="lm ln lo"><p id="1f46" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><em class="in">我不会深入探讨如何用 OTel 为 Python 创建跨度，因为</em> <a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python" rel="noopener ugc nofollow" target="_blank"> <em class="in">官方 OTel 文档</em> </a> <em class="in">已经做得很好了。</em></p></blockquote><p id="e82c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你害怕吗？别担心，因为我已经想通了，所以你不用担心！</p><p id="ef2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你准备好了吗？我们开始吧！！</p><h1 id="257f" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">先决条件</h1><p id="22d6" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在我们开始我们的教程之前，这里有一些你需要的东西:</p><ul class=""><li id="ecb5" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">基本了解<a class="ae jz" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae jz" href="https://realpython.com/python-virtual-environments-a-primer" rel="noopener ugc nofollow" target="_blank"> Python 虚拟环境</a></li><li id="74ff" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">对<a class="ae jz" href="https://lightstep.com/blog/opentelemetry.io" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>的基本了解。如果你需要的话，我建议查看一下官方 OTel 文档。</li></ul><p id="b02d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想运行第 2 部分中的完整代码示例，您还需要:</p><ul class=""><li id="45c8" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">一个<a class="ae jz" href="https://app.lightstep.com/signup/developer?signup_source=docs" rel="noopener ugc nofollow" target="_blank">光步可观察性账户</a></li><li id="c329" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一个<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>告诉 Lightstep 将你的跟踪发送到什么项目</li><li id="a678" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">基本了解如何使用<a class="ae jz" href="http://app.lightstep.com/" rel="noopener ugc nofollow" target="_blank">光步可观性</a></li><li id="8bf0" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一个<a class="ae jz" href="https://www.python.org/downloads" rel="noopener ugc nofollow" target="_blank"> Python </a>的工作装置</li></ul><h1 id="4d64" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">第 1 部分:发生了什么？</h1><p id="0ce9" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们将通过一个客户端和服务器应用程序用 OpenTelemetry 演示 Python 手动工具。客户端将调用服务器托管的一个<code class="fe mw mx my mz b">/ping</code>端点。</p><p id="14d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本教程中的示例可在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/tree/main/python/opentelemetry/manual_instrumentation" rel="noopener ugc nofollow" target="_blank">light step/open telemetry-examples</a>repo 中找到。我们将使用三个主要文件:</p><ul class=""><li id="17d7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/common.py" rel="noopener ugc nofollow" target="_blank"> common.py </a> — OTel 配置和连接(连接到 Lightstep)</li><li id="edd5" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/client.py" rel="noopener ugc nofollow" target="_blank"> client.py </a> —连接到我们服务器的<code class="fe mw mx my mz b">/ping</code>端点</li><li id="c29f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/server.py" rel="noopener ugc nofollow" target="_blank"> server.py </a> —托管<code class="fe mw mx my mz b">/ping</code>端点</li></ul><p id="11d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在运行示例代码之前，我们必须首先理解它在做什么。</p><h2 id="7467" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">1- OTel 库</h2><p id="d135" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了将 OpenTelemetry 数据发送到可观测性后端(如 Lightstep)，您需要安装以下<strong class="kc io"> <em class="lp"> OpenTelemetry 包</em> </strong>，这些包包含在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt </a>中:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="6b73" class="na lu in mz b gy nu nv l nw nx">opentelemetry-api<br/>opentelemetry-sdk<br/>opentelemetry-exporter-otlp-proto-grpc</span></pre><p id="4af6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所看到的，我们正在安装 OpenTelemetry API 和 SDK 包，以及用于通过<a class="ae jz" href="https://opentelemetry.io/docs/concepts/glossary/#grpc" rel="noopener ugc nofollow" target="_blank"> gRPC </a>将 OTel 数据发送到你的 Observability 后端(例如 Lightstep)。</p><h2 id="3d38" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">2- OTel 设置和配置(common.py)</h2><p id="24f3" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在我们的例子中，OTel 设置和配置是在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/common.py" rel="noopener ugc nofollow" target="_blank"> common.py </a>中完成的。我们将事情分解到这个单独的文件中，这样我们就不必在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/client.py" rel="noopener ugc nofollow" target="_blank"> client.py </a>和<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/server.py" rel="noopener ugc nofollow" target="_blank"> server.py </a>中重复这段代码。</p><p id="7601" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们必须导入所需的 OTel 包:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="09f6" class="na lu in mz b gy nu nv l nw nx">from opentelemetry import trace<br/>from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter<br/>from opentelemetry.sdk.resources import SERVICE_NAME, Resource<br/>from opentelemetry.sdk.trace import TracerProvider<br/>from opentelemetry.sdk.trace.export import BatchSpanProcessor</span></pre><p id="cbd8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们必须配置导出器。导出器是我们向 OpenTelemetry 发送数据的方式。正如我前面提到的，Lightstep 接受 OTLP 格式的数据，所以我们需要定义一个 OTLP 导出器。</p><blockquote class="lm ln lo"><p id="a0c4" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><em class="in">有些厂商不接受 OTLP 格式的数据，这意味着你需要使用一个</em> <a class="ae jz" href="https://opentelemetry.io/registry/?language=go&amp;component=exporter" rel="noopener ugc nofollow" target="_blank"> <em class="in">特定于厂商的导出器</em> </a> <em class="in">来向他们发送数据。</em></p></blockquote><p id="6f50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在 Python 中这样配置我们的导出器:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="59fc" class="na lu in mz b gy nu nv l nw nx">def get_otlp_exporter():<br/>   ls_access_token = os.environ.get("LS_ACCESS_TOKEN")<br/>   return OTLPSpanExporter(<br/>       endpoint="ingest.lightstep.com:443",<br/>       headers=(("lightstep-access-token", ls_access_token),),<br/>   )</span></pre><p id="98af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="3ff0" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">将<code class="fe mw mx my mz b">endpoint</code>设置为<code class="fe mw mx my mz b">ingest.lightstep.com:443</code>，指向 Lightstep 的公共微卫星池。如果您使用的是内部卫星池，请查看这些文档。</li><li id="056c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">您需要用自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>来设置<code class="fe mw mx my mz b">LS_ACCESS_TOKEN</code>环境变量。</li></ul><p id="beb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们配置跟踪提供程序。一个<code class="fe mw mx my mz b">TracerProvider</code>作为 OpenTelemetry API 的入口点。它提供对<code class="fe mw mx my mz b">Tracer</code>的访问。A <code class="fe mw mx my mz b">Tracer</code>负责创建一个<a class="ae jz" href="https://opentelemetry.io/docs/concepts/observability-primer/#spans" rel="noopener ugc nofollow" target="_blank">跨度</a>来跟踪给定的操作。</p><p id="6c5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在 Python 中这样配置我们的 Tracer Provider:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5f5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="05f1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">我们定义了一个<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/sdk.md" rel="noopener ugc nofollow" target="_blank">资源</a>来为 OpenTelemetry 提供一系列标识我们服务的信息，包括<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-python/blob/41b9e26d8324ae0496c85326b35e92bf617932d9/opentelemetry-semantic-conventions/src/opentelemetry/semconv/resource/__init__.py#L415" rel="noopener ugc nofollow" target="_blank">服务名</a>和<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-python/blob/41b9e26d8324ae0496c85326b35e92bf617932d9/opentelemetry-semantic-conventions/src/opentelemetry/semconv/resource/__init__.py#L433" rel="noopener ugc nofollow" target="_blank">服务版本</a>。(您可以在这里看到您可以设置的资源属性的完整列表<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-python/blob/main/opentelemetry-semantic-conventions/src/opentelemetry/semconv/resource/__init__.py#L433" rel="noopener ugc nofollow" target="_blank">。)顾名思义，<em class="lp">服务名</em>是您正在检测的微服务的名称，<em class="lp">服务版本</em>是您正在检测的服务的版本。在这个例子中，我们将服务名和服务版本作为键/值传入环境变量</a><a class="ae jz" href="https://opentelemetry.io/docs/reference/specification/sdk-environment-variables/#general-sdk-configuration" rel="noopener ugc nofollow" target="_blank"> OTEL 资源属性</a>(我们将在第 2 部分看到一些示例值)。如果环境变量不存在，那么我们设置一个默认服务名<code class="fe mw mx my mz b">"test-py-manual-otlp"</code>。</li><li id="cae3" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">我们正在使用<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#batching-processor" rel="noopener ugc nofollow" target="_blank"> BatchSpanProcessor </a>，这意味着我们正在告诉 OTel 批量导出数据。出于这个例子的目的，我们不做任何超出基本配置的事情。</li></ul><h2 id="8afa" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">3-初始化(client.py 和 server.py)</h2><p id="d26f" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们终于准备好向 Lightstep 发送数据了！我们需要做的就是从<code class="fe mw mx my mz b">client.py</code>(第<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/client.py#L17-L20" rel="noopener ugc nofollow" target="_blank">行 17-20 </a>)和<code class="fe mw mx my mz b">server.py</code>(第<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py#L17" rel="noopener ugc nofollow" target="_blank">行 17 </a>和<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py#L29" rel="noopener ugc nofollow" target="_blank">行 29 </a>)调用<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/common.py" rel="noopener ugc nofollow" target="_blank"> common.py </a>的<code class="fe mw mx my mz b">get_tracer</code>函数，就像这样:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="682e" class="na lu in mz b gy nu nv l nw nx">from common import get_tracer<br/><br/>...<br/><br/>tracer = get_tracer()<br/><br/>...</span></pre><p id="dc3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">初始化完成后，我们需要检测我们的代码，这意味着我们需要创建 Spans。我不会在这里讨论 Span 创建的细节，因为 OTel 文档在这方面做得很好，正如我在介绍中提到的，这超出了本文的范围。</p><p id="66ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，我将简要地提到有几种方法可以在 Python 中检测我们的代码，您将在示例代码中看到两种创建 Span 的方法:<a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/manual/#creating-spans" rel="noopener ugc nofollow" target="_blank">使用 with 语句</a>和<a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/manual/#creating-spans-with-decorators" rel="noopener ugc nofollow" target="_blank">使用函数装饰符</a>。</p><p id="efca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/client.py#L23-L32" rel="noopener ugc nofollow" target="_blank"> client.py 的第 23–32 行</a>中看到使用<a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/manual/#creating-spans" rel="noopener ugc nofollow" target="_blank"> with 语句</a>创建 Span 的示例。下面是完整的函数列表:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a55f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Span 用行<code class="fe mw mx my mz b">with tracer.start_as_current_span("client operation"):</code>初始化，该行以下的所有内容都在该 Span 的范围内。</p><p id="9007" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py#L78" rel="noopener ugc nofollow" target="_blank"> server.py 第 78 行</a>中看到一个使用<a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/manual/#creating-spans-with-decorators" rel="noopener ugc nofollow" target="_blank">函数装饰器</a>创建 Span 的例子。下面是完整的函数列表:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="71b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些值得注意的事项:</p><ul class=""><li id="0ddc" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">线<code class="fe mw mx my mz b">@tracer.start_as_current_span("pymongo_integration")</code>开始<code class="fe mw mx my mz b">pymongo_integration</code>功能的跨度。该函数中的所有内容都在该跨度的范围内。</li><li id="91e6" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">您可能也注意到了，我们在那里初始化了另一个 span，使用了行，<code class="fe mw mx my mz b">with tracer.start_as_current_span("server pymongo operation"):</code>，(<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py#L89" rel="noopener ugc nofollow" target="_blank"> server.py，Line 89 </a>)。这意味着我们最终得到了<a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/manual/#creating-nested-spans" rel="noopener ugc nofollow" target="_blank">嵌套的跨度</a>(跨度中的跨度)。</li></ul><h2 id="0acb" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">5-上下文传播</h2><p id="300c" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">正如我在介绍中提到的，使用 Python 自动插装的一个优点是它为您处理跨服务的上下文传播。然而，如果您不使用自动插装，您必须自己处理上下文传播。太好了。太好了。</p><p id="6600" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在我们深入研究如何做到这一点之前，我们需要首先理解上下文传播。</p><p id="810f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义时间！</p><p id="d1c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">上下文</strong>表示关联跨越流程边界的跨度的信息。</p><p id="60e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">传播</strong>是一种方法，通过这种方法，上下文在服务中以及跨服务进行捆绑和传输，通常是通过 HTTP 头。</p><p id="e017" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着当一个服务调用另一个服务时，它们将作为同一个<a class="ae jz" href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces" rel="noopener ugc nofollow" target="_blank">跟踪</a>的一部分链接在一起。然而，如果您走纯手工插装的路线(就像我们今天正在做的)，您必须确保您的上下文在相互调用的服务之间传播，否则您将会以单独的、不相关的(即使它们应该是相关的)跟踪结束。</p><p id="3927" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不得不承认，我绞尽脑汁试图弄清楚这种上下文传播的东西。在花了很多时间在谷歌上搜索并向周围的人寻求澄清后，我终于明白了，所以我将在这里与你分享这篇文章，希望能减轻你的压力。</p><blockquote class="lm ln lo"><p id="c1b7" class="ka kb lp kc b kd ke kf kg kh ki kj kk lq km kn ko lr kq kr ks ls ku kv kw kx ig bi translated"><em class="in">虽然 open 遥测文档确实对如何在 Python 中进行</em> <a class="ae jz" href="https://opentelemetry.io/docs/instrumentation/python/cookbook/#manually-setting-span-context" rel="noopener ugc nofollow" target="_blank"> <em class="in">手动上下文传播提供了一些见解</em> </a> <em class="in">，但是该文档需要一些工作。我实际上是</em><a class="ae jz" href="https://github.com/open-telemetry/opentelemetry.io" rel="noopener ugc nofollow" target="_blank"><em class="in">open 遥测通信信号</em> </a> <em class="in">的一部分，所以我以此为动力来改进围绕这个主题的文档……也请关注 OTel 文档的更新！😎</em></p></blockquote><p id="ab3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，那么我们如何进行这个手动的上下文传播呢？首先，让我们提醒自己示例应用程序中发生了什么。我们有<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/client.py" rel="noopener ugc nofollow" target="_blank">客户端</a>服务和<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py" rel="noopener ugc nofollow" target="_blank">服务器</a>服务。客户端服务调用服务器服务上的<code class="fe mw mx my mz b">/ping</code>端点，这意味着我们希望它们是同一个 Trace 的一部分。这反过来意味着我们必须确保它们都有相同的跟踪 ID，以便 Lightstep(和其他可观察性后端)认为它们是相关的。</p><p id="26e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在更高的层面上，我们通过以下方式实现这一目标:</p><ul class=""><li id="cc94" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">获取客户端的跟踪标识</li><li id="f503" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">在客户端调用服务器之前将跟踪标识注入到 HTTP 头中</li><li id="5b9c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">从服务器端的 HTTP 头中提取客户端的跟踪 ID</li></ul><p id="1669" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">冷静点！现在让我们看看实现这一目标所需的代码。</p><p id="482a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要从一个叫做<code class="fe mw mx my mz b">carrier</code>的东西开始。<code class="fe mw mx my mz b">carrier</code>只是一个包含跟踪标识的键值对，看起来像这样:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="8454" class="na lu in mz b gy nu nv l nw nx">{'traceparent': '00-a9c3b99a95cc045e573e163c3ac80a77-d99d251a8caecd06-01'}</span></pre><p id="d95e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其中<code class="fe mw mx my mz b">traceparent</code>为密钥，值为您的追踪 ID。请注意，上面只是跟踪 ID 可能是什么样子的一个例子。显然，您自己的跟踪 ID 会有所不同(每次运行代码时也会有所不同)。</p><p id="e77d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，很好。<code class="fe mw mx my mz b">carrier</code>现在我们如何获得说？</p><p id="1837" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/client.py" rel="noopener ugc nofollow" target="_blank">客户端导入<code class="fe mw mx my mz b">TraceContextTextMapPropagator</code>，py </a>:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="51b1" class="na lu in mz b gy nu nv l nw nx">from opentelemetry.trace.propagation.tracecontext import TraceContextTextMapPropagator</span></pre><p id="8094" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们必须填写承运人:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="051f" class="na lu in mz b gy nu nv l nw nx">carrier = {}<br/>TraceContextTextMapPropagator().inject(carrier)</span></pre><p id="c772" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在这一行之后检查<code class="fe mw mx my mz b">carrier</code>的值，您会看到它看起来像这样:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="b295" class="na lu in mz b gy nu nv l nw nx">{'traceparent': '00-a9c3b99a95cc045e573e163c3ac80a77-d99d251a8caecd06-01'}</span></pre><p id="00bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">眼熟吗？🤯</p><p id="e568" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了<code class="fe mw mx my mz b">carrier</code>，我们需要在调用服务器之前将它放入我们的 HTTP 头中。</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="ad7c" class="na lu in mz b gy nu nv l nw nx">header = {"traceparent": carrier["traceparent"]}<br/>res = requests.get(url, headers=header)</span></pre><p id="e26e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">瞧！您的运营商在 HTTP 请求中！</p><p id="11f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道了所有这些片段的作用，让我们把它们放在一起。下面是我们的客户端代码:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e224" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关完整的代码清单，请查看<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/client.py" rel="noopener ugc nofollow" target="_blank"> client.py </a>。</p><p id="1477" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的……我们已经解决了客户端的问题。耶！现在让我们转到服务器端，从 HTTP 请求中取出我们的<code class="fe mw mx my mz b">carrier</code>。</p><p id="1eda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/main/python/opentelemetry/manual_instrumentation/server.py" rel="noopener ugc nofollow" target="_blank"> server.py </a>中，我们像这样从我们的头中取出<code class="fe mw mx my mz b">traceparent</code>的值:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="1ad1" class="na lu in mz b gy nu nv l nw nx">traceparent = get_header_from_flask_request(request, "traceparent")</span></pre><p id="e5c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们对<code class="fe mw mx my mz b">get_header_from_flask_request</code>的定义是:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="6c53" class="na lu in mz b gy nu nv l nw nx">def get_header_from_flask_request(request, key):<br/>    return request.headers.get_all(key)</span></pre><p id="44ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以从这些信息中构建我们的<code class="fe mw mx my mz b">carrier</code>:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="f23b" class="na lu in mz b gy nu nv l nw nx">carrier = {"traceparent": traceparent[0]}</span></pre><p id="8858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用它来从这个<code class="fe mw mx my mz b">carrier</code>中提取上下文:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="60d0" class="na lu in mz b gy nu nv l nw nx">ctx = TraceContextTextMapPropagator().extract(carrier)</span></pre><p id="1a36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以用上下文创建我们的跨度，<code class="fe mw mx my mz b">ctx</code>:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="6f61" class="na lu in mz b gy nu nv l nw nx">with tracer.start_as_current_span("/ping", context=ctx):</span></pre><p id="93c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们将<code class="fe mw mx my mz b">ctx</code>传递给一个名为<code class="fe mw mx my mz b">context</code>的命名参数。这确保了我们的<code class="fe mw mx my mz b">"/ping"</code> Span 知道它是现有跟踪的一部分(源自我们的客户端调用)。</p><p id="957c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，<code class="fe mw mx my mz b">"/ping"</code>跨度的任何子跨度都不需要我们传入上下文，因为这是隐式传入的(例如，参见<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py#L81" rel="noopener ugc nofollow" target="_blank"> server.py，第 81 行</a>)。</p><p id="75ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道了所有这些片段的作用，让我们把它们放在一起。下面是我们的服务器代码:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4f91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关完整的代码清单，请查看<a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples/blob/49f018f2cb529a5c0def6109c7e0bfda791e1164/python/opentelemetry/manual_instrumentation/server.py" rel="noopener ugc nofollow" target="_blank"> server.py </a>。</p><h1 id="85fb" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">第 2 部分:试试看！</h1><p id="0792" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">现在我们知道了所有这些背后的理论，让我们运行我们的例子！</p><h2 id="7c73" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">1-克隆回购</h2><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="67ec" class="na lu in mz b gy nu nv l nw nx">git clone <a class="ae jz" href="https://github.com/lightstep/opentelemetry-examples.git" rel="noopener ugc nofollow" target="_blank">https://github.com/lightstep/opentelemetry-examples.git</a></span></pre><h2 id="8752" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">2-设置</h2><p id="58be" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">让我们首先设置我们的 Python 虚拟环境:</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="7838" class="na lu in mz b gy nu nv l nw nx">cd python/opentelemetry/manual_instrumentation<br/><br/>python3 -m venv .<br/>source ./bin/activate<br/><br/># Install requirements.txt<br/>pip install -r requirements.txt</span></pre><h2 id="a229" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">3-运行服务器应用程序</h2><p id="8028" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们准备好运行服务器了。确保用您自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>替换<code class="fe mw mx my mz b">&lt;LS_ACCESS_TOKEN&gt;</code>。</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="1f75" class="na lu in mz b gy nu nv l nw nx">export LS_ACCESS_TOKEN="&lt;LS_ACCESS_TOKEN&gt;"</span><span id="a3c6" class="na lu in mz b gy oa nv l nw nx">export OTEL_RESOURCE_ATTRIBUTES=service.name=py-opentelemetry-manual-otlp-server,service.version=10.10.9</span><span id="e8f6" class="na lu in mz b gy oa nv l nw nx">python server.py</span></pre><p id="6b19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还记得我告诉过你我们会看到一个传入<a class="ae jz" href="https://opentelemetry.io/docs/reference/specification/sdk-environment-variables/#general-sdk-configuration" rel="noopener ugc nofollow" target="_blank">OTEL _ 资源 _ 属性</a>的值的例子吗？嗯，在这里！这里，我们传入服务名<code class="fe mw mx my mz b">py-opentelemetry-manual-otlp-server</code>和服务版本<code class="fe mw mx my mz b">10.10.9</code>。服务名称将显示在 Lightstep 浏览器中。</p><p id="8a2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的输出将如下所示:</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/d067d5c3b53783e45b0b9dee81175808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d1STIMKIosVbnXyQ"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Python server.py 服务器启动序列输出的屏幕截图。Adri Villela 拍摄的画面。</figcaption></figure><h2 id="6004" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">4-运行客户端应用程序</h2><p id="3b63" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">打开一个新的终端窗口，运行客户端应用程序。确保用您自己的<a class="ae jz" href="https://docs.lightstep.com/docs/create-and-manage-access-tokens" rel="noopener ugc nofollow" target="_blank"> Lightstep 访问令牌</a>替换<code class="fe mw mx my mz b">&lt;LS_ACCESS_TOKEN&gt;</code>。</p><p id="9186" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PS:确保你在<code class="fe mw mx my mz b">opentelemetry-examples</code>回购根的<code class="fe mw mx my mz b">python/opentelemetry/manual_instrumentation</code>。</p><pre class="nm nn no np gt nq mz nr ns aw nt bi"><span id="706b" class="na lu in mz b gy nu nv l nw nx">export LS_ACCESS_TOKEN = "&lt;LS_ACCESS_TOKEN&gt;"</span><span id="7027" class="na lu in mz b gy oa nv l nw nx">export OTEL_RESOURCE_ATTRIBUTES =service.name=py-opentelemetry-manual-otlp-client,service.version= 10.10.10 </span><span id="aa47" class="na lu in mz b gy oa nv l nw nx">python client.py test</span></pre><p id="2470" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意我们是如何传入服务名<code class="fe mw mx my mz b">py-opentelemetry-manual-otlp-client</code>和服务版本<code class="fe mw mx my mz b">10.10.10</code>的。服务名称将显示在 Lightstep 浏览器中。</p><p id="3941" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您运行客户端应用程序时，它会不断调用<code class="fe mw mx my mz b">/ping</code>端点。让它运行几次(也许 5-6 次左右？)，然后杀了它(à la <code class="fe mw mx my mz b">ctrl+c</code>)。样本输出:</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/18f4c02844ede2809bbd2294cf02e0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MH3wYISbmVdLpv8W"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">示例 client.py 输出的屏幕截图。阿德里·维勒拉拍摄的屏幕截图。</figcaption></figure><p id="99f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您瞥一眼运行<code class="fe mw mx my mz b">server.py</code>的终端，您可能会注意到一个超级难看的堆栈跟踪。不要慌！<code class="fe mw mx my mz b">/ping</code>服务调用<a class="ae jz" href="https://redis.com" rel="noopener ugc nofollow" target="_blank"> Redis </a>和<a class="ae jz" href="https://www.mongodb.com" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，由于这两个服务都没有运行，您最终会得到如下令人讨厌的错误消息:</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/69751a5d987b7994ea84bfd38db23b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ODjidrYSJKjQuLt_"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">示例 server.py 程序输出运行出错的屏幕截图。Adri Villela 截屏。</figcaption></figure><h2 id="c74d" class="na lu in bd lv nb nc dn lz nd ne dp md kl nf ng mh kp nh ni ml kt nj nk mp nl bi translated">5-在 Lightstep 中查看</h2><p id="e503" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">如果您在 Lightstep 中通过从浏览器中选择<code class="fe mw mx my mz b">py-opentelemetry-manual-otlp-client</code>服务来进入跟踪视图(您也可以通过进入<code class="fe mw mx my mz b">py-opentelemetry-manual-otlp-server</code>服务来查看相同的内容)，您将会看到显示客户端调用服务器以及服务器内调用的其他函数的端到端跟踪。</p><p id="a890" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还记得步骤 4 中堆栈跟踪吗？它在你的追踪中显示为一个错误。这很酷，因为它告诉你你有一个问题，并指出它发生在哪里！多酷啊。？</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/3c173dcada50dee0f0756ca3b46762a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ekS3DtcJ2SavO9i"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Lightstep 中 server.py 和 client.py 的端到端跟踪示例的屏幕截图。Adri Villela 截屏。</figcaption></figure><p id="806d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还记得我们从未将我们的上下文传递给<code class="fe mw mx my mz b">redis_integration</code>和<code class="fe mw mx my mz b">server redis operation</code>跨度，你可以看到<code class="fe mw mx my mz b">server redis operation</code>向上滚动到<code class="fe mw mx my mz b">redis_integration</code>，后者向上滚动到<code class="fe mw mx my mz b">/ping</code>，正如我所说的那样。神奇！🪄</p><h1 id="cd09" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后的想法</h1><p id="352b" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">今天我们学习了如何为 Python 手动配置 OpenTelemetry 以连接到 Lightstep(这也适用于任何接受<a class="ae jz" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md" rel="noopener ugc nofollow" target="_blank"> OTLP 格式</a>的可观测性后端)。我们还学习了如何通过手动上下文传播将相关服务链接在一起。</p><p id="aee4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果您发现自己处于需要在不使用 Python 自动检测二进制文件的情况下连接到可观察性后端和/或需要跨服务手动传播上下文的情况下，您将知道如何做！</p><p id="574a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，请享受这可爱的小老鼠堆。从前到后:菲比，兔子，和 Mookie。我丈夫抱着它们的时候，它们很乖，安静地坐在相机前。</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/c93d1f2854c405f5c557e2f3f99d8f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LFxHUDMZkavZKpvW"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">一堆老鼠！从前到后:菲比、邦妮和穆琪。Adri Villela 拍摄的照片。</figcaption></figure><p id="bd06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和平、爱和准则。🌈 🦄 💫</p><p id="ecd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关于使用 Python 进行 OTel 测试的问题吗？跟我说话！你可以通过<a class="ae jz" href="mailto:devrel@lightstep.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a>联系我，或者在<a class="ae jz" href="https://twitter.com/adrianamvillela" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae jz" href="https://www.linkedin.com/in/adrianavillela" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。希望收到你们的来信！</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="a281" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多关于可观察性的文章，请查看我的拆包可观察性系列:</p><div class="ol om gp gr on"><div role="button" tabindex="0" class="ab bv gv cb fp oo op bn oq jt ex"><div class="or l"><div class="ab q"><div class="l di"><img alt="Adri Villela" class="l de bw os ot fe" src="../Images/e70eedd2981b8eb48ebfa3602f42bc0f.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*rW45is0FCLsRpWvdMdSWpA@2x.jpeg"/><div class="fb bw l os ot fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">阿德里·维莱拉</p></div></div><div class="ow ox gw l"><h2 class="bd io uc ky fp ud fr fs ue fu fw im bi translated">拆包可观察性</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi uf au ug uh ui qs uj an eh ei uk ul um el em eo de bk ep" href="https://adri-v.medium.com/list/unpacking-observability-be1835c6dd23?source=post_page-----aa3507b87343--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="un l fo"><span class="bd b dl z dk">18 stories</span></div></div></div><div class="pj dh pk fp ab pl fo di"><div class="di pb bv pc pd"><div class="dh l"><img alt="The image shows an adorable hand drawn cow looking though a telescope right at the reader. The cow is white with brown spots and the background is a cool teal." class="dh" src="../Images/5aef9c378ae90e96cc6cd9f39ac35e30.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*LyzUnNxwRZQQOQFHoeMgkA@2x.jpeg"/></div></div><div class="di pb bv pe pf pg"><div class="dh l"><img alt="" class="dh" src="../Images/b8fc7dec6f2edfa356fab506c8d60c52.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*o5doa7Uuzq22wxoBk88y2A.jpeg"/></div></div><div class="di bv ph pi pg"><div class="dh l"><img alt="Brick wall with the words “Look up to the starts” written on it." class="dh" src="../Images/cd448d901f7a1ff196c5ead536c0dac9.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*VEKi7Snzf8J6NfOUdHLmXg.png"/></div></div></div></div></div></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="49ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lp">最初发表于</em><a class="ae jz" href="https://lightstep.com/blog/opentelemetry-for-python-the-hard-way" rel="noopener ugc nofollow" target="_blank">T5【https://lightstep.com】</a><em class="lp">。</em></p></div></div>    
</body>
</html>