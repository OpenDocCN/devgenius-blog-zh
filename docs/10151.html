<html>
<head>
<title>Getting started with Julia open-source development for experienced Pythonistas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为有经验的 Pythonistas 开始 Julia 开源开发</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-julia-open-source-development-for-experienced-pythonistas-c3e8906e228a?source=collection_archive---------8-----------------------#2022-10-10">https://blog.devgenius.io/getting-started-with-julia-open-source-development-for-experienced-pythonistas-c3e8906e228a?source=collection_archive---------8-----------------------#2022-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个主要从事 python 项目的人，从你的第一个 Julia 包开始可能有点令人生畏。在 2022 年，作为一名 python 用户生活在 GitHub 上是相当舒适的，因为有大量的自动化框架用于林挺、测试和文档。虽然不像 Python 生态系统那样多样化，但 Julia 确实有实现相同目标的工具。在这里，我们将试图帮助你理解 Julia 中的包开发机制，以及如何将它集成到 GitHub 中。本文将讨论如何设置 Julia repo 的机制，如何在 GitHub 中自动化一些基本的持续集成工作流，以及如何自动构建文档。</p><p id="e62b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于 Julia 包开发的一般信息:<a class="ae ki" href="https://julialang.org/contribute/developing_package/" rel="noopener ugc nofollow" target="_blank">这篇来自 Julia 的官方文档和 YouTube 视频的文章</a>非常有用，应该被认为是一个先决条件，尽管一些关键点后来被翻新。但是在我们建立一个库之前，我们必须首先了解 Julia 的代码在你的计算机上的位置，以及它们是如何组织的。</p><h1 id="288b" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Julia 开发环境的心智模型</h1><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/9420ab5f738dc04c91755fe3d378f4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HpK6BXJZLFH5pKxQ"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">照片由<a class="ae ki" href="https://unsplash.com/@jon_chng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonathan Chng </a>在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e0bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虚拟环境在 Julia 中被称为<em class="lx">项目</em>环境，它们的配置将在其他<a class="ae ki" href="https://towardsdatascience.com/how-to-setup-project-environments-in-julia-ec8ae73afe9c" rel="noopener" target="_blank">文章</a>中介绍。在这里，我们将讨论如何考虑这些环境，以及在出现问题时应该做些什么。我们在<code class="fe ly lz ma mb b">conda</code>中称之为<em class="lx">通道</em>的东西在 Julia 中被称为<em class="lx">注册表</em>。注册表包含了大量软件包的所有依赖信息。<a class="ae ki" href="https://github.com/JuliaRegistries/General" rel="noopener ugc nofollow" target="_blank">通用</a>注册表可以认为是 Julia 的<code class="fe ly lz ma mb b">pypi</code>。Julia 管理包的方式和 python 管理包的方式以及 Julia 管理包的方式之间最大的区别在于，Julia 包都保存在<strong class="jm io">一个地方</strong>。虽然对于熟悉 python 虚拟环境的人来说，这听起来有些奇怪，但是这个决定实际上是非常明智的，因为系统上使用的不同 Julia 包将存储在一个特定的散列下(例如<code class="fe ly lz ma mb b">Graphs.jl</code>的 1.7.2 版本存储在<code class="fe ly lz ma mb b">~/.julia/packages/Graphs/6MoQZ</code>下，不需要复制到系统的其他地方。每个项目本质上都有一组指令，告诉你可以访问<code class="fe ly lz ma mb b">Manifest.toml</code>文件中的哪些包。从某种意义上说，<code class="fe ly lz ma mb b">Project.toml</code>与<code class="fe ly lz ma mb b">requirements.txt</code>的作用相似，而<code class="fe ly lz ma mb b">Manifest.toml</code>与<code class="fe ly lz ma mb b">conda</code>中的物理虚拟环境目录的作用相似。</p><p id="5a03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经使用 python 虚拟环境足够长的时间，你无疑已经破坏了你的环境几次，并且需要对整个环境进行核爆。在 Julia 中，这可能发生在注册表更新期间，或者如果您编辑了一些不应该编辑的代码。修复方法实际上和 python 中的完全一样，你可以删除单个的包或者用<a class="ae ki" href="https://stackoverflow.com/questions/66114900/unsatisfiable-requirements-detected-for-the-package-in-julia" rel="noopener ugc nofollow" target="_blank">销毁你的整个<em class="lx">通用</em>注册表</a>，这取决于你的注册表的混乱程度，然后只需安装你正在处理的任何项目的<code class="fe ly lz ma mb b">Project.toml</code>文件所需的所有包。</p><h1 id="3193" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">创建新的包</h1><p id="43b8" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">现在我们知道了朱莉娅的线人住在哪里。我们可以创建一个新项目并开始开发。在朱莉娅·REPL 中，运行以下命令来安装<code class="fe ly lz ma mb b">PkgTemplates</code>:</p><pre class="li lj lk ll gt mh mb mi mj aw mk bi"><span id="ee56" class="ml kk in mb b gy mm mn l mo mp">using Pkg<br/>Pkg.add("PkgTemplates")</span></pre><p id="3234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要创建您的包，请在朱莉娅·REPL 中执行以下命令:</p><pre class="li lj lk ll gt mh mb mi mj aw mk bi"><span id="d318" class="ml kk in mb b gy mm mn l mo mp">julia&gt; using PkgTemplates<br/>julia&gt; t = Template(;<br/>           user="&lt;GITHUB_USERNAME&gt;",<br/>           license="MIT",<br/>           dir="./",<br/>           authors=["&lt;YOUR NAME&gt;"],<br/>           plugins=[<br/>               Git(ssh=true),<br/>               GitHubActions(),<br/>               Documenter{GitHubActions}()<br/>           ])<!-- --> <br/>julia&gt; t("MyPkg.jl")</span></pre><p id="e9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意<code class="fe ly lz ma mb b">dir="./"</code>假设您使用当前目录来开发 Julia 包。如果未提供该字段，包裹将被放置在<code class="fe ly lz ma mb b">~/.julia/dev</code>。命令完成后，您应该有一个包含<code class="fe ly lz ma mb b">.git</code>和<code class="fe ly lz ma mb b">.github</code>工作流的<code class="fe ly lz ma mb b">MyPkg.jl</code>目录，准备好被推送到 GitHub。</p><h1 id="fb21" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">连续累计</h1><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mq"><img src="../Images/aad58d4c643b7c4ff5a3e7b496f974bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJVzhw2qmjG04glI"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">丹尼尔·劳埃德·布兰克-费尔南德斯在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="18c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用该模板，我们创建了一个空项目，其中包含所有必需的文件，包括三个 GitHub 工作流<code class="fe ly lz ma mb b">yml</code>文件:</p><pre class="li lj lk ll gt mh mb mi mj aw mk bi"><span id="dba9" class="ml kk in mb b gy mm mn l mo mp">% tree .github                                                                                                         <br/>.github<br/>└── workflows<br/>    ├── CI.yml<br/>    ├── CompatHelper.yml<br/>    └── TagBot.yml</span></pre><p id="ba8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些文件确实是</p><ul class=""><li id="2ec2" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated"><code class="fe ly lz ma mb b">CI.yml</code>包含测试工作流，这也是使用<code class="fe ly lz ma mb b">Documenter.jl</code>自动生成的文档工作流所在的地方。</li><li id="7ca2" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">更新你的包依赖关系，本质上是 Julia 的依赖机器人。</li><li id="2b1f" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated"><code class="fe ly lz ma mb b">TagBot.yml</code>运行一个<a class="ae ki" href="https://github.com/JuliaRegistries/TagBot" rel="noopener ugc nofollow" target="_blank"> TagBot </a>工作流，为你注册的 Julia 包创建标签、发布和变更日志，很像<code class="fe ly lz ma mb b">pypi</code>上的 python 代码的<a class="ae ki" href="https://pypi.org/project/twine/" rel="noopener ugc nofollow" target="_blank"> twine </a>。</li></ul><p id="2926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这个包已经被创建为一个 git repo，使用你的 GitHub 用户名，你只需要确保这个 repo 存在于 GitHub 上，然后使用。</p><pre class="li lj lk ll gt mh mb mi mj aw mk bi"><span id="e6f4" class="ml kk in mb b gy mm mn l mo mp">&gt; git push -u origin main</span></pre><p id="c080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在当前状态下，repo 在<code class="fe ly lz ma mb b">.github</code>下的 GitHub 动作会根据<code class="fe ly lz ma mb b">test/runtests.jl</code>中的内容自动测试你的代码。现在，您可以开始开发和测试您的代码了！</p></div></div>    
</body>
</html>