<html>
<head>
<title>Object Mutation In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的对象突变</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-mutation-in-javascript-c1a4bc27dea2?source=collection_archive---------2-----------------------#2022-09-13">https://blog.devgenius.io/object-mutation-in-javascript-c1a4bc27dea2?source=collection_archive---------2-----------------------#2022-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/9bbf900ea08b5316612a70ed3f34c807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*95QEp6e15d6bI71x.jpg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">Pic 信贷 BDI 资源</figcaption></figure><p id="3915" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 JavaScript 中，数据类型分为两组</p><ol class=""><li id="2a3b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">原始数据类型</strong> —不是<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Glossary/Object" rel="noopener ugc nofollow" target="_blank">对象</a>的数据，没有<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Glossary/Method" rel="noopener ugc nofollow" target="_blank">方法</a>或<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Glossary/property/JavaScript" rel="noopener ugc nofollow" target="_blank">属性</a>。</li></ol><p id="2255" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有原语都是<em class="ld">不可变的</em>；也就是说，它们不能被改变。该变量可以被重新分配一个新值，但现有值不能改变。</p><p id="6cb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">非原始/引用数据类型</strong> —是对象和数组。JavaScript 中的引用类型是可变的，这意味着可变类型的状态和字段可以改变。因此不会创建新的实例。</p><h2 id="29e8" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated">Javascript 中的对象突变</h2><p id="78b4" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">几天前，我试图复制一个对象，并修改复制的对象。我看到的是，当我试图更新复制的对象时，原始对象也在更新。这叫做物体突变。让我告诉你变异是如何工作的。当你复制任何对象时，它引用原始对象，这意味着复制的对象指向原始对象，这就是它更新原始对象的原因。你可以用下图来理解</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/aa7465c269379e3f0130fdbc048c13f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*jfk129JJNpA1ZNr2ymzbtw.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">对象的内存引用</figcaption></figure><p id="febb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们通过例子来理解这一点</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/b97cbfbd8f8a1eb5a4a356ae17441bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ey46yJvI6XLHBKk1hcvbQ.png"/></div></div></figure><p id="a05f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们逐行理解代码</p><p id="2673" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Line1 </strong>:这里我们声明了一个对象 person1，并分配了一个 object，name 为 key。</p><p id="b9f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Line2 </strong>:这里我们声明了第二个对象 person2，并将 person1 对象赋给它。</p><p id="b5bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第 3 行&amp;第 4 行</strong>我们通过控制台日志检查了对象，并获得了预期值。</p><p id="dd96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第 6 行:</strong>这里我们试图用值“Shiv”更新 person2 对象名。</p><p id="5df0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第 7 行:</strong>这里我们再次控制台日志 person2，并得到了 person2 的值。</p><p id="9446" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生了真正的奇迹。我们认为预期的输出应该是<em class="ld"> {name: "Ajay"} </em>，但是我们得到了<em class="ld"> {name: "Shiv"} </em>。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/7eddbb82b689fd9c98fe63e10f0c49f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*f8uw07Ya_uilYtUL"/></div></figure><p id="c7e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么会这样？当我们更新 person2 时，person1 也发生了变化，这是因为内存引用(person2 更新了原始引用，因此指向该引用的所有对象都将得到更新)或者你可以说是对象突变，我已经用图表解释过了。</p><h2 id="1632" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated">如何防止对象突变？</h2><p id="8514" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">我们可以使用许多第三方库来防止对象变异。但是在这里，我将解释 2 JavaScript 技术</p><h2 id="519d" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 1。</strong> </a></h2><p id="4689" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">此方法试图将所有参数从源对象复制到目标对象。如果使用不当，该方法会将可变对象作为输出。通过在目标参数中提供一个空对象，可以很容易地避免改变对象。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mn"><img src="../Images/17eab1eca855c68d7e65b2cd94a46204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gqoBmeiSDAQPTySy1KbIA.png"/></div></div></figure><p id="3863" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io">第 2 行</strong>这里，我们使用了 Object.assign 方法，这个方法给了我们预期的输出。</p><h2 id="75ee" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 2。展开语法</strong> </a></h2><p id="0e93" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">JavaScript 扩展语法可用于防止对象突变。你可以从<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于 spread 语法的知识。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mo"><img src="../Images/70edad1a9fb78f148043678b7d6b2d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF2quDluOYTL4LiyEaZgog.png"/></div></div></figure><p id="943d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里的<strong class="jx io"> line2 </strong>中，我们使用了 spread 语法，这给了我们预期的输出。</p><h2 id="9534" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated"><strong class="ak">如何防止单个对象上的变异？</strong></h2><p id="f675" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">在上面的例子中，我们试图修改 const 对象。如果你有一个要求，你不希望你的对象重新分配一些其他的值呢？你会怎么做？</p><p id="801a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上问题的解决方法是 Object.freeze()方法。这种方法可以防止数据被轻易更改，并且在我们的代码中访问数据时，都将使用原始值</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mp"><img src="../Images/ecac87c09cc35dc4fb974d40e07a6d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jm1ZpRanHEeHK8uxkE6XVw.png"/></div></div></figure><h2 id="244f" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated"><strong class="ak">结论</strong></h2><p id="780c" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">在这里，我们学习了 3 种防止对象突变的方法。还有其他几种方法可以用来防止对象突变。如果你有任何担心或者你知道任何其他方法，请在评论中告诉我。</p><p id="187c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae lc" href="https://www.youtube.com/@codingwithkrpajay?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅获取更多类似内容解码，我们的 YouTube 频道</strong> </a> <strong class="jx io">！</strong>感谢阅读。快乐编码。</p><p id="59e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的博客也将在<a class="ae lc" href="https://ajaykrp.me/" rel="noopener ugc nofollow" target="_blank">https://ajaykrp.me/</a>推出。</p></div></div>    
</body>
</html>