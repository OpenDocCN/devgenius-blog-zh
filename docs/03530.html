<html>
<head>
<title>Best solutions for Microsoft interview tasks. Pattern Recognition.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软面试任务的最佳解决方案。模式识别。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-solutions-for-microsoft-interview-tasks-pattern-recognition-fe331643a9c0?source=collection_archive---------2-----------------------#2020-11-15">https://blog.devgenius.io/best-solutions-for-microsoft-interview-tasks-pattern-recognition-fe331643a9c0?source=collection_archive---------2-----------------------#2020-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/bf5875794727fcdf7e3f0a290ac4769d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVek2pjvzHTm_I7dq-HRCA.jpeg"/></div></figure><div class=""/><h1 id="3065" class="jr js iu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">描述:</h1><div class="im in gp gr io kp"><a href="https://leetcode.com/discuss/interview-question/928806/" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd iv gy z fp ku fr fs kv fu fw it bi translated">微软| OA 2020 |模式识别- LeetCode讨论</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">697 VIEWS编程挑战描述:给定一个模式作为第一个参数和一个由|…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">leetcode.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld iq kp"/></div></div></a></div><h1 id="f1cb" class="jr js iu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">解决方案:</h1><p id="2b5d" class="pw-post-body-paragraph le lf iu lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">看起来这个任务不是关于算法的，这只是关于写一个简单的解析器，它将给定的字符串分解成多个部分，并写一个函数，它在给定的字符串中查找并计算所有的子字符串。</p><p id="c876" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这个任务中唯一有趣的主题是寻找子串算法的实现。但是任务不要求实现这个算法，字符串很短，我们对子字符串的搜索没有特殊要求，所以我们可以使用标准库中的实现。我们应该记住的唯一事情是，这个实现的复杂性可能非常不同。像这样的简单算法的平均复杂度约为2*N，其中N是字符串的长度，复杂度更低，为O(N*P ),其中P是模式的长度，这取决于std::string.find()方法的实现。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a63f" class="mq js iu mm b gy mr ms l mt mu">int count_substrings(const std::string &amp; s, const std::string&amp; sub, bool overlapped = true) {<br/>    size_t sub_size = sub.size();<br/>    if ( (sub_size == 0) || (sub_size &gt; s.size()) ) return 0;<br/>    int count = 0;<br/>    for (size_t offset = s.find(sub); <br/>      offset != string::npos;<br/>      offset = s.find(sub, overlapped?offset+1:offset+sub.size()))</span><span id="7a8e" class="mq js iu mm b gy mv ms l mt mu">    {<br/>        ++count;<br/>    }<br/>    return count;</span><span id="e37d" class="mq js iu mm b gy mv ms l mt mu">}</span></pre><p id="40ba" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于像“aaa…(1.000.000多一个‘a’)…aaaB”和重叠子串“aaa…(999.000多一个‘a’)…aaaB”这样的字符串，它会工作得非常慢，因为我们需要比较1.000.000 * 999.000个字符。</p><p id="1ee1" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">即使复杂度为O(N ),也有许多更快的算法，但它们都适用于特殊情况或有附加要求。这就是为什么有如此多的算法被发明出来，而人们并不是只使用其中最好的一个。下面我将展示几个最著名的通用算法，它们适用于大多数情况，并且没有太多额外的要求。</p><p id="72ac" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">最著名的是<a class="ae mw" href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="noopener ugc nofollow" target="_blank">Knuth-Morris-Pratt算法</a></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b40e" class="mq js iu mm b gy mr ms l mt mu">int KMP_count(const string &amp;s, const string &amp;sub) {<br/>    int num_subs = 0;<br/>    size_t sub_size = sub.size();<br/>    size_t s_size = s.size();<br/>    if ((sub_size == 0) || (sub_size &gt; s.size())) { return 0; }<br/>    vector&lt;int&gt; prefixes(sub_size);<br/>    for (int k = 0, i = 1; i &lt; sub_size; ++i) {<br/>        while ((k &gt; 0) &amp;&amp; (sub[i] != sub[k])) {<br/>            k = prefixes[k - 1];<br/>        }<br/>        if (sub[i] == sub[k]) { k++; }<br/>        prefixes[i] = k;<br/>    }</span><span id="0509" class="mq js iu mm b gy mv ms l mt mu">    for (int k = 0, i = 0; i &lt; s_size; ++i) {<br/>        while ((k &gt; 0) &amp;&amp; (sub[k] != s[i])) {<br/>            k = prefixes[k - 1];<br/>        }<br/>        if (sub[k] == s[i]) { k++; }</span><span id="3bd8" class="mq js iu mm b gy mv ms l mt mu">        if (k == sub_size) {<br/>            // to get position of substrings in the string<br/>            // (i - sub_size + 1); <br/>            ++num_subs;<br/>        }<br/>    }<br/>    return num_subs;<br/>}</span></pre><p id="8e31" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">有一种线性复杂度的快速算法，其工作原理类似于KMP算法，但看起来更容易理解。这就是所谓的<a class="ae mw" href="https://cp-algorithms.com/string/z-function.html" rel="noopener ugc nofollow" target="_blank"> Z功能</a>。与前面的算法一样，它需要分配一个大小为S的额外整数数组，其中S是字符串N的长度+子字符串p的长度。然后，我们将Z函数的计算结果保存在数组中，遍历该数组并识别搜索的子字符串的位置。这个算法的实现如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1932" class="mq js iu mm b gy mr ms l mt mu">vector&lt;int&gt; z_function (const string &amp; s) {<br/>    int n = (int) s.size();<br/>    vector&lt;int&gt; z (n);<br/>    for (int i=1, l=0, r=0; i&lt;n; ++i) {<br/>        if (i &lt;= r)<br/>            z[i] = min (r-i+1, z[i-l]);<br/>        while (i+z[i] &lt; n &amp;&amp; s[z[i]] == s[i+z[i]])<br/>            ++z[i];<br/>        if (i+z[i]-1 &gt; r)<br/>            l = i,  r = i+z[i]-1;<br/>    }<br/>    return z;<br/>}</span><span id="2ac7" class="mq js iu mm b gy mv ms l mt mu">int z_count(const std::string &amp; s, const std::string&amp; sub) {<br/>    size_t sub_size = sub.size();<br/>    if ( (sub_size == 0) || (sub_size &gt; s.size()) ) return 0;</span><span id="2127" class="mq js iu mm b gy mv ms l mt mu">    string working_string(sub + s);<br/>    size_t ws_size = working_string.size();</span><span id="53a1" class="mq js iu mm b gy mv ms l mt mu">    auto z = z_function(working_string);</span><span id="a47e" class="mq js iu mm b gy mv ms l mt mu">    int number_subs = 0;</span><span id="2480" class="mq js iu mm b gy mv ms l mt mu">    for(int i = sub_size; i &lt; ws_size; ++i) {<br/>        if (z[i] &gt;= sub_size) {<br/>// to get exact position of substrings in the string<br/>//            cout &lt;&lt; i - sub_size &lt;&lt; endl; <br/>            ++number_subs;<br/>        }<br/>    }<br/>    return number_subs;<br/>}</span></pre><p id="bdc5" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">最后，我们应该实现解析器，它将输入字符串分解为模式和blobs，我们将在其中搜索模式。</p><p id="b93a" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">不幸的是，标准C++仍然没有像普通C中的strtok那样好的标记器，所以我将使用它。即使它看起来不像纯C++解决方案那么安全，但它允许在一个类似的地方标记一个字符串，而不是在纯C++中标记几十行。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3890" class="mq js iu mm b gy mr ms l mt mu">string parser(const string &amp; s) {<br/>    string output;<br/>    int total_patterns = 0;</span><span id="96be" class="mq js iu mm b gy mv ms l mt mu">    size_t pos = s.find_first_of(';');</span><span id="ebf6" class="mq js iu mm b gy mv ms l mt mu">    string pattern = s.substr(0, pos);<br/>    string blobs = s.substr(pos+1);</span><span id="a9f6" class="mq js iu mm b gy mv ms l mt mu">    for(char *token = strtok((char*)blobs.c_str(), "|"); <br/>        token != NULL; token = strtok(NULL, "|")) <br/>    {<br/>        string stoken(token);<br/>//        int num_patterns = count_substrings(stoken, pattern);<br/>//        int num_patterns = z_count(stoken, pattern);<br/>        int num_patterns = KMP_count(stoken, pattern);<br/>        total_patterns += num_patterns;<br/>        output.append(to_string(num_patterns));<br/>        output.append("|");<br/>    }<br/>    output.append(to_string(total_patterns));<br/>    return output;<br/>}</span></pre><p id="5f52" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您可以在这里找到包含完整项目的资源库:<a class="ae mw" href="https://github.com/jolly-fellow/microsoft/tree/master/pattern_recognition" rel="noopener ugc nofollow" target="_blank">https://github . com/jolly-fellow/Microsoft/tree/master/pattern _ recognition</a></p><p id="6042" class="pw-post-body-paragraph le lf iu lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">返回到<a class="ae mw" href="https://medium.com/@molchevsky/best-solutions-for-microsoft-interview-tasks-cae6b0f3ff86" rel="noopener">目录。</a></p></div></div>    
</body>
</html>