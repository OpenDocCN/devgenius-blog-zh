<html>
<head>
<title>How to Send Concurrent HTTP Requests in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 发送并发 HTTP 请求</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-send-concurrent-http-requests-in-python-d9cda284c86a?source=collection_archive---------0-----------------------#2022-01-04">https://blog.devgenius.io/how-to-send-concurrent-http-requests-in-python-d9cda284c86a?source=collection_archive---------0-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3199750026e6fd97f16294dadced06c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-k9HLrvL9-XVyUC8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="62d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据一些消息来源，2020 年互联网上的数据总量将达到 40 兆字节。一个齐塔字节大约是一万亿吉字节。你不得不承认那是相当多的。</p><p id="676a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检索这些数据并利用它们做一些有用的事情的最好方法是发送一个 HTTP 请求。然而，单个请求可能无法获得大量数据。因此，检索数据的实际最佳方式是发送大量 HTTP 请求。但是如果同步发送，发送大量请求会花费相当多的时间，也就是说，如果在发送下一个请求之前等待一个请求完成。解决这个问题的最好方法是利用并发性。</p><p id="33dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 非常适合处理数据。有大量有用的库，它是数据科学的行业标准，也是数据工程的首选语言之一。</p><p id="5473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将描述发送并发请求的两种不同方法。</p><ol class=""><li id="61e5" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">内置并发库</strong></li></ol><p id="5252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，Python 是一种多线程语言，然而，由于实践中的 GIL(全局解释器锁)，它实际上并不是。因此，Python 中的线程与并发性的关系比与并行性的关系更大。</p><p id="ed61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并发库有一个名为 ThreadPoolExecutor 的类，我们将使用它来发送并发请求。对于这个例子，我使用的是 Rick 和 Morty API。我们的目标是获得瑞克和莫蒂漫画中各种角色的信息，API 是一个很好的起点。我们来看一些代码，我会逐行解释:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="bb52" class="lt lu iq lp b gy lv lw l lx ly">import requests</span><span id="dc93" class="lt lu iq lp b gy lz lw l lx ly">import concurrent</span><span id="8973" class="lt lu iq lp b gy lz lw l lx ly">from concurrent.futures import ThreadPoolExecutor</span><span id="0982" class="lt lu iq lp b gy lz lw l lx ly">characters = range(1, 100)</span><span id="d0f1" class="lt lu iq lp b gy lz lw l lx ly">base_url = 'https://rickandmortyapi.com/api/character'</span><span id="7b79" class="lt lu iq lp b gy lz lw l lx ly">threads = 20</span><span id="c807" class="lt lu iq lp b gy lz lw l lx ly">def get_character_info(character):</span><span id="2d12" class="lt lu iq lp b gy lz lw l lx ly">    r = requests.get(f'{base_url}/{character}')</span><span id="252a" class="lt lu iq lp b gy lz lw l lx ly">    return r.json()</span><span id="6764" class="lt lu iq lp b gy lz lw l lx ly">with ThreadPoolExecutor(max_workers=threads) as executor:</span><span id="8d5f" class="lt lu iq lp b gy lz lw l lx ly">    future_to_url = {executor.submit(get_character_info, char)</span><span id="bb10" class="lt lu iq lp b gy lz lw l lx ly">    for char in characters}</span><span id="b264" class="lt lu iq lp b gy lz lw l lx ly">    for future in concurrent.futures.as_completed(future_to_url):</span><span id="c44a" class="lt lu iq lp b gy lz lw l lx ly">    try:</span><span id="25ae" class="lt lu iq lp b gy lz lw l lx ly">        data = future.result()</span><span id="a179" class="lt lu iq lp b gy lz lw l lx ly">        print(data)</span><span id="d577" class="lt lu iq lp b gy lz lw l lx ly">    except Exception as e:</span><span id="91ed" class="lt lu iq lp b gy lz lw l lx ly">        print('Looks like something went wrong:', e)</span></pre><p id="7520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第 1–3 行是我们需要的导入库。我们将使用<a class="ae kc" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">请求</strong> </a>库向 API 发送 HTTP 请求，我们将使用<a class="ae kc" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">并发</strong> </a>库并发执行它们。</p><p id="fffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">characters 变量是一个从 1 到 99 的整数范围(注意，我使用的是 range 而不是 list，因为这样变量被延迟加载到内存中，这意味着它在内存方面更有效)。</p><p id="1b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ma"> base_url </em>是我们将调用的端点以及字符 id 后缀来获取我们的数据。</p><p id="9168" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ma"> threads </em>变量基本上告诉我们的<em class="ma"> ThreadPoolExecutor </em>我们想要产生最多 20 个线程(但不是我所说的真正的 OS 线程)。第 13–20 行进行实际的执行。</p><p id="20f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ma"> future_to_url </em>变量是一个字典，它有一个有趣的键值对。关键是一个方法— <em class="ma"> executor.submit </em>。更有趣的是，该方法接受两个参数。一个是函数名(<em class="ma"> get_character_info </em>)，另一个是传递给那个函数的参数。确保不要混淆这一点，通过在括号中添加<em class="ma"> char </em>参数，就像调用<em class="ma"> get_character_info </em>函数本身一样。字典的值基本上是一个元组理解，这是我们通常不会用作字典值的东西。这里的要点是迭代所有的角色 id，并对每个角色 id 进行函数调用。</p><p id="0201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们启动一个 for 循环，该循环将遍历<em class="ma">concurrent . futures . as _ completed(future _ to _ URL)</em>，简单来说，这意味着——将这些调用的结果作为结束。</p><p id="7138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">try/except 块将数据变量声明为 HTTP 请求的结果，希望不会失败。如果是这样，我们将打印一个简单的错误消息，看看哪里出错了。</p><p id="14a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您运行了这段代码，您可能已经看到了它的执行速度。我们在不到一秒钟的时间里获得了 100 个 API 结果。如果我们一个接一个地做这件事，可能要花一分多钟。</p><ol class=""><li id="429b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">Asyncio 库</strong></li></ol><p id="be33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Asyncio </strong> </a>模块也是内置的，但是为了配合 HTTP 调用使用，我们需要安装一个异步 HTTP 库，名为<a class="ae kc" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> aiohttp </strong> </a>。原因是我们之前使用的请求库不能异步工作，所以它在这里没有任何作用。</p><p id="c9e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Asyncio 的工作方式与 ThreadPoolExecutor 不同，它使用一种叫做<em class="ma">事件循环</em>的东西。这类似于 NodeJs 的工作方式，所以如果您来自 JavaScript，您可能对这种方法很熟悉。</p><p id="3a5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4bff" class="lt lu iq lp b gy lv lw l lx ly">import aiohttp</span><span id="bd9a" class="lt lu iq lp b gy lz lw l lx ly">import asyncio</span><span id="c84f" class="lt lu iq lp b gy lz lw l lx ly">characters = range(1,100)</span><span id="cffd" class="lt lu iq lp b gy lz lw l lx ly">base_url = 'https://rickandmortyapi.com/api/character'</span><span id="b752" class="lt lu iq lp b gy lz lw l lx ly">async def get_character_info(character, session):</span><span id="d92c" class="lt lu iq lp b gy lz lw l lx ly">    r = await session.request('GET', url=f'{base_url}/{character}')</span><span id="73a0" class="lt lu iq lp b gy lz lw l lx ly">    data = await r.json()</span><span id="4554" class="lt lu iq lp b gy lz lw l lx ly">    return data</span><span id="f0fd" class="lt lu iq lp b gy lz lw l lx ly">async def main(characters):</span><span id="4815" class="lt lu iq lp b gy lz lw l lx ly">    async with aiohttp.ClientSession() as session:</span><span id="df8a" class="lt lu iq lp b gy lz lw l lx ly">        tasks = []</span><span id="1a76" class="lt lu iq lp b gy lz lw l lx ly">        for char in characters:</span><span id="2ec3" class="lt lu iq lp b gy lz lw l lx ly">        tasks.append(get_character_info(character=char, session=session))</span><span id="8ab0" class="lt lu iq lp b gy lz lw l lx ly">        results = await asyncio.gather(*tasks, return_exceptions=True)</span><span id="ddbc" class="lt lu iq lp b gy lz lw l lx ly">    return results</span><span id="e4bf" class="lt lu iq lp b gy lz lw l lx ly">if __name__ == '__main__':</span><span id="8251" class="lt lu iq lp b gy lz lw l lx ly">    data = asyncio.run(main(characters))</span><span id="067d" class="lt lu iq lp b gy lz lw l lx ly">    for item in data:</span><span id="8c9b" class="lt lu iq lp b gy lz lw l lx ly">    print(item)</span></pre><p id="65e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前 10 行代码与 ThreadPoolExecutor 方法相对相似，有两个主要区别。首先，我们正在导入<strong class="kf ir"> aiohttp </strong>库，而不是<strong class="kf ir">请求</strong>。第二，在我们的函数定义中，我们在所有东西前面使用了<em class="ma"> async </em>关键字。这样我们就告诉 Python 解释器，我们将在一个事件循环中运行这个函数。</p><p id="30b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第 12-18 行是与第一种方法不同的地方，但是正如您可能得出的结论，最重要的调用是<em class="ma"> tasks.append </em>调用，它类似于第一种方法中的<em class="ma">executor . submit</em>call<em class="ma"/>。下一行中的<em class="ma"> asyncio.gather </em>类似于<em class="ma"> futures.as_completed </em>方法，因为它在一个集合中收集并发调用的结果。</p><p id="6511" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当使用 asyncio 时，我们需要调用<em class="ma"> asyncio.run() </em>(只有 Python 3.7 及更高版本才有，否则需要多几行代码)。这个函数接受一个参数，这个参数是我们想要添加到事件循环中的异步函数。</p><p id="0be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法可能有点复杂，但它更快、更可靠。一般来说，我会更多地推荐它，尤其是如果您正在进行数百甚至数千个并发调用的话。</p><p id="1550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，这两种方法中的任何一种都将在同步调用 HTTP 调用所需时间的一小部分内完成 HTTP 调用。</p><p id="70c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文到此为止。一如既往，如果你喜欢，请尽情鼓掌:)</p><p id="52ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我错过了什么，请留下评论。</p><p id="47fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>