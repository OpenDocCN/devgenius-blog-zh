<html>
<head>
<title>Best of Modern JavaScript — Array Holes and Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——数组漏洞和操作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-array-holes-and-operations-de6b0407f93b?source=collection_archive---------7-----------------------#2020-10-25">https://blog.devgenius.io/best-of-modern-javascript-array-holes-and-operations-de6b0407f93b?source=collection_archive---------7-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7611fe125d6c609c11b38c76b5782fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ccu2DiZFihF7eKho"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@palmografia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kittikom Chaichum </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3b62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些有洞的数组操作。</p><h1 id="6d36" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组操作和孔</h1><p id="04b2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">各种操作以不同的方式处理数组孔。</p><p id="631c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迭代是通过调用<code class="fe me mf mg mh b">Array.prototype[Symbol.iterator]</code>完成的。</p><p id="aad3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将孔视为条目<code class="fe me mf mg mh b">undefined</code>。</p><p id="91cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们直接给<code class="fe me mf mg mh b">Symbol.iterator</code>打电话，我们就能看到这一点。</p><p id="8e09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b9a8" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'];<br/>const iter = arr[Symbol.iterator]();</span><span id="b4a3" class="mq lc iq mh b gy mv ms l mt mu">console.log(iter.next())<br/>console.log(iter.next())</span></pre><p id="1b75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从返回迭代器，让我们用迭代器顺序获取数组的元素。</p><p id="cd68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们第一次调用<code class="fe me mf mg mh b">next</code>，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f68" class="mq lc iq mh b gy mr ms l mt mu">{ value: undefined, done: false }</span></pre><p id="3fca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们再次调用<code class="fe me mf mg mh b">next</code>，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0654" class="mq lc iq mh b gy mr ms l mt mu">{ value: "foo", done: false }</span></pre><p id="d64a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，第一个<code class="fe me mf mg mh b">next</code>调用返回的是<code class="fe me mf mg mh b">value</code>即<code class="fe me mf mg mh b">undefined</code>。</p><p id="9fc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread操作符也以同样的方式处理孔。</p><p id="71db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="701d" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'];<br/>console.log([...arr]);</span></pre><p id="1c49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们展开<code class="fe me mf mg mh b">arr</code>数组后，我们可以看到记录的值是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a954" class="mq lc iq mh b gy mr ms l mt mu">[undefined, "foo"]</span></pre><p id="9973" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of循环也以同样的方式处理孔。</p><p id="23eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07bf" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'];</span><span id="cfbd" class="mq lc iq mh b gy mv ms l mt mu">for (const x of arr) {<br/>  console.log(x);<br/>}</span></pre><p id="e805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">undefined</code>和<code class="fe me mf mg mh b">'foo'</code>。</p><p id="1de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Array.from()</code>使用迭代将可迭代对象转换为数组。</p><p id="2da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与spread运算符完全一样。</p><p id="24df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5e58" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'];</span><span id="42ea" class="mq lc iq mh b gy mv ms l mt mu">console.log(Array.from(arr));</span></pre><p id="3c7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f280" class="mq lc iq mh b gy mr ms l mt mu">[undefined, "foo"]</span></pre><p id="d1c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将一个不可迭代的类似数组的对象传入<code class="fe me mf mg mh b">Array.from</code>方法，丢失的条目仍然被视为<code class="fe me mf mg mh b">undefined</code>。</p><p id="fcea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2182" class="mq lc iq mh b gy mr ms l mt mu">const arr = Array.from({<br/>  1: 'foo',<br/>  length: 2<br/>})</span></pre><p id="4f36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到同样的结果。</p><p id="9c3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第二个参数，<code class="fe me mf mg mh b">Array.from</code>的工作方式类似于<code class="fe me mf mg mh b">Array.prototype.map</code>。</p><p id="a713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f605" class="mq lc iq mh b gy mr ms l mt mu">const arr = Array.from([, 'foo'], x =&gt; x)</span><span id="b749" class="mq lc iq mh b gy mv ms l mt mu">console.log(arr);</span></pre><p id="6fd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是<code class="fe me mf mg mh b">[undefined, “foo”]</code>。</p><p id="c8e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用它来得到指数。为此，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8552" class="mq lc iq mh b gy mr ms l mt mu">const arr = Array.from([, 'foo'], (x, i) =&gt; i)</span></pre><p id="8fa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是<code class="fe me mf mg mh b">[0, 1]</code>。</p><p id="5ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跳过洞，但保留它们。</p><p id="fd3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a79a" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'].map(x =&gt; x)</span><span id="5b21" class="mq lc iq mh b gy mv ms l mt mu">console.log(arr);</span></pre><p id="e5c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f36d" class="mq lc iq mh b gy mr ms l mt mu">[empty, "foo"]</span></pre><p id="9944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">贴图后，该孔将保留为空槽。</p><p id="9256" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将一个有孔的数组映射到一个索引数组，情况也是如此。</p><p id="d6ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="22ac" class="mq lc iq mh b gy mr ms l mt mu">const arr = [, 'foo'].map((x, i) =&gt; i)</span></pre><p id="e5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">[empty, 1]</code>。</p><p id="5e8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同的数组实例方法对数组孔的行为有不同的处理方式。</p><p id="c5d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">forEacg</code>、<code class="fe me mf mg mh b">filter</code>、<code class="fe me mf mg mh b">some</code>忽略孔洞。</p><p id="2c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">map</code>跳过但保留漏洞。</p><p id="b7ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">join</code>和<code class="fe me mf mg mh b">toString</code>像对待<code class="fe me mf mg mh b">undefined</code>一样对待球洞，</p><p id="1562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">null</code>和<code class="fe me mf mg mh b">undefined</code>被视为空字符串。</p><p id="8774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">copyWithin</code>复制孔时创建一个孔。</p><p id="e26d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">entries</code>、<code class="fe me mf mg mh b">keys</code>、<code class="fe me mf mg mh b">values</code>、<code class="fe me mf mg mh b">find</code>和<code class="fe me mf mg mh b">findIndex</code>将每个孔视为<code class="fe me mf mg mh b">undefined</code>。</p><p id="ad69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fill</code>不在乎有没有洞。</p><p id="378a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">concat</code>、<code class="fe me mf mg mh b">map</code>、<code class="fe me mf mg mh b">push</code>、<code class="fe me mf mg mh b">reverse</code>、<code class="fe me mf mg mh b">slice</code>、<code class="fe me mf mg mh b">sort</code>、<code class="fe me mf mg mh b">splice</code>、<code class="fe me mf mg mh b">unshift</code>均为预留孔。</p><p id="e64c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pop</code>和<code class="fe me mf mg mh b">shift</code>把它们当做元素。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e463f62d3ef16a46fc8f821b35a64255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w5b8xfztVvEO3Rqp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@afafa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德烈亚斯·菲克尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3f33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="91bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不同的运算符和方法会以不同的方式处理数组孔。</p></div></div>    
</body>
</html>