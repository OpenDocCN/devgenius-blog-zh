<html>
<head>
<title>CREDIT CS50</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信用 CS50</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/credit-cs50-100c71ee10a1?source=collection_archive---------5-----------------------#2022-04-04">https://blog.devgenius.io/credit-cs50-100c71ee10a1?source=collection_archive---------5-----------------------#2022-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bb07b32c4ff1bb39db8b54f516fb3df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAOBOaiGmR19VDLNvHNwJw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来自 energepic.com 的 IMG 乘坐<a class="ae jz" href="https://www.pexels.com/es-es/foto/terminal-de-pago-negro-2988232/" rel="noopener ugc nofollow" target="_blank"> Pexels </a></figcaption></figure><p id="0dc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们介绍了 Luhn 的算法，该算法允许我们确定信用卡号码在语法上是否有效，对于现实世界的问题，数据库检查也是必要的，但是 Luhn 的算法所做的是:</p><ol class=""><li id="37e6" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">从数字的倒数第二个数字开始，每隔一个数字乘以 2，然后将这些乘积的数字相加。</li><li id="8cd7" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">将总和加到没有乘以 2 的数字的总和上。</li><li id="65e6" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果总数的最后一位是 0(或者，更正式地说，如果总数模 10 等于 0)，则该数字有效！</li></ol><p id="f447" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的算法是我们必须在程序中实现的。看起来很简单对吗？</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="034c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看主体的第一部分。我们需要做的第一件事是从用户那里获得卡号，我们使用函数<code class="fe lt lu lv lw b">get_long</code>我们不能使用<code class="fe lt lu lv lw b">int</code>因为信用卡号码有太多的字符，<code class="fe lt lu lv lw b">get_long</code>已经处理了像字母或其他不计数的字符这样的输入，我们需要获得信用卡的长度，我们声明两个变量<code class="fe lt lu lv lw b">length</code>等于 0，它将存储总的卡长度，<code class="fe lt lu lv lw b">a</code>将存储卡号。</p><p id="6c22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我决定使用一个<code class="fe lt lu lv lw b">do while</code>循环，将一个数除以 10 会去掉它的最后一个数字，所以<code class="fe lt lu lv lw b">while</code> <code class="fe lt lu lv lw b">a</code>大于 0 我们会去掉<code class="fe lt lu lv lw b">a</code>的最后一个数字，并且我们会增加<code class="fe lt lu lv lw b">length</code>变量来得到输入的 CC 的长度</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8abb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 main 的第二部分，我们检查卡是否有效。我们需要打印无效的，或者如果有效，我们需要打印公司的名称。</p><p id="10ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">卡号只能有 13、15 或 16 位，所以这是我们用<code class="fe lt lu lv lw b">if</code>语句检查的第一件事。</p><p id="2543" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在那之后，我们初始化并声明一些我们稍后会用到的变量，其中一个是<code class="fe lt lu lv lw b">last</code>，它存储每个<code class="fe lt lu lv lw b">do while</code>循环后的最后一个数字，我们稍后需要求和在<code class="fe lt lu lv lw b">last</code>用<code class="fe lt lu lv lw b">last = x % 10;</code>存储当前的最后一个数字之后，我们删除当前的最后一个数字，然后我们对每个循环中的最后一个数字求和，<em class="md">这将是 Luhn 算法的第二部分(将总和加到没有乘以 2.0 的数字的总和上)</em>,我们将其存储在</p><p id="5e99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们必须做 Luhn 算法的第一部分，做第二部分可能会有点混乱，但我发现这样做更容易，我们需要<em class="md">将“每隔一个数字乘以 2，从数字的倒数第二个数字开始，然后将那些乘积的数字加在一起”。</em>在上一部分之后，我们删除了最后一位数字，所以现在我们有了存储在变量中的倒数第二位<em class="md">数字，然后我们删除它，我们调用函数<code class="fe lt lu lv lw b">sumDoubledNumber</code>负责将乘法所得的两位数相加，然后我们将乘积相加，循环再次开始，直到没有剩余的卡数字，并且添加了<code class="fe lt lu lv lw b">doubledSum and notDoubledSum</code>。</em></p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="39bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 main 的第三部分，我们检查品牌名称，这一部分的第一个检查是"<em class="md">如果总数的最后一位是 0(或者更正式地说，如果总数模 10 等于 0)，则该数字有效！"，</em>如果通过，我们检查品牌，我们做的第一个是 VISA，唯一有 13 个数字的卡是 VISA，所以如果<code class="fe lt lu lv lw b">length</code>是 13，我们打印 VISA，或者如果卡号从 4 开始，有 16 个数字作为<code class="fe lt lu lv lw b">length</code>，它也应该是 VISA，这里<code class="fe lt lu lv lw b">secondToLast</code>作为卡号的第一个数字。</p><p id="e2da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果该号码符合签证的要求，我们检查它是否是美国运通卡，该卡必须有 15 个数字，具有<code class="fe lt lu lv lw b">checkAMEX</code>功能。</p><p id="3ed8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果号码有 16 位，我们用<code class="fe lt lu lv lw b">checkMC </code>功能检查是否是主卡，这样就完成了我们的主功能。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h2 id="7093" class="me mf in bd mg mh mi dn mj mk ml dp mm kl mn mo mp kp mq mr ms kt mt mu mv mw bi translated">功能。</h2><p id="27fa" class="pw-post-body-paragraph ka kb in kc b kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated">第一个函数是处理两位数的数字，如果乘以 2 返回一个两位数的数字，我们需要分别对它们求和，为此我们使用模运算符去掉第二个数字，然后用 1 求和，因为一个数字乘以 2 最高可以是 18，否则我们只返回和。它在每次循环中都将倒数第二个数字作为参数。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6253" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个函数将检查卡是否是美国运通卡，以卡号作为参数，在这种情况下，所有的美国运通卡都以<strong class="kc io"> 37 开始，</strong>我决定做一个<code class="fe lt lu lv lw b">do while</code>循环，当最后一位数超过 38 时，继续丢弃数字，如果最后两位数等于<strong class="kc io"> 34 或 37 </strong>，则该卡是美国运通卡，否则无效。</p><p id="cd1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三个函数将检查该卡是否为主卡，基本上与上面的算法相同，我们只是将数字替换为<strong class="kc io"> 56、51 和 55 </strong>。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="13b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们的程序完成了，应该可以通过测试了。这里有一些号码来检查您的程序:378282246310005 作为美国运通，5105105105105 作为万事达卡，401288888881881 作为 VISA，5673598276138003 作为无效</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e6a30b8169f6f0d52e0259fbfdf6cf62.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*vsM1Cd3JygaRga3nR3pfbQ.png"/></div></figure><p id="8f7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读。如果这有帮助，请随意鼓掌两次，如果你觉得淘气，请跟我来。).</p></div></div>    
</body>
</html>