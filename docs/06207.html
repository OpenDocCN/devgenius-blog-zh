<html>
<head>
<title>C-Christmas tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">圣诞树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-christmas-tree-2d47299f20c2?source=collection_archive---------8-----------------------#2021-12-21">https://blog.devgenius.io/c-christmas-tree-2d47299f20c2?source=collection_archive---------8-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1cae10d7478e3a58e0f21bc22f72e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-2w2k9ZepwsR_HXB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@frostroomhead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rodion Kutsaev </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是圣诞节🎄还有什么比用 C 语言<em class="lb">编程一棵圣诞树并让灯光渐亮渐暗更好的呢？。或者只是说说树。我们热爱树木😄。这是我们要做的:</em></p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/fe46ae8cbc0552f00a8d69c98365a1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*pbRjX9bTV3nyGHQLanAIYg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">预期产出</figcaption></figure><blockquote class="lh li lj"><p id="5cc6" class="kd ke lb kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">一篇<!-- -->文章最初发布在<a class="ae kc" href="https://www.bytegarage.co/post/c-christmas-tree" rel="noopener ugc nofollow" target="_blank">字节跳动网站</a>！<strong class="kf ir">查看</strong>其他文章和开发技巧</p></blockquote><p id="e74a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会从零开始，但是我们会看到完整代码中一些有趣的部分，你可以在这里找到<a class="ae kc" href="https://github.com/bytegarage/c-christmas-tree" rel="noopener ugc nofollow" target="_blank"/>。我们将特别关注以下主题:</p><ol class=""><li id="7df0" class="ln lo iq kf b kg kh kk kl ko lp ks lq kw lr la ls lt lu lv bi translated">ANSI 转义序列</li><li id="59ee" class="ln lo iq kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated">指极星</li><li id="5b02" class="ln lo iq kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated">c 语言(显然是❤️)</li></ol><h2 id="21e9" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">我们开始吧！</h2><h1 id="39ea" class="mu mc iq bd md mv mw mx mg my mz na mj nb nc nd mm ne nf ng mp nh ni nj ms nk bi translated">设置环境</h1><p id="6eac" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated"><a class="ae kc" href="https://github.com/bytegarage/c-christmas-tree" rel="noopener ugc nofollow" target="_blank">下载项目</a>，在你喜欢的编辑器中打开根文件夹。我们喜欢<a class="ae kc" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"><em class="lb">vs code</em></a><em class="lb"/>，因为它是可配置的、可扩展的，并且有很多扩展可以满足每种语言和开发者的需要。<br/>您应该只看到所有信号源所在的<code class="fe nq nr ns nt b">src</code>。从终端根目录下创建一个新文件夹<code class="fe nq nr ns nt b">bin</code>:</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="0b83" class="mb mc iq nt b gy ny nz l oa ob">mkdir bin</span></pre><p id="1335" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保您的终端支持 ANSI 转义序列。我们在集成于 VSCode 的终端上使用<a class="ae kc" href="https://ohmyz.sh/#install" rel="noopener ugc nofollow" target="_blank"> Oh My Zsh </a>或者<a class="ae kc" href="https://iterm2.com" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>如果你使用 macOS 系统。快速测试运行最终项目，并检查输出是否像上面的 GIF 中的那样。</p><h1 id="39e5" class="mu mc iq bd md mv mw mx mg my mz na mj nb nc nd mm ne nf ng mp nh ni nj ms nk bi translated">探索项目</h1><p id="bfaa" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated">最重要的文件是<code class="fe nq nr ns nt b">christmas.c</code>和<code class="fe nq nr ns nt b">console_color.c</code></p><p id="bbe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">christmas.c</code>持有<code class="fe nq nr ns nt b">main()</code>和程序的高层逻辑。它还加载了包含圣诞树形状和灯位置的<code class="fe nq nr ns nt b">txt</code>文件。要定义形状，请使用任何字符、空格和换行符，要定义光线，请使用' $ '字符。一个例子给了打击</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="03ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">console_color.c</code>包含将 ANSI 代码写入<code class="fe nq nr ns nt b">stdout</code>(终端输出)的函数</p><h1 id="21a9" class="mu mc iq bd md mv mw mx mg my mz na mj nb nc nd mm ne nf ng mp nh ni nj ms nk bi translated">这段代码是如何工作的？</h1><p id="a2d8" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated">让我们深入研究一下<code class="fe nq nr ns nt b">christmas.c</code>文件的<code class="fe nq nr ns nt b">main()</code>功能。<br/>首先我们创建两个数组<em class="lb"> str </em>和<em class="lb"> line </em>:</p><ul class=""><li id="0170" class="ln lo iq kf b kg kh kk kl ko lp ks lq kw lr la oe lt lu lv bi translated"><code class="fe nq nr ns nt b">str</code>存储从<code class="fe nq nr ns nt b">load_happiness()</code>函数读取的<code class="fe nq nr ns nt b">tree.txt</code>文件的原始解析输入。</li><li id="5e2c" class="ln lo iq kf b kg lw kk lx ko ly ks lz kw ma la oe lt lu lv bi translated">从<code class="fe nq nr ns nt b">str</code>数组派生的<code class="fe nq nr ns nt b">line</code>，用一个随机的<strong class="kf ir">负数</strong>代替字符“$”。该变量属于<code class="fe nq nr ns nt b">char</code>类型，通常被编译器指定为<code class="fe nq nr ns nt b">signed char</code>(即范围为<code class="fe nq nr ns nt b">[-127,+127]</code>)，考虑到定义为<a class="ae kc" href="https://www.asciitable.com" rel="noopener ugc nofollow" target="_blank"> ASCII 表</a>的每个元素的 1 字节整数值，该变量被认为是用于<strong class="kf ir">。ASCII 表中没有对负数进行编码，在我们的例子中，每个负数都将由<code class="fe nq nr ns nt b">plot()</code>函数进行处理，以改变我们的挂件的颜色。</strong></li></ul><p id="02bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以注意到，在下面计算<code class="fe nq nr ns nt b">line</code>的代码中，我们没有使用<code class="fe nq nr ns nt b">line</code>变量本身，而是使用了一个指向它的指针。的确写<code class="fe nq nr ns nt b">char *pc = str;</code>就像写<code class="fe nq nr ns nt b">char *pc = &amp;str[0].</code></p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就是指针算术美女✨</p><p id="ba41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个<code class="fe nq nr ns nt b">char</code>指针，每次我们增加它，我们前进一个字符，<strong class="kf ir">，就像数组</strong>中的一个索引增量，但是更简洁！</p><h2 id="b25e" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">去吧！像设计师一样编码！</h2><p id="d227" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated">我们正在接近更图形化的部分。<br/>除了<em class="lb"> while </em>循环在每个周期结束时休眠<em class="lb"> 100ms </em>，<strong class="kf ir">之外，我们将关注以下函数</strong> : <code class="fe nq nr ns nt b">clrscr()</code>，<code class="fe nq nr ns nt b">plot()</code>，<code class="fe nq nr ns nt b">gotoxy()</code>，因为它们使用<em class="lb"> ANSI 转义码来控制终端，也称为(CSI —控制序列引入器)。</em>我认为解释它们的最快方法是说:</p><blockquote class="lh li lj"><p id="18d0" class="kd ke lb kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">并不是每一次打印都在命令行上输出一些文本</p></blockquote><p id="1696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上<strong class="kf ir">某些字符序列被解释为指令</strong>，允许改变文本颜色，移动光标或清除控制台屏幕和其他有趣的东西。<strong class="kf ir">有些甚至是参数化的！！</strong>🔝你可以在这里找到可用的<em class="lb">CSI</em>T27】列表</p><p id="aed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自己试试吧！！打开一个终端，运行一些产生输出的命令，如<code class="fe nq nr ns nt b">ls</code>，最后，运行以下命令:</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="eef5" class="mb mc iq nt b gy ny nz l oa ob">echo "\033[1J"</span></pre><p id="6f71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台上的所有输出都消失了。这个简单的例子与函数<code class="fe nq nr ns nt b">clrscr()</code>完全相同。<em class="lb">来看看<code class="fe nq nr ns nt b">console_color.c</code>中<code class="fe nq nr ns nt b">clrscr()</code>功能实现下面的</em>简单介绍一下<br/></p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe nq nr ns nt b">__puts(s)</code>是<code class="fe nq nr ns nt b">fputs(s,stdout)</code>的别名</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="8422" class="mb mc iq nt b gy ny nz l oa ob">#define __puts(<em class="lb">s</em>) fputs(s, stdout)</span></pre><p id="e999" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那个<strong class="kf ir">穿上</strong> <code class="fe nq nr ns nt b"><strong class="kf ir">stdout</strong></code>(实际打印)一串<code class="fe nq nr ns nt b">s</code>。考虑中的字符串是常量<code class="fe nq nr ns nt b">CLEAR_SCREEN</code>,定义为</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="0f14" class="mb mc iq nt b gy ny nz l oa ob">#define CLEAR_SCREEN "\033[1J"</span></pre><p id="0ad4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">嘿！我们之前在终端上运行的确切序列！</em> </strong></p><h2 id="09dc" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">坚持住！我们快到了</h2><p id="3f4e" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated"><code class="fe nq nr ns nt b">plot()</code>和<code class="fe nq nr ns nt b">gotoxy()</code>功能<em class="lb">与<code class="fe nq nr ns nt b">clrscr()</code>没有太大区别</em>，除了它们使用的转义序列不固定，而是<strong class="kf ir">参数化</strong>。</p><p id="27a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在项目中查找<code class="fe nq nr ns nt b">gotoxy()</code>的出现，我们发现作为主 while 循环中调用的第一条指令，每周期调用一次，并且总是将光标放在位置<code class="fe nq nr ns nt b">(1,1)</code> ( <code class="fe nq nr ns nt b">gotoxy(1,1)</code>即<em class="lb">终端屏幕左上角</em>)。<em class="lb">老何</em>是</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="b141" class="mb mc iq nt b gy ny nz l oa ob">#define GOTO_ROW_COL "\033[%d;%dH"</span></pre><p id="3498" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe nq nr ns nt b">fprintf</code>函数在<code class="fe nq nr ns nt b">stdout</code>上放置一个格式化的字符串，其中两个整数<code class="fe nq nr ns nt b">%d</code>作为参数传递</p><p id="0689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe nq nr ns nt b">line</code>参数调用<code class="fe nq nr ns nt b">plot(line)</code>函数(即使名称可能会引起误解，但这不是我们输入的一行，而是包含随机数的变量，以代替<code class="fe nq nr ns nt b">tree.txt</code>输入文件中的‘$’字符)。这里是圣诞奇迹发生的地方，所以我们会更近距离地看到它:</p><ol class=""><li id="ea60" class="ln lo iq kf b kg kh kk kl ko lp ks lq kw lr la ls lt lu lv bi translated">它以与上面相同的逻辑循环字符串中的每个字符</li><li id="9f6b" class="ln lo iq kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated"><strong class="kf ir">对于每个字符，我们检查值<br/> — </strong>，如果大于 0，将控制台字符颜色设置为绿色<code class="fe nq nr ns nt b">set_color(color_rgb)</code>，并将字符原样放入<code class="fe nq nr ns nt b">stdout</code>。它会被印上绿色的' *' <br/> — <strong class="kf ir">这里是最神奇的部分！</strong>如果小于等于 0<em class="lb">2 . 2 . 1<br/>。</em>将控制台颜色设置为字符值的函数(<code class="fe nq nr ns nt b">set_color_rgb(color,0,0)</code>其中<code class="fe nq nr ns nt b">color = -(*p * 2)</code>)。<br/> <em class="lb"> 2.2.2 中我们将谈到色彩值。</em>在<code class="fe nq nr ns nt b">stdout</code>上打印“*”字符代替数字<br/> 2.2。<em class="lb"> 3。</em> <strong class="kf ir">逐渐减少指针值</strong>直到最小值，之后返回上限值并再次开始减少</li><li id="87a9" class="ln lo iq kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated">用<code class="fe nq nr ns nt b">fflush(stdout)</code>清除<code class="fe nq nr ns nt b">stdout</code></li></ol><h2 id="819a" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">最后是颜色值的解释</h2><p id="d989" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated">上面的点 2 基于指针值做出决定，代码建议我们需要<em class="lb">在我们有负指针值的地方放置字符“*”</em>。我们的输出全是' * '，我们的<code class="fe nq nr ns nt b">tree.txt</code>输入也全是' * '，除了灯应该在哪里。这意味着决策部分的<code class="fe nq nr ns nt b">else</code>部分与<code class="fe nq nr ns nt b">line</code>变量创建期间生成的随机数相关。实际上' * '对应于<a class="ae kc" href="https://www.asciitable.com" rel="noopener ugc nofollow" target="_blank"> ASCII 表</a>中的整数 42，我们让它保持原样。相反，当我们遇到' $ '字符时，我们会生成一个范围为<code class="fe nq nr ns nt b">[-1,-100]</code>的随机数。上面的“魔法发生的地方”中，在点<em class="lb"> 2.2.1 </em>将颜色定义为</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="2ea0" class="mb mc iq nt b gy ny nz l oa ob">unsigned char color = -(*p * 2)</span></pre><p id="ef2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将该值标准化以传入使用另一个<em class="lb"> CSI </em>从 RGB 术语设置颜色的函数<code class="fe nq nr ns nt b">set_color_rgb()</code>:</p><pre class="ld le lf lg gt nu nt nv nw aw nx bi"><span id="6296" class="mb mc iq nt b gy ny nz l oa ob">#define RGB_FOREGRAUND_PATTERN "\033[38;2;%d;%d;%dm"</span></pre><p id="d1ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反转<code class="fe nq nr ns nt b">*p</code>的符号就足以达到预期的效果。乘数因子<code class="fe nq nr ns nt b">2</code>是<strong class="kf ir">唯一的</strong>来扩展范围，以更好地看到使用更多<code class="fe nq nr ns nt b">[0,255]</code> RGB 范围的淡入淡出效果。注意，我们可以做这个乘法，因为** <strong class="kf ir">我们已经将</strong> <code class="fe nq nr ns nt b"><strong class="kf ir">color</strong></code> <strong class="kf ir">定义为具有范围<code class="fe nq nr ns nt b">[0,255]</code>的</strong> <code class="fe nq nr ns nt b"><strong class="kf ir">unsigned char,</strong></code>。如果我们将<code class="fe nq nr ns nt b">color</code>定义为简单的<code class="fe nq nr ns nt b">char</code>，我们将有一个介于<code class="fe nq nr ns nt b">[-127,127]</code>和<code class="fe nq nr ns nt b">* 2</code>乘法之间的范围，因为默认情况下<code class="fe nq nr ns nt b">char</code>是带符号的，我们可能会溢出。</p><p id="cc84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你检查<code class="fe nq nr ns nt b">set_color_rgb()</code>函数，有一些按位运算符处理 RGB 颜色分量，但这些不是现在的重点。我只是想强调一下，只是为了解释为什么我们把每个“光字符”的值变成大于 0 的值<code class="fe nq nr ns nt b">≤ 255</code>(<strong class="kf ir">RGB 编码中的每个通道都是</strong> <code class="fe nq nr ns nt b"><strong class="kf ir">8 bit ~&gt; [0,255]</strong></code>)</p><h2 id="a39e" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">给你的代码增加时间</h2><p id="cb87" class="pw-post-body-paragraph kd ke iq kf b kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la ij bi translated">我们演练的最后一部分是通过在代码中添加时间来给出的。<code class="fe nq nr ns nt b">christmas.c</code>中<code class="fe nq nr ns nt b">main()</code>功能中<em class="lb"> while </em>循环的最后一条指令是在<code class="fe nq nr ns nt b">console.c</code>中定义的<code class="fe nq nr ns nt b">sleepms(100)</code>。它只休眠了<em class="lb">100 毫秒</em>，否则，我们将看不到灯光的效果，因为程序几乎会立即终止。有了这个睡眠时间，我们可以在<em class="lb">100 毫秒</em>内看到每个小球的颜色。</p><p id="f194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，圣诞快乐！🎅</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/184dc899c30d16aff481ac326d8aae3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6S8HDhMTGXwf8oznpUAkA.jpeg"/></div></div></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="2606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文章灵感来自<strong class="kf ir"> <em class="lb"> redmax </em> </strong>代码托管在<a class="ae kc" href="https://github.com/bytegarage/c-christmas-tree" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上</p></div></div>    
</body>
</html>