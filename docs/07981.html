<html>
<head>
<title>JavaScript :: this &amp; binding.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript :: this &amp; binding。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-this-binding-39428cb65165?source=collection_archive---------7-----------------------#2022-05-08">https://blog.devgenius.io/javascript-this-binding-39428cb65165?source=collection_archive---------7-----------------------#2022-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc34a0965dd0acfaa1663bd419d94a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXZoBU5l3niJBGsPzS4QWQ.png"/></div></div></figure><p id="10fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最容易混淆的一个概念就是“<strong class="jx io">这个</strong>”。我们在确定<strong class="jx io">这个</strong>的值时一般容易混淆。即使是经验丰富的 JavaScript 开发人员有时也会犯这个错误。</p><p id="ba11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在深入探讨之前，关于确定“this”的值，需要注意的一个关键点是，它是从调用<strong class="jx io">的地方</strong>开始的，而不是从声明<strong class="jx io">的地方</strong>开始的。</p><p id="8e52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然上面的陈述不能保证你会成为“这个”中的忍者，但至少你会对它有一个更好的了解。</p><p id="e57b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们举个例子。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/1e0f6cf218eaba78eab526c6803ddf3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*13NU28owysxbCbI7AbbWuw.png"/></div></figure><p id="115d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的程序不言自明。如果你看到 2，3，4 印在控制台上。</p><p id="0ca4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，猜猜 koo.count 的输出应该是什么？？// 3.</p><p id="8003" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果是的话，那么也许我们需要更详细地理解“这个”的概念。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/8f6db603e29b95ea6d4aece4fe9d33ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PHioIxtXCg09PxQqByv2g.png"/></div></div></figure><p id="8f48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很惊讶。</p><p id="8d31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，让我们尝试在 JS 引擎遇到第 3 行时检查上面的代码。</p><p id="56d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看到第 5 行，我们在 koo 对象上分配属性“count ”,它被初始化为 0。</p><p id="aa2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，我们试图考察这里的“这个”属于全局窗口对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/4be09eab95a1fa0c6a8d11d03edd45ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIuGJqurl6xJhXZegtM3lg.png"/></div></div></figure><blockquote class="la lb lc"><p id="cfc9" class="jv jw ld jx b jy jz ka kb kc kd ke kf le kh ki kj lf kl km kn lg kp kq kr ks ig bi translated"><strong class="jx io">注意:无论何时调用一个函数，都要记住新的执行上下文和作用域链。</strong></p></blockquote><p id="3468" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第 3 行 this.count++上，在全局窗口对象上创建了一个 count 属性。但是，在第 5 行，koo.count = 0，与 this.count++不同。前者是 koo 函数对象上的属性，后者是全局窗口对象上的属性。目前，this.count++的值将是 NaN。</p><p id="a63e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，“this”并没有指向所有的函数对象，这就是混乱的地方。</p><p id="fc46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，问题是为什么“<strong class="jx io">这个</strong>没有指向函数对象自己的作用域。</p><p id="0a12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个问题几乎没有可能的解决办法。</p><p id="d227" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们设法找到解决这个问题的第一个办法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/d323344fa527b550003115d6364c9cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWNKjl9_ur_tM58nxKaGZg.png"/></div></div></figure><p id="6410" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述问题的解决方案就像我们用窗口全局对象的 count 属性创建一个新的循环对象，并且每当满足 for 循环条件时递增计数。但是，上述解决方案试图转移我们对“这个”的理解。</p><p id="7e9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请继续本教程的其他部分，将会更好地了解 JavaScript 中使用的不同绑定，如调用、应用和绑定。</p><p id="172d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该问题的另一个解决方案是通过 koo 函数对象的词法范围将 koo.count 属性递增到 koo 函数对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/bb17a959cef28cee15d0ce8a354e588e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0f36w2OMu_GVIKXGjy5X_g.png"/></div></div></figure><p id="86ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，我们并没有强迫我们的问题使用“this”，这使我们处于一种分散“<strong class="jx io"> this </strong>”的真实用例的情况。</p><p id="a577" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，如何才能强制将“<strong class="jx io">这个</strong>”绑定到函数对象的范围呢？</p><p id="554d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个问题的第一个解决方案是使用 JavaScript 中的“绑定”。</p><p id="b2c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在进一步讨论之前，如何在不猜测的情况下确定“这个”的值？</p><p id="f123" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ld">什么是“呼叫站点”？</em>T19】</strong></p><p id="f3c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ld">检测代码中调用函数的位置，而不是声明函数的位置。</em>T3】</strong></p><p id="17aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，当代码变得沉重和复杂时，不容易找到调用位置。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/8326f86f121451886369b91effc2bbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5t72ZawD_L4Nyo7GaQgAOQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">调用站点和调用堆栈</figcaption></figure><p id="07a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看看 foo 和 koo 这两个方法，我们可以很容易地把它从调用点和调用栈中取出来。</p><p id="2605" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们继续使用不同的绑定来强制使用“this”。</p><p id="112f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，有五个规则适用于绑定。</p><ol class=""><li id="46db" class="lo lp in jx b jy jz kc kd kg lq kk lr ko ls ks lt lu lv lw bi translated"><strong class="jx io"> <em class="ld">默认绑定</em> </strong></li><li id="7de7" class="lo lp in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated"><strong class="jx io"> <em class="ld">隐式绑定</em> </strong></li><li id="c1b1" class="lo lp in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated"><strong class="jx io"> <em class="ld">显式绑定</em> </strong></li><li id="9557" class="lo lp in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated"><strong class="jx io"> <em class="ld">硬装订</em> </strong></li><li id="45ee" class="lo lp in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated"><strong class="jx io">新装订</strong></li></ol><p id="2b55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于以上 5 条规则，我们将尝试确定“this”的值。</p><ol class=""><li id="a0b8" class="lo lp in jx b jy jz kc kd kg lq kk lr ko ls ks lt lu lv lw bi translated"><strong class="jx io">默认绑定</strong> —如果没有其他规则适用，此规则适用于默认。这里，“<strong class="jx io"> this </strong>”被解析为全局对象。</li></ol><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/51f41f753a9c84521b42dc387bbf7f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*v4H1t3UAHSlWWU9naBsDng.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">默认绑定</figcaption></figure><p id="d9cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">隐式绑定</strong> —当我们检查调用点是否有上下文对象时，这条规则适用。它是负责函数调用“this”绑定的对象。</p><p id="8f19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论 foo 在代码中的什么地方声明，调用点都使用对函数的 obj 引用。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4e49d2b60e88641960be7de4625f9b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*LTEi8zbxfE9abNh5gmRPKw.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">隐式结合</figcaption></figure><p id="a363" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在隐式绑定中，为了加强“this”用法，我们改变了 obj 并在其上调用 foo 函数。但是，如果我们想在不使用对象的附加属性的情况下执行“this ”,该怎么办呢？接下来是“<strong class="jx io">显式绑定</strong>”。</p><p id="8c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.<strong class="jx io">显式绑定</strong> —它允许我们将<strong class="jx io">这个</strong>强制为“obj”。它有三种味道。调用(…)、应用(…)和绑定(…)。函数的第一个参数是“this”。</p><p id="62ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="ld">call 和 apply 的区别在于 call 带单个参数，apply 带一个参数数组。</em> </strong></p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f4820da34afd64e143b2494b5f5ea1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*ueJDZtjt74Q4zhRSeRKTeA.png"/></div></figure><p id="e65b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.<strong class="jx io">硬绑定</strong> —我们创建一个函数 bar()，在内部调用 foo.call(obj)，从而为此强制调用 foo 与 obj 绑定。不管你怎么操作这个 bar，它总是会用 obj 手动调用 foo。这种绑定既显式又强，所以我们称之为硬绑定。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/f4651e684787b00930938c21401e4c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*ODF-o2JNapmEJfXOqqE_SA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">硬装订</figcaption></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/96e9998e9989b5f118323269ec40bd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*VQNEFhijkoz0NkIPjRSFog.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">使用绑定方法</figcaption></figure><p id="54d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.<strong class="jx io">新绑定</strong> —通过构造函数调用来调用。</p><blockquote class="la lb lc"><p id="50bc" class="jv jw ld jx b jy jz ka kb kc kd ke kf le kh ki kj lf kl km kn lg kp kq kr ks ig bi translated"><strong class="jx io">现在，应用上述 4 个规则，优先级从新绑定&gt;硬绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定。如果上述规则都不适用，将自动调用默认绑定。</strong></p></blockquote><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/8cbb34735d675943a5e4fcabf879f80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ld9NiqqEfp02yLuLaNbX_Q.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">绑定优先顺序</figcaption></figure><p id="08e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你可能已经对“这个”有了更好的理解。</p><blockquote class="la lb lc"><p id="8f4a" class="jv jw ld jx b jy jz ka kb kc kd ke kf le kh ki kj lf kl km kn lg kp kq kr ks ig bi translated">请记住:如果您将 null 或 undefined 作为 this binding 参数传递给 call、apply 或 bind，这些值实际上会被忽略，取而代之的是应用于调用的默认绑定规则。</p></blockquote><p id="4060" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，上面的程序可以通过调用、应用和绑定来解决。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/b469b5db0de62108e774e9e9aceed97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdRaMiKqbsq8tzG9LiJCMA.png"/></div></div></figure><p id="c56c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请随意摆弄代码，并掌握好 JavaScript 中的“this”和绑定。</p><p id="91b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的意图是使概念解释更加简单化。</p><blockquote class="la lb lc"><p id="5374" class="jv jw ld jx b jy jz ka kb kc kd ke kf le kh ki kj lf kl km kn lg kp kq kr ks ig bi translated"><strong class="jx io">声明:我学习 JavaScript 的灵感来自 Kyle Simpson 的《你不知道 JS》。</strong></p></blockquote><p id="d542" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码。不断学习。继续探索。😊</p></div></div>    
</body>
</html>