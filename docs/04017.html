<html>
<head>
<title>Understanding the Stack — A Precursor to exploiting Buffer Overflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解堆栈——利用缓冲区溢出的前奏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-the-stack-a-precursor-to-exploiting-buffer-overflow-8c6972fdb4ac?source=collection_archive---------1-----------------------#2021-01-16">https://blog.devgenius.io/understanding-the-stack-a-precursor-to-exploiting-buffer-overflow-8c6972fdb4ac?source=collection_archive---------1-----------------------#2021-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3f02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，</p><p id="e5b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我试图利用C程序中的缓冲区溢出，事实证明，理解堆栈对于在这一努力中取得有意义的进步是至关重要的。</p><p id="22dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多课堂笔记很好地解释了缓冲区溢出，但不知何故，它们往往没有给出攻击期间RAM中发生了什么的整体视图。</p><p id="69c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我决定写一篇文章来了解缓冲区溢出是如何工作的，以及内存中有什么。</p><p id="2599" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将根据我的理解讨论这三张图，希望有人能从这篇文章中受益！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/945cd3af6297e5a11d7ca978aad8f031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0_ldrMQW__kRL7HV.jpg"/></div></div></figure><p id="b2ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">左边的图1(橙色)展示了当程序被加载到内存中时，内存分配是如何完成的。</p><p id="2147" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设我们在32位机器上的系统中有4 GB的RAM。此后我们将把RAM称为存储器。在现代操作系统中，加载到内存中的每个程序都假设整个内存(在本例中为4 GB)属于该进程。从程序的角度来看，它是这样的。这就是我们在这篇文章中讨论的记忆。</p><p id="afa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意——(对于那些想知道这是如何工作的人来说——在现代操作系统中，内存位置的地址是范围<strong class="jm io"> 0x00000000到0x ffffff</strong>的虚拟地址，经过地址转换后映射到物理地址。这种映射是使用分页和分段机制来完成的。你可以在操作系统课程或网上了解更多，但对我们来说，你不需要关心这个。</p><p id="81ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，加载到存储器中的程序组件被分配到存储器中的各个部分。程序的代码(也称为文本)被加载到文本部分。这个部分的大小是固定的，在程序执行期间不会改变。</p><p id="4baf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">初始化的全局变量和静态变量被放入内存的数据区。</p><p id="58ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">未初始化的全局变量和未初始化的静态局部变量放在内存的BSS部分。如果你想知道为什么这个部分被称为BSS，那么让我告诉你，BSS的完整形式是由符号开始的块，它被这样称呼是出于历史原因，你可以忽略它。</p><p id="99e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆是在运行时用来动态分配内存的内存区域。像C语言中的<strong class="jm io"> Malloc()、Realloc() </strong>这样的函数用于分配这部分内存的空间。如图1所示，堆朝着更高的地址向上增长。</p><p id="34c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈部分从内存中最高的地址开始，向下朝着较低的地址增长。一个函数的局部变量和另一个函数的参数存储在堆栈中。</p><p id="ca3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈是一种LIFO结构，这意味着— <em class="ku">后进先出</em>。推入堆栈的第一个元素是最后一个弹出堆栈的元素。</p><p id="e256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么堆栈和堆放在内存的两端？好吧，在古代，当内存很小的时候，那么stack和heap经常会耗尽空间并触及其他部分的边界。为了避免这种情况，我们采用了这种布局，并且现在仍在使用。</p><p id="f908" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就完成了内存的高级视图。在此阶段，我们继续前进，只关注堆栈。</p><p id="36ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，每个还没有返回的函数，在堆栈上都有一个堆栈框架。在下图中，<strong class="jm io"> <em class="ku"> last() </em> </strong>函数<strong class="jm io"> <em class="ku"> </em> </strong>被调用并被执行的点，此时上图2(绿色)显示了函数<strong class="jm io"> <em class="ku"> last() </em> </strong>被执行时堆栈的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/11ec15a0568074deb4498e17c24a4a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*wNSW5zygHDvcpigo.jpg"/></div></figure><p id="10fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了返回到原始函数并继续正常执行，EIP ( <em class="ku">扩展指令指针寄存器，指向在任意时间点</em>要执行的下一条指令)自然必须指向调用函数(<em class="ku">，刚刚返回</em>)的下一行。</p><p id="495b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，在调用任何函数之前，我们将EIP的内容保存在堆栈中是很自然的。</p><p id="7331" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，为了使用堆栈，我们需要两个非常重要的寄存器</p><p id="ddf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.EBP(扩展基本指针)</p><p id="8732" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.扩展堆栈指针</p><p id="010e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基址指针存储堆栈帧的基址地址。栈指针总是指向栈顶。(实际上，这是堆栈中地址最低的位置)。</p><p id="a1c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个重要的寄存器是EIP ( <em class="ku">扩展指令指针</em>)，它总是指向下一条要执行的指令。在将控制权转移给另一个函数之前，EIP总是最后保存在给定函数的堆栈框架中。这样做是为了让被调用的函数在完成执行后能够将控制权返回给调用函数。这种控制转移是通过用旧值加载EIP(它指向调用函数中的下一行代码)并将ESP和EBP设置为旧值来完成的，以便调用函数可以继续正常执行。</p><p id="a11e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，EIP、ESP和EBP使得一个函数调用另一个函数，然后在被调用的函数返回后继续正常执行成为可能。所有这些都是借助堆栈框架实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/35ee085d692f098eef878db95ffbd5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*K992sQOanLQaLOat.jpg"/></div></figure><p id="d741" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上图所示，EBP和ESP指向当前正在执行的函数的堆栈框架的底部和顶部。所有其他堆栈帧在将控制转移到另一个函数之前保存EBP和EIP值。</p><p id="ac72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们转到图3(蓝色)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56bd6dbe0aeea2d0922805ecbb77bdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EHuTFxntCVL8r9Q7.jpg"/></div></div></figure><p id="4f37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这张图表最重要的事情如下:</p><p id="c339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.推入函数堆栈框架的第一项是前一个函数堆栈框架的EBP。这是<strong class="jm io">始终出现在堆栈框架上的</strong>。</p><p id="8c50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.然后<strong class="jm io">可能有也可能没有</strong>一些空间(是4字节的倍数)来存储返回值。</p><p id="91bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.局部变量总是按照它们被声明的顺序排列(局部变量1，局部变量2)。这些变量<strong class="jm io">总是出现在堆栈上</strong>。</p><p id="ecf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<strong class="jm io">可能有也可能没有</strong>任何保存的寄存器和临时寄存器。</p><p id="c45a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.下一个函数调用的<strong class="jm io">参数保存在<strong class="jm io">逆序</strong> (arg 2，arg 1)中。如果</strong>下一个函数需要参数，这些参数<strong class="jm io">总是存在。</strong></p><p id="95f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.栈上的最后一个<strong class="jm io">是EIP </strong>，也就是返回地址ie。被调用函数返回后要执行的下一行代码的地址。</p><p id="b068" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这里重要的是要认识到</strong>——尽管局部变量和自变量以它们在图中指定的顺序出现在堆栈上，但堆栈可能有其他临时值(s <em class="ku">可能返回值或在函数执行期间生成的其他值</em>),因此，当您比较两个程序的堆栈框架时，您可以预期局部变量和自变量以它们在图中指定的顺序在EBP和ESP之间浮动。</p><p id="df95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缓冲区溢出攻击</strong>的目的，就是在堆栈上覆盖这个值，这样当被调用的函数返回时，它就加载攻击者代码的地址并执行它。例如，下一个堆栈帧的局部变量1可能溢出，从而覆盖EBP，然后覆盖EIP(因为内存从较低的地址填充到较高的地址)。</p><p id="192f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽情享受吧！</p></div></div>    
</body>
</html>