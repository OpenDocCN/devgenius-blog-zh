<html>
<head>
<title>Forget Git Checkout, Use Git Switch and Git Restore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">忘记 Git 检验，使用 Git 开关和 Git 恢复</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/forget-git-checkout-use-git-switch-and-git-restore-78fb01a55011?source=collection_archive---------3-----------------------#2022-09-06">https://blog.devgenius.io/forget-git-checkout-use-git-switch-and-git-restore-78fb01a55011?source=collection_archive---------3-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3df8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它仍然存在，但应该被遗忘</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7ed8eb618247ae62cbf21f3d23087d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qmQCdFjB52lkmyhv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马尔斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d4cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在日常工作中使用 Git，<code class="fe ls lt lu lv b">git checkout</code>是一个常用命令。经常用来切换分支，看<a class="ae kv" href="https://git-scm.com/docs/git-checkout" rel="noopener ugc nofollow" target="_blank">文档</a>可以看到<em class="lw">“切换分支或者恢复工作树文件”</em>这句话。但是 UNIX 应该是<a class="ae kv" href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well" rel="noopener ugc nofollow" target="_blank"> <em class="lw">做一件事并且做好</em> </a>。这令人困惑，所以 Git 2.23 带来了一对实验命令来代替它。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="fa44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在介绍它是如何工作的之前，我们需要简要地理解它相关的 Git 概念。</p><ul class=""><li id="3a15" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">工作副本(工作树文件):是指出现在硬盘上的存储库中的文件。</li><li id="28f1" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">索引(暂存区或缓存):它指的是你已经执行了<code class="fe ls lt lu lv b">git add</code> -ed，或者，如果你要运行<code class="fe ls lt lu lv b">git commit</code>会提交什么。</li><li id="7cff" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">HEAD:指的是“当前的”或者“活动的”分支，当我们需要签出一个分支时(指的是你试图将分支与工作副本中的内容进行匹配)，一次只能签出一个。</li></ul><p id="9380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">git checkout</code>可以签出一个分支或创建一个新分支并签入其中:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="bb8b" class="mw mx iq lv b gy my mz l na nb"># Switched to branch 'test'<br/><strong class="lv ir">$ git checkout test</strong></span><span id="657d" class="mw mx iq lv b gy nc mz l na nb"># Switched to a new branch 'test'<br/><strong class="lv ir">$ git checkout -b test</strong></span><span id="614e" class="mw mx iq lv b gy nc mz l na nb"># Switch back to the previous branch<br/><strong class="lv ir">$ git checkout -</strong></span><span id="48fe" class="mw mx iq lv b gy nc mz l na nb"># Switched to a commit<br/><strong class="lv ir">$ git checkout master~1</strong></span></pre><p id="8808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而<code class="fe ls lt lu lv b"><strong class="ky ir">git switch</strong></code>是用来接管分公司相关的，所以它也可以做:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="e46c" class="mw mx iq lv b gy my mz l na nb"># Switched to branch 'test'<br/><strong class="lv ir">$ git switch test</strong></span><span id="4dd8" class="mw mx iq lv b gy nc mz l na nb"># Switched to a new branch 'test'<br/><strong class="lv ir">$ git switch -c test</strong></span><span id="155d" class="mw mx iq lv b gy nc mz l na nb"># Switch back to the previous branch<br/><strong class="lv ir">$ git switch -</strong></span><span id="8b5c" class="mw mx iq lv b gy nc mz l na nb"># Switched to a commit<br/><strong class="lv ir">$ git switch -d master~1</strong></span></pre><p id="abaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且就像我们开头说的，<code class="fe ls lt lu lv b">git checkout</code>也可以恢复工作树文件。这部分功能由<code class="fe ls lt lu lv b"><strong class="ky ir">git restore</strong></code>接手。</p><p id="12ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过去，我们可以使用<code class="fe ls lt lu lv b">git checkout -- main.c</code>从索引中恢复工作树文件，语法是<code class="fe ls lt lu lv b">git checkout [treeish] -- &lt;filename&gt;</code>，其中<code class="fe ls lt lu lv b">treeish</code>可以指定为源。简单的例子:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="2cd9" class="mw mx iq lv b gy my mz l na nb"># Restoring the working tree from the index<br/><strong class="lv ir">$ git checkout -- ./main.c</strong></span><span id="df7b" class="mw mx iq lv b gy nc mz l na nb"># Restoring index content from HEAD<br/><strong class="lv ir">$ git reset -- ./main.c</strong></span><span id="568f" class="mw mx iq lv b gy nc mz l na nb"># Restoring the working tree and index from HEAD<br/><strong class="lv ir">$ git checkout HEAD -- ./main.c</strong></span></pre><p id="682d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，从头恢复索引内容时，我们只能使用<code class="fe ls lt lu lv b">git reset</code>，而<code class="fe ls lt lu lv b">git checkout</code>没有对应的选项。</p><p id="2c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用图表显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/774be389f5e6525d2b2c4dd3623aacf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoaJS3Zfa6gJSPn4IWv3lA.png"/></div></div></figure><p id="e5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">git restore</strong></code>更容易确定哪些文件将被恢复，以及它们将被恢复到哪里。以下选项指定还原位置:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="eb48" class="mw mx iq lv b gy my mz l na nb">-W<br/>--worktree<br/>-S<br/>--staged</span></pre><p id="6c7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，<code class="fe ls lt lu lv b">-W</code>和<code class="fe ls lt lu lv b">--worktree</code>将从索引中恢复工作树，就像没有指定选项一样(比如<code class="fe ls lt lu lv b">git restore -- ./main.c</code>)。而<code class="fe ls lt lu lv b">-S</code>和<code class="fe ls lt lu lv b">--staged</code>将从头恢复索引内容。当两者都通过时，索引和工作树将从头恢复。</p><p id="c13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="f8c5" class="mw mx iq lv b gy my mz l na nb"># Restoring the working tree from the index<br/><strong class="lv ir">$ git restore -- ./main.c</strong><br/># Equivalent to<br/><strong class="lv ir">$ git restore --worktree -- ./main.c</strong></span><span id="1923" class="mw mx iq lv b gy nc mz l na nb"># Restoring index content from HEAD<br/><strong class="lv ir">$ git restore --staged -- ./main.c</strong></span><span id="903a" class="mw mx iq lv b gy nc mz l na nb"># Restoring the working tree and index from HEAD<br/><strong class="lv ir">$ git restore --staged --worktree ./main.c</strong></span></pre><p id="69b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用图表显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/ead50729342e0adb954961898092eb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsT5A_IczU7XEHiO1xJcNQ.png"/></div></div></figure><p id="ebe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面提到的是默认设置，如果我们想从不同的提交中恢复，我们可以使用<code class="fe ls lt lu lv b">--source</code>选项。例如:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="1612" class="mw mx iq lv b gy my mz l na nb"># Restore `./main.c` in the working tree with the last commit<br/><strong class="lv ir">$ git restore -s HEAD^ -- ./main.c</strong><br/># Equivalent to<br/><strong class="lv ir">$ git restore --source=HEAD^ -- ./main.c</strong></span></pre><p id="618f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个有用的情况可能是恢复一个处理不当的文件。例如:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="499d" class="mw mx iq lv b gy my mz l na nb"># Incorrectly deleted files<br/>$ rm -f ./main.c</span><span id="bc4d" class="mw mx iq lv b gy nc mz l na nb"># Quickly restore main.c from index<br/><strong class="lv ir">$ git restore ./main.c</strong></span></pre><p id="4c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于批量恢复:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="e2ed" class="mw mx iq lv b gy my mz l na nb"># Restore all C source files to match the version in the index<br/><strong class="lv ir">$ git restore '*.c'</strong></span><span id="70aa" class="mw mx iq lv b gy nc mz l na nb"># Restore all files in the current directory<br/><strong class="lv ir">$ git restore .</strong></span><span id="604f" class="mw mx iq lv b gy nc mz l na nb"># Restore all working tree files with top pathspec magic<br/><strong class="lv ir">$ git restore :/</strong></span></pre><h1 id="7918" class="nf mx iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">结论</h1><p id="3e30" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated"><code class="fe ls lt lu lv b">git checkout</code>的功能划分得很清楚:<code class="fe ls lt lu lv b">git switch</code>用于切换分支，<code class="fe ls lt lu lv b">git restore</code>用于恢复工作树文件。它们提供了更明确的语义，符合 UNIX 的理念。</p><p id="f854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个命令都是在 2019 年提出的，截至目前，它们都是实验性的。可能会有变化，但通常不会太多，所以你现在可以使用它们，它们更容易理解，更少混淆。</p><h1 id="acd9" class="nf mx iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">参考</h1><p id="3a6b" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">[1]<a class="ae kv" href="https://git-scm.com/docs/git-switch" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-switch</a></p><p id="5326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]<a class="ae kv" href="https://git-scm.com/docs/git-restore" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-restore</a></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="994f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="lw">中等会员</em> </a> <em class="lw">。每月 5 美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="lw">我的链接</em> </a> <em class="lw">报名，我会得到一点佣金。</em></p><p id="f888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>