<html>
<head>
<title>Implementing Design Patterns Using Java 8 Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Java 8 Lambda 实现设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-design-patterns-using-java-8-lambda-c8a95ef66115?source=collection_archive---------6-----------------------#2022-12-14">https://blog.devgenius.io/implementing-design-patterns-using-java-8-lambda-c8a95ef66115?source=collection_archive---------6-----------------------#2022-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/22f435494bbaee098184f743bf2aa8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v07be1bF4DC2hK5-.png"/></div></div></figure><p id="2d8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java 8 引入了 lambda 表达式的概念，它是匿名函数，可用于实现函数接口(具有单一抽象方法的接口)。这允许使用更简洁和功能性的编程风格来实现设计模式。</p><p id="7d9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，<strong class="jx io">策略模式</strong>定义了一系列算法并支持它们的可互换性，可以使用 Java 8 中的 lambda 表达式实现，如下所示:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="4c37" class="lc ld in ky b be le lf l lg lh">public interface SortStrategy {<br/>    List&lt;Integer&gt; sort(List&lt;Integer&gt; list);<br/>}<br/><br/>public class QuickSortStrategy implements SortStrategy {<br/>    @Override<br/>    public List&lt;Integer&gt; sort(List&lt;Integer&gt; list) {<br/>        // Implementation of quick sort algorithm<br/>    }<br/>}<br/><br/>public class MergeSortStrategy implements SortStrategy {<br/>    @Override<br/>    public List&lt;Integer&gt; sort(List&lt;Integer&gt; list) {<br/>        // Implementation of merge sort algorithm<br/>    }<br/>}<br/><br/>public class Sorter {<br/>    private SortStrategy strategy;<br/><br/>    public Sorter(SortStrategy strategy) {<br/>        this.strategy = strategy;<br/>    }<br/><br/>    public void setStrategy(SortStrategy strategy) {<br/>        this.strategy = strategy;<br/>    }<br/><br/>    public List&lt;Integer&gt; sort(List&lt;Integer&gt; list) {<br/>        return strategy.sort(list);<br/>    }<br/>}<br/><br/>// Usage:<br/>Sorter sorter = new Sorter(new QuickSortStrategy());<br/>List&lt;Integer&gt; sortedList = sorter.sort(unsortedList);<br/><br/>// Using lambda expressions:<br/>Sorter sorter = new Sorter(list -&gt; {<br/>    // Implementation of quick sort algorithm using lambda expression<br/>});<br/>List&lt;Integer&gt; sortedList = sorter.sort(unsortedList);</span></pre><p id="3335" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<code class="fe li lj lk ky b">SortStrategy</code>接口及其实现(<code class="fe li lj lk ky b">QuickSortStrategy</code>和<code class="fe li lj lk ky b">MergeSortStrategy</code>)定义了不同的排序算法。<code class="fe li lj lk ky b">Sorter</code>类使用<code class="fe li lj lk ky b">SortStrategy</code>接口对整数列表进行排序。使用 lambda 表达式，排序算法可以内联实现，从而允许更简洁和功能性的编程风格。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="b364" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">观察者模式</strong>，用于在对象之间建立一对多的依赖关系，可以通过以下方式使用 lambda 表达式实现:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="88cc" class="lc ld in ky b be le lf l lg lh">// Define the interface for the strategy<br/>public interface Strategy {<br/>    public int doOperation(int a, int b);<br/>}<br/><br/>// Define the context that uses the strategy<br/>public class Context {<br/>    private Strategy strategy;<br/><br/>    public Context(Strategy strategy) {<br/>        this.strategy = strategy;<br/>    }<br/><br/>    public int executeStrategy(int a, int b) {<br/>        return strategy.doOperation(a, b);<br/>    }<br/>}<br/><br/>// Use the context and lambda expressions to define the strategies<br/>public class Main {<br/>    public static void main(String[] args) {<br/>        Context context = new Context((a, b) -&gt; a + b);<br/>        System.out.println(context.executeStrategy(3, 4)); // 7<br/><br/>        context = new Context((a, b) -&gt; a - b);<br/>        System.out.println(context.executeStrategy(3, 4)); // -1<br/><br/>        context = new Context((a, b) -&gt; a * b);<br/>        System.out.println(context.executeStrategy(3, 4)); // 12<br/>    }<br/>}</span></pre><p id="35de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，<code class="fe li lj lk ky b">Strategy</code>接口定义了所有策略都必须实现的方法。<code class="fe li lj lk ky b">Context</code>类使用一个<code class="fe li lj lk ky b">Strategy</code>对象来执行特定的操作。在<code class="fe li lj lk ky b">main()</code>方法中，lambda 表达式用于定义不同的策略，然后传递给<code class="fe li lj lk ky b">Context</code>执行。这允许您在运行时轻松地在不同策略之间切换，使您的代码更加灵活和可重用。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="fdf5" class="lc ld in ky b be le lf l lg lh">// Create an observable sequence of data<br/>Observable&lt;Data&gt; observable = Observable.create(emitter -&gt; {<br/>  while (!emitter.isDisposed()) {<br/>    Data data = getNextData();<br/>    emitter.onNext(data);<br/>  }<br/>});<br/><br/>// Subscribe to the observable sequence<br/>observable.subscribe(data -&gt; {<br/>  // Handle the data as it is received<br/>});</span></pre><p id="e7b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们使用一个 lambda 表达式来创建一个可观察的数据序列，该序列可以被程序中的其他组件订阅。lambda 表达式用于生成数据并将其发送给订阅的组件。这允许我们使用 Java 8 的 lambda 表达式以简洁和功能性的方式实现观察者模式。</p></div></div>    
</body>
</html>