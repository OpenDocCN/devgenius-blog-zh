<html>
<head>
<title>Protocol Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向协议的编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pop-or-protocol-oriented-programming-swift-3d90e006d0b3?source=collection_archive---------0-----------------------#2020-04-09">https://blog.devgenius.io/pop-or-protocol-oriented-programming-swift-3d90e006d0b3?source=collection_archive---------0-----------------------#2020-04-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="c825" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">POP比OOP好吗？</h2><div class=""/><div class=""><h2 id="807a" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">Swift中的POP介绍</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/680541f245f8521394fcfbd33eff2634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H_Ry5bGvNBqMTdkz"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">谢尔盖·佐尔金在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="71d3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated"><span class="l lz ma mb bm mc md me mf mg di">P</span>rotocol是Swift的一个基本特性。面向协议的编程是一种以完全不同的方式编写代码的强大方法。</p><p id="3c88" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">协议<strong class="le ix"> </strong>有很多特性，但这次我们不会深入探讨，假设您已经了解了协议的基础和优点:</p><p id="ee44" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在本文中，我们将深入讨论面向协议的编程，我们将确定Swift为何面向协议，列举POP和OOP(面向对象编程)两种范式的优缺点，最后我们将确定使用哪一种。</p><h1 id="b5b9" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">什么是面向协议编程或POP？</h1><p id="05ee" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">顾名思义，我们可能会错误地认为面向协议的编程就是关于协议的。实际上，这不仅是编写应用程序的不同方式，也是我们思考编程的不同方式。是一种不同的编程范式，它改进了我们在应用程序中实现代码的方式，并解决了与面向对象编程相关的问题。</p><h1 id="36fd" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated"><strong class="ak">为什么要在Swift中实施面向协议的编程？</strong></h1><p id="ac3a" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">在其他一些语言中，如C++、C #或其他具有objective-c协议的语言，这些接口和协议并不实现它们协议中的任何东西，这些协议只是作为一个蓝图来指定一个类应该采用的需求。相反，Swift协议有一个规则改变者特性:<em class="ne">协议扩展。</em></p><p id="1512" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们还可以注意到，Swift标准库(例如，看看Swift的数组定义，它继承了11个协议)也是使用协议实现的。即使我们知道一些苹果框架仍然是用Objective-C、C++或C编写的，我们也可以注意到一些新的框架，如SwiftUI或其他如GameplayKit，是由协议推动的。除此之外，您还可以扩展Swift标准库协议。</p><p id="ace1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">此外，Swift著名的委托模式使用协议作为完整的资源。</p><p id="28d6" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">另一方面，由于Swift推动我们使用更多值类型而不是引用类型来构建我们的应用程序，这些值类型(如structs和enums)可以符合协议，但不支持继承，因此协议得到了增强。除此之外，协议在Swift中作为类型工作，并支持多态性。</p><p id="e730" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">POP的另一个优点是对象可以符合Swift中的多种协议。在OOP中，对象只能从一个超类继承。这就引出了一个著名的问题:大型单片类(Massive View Controller你在吗？).使用组合将其分解成小组件，使代码更容易重用。</p><p id="55e9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">此外，面向协议的编程利用强大的协议来围绕它构建我们的应用程序架构。这一点以及我们必须编写单元测试的事实使我们利用这一范例来避免类之间的紧密耦合，并鼓励使用依赖注入。</p><p id="8286" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">此外，使用POP实现您的应用程序可以让整个团队受益于更容易的重构和维护过程。你可能会问为什么？答案是<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener">坚实的</a>和良好的实践。SOLID引导我们开始使用POP范式以不同的方式编写代码，SOLID是为使用POP而设计的。同样，你应该利用协议来编写小函数、类、结构和代码文件，将相关的属性和函数分组到协议、结构、枚举和类中，并使用有意义的变量名。即使我们使用OOP或其他范例，我们也应该始终使用软件开发的基本良好实践。</p><p id="1543" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在这里，你有一大堆理由开始审视流行范例。当然，POP的关键是利用协议的特性，如协议继承、组合和扩展。</p><h1 id="2f05" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">如何使用</h1><p id="39a5" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">如果你来自OOP，继承可能是你开始编码时首先想到的事情之一。<strong class="le ix"> </strong>所以现在，与其这样，不如试着像对待基类一样，先考虑协议。然后，您可以通过继承初始协议来创建新的协议，并编写扩展，以便它们具有默认的实现。</p><p id="b39f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这就是这个范例的工作方式，我们应该编写小的特定协议，然后向这些协议扩展添加默认实现和新功能。</p><p id="ffec" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">下面是实现POP必须了解的协议的更深层次的观点:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/better-programming/protocols-from-zero-to-hero-72423dfdfe21" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ix gy z fp nn fr fs no fu fw iw bi translated">如何掌握Swift中的协议</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">协议定义、继承、扩展等等</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kv ni"/></div></div></a></div><h1 id="4653" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">协议性能</h1><p id="9d48" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">乍一看，使用POP可能会降低应用程序在构建时间和静态分派的其他好处方面的性能，但这种范式(POP)让我们使用结构而不是类(值类型而不是引用类型)来平衡和倾斜性能，使性能更好。</p><p id="694b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">无论如何，为了实现这个目标，你可以将这种炫耀与其他实践结合起来以提高性能，看看苹果的博客吧。</p><div class="nf ng gp gr nh ni"><a href="https://developer.apple.com/swift/blog/?id=27" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ix gy z fp nn fr fs no fu fw iw bi translated">通过减少动态调度提高性能- Swift博客</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">像许多其他语言一样，Swift允许一个类覆盖在其超类中声明的方法和属性。这个…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">developer.apple.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kv ni"/></div></div></a></div><p id="36db" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">关于性能的最后一句话，您可以使用POP来提高性能，但是不要把这个范例当作灵丹妙药，您需要继续遵循所有的性能提示和技巧来达到我们的性能目标。</p><h1 id="7232" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">面向对象的常见问题</h1><p id="df8c" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">在OOP中，继承本身并不灵活，因为只允许一个超类，这使得这个超类太大，并且可能有太多的实例共享对该对象的引用。在OOP中，你必须马上选择一个超类，没有其他的建模选择。</p><p id="0d03" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果超类有存储的属性，子类必须接受它们，增加了初始化的负担。</p><p id="c41b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">超类必须在方法体中有一些东西，它不能是一个蓝图(例如，如果你的func不是Void，你必须返回一个值，在其他情况下，你必须将体设置为空或调用fatalError)。</p><p id="685a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，您必须使用final关键字来避免函数被覆盖</p><h1 id="3d35" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">所以POP还是OOP</h1><p id="c584" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">我们已经列出了两种范式之间的一些差异。我们可能认为面向协议的编程明显优于面向对象的编程，但是我们应该停止考虑它们之间的区别以及哪一个更好，并开始使用两种范例中最好的。POP和OOP并不互相排斥，它们可以互相补充。</p><h1 id="0fec" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated">结论</h1><p id="ded6" class="pw-post-body-paragraph lc ld in le b lf mz jx lh li na ka lk ll nb ln lo lp nc lr ls lt nd lv lw lx ig bi translated">我们已经读到了许多从OOP转向POP的好理由，但是，和往常一样，我们不应该仅仅因为我们读到了它或者它变得流行就转向一个新的范例、方法或者框架。我们应该像专业人士一样，选择正确的武器杀死我们的怪物。</p><p id="cf8c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">总之，让我们从协议开始，但是不要忘记基类或超类的好处。POP功能强大但不完美，记住OOP和POP可以互相补充。</p><h1 id="c3f2" class="mh mi in bd mj mk ml mm mn mo mp mq mr kc ms kd mt kf mu kg mv ki mw kj mx my bi translated"><strong class="ak">参考书目</strong></h1><ol class=""><li id="63a5" class="ny nz in le b lf mz li na ll oa lp ob lt oc lx od oe of og bi translated">WWDC 2015关于“<a class="ae lb" href="https://developer.apple.com/videos/play/wwdc2015/408/" rel="noopener ugc nofollow" target="_blank">Swift中面向协议的编程”的演讲</a></li><li id="8ad8" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">WWDC 2016关于“<a class="ae lb" href="https://developer.apple.com/videos/play/wwdc2016/419/" rel="noopener ugc nofollow" target="_blank">协议和UIKit应用</a>中面向价值的编程”的演讲</li><li id="3b17" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">Swift标准库<a class="ae lb" href="http://swiftdoc.org" rel="noopener ugc nofollow" target="_blank">http://swiftdoc.org</a></li><li id="8f15" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">Swift标准库阵列定义<a class="ae lb" href="http://swiftdoc.org/v3.1/type/Array/" rel="noopener ugc nofollow" target="_blank">http://swiftdoc.org/v3.1/type/Array/</a></li><li id="29ff" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">协议功能<a class="ae lb" href="https://medium.com/@piero9212/protocol-masters" rel="noopener">https://medium.com/@piero9212/protocol-masters</a></li><li id="bd66" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">SOLID Swift<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener">https://medium . com/better-programming/SOLID-Swift-by-examples-part-one-35018d 53d 3 e 6</a></li><li id="40f5" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">SOLID Swift<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-two-82ac3c457e4e" rel="noopener">https://medium . com/better-programming/SOLID-Swift-by-examples-part-two-82 AC 3c 457 e4e</a></li><li id="f847" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">实Swift<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-three-675672c1ec20" rel="noopener">https://medium . com/better-programming/SOLID-Swift-by-examples-part-three-675672 C1 EC 20</a></li><li id="5c16" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">实Swift<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-four-ec31bdb2872" rel="noopener">https://medium . com/better-programming/SOLID-Swift-by-examples-part-four-EC 31 BDB 2872</a></li><li id="6839" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">SOLID Swift<a class="ae lb" href="https://medium.com/better-programming/solid-swift-by-examples-part-five-a860b86b85f5" rel="noopener">https://medium . com/better-programming/SOLID-Swift-by-examples-part-five-a860 b 86 b 85 f 5</a></li><li id="7ba9" class="ny nz in le b lf oh li oi ll oj lp ok lt ol lx od oe of og bi translated">面向协议编程乔恩霍夫曼电子书</li></ol></div></div>    
</body>
</html>