<html>
<head>
<title>Method Resolution Order in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的方法解析顺序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/method-resolution-order-in-python-42505decb907?source=collection_archive---------5-----------------------#2022-08-21">https://blog.devgenius.io/method-resolution-order-in-python-42505decb907?source=collection_archive---------5-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="42f8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么样的顺序是方法解析顺序？</h1><p id="4896" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是 python 在类层次结构中搜索方法的顺序。当我们处理多重继承时，它特别有用。方法解析的重要性并不明显，直到我们处理一个我们绝对需要它的情况。</p><h1 id="35cb" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">到底哪里需要？</h1><p id="ecec" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设我们有以下情况。我们有父亲班和母亲班。我们有一个子类，按照这个顺序继承父类和母类。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/06b194d807c4feea031a2a79851153fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*S97CYPozPUu3MEr4Chywzw.png"/></div></figure><p id="d7de" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated">在这种情况下，当调用 child.do_something()时将调用哪个函数，因为父亲和母亲都有函数 do_something？这正是我们需要将类在层次结构中的顺序线性化的情况，这样我们就可以确定谁的方法或属性优先于谁。</p><h1 id="7610" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如何获得一个类的 MRO？</h1><p id="a829" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了显示类的方法解析顺序，我们可以访问类的<code class="fe lt lu lv lw b">__mro__</code>属性或者调用<code class="fe lt lu lv lw b">Child.mro()</code>函数。这将给出方法解析顺序。从这里我们可以看到，父亲的 do_something 方法将被调用，因为它是 MRO 中第一个具有 do_something 方法的类。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lx"><img src="../Images/a68c2a9c8357b247f5d6b564c7a98f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyQaR9TtMvxsQe4enTvY2Q.png"/></div></div></figure><h1 id="021c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">在基本情况下计算顺序的简单方法</h1><p id="a640" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">实际上，在简单的情况下，通过使用深度优先的从左到右方案，只需查看它是如何被继承的，就可以确定 MRO。</p><ul class=""><li id="a4ee" class="mc md in kk b kl lo kp lp kt me kx mf lb mg lf mh mi mj mk bi translated">决定优先级的第一个因素是继承的深度，即类在层次结构中的位置。这是一种理论，即子类覆盖了其父类的方法，这是非常标准的。</li><li id="6b92" class="mc md in kk b kl ml kp mm kt mn kx mo lb mp lf mh mi mj mk bi translated">第二个要考虑的因素是同一代人中各阶级的地位。在这里，优先级从左到右。在我们的例子<code class="fe lt lu lv lw b">class Child(Father, Mother)</code>中，父类先于母类。</li></ul><p id="52dc" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated">所以考虑到以上两个因素，上面例子中我们的<code class="fe lt lu lv lw b">Child</code>类的 MRO 应该是 Child&gt;Father&gt;Mother&gt;object。</p><h1 id="b131" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">C3 线性化</h1><p id="9481" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，我们试图更深入地挖掘算法的工作原理。在更复杂的类层次结构中，确定 MRO 并不容易。虽然我说过，为了我们的方便，可以在简单的情况下使用深度优先的从左到右方案来确定 MRO，但 python3 中用于确定 MRO 的实际算法是 C3 线性化。C3 线性化产生三个重要特性:</p><ul class=""><li id="860f" class="mc md in kk b kl lo kp lp kt me kx mf lb mg lf mh mi mj mk bi translated">一致扩展优先图</li><li id="8d11" class="mc md in kk b kl ml kp mm kt mn kx mo lb mp lf mh mi mj mk bi translated">保留本地优先顺序</li><li id="f30e" class="mc md in kk b kl ml kp mm kt mn kx mo lb mp lf mh mi mj mk bi translated">单调排序</li></ul><h2 id="7c6a" class="mq jl in bd jm mr ms dn jq mt mu dp ju kt mv mw jy kx mx my kc lb mz na kg nb bi translated">定义</h2><ul class=""><li id="be93" class="mc md in kk b kl km kp kq kt nc kx nd lb ne lf mh mi mj mk bi translated">类的 C3 线性化是<br/> *类本身加上<br/> *其父类的线性化加上父类列表的唯一合并</li><li id="8e4a" class="mc md in kk b kl ml kp mm kt mn kx mo lb mp lf mh mi mj mk bi translated">父项线性化的合并是通过选择不出现在任何其他列表尾部的列表的第一个头部来完成的。从输出列表的合并列表中取出选定的标题。</li><li id="508a" class="mc md in kk b kl ml kp mm kt mn kx mo lb mp lf mh mi mj mk bi translated">重复第二步，直到所有的类都从合并列表中出来，进入输出列表。</li></ul><h2 id="497a" class="mq jl in bd jm mr ms dn jq mt mu dp ju kt mv mw jy kx mx my kc lb mz na kg nb bi translated">我们自己做个 C3 连载吧</h2><p id="8be6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">下面是一个多重继承的例子。让我们在下面的例子中计算类 K 的 MRO。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/954311692aaa1379e5e0de613714b677.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*fsaD4rzkPTap8UxX-tSc8w.png"/></div></figure><p id="af42" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated">解决方案:</p><pre class="lh li lj lk gt ng lw nh ni aw nj bi"><span id="4d1f" class="mq jl in lw b gy nk nl l nm nn">First, let's get the linearization of the base class<br/>L(object) = [object] --Eq1 // since it is has no base class it's linearization list only has itself</span><span id="7761" class="mq jl in lw b gy no nl l nm nn">Now, to get the linearization of 1st generations.<br/>From the definition of [C3 Linearization, we can write, L(A) = [A] + merge(L(object), [object])`<br/>L(A) = [A] + merge(L(object), [object]) <br/>     = [A] + merge([object], [object]) // from [Eq1]<br/>     = [A, object] // object added to the output list because it's the only head doesn't appear in any tail</span><span id="27d7" class="mq jl in lw b gy no nl l nm nn">Similarly, for B &amp; C,</span><span id="e867" class="mq jl in lw b gy no nl l nm nn">L(B) = [B, object] <br/>L(C) = [C, object]</span><span id="f623" class="mq jl in lw b gy no nl l nm nn">Now, let's calculate the linearization for K<br/>From the definition of [C3 Linearization], L(K) is class + unique merge of (linearizations of parents + list of parent from left to right),<br/>L(K) = [K] + merge(L(A), L(B), L(C), [A, B, C])                      <br/>     = [K] + merge([A, object], [B, object], [C, object], [A, B, C]) // Replacing all the L(A), L(B), L(C) with their actual value<br/>     = [K, A] + merge([object], [B, object], [C, object], [B, C])    // Added A to the output list because it only appears in the head of all list in the merge part<br/>     = [K, A, B] + merge([object], [object], [C, object], [C])       // Skipped object (going from left to right) and added B to the output list because it only appears in the head of all list in the merge part<br/>     = [K, A, B, C] + merge([object], [object], [object])<br/>     = [K, A, B, C, object]</span></pre><p id="4567" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated">我们可以通过调用。mro()函数</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi np"><img src="../Images/3260ea0f340b7b8bc70fa0908b62334a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfsV6waqRtga9y3bkVv6vQ.png"/></div></div></figure><h2 id="0d73" class="mq jl in bd jm mr ms dn jq mt mu dp ju kt mv mw jy kx mx my kc lb mz na kg nb bi translated">你能想到多重继承会破裂的情况吗？</h2><p id="e316" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因为 C3 线性化要求保持局部优先顺序。当 C3 线性化中断时，通常是因为设计选择不当。下面给出了一个这样的例子:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fa2683a6a103c67ad3e47ddb4b576609.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*TDW0ut7U7Rf6R3VmEebsag.png"/></div></figure><p id="a0f8" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated">A &amp; B 的顺序在 M &amp; N 的继承中是颠倒的。这不会引起任何问题。但是当 X 从 M 和 N 继承时，局部优先级在类 X 的层次结构中没有保留。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5843f96d767bd05c1b729824eb49b250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*y26V49yS3ZVmOXmUXSVO0A.png"/></div></figure><h1 id="fa95" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="46ef" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，在 python 和任何支持多重继承的编程语言中，MRO 都是一个非常有用的概念。这是 python 在类的层次结构中寻找方法的顺序。在这篇博客中，我们了解了一些它的内部运作。您可以在参考资料部分提供的链接中阅读关于这个主题的更多信息。</p><h1 id="f198" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><p id="3745" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ns" href="http://python-history.blogspot.com/2010/06/method-resolution-order.html" rel="noopener ugc nofollow" target="_blank"> MRO 通过非吉多·范·罗苏姆本人莫属</a></p><p id="48c3" class="pw-post-body-paragraph ki kj in kk b kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf ig bi translated"><a class="ae ns" href="https://en.wikipedia.org/wiki/C3_linearization" rel="noopener ugc nofollow" target="_blank"> C3 线性化</a></p></div></div>    
</body>
</html>