<html>
<head>
<title>Generic Interface for Baremetal Task Management in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中裸机任务管理的通用接口</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/generic-interface-for-baremetal-task-management-in-rust-f3c1f1ca92a2?source=collection_archive---------8-----------------------#2022-01-12">https://blog.devgenius.io/generic-interface-for-baremetal-task-management-in-rust-f3c1f1ca92a2?source=collection_archive---------8-----------------------#2022-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/acab16433afec0fd91163d21af2ff15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbazHkCke5TUEbDOw_Y16A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">teensy 4.0微控制器对抗绘图纸</figcaption></figure><p id="12db" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我们将探索我的解决方案，在实时环境中推广任务管理。这里的代码与Rust编程语言紧密耦合，尽管概念可以在任何地方实现。</p><p id="d1d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种需求源于一个裸机内核项目。我正在开发的硬件是单核ARMv7 Cortex-M芯片:<a class="ae kx" href="https://www.pjrc.com/store/teensy40.html" rel="noopener ugc nofollow" target="_blank"> Teensy4.0 </a>。你可以在GitHub 上找到所有的源代码<a class="ae kx" href="https://github.com/SharpCoder/hexagon2/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8872" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">任何裸机程序都需要执行多个任务。问题是，你希望它们有多并发？我的内核可以归类为<em class="ky">实时操作系统</em> (RTOS)，这意味着我不使用线程调度程序来管理任务。我只是有一个进程集合，每个进程都执行得非常快，看起来像是并行的。</p><p id="f28c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是我的任务管理通用方法的一个例子。我把这些叫做<code class="fe kz la lb lc b">gates</code>。在这篇文章中，我们将探索门是如何发展的，以及实现它们的一种方法。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="52d2" class="ll lm in lc b gy ln lo l lp lq">// System entrypoint<br/>loop {<br/>   blink_task();<br/>}</span><span id="6d00" class="ll lm in lc b gy lr lo l lp lq">fn blink_task() {<br/>    gate_open!()<br/>       .once(|| { pin_mode(13, OUTPUT); })<br/>       .when_ms(500, || { pin_out(13, HIGH); })<br/>       .when_ms(500, || { pin_out(13, LOW); })<br/>       .build();<br/>}</span></pre><p id="4fb0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是另一个大门实际运行的例子:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="e0b6" class="ll lm in lc b gy ln lo l lp lq">// When data is available over serial, read the bytes into a buffer.</span><span id="27ce" class="ll lm in lc b gy lr lo l lp lq">loop {</span><span id="3174" class="ll lm in lc b gy lr lo l lp lq">gate_open!().when(<br/>|| { return serial_available() &gt; 0 }, <br/>|| { serial_buffer.append(serial_read()); }<br/>).build();</span><span id="1bd9" class="ll lm in lc b gy lr lo l lp lq">}</span></pre><p id="fc79" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里的关键是<em class="ky">门</em>存在于<code class="fe kz la lb lc b">loop { }</code>段中，但是自动处理何时将计算能力交还给内核。您不必自己实现任何状态管理，gate将它全部抽象化了。</p><h1 id="efc1" class="ls lm in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">旧世界</h1><p id="c66e" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">总的来说，我注意到了一些关于嵌入式任务的模式:</p><ul class=""><li id="38b0" class="mu mv in kb b kc kd kg kh kk mw ko mx ks my kw mz na nb nc bi translated">任务通常至少有两种谨慎的状态:初始化和工作。</li><li id="c00e" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">任务可以有复杂的嵌套条件。</li><li id="4f82" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">任务经常被放在一个无限循环中，并且需要能够从每次迭代停止的地方重新开始。</li></ul><p id="f11f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">举个我们最喜欢的例子，闪个灯。在一个要求接近实时性能的系统中，我们不能只使用<code class="fe kz la lb lc b">delay()</code>和hog资源。这里有一些rust代码来演示我们如何在闪烁状态之间产生处理能力:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="1aa7" class="ll lm in lc b gy ln lo l lp lq">static mut INITIALIZED: bool = false;<br/>static mut NEXT_ITERATION: u64 = 0;<br/>static mut HIGH: bool = false;</span><span id="abfc" class="ll lm in lc b gy lr lo l lp lq">// System entrypoint<br/>loop {<br/>    blink_task();<br/>}</span><span id="05d8" class="ll lm in lc b gy lr lo l lp lq">fn blink_task() {<br/>    if unsafe { INITIALIZED } == false {<br/>        pin_mode(13, Output);<br/>        unsafe { INITIALIZED = true };<br/>    } else {<br/>        if system::millis() &gt; unsafe { NEXT_ITERATION } {<br/>            pin_out(13, unsafe { !HIGH });<br/>            unsafe { <br/>                HIGH = !HIGH;<br/>                NEXT_ITERATION = system::millis() + 500; <br/>            };<br/>        }<br/>    }<br/>}</span></pre><p id="724c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这肯定是可行的，但不是通用的。我们系统中的每个任务都将需要多个静态变量来帮助控制我们的流程。它很快就变得笨拙了。</p><h1 id="386d" class="ls lm in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">门的解剖</h1><p id="15fa" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">如果我们能就表示工作的有状态部分的接口达成一致，那就成功了一半。另一半是抽象所有那些讨厌的静态变量…</p><p id="43b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">介绍<code class="fe kz la lb lc b">Gate</code>！</p><p id="cfe1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一个门描述了一系列由一个条件控制的相关任务。门的界面看起来像这样:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="6303" class="ll lm in lc b gy ln lo l lp lq">pub trait Gated {<br/>    fn new() -&gt; Self;<br/>    fn when(&amp;mut self, cond: CondFn, then: ExecFn) -&gt; &amp;mut Self;<br/>    fn when_ms(&amp;mut self, then: ExecFn) -&gt; &amp;mut Self;<br/>    fn once(&amp;mut self, then: ExecFn) -&gt; &amp;mut Self;<br/>    fn build(&amp;mut self) -&gt; Gate;<br/>    fn process(&amp;mut self);<br/>}</span><span id="eacd" class="ll lm in lc b gy lr lo l lp lq">pub struct Gate {<br/>    pub conditions: Vector::&lt;CondFn&gt;,<br/>    pub functions: Vector::&lt;ExecFn&gt;,<br/>    pub durations: Vector::&lt;u64&gt;,<br/>    pub target_times: Vector::&lt;u64&gt;,<br/>    pub current_index: usize,<br/>    pub tail: usize,<br/>    pub built: bool,<br/>}</span></pre><p id="3fff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您熟悉设计模式，您可能会认为这是构建器模式。该特性允许我们将多个逻辑块链接在一起。如果用下面的设计原则来实现这个接口，你将会有一个更清晰的机制来表示连接的工作单元。</p><p id="4c03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">浇口设计原则</strong></p><ul class=""><li id="6525" class="mu mv in kb b kc kd kg kh kk mw ko mx ks my kw mz na nb nc bi translated">当条件不满足时，一个门必须让步。</li><li id="ec10" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">当条件满足时，闸门将只运行一次伴随的工作功能<em class="ky"/>。</li><li id="c299" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">门的后续调用将不会重新运行任何已经处理过的代码块。</li><li id="12c5" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">大门可以用链子拴在一起，类似于<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>。</li><li id="832e" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">一旦按顺序调用了每个门，整个流程将被重置。</li></ul><h1 id="7638" class="ls lm in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">履行</h1><p id="6be6" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">我决定使用Rust宏来实现gates，这给了我们一个独特的机会来围绕给定的语句注入代码。使用这个语言特性，我们面临的挑战是编写一些在<code class="fe kz la lb lc b">loop { }</code>中稳定的东西，并且可以为任何创建的离散门执行。</p><p id="58cd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您能够以某种方式获得一个表示门的惟一散列，那么下面的伪代码将是任何门提供机制都可以遵循的合理模板:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="67a3" class="ll lm in lc b gy ln lo l lp lq">static mut SYSTEM_GATES: BTreeMap&lt;u32, Gate&gt; = BTreeMap::new();</span><span id="9374" class="ll lm in lc b gy lr lo l lp lq">loop {<br/>   // Given a unique identifier that describes a block of code...<br/>   let id: u32 = code_hash();<br/>   let gate: Gate = unsafe { SYSTEM_GATES.get(id) };</span><span id="21c8" class="ll lm in lc b gy lr lo l lp lq">   match gate {<br/>       None =&gt; {<br/>           // Create gate and add it to the SYSTEM_GATES static<br/>       },<br/>       Some(gate) =&gt; {<br/>           // Process gate<br/>       }<br/>   }<br/>}</span></pre><p id="9ce0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里有一个灾难性的警告:Rust不支持反射。暂且把它放在一边，让我们来探索一下宏可能是什么样子的。</p><p id="5f85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个宏中，我们只需查找gate是否存在，然后返回一个闪亮的新gate——或者存储的实例。这个宏的酷之处在于它在门之前注入代码<em class="ky">。这是一个重要的特性，我稍后会谈到。</em></p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="bfe4" class="ll lm in lc b gy ln lo l lp lq">#[macro_export]<br/>macro_rules! gate_open {<br/>    ( $( $x:expr ),* ) =&gt; {<br/>        {<br/>            // Get the hash of the gate in question<br/>            let id = code_hash();<br/>            let current_node = unsafe { GATES.get(id) };<br/>            let result: &amp;mut Gate;<br/>            <br/>            // Determine if the gate already exists, or if we need to make it<br/>            match current_node {<br/>                None =&gt; {<br/>                    // Let's create a new gate.<br/>                    let new_gate = crate::mem::alloc::&lt;Gate&gt;();<br/>                    unsafe { *new_gate = Gate::new(); }</span><span id="7476" class="ll lm in lc b gy lr lo l lp lq">                    // This new gate is what we'll return<br/>                    result = unsafe { &amp;mut (*new_gate) };</span><span id="2ef6" class="ll lm in lc b gy lr lo l lp lq">                    // Insert the gate in the global gate register<br/>                    unsafe { GATES.insert(id, new_gate as u32) };<br/>                },<br/>                Some(gate) =&gt; {<br/>                    result = unsafe { (gate as *mut Gate).as_mut().unwrap() };<br/>                }<br/>            }</span><span id="bbe8" class="ll lm in lc b gy lr lo l lp lq">            result<br/>        }<br/>    };<br/>}</span></pre><p id="3443" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我不会详细介绍构建器实现内部的内容，但从较高的层面来看，它是这样工作的:</p><p id="1c72" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每次你添加一个组件到gate中，<em class="ky">条件</em>被存储在<em class="ky">条件</em>向量中，<em class="ky">工作函数</em>被存储在<em class="ky">函数</em>向量中，就这样。下面是一些演示代码:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="e99c" class="ll lm in lc b gy ln lo l lp lq">pub fn when(&amp;mut self, cond: CondFn, then: ExecFn) -&gt; &amp;mut Self {<br/>    if self.built {<br/>        return self;<br/>    }</span><span id="52cd" class="ll lm in lc b gy lr lo l lp lq">    self.conditions.add(cond);<br/>    self.functions.add(then);<br/>    self.tail += 1;<br/>    return self;<br/>}</span><span id="dc07" class="ll lm in lc b gy lr lo l lp lq">pub fn build(&amp;mut self) -&gt; Gate {<br/>    if self.built {<br/>        self.process();<br/>    } else {<br/>        self.compiled = true;<br/>    }<br/>    return *self;<br/>}</span></pre><p id="ee11" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">秘制酱在<code class="fe kz la lb lc b">build()</code>法里。如果大门已经建好，那么<code class="fe kz la lb lc b">build()</code>将只是代理<code class="fe kz la lb lc b">process()</code>。这样，任何后续的构建gate的尝试都会导致运行它。</p><h1 id="93a6" class="ls lm in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">代码散列()</h1><p id="ea78" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">所有这些代码看起来都很棒，但是它基于一个根本不存在的语言特性。你如何得到一个函数的唯一散列，它在<code class="fe kz la lb lc b">loop { }</code>中是稳定的？没有这一块，整个事情就崩溃了。</p><p id="6991" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，永远不要让语言限制成为美丽代码的绊脚石！</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="b4af" class="ll lm in lc b gy ln lo l lp lq">/// This function returns a u32 containing the<br/>/// program counter of the line of code which<br/>/// invokes this function.<br/>pub fn code_hash() -&gt; u32 {<br/>    let result = 0;<br/>    unsafe {<br/>        asm!("mov r0, lr");<br/>    }<br/>    return result;<br/>}</span></pre><p id="f7fb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我的抵抗计划。</p><p id="a90d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为rust宏允许我们在函数调用周围注入代码<em class="ky">，这意味着在调用<code class="fe kz la lb lc b">Gate()</code>构造函数之前<a class="ae kx" href="https://en.wikipedia.org/wiki/Program_counter" rel="noopener ugc nofollow" target="_blank">程序计数器</a>将是唯一的。但是因为我们在一个循环中运行所有这些——它将在迭代中保持一致。</em></p><p id="4365" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">换句话说，调用gate构造函数的代码行对于每个gate都是不同的。但是它永远不会在应用程序循环的迭代之间改变。使用这个绝对值，我们可以得到令人垂涎的唯一散列值，这是将整个解决方案整合在一起所必需的。</p><h1 id="49e4" class="ls lm in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">包扎</h1><p id="5460" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">我的目标是让编写高效的裸机代码变得极其简单，让代码自动产生处理能力，而无需再考虑它。这个<em class="ky">门</em>的概念已经在我的内核项目中看到了价值。然而，也有一些限制:</p><ul class=""><li id="a48f" class="mu mv in kb b kc kd kg kh kk mw ko mx ks my kw mz na nb nc bi translated">两个匿名函数相邻的语法让我很困扰。</li><li id="379e" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">该门引入了一些感觉不必要的额外周期。</li><li id="04de" class="mu mv in kb b kc nd kg ne kk nf ko ng ks nh kw mz na nb nc bi translated">对于极其复杂的时序(比如为WS2812b LEDs编写驱动程序)，我发现gates不够强大。</li></ul><p id="6903" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也就是说，我可以看到这个概念从根本上提供价值的世界。我希望很快发布一个板条箱版本。</p><p id="dbe2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你想看我完整的<code class="fe kz la lb lc b">gate_open!()</code>原型，请随意<a class="ae kx" href="https://github.com/SharpCoder/teensycore/blob/main/src/gate.rs" rel="noopener ugc nofollow" target="_blank">探索代码</a>。发表这篇文章后，情况可能会有所改变，但情绪会是一样的。</p></div></div>    
</body>
</html>