<html>
<head>
<title>Why Software Design?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是软件设计？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-software-design-3a147f37f18b?source=collection_archive---------5-----------------------#2022-09-17">https://blog.devgenius.io/why-software-design-3a147f37f18b?source=collection_archive---------5-----------------------#2022-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="36e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几周里，我在不同的对话中，人们基本上都在说软件设计是一种浪费时间的行为。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0c65238f78d090908916da0a24ba4dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuYS7Yp4WZ3O0QqO1tn7sg.jpeg"/></div></div></figure><blockquote class="kx ky kz"><p id="5549" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">“让它工作，让它正确，让它快。”<br/> <a class="ae le" href="https://quotefancy.com/quote/1663435/Kent-Beck-Make-it-work-make-it-right-make-it-fast" rel="noopener ugc nofollow" target="_blank">肯特·贝克</a></p></blockquote><p id="540f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这句话中有一个顺序，这个顺序非常重要，但是除了顺序，我们必须做三件事。</p><h2 id="be6a" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">使其工作</h2><p id="3b07" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这意味着创建一个软件来解决我们想要解决的问题，不多也不少。在这段时间里，我们只需要专注于解决这个问题。</p><h2 id="a671" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">做正确的事</h2><p id="57b3" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这就是设计，所以应用所有我们知道的原则会对我们有帮助。试图检测我们代码中的问题，这些问题会降低我们修改和维护代码的能力。不是添加更多的功能，不是添加我们不需要的东西，而是使用我们已经创建的代码并对其进行改进。</p><h2 id="274b" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">动作快点</h2><p id="afbf" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在解决问题之后，优化是最后一件要做的事情，而不是第一件，因为当你知道什么样的优化能更好地改善你的系统时，就必须进行优化。</p><p id="8118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在我看来，我们正在努力做这样的事情:</p><ul class=""><li id="58ac" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">在问题中思考</li><li id="12a2" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">密码</li><li id="0520" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">设计</li><li id="b67c" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">使最优化</li><li id="53fb" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">回去想想</li></ul><p id="0872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个或长或短的反馈循环，取决于要解决的问题有多大。因此，提高这种循环频率的一个好策略是试图解决一个小问题，而不是大问题。<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157"> TDD </a>可以帮助你更好地理解如何按照这个方法做<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/a-lot-of-tiny-steps-16eaac27acb4?sk=3aaec6e2fd13f9710ecce4935c2189bc">小步骤</a>。</p><p id="740b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们能够从一个小问题开始，解决我们大问题的一些场景，我们可以迭代它，增加复杂性，我们将能够以迭代的方式解决整个问题。<br/>这和:<br/> <a class="ae le" href="https://www.forbes.com/sites/chunkamui/2019/01/02/6-words-to-remember-in-2019-think-big-start-small-learn-fast/?sh=6f298bf05f17" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">“大处着眼，小处着手，学得快</strong>”</a></p><p id="3a1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的设计将随着我们试图解决的每一个更困难的问题而成长。我们将针对我们正在解决的小问题进行优化，不多也不少。</p><p id="c87e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如何将这些问题以及如何从简单到复杂地排序来做。更简单的问题是我们的问题的一个非常简单的场景，其中要求不太严格。<br/>如果我想创建一个书店，我不需要开始思考我将拥有每秒成千上万的用户。很可能一开始很少有人会使用我的书店，即使你可以使用这个策略来获得反馈。利用你的朋友来测试，并从你的书店得到反馈。<br/>那为什么一开始要在意用什么数据库呢，让我们用任何能帮我解决问题的人。<br/>在这种情况下，我的代码需要允许我在学到更多知识时更改 DB，并且我对不久的将来的性能需求有了更好的了解。<br/>所有这些都将缩短投入生产的时间，缩短从用户那里获得反馈并向他们学习的时间。</p><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果一切都与我的数据库相结合，我将不能轻易改变它。如果我的所有代码都直接使用与我的数据库类型相关的代码，我将被我的数据库绑架。这就是耦合。</p><h2 id="4a1a" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">连接</h2><p id="1e72" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae le" href="https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/" rel="noopener ugc nofollow" target="_blank">耦合是模块之间相互依赖程度的度量。</a></p><ul class=""><li id="cf56" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">数据耦合</strong>:如果模块之间的依赖关系是基于它们只通过传递数据来进行通信，那么这些模块就被称为是数据耦合的。在数据耦合中，组件相互独立，并通过数据进行通信。模块通信不包含 tramp 数据。示例-客户计费系统。</li><li id="435c" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">印记耦合:在印记耦合中，完整的数据结构从一个模块传递到另一个模块。因此，它涉及到不定期数据。由于效率因素，这可能是必要的，这个选择是由有洞察力的设计者做出的，而不是懒惰的程序员。</li><li id="87c0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">控制耦合:如果模块通过传递控制信息进行通信，那么它们被称为是控制耦合的。如果参数指示完全不同的行为，这可能是不好的；如果参数允许分解和重用功能，这可能是好的。将比较函数作为参数的示例排序函数。</li><li id="3d63" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">外部耦合:在外部耦合中，模块依赖于正在开发的软件或特定类型硬件外部的其他模块。Ex 协议、外部文件、设备格式等。</strong></li><li id="8e92" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">公共耦合:模块共享数据，比如全局数据结构。全局数据的变化意味着追溯到访问该数据的所有模块，以评估变化的影响。因此，它有很多缺点，如模块重用困难，控制数据访问的能力降低，可维护性降低。</li><li id="f38b" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">内容耦合:在内容耦合中，一个模块可以修改另一个模块的数据，或者控制流从一个模块传递到另一个模块。这是最糟糕的耦合形式，应该避免。</li></ul><p id="2ca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">耦合就像重力一样，是一种对抗变化的巨大力量。</p><p id="fe8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是针对您的数据库，而是针对您的任何基础设施(考虑您无法控制的基础设施、库、框架、外部服务等)。如果你的业务代码完全被你的基础设施所感染，你的代码会和很多东西联系在一起，这意味着很难改变。</p><p id="1ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/evolutionary-design-an-example-d9889a262e3d?sk=8cfb8b20335ca39f6f0ce84b8cbc73e6">为了改进我的设计，改进我的架构，我需要在我的设计中牢记这一点。</a> <br/>我需要减少我的外部耦合，或者至少命名我的代码中耦合到外部模块的部分，以了解我改变 DB(或任何其他基础设施的东西)的工作量。<br/>这不仅仅是创建一些接口，你还需要考虑数据耦合。如果在那些外部模块和你的内部模块之间，你的代码使用相同的数据结构(数据耦合)，那么你的代码就是高度耦合的。<br/>有人为此使用<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/the-whys-of-hexagonal-architecture-1ccca8476c86?sk=8d8e99e381ae473c001fd80c348fa5f8">六边形架构</a>。</p><h2 id="afa6" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">设计，我不在乎</h2><p id="68bb" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">还有一种倾向，认为设计是死的，我们只是专注于使事情工作。就算你不在乎设计，你也在设计。如果你有一个类或者一个模块有大量的依赖项，你就把这个类和所有的依赖项耦合起来。如果依赖关系发生变化，你的类也必须改变，如果你没有创建正确的接收器，你的类中耦合的任何东西都会改变。旨在阻止滚雪球效应，以避免重写整个应用程序。</p><p id="9af6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不需要通过创建对你现在的问题无用的结构来预测未来，但是你必须创建一些东西来减少你的代码的读者的认知负荷。</p><p id="8619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件设计应该考虑到未来开发人员对代码的可维护性。并非所有的设计都是一样的，你必须为简单而设计，但这并不容易，而且这通常不是你对一个问题的第一反应。</p><p id="d46c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单设计的四个规则可以帮助你:</p><ul class=""><li id="47ad" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">通过测试</li><li id="dfb5" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">揭示意图(应该容易理解)</li><li id="9846" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">无重复(干)</li><li id="79ae" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">最少的元素(删除任何不符合前面三个规则的元素)</li></ul><p id="657d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我不喜欢<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/why-i-dont-like-the-builder-pattern-e05423698a9a?sk=ab3e214029e33109be6c2157f66b5dfa"> Builder </a>模式的原因之一，因为它违背了“低耦合”<a class="ae le" href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Low_coupling" rel="noopener ugc nofollow" target="_blank"> GRASP </a>原则。<br/>抱歉，我会更好地解释我自己，我并不反对构建器模式，它有空间，但我不喜欢人们如何使用它。构建器模式不是为了隐藏一个在构造器中有太多参数的类。这是为了解决一个有可选和非可选参数的类的问题，你不能为所有情况创建大量的构造函数。</p><h2 id="7618" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">我不知道如何设计</h2><p id="c0eb" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">答案是努力学习，软件设计是巨大和困难的，因为你必须理解你的问题的权衡和软件设计原则的权衡。</p><p id="d499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我解释了我在日常工作中尝试使用的软件设计原则:<br/><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/software-design-principles-ccc3913bfd56?sk=072f3a4d996bfd3106e1583f8f667fa8">https://blog . dev genius . io/software-design-principles-CCC 3913 bfd 56？sk = 072 F3 a4 d 996 bfd 3106 e 1583 f8f 667 fa 8</a></p></div></div>    
</body>
</html>