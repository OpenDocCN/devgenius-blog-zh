<html>
<head>
<title>A Performance Analysis of C and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C和Go的性能分析</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-performance-analysis-of-c-and-go-82a378be8c87?source=collection_archive---------3-----------------------#2021-12-15">https://blog.devgenius.io/a-performance-analysis-of-c-and-go-82a378be8c87?source=collection_archive---------3-----------------------#2021-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2eaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们探讨了C和Go这两种世界上最流行的编程语言的区别、相似之处和用例。c是有史以来最广泛使用的编程语言之一。Go是一种<em class="ki"> n开源编程语言，可以轻松构建简单、可靠、高效的软件</em>。<em class="ki">从这两者的快速比较开始，然后看看它们在可读性、速度、易学性等方面的表现如何。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/848990d57d9556e298fab54e5d55eb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOJx3gb3kF0AOs9zFLIaQg.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">信用:<a class="ae kz" href="https://careerkarma.com/blog/go-vs-c-plus-plus/" rel="noopener ugc nofollow" target="_blank">卡雷卡尔马</a></figcaption></figure><h1 id="defc" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍</h1><p id="7fa2" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在本文中，我们使用Go和C语言实现了Peter Pacheco 所著的《并行编程入门》一书第6章中描述的旅行售货员问题(TSP)算法的并行版本。这个问题寻求确定穿过一系列城市的最短路线。(每个人只拜访一次)，回到原来的城市。这是一个<a class="ae kz" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP-hard </a></p><p id="827c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两个系统都从进程0开始读取实例，并将其传播给所有其他系统。所有进程必须复制广度搜索的开始，然后致力于探索一个子树。我们的程序应该静态地在具有全局最佳路由更新的进程之间划分工作。为了比较所实现算法的性能，我们测量了每个进程中2或4个线程的执行时间。最后，我们使用已知的TSP场景来比较实现的性能。重要的是要说，这篇文章比较的是C和逆天一个具体算法的性能。性能测试不应该这样进行。</p><h1 id="891d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Go中的实现</h1><p id="af2a" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">Go(也称为Golang)是由Google的工程师设计的，他们希望这种语言能够提供C++的效率，但更容易学习、编写、阅读和部署。该语言的<a class="ae kz" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> Goroutines </em> </a>使开发人员可以轻松构建充分利用并发性的应用，例如通过同时在多个CPU内核上部署工作负载来构建主要的电子商务网站。换句话说，非常适合并行计算环境。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi md"><img src="../Images/dd9c1c0d591b467334cb9851bb98fd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k1jQBcMtXf8Swv_7.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">学分:<a class="ae kz" href="https://softensy.com/is-go-the-best-programming-language-for-finance-best-practices-and-our-expertise/" rel="noopener ugc nofollow" target="_blank">柔化</a></figcaption></figure><p id="8e12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的程序使用分支定界法来解决这个问题。这意味着每个实例都包含一条路径、已经通过的边数以及以该路径为起点的往返行程的最小开销。这些实例在一个优先级队列中进行管理，该队列目前被实现为一个基于数组的二进制堆。我们使用<em class="ki"> Goroutines </em>来并行执行线程。这个想法是，我们将同时能够更快地达到理想的解决方案。扩展一个实例，生成给定路径的所有可能范围，添加所有可用的边，重新计算边界，最后将这些实例插回到堆中。为了防止队列中出现竞争情况，我们使用同步互斥体。这是一种用作锁定机制的方法，以确保在任何时候只有一个<em class="ki"> Goroutine </em>可以访问代码的临界区。</p><p id="14d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们解决这个问题的方法是使用下界。我们计算一个值，该值表示具有某个子路径的每个可能路径的确定的最小长度。为此，我们首先计算每个顶点的输出边的最低权重。现在我们可以把所有这些加在一起。我们可以对输入边做同样的事情。因为这两个值是最短路径长度的确定下限，所以我们只需要考虑较高的值。</p><p id="bb51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在有了第一个子路径。它只包含一个顶点，没有边。该路径可以被最后访问的节点(目前唯一的一个)的所有邻居扩展。我们现在最多创建n-1个<strong class="jm io"><em class="ki"/></strong>新候选人。对于所有这些，我们可以再次计算最终的下限。唯一的区别是，在这一点上，我们有一个已知输出权重的节点和一个已知输入权重的节点。</p><p id="bc58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这个决定可以改变下限，我们现在可以选择最小成本最低的候选。如果有两个候选具有相同的阈值但不同的长度，我们选择较短的一个，因为访问的节点越多意味着阈值更可能是实际的最终值。</p><p id="e087" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某一点上，我们最终会得到一个恰好有n条边的“候选项”,它的代价至多等于另一个候选项的下界。所以没有其他更短的路径。你可以通过这个<a class="ae kz" href="https://github.com/matheusroleal/tsp-golang" rel="noopener ugc nofollow" target="_blank"> repo </a>访问完整的实现。</p><h1 id="a2d9" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用C实现</h1><p id="ce1c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">c是一种通用的高级语言，最初是由Dennis Ritchie为Unix操作系统开发的。它是一种通用的、过程化的计算机编程语言，支持结构化编程、词法变量范围和递归，具有静态类型系统。由于各种原因，c语言现在已经成为广泛使用的专业语言。通过设计，它提供了有效映射到典型机器指令的结构。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8285744c6f2ec5b2a61638a9bdbf5d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*L3rqgl63o5bvclwL"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">演职员表:<a class="ae kz" href="https://www.quora.com/Why-should-we-learn-C-in-2021-1" rel="noopener ugc nofollow" target="_blank"> Quora </a></figcaption></figure><p id="164a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的来说，实现遵循了彼得·帕切科在参考书中建议的途径。只修改了几个部分。其中之一是在算法开始时，进程0需要将问题数据发送给其他进程。我们最终以稍微不同的方式解决了这个问题。我们没有将整个图矩阵发送给其他流程，也没有在宽度方向上重复搜索以在每个流程中生成任务，而是选择在初始流程中进行搜索和划分。在为每个进程生成每个任务堆栈后，主进程只发送生成的堆栈，其他进程在收到现成的堆栈后很快就开始在堆栈上工作。这些进程通过MPI进行通信，在每个进程中，我们通过<a class="ae kz" href="https://man7.org/linux/man-pages/man7/pthreads.7.html" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> pthreads </em> </a>使用线程。在这些线程之间，我们有一个动态的工作平衡，使用书中描述的策略。</p><p id="ab8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至于在宽度上的搜索和任务本身的划分，我们遵循书中建议的逻辑，生成任务并将它们放入队列中，直到我们到达树的一个级别，该级别有几个生成的任务大于进程的数量。这个函数也在每个进程中重复，为每个线程生成不同的任务堆栈。</p><p id="c0c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">准备好每个进程中每个线程的所有堆栈后，算法开始并行运行。我们有一个角色，负责生成新的旅程，并将它们与迄今为止找到的最佳旅程进行比较。它还执行进程间的动态平衡策略，检查进程是否在等待新任务，并在必要时划分堆栈。</p><p id="0a28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，在每个线程和每个进程完成它的搜索之后，制定归约策略来找出哪个线程具有最低的旅行成本。我们还遵循书中的建议，使用<em class="ki"> MPI_Allreduce </em>操作符来查找具有最佳旅程的流程，然后该流程将有问题的旅程发送到主流程，主流程打印在最终确定算法的屏幕上。这个<a class="ae kz" href="https://github.com/matheusroleal/tsp-mpi" rel="noopener ugc nofollow" target="_blank">库</a>包含了问题的完整实现。</p><h1 id="12d8" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">技术性能分析</h1><p id="1fc7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">一些<a class="ae kz" href="https://people.sc.fsu.edu/~jburkardt/datasets/tsp/tsp.html" rel="noopener ugc nofollow" target="_blank">网页</a>有众所周知的TSP的测试文件。我们使用其中一个站点进行测试。我们注意到，当测试有许多实例的场景时，解决这些问题很快变得非常耗时。我们使用一个5个城市的场景作为我们的起点，然后扩展到15个城市，看看一个稍微复杂一点的场景。正如我们在下面的结果中看到的，Go中的实现比c中的实现获得了更好的结果。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mf"><img src="../Images/80eba4a4c152fda4792e77c84a085f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsXIRM3FDLJ96wM4Qg2Zfw.jpeg"/></div></div></figure><p id="a40c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在Go中的第一个实现比在c中的算法性能差3倍。在快速搜索中，可以找到证明这种差异与像Go这样的语言的<a class="ae kz" href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>特性的分析。这个分析很浅薄。垃圾收集通常只占总运行时间的很小一部分，还有一些间接和相关的事情。垃圾收集语言试图成为内存安全的语言，所以当编译器不能证明它们可以被省略时，它们也倾向于进行数组边界检查。他们也倾向于不允许同样多的<a class="ae kz" href="https://www.javatpoint.com/kotlin-smart-cast" rel="noopener ugc nofollow" target="_blank">智能造型</a>，也倾向于不允许<a class="ae kz" href="http://ibm.com/docs/en/i/7.2?topic=pointers-pointer-arithmetic" rel="noopener ugc nofollow" target="_blank">算术指针</a>。</p><p id="27db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">波格丹一世·温古雷亚努回复了这篇文章，告诉我们这个问题可能与使用同步有关。Mutex而不是sync.RWMutex。正因为如此，所有goroutines都将处于锁定模式，不管你是在读还是写。多亏了他的拉请求，Go中的实现得到了更新，得到了更好的结果。</p><h1 id="7f63" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="5201" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们能够使用Go和C语言实现Peter Pacheco所著的《并行编程入门》一书第6章中描述的旅行推销员问题(TSP)算法的并行版本。通过从互联网上获得的一些场景，我们能够比较这两种解决方案的性能。正如我们在结果中看到的，Go中的实现比c中的实现获得了更好的结果，需要强调的是，本文的目的是进行快速比较。c语言是我们最擅长的语言，这可能会影响所获得的结果。对于未来的工作，除了在具有更大计算能力的专用机器上运行更复杂的场景之外，我们还将尽可能地实现这些算法。</p></div></div>    
</body>
</html>