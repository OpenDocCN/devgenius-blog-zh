<html>
<head>
<title>An Introduction to Dynamic Programming through the Fibonacci Sequence, Memoization, and Tabulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过斐波纳契数列、记忆和制表介绍动态规划</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-introduction-to-dynamic-programming-through-the-fibonacci-sequence-memoization-and-tabulation-67a8624be61a?source=collection_archive---------2-----------------------#2020-09-02">https://blog.devgenius.io/an-introduction-to-dynamic-programming-through-the-fibonacci-sequence-memoization-and-tabulation-67a8624be61a?source=collection_archive---------2-----------------------#2020-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5aa4484a5e6e4758b2fa29c701ad7619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c7AlZLTI-OXQexDv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">罗斯·斯奈登在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我一直在学习算法和数据结构，同时努力准备技术面试。有些事情来得容易，但我总是喜欢好的挑战。我喜欢白板上的问题，感觉就像一个你很快就能拼起来的拼图。在某个时候，它会在你的大脑中一闪而过，你就知道你需要做什么了。例如，我真的很喜欢我的第一个使用斐波那契数列的问题。如果您不熟悉，一般的斐波那契问题可能是这样的:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7f2d" class="lk ll iq lg b gy lm ln l lo lp">You have an array with the following values: <br/>array = [0,1,1,2,3,5,8,13,21,34]</span><span id="4037" class="lk ll iq lg b gy lq ln l lo lp">Given any index, n, determine what the value at that index in the array would be, array[n].</span></pre><p id="a500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当时，我没有接触过这个序列，所以这个问题对我来说很难解决。挑战结束后，我想更好地理解序列的解决方案。经过一番练习，我得出了以下结论:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8f0e" class="lk ll iq lg b gy lm ln l lo lp">The relationship between values in the array is:<br/>array[n] = array[n-1] + array[n-2]</span><span id="845b" class="lk ll iq lg b gy lq ln l lo lp">function fibonacci(n){<br/>   if(n &lt;= 2) return 1<br/>   return fibonacci(n-1) + fibonacci(n-2)<br/>}</span></pre><p id="b59a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对这个解决方案很满意。它对我来说是有意义的，通过了我的测试，并利用了我刚刚学到的递归(如果你想重温递归，请查看我的博客文章<a class="ae kc" href="https://medium.com/dev-genius/an-introduction-to-recursion-in-programming-b38f25bee843" rel="noopener">这里</a>)。后来，我意识到我的解决方案有问题。如果我用大于35的数字运行我的解决方案，它需要一段时间来返回值，如果我用大于50的数字运行它，它会冻结我的计算机或使应用程序崩溃。发生了什么事？这个解决方案的时间复杂度非常高。这是O(2^n).因此，随着我的输入增加，我的计算机必须做的工作量也呈指数增长。我必须以某种方式降低时间复杂度。这是我了解动态编程的时候。</p><p id="aa97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态规划是一种问题解决方法，它利用重叠子问题和最佳结构来减少解决问题所需的时间或工作量。它优化了解决方案。这如何适用于斐波那契？嗯，斐波那契问题有最优结构和重叠的子问题，因为相同的输入应该总是给出相同的结果，而且有重复的子问题。例如，fibonacci(6)将始终返回8。但是看看这是如何通过我的递归函数计算出来的:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f241" class="lk ll iq lg b gy lm ln l lo lp">fib(6) =<br/>fib(5) + fib(4) = <br/>fib(4) + fib(3) + fib(3) + fib(2) = <br/>fib(3) + fib(2) + fib(2) + fib(1) + fib(2) + fib(1) + 1 =<br/>fib(2) + fib(1) + 1 + 1 + 1 + 1 + 1 + 1 =<br/>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 =<br/>8</span></pre><p id="37b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个问题。给定相同的输入，序列将总是返回相同的数字，那么为什么我让我的计算机运行fib(4)两次，fib(3)三次，fib(2)四次呢？6是一个很小的输入，你能想象如果我最初的输入是fib(30)我会让我的计算机运行fib(3)多少次吗？我们是程序员，我们不喜欢在代码中重复自己，也不喜欢重复工作。</p><p id="646e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入记忆化。不是“记忆”。这是我最初的假设，但这并不是一个可怕的思考方式。你是在‘记忆’你已经运行过的输入的返回值，这样，如果你的计算机试图第二次计算fib(4 ),就像你输入fib(6)时一样，你阻止了它再次递归分解它，并且只是说“嘿，你已经这样做了！答案是3记住！?"。</p><p id="eaa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你必须记住，你的电脑不是魔术。它一次计算一个fib(n)调用<strong class="kf ir">的答案</strong>。所以，不像上面的代码片段，我们是按行从左到右读的，你的计算机更多的是按列工作。它不会寻找下一个fib(n)调用，直到它对第一个调用有了明确的答案。让我试着想象一下。如果你调用fib(6 ),下面是你的计算机将按照它的调用栈的顺序运行的内容，其中<strong class="kf ir">粗体</strong>函数是你的计算机运行的下一步，在下一行:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d68a" class="lk ll iq lg b gy lm ln l lo lp">fib(6) = <strong class="lg ir">fib(5)</strong> + fib(4)<br/>fib(5) = <strong class="lg ir">fib(4) </strong>+ fib(3)<br/>fib(4) = <strong class="lg ir">fib(3)</strong> + fib(2)<br/>fib(3) = <strong class="lg ir">fib(2)</strong> + fib(1)<br/>fib(2) = 1 //YAY we removed a fib call from the stack and bubble up<br/>fib(3) = 1 + <strong class="lg ir">fib(1) //</strong>we now get to run the 2nd fib call from here<strong class="lg ir"><br/></strong>fib(1) = 1 //another fib call done, we bubble up again!<br/>fib(3) = 1 + 1 = 2 //Now those first 2 calls let us finish this call<br/>fib(4) = 2 + <strong class="lg ir">fib(2) //</strong>We solved fib(2) before but are doing it again<br/>fib(2) = 1 //same answer we got last time we did fib(2)<br/>fib(4) = 2 + 1 = 3 //and now we bubble up again to finish this call<br/>fib(5) = 3 + <strong class="lg ir">fib(3) //</strong>we already solved fib(3) once! Why again?!<br/>fib(3) = <strong class="lg ir">fib(1)</strong> + fib(2) //See how repetitive this is?<br/>fib(1) = 1 //same solution we got the first time<br/>fib(3) = 1 + <strong class="lg ir">fib(2) </strong>//have I made my point yet?<br/>fib(2) = 1 //This isn't new information<br/>fib(3) = 1 + 1 = 2 //yep, fib(3) still equals 2<br/>fib(5) = 3 + 2 = 5 //Finally finish 1/2 of the original problem<br/>fib(6) = 5 + <strong class="lg ir">fib(4) </strong>//you've got to be kidding me...<br/>fib(4) = <strong class="lg ir">fib(3)</strong> + fib(2) //we could've finished this a long time ago<br/>fib(3) = <strong class="lg ir">fib(1)</strong> + fib(2) //all of this is not fun to write out<br/>fib(1) = 1 //We meet again fib(1)<br/>fib(3) = 1 + <strong class="lg ir">fib(2) </strong>//this is the 4th time we are doing fib(2)<br/>fib(2) = 1 //who would've thought!? (sarcasm)<br/>fib(3) = 1 + 1 = 2 //dejavu<br/>fib(4) = 2 + <strong class="lg ir">fib(2) </strong>//Yeah sure, a 5th time for good measure<strong class="lg ir"><br/></strong>fib(2) = 1 //I genuinely hope all this is helpful to you<br/>fib(4) = 2 + 1 = 3<br/>fib(6) = 5 + 3 = 8 //FINALLY WE HAVE AN ANSWER</span></pre><p id="9b80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，我们的fib(6)调用使我们的计算机运行fib(n) 15次，而这些fib(n)调用中只有6次是唯一的！如果我们能够记忆，我们就可以大大减少工作量，跳过几乎每一个重复的谎言:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="986e" class="lk ll iq lg b gy lm ln l lo lp">fib(6) = <strong class="lg ir">fib(5)</strong> + fib(4)<br/>fib(5) = <strong class="lg ir">fib(4) </strong>+ fib(3)<br/>fib(4) = <strong class="lg ir">fib(3)</strong> + fib(2)<br/>fib(3) = <strong class="lg ir">fib(2)</strong> + fib(1)<br/>fib(2) = 1 //lets remember that<br/>fib(3) = 1 + <strong class="lg ir">fib(1)<br/></strong>fib(1) = 1 //lets remember that too<br/>fib(3) = 1 + 1 = 2 //Cool, lets remember that as well<br/>fib(4) = 2 + <strong class="lg ir">fib(2) //</strong>oh yeah! fib(2) = 1<br/>fib(4) = 2 + 1 = 3 // sweet lets remember that<br/>fib(5) = 3 + <strong class="lg ir">fib(3) //</strong>oh yeah! fib(3) = 2<br/>fib(5) = 3 + 2 = 5<br/>fib(6) = 5 + <strong class="lg ir">fib(4) </strong>//oh yeah! fib(4) = 3<br/>fib(6) = 5 + 3 = 8 //DONE</span></pre><p id="3194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，通过记住我们的返回值，我们大大减少了调用fib(n)的次数。我们如何做这样的事情？我们如何使用记忆化？我们通过递归调用持久化一个返回值数组，并且每次都检查这个数组，以查看我们之前是否已经解决了fib(n)。我们如何知道在数组中的哪里存储和检索我们的值呢？我们只是将fib(n)的答案存储在array[n]中。这是它的样子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3a94" class="lk ll iq lg b gy lm ln l lo lp">function fib(n, memo=[]){<br/>  if(memo[n] !== undefined) return memo[n];<br/>  if(n &lt;= 2) return 1<br/>  let num = fib(n-1, memo) + fib(n-2, memo)<br/>  memo[n] = num<br/>  return num<br/>}</span></pre><p id="f0a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事情是这样的。我们传入存储返回值的数组(称为“memo”表示“memoization”)，并默认它只在第一次调用时作为一个空数组。然后，我们检查我们的memo数组，看看我们是否已经在它的第n个位置存储了一个答案；如果是这样，我们就把它退回去。然后，如果n是1或2，我们返回1，就像我们最初做的那样。然后，我们像以前一样递归地调用fib(n-1)和fib(n-2 ),但是这一次，传递我们的持久memo数组，并将总和设置为一个变量。然后，我们将总和放在memo数组的第n个位置，并返回总和。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/627d60d4f7043ddff661e10e232b1a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pTqjbXuYWkdgyBvb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lukephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基思·卢克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="9e85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以使用这个解决方案，任何时候调用fib(n)而n已经被求解过一次，memo[n]将已经保存答案，并返回它，而不是继续递归调用fib(n-1) + fib(n-2)。这使得时间复杂度从O(2^n)降低到O(n ),这要好得多。这意味着以前fib(39)需要一分多钟才能解决的问题，现在只需要不到一秒钟！</p><p id="3920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要太早庆祝…继续尝试在<a class="ae kc" href="https://repl.it/languages/javascript" rel="noopener ugc nofollow" target="_blank"> repl.it </a>上运行fib(8349)。它会在不到一秒的时间内返回无穷大。所以时间很好，返回的数字并不理想，但是我们使用的是javascript，事实就是这样。真正的问题是当你把1加到n…运行fib(8350)，你得到:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="58c1" class="lk ll iq lg b gy lm ln l lo lp">RangeError: Maximum call stack size exceeded</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/51bfa46166c97c2c7aa3198dcc694f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9NFUdIkdWSt5Hh1g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@krisroller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯多佛罗拉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="2d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经典堆栈溢出。我们有太多的递归调用等待我们的堆栈，这是太多的处理。记忆化背叛了我们。经典的西斯复仇——“你应该是被选中的人”。</p><p id="3540" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没关系，来个‘制表’来化险为夷！制表是一个过程，在这个过程中，你将结果存储在一个表(通常是一个数组)中，同时进行迭代，而不是递归调用。这节省了空间复杂度并防止了堆栈溢出。它看起来是这样的:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d49a" class="lk ll iq lg b gy lm ln l lo lp">function fib(n){<br/>  if(n &lt;= 2) return 1<br/>  const fibNums = [0,1,1]<br/>  for(let i = 3; i &lt;= n; i++){<br/>    fibNums[i] = fibNums[i-1] + fibNums[i - 2]<br/>  }<br/>  return fibNums[n]<br/>}</span></pre><p id="e132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，不是将数组作为参数传递，而是在函数中紧接在边缘情况之后进行赋值。它用[0，1，1]初始化，因为我们知道这些值，我们需要给我们的循环一些东西来计算。在我们的循环中，我们从i = 3开始，因为我们已经填充了数组索引0–2。然后，当I小于<strong class="kf ir">或</strong> <strong class="kf ir">等于</strong> n时，我们运行循环。这是正确达到第n个值的关键。我们现在在循环中向上迭代，每次增加I，而不是递归分解。这确保我们不会重新计算任何值，并允许我们在O(n)时间内返回当前值，而不会导致堆栈溢出。所以我们现在可以毫无问题地运行fib(8350)。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="7b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们越来越擅长解决问题，我们能够识别模式，并轻松地提出自己的解决方案。我们也许能够写出一个通过所有测试用例的解决方案，但是作为程序员，这不是我们工作的终点。我们需要关心时间和空间的复杂性……这很复杂。尝试改进解决方案的时间复杂性的一个很好的方法是采用动态编程方法。在你的问题中寻找更小的问题。寻找重复的计算、循环和函数调用。尝试在递归工作时实现记忆化，或者在循环时实现列表化，并尝试提高你的BigO。平衡时间复杂度和空间复杂度之间的权衡，因为一个通常可以帮助另一个。我希望你和我一样对这些概念感兴趣，并且我希望下次你面对另一个算法时，它能激发出另一个灵感。感谢阅读！</p></div></div>    
</body>
</html>