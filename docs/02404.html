<html>
<head>
<title>JavaScript: Traverse Tree Recursively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:递归遍历树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-traverse-tree-recursively-2e525cb176e2?source=collection_archive---------1-----------------------#2020-08-02">https://blog.devgenius.io/javascript-traverse-tree-recursively-2e525cb176e2?source=collection_archive---------1-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1a396b9738cd02e9231a46fe7ac34f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N8dHLB4d1Xrl1l3M"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@niko_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> niko photos </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4e0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遍历树的能力是一个重要的基本概念。<a class="ae kc" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>是一种数据结构，其中包含一组具有分层模式的节点。每个节点都有自己的数据结构。树的结构有一个“根”节点，每个节点都有一个值和一个指向其子节点的引用。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/e39d64d69208936d774dd3e7dc20e795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrJfBlE1ir21Cizw9WSn7A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">以值2为根节点的树形数据结构示例。参考:<a class="ae kc" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Tree _(data _ structure)</a></figcaption></figure><p id="eb71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章中涉及的简单的树的概念是:</p><ol class=""><li id="05e4" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">伪经典实例化</a>模式构建一个树类</li><li id="88ce" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">创建一个向树中添加子节点的方法</li><li id="e623" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">深度优先递归遍历树</li><li id="54c9" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">创建一个map方法，使用递归返回一个与原始树结构相同但值不同(2种不同方式)的树</li></ol><p id="ba48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://javascript.info/recursion#:~:text=Recursion%20is%20a%20programming%20term,that's%20called%20a%20recursion%20step." rel="noopener ugc nofollow" target="_blank">递归</a>是一种解决问题的方法，函数在自己的代码中调用自己。原因是将更大、更复杂的问题分解成更容易解决的更简单的问题。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="fc2a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">构造一个树类和add方法，向树中添加子树</strong></h1><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="616b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简化的树，它接受一个值，并有一个子数组。此时<code class="fe nb nc nd ne b">root1</code>树看起来如下。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/495fd541bffa3cfc5d2e29cb51c57c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpTg0y3WxqsRCx8kSQ_wkg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">上面代码中的树形白板结构</figcaption></figure><h1 id="17d1" class="mb mc iq bd md me nf mg mh mi ng mk ml mm nh mo mp mq ni ms mt mu nj mw mx my bi translated"><strong class="ak">深度优先递归遍历树</strong></h1><p id="cc34" class="pw-post-body-paragraph kd ke iq kf b kg nk ki kj kk nl km kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">让我们实现一个简单的<code class="fe nb nc nd ne b">contains</code>方法来深度优先遍历树，看看目标值是否包含在树中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dcb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Contains方法有一个基本用例来检查当前节点的值是否等于传入的值参数。然后遍历节点的子节点，并递归遍历每个子节点，这导致树遍历深度首先继续检查这个基本情况。如果基本情况从未通过，contains方法将返回false。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="30b8" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">创建地图的方法</strong></h1><p id="4c66" class="pw-post-body-paragraph kd ke iq kf b kg nk ki kj kk nl km kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">Map方法将返回一个与原始树结构相同的新树，但是新树将具有与回调函数不同的值。另外，原始树不受影响。让我们来看看用递归来解决这个问题的两种不同的方法，可能还有很多其他的解决方法。</p><ol class=""><li id="e888" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">使用带有帮助函数的递归，并在树中创建整个原始文件的初始副本</li><li id="03cd" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">使用不带帮助函数的递归，并在遍历原始传入树时创建新的树实例和子树</li></ol><h1 id="ee93" class="mb mc iq bd md me nf mg mh mi ng mk ml mm nh mo mp mq ni ms mt mu nj mw mx my bi translated"><strong class="ak">让我们来图解第一个解决方案:</strong></h1><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a47f3706330c60df76214a0f09c228f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7m23u2ZiObSNGs0Lo4r9lA.png"/></div></div></figure><ol class=""><li id="9f85" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">为传入树中的原始文件创建一个副本(不仅仅是指针引用)</li><li id="9b82" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">通过使用带有帮助函数的递归遍历新复制的树。</li><li id="dcff" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">在遍历复制的树的过程中，对每个节点的值应用回调</li></ol><h1 id="26b6" class="mb mc iq bd md me nf mg mh mi ng mk ml mm nh mo mp mq ni ms mt mu nj mw mx my bi translated"><strong class="ak">让我们来图解第二个解决方案:</strong></h1><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/b4d85d398397ba0a07a4404b60707790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoRbIsjMflssRfc64Cxxqg.png"/></div></div></figure><p id="5b3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案在遍历原始传入树时创建新树。</p><ol class=""><li id="1bfb" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">使用应用回调的原始根节点值创建新实例</li><li id="7879" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">遍历原始树并将子节点(带有更新的值)添加到新的树实例中，以模拟原始树的结构。</li><li id="ec0e" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">遍历原始树时，确保新树的节点位置与原始树的节点位置相同，以保留原始树的结构。</li></ol><p id="1a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是图解解决方案的示例代码。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="8617" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是黑客反应堆训练营第四周的结束。在过去的一周里，我们集中讨论了函数模式、伪经典模式和ES6模式中的类继承和子类。我们还学习了如何:</p><ul class=""><li id="df52" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la nq lm ln lo bi translated">正确设置子类到超类的原型链委托</li><li id="26b0" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la nq lm ln lo bi translated">确定<code class="fe nb nc nd ne b">this</code>引用的是什么以及如何正确绑定<code class="fe nb nc nd ne b">this</code>,这对我来说仍然是模糊的</li><li id="f891" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la nq lm ln lo bi translated">使用对象继承创建不同的实例，并利用j Query、HTML和CSS来直观地显示这一点</li></ul><p id="5886" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，递归是一个我仍然试图掌握的概念，这让我写了一篇关于它的文章。希望这能对我和其他人有所帮助。</p></div></div>    
</body>
</html>