<html>
<head>
<title>Docking a Docker Container — Part 3 : Networking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对接码头集装箱第 3 部分:联网</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docking-a-docker-container-part-3-networking-edd779f068cb?source=collection_archive---------0-----------------------#2016-11-07">https://blog.devgenius.io/docking-a-docker-container-part-3-networking-edd779f068cb?source=collection_archive---------0-----------------------#2016-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><blockquote class="jr js jt"><p id="5901" class="ju jv jw jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">帮助弱者！打击网络犯罪<a class="ae kt" href="https://forms.gle/JWAPHzf2gd7jGq2YA" rel="noopener ugc nofollow" target="_blank">了解如何</a>。</p></blockquote></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="5d4b" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">在<a class="ae kt" href="https://medium.com/@tomdeore/docking-a-docker-container-part-2-c1206e7c6677#.emitlalza" rel="noopener">之前的</a>会话中，我们看到 namespace 和 cgroup 为容器运行创建了一个执行环境。将它们缝合在一起另一个重要部分是网络。当您实际部署您的生产应用程序时，它必须有多个容器，但是这些容器如何相互通信呢？容器框架的 IP 架构应该是怎样的？</p><h1 id="7303" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">docker 网络是如何工作的？</h1><p id="e473" class="pw-post-body-paragraph ju jv in jx b jy lv ka kb kc lw ke kf ku lx ki kj kv ly km kn kw lz kq kr ks ig bi translated">默认情况下，当您启动 docker 守护程序时，docker 会创建三个网络，即:</p><ol class=""><li id="5cb6" class="ma mb in jx b jy jz kc kd ku mc kv md kw me ks mf mg mh mi bi translated"><a class="ae kt" href="https://docs.docker.com/network/bridge/#:~:text=In%20terms%20of%20Docker%2C%20a,connected%20to%20that%20bridge%20network." rel="noopener ugc nofollow" target="_blank">桥</a>，</li><li id="5e24" class="ma mb in jx b jy mj kc mk ku ml kv mm kw mn ks mf mg mh mi bi translated">没有，</li><li id="a15d" class="ma mb in jx b jy mj kc mk ku ml kv mm kw mn ks mf mg mh mi bi translated">主持人。</li></ol><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ee16" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docket ]</strong> docker network ls<br/>NETWORK ID          NAME                DRIVER<br/>8b169e0c38fd        <strong class="mt io">none</strong>                null                <br/>0422d120f29c        <strong class="mt io">host</strong>                host                <br/>19e614e5beec        <strong class="mt io">bridge</strong>              bridge              </span><span id="316b" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker ps<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br/><strong class="mt io">3673e651a804</strong>        ubuntu              "/bin/bash"         16 hours ago        Up 16 hours                             rcv<br/><strong class="mt io">148edfe98193</strong>        ubuntu              "/bin/bash"         16 hours ago        Up 16 hours                             src</span><span id="f547" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker network inspect bridge<br/>[<br/>    {<br/>        "Name": "bridge",<br/>        "Id": "19e614e5beeca0bbb73907f37c3ccb81893349a91031264a3610e7a1c158c28d",<br/>        "Scope": "local",<br/>        "Driver": "bridge",<br/>        "IPAM": {<br/>            "Driver": "default",<br/>            "Config": [<br/>                {<br/>                    "Subnet": "172.17.160.1/19",<br/>                    "Gateway": "172.17.160.1"<br/>                }<br/>            ]<br/>        },<br/>        "<strong class="mt io">Containers</strong>": {<br/>            "<strong class="mt io">148edfe981937f3f8b15b40e1088273aafaeb9bd57d03a3f102ba6248a9f6575</strong>": {<br/>                "EndpointID": "8c921a07b26255535f97045f9f7ce4a4d379f471c139d8d7837ed70d9d94a0b5",<br/>                "MacAddress": "02:42:ac:11:a0:02",<br/>                "IPv4Address": "<strong class="mt io">172.17.160.2</strong>/19",<br/>                "IPv6Address": ""<br/>            },<br/>            "<strong class="mt io">3673e651a804c872584a588d8e39d95cba7219d02541266a8bf4fe903696bb1c</strong>": {<br/>                "EndpointID": "249d1edf5f05304d89652cb10839d2bb731d964e32635f164829fd3702398065",<br/>                "MacAddress": "02:42:ac:11:a0:03",<br/>                "IPv4Address": "<strong class="mt io">172.17.160.3</strong>/19",<br/>                "IPv6Address": ""<br/>            }<br/>        },<br/>        "Options": {<br/>            "com.docker.network.bridge.default_bridge": "true",<br/>            "com.docker.network.bridge.enable_icc": "true",<br/>            "com.docker.network.bridge.enable_ip_masquerade": "true",<br/>            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",<br/>            "com.docker.network.bridge.name": "docker0",<br/>            "com.docker.network.driver.mtu": "1500"<br/>        }<br/>    }<br/>]</span><span id="1c85" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker network inspect none<br/>[<br/>    {<br/>        "Name": "none",<br/>        "Id": "8b169e0c38fdc80337f4e38ab1e89328fb79f260c501ffadad8ff1141e2384f0",<br/>        "Scope": "local",<br/>        "Driver": "null",<br/>        "IPAM": {<br/>            "Driver": "default",<br/>            "Config": []<br/>        },<br/>        "Containers": {},<br/>        "Options": {}<br/>    }<br/>]</span><span id="0e3a" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker network inspect host<br/>[<br/>    {<br/>        "Name": "host",<br/>        "Id": "0422d120f29cd0a63952fdf5bc41dde7004bc34e4140458ea8ed90b1c60e4bde",<br/>        "Scope": "local",<br/>        "Driver": "host",<br/>        "IPAM": {<br/>            "Driver": "default",<br/>            "Config": []<br/>        },<br/>        "Containers": {},<br/>        "Options": {}<br/>    }<br/>]</span></pre><p id="15b0" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">查看上面的输出，这两个容器被列在 network ' <strong class="jx io"> bridge </strong>和<strong class="jx io"> <em class="jw">下。默认情况下，网桥网络下的任何容器都可以通过它们的 IP 地址到达(PINGable)，但不能通过它们的名称</em> </strong> <code class="fe nd ne nf mt b"><strong class="jx io"><em class="jw">src</em></strong></code> <strong class="jx io"> <em class="jw">和</em> </strong> <code class="fe nd ne nf mt b"><strong class="jx io"><em class="jw">rcv</em></strong></code>到达。容器也可以使用它们的名字来相互通信，但是为此，它们需要使用——<code class="fe nd ne nf mt b">link</code>选项(我们稍后会谈到)。</p><figure class="mo mp mq mr gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ng"><img src="../Images/bde0f511c7b76aff90b8a0ccef885135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csmPlbZX1WkBVyn4IiKMuw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">与集装箱对接的码头桥</figcaption></figure><p id="6562" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">此图显示了将主机上的物理以太网接口连接到 docker 容器的网桥接口。Docker 守护进程拥有一系列来自网桥接口所在子网的 IP 地址，并将其分配给每个新容器，它使用基于 IP 地址的命名。紧逼也隔离了容器与外界的交流，它们只能通过一个桥与外界联系。默认情况下，docker 守护进程中的所有容器都可以相互对话，这是通过 docker 守护进程标志<code class="fe nd ne nf mt b">— icc=true</code>(容器间通信)来完成的。还有另一个值得一提的标志<code class="fe nd ne nf mt b">— iptables</code>，它覆盖了<code class="fe nd ne nf mt b">— icc</code>功能，它阻止 docker 守护进程在<code class="fe nd ne nf mt b">— iptables=false</code>时对<code class="fe nd ne nf mt b">iptables </code>进行更改。</p><p id="d1ac" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">现在，在生产环境中，您肯定会设置适当的寻址方案来避免干扰和最有可能的<a class="ae kt" href="https://en.wikipedia.org/wiki/Private_network" rel="noopener ugc nofollow" target="_blank">私有 IP 寻址</a>。在本例中，我们为网关桥和其中所有的 NAT 主机使用了 B 类地址。默认情况下，docker 根据<a class="ae kt" href="https://tools.ietf.org/html/rfc1918" rel="noopener ugc nofollow" target="_blank"> RFC1918 </a>设置一个私有 IP 地址，但有时您可能需要设置自己的私有 IP 方案，此时您需要更改默认行为并设置网桥 IP 地址，以获得更多<a class="ae kt" href="https://docs.docker.com/engine/userguide/networking/default_network/custom-docker0/" rel="noopener ugc nofollow" target="_blank">选项</a>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e3dd" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker$ ]</strong> service docker stop <br/><strong class="mt io">[root@docker$</strong> <strong class="mt io">]</strong> vim /etc/default/docker</span><span id="9459" class="mx ky in mt b gy nc mz l na nb">DOCKER_OPTS="<strong class="mt io">--bip=172.16.160.1/20</strong>"</span><span id="3d14" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker$</strong> <strong class="mt io">]</strong> service docker start<br/><strong class="mt io">[root@docker$</strong> <strong class="mt io">]</strong> ifconfig<br/>docker0   Link encap:Ethernet  HWaddr 02:42:64:0d:8b:b6  <br/>          inet addr:<strong class="mt io">172.16.160.1</strong>  Bcast:0.0.0.0  Mask:255.255.224.0<br/>          UP BROADCAST MULTICAST  MTU:1500  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0 <br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><span id="8a49" class="mx ky in mt b gy nc mz l na nb">eth0      Link encap:Ethernet  HWaddr 08:00:27:44:20:d8  <br/>          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0<br/>          inet6 addr: fe80::a00:27ff:fe44:20d8/64 Scope:Link<br/>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br/>          RX packets:63 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:112 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:1000 <br/>          RX bytes:16848 (16.8 KB)  TX bytes:14347 (14.3 KB)</span><span id="62db" class="mx ky in mt b gy nc mz l na nb">lo        Link encap:Local Loopback  <br/>          inet addr:127.0.0.1  Mask:255.0.0.0<br/>          inet6 addr: ::1/128 Scope:Host<br/>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br/>          RX packets:69 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:69 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0 <br/>          RX bytes:7229 (7.2 KB)  TX bytes:7229 (7.2 KB)</span></pre><p id="a247" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">现在，如果您启动这个守护进程中的任何容器，它将自动从上述 IP 地址子网范围中获取 IP 地址。示例:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b9b9" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">root@9d51b764a3c1:/#</strong> ifconfig<br/>eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:a0:02  <br/>          inet addr:<strong class="mt io">172.16.160.2</strong>  Bcast:0.0.0.0  Mask:255.255.224.0<br/>          inet6 addr: fe80::42:acff:fe11:a002/64 Scope:Link<br/>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br/>          RX packets:10863 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:10767 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0 <br/>          RX bytes:25248347 (25.2 MB)  TX bytes:586961 (586.9 KB)</span><span id="c970" class="mx ky in mt b gy nc mz l na nb">lo        Link encap:Local Loopback  <br/>          inet addr:127.0.0.1  Mask:255.0.0.0<br/>          inet6 addr: ::1/128 Scope:Host<br/>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0 <br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span></pre><p id="e699" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">同样，有时我们希望这些容器有一个特定的静态 IP 地址(当然是来自相同的子网范围，但是是我们自己选择的，而不是 docker 守护进程分配的随机地址)。有一种方法可以做到这一点:</p><ul class=""><li id="bc26" class="ma mb in jx b jy jz kc kd ku mc kv md kw me ks ns mg mh mi bi translated"><strong class="jx io">容器运行时间</strong>:运行容器后，我们可以在<code class="fe nd ne nf mt b">/var/lib/docker/containers/&lt;container ID&gt;</code>修改存储网络设置的配置文件。但是这可能不是很有用，因为这种网络设置通常需要在启动时给出，因为运行时是易变的，并且可能在下一次启动时消失。除了在启动时，我找不到任何其他合适的方法给容器分配特定的 IP 地址。</li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9b21" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker ]</strong> docker ps<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br/>708290c3743e        centos              "/bin/bash"         35 minutes ago      Up 35 minutes                           silly_visvesvaraya<br/>9d51b764a3c1        ubuntu              "/bin/bash"         39 minutes ago      Up 39 minutes                           small_jang</span><span id="1a2c" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> ls -l /var/lib/docker/containers/9d51b764a3c1034585f61a2d8156702b8afbcf258f510d5c93bde91d82d7767d/<br/>total 60<br/>-rw------- 1 root root 36856 Nov  6 23:12 9d51b764a3c1034585f61a2d8156702b8afbcf258f510d5c93bde91d82d7767d-json.log<br/>-rw-r--r-- 1 root root  2398 Nov  6 22:55 config.json<br/>-rw-r--r-- 1 root root   720 Nov  6 22:55 hostconfig.json<br/>-rw-r--r-- 1 root root    13 Nov  6 22:55 hostname<br/>-rw-r--r-- 1 root root   176 Nov  6 22:55 <strong class="mt io">hosts</strong><br/>drwxrwxrwt 2 root root    40 Nov  6 22:38 mqueue<br/>-rw-r--r-- 1 root root   190 Nov  6 22:55 <strong class="mt io">resolv</strong>.<strong class="mt io">conf</strong><br/>-rw------- 1 root root    71 Nov  6 22:55 resolv.conf.hash<br/>drwxrwxrwt 2 root root    40 Nov  6 22:55 shm</span></pre><h1 id="adc4" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">链接容器</strong></h1><p id="c321" class="pw-post-body-paragraph ju jv in jx b jy lv ka kb kc lw ke kf ku lx ki kj kv ly km kn kw lz kq kr ks ig bi translated">在 docker 主机/守护进程中连接容器的最佳方式称为“<strong class="jx io">链接容器</strong>”。最安全的通信方式，但缺点是它只能在容器间通信，而不能与外界通信。“在某种程度上，这是塞翁失马，焉知非福”。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2316" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker ]</strong> docker run —name=src -d &lt;source container image&gt;<strong class="mt io">[root@docker ]</strong> docker run —name=rcvr —link=src:alias-src -d &lt;receiver container image&gt;</span><span id="b0d5" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker inspect rcvr<br/>........<br/>“Links”: [<br/>     “/src:/src/alias-src”<br/>........</span><span id="c041" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker inspect src | grep Links<br/>“Links”: null,</span></pre><p id="dab3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">这是因为源容器为接收容器提供了相当多的环境变量。它还在/etc/hosts 文件中添加了一个条目，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c074" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">root@1c8b2b26e9fa:/#</strong>  env | grep ALIAS<br/>ALIAS_SRC_PORT_80_TCP_ADDR=172.16.160.2<br/>ALIAS_SRC_PORT_80_TCP_PROTO=tcp<br/>ALIAS_SRC_PORT_80_TCP_PORT=80<br/>ALIAS_SRC_PORT=tcp://172.16.160.2:80<br/>ALIAS_SRC_NAME=/rcvr/alias-src<br/>ALIAS_SRC_PORT_80_TCP=tcp://172.16.160.2:80</span><span id="3f86" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">root@1c8b2b26e9fa:/#</strong> cat /etc/hosts<br/>172.16.160.3       1c8b2b26e9fa<br/>127.0.0.1          localhost<br/>::1  localhost ip6-localhost ip6-loopback<br/>fe00::0 ip6-localnet<br/>ff00::0 ip6-mcastprefix<br/>ff02::1 ip6-allnodes<br/>ff02::2 ip6-allrouters<br/>172.16.160.2        alias-rcvr</span></pre><p id="3fab" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">还有一点很重要，即“src”和“rcvr”都可以相互通信，这意味着它创建了一个双向通道。同样，一个源可以连接到许多接收器，同样，一个接收器可以链接到许多源。</p><h1 id="2bac" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将端口暴露给外部世界</h1><p id="4188" class="pw-post-body-paragraph ju jv in jx b jy lv ka kb kc lw ke kf ku lx ki kj kv ly km kn kw lz kq kr ks ig bi translated">这是容器与外部世界之间最常见的通信方式，而对于外部世界与容器的通信来说，这是一种更好的方式，因为这里我们只公开端口，而不公开 IP 地址。这也意味着 docker 主机上的任何物理接口都可以接受传入的数据包，因为 iptable 将规则设置为<strong class="jx io"> 0.0.0.0:80 </strong>，让我们举个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1675" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker ]</strong> vim Dockefile</span><span id="358e" class="mx ky in mt b gy nc mz l na nb">.........<br/>EXPOSE 80<br/>.........</span><span id="fd17" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker build -t="apache-img" .</span></pre><p id="9c4c" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">在应用程序中使用 EXPOSEing 端口号构建映像后，使用<code class="fe nd ne nf mt b">-p</code>选项运行映像，并指定:<strong class="jx io">{ docker 主机的传入端口:docker 容器端口}。</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f69f" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker ] </strong>docker run -d -p 5010:80 apache-img</span><span id="2a81" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker ps<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br/>9d51b764a3c1        apache-img          "/bin/bash"         2 hours ago         Up 2 hours                  0.0.0.0:5010-&gt;80/tcp            small_jang</span><span id="91a5" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker port small_jang<br/>80/tcp -&gt; 0.0.0.0:5010</span></pre><p id="27bb" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">这意味着来自端口 5010 的 0.0.0.0(任何接口)上的 docker 主机接口的所有数据包将进入已经暴露端口 80 的 docker 容器的端口 80。</p><p id="d0b3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">特定接口/IP 地址也可以是特定的，而不是 0.0.0.0，这可以使用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="32e1" class="mx ky in mt b gy my mz l na nb"><strong class="mt io">[root@docker ] </strong>docker run -d -p 192.168.56.5:5010:80 apache-img</span><span id="8aad" class="mx ky in mt b gy nc mz l na nb"><strong class="mt io">[root@docker ]</strong> docker port small_jang<br/>80/tcp -&gt; 192.168.56.5:5010</span></pre><p id="73d5" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">其中，假设<a class="ae kt" href="http://192.168.56.5:5010" rel="noopener ugc nofollow" target="_blank"> http://192.168.56.5:5010 </a>请求将到达运行在容器中的 apache 服务器的端口 80。</p><h1 id="6368" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在我说“再见”之前</h1><p id="9fb7" class="pw-post-body-paragraph ju jv in jx b jy lv ka kb kc lw ke kf ku lx ki kj kv ly km kn kw lz kq kr ks ig bi translated">默认网桥将允许<a class="ae kt" href="https://docs.docker.com/engine/userguide/networking/default_network/container-communication/" rel="noopener ugc nofollow" target="_blank">容器到容器的通信</a>使用它们的 IP 地址(由守护程序动态分配),这变得难以知道容器的 IP，并且更难以编程(重启将不能保证相同的 IP 将被分配回)。在这种情况下，最好的选择是链接容器，即通过它们的名称，在启动之前你就知道容器的名称，并且易于编程。因此，你可能想关闭默认的 IP 地址为基础的通信是不是？这可以通过以下方式实现</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="81fb" class="mx ky in mt b gy my mz l na nb">--icc=false</span></pre><p id="3b3e" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated">在这之后，你可以连接你的容器，世界将会变得更加安全。</p><h1 id="bbe9" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="7bd7" class="pw-post-body-paragraph ju jv in jx b jy lv ka kb kc lw ke kf ku lx ki kj kv ly km kn kw lz kq kr ks ig bi translated">没有硬性规定，但是公开端口最适合与外部世界通信，而链接容器最适合容器之间的内部通信。这也是一个隐藏的局域网，与外界隔绝，因此也受到保护。</p><p id="60e3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf ku kh ki kj kv kl km kn kw kp kq kr ks ig bi translated"><strong class="jx io">你可以在|</strong><a class="ae kt" href="https://www.linkedin.com/in/mdeore/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">LinkedIn</strong></a><strong class="jx io">|</strong><a class="ae kt" href="https://tomdeore.wixsite.com/epoch" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">网站</strong></a><strong class="jx io">|</strong><a class="ae kt" href="https://github.com/milinddeore" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Github</strong></a><strong class="jx io">|</strong></p></div></div>    
</body>
</html>