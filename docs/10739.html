<html>
<head>
<title>How can we optimise Kafka performance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何优化卡夫卡的表演？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-can-we-optimise-kafka-performance-ce2788c54373?source=collection_archive---------5-----------------------#2022-11-26">https://blog.devgenius.io/how-can-we-optimise-kafka-performance-ce2788c54373?source=collection_archive---------5-----------------------#2022-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4f18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">优化 Kafka 性能</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3597574f03041153a4a881050647b733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEAtGOJkE7x9dWHoTERNaQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">阿帕奇卡夫卡</figcaption></figure><h2 id="e447" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">前言</h2><p id="139d" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Apache Kafka 已经成为世界上最好的事件流媒体平台，被各个领域的公司所利用，从银行和欺诈检测到物联网和运输。生产者和消费者应用程序只需要利用 Kafka APIs，剩下的就交给它了。</p><p id="a858" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">下面是卡夫卡在幕后做的一些看起来很像魔术的事情:</strong></p><ul class=""><li id="b4f0" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">自动平衡集群中所有代理的负载</li><li id="be70" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">利用代理中的零拷贝传输向消费者发送数据</li><li id="8a0e" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">添加或删除使用者时，自动重新平衡使用者组</li><li id="f9dc" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">代理出现故障时，自动将分区领导者重新分配给实时代理</li></ul><p id="5603" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然 Kafka 确实提供了许多功能，但是可能有某些不同的用例需要调整 Kafka 的不同参数。</p><blockquote class="mk"><p id="5825" class="ml mm in bd mn mo mp mq mr ms mt kh dk translated">Kafka 的设计本质上为用户提供了配置灵活性。</p></blockquote><p id="901e" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">Kafka 可以进一步优化以下内容:</p><ul class=""><li id="a344" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">吞吐量</li><li id="26f6" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">潜伏</li><li id="6fe0" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">持久性</li><li id="7f1d" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">有效性</li></ul><p id="cfca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它们都是相互关联的，因此我们无法同时优化所有功能。尽管这四者之间有时会有折衷，但我们可以根据项目业务需求对其进行调整。</p><h2 id="0a0f" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">吞吐量优化</h2><ul class=""><li id="09ba" class="lw lx in jm b jn lr jr ls jv mz jz na kd nb kh mb mc md me bi translated">为了优化吞吐量，我们正在尝试提高数据移动的速率。</li><li id="b242" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">更多的<strong class="jm io"> <em class="nc">主题分区</em> </strong>会导致更高的吞吐量，并且分区应该在代理之间均匀分布。</li><li id="15ce" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">此外，消息的<strong class="jm io"> <em class="nc">键</em> </strong>需要仔细分配，以便消息尽可能均匀地分布在主题分区上。</li><li id="c179" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">调整生成器批处理，以增加批处理大小和等待消息填满批处理所花费的时间。配置<code class="fe nd ne nf ng b">batch.size</code> <strong class="jm io"> <em class="nc"> </em> </strong>参数，增加每个消息批次的最大字节数。</li><li id="c24a" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">配置<code class="fe nd ne nf ng b">linger.ms</code>参数，让生成器在发送前等待更长时间。</li><li id="2c63" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">通过配置<code class="fe nd ne nf ng b">compression.type</code>参数启用压缩，该参数可以设置为以下标准压缩编解码器之一:lz4、snappy 和 zstd。</li><li id="377d" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">Set <code class="fe nd ne nf ng b">acks=1</code>使主代理将消息写入其本地日志，然后确认请求，而不等待来自所有从代理的确认，这反过来增加了吞吐量。</li></ul><h2 id="625f" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">延迟优化</h2><ul class=""><li id="78fc" class="lw lx in jm b jn lr jr ls jv mz jz na kd nb kh mb mc md me bi translated">为了优化延迟，我们正试图最大限度地减少端到端(从生产者到经纪人再到消费者)传递消息的时间。</li><li id="fbbb" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">增加<strong class="jm io"> <em class="nc">分区数量</em> </strong>往往会增加延迟，所以减少主题分区数量。</li><li id="ac1d" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">调整参数<strong class="jm io"> <em class="nc"> </em> </strong> <code class="fe nd ne nf ng b">num.replica.fetchers</code>以增加跟随者代理中的 I/O 并行度。</li><li id="b79c" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">默认情况下，生成器针对低延迟进行了调整。<code class="fe nd ne nf ng b">linger.ms</code>设置为 0，这意味着生产者将在有数据要发送时立即发送。</li><li id="ecdc" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">使用<strong class="jm io"> <em class="nc"> </em> </strong> <code class="fe nd ne nf ng b">compression.type=none</code>禁用压缩以节省 CPU 周期，尽管一个好的压缩编解码器也可能<br/>减少延迟。</li><li id="dbe4" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设置<code class="fe nd ne nf ng b">acks=all</code> <strong class="jm io"> <em class="nc"> </em> </strong>，这意味着主代理将在所有副本接收到消息之前更快地<br/>对生产者做出响应。</li><li id="6348" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">将<code class="fe nd ne nf ng b">fetch.min.bytes</code> <strong class="jm io"> <em class="nc"> </em> </strong>置 1，表示只要有一个字节的数据可用，或者取请求超时等待数据到达，取请求就被应答，即<code class="fe nd ne nf ng b">fetch.max.wait.ms</code>。</li></ul><h2 id="4b63" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">优化耐用性</h2><ul class=""><li id="ed14" class="lw lx in jm b jn lr jr ls jv mz jz na kd nb kh mb mc md me bi translated">为了优化耐久性，我们试图减少信息丢失的机会。</li><li id="9f11" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设置主题<code class="fe nd ne nf ng b">replication.factor=3</code>、代理<code class="fe nd ne nf ng b">min.insync.replicas=2</code>和生产者<code class="fe nd ne nf ng b">acks=all</code>确保生产者将在大多数副本没有接收到写入时引发异常。</li><li id="1458" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设置<code class="fe nd ne nf ng b">broker.rack</code>配置，将代理分配到不同的可用性区域，以提高耐用性。</li><li id="db98" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">如果发送失败，生产者还可以通过尝试重新发送消息来增加持久性，以确保数据不会丢失。生成器自动尝试重新发送消息，发送次数由参数<code class="fe nd ne nf ng b">retries=MAX_INT</code> <em class="nc">指定。</em></li><li id="300c" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">对于吞吐量非常低的主题，根据需要将消息间隔或时间间隔设置为低(默认允许操作系统控制刷新)。</li></ul><h2 id="fe05" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">可用性优化</h2><ul class=""><li id="c42c" class="lw lx in jm b jn lr jr ls jv mz jz na kd nb kh mb mc md me bi translated">为了优化可用性，我们正在努力减少意外故障情况下的停机时间</li><li id="c068" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">更高的<strong class="jm io"> <em class="nc">主题分区</em> </strong>计数可能会增加并行性，但是拥有更多分区也会增加代理失败时的恢复时间，从而降低可用性。</li><li id="f4a7" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设置<code class="fe nd ne nf ng b">acks=all</code>，这将确保只要满足最小数量的副本，生产者请求将继续成功。这增加了分区的可用性。</li><li id="a884" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设置<code class="fe nd ne nf ng b">min.insync.replicas=1</code>，通过将此值设置为低，群集将能够容忍更多副本故障，从而提高可用性。</li><li id="ebb7" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><strong class="jm io">注意</strong> : <br/>当<code class="fe nd ne nf ng b">acks=all</code>带有<code class="fe nd ne nf ng b">replication.factor=N</code>和<code class="fe nd ne nf ng b">min.insync.replicas=M</code>时，集群可以容忍<code class="fe nd ne nf ng b">N-M</code>个经纪人为了话题可用性而下线。</li><li id="f28c" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">设定<code class="fe nd ne nf ng b">unclean.leader.election.enable=true</code>。这使得领导者选举发生得更快，从而提高了整体可用性。</li></ul><h2 id="50f2" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">结论</h2><p id="d473" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">为了优化 Kafka 性能，应该根据业务需求调整 Kafka 配置参数。吞吐量和延迟之间以及持久性和可用性之间存在性能上的权衡。基准测试对于验证特定 Kafka 集群部署的设置至关重要。</p><h2 id="7877" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">参考</h2><p id="6386" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">优化您的 Apache Kafka 部署</p></div></div>    
</body>
</html>