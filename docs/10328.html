<html>
<head>
<title>Playing PyFlink in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一言以蔽之，扮演皮弗林克</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/playing-pyflink-in-a-nutshell-3abd16467677?source=collection_archive---------7-----------------------#2022-10-24">https://blog.devgenius.io/playing-pyflink-in-a-nutshell-3abd16467677?source=collection_archive---------7-----------------------#2022-10-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8406" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解 PyFlink 的力量</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/13c527a98d50c00eb550926ebbddb3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*93z652Elyzx7s7Or"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com/@artturijalli" rel="noopener ugc nofollow" target="_blank"> Artturi Jalli </a>在<a class="ae ks" href="https://unsplash.com/photos/g5_rxRjvKmg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2992" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上周，我们介绍了<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/playing-pyflink-from-scratch-65c18908c366">如何构建 PyFlink 实验环境</a>，今天我们将使用该实验环境来探索 PyFlink 的可能性。</p><p id="0274" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">PyFlink 是一个通用的流框架，将流处理抽象为四个层次。</p><ol class=""><li id="dfa9" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">结构化查询语言</li><li id="225b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">表 API</li><li id="d135" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">数据流</li><li id="e294" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">有状态流处理</li></ol><p id="131b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">越靠近底部，灵活性越大，但也需要编写更多的代码。我希望能够用 PyFlink 做几乎所有的事情，所以让我们从数据流的角度开始了解 PyFlink 开发的基本概念。</p><p id="ba99" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将用简单的描述和例子介绍 PyFlink 开发的几个要点，但不会提及 Flink 的实现细节。</p><h1 id="15e0" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">数据流概念</h1><p id="8de6" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">数据流的开发将遵循以下过程。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/e27de6bda651d48a9cb28dba941b39e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scE7_-sNF8-KvDa3x6WXOA.png"/></div></div></figure><p id="8348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基本上，我们从一个源获得流数据，处理它，然后输出到某个地方。</p><p id="2edc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这用 PyFlink 表示如下。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="3300" class="ng me in nc b gy nh ni l nj nk">ds = env.add_source(kafka_consumer)<br/>ds = ds.map(transform, output_type=output_type_info)<br/>ds.add_sink(kafka_producer)</span></pre><p id="77e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">源和汇很好理解，但关键是可以用什么处理？</p><p id="7038" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在官方文件中有一个所有可用操作的列表。<br/><a class="ae ks" href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/overview/" rel="noopener ugc nofollow" target="_blank">https://night les . Apache . org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/overview/</a></p><p id="a013" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于上面的例子，我们使用了<code class="fe nl nm nn nc b">map</code>。</p><p id="3f0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在 Flink 工件中还有一个操作的例子，代码放在<code class="fe nl nm nn nc b">./examples/python/datastream/basic_operations.py</code>处。</p><h1 id="afc8" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated"><code class="fe nl nm nn nc b">map</code>和<code class="fe nl nm nn nc b">flat_map</code>有什么区别？</h1><p id="841b" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">操作列表中有两个类似的操作，<code class="fe nl nm nn nc b">map</code>和<code class="fe nl nm nn nc b">flat_map</code>，这两个操作有什么区别？</p><p id="0269" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不同之处在于生成的输出数量。</p><p id="8785" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nl nm nn nc b">map</code>的情况下，一个输入事件产生一个且只有一个输出事件；另一方面，<code class="fe nl nm nn nc b">flat_map</code>可以生成零到多个输出事件。</p><p id="80b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们以实际代码为例。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="75c8" class="ng me in nc b gy nh ni l nj nk">def map_transform(i: int):<br/>  return i * i<br/>  <br/>def flat_map_transform(i: int):<br/>  for idx in range(i):<br/>    yield idx<br/>    <br/>ds.map(map_transform, output_type=Types.INT())<br/>ds.flat_map(flat_map_transform, output_type=Types.INT())</span></pre><p id="da30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，<code class="fe nl nm nn nc b">map</code>对所有输入的整数求平方并传递出去，一个输入对应一个输出。而<code class="fe nl nm nn nc b">flat_map</code>输出一系列事件，输出事件的数量由输入事件决定。</p><p id="bf93" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果输入为<code class="fe nl nm nn nc b">0</code>，则<code class="fe nl nm nn nc b">flat_map</code>的<code class="fe nl nm nn nc b">yield</code>不会被触发，不会产生任何东西。</p><h1 id="4ccc" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">状态</h1><p id="52e7" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">状态是 Flink 最大的特点。</p><p id="cbd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然我们有各种操作可用，但其中许多实际上是基于以前的事件产生结果的。我们如何保留以前的事件？这就是<code class="fe nl nm nn nc b">State</code>的用武之地。</p><p id="cbbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了持久化数据，状态可以看作是一个内部存储器，状态的大小是每个节点内存的总和。</p><p id="d7ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，状态可以保存在像<code class="fe nl nm nn nc b">RocksDB</code>这样的持久存储中，以获得更大的可伸缩性。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="d92d" class="ng me in nc b gy nh ni l nj nk">from pyflink.datastream import StreamExecutionEnvironment, EmbeddedRocksDBStateBackend</span><span id="081d" class="ng me in nc b gy no ni l nj nk">env = StreamExecutionEnvironment.get_execution_environment()<br/>env.set_state_backend(EmbeddedRocksDBStateBackend())</span></pre><p id="b980" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在 Flink 框架中使用状态，有两个关键点值得注意。</p><ol class=""><li id="e8cb" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">状态只能在“键控数据流”中使用。</li><li id="bfe1" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">状态基于操作，不能与其他人共享。</li></ol><p id="fb50" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面列出了所有可用的状态和参考。<br/><a class="ae ks" href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/fault-tolerance/state/" rel="noopener ugc nofollow" target="_blank">https://night les . Apache . org/flink/flink-docs-release-1.15/docs/dev/datastream/fault-tolerance/state/</a></p><p id="bd76" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其实<code class="fe nl nm nn nc b">./examples/python/datastream/state_access.py</code>的一个例子也提供了很好的示范。</p><h1 id="c7bc" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">连接(共享状态)</h1><p id="493b" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">如前一节所述，状态是基于操作的，不能共享，但有时我们确实需要组合两个不同的流状态，那么我们应该怎么做呢？</p><p id="6e8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，Flink 提供了<code class="fe nl nm nn nc b">connect</code>,使我们能够共享同一作业中不同流的状态。</p><p id="4784" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过使用<code class="fe nl nm nn nc b">connect</code>，我们可以组合不同的流，使用相同的操作，这样我们就可以共享相同的操作状态。</p><p id="b805" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更具体地说，让我举一个实际的例子。有两条溪流。</p><ul class=""><li id="3e98" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo np lv lw lx bi translated">流 1 提供了项目标识符和项目名称之间的映射。当项目名称改变时，一个事件<code class="fe nl nm nn nc b">(item_id, item_name)</code>被发送到流中，所以我们只需要保存最新的状态。</li><li id="8de4" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo np lv lw lx bi translated">流 2 是交易历史，包括售出的商品和订购的商品数量。</li></ul><p id="4d45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们想要做的是，当输入任何购买时，我们必须对其进行汇总，并将最新的商品名称追加到其中。</p><p id="e433" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是经典的流式丰富模式，我在<a class="ae ks" href="https://betterprogramming.pub/design-pattern-of-streaming-enrichment-17a9eb065eca" rel="noopener ugc nofollow" target="_blank">我的上一篇文章</a>中详细解释了丰富设计模式。</p><p id="ef34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是完整的程序示例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="875b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nl nm nn nc b">flat_map1</code>中处理了流 1，也就是说维护了项目编号和项目名称的映射，所以这个流不需要生成输出事件。</p><p id="cdc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">整个应用的核心在<code class="fe nl nm nn nc b">flat_map2</code>里。我们从<code class="fe nl nm nn nc b">self.cnt_state</code>中获取累计量，不仅添加新量，还将其更新回状态。然后，在输出过程中，我们从<code class="fe nl nm nn nc b">self.state</code>中取相应的名字，最后输出丰富的事件。</p><h1 id="5dcf" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">结论</h1><p id="eb25" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">在最后一个例子中，我们演示了流的操作、状态和合并。</p><p id="0dd8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从这个例子我们很容易理解，只要我们正确的编写程序，Flink 可以做任何我们想做的事情。</p><p id="f780" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将继续在流处理上做一些实验，如果有任何进一步的更新，我们将继续发布。</p></div></div>    
</body>
</html>