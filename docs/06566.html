<html>
<head>
<title>An Introduction to Custom Views on Android — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android自定义视图介绍—第1部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-introduction-to-custom-views-on-android-part-1-4972a10fb133?source=collection_archive---------8-----------------------#2022-01-17">https://blog.devgenius.io/an-introduction-to-custom-views-on-android-part-1-4972a10fb133?source=collection_archive---------8-----------------------#2022-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/48ed916e54017d97db8018fc34576c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4Kj7DmCNWNtKPRCPZtglg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">图片来源:斯蒂夫·约翰森Pexels</figcaption></figure><div class=""/><p id="1250" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当构建android应用程序时，我们使用Android UI框架提供给我们的视图，无论是显示存储在本地数据库中的文本的<code class="fe kx ky kz la b">TextView</code>还是显示通过网络加载的图像的<code class="fe kx ky kz la b">ImageView</code>。这些视图迎合了我们的基本需求，令人惊叹的android应用程序利用这些预先存在的视图来提供出色的体验。材料设计库也为Android设计生态系统带来了统一感，世界各地的设计师和工程师都在遵循当今构建应用程序的既定准则。</p><p id="01f7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，我们可能想要建立一些不同的东西，一些Android没有提供的东西。设计规范各不相同，android工程师有时会发现自己陷入困境，想出一个“特殊”的观点是唯一的出路。在这种情况下，我们看到了自定义视图，这是一种可扩展的方法，提供了一种将自定义逻辑和设计定义到视图中的方法。</p><h2 id="04ab" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">但是什么是自定义视图呢？，真的。</h2><blockquote class="lu lv lw"><p id="2250" class="jz ka lx kb b kc kd ke kf kg kh ki kj ly kl km kn lz kp kq kr ma kt ku kv kw ig bi translated">定制视图是对现有的<strong class="kb jd">视图</strong>或<strong class="kb jd">视图组</strong>实现的子类化，以提供对元素外观和功能的绝对控制。</p></blockquote><p id="d2de" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">可以通过两种方式创建自定义视图，这两种方式是:</p><ol class=""><li id="d378" class="mb mc jc kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated"><strong class="kb jd">扩展视图:</strong>我们通过扩展现有的视图(如TextView、EditText e.t.c)来创建这些视图，并为其提供自定义实现，定义我们的自定义逻辑。如果我们想从头创建一个视图，而不依赖于现成视图的特性，我们也可以扩展基本视图类。</li><li id="a4c7" class="mb mc jc kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><strong class="kb jd">扩展视图组:</strong>这有点不同，因为它需要创建一个视图组的自定义实现，例如ConstraintLayout、LinearLayout等。通常，当所需的视图不需要从头开始构建，但可以通过隔离同一视图组下的不同视图(具有密切相关的功能)来获得时，会使用这种方法。这被称为<strong class="kb jd">复合组件</strong>。它们建立在现有视图组的基础上。如果您对此感兴趣，或者想了解更多关于<strong class="kb jd">复合元件</strong>的信息，可以查看<a class="ae mp" href="https://medium.com/android-dev-hacks/a-kotlin-based-introduction-to-compound-components-on-android-part-1-2d28323b9ef9" rel="noopener">我的复合元件系列</a>，希望对您有用。</li></ol><h2 id="2dea" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">但是我们将会看到一个视图的扩展，以及自定义视图在这里是如何工作的。我们走吧！。</h2><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/1650d1f7011c157dbbc982a9dd7b89ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*5zA8Ry7-OsNlDcagICFo4Q.gif"/></div></figure></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h2 id="e242" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">自定义视图的工作方式。</h2><p id="8740" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">现在，我可能过度强调了视图的“扩展”(最后一次，我保证)。创建自定义视图时，有两个非常重要的过程，即:</p><ol class=""><li id="383a" class="mb mc jc kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">图画</li><li id="976b" class="mb mc jc kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">测量</li></ol><p id="2a68" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">绘制我们的视图需要将形状、文本、图像(或任何你能想到的东西)映射到屏幕上，这基本上是你想要创建的东西的绘图。</p><p id="3d50" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">测量我们的视图与尺寸有关，并决定在不同的屏幕条件(大小、密度等)下显示视图的正确部分。这是在屏幕上正确呈现我们的视图，并确保在“不寻常”的情况下不会变得一塌糊涂的过程。</p><h2 id="25d3" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">在这篇文章中，我们倾向于绘画方面。</h2><h1 id="d61a" class="nh lc jc bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">绘制自定义视图</h1><p id="2459" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">绘制自定义视图时，需要理解三个重要概念，即:</p><ol class=""><li id="3e6a" class="mb mc jc kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated"><strong class="kb jd">画什么</strong> —形状、文本、图像等等</li><li id="6482" class="mb mc jc kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><strong class="kb jd">在哪里画</strong> —画布类。</li><li id="fa8e" class="mb mc jc kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><strong class="kb jd">怎么画</strong> —画类。</li></ol><h2 id="a800" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">了解Android画布</h2><p id="c992" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">想象一下，给你一块巨大的、没有杂质的白色石板，并让你用它做任何事情。你的第一个想法(如果你和我一样的话)会是理解石板的结构，然后在石板上尝试不同的物体，看看什么有用(或者没用)。你(实际上是我)可能会用一支钢笔、一支铅笔、一支记号笔——无论什么。android画布就是这样。我们的视图类给我们的一个区域，我们可以随意绘制。想象一个巨大的白色艺术板。</p><h2 id="4ec7" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">那么我的画布有多大？和景色一样大。</h2><h2 id="6264" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">绘画课</h2><p id="4475" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">上面提到的Paint类指定了“如何绘制”。这个类允许我们定义希望绘制的元素采用的样式。它的用途范围很广，从简单的绘制矩形/圆形轮廓、向文本添加格式(倾斜、缩放)到更复杂的样式，如使用混合模式组合两幅图像以提供合成效果。所有这些以及更多的都可以使用Paint类来实现。再一次，想象这是你的画笔——你要在你的画板上使用的画笔。</p><h2 id="dd26" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">在Android画布上绘画</h2><p id="a2e9" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">在我们研究在android画布上绘图之前，让我们创建第一个自定义视图。继续创建一个名为<code class="fe kx ky kz la b">MyFirstCustomView.kt </code>的新Kotlin文件。这个文件将包含我们的自定义视图定义和业务逻辑。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">创建扩展视图类的类的代码。</figcaption></figure><p id="bde2" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，视图类有许多需要在子类(MyFirstCustomView)中实现的构造函数，让我们快速看一下这些构造函数。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">视图类中存在的构造函数定义。</figcaption></figure><p id="df3d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">视图类(如上所示)有四个对象构造器，每个构造器都可以根据对象实例化的条件调用。在我们的例子中，我们必须在视图子类中提供构造函数定义，方法是创建二级构造函数并将调用连接到超类，如下面的代码片段所示👇🏾</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">MyFirstCustomView类显示视图构造函数重载。</figcaption></figure><p id="b66a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，这解决了我们的问题(这并不完全是一个问题)，但是如果你像我一样是Kotlin的粉丝，你可能总是想把这样的实现做得更好。好消息是:<strong class="kb jd">我们可以</strong>。更类似Kotlin的方法是在构造函数定义中使用命名和默认参数。让我们更仔细地看看这个。</p><h2 id="553a" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">@JvmOverloads批注</h2><p id="a48d" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">当添加到构造函数定义中时，该注释指示transpiler (to Java)提供构造函数定义的重载。我们首先为MyFirstCustomView类创建一个辅助构造函数。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">使用@JvmOverloads注释来减少我们编写的构造函数的数量。</figcaption></figure><p id="140f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，我们创建了一个构造函数，所有参数都被传入(同时传入超类)，但是除了<code class="fe kx ky kz la b">ctx</code>对象之外，所有参数都使用默认值。这是因为它是在实例化过程中唯一一个<strong class="kb jd">必须</strong>传入的对象——而不是我们自己负责实例化。等等，这段代码要被转换成Java，而Java(据我所知)不知道如何处理默认参数——这就是为什么我们有了<code class="fe kx ky kz la b">@JvmOverloads</code>注释，帮助我们在最终的Java源代码中创建已定义构造函数的重载。</p><p id="cbc1" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">添加注释后，我们的最终代码是:</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="69e6" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们已经建立了我们的第一个自定义视图类，我们如何绘制呢？我们通过覆盖视图类提供给我们的<code class="fe kx ky kz la b">onDraw</code>方法来做到这一点。其签名声明如下👇🏾</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">onDraw方法定义</figcaption></figure><p id="94a3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">View类提供的<code class="fe kx ky kz la b">onDraw</code>方法是我们<strong class="kb jd"/>绘制自定义视图的地方。一个可空的<code class="fe kx ky kz la b">Canvas</code>对象被传入，如果你还记得的话，<code class="fe kx ky kz la b">Canvas</code>类是我们巨大的画板，在这里我们可以绘制大量的元素。我们在<code class="fe kx ky kz la b">Canvas</code>类中有一些方法可以帮助绘制矩形— <code class="fe kx ky kz la b">drawRect</code>、圆形— <code class="fe kx ky kz la b">drawCircle</code>、路径— <code class="fe kx ky kz la b">drawPath</code>等等。不言而喻，这个方法是许多绘图调用的宿主，这些调用最终往往是内存密集型的，因此在这个方法中声明和/或实例化对象并不是一个好主意，以避免降低性能。因此，所有对象实例化都将在该方法之外完成。</p><p id="a966" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这似乎是在屏幕上绘制我们的第一个元素的好时机，但是我们还需要理解<strong class="kb jd">画布</strong> <strong class="kb jd">坐标系统</strong>，它将在我们的开发中大量使用。</p><h2 id="02ae" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">画布坐标系统</h2><p id="6499" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">回到高中，我们学习了笛卡尔平面，它使用<strong class="kb jd"> X(水平)</strong>和<strong class="kb jd"> Y(垂直)</strong>轴来表示平面的不同方向。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oa"><img src="../Images/f847a9fd93ecb13892078f282c7193f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgBrT-xBBeFZkJZdl_dPyg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">笛卡尔平面</figcaption></figure><h2 id="6a5b" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated"><strong class="ak">看着眼熟？</strong></h2><p id="b2b9" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">现在我已经重新点燃了一些高中的记忆，我们需要明白画布坐标系仍然使用X轴和Y轴，但不是以如上所示的方式。下图更加清晰。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/84dbcc89509c68bcdcbdf41199402100.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*mlXeJJNMU826R6FCCBYj0Q.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">画布坐标系统</figcaption></figure><p id="74bf" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上图显示了X和Y轴在android画布上的移动。这表明视图的左上部分是画布的原点(0，0)。X轴向右增加，Y轴沿视图向下增加。</p><h2 id="e8c7" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">现在我们已经巩固了android画布的坐标系统，是时候绘制我们的第一个形状了。同时，如果在这一点上，你有一个渴望的问题，请在下面留下评论或在twitter上给我发一个DM-我很乐意回答。</h2><h1 id="7aab" class="nh lc jc bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">画一个矩形</h1><p id="e94c" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">Canvas类中的<code class="fe kx ky kz la b">drawRect</code>方法正好完成了这个任务。这个方法有许多重载，我们将快速查看一下。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">drawRect方法定义。</figcaption></figure><p id="891c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一个重载接受两个参数，第一个是Rect (r)对象。这个draw调用使用传递的矩形绘制一个矩形，并根据传递的对象的属性设置其边界(高度和宽度)。第二个重载接受一些位置(在画布上)参数，这些参数决定了我们的矩形从左、右、上、下要画多远。另一方面，Paint对象指定样式选项，如要绘制的矩形的颜色、笔画和整体设计。让我们来看看这个插图。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/342c153c8d68af3444da108335eb6b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*PlF3czSKd0eFuFcGJigFMg.png"/></div></figure><p id="0a1c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在屏幕上绘制矩形需要左、上、右和下的值。在上图中，我们以左— x1、上— y1、右— x2和下— y2的形式指定值。x1和y1线相交于同一点，形成矩形的左上边缘。x2和y2线从各自的原点出发，在矩形的右下边缘相交。</p><h2 id="ff1c" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">让我们画画。</h2><p id="dce6" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">首先，让我们为矩形创建画图对象，并在<code class="fe kx ky kz la b">init</code>块中初始化它的属性。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="77f9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦我们初始化了paint对象，我们就在init块中将颜色设置为蓝色。添加了一条额外的线(isAntiAlias = true)，这告诉paint对象确保平滑将要绘制的任何对象的边缘，以避免不规则的形状。</p><p id="21ca" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，在我们的onDraw方法中，我们调用一个名为drawRectangle的方法，并传入我们的canvas对象，该方法将进行绘制，以避免onDraw过度拥挤。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1978" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的<code class="fe kx ky kz la b"><strong class="kb jd">drawRectangle</strong></code>方法定义如下👇🏾</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8c3f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">本质上，我们告诉画布的是:“<strong class="kb jd">给我画一个矩形，左边和上边都没有间距，矩形的右边应该从视图的左边偏移150f，矩形的下边应该从上边偏移150 f</strong>”。</p><p id="c603" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有了这个，我们想出了这个👇🏾，而蓝色是因为传入了paint对象。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi od"><img src="../Images/6ddb43e327e2138002a1c93b3c78b3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBaOJrHfNl5b063inSdfnQ.png"/></div></div></figure><h2 id="0f7e" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">接下来，我们将画一个圆。</h2><h1 id="aa56" class="nh lc jc bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">画一个圆</h1><p id="e96f" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">为此，我们从创建自己的paint对象和初始化必要属性的相同方法开始。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7b1b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后我们在<code class="fe kx ky kz la b">onDraw</code>方法中添加一个对<code class="fe kx ky kz la b">drawCircle</code>方法的调用。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0e26" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们绘制之前，让我们检查一下画布对象中的<code class="fe kx ky kz la b">drawCircle</code>方法的签名。</p><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bc3c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe kx ky kz la b">cx</code>和<code class="fe kx ky kz la b">cy</code>参数表示X轴和Y轴的交点——这将帮助我们确定圆心。<code class="fe kx ky kz la b">radius</code>参数表示我们圆的一半宽度，最后是我们熟悉的<code class="fe kx ky kz la b">paint</code>物体。请看下面的图形表示，了解更多的上下文。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/20f429176096510f802ecd6ab0f3231c.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*8pg2vXjHoQ5GDlcxziuzCw.png"/></div></figure><p id="ce9f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，我们需要我们的<code class="fe kx ky kz la b">X</code>和<code class="fe kx ky kz la b">Y</code>值。这些线的交点表示圆的中心，而<code class="fe kx ky kz la b">r</code>表示半径——圆宽度的一半。</p><h2 id="fe04" class="lb lc jc bd ld le lf dn lg lh li dp lj kk lk ll lm ko ln lo lp ks lq lr ls lt bi translated">现在，我们抽签！</h2><figure class="mr ms mt mu gt ip"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="70df" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，<strong class="kb jd">我们从视图的总宽度中减去75px，因此它位于屏幕的末端，我们的Y值位于视图顶部的75px处。我们的半径是75px，所以我们正好有足够的空间。我们还传入我们的paint对象来应用红色</strong>。结果如下所示，我们最初绘制的矩形。</p><figure class="mr ms mt mu gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi od"><img src="../Images/40e59d7f59d1baaad5d760bee379d42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3M1GVNbBZYaeGNZ8_A4Ow.png"/></div></div></figure><h1 id="baf6" class="nh lc jc bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">包裹</h1><p id="1271" class="pw-post-body-paragraph jz ka jc kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">这是这一部分的结尾，我们已经讲述了绘制自定义视图的要点，并且我们已经实验了矩形和圆形。在下一部分中，我们将通过学习canvas翻译来更深入地研究canvas对象，并为我们的自定义视图添加一些动态性。如果你有任何问题，欢迎在下面留言或在twitter上给我发信息。</p><p id="e4ca" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢阅读！。😊</p></div></div>    
</body>
</html>