<html>
<head>
<title>No, Docker isn’t Dead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不，多克没有死</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/no-docker-isnt-dead-2b9ee45d5833?source=collection_archive---------1-----------------------#2020-12-05">https://blog.devgenius.io/no-docker-isnt-dead-2b9ee45d5833?source=collection_archive---------1-----------------------#2020-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="adea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，Kubernetes 是在贬低 Docker 的支持，但它的影响可能没有听起来那么戏剧性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d24903a39509925630a5abd1b91b8409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18Osxj7Q9NzR-94dpYDI0A.png"/></div></div></figure><p id="53f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候一条推文就足以让人关注。随着 Kubernetes v1.20 即将发布，Kubernetes SIG 安全联席主席<a class="ae kx" href="https://twitter.com/IanColdwater" rel="noopener ugc nofollow" target="_blank">伊恩·科尔德沃特</a>在 Twitter 上扔了一颗炸弹，让 Kubernetes 社区陷入混乱:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="814c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这条推文淹没了对 1.20 版本的其他报道，详细介绍了一些不错的改进，如<a class="ae kx" href="https://sysdig.com/blog/whats-new-kubernetes-1-20/" rel="noopener ugc nofollow" target="_blank">节点的优雅关闭</a>和<a class="ae kx" href="https://sysdig.com/blog/whats-new-kubernetes-1-20/" rel="noopener ugc nofollow" target="_blank">高效重启</a>。巨大的混乱随之而来，直到两个新的博客帖子出来澄清反对通知:</p><ul class=""><li id="3ac5" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated"><a class="ae kx" href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener ugc nofollow" target="_blank">别慌:Kubernetes 和 Docker </a></li><li id="1147" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><a class="ae kx" href="https://kubernetes.io/blog/2020/12/02/dockershim-faq/" rel="noopener ugc nofollow" target="_blank"> Dockershim 反对常见问题解答</a></li></ul><p id="838d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，对 Docker API 和 Kubernetes 容器运行时接口(CRI)之间的桥梁<em class="lo"> dockershim 的支持正在被放弃，取而代之的是其他 CRI，如<a class="ae kx" href="https://github.com/containerd/containerd/" rel="noopener ugc nofollow" target="_blank"> containerd </a>和<a class="ae kx" href="https://github.com/cri-o/cri-o" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>。这意味着通过<code class="fe lp lq lr ls b">docker build</code>构建的现有 Docker 映像将继续工作(以及其他构建选项，如<a class="ae kx" href="https://github.com/genuinetools/img" rel="noopener ugc nofollow" target="_blank"> img </a>、<a class="ae kx" href="https://github.com/containers/buildah" rel="noopener ugc nofollow" target="_blank"> buildah </a>或<a class="ae kx" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> kaniko </a>)，但 Docker 运行时(提取和运行您的映像的组件)将在 2021 年末的 1.22 版本中删除。</em></p><h1 id="efd1" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">等等，什么？</h1><p id="74c1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果您仍然感到困惑，这可能是因为随着时间的推移，Docker 已经成为容器的同义词，尽管它实际上是指整个技术栈。Docker 是在 Kubernetes 之前推出的，用来普及 Linux 容器模式。这意味着 Docker 最初设计时没有考虑到 Kubernetes，留下了一些不兼容的部分和一些多余的部分。</p><p id="d0cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，Kubernetes 是一个容器编排器，旨在与 Docker 之外的更广泛的容器生态系统合作。在考察 Docker 架构时，Kubernetes 实际上只使用了 Docker 技术栈的一小部分:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/c597d7195df77372b5ec1c89e6ee0d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1jg8fBv2rlbwzhVt.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图片来源:<a class="ae kx" href="https://dev.to/inductor/wait-docker-is-deprecated-in-kubernetes-now-what-do-i-do-e4m" rel="noopener ugc nofollow" target="_blank">太田康平</a></figcaption></figure><p id="fab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最关键的是 containerd，Docker 用来拉取和运行图像的容器运行时元素。不幸的是，Docker 目前不支持 Kubernetes 的 CRI 标准，因此 Kubernetes 的维护人员编写了一个层来支持这一点(dockershim)。然而，dockershim 是一个临时解决方案，长期维护成为一个问题，因为它变得与新功能(如 cgroups v2、用户名称空间)不兼容。这就是为什么 Kubernetes 的维护者不支持 dockershim(因此也不支持 Docker ),而是鼓励迁移到符合 CRI 的运行时。</p><p id="ac8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这对你意味着什么呢？</p><h1 id="5802" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">对于开发人员</h1><p id="6720" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">好消息是，一切都不会改变。最有可能的是，你和 Docker 的互动是本地发展和建立 Docker 形象。Docker 构建的映像是开放容器倡议(OCI)兼容的映像，Kubernetes 支持的其他运行时知道如何获取和运行该映像。</p><p id="e9ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用 Docker 插座(<code class="fe lp lq lr ls b">/var/run/docker.sock</code>)，可能会出现边缘情况。Docker 中的 Docker 场景(可能是用 Gitlab 运行人员在一个开发集群上运行集成测试)。在这种情况下，寻找替代的容器解决方案，如<a class="ae kx" href="https://github.com/genuinetools/img" rel="noopener ugc nofollow" target="_blank"> img </a>、<a class="ae kx" href="https://github.com/containers/buildah" rel="noopener ugc nofollow" target="_blank"> buildah </a>或<a class="ae kx" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> kaniko </a>。</p><h1 id="47b1" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">对于 Kubernetes 管理员</h1><p id="1900" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果您正在管理一个 Kubernetes 集群，您将需要在 2021 年末的 v1.22 版本之前用一个兼容 CRI 的运行时来替换 Docker，比如 containerd 或 CRI-O(或<a class="ae kx" href="https://landscape.cncf.io/category=container-runtime&amp;format=card-mode&amp;grouping=category" rel="noopener ugc nofollow" target="_blank">其他 CNCF 替代品</a>)(v 1.20 将只显示一个警告)。好消息是，托管的 Kubernetes 提供商如 GKE 和 AKS 已经支持 containerd，EKS 很可能会跟进，因为 Fargate 已经支持 containerd。充分的测试是必要的，但是迁移到 containerd 应该相对容易，因为 Docker 也在底层使用 containerd。</p><h1 id="82d5" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="dac1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">长话短说，没必要恐慌。Kubernetes 将继续使用您现有的 Docker 容器，Kubernetes 管理员还有几个月的时间来推出必要的更改。Dockershim 要走了，但是 Docker 没有死。</p></div></div>    
</body>
</html>