<html>
<head>
<title>Top 4 Must Know Algorithms for Software Engineers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程师必须知道的算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-four-must-know-algorithms-for-software-engineers-ae54328b5d4d?source=collection_archive---------3-----------------------#2022-07-14">https://blog.devgenius.io/top-four-must-know-algorithms-for-software-engineers-ae54328b5d4d?source=collection_archive---------3-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1a1e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="eabd" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">老实说，我并不热衷于算法，但这些算法是值得的</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5d641fde128a3f23991d7548b56a3289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZO8QjCVWqw_8Rwai"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Michael Dziedzic 在 Unsplash 上的照片</figcaption></figure><h2 id="ea9f" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">概观</h2><p id="a66a" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">我是美国一家大型科技公司的软件工程师。然而，老实说，我对数据结构和算法不太感兴趣。尤其是，我讨厌 Leetcode 中的编码问题格式。如果你和我的情况一样，我认为这篇文章对你有帮助，因为我将分享我的方法，以确保你仍然可以知道软件工程师必须知道的最重要的算法。我相信这些算法对任何软件工程师来说都足够好，可以在从小到大的许多软件项目中工作，而不会遇到任何问题。</p><h2 id="d9d5" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">1.搜索</h2><p id="b085" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">搜索算法是在数据集合中寻找一个项目。以下是流行的搜索算法。</p><p id="8ad7" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">直线搜索</em> </strong></p><p id="7f10" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这种搜索的思想是顺序遍历输入数据集合中的每个元素。线性搜索的简单方法:</p><ul class=""><li id="25a7" class="mz na iq mc b md mt mg mu lo nb ls nc lw nd ms ne nf ng nh bi translated">从数据收集的第一个元素开始，逐一比较搜索元素与数据收集的每个元素。</li><li id="0fa1" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">如果搜索元素与数据集合中的元素匹配，则返回该元素在数据集合中的索引</li><li id="79fe" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">如果搜索元素与任何元素都不匹配，则返回 invalid。</li></ul><p id="9401" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个线性搜索的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">线性搜索 Java 代码</figcaption></figure><p id="7e01" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">请注意，实际上很少使用线性搜索，因为与其他搜索算法相比，其时间复杂度不是很高。线性搜索的时间复杂度为 O(n)。</p><p id="5cbe" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">二分搜索法</em> </strong></p><p id="90a8" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">二分搜索法是一种在排序数组中使用的搜索算法，通过重复地将搜索区间分成两半。</p><p id="2f93" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是执行二分搜索法的想法:</p><ul class=""><li id="e036" class="mz na iq mc b md mt mg mu lo nb ls nc lw nd ms ne nf ng nh bi translated">从整个数据集合的中间元素开始作为搜索关键字。</li><li id="9cbc" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">如果搜索关键字的值等于该项，则返回搜索关键字的索引。</li><li id="e4a8" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">或者，如果搜索关键字的值小于间隔中间的项目，则将间隔缩小到下半部分。</li><li id="69ea" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">否则，缩小到上半部分。</li><li id="19fd" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">从第二点开始重复检查，直到找到值或间隔为空。</li></ul><p id="7c1a" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个用于二分搜索法的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">二分搜索法 Java 代码</figcaption></figure><p id="04d3" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">请注意，我们需要确保在应用二分搜索法之前对数据集合进行排序。二分搜索法的时间复杂度为 O(Log n)。</p><p id="d30a" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">广度优先搜索(BFS) </em> </strong></p><p id="873d" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">BFS 是一种图形遍历算法，它从根节点开始，搜索所有相邻节点。然而，图可能包含循环，因此我们可能再次访问图中的相同节点。为了避免这种情况，我们使用布尔访问数组。</p><p id="1207" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个在 BFS 遍历的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">BFS Java 代码</figcaption></figure><p id="17c3" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">BFS 的时间复杂度是 O(V+E ),其中 V 是节点数，E 是边数。</p><p id="ae16" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">【深度优先搜索】</em> </strong></p><p id="05f3" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">DFS 从根节点开始，在回溯之前尽可能地沿着图的每个分支探索，以检查其他未标记的节点并遍历它们。最后，打印路径中的节点。</p><p id="da6f" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个在 DFS 中遍历的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">DFS Java 代码</figcaption></figure><p id="bdb1" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">DFS 的时间复杂度为 O(V+E ),其中 V 是节点数，E 是边数。</p><h2 id="e651" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">2.整理</h2><p id="7e77" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">气泡排序</em> </strong></p><p id="bef1" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">冒泡排序<strong class="mc ja"> </strong>是最简单的排序算法，如果相邻元素的顺序错误，它会重复交换相邻元素。以下是冒泡排序的步骤(升序):</p><ol class=""><li id="dfeb" class="mz na iq mc b md mt mg mu lo nb ls nc lw nd ms np nf ng nh bi translated">从第一个元素(index = 0)开始，将当前元素与数据集合的下一个元素进行比较。</li><li id="99a3" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms np nf ng nh bi translated">如果当前元素大于数组的下一个元素，则交换它们。</li><li id="c4f1" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms np nf ng nh bi translated">如果当前元素小于下一个元素，则移动到下一个元素。<em class="my">重复步骤 1。</em></li></ol><p id="3132" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个用于冒泡排序的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">冒泡排序 Java 代码</figcaption></figure><p id="80c1" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">请注意，冒泡排序在实际项目中很少使用，因为与其他排序算法相比，它的时间复杂度不是很高。冒泡排序的时间复杂度为 O(n)。</p><p id="7075" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">快速排序</em> </strong></p><p id="cc70" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个分治算法。它选取一个元素作为轴心，并在选取的轴心周围划分给定的数组。</p><p id="0cad" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个快速排序的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">快速排序 Java 代码</figcaption></figure><p id="0e5a" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">快速排序的时间复杂度为 O(n*logn)。</p><p id="71bc" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja"> <em class="my">合并排序</em> </strong></p><p id="1d55" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这也是一个分治算法。其思想是将数据集合分成相等的两半，然后以排序的方式组合它们。以下是合并排序的步骤:</p><ul class=""><li id="6671" class="mz na iq mc b md mt mg mu lo nb ls nc lw nd ms ne nf ng nh bi translated">将左侧变量声明为 0，将右侧变量声明为 n-1</li><li id="de03" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">找到中间值。mid =(左+右)/2</li><li id="f174" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">调用合并排序打开(左，中)</li><li id="4ba1" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">调用合并排序 on (mid+1，右)</li><li id="b13e" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">继续，直到左小于右</li><li id="5e76" class="mz na iq mc b md ni mg nj lo nk ls nl lw nm ms ne nf ng nh bi translated">然后调用 merge 函数进行合并排序。</li></ul><p id="ac8b" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个用于合并排序的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">合并排序 Java 代码</figcaption></figure><p id="1654" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">归并排序的时间复杂度为 O(n*logn)。</p><h2 id="70e3" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">3.动态规划</h2><p id="75c9" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">动态编程主要是对基本递归的优化。在代码中，如果我们看到一个递归解决方案重复了对相同输入的函数调用，我们可以使用动态编程来优化它。</p><p id="b7b3" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">该算法的思想是简单地存储子问题的结果，这样我们就不必在以后需要时重新计算它们。DP 有很多好处，可以解决实际项目中的很多问题。然而，为了简单起见，让我们举一个简单的例子，用简单的递归和 DP 来求解这个斐波那契数。</p><p id="8c46" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">斐波那契数列是以下整数序列中的数字。<br/> <em class="my"> 0，1，1，2，3，5，8，13，21，34，55，89，144 等。</em></p><p id="3ae7" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">我们的问题很简单，给定一个数 x，打印第 x 个斐波那契数。例如:</p><p id="d96d" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><em class="my"> x=10，打印 55 </em></p><p id="043f" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><em class="my"> x=11，打印 89 </em></p><p id="af78" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是一个通过递归解决上述问题的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">递归方法</figcaption></figure><p id="b2ef" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">这是用 DP 解决上述问题的 Java 示例代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">动态规划方法</figcaption></figure><p id="e55a" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">在 DP 中，我们通过存储迄今为止计算的斐波那契数来避免递归方法中的重复任务。</p><h2 id="4056" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">4.各个击破</h2><p id="6698" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">分治算法递归地将一个问题分解成同一个相关问题的两个或多个子问题，直到这些问题变得足够简单，可以直接解决。最后，子问题的输出然后被组合以给出原始问题的最终解决方案。在这个算法中，我们分为三个部分:</p><p id="da18" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja">划分:</strong>这包括将问题划分成更小的相关子问题。</p><p id="d03e" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja">征服:</strong>通过递归调用解决子问题，直到问题解决。</p><p id="f626" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><strong class="mc ja">合并:</strong>将子问题合并，得到整个问题的最终解。</p><p id="ddda" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">分治算法是许多问题的有效算法的基础，例如排序、寻找最近的点对等。要用简单的方法解释这个算法，可以参考上面的合并排序。该算法将数组分成两半，对它们进行递归排序，最后合并排序后的两半。</p><h2 id="17b4" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">摘要</h2><p id="533f" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">作为一名软件工程师，我们不会在日常工作中实现上述复杂性算法。然而，我认为，如果我们有知识，并了解它们是如何工作的，将有助于我们解决很多问题。在本文中，我们探讨了软件工程师必须知道的四大算法。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="ace7" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated">如果你喜欢这个故事，请<a class="ae le" href="https://medium.com/@techisbeautiful" rel="noopener">关注</a>，<a class="ae le" href="https://medium.com/subscribe/@techisbeautiful" rel="noopener">让我</a>成为第一个收到我下一个故事邮件的人。</p><p id="9af3" class="pw-post-body-paragraph ma mb iq mc b md mt ka mf mg mu kd mi lo mv mk ml ls mw mn mo lw mx mq mr ms ij bi translated"><a class="ae le" href="https://medium.com/@techisbeautiful/membership" rel="noopener">你可以在这里</a>成为媒介会员，可以<strong class="mc ja">无限制访问</strong>媒介平台上的每一个故事。如果你使用上面的链接，它也支持我，因为我有一个来自 Medium 的小佣金。谢谢大家！</p></div></div>    
</body>
</html>