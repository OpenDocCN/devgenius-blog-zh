<html>
<head>
<title>.NET 5 Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET 5预览版</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/net-5-preview-13fc5ccf103f?source=collection_archive---------16-----------------------#2020-07-05">https://blog.devgenius.io/net-5-preview-13fc5ccf103f?source=collection_archive---------16-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc1af22691fa6a414e5fa025bc19f3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPLs8lZHDjtbkjo93sH99A.png"/></div></div></figure><h1 id="201a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">1.C# 9</h1><p id="6df4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">C# 9将有许多特性，包括记录、顶级语句、改进的模式匹配等等。<br/> <strong class="kv io">在此阅读更多</strong>:<a class="ae lr" href="https://medium.com/dev-genius/c-9-early-review-5bcd88296c54" rel="noopener">https://medium.com/dev-genius/c-9-early-review-5bcd88296c54</a></p><h1 id="54a1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">2.F# 5</h1><p id="6679" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">F# 5将会有F#脚本的包引用，增强的切片，<code class="fe ls lt lu lv b">nameof</code>函数以及更多的新特性和改进。<br/> <strong class="kv io">此处阅读更多:</strong> <br/> 1。<a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-f-5-preview-1/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/announding-f-5-preview-1/</a><br/>2 .<a class="ae lr" href="https://devblogs.microsoft.com/dotnet/f-5-update-for-net-5-preview-4/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/f-5-update-for-net-5-preview-4/</a></p><h1 id="c438" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">3.正则表达式性能改进</h1><h2 id="51b0" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 1。字符</strong></h2><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="9815" class="lw jw in lv b gy mq mr l ms mt">private Regex _regex = new Regex("[a-zA-Z0-9]*", RegexOptions.Compiled);<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch("abcdefghijklmnopqrstuvwxyz123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/24129faa10dc1d7ad772ffddd6942f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMHVfw5qYcrK99QcWRfpRw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">字符差异</figcaption></figure><h2 id="33ad" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 2。基于跨度的</strong></h2><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="6f1c" class="lw jw in lv b gy mq mr l ms mt">private Regex _regex = new Regex("hello.*world", RegexOptions.Compiled);<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch("hello.  this is a test to see if it's able to find something more quickly in the world.");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/997263d4f97b9d3919b58096a139803f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KERFxc21iFLSp33NFV3few.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">基于跨度的差异</figcaption></figure><h2 id="351f" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 3。基于阵列的</strong></h2><p id="5a96" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">基于数组的字符:</p><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="5c8a" class="lw jw in lv b gy mq mr l ms mt">private static Random s_rand = new Random(42);<br/>    <br/>private Regex _regex = new Regex("([ab]cd|ef[g-i])jklm", RegexOptions.Compiled);</span><span id="1781" class="lw jw in lv b gy na mr l ms mt">private string _input = string.Concat(Enumerable.Range(0, 1000).Select(_ =&gt; (char)('a' + s_rand.Next(26))));<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch(_input);</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/cd61047569b43cfeac8d7417ceacc2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NC4ieAXVfotbHo_K017e1A.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">基于数组的字符差异</figcaption></figure><p id="1b20" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">基于数组的数字:</p><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="2842" class="lw jw in lv b gy mq mr l ms mt">private readonly Regex _regex = new Regex("[0-9]{3}-[0-9]{2}-[0-9]{4}", RegexOptions.Compiled);<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch("123-45-678");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/ab5e963020b4b0d761df06f9b25d2119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKVGHzy18PvrmQfSIqgz0g.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">基于数组的数字差分</figcaption></figure><h2 id="9c68" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 4。基于回溯的</strong></h2><p id="c9ec" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">任意数量的子查询:</p><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="f940" class="lw jw in lv b gy mq mr l ms mt">private Regex _regex = new Regex("a*a*a*a*a*a*a*b", RegexOptions.Compiled);<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch("aaaaaaaaaaaaaaaaaaaaa");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/48040576fcf5076b85811b10a21e5054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2EPLNKsc7Jv63ElILDoag.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">基于回溯的差异</figcaption></figure><p id="505b" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">任何符号:</p><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="334d" class="lw jw in lv b gy mq mr l ms mt">private readonly Regex _regex = new Regex(@".*text", RegexOptions.Compiled);<br/>    <br/>public bool IsMatch() =&gt; _regex.IsMatch("This is a test.\nDoes it match this?\nWhat about this text?");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/b2333ee2da77a7c682100e7c888de300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBADfb-PT4rup1ntp4rasg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">基于回溯的任意符号差</figcaption></figure><h2 id="ac8a" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 5。并发优化:</strong></h2><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="ddc1" class="lw jw in lv b gy mq mr l ms mt">Parallel.Invoke(<br/>            () =&gt; { while (true) Regex.IsMatch("abc", "^abc$"); },<br/>            () =&gt; { while (true) Regex.IsMatch("def", "^def$"); },<br/>            () =&gt; { while (true) Regex.IsMatch("ghi", "^ghi$"); },<br/>            () =&gt; { while (true) Regex.IsMatch("jkl", "^jkl$"); });</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/4c4ce8296f38bcec3ed48943321c422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M3KcKMUOoJZY_9FU.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">。网络核心3.1</figcaption></figure><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/bd22a933bc4e4fe11e266c74dae1f695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J2ODCnPbWZOR2TOY.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">。网络5</figcaption></figure><h2 id="587d" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 6。替换优化:</strong></h2><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="81ee" class="lw jw in lv b gy mq mr l ms mt">private Regex _regex = new Regex("a", RegexOptions.Compiled);<br/>private string _input = string.Concat(Enumerable.Repeat("abcdefghijklmnopqrstuvwxyz", 1_000_000));<br/>    <br/>public string Replace() =&gt; _regex.Replace(_input, "A");</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/489c3466ea749d6e7e57d941ae4fec2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fs_WTpWDjg4L5Qt9DZB6QA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">更换速度差</figcaption></figure><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/842674208fc84040b271ccf570c3e6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOn9o8syDS47nZnpCL4czQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">替换内存分配差异</figcaption></figure><p id="acc6" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">在这里阅读更多:</strong><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/regex-performance-improvements-in-net-5/</a></p><h1 id="40d0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">4.提高字符串的性能。ToUpperInvariant，string。ToLowerInvariant，char。ToUpperInvariant，char。ToLowerInvariant和其他相关模式</h1><ol class=""><li id="9972" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated">通过将<code class="fe ls lt lu lv b">string.ToUpperInvariant</code>、<code class="fe ls lt lu lv b">string.ToLowerInvariant</code>、<code class="fe ls lt lu lv b">char.ToUpperInvariant</code>、<code class="fe ls lt lu lv b">char.ToLowerInvariant</code>直接绑定到正确的<code class="fe ls lt lu lv b">TextInfo</code>实例来提高它们的性能，而不是通过<code class="fe ls lt lu lv b">CultureInfo.Invariant</code>跳跃。</li><li id="f402" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">尽可能在调用点避免解引用<code class="fe ls lt lu lv b">CultureInfo.InvariantCulture</code>,使用特定于不变量的代码路径。</li><li id="2e36" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">更换图案<code class="fe ls lt lu lv b">if (string.Trim().Length != 0)</code>以使用<code class="fe ls lt lu lv b">string.IsNullOrWhiteSpace</code>代替。</li><li id="b7d0" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">替换不正确使用文化感知<code class="fe ls lt lu lv b">string.ToUpper</code> / <code class="fe ls lt lu lv b">string.ToLower</code>的调用站点，改为使用<code class="fe ls lt lu lv b">ToUpperInvariant</code> / <code class="fe ls lt lu lv b">ToLowerInvariant</code>。</li><li id="8091" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">替换不正确地使用文化感知<code class="fe ls lt lu lv b">string.IndexOf(...)</code>的调用站点，使用<code class="fe ls lt lu lv b">string.IndexOf(..., StringComparison.Ordinal)</code>来代替。</li><li id="625a" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">替换不正确使用区分区域性的<code class="fe ls lt lu lv b">string.StartsWith(...)</code> / <code class="fe ls lt lu lv b">string.EndsWith(...)</code>的调用站点，改为使用序数<code class="fe ls lt lu lv b">string.StartsWith(..., StringComparison.Ordinal)</code> / <code class="fe ls lt lu lv b">string.EndsWith(..., StringComparison.Ordinal)</code>。</li><li id="02f1" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">如果一个项目专门针对。网芯最新，把<code class="fe ls lt lu lv b">string.IndexOf("x", StringComparison.Ordinal)</code>改成<code class="fe ls lt lu lv b">string.IndexOf('x')</code>。</li></ol><h1 id="59e4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">5.HTTP 1.1和HTTP/2性能改进</h1><ol class=""><li id="51dd" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/corefx/pull/41640" rel="noopener ugc nofollow" target="_blank"> HTTP 1.1 SocketsHttpHandler性能</a></li><li id="0546" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35694" rel="noopener ugc nofollow" target="_blank"> HTTP/2伸缩性能</a></li></ol><h1 id="d24d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">6.系统。Json的改进</h1><ol class=""><li id="c8ec" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/655" rel="noopener ugc nofollow" target="_blank">增加对JSON dotnet/runtime #655 </a>上保留引用的支持——<a class="ae lr" href="https://github.com/dotnet/runtime/issues/29900" rel="noopener ugc nofollow" target="_blank">启用</a> <code class="fe ls lt lu lv b"><a class="ae lr" href="https://github.com/dotnet/runtime/issues/29900" rel="noopener ugc nofollow" target="_blank">ReferenceLoopHandling</a></code>，这是JSON.NET序列化的关键特性之一。</li><li id="3bfd" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33459" rel="noopener ugc nofollow" target="_blank">添加新系统。net . http . Json project/namespace dot net/runtime # 33459</a>—为HttpClient添加了<a class="ae lr" href="https://github.com/dotnet/runtime/issues/32937" rel="noopener ugc nofollow" target="_blank">新的扩展方法，允许从/到JSON的序列化</a>。</li><li id="740b" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33444" rel="noopener ugc nofollow" target="_blank">添加</a> <code class="fe ls lt lu lv b"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33444" rel="noopener ugc nofollow" target="_blank">JsonConstructor</a></code> <a class="ae lr" href="https://github.com/dotnet/runtime/pull/33444" rel="noopener ugc nofollow" target="_blank">并支持使用参数化的构造器进行反序列化dotnet/runtime #33444 </a> —向JsonSerializer添加对不可变类和结构的支持。</li><li id="105d" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">添加JsonIgnoreCondition】每属性忽略逻辑# 34049-添加对空值处理的支持，这是JSON.NET序列化的另一个特性。</li><li id="7fb4" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34725" rel="noopener ugc nofollow" target="_blank">将复制构造函数添加到JsonSerializerOptions </a> —使框架库能够管理一个<code class="fe ls lt lu lv b">JsonSerializerOptions</code>实例，使用它设置的特定值，同时类型随时间变化。</li><li id="2c00" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34675" rel="noopener ugc nofollow" target="_blank">添加对非公共访问器的JsonIncludeAttribute &amp;支持</a> —启用非公共getter用法，这类似于Newtonsoft的功能。Json <code class="fe ls lt lu lv b">JsonProperty</code>属性。</li></ol><h1 id="d311" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">7.垃圾收集工</h1><ol class=""><li id="7f1e" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/coreclr/pull/25986" rel="noopener ugc nofollow" target="_blank">卡片标记窃取— dotnet/coreclr #25986 </a> —服务器GC(在不同线程上)现在可以在标记由老一代对象保持活动的gen0/1对象时进行工作窃取。这意味着短暂的GC暂停在某些GC线程比其他线程花费更长时间来标记的情况下会更短。</li><li id="06e0" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32283" rel="noopener ugc nofollow" target="_blank">引入固定对象堆— dotnet/runtime #32283 </a> —实现了POH(固定对象堆)特性的一部分—GC的内部部分。这个新堆(本质上是LOH的对等体)将允许GC单独管理固定对象，从而避免固定对象对分代堆的负面影响。</li><li id="26f4" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/2103" rel="noopener ugc nofollow" target="_blank">允许在后台清理SOH时从空闲列表分配大对象— dotnet/runtime #2103 </a> —在BGC清理SOH时，使用空闲列表启用LOH分配。以前，这只是在LOH上使用段尾空间。这允许更好地使用堆。</li><li id="0e68" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/coreclr/pull/27729" rel="noopener ugc nofollow" target="_blank">后台GC挂起修复— dotnet/coreclr #27729 </a> —挂起修复减少了BGC和用户线程被挂起的时间。这减少了在GC发生之前挂起托管线程所需的总时间。<a class="ae lr" href="https://github.com/dotnet/coreclr/pull/27578" rel="noopener ugc nofollow" target="_blank"> dotnet/coreclr #27578 </a>也促成了同样的结果。</li><li id="9d4f" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/980" rel="noopener ugc nofollow" target="_blank">修复docker-dot net/runtime # 980</a>中的命名cgroup处理-添加了对从命名c group读取限制的支持。以前我们只从全局中读取。</li></ol><h1 id="d1c6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">8.的Windows窗体设计器。网络核心</h1><ol class=""><li id="c8b6" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated">除了<code class="fe ls lt lu lv b">DataGridView</code>和<code class="fe ls lt lu lv b">ToolStripContainer</code>之外的所有Windows窗体控件</li><li id="37ef" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe ls lt lu lv b">UserControl</code>和自定义控件基础架构</li><li id="4916" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">所有设计器功能，如<br/> 3.1拖放<br/> 3.2选择、移动和调整大小<br/> 3.3剪切/复制/粘贴/删除<br/> 3.4与属性窗口的集成<br/> 3.5事件生成等等</li><li id="e7ee" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">新的<code class="fe ls lt lu lv b">WebView2</code>控件<br/>这个基于chromium的嵌入式浏览器控件允许为。网络应用。两者都支持它。网芯和。用于Windows窗体和WPF应用程序的. NET Framework平台。你可以在微软文档中找到<a class="ae lr" href="https://docs.microsoft.com/microsoft-edge/webview2/gettingstarted/winforms" rel="noopener ugc nofollow" target="_blank">入门教程</a>。</li><li id="3714" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">当地资源</li><li id="bd7d" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">部分支持本地化:<br/> 6.1控件和UserControl的可本地化属性可以序列化为ResX文件(通过将<code class="fe ls lt lu lv b">Localizable</code>属性设置为<code class="fe ls lt lu lv b">true</code>)。<br/> 6.2通过改变<code class="fe ls lt lu lv b">Language</code>属性支持不同的语言。<br/> 6.3在的预览中增加了额外的<code class="fe ls lt lu lv b">Cultures</code>。NET 5，符合Unicode国际组件标准(ICU)。</li><li id="2dee" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">控件支持:<br/> 7.1所有对话框控件<br/>7.2<code class="fe ls lt lu lv b">PropertyGrid</code><br/>7.3<code class="fe ls lt lu lv b">HScrollBar</code><br/>7.4<code class="fe ls lt lu lv b">VScrollBar<br/></code>7.5<code class="fe ls lt lu lv b">DomainUpDown</code><br/>7.6<code class="fe ls lt lu lv b">TrackBar</code><br/>7.7<code class="fe ls lt lu lv b">TableLayoutPanel</code><br/>7.8第三方控件基础支持<br/> 7.9数据绑定基础支持<br/> 7.10设计器与<code class="fe ls lt lu lv b">TableLayoutPanel</code> <br/> 7.11 <a class="ae lr" href="https://github.com/dotnet/winforms/issues/3067" rel="noopener ugc nofollow" target="_blank">折叠的改进这一</a><a class="ae lr" href="https://github.com/dotnet/winforms/pull/3155" rel="noopener ugc nofollow" target="_blank">变化</a>使得管理具有多个<code class="fe ls lt lu lv b">ListViewGroups</code>的表单变得更加容易</li></ol><p id="ecb0" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">在这里阅读更多:</strong><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/windows-forms-designer-for-net-core-released/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/windows-forms-designer-for-net-core-released/</a></p><h1 id="a021" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">9.C#源代码生成器</h1><p id="db80" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">源代码生成器是C#开发人员可以编写的一种新的组件，它让您可以做两件主要的事情:</p><ol class=""><li id="b760" class="nn no in kv b kw nc la nd le ob li oc lm od lq ns nt nu nv bi translated">检索一个代表所有正在编译的用户代码的<em class="oe">编译</em>对象。这个对象可以被检查，你可以为正在编译的代码编写使用语法和语义模型的代码，就像现在的分析器一样。</li><li id="e8b1" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">生成C#源文件，可以在编译过程中添加到<em class="oe">编译</em>对象中。换句话说，您可以在编译代码时提供额外的源代码作为编译的输入。</li></ol><p id="a26f" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">当这两者结合在一起时，源代码生成器就变得如此有用。您可以使用编译器在编译期间构建的所有丰富元数据来检查用户代码，然后将C#代码发送回基于您所分析的数据的相同编译中！如果您熟悉Roslyn分析器，您可以将源生成器视为可以发出C#源代码的分析器。</p><p id="9d6d" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">源代码生成器作为编译的一个阶段运行，如下图所示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/b611c966083ff1272cf6df3fd16d7406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ipjzb6I80bBqlHCm.png"/></div></div></figure><p id="064f" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">关于源代码生成器的更多信息:</strong><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/introducing-c-source-generators/</a></p><h1 id="a36c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">10.[突破性变化]删除内置的WinRT支持。NET 5.0</h1><p id="e029" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">内置的WinRT支持已经被Windows团队提供的<a class="ae lr" href="https://docs.microsoft.com/windows/uwp/csharp-winrt/" rel="noopener ugc nofollow" target="_blank"> C#/WinRT </a>工具链所取代。NET 5.0。WinRT互操作中的这个<a class="ae lr" href="https://github.com/dotnet/runtime/issues/37672" rel="noopener ugc nofollow" target="_blank">变化是一个突破性的变化</a>，并且。使用WinRT的NET Core 3.x应用程序需要重新编译。</p><p id="aaa3" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">的<a class="ae lr" href="https://github.com/dotnet/runtime/issues/35318" rel="noopener ugc nofollow" target="_blank">支持WinRT APIs中介绍了这些优势。网络5 </a>:</p><ul class=""><li id="a134" class="nn no in kv b kw nc la nd le ob li oc lm od lq og nt nu nv bi translated">WinRT互操作可以独立于。NET运行时。</li><li id="b37a" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated">使WinRT互操作与为其他操作系统(如iOS和Android)提供的互操作系统对称。</li><li id="d552" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated">可以利用许多其他优势。NET功能(AOT、C#功能、IL链接)。</li><li id="1eb4" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated">简化了。NET运行时代码库(<a class="ae lr" href="https://github.com/dotnet/runtime/pull/36715" rel="noopener ugc nofollow" target="_blank">删除60k行代码</a>)。</li></ul><p id="1051" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">详见</strong><a class="ae lr" href="https://github.com/dotnet/docs/issues/18875" rel="noopener ugc nofollow" target="_blank">https://github.com/dotnet/docs/issues/18875</a>发布的正式文件。</p><h1 id="b1c0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">11.Windows ARM64</h1><p id="66d3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">。NET应用程序现在可以在Windows ARM64上本地运行。这是在中添加了对Linux ARM64 的支持之后。网芯3.0。与。NET 5.0，你可以在Windows ARM64设备上开发web和UI应用，并将你的应用交付给拥有<a class="ae lr" href="https://www.microsoft.com/en-us/p/surface-pro-x/8VDNRP2M6HHC" rel="noopener ugc nofollow" target="_blank"> Surface Pro X </a>和类似设备的用户。你已经可以跑了。网芯和。Windows ARM64上的. NET Framework应用程序，但通过x86仿真。这是可行的，但原生ARM64执行有更好的性能。</p><p id="e869" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">阅读更多关于性能优化的内容:</strong> <br/> 1。<a class="ae lr" href="https://github.com/dotnet/runtime/issues/33308" rel="noopener ugc nofollow" target="_blank">使用arm64内部函数</a> <br/> 2优化库代码。<a class="ae lr" href="https://github.com/dotnet/runtime/issues/35853" rel="noopener ugc nofollow" target="_blank">提高ARM64的性能。NET 5.0 </a></p><h1 id="192f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">12.RyuJIT改进</h1><ol class=""><li id="de1f" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/1735" rel="noopener ugc nofollow" target="_blank">空检查折叠的改进</a> —通过观察更多可能不需要空检查的模式，在更多情况下不再需要生成空检查。</li><li id="f2a8" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/1463" rel="noopener ugc nofollow" target="_blank">优化的公共子表达式求值(CSE)</a>—JIT查找并折叠只需要求值一次的重复表达式(wiki)。</li><li id="4e58" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/issues/5310" rel="noopener ugc nofollow" target="_blank">优化“常量_字符串”。长度</a> —优化该模式并将代码压缩到正确的整数值。</li><li id="0518" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/1309" rel="noopener ugc nofollow" target="_blank"> JIT:在变形之前构建基本块预测列表</a> —对JIT中的阶段进行重新排序，以允许更早地使用关键优化，从而为后续阶段带来更好的代码质量和更少的工作，这提高了JIT吞吐量(参考PR中的“TP”)。</li><li id="482a" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32538" rel="noopener ugc nofollow" target="_blank">使用xmm for stack prolog—dot net/runtime # 32538</a>—更改为x86/x64 prolog零位代码。改进:<a class="ae lr" href="https://github.com/dotnet/runtime/pull/32538#issuecomment-595503265" rel="noopener ugc nofollow" target="_blank">Json</a>；<a class="ae lr" href="https://github.com/dotnet/runtime/pull/32538#issuecomment-595619687/" rel="noopener ugc nofollow" target="_blank"> TechEmpower </a>。功劳:<a class="ae lr" href="https://github.com/benaadams" rel="noopener ugc nofollow" target="_blank">本·亚当斯</a>。</li><li id="03a6" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/31834" rel="noopener ugc nofollow" target="_blank">为GT_SIMD和GT _ HW内在树节点添加ValueNumbering支持— dotnet/runtime #31834 </a> —为SIMD和硬件内在类型启用优化器。</li><li id="021b" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32641" rel="noopener ugc nofollow" target="_blank">对未使用的间接寻址使用GT _ null check—dot net/runtime # 32641</a>—删除多余的null检查。</li><li id="2de3" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">I <a class="ae lr" href="https://github.com/dotnet/runtime/pull/32269" rel="noopener ugc nofollow" target="_blank"> nvoke nullable box优化较早— dotnet/runtime #32269 </a> —改进对<code class="fe ls lt lu lv b">Nullable&lt;T&gt;</code>的优化。</li><li id="5ca7" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/1644" rel="noopener ugc nofollow" target="_blank">针对各种数组索引模式优化范围检查— dotnet/runtime #1644 </a> —范围检查消除方面的改进。</li><li id="1668" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32790" rel="noopener ugc nofollow" target="_blank">为密封类优化</a><code class="fe ls lt lu lv b"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32790" rel="noopener ugc nofollow" target="_blank">obj.GetType() != typeof(X)</a></code><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32790" rel="noopener ugc nofollow" target="_blank">—dot net/runtime # 32790</a>—对类型检查表达式的改进。</li><li id="b8b8" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/31960" rel="noopener ugc nofollow" target="_blank">更积极地消除重复的零初始化— dotnet/runtime #31960 </a> —消除重复的零初始化的更好和更广泛的方法。</li><li id="bfcb" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/2126" rel="noopener ugc nofollow" target="_blank">早期opts使用的Fix方法和基本块标志— dotnet/runtime #2196 </a> —使得某些优化可以更频繁地使用。例如，用常数替换数组长度现在更常见了。</li><li id="5f1e" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32969" rel="noopener ugc nofollow" target="_blank">实现栈上替换(OSR)的简单版本— dotnet/runtime #32969 </a>。<a class="ae lr" href="https://github.com/dotnet/runtime/blob/master/docs/design/features/OnStackReplacement.md" rel="noopener ugc nofollow" target="_blank">栈上替换(OSR) </a>是一种新功能，它允许在方法执行过程中更改当前运行的方法所执行的代码，而这些方法在“栈上”是活动的。这个特性目前是试验性的和可选的(在x64上)，旨在改进分层编译的更具挑战性的性能特征。请试用并给我们反馈。</li><li id="68ba" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32270" rel="noopener ugc nofollow" target="_blank">动态泛型字典扩展特性dotnet/runtime #32270 </a> —基于改进运行时用来存储泛型类型和方法信息的低级(本机代码)字典的实现，泛型的一些(可能是许多)使用现在有了更好的性能(<a class="ae lr" href="https://github.com/dotnet/runtime/pull/32270#issuecomment-586459130" rel="noopener ugc nofollow" target="_blank">初始性能发现</a>)。请参见<a class="ae lr" href="https://github.com/dotnet/runtime/issues/11971#issuecomment-462183168" rel="noopener ugc nofollow" target="_blank"> Perf: Collection Count()在内核中比CLR </a>慢，了解更多信息。</li><li id="240d" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34221" rel="noopener ugc nofollow" target="_blank"> JIT:允许CORINFO _ HELP _ ready torun _ GENERIC _ HANDLE被优化dotnet/runtime #34221 </a>。提高Ready2Run映像中泛型的代码质量。</li><li id="6188" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33004" rel="noopener ugc nofollow" target="_blank"> JIT:为隐式byref structs #33004 </a>启用尾部调用和复制省略。提高在“尾调用”位置调用中作为参数的结构的代码质量。</li><li id="1094" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/341" rel="noopener ugc nofollow" target="_blank">新的、更快的、可移植的tailcall助手实现</a>。</li><li id="36c9" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35352" rel="noopener ugc nofollow" target="_blank">改进了影响正则表达式编译的JIT速度</a></li><li id="d15e" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34550" rel="noopener ugc nofollow" target="_blank">使用BSF/BSR的新硬件固有特性提高英特尔架构性能</a></li><li id="3760" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33924" rel="noopener ugc nofollow" target="_blank">实现向量{Size}。AllBitsSet </a></li><li id="2886" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36146" rel="noopener ugc nofollow" target="_blank">结构处理改进</a></li><li id="da1d" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36918" rel="noopener ugc nofollow" target="_blank">消除冗余零初始化的优化</a></li></ol><h1 id="ad24" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">13.RyuJIT ARM64改进</h1><ol class=""><li id="d4bf" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33749" rel="noopener ugc nofollow" target="_blank">针对ARM64的矢量BitArray—dot net/runtime # 33749</a>—<a class="ae lr" href="https://docs.microsoft.com/dotnet/api/system.collections.bitarray?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank">BitArray类</a>经过更新，使用<a class="ae lr" href="https://github.com/dotnet/runtime/tree/master/src/libraries/System.Private.CoreLib/src/System/Runtime/Intrinsics/Arm" rel="noopener ugc nofollow" target="_blank"> ARM64 </a>内部函数为ARM64 添加了一个<a class="ae lr" href="https://github.com/dotnet/runtime/blob/8511b5b9cc957ce824fc88c0780249fc0edbef15/src/libraries/System.Collections/src/System/Collections/BitArray.cs#L181" rel="noopener ugc nofollow" target="_blank">硬件加速实现。BitArray的</a><a class="ae lr" href="https://github.com/dotnet/runtime/pull/33749#issuecomment-603597689" rel="noopener ugc nofollow" target="_blank">性能改进</a>非常显著。</li><li id="fbc6" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/31993" rel="noopener ugc nofollow" target="_blank">实现矢量。天花板/向量。floor dot net/runtime # 31993</a>—实现向量。天花板/向量。根据<a class="ae lr" href="https://github.com/dotnet/runtime/issues/20509" rel="noopener ugc nofollow" target="_blank"> API提案</a>，Floor使用x64和ARM64内部函数。</li><li id="d831" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35030" rel="noopener ugc nofollow" target="_blank">实施ASIMD提取插入提取矢量64提取矢量128 </a></li><li id="3bb7" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35612" rel="noopener ugc nofollow" target="_blank">实现ASIMD扩大、缩小、饱和内部函数</a></li><li id="8a0e" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35600" rel="noopener ugc nofollow" target="_blank">添加VectorTableList和TableVectorExtension内部函数</a></li><li id="222f" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34579" rel="noopener ugc nofollow" target="_blank">增加对arm64固有的CreateScalarUnsafe()的支持</a></li><li id="2892" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35590" rel="noopener ugc nofollow" target="_blank"> ARM64对Vector64的内在支持。创建()和Vector128。Create() </a></li><li id="d69f" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35636" rel="noopener ugc nofollow" target="_blank">优化位操作。带有arm64内部函数的PopCount()</a></li><li id="2aa4" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36144" rel="noopener ugc nofollow" target="_blank">实现复制和复制选定的标尺</a></li><li id="813b" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36830" rel="noopener ugc nofollow" target="_blank"> ASIMD移位内在函数</a></li><li id="9405" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36853" rel="noopener ugc nofollow" target="_blank">多项式乘法长内函数</a></li><li id="f5ba" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36267" rel="noopener ugc nofollow" target="_blank">优化Vector64和Vector128。创建方法</a></li><li id="a53c" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36156" rel="noopener ugc nofollow" target="_blank">优化ToScalar()和GetElement()使用arm64固有</a></li><li id="21e3" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36732" rel="noopener ugc nofollow" target="_blank">优化ToVector128，ToVector128Unsafe和Vector128。GetLower() </a></li><li id="e7a9" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/35675" rel="noopener ugc nofollow" target="_blank">针对R2R、Arm和Arm64场景优化间接呼叫</a></li><li id="32fb" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/36817" rel="noopener ugc nofollow" target="_blank">优化R2R和JIT的虚拟调用存根</a></li></ol><h1 id="6daa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">14.膨胀系统。目录服务。Linux和macOS协议</h1><p id="0670" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">对<a class="ae lr" href="https://docs.microsoft.com/dotnet/api/system.directoryservices.protocols" rel="noopener ugc nofollow" target="_blank">系统的跨平台支持。添加了目录服务协议</a>。</p><p id="7785" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><a class="ae lr" href="https://docs.microsoft.com/dotnet/api/system.directoryservices.protocols" rel="noopener ugc nofollow" target="_blank">系统。directory services . Protocols</a>是比<a class="ae lr" href="https://docs.microsoft.com/dotnet/api/system.directoryservices" rel="noopener ugc nofollow" target="_blank">系统更低级的API。DirectoryServices </a>，启用(或者可以用来启用)更多场景。系统。DirectoryServices包括仅Windows的概念/实现，因此跨平台不是一个显而易见的选择。这两个API集都支持控制目录服务服务器并与之交互，如<a class="ae lr" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" rel="noopener ugc nofollow" target="_blank"> LDAP </a>或<a class="ae lr" href="https://en.wikipedia.org/wiki/Active_Directory" rel="noopener ugc nofollow" target="_blank"> Active Directory </a>。</p><h1 id="451a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">15.。NET SDK对。NET框架程序集</h1><p id="0f31" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae lr" href="https://github.com/dotnet/sdk/issues/4009" rel="noopener ugc nofollow" target="_blank">。NET SDK现在将自动引用</a>的<a class="ae lr" href="https://www.nuget.org/packages/Microsoft.NETFramework.ReferenceAssemblies/" rel="noopener ugc nofollow" target="_blank">微软。给定项目文件中的. NETFramework目标框架，NET Framework . reference assemblies</a>nu get包。这种变化使建筑成为可能。NET Framework项目在没有所需的。已安装. NET Framework目标包。这种改进是特定于目标包的，并没有考虑到项目可能具有的其他依赖性。</p><h1 id="6cb3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">16.本地出口</h1><p id="6e5d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">本地导出项目使您能够:</p><ul class=""><li id="d292" class="nn no in kv b kw nc la nd le ob li oc lm od lq og nt nu nv bi translated">公开自定义本机导出。</li><li id="544d" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated">不需要像COM这样的高级互操作技术。</li><li id="4c1e" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated">跨平台工作。</li></ul><p id="3f17" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">更多信息请点击:</strong> <a class="ae lr" href="https://github.com/AaronRobinsonMSFT/DNNE" rel="noopener ugc nofollow" target="_blank">土特产出口。网</a></p><h1 id="fb8f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">17.本机托管应用程序</h1><p id="ce2c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">多年来，我们已经看到了各种各样的托管模式。NET在本机应用程序中的应用。<a class="ae lr" href="https://github.com/rseanhall" rel="noopener ugc nofollow" target="_blank"> @rseanhall </a>提出并实现了<a class="ae lr" href="https://github.com/dotnet/runtime/issues/35465" rel="noopener ugc nofollow" target="_blank">一个新颖的新模型来做这件事</a>，它利用了。NET应用程序宿主层(特别是加载依赖项)，同时允许从本机代码调用自定义入口点。</p><h1 id="1c86" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">18.单文件应用程序</h1><p id="52c3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">单文件应用——一种新的<a class="ae lr" href="https://github.com/dotnet/runtime/issues/36590" rel="noopener ugc nofollow" target="_blank">单文件发布类型</a>,它从单个二进制文件中执行您的应用(例如，可以在只读介质上使用)。</p><p id="0b1c" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">对于，X64上支持此功能。NET 5.0，在Windows和Linux上。它将适用于ARM32/64应用程序。对于单个文件，依赖于运行时和自包含的发布类型都将被支持。</p><h1 id="bb45" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">19.P95+延迟改进</h1><ol class=""><li id="e4cf" class="nn no in kv b kw kx la lb le np li nq lm nr lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32250" rel="noopener ugc nofollow" target="_blank">改进分层JIT编译使用的调用计数机制</a>,使启动时的性能更加平稳</li><li id="3285" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32270" rel="noopener ugc nofollow" target="_blank">内部通用字典的动态扩展</a>消除了通用代码带来的性能下降</li><li id="1ef1" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/pull/32283" rel="noopener ugc nofollow" target="_blank">钉住对象堆</a>减少因钉住导致的堆碎片</li><li id="e395" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">减少特定情况下的GC暂停时间，如<a class="ae lr" href="https://github.com/dotnet/coreclr/pull/27776" rel="noopener ugc nofollow" target="_blank">数组。复制</a>、<a class="ae lr" href="https://github.com/dotnet/runtime/pull/35297" rel="noopener ugc nofollow" target="_blank">数组。排序</a>或<a class="ae lr" href="https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480" rel="noopener ugc nofollow" target="_blank">对象拆箱</a></li></ol><h1 id="d9ee" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">20.缩小容器图像的大小</h1><p id="88fc" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">进行了一项更改，显著减小了您在多阶段构建场景中提取的聚合映像的大小(这是一种非常常见的模式)。<a class="ae lr" href="https://github.com/dotnet/dotnet-docker/pull/1848" rel="noopener ugc nofollow" target="_blank">ASP.NET映像</a>之上的SDK映像被重新基于，而不是<a class="ae lr" href="https://hub.docker.com/_/buildpack-deps" rel="noopener ugc nofollow" target="_blank"> buildpack-deps </a>。</p><p id="4edd" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">这一变更对于多阶段构建具有以下优势(在<a class="ae lr" href="https://github.com/dotnet/dotnet-docker/blob/master/samples/aspnetapp/Dockerfile" rel="noopener ugc nofollow" target="_blank">文档</a>中的使用示例):</p><p id="f662" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">使用Ubuntu 20.04 Focal的多阶段构建成本<strong class="kv io">:</strong></p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/920590923e5aaf129e94ae6cdfa057d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*a9HUBXmQRJbpgRUp38Ue_A.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><em class="oi">净下载节省量</em> : 100 MB (-30%)</figcaption></figure><p id="0fac" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">Debian 10 Buster 的多阶段构建成本:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ffd9e177afabbad19482b8f37bd04455.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*E7jJqeRAJN4Xis4UQvQpBw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><em class="oi">净下载节省量</em> : 146 MB (-40%)</figcaption></figure><p id="c86c" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">有关更多详细信息，请参见:</strong><a class="ae lr" href="https://github.com/dotnet/dotnet-docker/issues/1814#issuecomment-625294750" rel="noopener ugc nofollow" target="_blank">dot net/dot net-docker # 1814</a></p><h1 id="4747" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">21.阿尔卑斯山3.12</h1><p id="d11e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">对于Alpine 3.12的支持。添加了NET 5。Alpine Linux的维护者在5月29日宣布了Alpine 3.12的<a class="ae lr" href="https://twitter.com/alpinelinux/status/1266471727678337024" rel="noopener ugc nofollow" target="_blank">发布。</a></p><h1 id="e33e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">22.事件管道</h1><h2 id="6243" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 1。事件管道中增加了装配负载诊断</strong></h2><p id="da37" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">程序集加载信息已添加到事件管道中。这一改进是使作为的一部分的类似诊断功能可用的开始。NET框架与<a class="ae lr" href="https://docs.microsoft.com/dotnet/framework/tools/fuslogvw-exe-assembly-binding-log-viewer" rel="noopener ugc nofollow" target="_blank">融合日志查看器</a>。您现在可以使用以下命令，使用<a class="ae lr" href="https://docs.microsoft.com/dotnet/core/diagnostics/dotnet-trace" rel="noopener ugc nofollow" target="_blank"> dotnet-trace </a>来收集这些信息:</p><pre class="mi mj mk ml gt mm lv mn mo aw mp bi"><span id="0cdb" class="lw jw in lv b gy mq mr l ms mt">dotnet-trace collect --providers Microsoft-Windows-DotNETRuntime:4:4 --process-id [process ID]</span></pre><p id="97d8" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">工作流程在<a class="ae lr" href="https://github.com/richlander/testapps/tree/master/trace-assembly-loading" rel="noopener ugc nofollow" target="_blank">用事件管道</a>跟踪装配加载中描述。您可以看到一个简单测试应用程序的程序集加载信息。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/12f7f1bb55a9dbc153897482190cf5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JMqNFE5LWyppK9io.png"/></div></div></figure><h2 id="f9fc" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated"><strong class="ak"> 2。事件管道分析器API</strong></h2><p id="4761" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">事件管道是新增的一个子系统和API。NET Core 2.2 使<a class="ae lr" href="https://github.com/dotnet/runtime/blob/master/docs/project/linux-performance-tracing.md" rel="noopener ugc nofollow" target="_blank">在任何操作系统上执行性能和其他诊断调查</a>成为可能。英寸NET 5.0中，事件管道已经扩展到允许探查器编写事件管道事件。这种情况对于以前依赖ETW来监控应用程序行为和性能的检测分析器来说至关重要。</p><h1 id="17c5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">23.在Windows上支持ICU</h1><p id="be1e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae lr" href="http://site.icu-project.org/" rel="noopener ugc nofollow" target="_blank"> ICU </a>库，为Linux和macOS上的应用程序提供Unicode和全球化支持。我们现在在Windows 上使用<a class="ae lr" href="https://docs.microsoft.com/en-us/windows/win32/intl/international-components-for-unicode--icu-" rel="noopener ugc nofollow" target="_blank">这个相同的库。</a><a class="ae lr" href="https://github.com/dotnet/runtime/pull/34645" rel="noopener ugc nofollow" target="_blank">这一变化</a>使得全球化API的行为，如特定于文化的字符串比较，在Windows 10和其他操作系统之间保持一致。</p><h1 id="1786" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">24.支持cgroup v2(用于容器)</h1><p id="44f3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">。NET现在有了对cgroup v2 的<a class="ae lr" href="https://github.com/dotnet/runtime/pull/34334" rel="noopener ugc nofollow" target="_blank">支持，它有望在2020年及以后成为一个重要的容器相关API。Docker目前使用的是cgroup v1(已经被。网)。相比之下，cgroup v2比cgroup v1更简单、更高效、更安全。可以从2019 Docker更新了解更多</a><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/" rel="noopener ugc nofollow" target="_blank"> cgroup和Docker资源限制</a>。Linux发行版和容器运行时正在添加对cgroup v2的支持。。一旦cgroup v2环境变得更加普遍，NET 5.0将在其中正常工作。感谢奥迈尔·马吉德的支持。红帽网。</p><h1 id="8bd3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">25.GitHub回购整合</h1><p id="f7f4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">作为的一部分。NET 5发布，GitHub回购的<a class="ae lr" href="https://github.com/dotnet/runtime/issues/13688" rel="noopener ugc nofollow" target="_blank">数量减少。回购边界对项目的许多方面都有重大影响，包括构建和问题管理。与。NET Core 1.0，在ASP.NET、英孚和微软有超过100个回购。网芯。有了这个最新的版本，你现在可以用一只手数一次回购。几乎所有回购都被转移到了dotnet org。</a></p><p id="57f6" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated">查看新的整合回购:</p><ul class=""><li id="e8ce" class="nn no in kv b kw nc la nd le ob li oc lm od lq og nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime" rel="noopener ugc nofollow" target="_blank"> dotnet/runtime </a>(是dotnet/corefx，dotnet/coreclr，和dotnet/core-setup)</li><li id="0505" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/aspnetcore" rel="noopener ugc nofollow" target="_blank">dot net/aspnet core</a>(aspnet org中的几个回购)</li><li id="0403" class="nn no in kv b kw nw la nx le ny li nz lm oa lq og nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/sdk" rel="noopener ugc nofollow" target="_blank">dot net/SDK</a>(was dot net/SDK，dotnet/cli)</li></ul><p id="b50c" class="pw-post-body-paragraph kt ku in kv b kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq ig bi translated"><strong class="kv io">附注:你可以在这里找到更多信息:</strong></p><ol class=""><li id="5974" class="nn no in kv b kw nc la nd le ob li oc lm od lq ns nt nu nv bi translated"><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-1/" rel="noopener ugc nofollow" target="_blank">宣布。NET 5预览1 </a></li><li id="5744" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-2/" rel="noopener ugc nofollow" target="_blank">宣布。NET 5预览版2 </a></li><li id="8839" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-3/" rel="noopener ugc nofollow" target="_blank">宣布。NET 5预览版3 </a></li><li id="166b" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/" rel="noopener ugc nofollow" target="_blank">宣布。NET 5预览版4 </a></li><li id="e225" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-5/" rel="noopener ugc nofollow" target="_blank">宣布。NET 5预览版5 </a></li><li id="51c6" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated">宣布。NET 5预览版6 </li><li id="60c2" class="nn no in kv b kw nw la nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Abreaking-change&amp;milestone=7" rel="noopener ugc nofollow" target="_blank">版本中的所有重大变更(在dot net/运行时中)</a></li></ol></div></div>    
</body>
</html>