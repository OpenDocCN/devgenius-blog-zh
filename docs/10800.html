<html>
<head>
<title>How to Write Better SQL to Improve Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写更好的 SQL 来提高查询性能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-better-sql-to-improve-query-performance-d2167d16b7dd?source=collection_archive---------6-----------------------#2022-11-30">https://blog.devgenius.io/how-to-write-better-sql-to-improve-query-performance-d2167d16b7dd?source=collection_archive---------6-----------------------#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e18d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><strong class="ak">软件工程之旅</strong></h2><div class=""/><div class=""><h2 id="a73e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">为了提高 SQL 查询的性能，软件工程师必须了解这些优化技术。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/224a1a78da4b171d2fcae35abbce2a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*quK8QyvVLCHGZAb-"/></div></figure><h1 id="6c1b" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak">概述</strong></h1><p id="7ecb" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你是一个程序员，软件工程师，你必须熟悉写 SQL 查询，这里。在本文中，我将告诉您如何编写 SQL 查询来提高其性能并优化它以减少查询的响应时间。</p><p id="e877" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，并不是每个人都知道如何正确地、最佳地、容易阅读地、以高处理速度来编写，本文将通过考虑可能的查询计划来帮助您确定执行查询的最佳有效方式。</p><h1 id="417a" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #1 定义并理解您的需求</strong></h1><p id="6241" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每当您编写 SQL 查询来查找特定数据时，您必须知道您需要什么类型的数据，然后根据您的要求编写查询。这将使您能够只接收您需要的信息，潜在地减少执行时间，并优化 SQL 查询。</p><h1 id="a80b" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #2 不要在 Select 语句中使用*</strong></h1><p id="a6b8" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每当我们在查询中使用*时，它会给出表的所有列，这会花费更多的时间，因此建议编写结果所需的列名。</p><p id="bb94" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">举例:</strong></p><p id="eed2" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-糟糕的方式</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="c053" class="mu kx iq mq b be mv mw l mx my">SELECT *<br/>FROM Department</span></pre><p id="0c55" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好方法</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="ac2e" class="mu kx iq mq b be mv mw l mx my">SELECT Id, DeptName, Description<br/>FROM Department</span></pre><h1 id="ecd9" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #3 避免循环查询</strong></h1><p id="4691" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每当我们想要多次执行同一个查询时，比如我们想要插入任意数据 n 次，不要在循环中使用 insert query，而要使用 bulk insert。</p><p id="0043" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">示例:</strong></p><p id="5de3" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-糟糕的方式</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="675b" class="mu kx iq mq b be mv mw l mx my">for(Int i = 0;i &lt;= 5; i++)<br/>{<br/>INSERT INTO Table1(Id,Value) Values( i , 'Value' + i );<br/>}</span></pre><p id="fb32" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好方法</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="9727" class="mu kx iq mq b be mv mw l mx my">INSERT INTO Table1(Id, Value)<br/>Values(1,Value1),(2,Value2),(2,Value3),(4,Value4),(5,Value5)</span></pre><h1 id="5f04" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #4 在</strong>列中使用有效的数据类型</h1><p id="80a4" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有时，一些新程序员不知道数据类型的实际用途，他们对所有列使用“varchar”数据类型，但这不是正确的方法，我们需要确定需要哪种类型的数据，然后使用特定的数据类型。</p><p id="d16a" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">例如:</strong></p><ol class=""><li id="c95b" class="mz na iq lq b lr mk lu ml lx nb mb nc mf nd mj ne nf ng nh bi translated">在 Isdelete 列中，如果记录是否被删除，我们只需要设置布尔值(true、false)。</li><li id="2dcc" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated">在创建日期列中，我们需要设置日期时间数据类型。</li><li id="8494" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated">如果 Department 列被用作任何表中的外键，那么我们只需要存储该部门的 id，而不是名称，这样我们就可以设置 Integer 数据类型。</li></ol><h1 id="09cc" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #5 在查询的开头添加解释</strong></h1><p id="4561" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们在查询的开头添加 EXPLAIN 时，它会告诉我们执行计划的顺序以及执行需要多长时间，也就是说，你的运行时间会有多长。</p><p id="f6f9" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过这样做，我们可以了解最昂贵的步骤，并定位或修改它们以减少运行时间，并可以再次检查这些更改是否减少了运行时间。</p><p id="b8f3" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">例子:</strong></p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="b57d" class="mu kx iq mq b be mv mw l mx my">EXPLAIN<br/>SELECT CONCAT(g.FirstName,g.LastName) AS FULLNAME<br/>FROM workTable AS g, dataTable AS h<br/>WHERE g.Roll=h.Roll;</span></pre><p id="c398" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/6af1c378c18565a209befae778e96b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i06Z_KVMkstGl5Cf"/></div></div></figure><h1 id="b701" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #6 使用 SQL 查询优化工具</strong></h1><p id="cd76" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们知道我们的系统性能很差，并且我们无法确定优化哪个查询以获得更好的性能时，那么我们应该使用 SQL 查询优化工具，因为它将使您能够快速找到优化所需的查询。</p><p id="b018" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">查询本身并不总是导致执行缓慢。有时还有其他因素造成的，如果没有 SQL 查询优化工具，很难区分执行缓慢是由于任何查询还是其他因素造成的。</p><p id="60a7" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">虽然您可以在 MySQL 性能模式、PostgreSQL pg _ stat _ 语句和查询日志中找到查询，但是使用 MS SQL 查询优化工具可以节省您的时间并减少您的麻烦。</p><h1 id="3811" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #7 用 EXISTS()代替 COUNT() </strong></h1><p id="884c" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以使用 EXISTS()和 COUNT()来查找表中是否包含任何特定的记录，但 EXISTS()更有效，因为 COUNT()将搜索整个表以提供匹配记录的总数，而 EXISTS()将只搜索到它没有找到表中的第一个条目，从而节省您的时间和计算能力，并使您能够以更好的方式优化 SQL 查询。</p><p id="6c91" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">举例:</strong></p><p id="ccd8" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好方法</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="f37e" class="mu kx iq mq b be mv mw l mx my">SET STATISTICS IO ON<br/>IF EXISTS(SELECT * FROM OrderDetails<br/>WHERE orderid = 10248)<br/>PRINT 'yes'<br/>ELSE<br/>PRINT 'no'<br/>SET STATISTICS IO OFF</span></pre><p id="c7a6" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-糟糕的方式</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="67c0" class="mu kx iq mq b be mv mw l mx my">SET STATISTICS IO ON<br/>IF (SELECT COUNT(*) FROM OrderDetails<br/>WHERE orderid = 10248) &gt; 0<br/>PRINT 'yes'<br/>ELSE<br/>PRINT 'no'<br/>SET STATISTICS IO OFF</span></pre><h1 id="bc2f" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #8 用“Where”代替“Having”从句</strong></h1><p id="789c" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们使用“where”时，它会根据其特定条件检查表中的所有记录，而当我们使用“having”时，我们需要使用“group by ”,这样，数据会按组显示，之后，当我们应用 Having 时，只在那些已筛选的组中搜索数据。</p><p id="c09f" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">举例:</strong></p><p id="fba3" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好方法</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="1113" class="mu kx iq mq b be mv mw l mx my">SELECT Emp.Id, Emp.Name,Dept.DeptName,Emp.Salary<br/>FROM Employee Emp<br/>RIGHT JOIN Department Dept on Emp.DeptId = Dept.Id<br/>WHERE Emp.Salary &gt;= 20000;</span></pre><p id="9669" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-糟糕的方式</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="9858" class="mu kx iq mq b be mv mw l mx my">SELECT Emp.Id, Emp.Name,Dept.DeptName,Emp.Salary<br/>FROM Employee Emp<br/>RIGHT JOIN Department Dept on Emp.DeptId = Dept.Id<br/>GROUP BY dept.DeptName<br/>HAVING Emp.Salary &gt;= 20000;</span></pre><h1 id="35e6" class="kw kx iq bd ky kz la lb lc ld le lf lg kf lh kg li ki lj kj lk kl ll km lm ln bi translated"><strong class="ak"> #9 使用适当的连接代替子查询</strong></h1><p id="7b89" class="pw-post-body-paragraph lo lp iq lq b lr ls ka lt lu lv kd lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们使用连接而不是子查询时，它节省了我们大量的时间，因为当我们使用子查询时，它检查表中的所有记录，而当我们使用连接时，如左或右查询，它只检查符合标准的记录。</p><p id="cd66" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">示例:</strong></p><p id="b6aa" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">— —糟糕的方式</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="c618" class="mu kx iq mq b be mv mw l mx my">SELECT Id, Name<br/>FROM Employee<br/>WHERE DeptId in (SELECT Id<br/>FROM Department<br/>WHERE Name like '%Management%')</span></pre><p id="6f1d" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">——好办法</p><pre class="kp kq kr ks gt mp mq mr bn ms mt bi"><span id="1cd8" class="mu kx iq mq b be mv mw l mx my">SELECT Emp.Id, Emp.Name,Dept.DeptName<br/>FROM Employee Emp<br/>RIGHT JOIN Department Dept on Emp.DeptId = Dept.Id<br/>WHERE Dept.DeptName like '%Management%'</span></pre><p id="394e" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ja">结论</strong></p><p id="aef1" class="pw-post-body-paragraph lo lp iq lq b lr mk ka lt lu ml kd lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我想对阅读我文章的读者说声谢谢。我希望它能帮助您提高 SQL 查询的性能。我已经建议了一些可以用来提高性能的东西，如果软件工程师能够注意到上面提到的事情，那么与性能相关的问题将会得到解决，运行时间将会减少。感谢阅读！</p></div></div>    
</body>
</html>