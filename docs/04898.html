<html>
<head>
<title>Working With Lambda Expressions in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java中使用Lambda表达式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-lambda-expressions-in-java-acde58231520?source=collection_archive---------1-----------------------#2021-05-18">https://blog.devgenius.io/working-with-lambda-expressions-in-java-acde58231520?source=collection_archive---------1-----------------------#2021-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8d63b81378e324ca6ee6d8330c0c6e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lD100HAcOhPJu-oYakXhmQ.png"/></div></div></figure><div class=""/><figure class="gl gn jw jx jy ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi jv"><img src="../Images/e34d78f230eef27c896202d080ad224d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2HyWr7jfnfNAXpAQ04Klw.png"/></div></div><figcaption class="jz ka gj gh gi kb kc bd b be z dk translated">这难道不更符合用户的需求吗？我将在接下来的文章中介绍:)</figcaption></figure><p id="2e41" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">让我们先了解什么是<strong class="kf iz">功能接口</strong>:</p><p id="9099" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在这个例子中，我们用Lambda表达式替换了一个实现接口比较器的匿名类</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f075" class="lk ll iy lg b gy lm ln l lo lp">products.sort(new Comparator&lt;Product&gt;() {</span><span id="e43a" class="lk ll iy lg b gy lq ln l lo lp">@Override<br/>public int compare(Product p1, Product p2) { <br/>return p1.getPrice().compareTo(p2.getPrice());<br/>}</span><span id="ce93" class="lk ll iy lg b gy lq ln l lo lp">});</span></pre><p id="3311" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">去…</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f22c" class="lk ll iy lg b gy lm ln l lo lp">products.sort((p1, p2) -&gt; p1.getPrice().compareTo(p2.getPrice()));</span></pre><p id="99bd" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是一个<strong class="kf iz">单一的抽象方法:</strong>比较方法。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d6f9" class="lk ll iy lg b gy lm ln l lo lp">@FunctionalInterface<br/>public interface Comparator&lt;T&gt; {<br/>int compare(T o1, T o2);<br/>}</span></pre><p id="e5bf" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">java中有很多这样的接口，您可能已经熟悉了。例如，在处理威胁时，有一个可运行的界面<strong class="kf iz"/>。您将实现run方法，该方法在您正在创建的线程中执行。另一个是界面<strong class="kf iz">文件过滤器</strong>:可以用来从目录列表中过滤文件列表。这个接口定义了一个accept方法，用于确定是否在列表中包含一个文件。还有一个来自Swing UI工具包的界面<strong class="kf iz"> ActionListener </strong>。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lr"><img src="../Images/189ac0050e4029078c14a4b0c1982788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kgfcREwZQ3LNL-pG"/></div></div></figure><p id="ac5e" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf iz">单个抽象方法接口</strong>也称为函数接口，它们在λ表达式方面起着重要的作用。<strong class="kf iz">λ表达式总是实现一个功能接口</strong>。<strong class="kf iz">每当您在Java代码中遇到lambda表达式时，总是会有一个函数接口，lambda表达式会实现这个接口</strong>。</p><p id="fa60" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">除了我刚才提到的比较器和其他功能接口之外，在java的标准库中还有一个包，java.util.function，里面有一组常用的功能接口。</p><p id="6f75" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">我们将仔细研究标准的功能接口。现在，您只需要知道函数接口是一个具有单个抽象方法的接口，您可以用lambda表达式来实现它。</p><h1 id="543e" class="ls ll iy bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">Lambda表达式语法</strong></h1><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/d7912e253cf424c8fbff3802cebd9dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9TFRdZgQGyUi5pIM"/></div></div></figure><p id="5eac" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">λ表达式由<strong class="kf iz">参数列表、箭头符号</strong>和正文组成。</p><p id="87b0" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">由于lambda表达式是一个匿名方法，它显然也没有名称。您不需要显式指定lambda表达式的返回类型，也不需要指定参数的类型。</p><p id="816b" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">编译器已经知道参数和返回类型，因为它们是由lambda表达式实现的函数接口指定的。例如，这个lambda表达式实现了接口Comparator，其compare方法采用两个乘积并返回一个int。如果您真的想这样做，您可以指定参数的类型，但这通常不是必需的。如果是这样，它们显然必须与函数接口指定的参数类型相匹配；否则，您会得到一个编译错误。</p><figure class="lb lc ld le gt ip"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="252d" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">当lambda表达式没有参数时，可以在箭头前使用一对空括号。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ms"><img src="../Images/0572d104a49f1dbf58604ddd3d302383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oWXAMc4-eW1tkcVq"/></div></div></figure><p id="352e" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">例如，如果你用lambda表达式实现了Runnable接口，你就会这样做。干预的运行方法合理地不带任何参数。最后，当lambda表达式只有一个参数时，你可以省去括号，但前提是你没有明确指定参数的类型。对于单参数lambda表达式来说，这是一个特例规则，可以使语法更加简洁。lambda表达式的主体有两种可能的形式。要么是单个表达式，要么是花括号之间的块。</p><h1 id="e184" class="ls ll iy bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">捕捉Lambda表达式中的变量</strong></h1><p id="c473" class="pw-post-body-paragraph kd ke iy kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ig bi translated">一些需要理解的限制和一个你应该避免的坏习惯。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b4d4" class="lk ll iy lg b gy lm ln l lo lp">public class LambdasExample {</span><span id="78b5" class="lk ll iy lg b gy lq ln l lo lp">interface ProductFilter {<br/>boolean accept(Product product);<br/>}</span><span id="6a3c" class="lk ll iy lg b gy lq ln l lo lp">// Print the products that cost less than the price limit.<br/>static void printProducts(List&lt;Product&gt; products, BigDecimal priceLimit) {</span><span id="ff01" class="lk ll iy lg b gy lq ln l lo lp">for (Product product : products) {</span><span id="9441" class="lk ll iy lg b gy lq ln l lo lp">if (product.getPrice().compareTo(priceLimit) &lt; 0) {<br/>System.<em class="my">out</em>.println(product);}<br/>}<br/>}</span><span id="0c19" class="lk ll iy lg b gy lq ln l lo lp">public static void main(String[] args) {</span><span id="c958" class="lk ll iy lg b gy lq ln l lo lp">List&lt;Product&gt; products = ExampleData.<em class="my">getProducts</em>();</span><span id="488f" class="lk ll iy lg b gy lq ln l lo lp">BigDecimal priceLimit = new BigDecimal(“5.00”);</span><span id="1fb9" class="lk ll iy lg b gy lq ln l lo lp">ProductFilter filter = product -&gt; product.getPrice().compareTo(priceLimit) &lt; 0;</span><span id="1217" class="lk ll iy lg b gy lq ln l lo lp"><em class="my">printProducts</em>(products, priceLimit);</span><span id="edae" class="lk ll iy lg b gy lq ln l lo lp">}</span><span id="5964" class="lk ll iy lg b gy lq ln l lo lp">}</span></pre><p id="1f36" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">“上面的代码可以很好地工作，但是有一个规则你必须非常非常清楚。<strong class="kf iz">捕获的局部变量必须是有效的最终变量”。</strong>这意味着“限价”应该是最终价格或“有效最终价格”:这意味着“限价”应该表现得就像是最终价格一样。现在你明白了，在上面的代码中，这必须在Lambda表达式之前声明。如果被重新分配，变量不是<strong class="kf iz">有效最终变量</strong>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fd9b" class="lk ll iy lg b gy lm ln l lo lp">BigDecimal priceLimit= new BigDecimal(“5.00”);</span><span id="3f5a" class="lk ll iy lg b gy lq ln l lo lp">ProductFilter filter = product -&gt; product.getPrice().compareTo(priceLimit) &lt; 0;</span><span id="1e2d" class="lk ll iy lg b gy lq ln l lo lp">BigDecimal priceLimit = new BigDecimal(“6.00”);</span></pre><p id="20cf" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这个代码真的可以用吗？没有怎么了？？“限价”也更新了。而且这还不是<strong class="kf iz">现在有效的最终</strong>。所以我们可以说，Java编程语言的设计者选择要求捕获的局部变量实际上是最终变量。</p><blockquote class="mz na nb"><p id="7a5b" class="kd ke my kf b kg kh ki kj kk kl km kn nc kp kq kr nd kt ku kv ne kx ky kz la ig bi translated">让我们再清楚一次:</p></blockquote><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="79de" class="lk ll iy lg b gy lm ln l lo lp">List&lt;Product&gt; products = ExampleData.<em class="my">getProducts</em>();</span><span id="ce63" class="lk ll iy lg b gy lq ln l lo lp">BigDecimal priceLimit = new BigDecimal(“5.00”);</span><span id="685a" class="lk ll iy lg b gy lq ln l lo lp">int numberOfCheapProducts = 0;</span><span id="8bbd" class="lk ll iy lg b gy lq ln l lo lp">Because local variables are effectively final, you cannot modify them inside a lambda expression.</span><span id="2328" class="lk ll iy lg b gy lq ln l lo lp">products.forEach(product -&gt; {</span><span id="6ca8" class="lk ll iy lg b gy lq ln l lo lp">if (product.getPrice().compareTo(priceLimit) &lt; 0) {</span><span id="2317" class="lk ll iy lg b gy lq ln l lo lp">numberOfCheapProducts++; // Error: Variable must be effectively final</span><span id="7022" class="lk ll iy lg b gy lq ln l lo lp">}</span><span id="0d49" class="lk ll iy lg b gy lq ln l lo lp">});</span></pre><blockquote class="mz na nb"><p id="4299" class="kd ke my kf b kg kh ki kj kk kl km kn nc kp kq kr nd kt ku kv ne kx ky kz la ig bi translated">但是…..</p></blockquote><figure class="lb lc ld le gt ip"><div class="bz fp l di"><div class="nf mr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1c65" class="lk ll iy lg b gy lm ln l lo lp">List&lt;Product&gt; products = ExampleData.<em class="my">getProducts</em>();</span><span id="a7bd" class="lk ll iy lg b gy lq ln l lo lp">BigDecimal priceLimit = new BigDecimal(“5.00”);</span><span id="7e01" class="lk ll iy lg b gy lq ln l lo lp">List&lt;Product&gt; cheapProducts = new ArrayList&lt;&gt;();</span><span id="c759" class="lk ll iy lg b gy lq ln l lo lp">// BAD PRACTICE! Modifying cheapProducts inside the body of the lambda expression.</span><span id="2569" class="lk ll iy lg b gy lq ln l lo lp">// In general, avoid side effects such as modifying objects from captured variables in lambda expressions.</span><span id="557b" class="lk ll iy lg b gy lq ln l lo lp">products.forEach(product -&gt; {</span><span id="b885" class="lk ll iy lg b gy lq ln l lo lp">if (product.getPrice().compareTo(priceLimit) &lt; 0) {</span><span id="10fd" class="lk ll iy lg b gy lq ln l lo lp">cheapProducts.add(product);</span><span id="6b8c" class="lk ll iy lg b gy lq ln l lo lp">}</span><span id="e5c8" class="lk ll iy lg b gy lq ln l lo lp">});</span><span id="39bf" class="lk ll iy lg b gy lq ln l lo lp">// Print the cheap products.</span><span id="1353" class="lk ll iy lg b gy lq ln l lo lp">cheapProducts.forEach(product -&gt; System.<em class="my">out</em>.println(product));</span></pre><p id="1663" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi ng translated"><span class="l nh ni nj bm nk nl nm nn no di">答</span>说了所有的事情之后<strong class="kf iz">你不能修改被捕获的局部变量</strong></p><p id="719c" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">但是……现在我在这里更新一些东西</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="510e" class="lk ll iy lg b gy lm ln l lo lp">cheapProducts.add(product);</span></pre><blockquote class="mz na nb"><p id="1dcb" class="kd ke my kf b kg kh ki kj kk kl km kn nc kp kq kr nd kt ku kv ne kx ky kz la ig bi translated">为什么没有错误？？？</p></blockquote><p id="7fc5" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">那是因为我们没有修改变量。我们正在修改它引用的一个<strong class="kf iz">对象。</strong>不可变对象如数组列表在上述情况下仍然可以修改该对象的状态。</p><p id="8009" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf iz">处理Lambda表达式中的异常</strong></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="522f" class="lk ll iy lg b gy lm ln l lo lp">List&lt;Product&gt; products = ExampleData.<em class="my">getProducts</em>();<br/>try (FileWriter writer = new FileWriter(“products.txt”)) {</span><span id="ed8b" class="lk ll iy lg b gy lq ln l lo lp">products.forEach(product -&gt; {writer.write(product.toString() + “\n”);</span><span id="8812" class="lk ll iy lg b gy lq ln l lo lp">});<br/>} catch (IOException | RuntimeException e) {<br/>     System.<em class="my">err</em>.println(“An exception occurred: “ + e.getMessage());<br/>}<br/>}</span></pre><p id="bf83" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">FileWriter的构造函数及其大多数方法可能会引发IOException。因为这是一个检查过的异常，我们像上面一样处理try-catch。</p><p id="5561" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">但是，</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi np"><img src="../Images/53f49276d0780cb1051103be42f156d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NC9UwlbndYw_nXtz"/></div></div></figure><p id="00ff" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">为了处理“java.io.IOException ”,我们必须捕捉并处理lambda表达式内部的异常。是的，这很不幸，因为这会使代码变得更大。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7b79" class="lk ll iy lg b gy lm ln l lo lp">products.forEach(product -&gt; {<br/>try {</span><span id="6a77" class="lk ll iy lg b gy lq ln l lo lp">writer.write(product.toString() + “\n”);<br/>} catch (IOException e) {<br/>throw new RuntimeException(e);<br/>}<br/>});<br/>} catch (IOException | RuntimeException e) {<br/>System.<em class="my">err</em>.println(“An exception occurred: “ + e.getMessage());<br/>}</span></pre><p id="773e" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">希望你理解我们在这里所做的一切。<strong class="kf iz">包装异常，处理异常。</strong></p><p id="ebf8" class="pw-post-body-paragraph kd ke iy kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">是的，Lambda对许多解决方案来说可能更好，但有时一个简单的for循环可能是更好的解决方案。:)</p><h1 id="e07d" class="ls ll iy bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">总结</strong></h1><ul class=""><li id="bb54" class="nq nr iy kf b kg mt kk mu ko ns ks nt kw nu la nv nw nx ny bi translated">让我们总结一下你学到的最重要的话题。我们从λ表达式开始。考虑lambda表达式的最佳方式是，它是一个匿名方法，你可以将它传递给其他方法，传递给你传递lambda表达式的方法，它看起来像一个实现函数接口的对象。</li><li id="1388" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">lambda表达式实现了一个函数接口，但不是lambda表达式本身决定了它实现哪个接口。接收lambda表达式的方法指定它应该匹配哪个接口。</li><li id="fae1" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">函数接口是具有单一抽象方法的接口。函数接口可能有其他方法，例如，默认方法，但是它们必须总是有且只有一个抽象方法。具有零个或多个抽象方法的接口不是函数接口。</li><li id="6c84" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">lambda表达式的语法由三部分组成:参数、箭头符号和主体。</li><li id="be0e" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">有一些语法快捷方式可以帮助您保持代码的简洁和可读性。指定lambda表达式的参数类型是可选的。如果主体由单个表达式组成，那么可以省略花括号和return语句。如果它没有参数，那么使用一组空的括号，如果它只有一个参数，那么可以省略括号。lambda表达式可以从其周围的代码中捕获变量。</li><li id="d94c" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">lambda表达式捕获的局部变量实际上必须是final，这意味着您不能在lambda表达式内部或外部修改这样的变量。最好避免lambda表达式中的副作用，比如修改来自lambda表达式之外的对象的状态。这样做会导致混乱的代码和难以发现的bug。</li><li id="7c3c" class="nq nr iy kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">如果lambda表达式匹配的函数接口在其包含异常的抽象方法上没有throws子句，则不允许抛出检查过的异常。</li></ul><figure class="lb lc ld le gt ip"><div class="bz fp l di"><div class="oe mr l"/></div></figure></div></div>    
</body>
</html>