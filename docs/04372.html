<html>
<head>
<title>Django + React Authentication: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django + React认证:第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-react-authentication-part-2-ea626688165e?source=collection_archive---------2-----------------------#2021-03-07">https://blog.devgenius.io/django-react-authentication-part-2-ea626688165e?source=collection_archive---------2-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4226" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React创建Django API的前端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aaef5cb1fccdabfbd164eb5377c8bfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNz6L9LH-OB6dmeKQBlLxA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">文本编辑器中的代码</figcaption></figure><p id="7b77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上一篇文章中，我带领您使用<a class="ae lr" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>和<a class="ae lr" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> Django Rest框架</a>创建了一个后端用户认证API。那篇文章可以在<a class="ae lr" href="https://medium.com/dev-genius/django-react-authentication-part-1-d351726b284d" rel="noopener">这里</a>找到。在本文中，我们将使用<a class="ae lr" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>创建一个简单的前端来使用这个API。注意，我不会使用任何花哨的东西，比如Redux或上下文API。相反，我将通过使用诸如<code class="fe ls lt lu lv b">useState</code>和<code class="fe ls lt lu lv b">useEffect</code>这样的React挂钩来保持简单。</p><p id="b3c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">创建项目并清理:</strong></p><p id="3be7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我喜欢用<code class="fe ls lt lu lv b">create-react-app</code>来搭建我的React项目。我将命名这个项目客户。在终端中运行以下命令。注意，你需要在你的机器上安装<code class="fe ls lt lu lv b">node</code>和<code class="fe ls lt lu lv b">npm</code>，这样才能工作。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7d03" class="ma mb iq lv b gy mc md l me mf">npx create-react-app client</span></pre><p id="efd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦运行完成(可能需要一两分钟)，您应该有了React应用程序的框架。文件结构应该如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6fe7" class="ma mb iq lv b gy mc md l me mf">- public/<br/>-- favicon.ico<br/>-- index.html<br/>-- logo192.png<br/>-- logo512.png<br/>-- manifest.json<br/>-- robots.txt<br/>- src/<br/>-- App.css<br/>-- App.js<br/>-- App.test.js<br/>-- index.css<br/>-- index.js<br/>-- logo.svg<br/>-- reportWebVitals.js<br/>-- setUpTests.js<br/>- .gitignore<br/>- package-lock.json<br/>- package.json<br/>- README.md</span></pre><p id="6429" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我把node-module文件夹留在这里，但是它将出现在您的文件结构中。</p><p id="d166" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可悲的是，<code class="fe ls lt lu lv b">create-react-app</code>制造了很多我们不需要的文件。我倾向于通过删除这些文件来清理我的React项目。如果以后需要，我会把它们加回去。然而现在，它只是一大堆看起来杂乱的噪音。这是我留下的文件结构的样子。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="889d" class="ma mb iq lv b gy mc md l me mf">- public/<br/>-- index.html<br/>- src/<br/>-- App.js<br/>-- index.js<br/>- .gitignore<br/>- package-lock.json<br/>- package.json<br/>- README.md</span></pre><p id="9e0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们现在查看<code class="fe ls lt lu lv b">public/index.html</code>的内部，我们会看到一些评论，以及对我们删除的内容的引用。我也清理了这个文件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">清理由create-react-app生成的index.html文件</figcaption></figure><p id="0907" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">src/App.js</code>和<code class="fe ls lt lu lv b">src/index.js</code>也需要一些清理，因为我们删除了他们导入的一些东西，比如<code class="fe ls lt lu lv b">App.css.</code></p><p id="cb9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是清理后的<code class="fe ls lt lu lv b">index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">清理由create-react-app生成的index.js文件</figcaption></figure><p id="e817" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是清理后的<code class="fe ls lt lu lv b">App.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">清理由create-react-app生成的App.js文件</figcaption></figure><p id="d708" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我还把<code class="fe ls lt lu lv b">App.js</code>转换成了箭头函数。</p><p id="f86f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> NPM套餐:</strong></p><p id="9376" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个项目，我们只需要1个npm包。<code class="fe ls lt lu lv b">react-router-dom.</code>这将允许我们轻松地实现到应用程序的路由。</p><p id="24ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要安装它，请在终端中运行以下命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="08a2" class="ma mb iq lv b gy mc md l me mf">npm install react-router-dom</span></pre><p id="1e98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了配置<code class="fe ls lt lu lv b">react-router-dom</code>,我们需要对<code class="fe ls lt lu lv b">App.js.</code>进行一些修改</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">添加react-router-dom后的App.js</figcaption></figure><p id="adfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们添加了<code class="fe ls lt lu lv b">react-router-dom.</code>的导入，我们还放置了导入到App div中的<code class="fe ls lt lu lv b">Router</code>和<code class="fe ls lt lu lv b">Switch</code>组件。</p><p id="bdfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">Router </code>是将<code class="fe ls lt lu lv b">react-router-dom</code>中的组件放入其中所需的包装器。如果您试图在路由器之外使用库中的任何组件，它将抛出一个错误。</p><p id="e947" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">Switch </code>将允许我们在其中定义特定的路线，这将允许通过链接和重定向导航。</p><p id="ca8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">项目布局:</strong></p><p id="356c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们考虑一下认证用户所涉及的不同页面。我们将需要一个最起码的<code class="fe ls lt lu lv b">login</code>、<code class="fe ls lt lu lv b">signup</code>和<code class="fe ls lt lu lv b">logout </code>页面。这就是我们将在这里包括的内容。当然，在一个真实的应用程序中，你会希望包含诸如忘记密码和修改密码的页面。我将在以后的文章中写这些。另外两个有用的页面是一个<code class="fe ls lt lu lv b">landing page</code>和一个<code class="fe ls lt lu lv b">dashboard</code>。</p><p id="f3b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了<code class="fe ls lt lu lv b">dashboard </code>之外的每个页面都将是公开的，而<code class="fe ls lt lu lv b">dashboard </code>将受到保护并需要认证。</p><p id="75c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我喜欢在react项目中使用的文件结构。然而，你可以随意转换它，因为它与你如何构建组件的功能无关。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4858" class="ma mb iq lv b gy mc md l me mf">- public/<br/>-- index.html<br/>- src/<br/>-- components/ <br/>--- layout/ <br/>---- Navbar.js<br/>-- views/ <br/>--- auth/ <br/>---- Login.js <br/>---- Logout.js <br/>---- Signup.js <br/>--- app/ <br/>---- Dashbaord.js<br/>-- App.js<br/>-- index.js<br/>- .gitignore<br/>- package-lock.json<br/>- package.json<br/>- README.md</span></pre><p id="3704" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建了一些新的目录和文件。我将解释每个工具的作用:</p><p id="51d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">组件:</strong>在这里我们将放置不同的组件，这些组件将被组合起来创建页面。注意，我创建了一个<code class="fe ls lt lu lv b">layout</code>目录。在这里，我喜欢放置会出现在大多数页面上的东西。如导航条和页脚。如果我们有与显示用户帐户信息相关的组件，我会创建另一个文件夹<code class="fe ls lt lu lv b">components/account.</code>,这有助于我组织我的组件。</p><p id="53fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">视图:这里是将向用户显示的完整页面。我在这里有两个文件夹，<code class="fe ls lt lu lv b">auth</code>和<code class="fe ls lt lu lv b">app.</code>在<code class="fe ls lt lu lv b">auth </code>文件夹中，我放置了所有用于用户认证的视图，如<code class="fe ls lt lu lv b">login</code>、<code class="fe ls lt lu lv b">signup</code>和<code class="fe ls lt lu lv b">logout</code>。</p><p id="d746" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">导航条:</strong></p><p id="4cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">navbar组件将是简单的，将出现在每一页。<code class="fe ls lt lu lv b">src/components/layout/Navbar.js</code>内部</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Navbar.js组件</figcaption></figure><p id="f4a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了一些事情。</p><p id="278f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，注意我们正在从<code class="fe ls lt lu lv b">react-router-dom.</code>导入<code class="fe ls lt lu lv b">Link</code>组件，链接组件被渲染为一个<code class="fe ls lt lu lv b">&lt;a&gt;</code>标签。所以:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0099" class="ma mb iq lv b gy mc md l me mf">&lt;Link to='/login'&gt;Login&lt;/Link&gt;</span></pre><p id="8128" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与以下内容相同:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="411e" class="ma mb iq lv b gy mc md l me mf">&lt;a href=”/login”&gt;Login&lt;/a&gt;</span></pre><p id="1743" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe ls lt lu lv b">Link </code>的原因是因为它需要匹配我们将在<code class="fe ls lt lu lv b">App.js</code>中设置的路线。稍后会有更多的介绍。</p><p id="ce03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，注意我们使用了<code class="fe ls lt lu lv b">useState</code>和<code class="fe ls lt lu lv b">useEffect</code>钩子。</p><p id="c987" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用<code class="fe ls lt lu lv b">useState </code>来跟踪用户认证的状态。默认状态是未认证的，因此呈现了<code class="fe ls lt lu lv b">login </code>和<code class="fe ls lt lu lv b">signup Links </code>。如果用户通过了身份验证，那么将转而呈现<code class="fe ls lt lu lv b">dashboard </code>和<code class="fe ls lt lu lv b">logout</code> <code class="fe ls lt lu lv b">Links </code>。这个逻辑由使用三元运算符的条件呈现来处理。你可以在React文档的这里阅读<a class="ae lr" href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4554" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">useEffect </code>钩子用于检查和改变用户的认证状态。它通过在本地存储中检查一个名为<code class="fe ls lt lu lv b">token</code>的键来实现这一点。如果密钥存在，则用户已经通过了身份验证。</p><p id="16dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们要将导航条导入到<code class="fe ls lt lu lv b">App.js</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">App.js在导入并实现了Navbar组件之后</figcaption></figure><p id="b370" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样简单的导入并使用<code class="fe ls lt lu lv b">App.js</code>中的导航条。请注意，它位于路由器内部，但在交换机外部。开关将用于匹配放置在内部的路由。因为我们希望导航条出现在每一页上，所以它被放置在开关之外。但是，因为navbar中的Link组件来自<code class="fe ls lt lu lv b">react-router-dom</code>，所以它必须放在路由器内部。</p><p id="2675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行<code class="fe ls lt lu lv b">npm start</code>,我们应该会在浏览器中看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/9e087984fc767251d3132975998ee963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxgTAVIU3nNPViM9dMwQnA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">npm启动后的导航栏组件示例</figcaption></figure><p id="c288" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这再简单不过了。没有造型或任何花哨的东西。请注意，点击链接还不会导致任何地方。在下一部分，我们将创建<code class="fe ls lt lu lv b">login </code>和<code class="fe ls lt lu lv b">signup </code>页面。</p><p id="158b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">登录和注册页面:</strong></p><p id="818d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">Login </code>和<code class="fe ls lt lu lv b">signup </code>将共享一些相同的功能。尽管在实践中最好不要重复自己，并且以一种可以在组件之间共享的方式编写方法，但我们在这里不会这样做，所以对正在发生的事情100%清楚。</p><p id="f199" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下代码用于<code class="fe ls lt lu lv b">views/auth/Login.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">views/auth/Login.js中的Login.js</figcaption></figure><p id="b86e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了很多事情，但是让我们来分析一下。</p><p id="56d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在4个不同的状态上使用了<code class="fe ls lt lu lv b">useState</code>。</p><p id="ed0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第4行和第5行中设置的<code class="fe ls lt lu lv b">email</code>和<code class="fe ls lt lu lv b">password</code>状态用于形状控制。这些值会在用户键入时更新。您可以在第59行和第68行看到，输入的<code class="fe ls lt lu lv b">onChange</code>属性被设置为通过使用它们的setter方法来更新<code class="fe ls lt lu lv b">email </code>和<code class="fe ls lt lu lv b">password</code>。这些也是在登录请求期间累加的值。</p><p id="a50f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">errors</code>状态用于在出现任何错误的情况下将任何错误推入。如果有错误，您可以从第50行看到它将被呈现。此外，如果登录请求有任何错误，您可以在第42行看到errors被设置为true。</p><p id="6247" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">loading</code>状态用于在请求登录页面和实际呈现页面之间建立缓冲。这是因为如果用户已经通过身份验证，您就不希望再次显示登录页面。相反，您会将它们重定向到<code class="fe ls lt lu lv b">dashboard</code>。您可以在第9到15行的<code class="fe ls lt lu lv b">useEffect </code>钩子中看到这个逻辑。</p><p id="ccee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JSX相当简单。它呈现了一个简单的带有标签的登录表单，并输入了电子邮件和密码。</p><p id="cca6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大部分逻辑在<code class="fe ls lt lu lv b">onSubmit</code>方法中。第18行用于在提交表单时防止页面刷新。在第20到23行中，我们用表单中输入的电子邮件和密码的值创建了一个用户对象。使用这个用户对象，我们向API发出一个获取请求，如第25行到第31行所示。在第32到37行，我们检查请求是否成功。如果是，那么我们将本地存储中的<code class="fe ls lt lu lv b">token</code>设置为API返回的值，然后将经过身份验证的用户重定向到仪表板。我们通过查看API是否返回名为key的身份验证令牌来检查请求是否成功。这在第34行中有明确的说明。第38到43行处理任何错误。如果请求中没有身份验证令牌，这意味着有些地方不对劲。因此，这将清除表单并将<code class="fe ls lt lu lv b">errors</code>切换为true以显示给用户。</p><p id="68ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是<code class="fe ls lt lu lv b">views/auth/Signup.js</code>的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">views/auth/Signup.js中的注册视图代码</figcaption></figure><p id="d73f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注册视图的逻辑与登录几乎相同。主要区别在于密码。这些字段被命名为<code class="fe ls lt lu lv b">password1</code>和<code class="fe ls lt lu lv b">password2.</code>，这是因为当用户注册该网站时，他们需要确认他们的密码。</p><p id="c1b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注册成功后，用户将从请求中收到一个身份验证令牌。该令牌将用于对他们进行身份验证，而不是让他们登录。</p><p id="6dc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们将登录和注册视图导入到<code class="fe ls lt lu lv b">App.js</code>中，并为它们创建一些路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">添加登录和注册后的App.js</figcaption></figure><p id="54f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们导入了<code class="fe ls lt lu lv b">Login</code>和<code class="fe ls lt lu lv b">Signup.</code>记住，即使我们称它们为视图，它们仍然是React组件。视图的概念只是用来组织我们自己和项目。</p><p id="a6ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，请注意<code class="fe ls lt lu lv b">Switch</code>内部的2个新的<code class="fe ls lt lu lv b">Route</code>组件。一个<code class="fe ls lt lu lv b">Route</code>的<code class="fe ls lt lu lv b">path</code>属性(prop)声明了该路径将被呈现的url。在这种情况下，我们使用路线内的<code class="fe ls lt lu lv b">component</code>道具来渲染视图。因此在路线<code class="fe ls lt lu lv b"><a class="ae lr" href="http://localhost:3000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/login</a></code>处将呈现<code class="fe ls lt lu lv b">Login</code>视图。这里的<code class="fe ls lt lu lv b">exact</code>关键字指定在特定的路线上只应该渲染这个视图。</p><p id="78f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注销:</strong></p><p id="ca33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只有在用户已经通过身份验证的情况下，才能访问注销视图。这个视图与登录和注册有很多相同的逻辑。基本上，这是一个表单，用户通过按一个按钮来确认他们想要注销。出于安全目的，注销是作为post请求完成的。</p><p id="5112" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是<code class="fe ls lt lu lv b">views/auth/Logout.js</code>的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在views/auth/Logout.js中找到注销视图</figcaption></figure><p id="5b85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要为<code class="fe ls lt lu lv b">App.js</code>添加一个注销路由:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0612" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">仪表盘:</strong></p><p id="09d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将所有这些放在一起的最后一个视图是仪表板。仪表板将成为受保护的视图。这意味着用户在访问它之前必须经过身份验证。在<code class="fe ls lt lu lv b">react-router-dom</code>有一个比我在这里使用的更好的方法来处理这种情况。我建议仔细阅读。然而，为了简单起见。我将只使用简单的重定向和其他视图中使用的类似逻辑。</p><p id="727b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是<code class="fe ls lt lu lv b">views/app/Dashboard.js</code>的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="22ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意第8行中的检查，查看用户是否通过了身份验证。此外，如果用户可以访问这个页面，那么它会显示他们的电子邮件。</p><p id="943f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论:</strong></p><p id="b989" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个关于使用Django和React的认证系统的简单概述。当然，还需要进行更多的检查。然而，这足以让你开始。</p><p id="c2fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是GitHub上已完成项目回购的<a class="ae lr" href="https://github.com/tarricsookdeo/django-react-auth" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="1dae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有，这里是工作app的视频！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mh l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="119e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢这篇博文，并且觉得它很有用，可以考虑为它鼓掌，并在Medium上关注我。此外，考虑使用我的推荐链接在这里注册媒体<a class="ae lr" href="https://tarricsookdeo.medium.com/subscribe" rel="noopener"/>。只要你还是会员，我就能得到一点回扣。如果你愿意，你也可以在这里给我买杯咖啡。非常感谢！</p></div></div>    
</body>
</html>