<html>
<head>
<title>Adding PostgreSQL to Django in Docker Configuration.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Docker 配置中将 PostgreSQL 添加到 Django。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/adding-postgresql-to-django-in-docker-configuration-18cca442f174?source=collection_archive---------3-----------------------#2022-07-28">https://blog.devgenius.io/adding-postgresql-to-django-in-docker-configuration-18cca442f174?source=collection_archive---------3-----------------------#2022-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7af1d303147730d1348490f24aa53361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyY9VYjxlsy8LlhUU59ZeA.jpeg"/></div></div></figure><p id="829a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将把 PostgreSQL 添加到我们在这里创建的<a class="ae kt" href="https://paulawolesi.medium.com/django-docker-setup-tutorial-4c3e5f8d6def" rel="noopener">项目中。Django 提供了内置的 SQLite 支持，但是即使对于本地开发，您也最好使用像 PostgreSQL 这样的“真正的”数据库，与生产中的数据库相匹配。</a></p><p id="f515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您遵循前面的教程，请进入虚拟环境并从那里继续。</p><h1 id="68f0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">心理战 2</h1><p id="7a23" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在停下来思考一下将一个包安装到 Docker 相对于本地虚拟环境意味着什么是很重要的。在传统项目中，我们会从命令行运行命令<code class="fe lx ly lz ma b">python -m pip install psycopg2-binary</code>来安装 Pyscopg2。但我们现在和 Docker 合作。</p><p id="d0e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有两种选择。首先是在本地安装<code class="fe lx ly lz ma b">psycopg2-binary</code>，然后<code class="fe lx ly lz ma b">pip freeze</code>我们的虚拟环境来更新<code class="fe lx ly lz ma b">requirements.txt</code>。如果我们要使用本地环境，这可能是有意义的。但是由于我们致力于 Docker，我们可以跳过这一步，而是用<code class="fe lx ly lz ma b">psycopg2-binary</code>包更新<code class="fe lx ly lz ma b">requirements.txt</code>。我们不需要进一步更新实际的虚拟环境，因为我们不太可能会使用它。如果我们曾经做过，我们可以基于<code class="fe lx ly lz ma b">requirements.txt</code>更新它。</p><p id="d9cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在你的文本编辑器中，打开现有的<code class="fe lx ly lz ma b">requirements.txt</code>文件，并将<code class="fe lx ly lz ma b">psycopg2-binary</code>添加到底部。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="3f24" class="mj kv in ma b gy mk ml l mm mn">psycopg2-binary</span></pre><p id="a53e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 PostgreSQL 配置更改的最后，我们将构建新的映像并启动我们的容器。但还没有。</p><h1 id="e0a3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">一种数据库系统</h1><p id="d146" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在现有的<code class="fe lx ly lz ma b">docker-compose.yml</code>文件中添加一个名为<code class="fe lx ly lz ma b">db</code>的新服务。这意味着我们的 Docker 主机中将运行两个独立的容器:<code class="fe lx ly lz ma b">web</code>用于 Django 本地服务器，而<code class="fe lx ly lz ma b">db</code>用于 PostgreSQL 数据库。</p><p id="307c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">web</code>服务依赖于<code class="fe lx ly lz ma b">db</code>服务来运行，所以我们将在<code class="fe lx ly lz ma b">web</code>中添加一行<code class="fe lx ly lz ma b">depends_on</code>来表示这一点。</p><p id="6888" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe lx ly lz ma b">db</code>服务中，我们指定使用哪个版本的 PostgreSQL。在撰写本文时，Heroku 支持版本<code class="fe lx ly lz ma b">13</code>作为最新发布版，所以我们将使用它。Docker 容器是短暂的，这意味着当容器停止运行时，所有信息都会丢失。这对我们的数据库来说显然是个问题！解决方案是创建一个名为<code class="fe lx ly lz ma b">postgres_data</code>的<code class="fe lx ly lz ma b">volumes</code>挂载，然后将其绑定到位于<code class="fe lx ly lz ma b">/var/lib/postgresql/data/</code>的容器中的一个专用目录。最后一步是为<code class="fe lx ly lz ma b">db</code>向<code class="fe lx ly lz ma b">environment</code>添加一个<a class="ae kt" href="https://www.postgresql.org/docs/current/auth-trust.html" rel="noopener ugc nofollow" target="_blank">信任认证</a>。对于有许多数据库用户的大型数据库，建议使用更明确的权限，但是当只有一个开发人员时，这个设置是一个很好的选择。</p><p id="0f97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新后的文件如下所示:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7a88" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">version</strong>: "3.9"<br/><br/>services:<br/>  web:<br/>    build: .<br/>    command: python <strong class="ma io">/</strong>code<strong class="ma io">/</strong>manage.py runserver 0.0.0.0:8000<br/>    volumes:<br/>      <strong class="ma io">-</strong> .:<strong class="ma io">/</strong>code<br/>    ports:<br/>      <strong class="ma io">-</strong> 8000:8000<br/>    depends_on:<br/>      <strong class="ma io">-</strong> db<br/>  db:<br/>    image: postgres:13<br/>    volumes:<br/>      <strong class="ma io">-</strong> postgres_data:<strong class="ma io">/</strong>var<strong class="ma io">/</strong>lib<strong class="ma io">/</strong>postgresql<strong class="ma io">/data/</strong><br/>    environment:<br/>      <strong class="ma io">-</strong> "POSTGRES_HOST_AUTH_METHOD=trust"<br/><br/>volumes:<br/>  postgres_data:</span></pre><h1 id="22a0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">数据库</h1><p id="c281" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">第三步也是最后一步是更新<code class="fe lx ly lz ma b">django_project/settings.py</code>文件，使用 PostgreSQL 而不是 SQLite。在文本编辑器中，向下滚动到<code class="fe lx ly lz ma b">DATABASES</code>配置。</p><p id="093c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，Django 将<code class="fe lx ly lz ma b">sqlite3</code>指定为数据库引擎，将其命名为<code class="fe lx ly lz ma b">db.sqlite3</code>，并将其放在<code class="fe lx ly lz ma b">BASE_DIR</code>处，这意味着在我们的项目级目录中。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="56ab" class="mj kv in ma b gy mk ml l mm mn"><em class="mo"># django_project/settings.py</em><br/>DATABASES <strong class="ma io">=</strong> {<br/>    "default": {<br/>        "ENGINE": "django.db.backends.sqlite3",<br/>        "NAME": BASE_DIR <strong class="ma io">/</strong> "db.sqlite3",<br/>    }<br/>}</span></pre><p id="6ce5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了切换到 PostgreSQL，我们将更新<a class="ae kt" href="https://docs.djangoproject.com/en/4.0/ref/settings/#std:setting-DATABASE-ENGINE" rel="noopener ugc nofollow" target="_blank">引擎</a>配置。PostgreSQL 需要一个<code class="fe lx ly lz ma b">NAME</code>、<code class="fe lx ly lz ma b">USER</code>、<code class="fe lx ly lz ma b">PASSWORD</code>、<code class="fe lx ly lz ma b">HOST</code>和<code class="fe lx ly lz ma b">PORT</code>。为了方便起见，我们将前三个设置为<code class="fe lx ly lz ma b">postgres</code>，将<code class="fe lx ly lz ma b">HOST</code>设置为<code class="fe lx ly lz ma b">db</code>，这是我们在<code class="fe lx ly lz ma b">docker-compose.yml</code>中设置的服务的名称，将<code class="fe lx ly lz ma b">PORT</code>设置为<code class="fe lx ly lz ma b">5432</code>，这是默认的 PostgreSQL <a class="ae kt" href="https://en.wikipedia.org/wiki/Port_%28computer_networking%29" rel="noopener ugc nofollow" target="_blank">端口</a>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="1514" class="mj kv in ma b gy mk ml l mm mn"># django_project/settings.py<br/>DATABASES = {<br/>    "default": {<br/>        "ENGINE": "django.db.backends.postgresql",<br/>        "NAME": "postgres",<br/>        "USER": "postgres",<br/>        "PASSWORD": "postgres",<br/>        "HOST": "db",  # set in docker-compose.yml<br/>        "PORT": 5432,  # default postgres port<br/>    }<br/>}</span></pre><p id="a17c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！我们可以构建包含<code class="fe lx ly lz ma b">psycopg2-binary</code>的新映像，并使用以下单一命令在分离模式下启动这两个容器:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="39c7" class="mj kv in ma b gy mk ml l mm mn">$ docker-compose up -d --build</span></pre><p id="f880" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在<code class="fe lx ly lz ma b">http://127.0.0.1:8000/</code>刷新 Django 欢迎页面，它应该可以工作，这意味着 Django 已经通过 Docker 成功连接到 PostgreSQL。</p><p id="bd9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Docker 中运行命令与在传统的 Django 项目中略有不同。例如，为了<code class="fe lx ly lz ma b">migrate</code>在 Docker 中运行的新 PostgreSQL 数据库，执行以下命令:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c73e" class="mj kv in ma b gy mk ml l mm mn">$ docker-compose exec web python manage.py migrate</span></pre><p id="8f1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想运行<code class="fe lx ly lz ma b">createsuperuser</code>，你也可以用<code class="fe lx ly lz ma b">docker-compose exec web...</code>作为前缀，所以:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a1c3" class="mj kv in ma b gy mk ml l mm mn">$ docker-compose exec web python manage.py createsuperuser</span></pre><p id="6cf5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">诸如此类。当你完成后，不要忘记关闭你的 Docker 容器，因为它会消耗大量的计算机内存。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="1b51" class="mj kv in ma b gy mk ml l mm mn">$ docker-compose down</span></pre><h1 id="354b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">快速回顾</h1><p id="1018" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">以下是我们在这篇文章中提到的术语和概念的简短版本:</p><ul class=""><li id="a906" class="mp mq in jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated"><strong class="jx io">图片</strong>:你项目的“定义”</li><li id="749b" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated"><strong class="jx io">容器</strong>:你的项目实际运行的地方(图像的一个实例)</li><li id="9610" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated"><strong class="jx io"> Dockerfile </strong>:定义你的图像的样子</li><li id="8dea" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated"><strong class="jx io"> docker-compose.yml </strong>:一个<a class="ae kt" href="http://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>文件，它接受 docker 文件，并为我们的 Docker 容器在生产中应该如何表现添加额外的指令</li></ul><p id="6a08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe lx ly lz ma b">Dockerfile</code>来告诉 Docker 如何建立我们的<em class="mo">形象</em>。然后我们在一个<em class="mo">容器</em>中运行我们的实际项目。<code class="fe lx ly lz ma b">docker-compose.yml</code>文件提供了 Docker 容器在生产中应该如何表现的附加信息。</p><p id="c71b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这篇文章，请给它一两个掌声，如果你有任何问题或疑问，请在下面的评论中留下。</p></div></div>    
</body>
</html>