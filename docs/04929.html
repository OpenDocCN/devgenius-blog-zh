<html>
<head>
<title>InDepth: Interactables. Design and implement using UnityEvents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度:可交互。使用UnityEvents设计和实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/indepth-interactables-design-and-implement-using-unityevents-9c81ee317eaa?source=collection_archive---------2-----------------------#2021-05-23">https://blog.devgenius.io/indepth-interactables-design-and-implement-using-unityevents-9c81ee317eaa?source=collection_archive---------2-----------------------#2021-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a68e" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">《深度》是一个关于在Unity中构建游戏的原子组件的系列。每周我都会深入研究游戏设计的一个方面，无论是<em class="kj">跳跃、移动</em>还是今天的<em class="kj">互动。本系列的一个条目涵盖了游戏设计中每个组件的考虑因素，并讨论了它们的实现。此外，我的目标应该是保持这些组件<em class="kj">的模块化、可定制化、</em>和<em class="kj">的可伸缩性</em>，因为我希望它们成为我未来项目的基本构建模块！</em></p><p id="8578" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">我试图在覆盖每个组件的尽可能多的方面，深入细节，以及像概述或游戏设计词典一样深入工作之间取得平衡。所以，事不宜迟，让我们开始吧！</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/87c0018f4e709dc62d27ef358e1bdf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EianxWqRo6VbCu_2eBhqZA.gif"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">一个可交互的终端从以前的游戏蠕虫过滤</figcaption></figure><h1 id="e68c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">TLDR；</h1><p id="9f18" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">向玩家传达互动的存在，并把它们组织起来，这是好的互动设计的重要部分。我们可能需要使用听觉和视觉提示以及UI元素来向玩家解释我们的交互。这种实现应该允许很大的灵活性，因为个人交互的方式和他们修改的游戏组件会有很大的变化。为了符合这一要求，我们可以实施以下措施:</p><ul class=""><li id="efa5" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated">创建两个触发器，记录玩家是否在附近(用于提供线索或框架)以及玩家是否在交互范围内。一个触发器的事件需要从子组件中冒泡。</li><li id="b535" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">使用<strong class="jn io"> UnityEvents </strong>在检查器中公开这些事件。这允许任意数量的游戏对象具有在满足这些触发条件时运行的功能。</li><li id="af5f" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">使用菜单和开关状态根据激活方法改变行为，即按下、释放、保持、空闲。</li><li id="bb64" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">为简单的复制和复杂的抽象创建一个预置。</li></ul><p id="847a" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">交互组件的代码相对简单，因为大多数功能需要在其他地方实现。它主要包装样板代码。尽管如此，当我们的游戏变大时，考虑设计并确保它适当地缩放确实对我们有很大的好处！</p><h1 id="9e20" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设计制作精良的可交互设备</h1><p id="1c78" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">互动可以是很多事情。躲在石头栅栏后面，拿起武器，打开电灯开关，或者发现一颗罕见的钻石，这只是几个例子。我们需要向玩家传达互动的存在，我们也需要设计这种互动。让我们从最后一个开始，分别看一下这些:</p><h2 id="3723" class="mr lb in bd lc ms mt dn lg mu mv dp lk jw mw mx lo ka my mz ls ke na nb lw nc bi translated">设计互动</h2><p id="e45a" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">在这一点上，玩家已经意识到有一个交互要做，以及为了执行他需要采取的步骤。对于实施而言，一个重要的考虑因素是交互作用的效果通常与交互作用本身无关，即:</p><ul class=""><li id="1780" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated"><em class="kj">隐蔽</em>。修改<strong class="jn io">角色</strong>的生命值和移动。可能它改变了<strong class="jn io">相机</strong>的角度。</li><li id="e2c0" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">拿起武器</em>。可能会改变“火”<strong class="jn io">脚本</strong>和<strong class="jn io">武器动画</strong>上的变量。</li><li id="8f66" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">打开灯开关</em>。这一个打开一盏灯<strong class="jn io">游戏对象</strong>，它甚至不一定靠近可交互的(灯开关)。</li></ul><p id="4ee1" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">关键是:与角色相关的代码也应该附加到角色上。对交互者来说不是。当我们稍后讨论实现时，我们将回到这一点。</p><p id="5dab" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">接下来，我们需要确定一种交互方式。<em class="kj">我们将特别关注单键交互</em>。这些往往与角色的世界空间联系在一起，也就是说，互动发生在角色当前居住的任何地方。请注意，存在大量其他形式，例如鼠标点击、拖动、点击、身体传感器或相机，更不用说虚拟现实了。但是让我们保持简单。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nd"><img src="../Images/89ff9fb3378b68f300f25952a1a48e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w2xss21LRYFwRWt2JQquDw.gif"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">拖动交互式</figcaption></figure><p id="f7b6" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated"><a class="ae ne" href="https://www.davideaversa.it/blog/game-design-essentials-single-button-controls/" rel="noopener ugc nofollow" target="_blank">Davide Aversa的这篇文章</a>深入探讨了单个按钮的输入状态，即<em class="kj">按下、释放、保持、空闲(无所事事)、节奏</em>。虽然我鼓励你自己去读这篇文章，但这里有一些主要的收获和我自己的观察:</p><ul class=""><li id="85b6" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated"><em class="kj">按下</em>。又快又直接。中立玩家感觉。适用于经常发生、需要快速执行或依赖反应的动作。</li><li id="3f32" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">发布</em>。模拟正在释放的张力/力。如果玩家需要做出一个非常重要或情绪化的决定，你可以尝试只在释放按键时<em class="kj">关闭</em>动作。还要注意，释放一个键的反应时间比按下一个键的反应时间要快。当然，它要求用户已经拿着钥匙。</li><li id="e29b" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">按住</em>。适用于被认为需要持续努力的动作，例如绳子摆动、推/拉障碍物、汽车加速等。也为我们提供了一种从二进制按钮创建非二进制值范围的方法。</li><li id="5c4d" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">闲置</em>。在RPG中自动拾取物品或在环形转轮中向前推动可以被分配到这个类别。适用于经常发生或对玩家来说无关紧要的动作。</li><li id="6a19" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">节奏。指重复按下按钮。快节奏是一种给玩家施加体力的方式。当角色打开一扇厚重的门，玩家必须按下按钮时使用。另一种较慢的节奏可用于锻造或其他持续精密动作的情况。更多信息请见Davide Aversa 的文章。</li></ul><h2 id="6f1b" class="mr lb in bd lc ms mt dn lg mu mv dp lk jw mw mx lo ka my mz ls ke na nb lw nc bi translated">交流互动</h2><p id="feac" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">正如上一节所述，玩家需要1)意识到交互的存在，2)知道如何执行它。让我们看一下存储或呈现这些信息的三个层次。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nd"><img src="../Images/f9841bdaf13af4df790c49b503e70098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D2mIbNPVw8SWgWtOm0IkaA.gif"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">可互动的摄像机取景(最后一个白盒)</figcaption></figure><ul class=""><li id="c8d7" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated"><em class="kj">知识、习俗和一致性。</em>作为游戏玩家，我们习惯于以某种方式看待事情。发光、移动或突出的东西很可能被认为是可交互的，也能吸引玩家的注意力。我们可以使用惯例，例如使用E键进行互动，和/或教玩家如何在整个游戏过程中进行互动。坚持使用可识别的共享外观也是有帮助的。</li><li id="3a73" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">非死亡元素</em>。我真的不知道该用什么词来形容这个——但基本上是所有不属于游戏世界的东西。例如，这包括用户界面弹出窗口、画外音、广告词、声音、摄影和取景。所有这些都是他们自己的主题，但考虑一下，例如，如果玩家在附近，一个摄像头会拍摄重要的项目(见示例)，或者一个图标声音，每当一个新的交互出现在屏幕上时就会播放！</li><li id="fb26" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj">游戏世界元素。</em> <strong class="jn io"> <em class="kj"> </em> </strong>这可能是游戏中的路标，一个看着可互动方向的角色，战术性放置以吸引注意力的灯光，或者来自角色的音频提示，让玩家知道有东西在附近。作为一个旁注，这是一个很好的做法，当依赖声音提示时，要确保有大量的视觉提示来补充它们，因为不是所有的玩家都选择在听觉能力上加分！</li></ul><p id="9cf1" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">现在，我们可以在这里提到这么多，但是所有这些，正如我们之前讨论的，都不是交互作用本身的一部分。我们只需要意识到它们，并使我们容易将它们绑定到交互对象上。</p><h1 id="6e3b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实施</h1><p id="9a09" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">考虑到我们到目前为止讨论的所有内容，看起来我们想要的是<strong class="jn io">公开一堆事件</strong>，我们可以在我们的项目中绑定任意代码！交互者只负责在适当的时候运行代码。</p><p id="b91e" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">请记住，我们希望支持以下两种通信:1)交互对象相对较近，2)玩家处于可以进行交互的范围内，以及3)玩家已经进行了交互。知道玩家是否已经离开这些区域也是有用的！您可以随意命名这些事件，但我们应该公开类似以下事件的内容:</p><ul class=""><li id="5fc8" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated"><em class="kj"> onInteract </em>。玩家进行了互动。</li><li id="782d" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj"> onInteractableEnter </em>。玩家在进行互动的范围内。</li><li id="0d09" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj"> onInteractableExit </em>。玩家已经离开了他可以互动的范围。</li><li id="f6b6" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj"> onNotifyingEnter </em>。玩家离你很近，你可能想向玩家暗示互动就在附近。</li><li id="1f8e" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated"><em class="kj"> onNotifyingExit </em>。玩家再次离开了这个范围。</li></ul><p id="a43d" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">接下来输入:<strong class="jn io"> UnityEvents </strong>。这些东西真的很厉害。您可以像这样定义和使用它们:</p><pre class="kl km kn ko gt nf ng nh ni aw nj bi"><span id="57ba" class="mr lb in ng b gy nk nl l nm nn">[SerializeField] private UnityEvent onNotifyingEnter;<br/>//...<br/>onNotifyingEnter.Invoke();</span></pre><p id="47f9" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">这样我们就可以创建一个每次在onNotifyingEnter上运行的函数列表。调用Invoke()。假设我们想在玩家接近交互对象时将摄像机移得更远。为此，在相机的脚本中创建一个具有缩小行为的函数。将摄像机拖动到UnityEvent onNotifyingEnter。可能对重置缩放进行同样的操作。它可能看起来像这样:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi no"><img src="../Images/43625c316339360e20a5c55ec64b4a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*sRHbZougoWt77PWeNdQo7Q.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">相机行为的单位事件</figcaption></figure><p id="6e4a" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">如果玩家使用两个设置为触发的碰撞器进入相关范围，我们可以注册。现在，Unity并不热衷于在一个游戏对象上安装多个碰撞器。出于这个原因，我们实际上需要在子对象上放置一个触发器，并使用一个脚本将触发器事件冒泡到父对象:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">从子到父的气泡触发事件</figcaption></figure><p id="ce03" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">最后一件事是创建实际的交互。还记得我们对按钮输入状态的讨论吗？我们可以这样用一个<strong class="jn io">枚举</strong>来建模(它将在检查器中创建一个下拉列表):</p><pre class="kl km kn ko gt nf ng nh ni aw nj bi"><span id="31ee" class="mr lb in ng b gy nk nl l nm nn">private enum activationMode {press, release, hold, idle};<br/>[SerializeField] private activationMode mode = activationMode.press;</span></pre><p id="a7e8" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">然后根据<em class="kj">模式</em>的值设置，我们可以不同地处理输入。我在自己的实现中使用了switch语句。它是这样工作的:</p><ul class=""><li id="f8c7" class="md me in jn b jo jp js jt jw mf ka mg ke mh ki mi mj mk ml bi translated">在模式为<em class="kj"> idle </em>的情况下，当玩家进入交互范围时，onInteract被调用一次。</li><li id="59be" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">如果模式是<em class="kj">按下</em>或<em class="kj">释放</em>，我会对输入进行额外的检查。GetKeyDown(键)和输入。分别为GetKeyUp(key)。</li><li id="8fac" class="md me in jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">最后，<em class="kj">保持</em>被设置为只要使用输入按下键就持续调用。GetKey(key)。</li></ul><h2 id="1b19" class="mr lb in bd lc ms mt dn lg mu mv dp lk jw mw mx lo ka my mz ls ke na nb lw nc bi translated">最后几个音符</h2><p id="cf03" class="pw-post-body-paragraph jl jm in jn b jo ly jq jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki ig bi translated">你可能注意到我选择了省略<em class="kj">节奏。</em>这个我认为更多的是<em class="kj">按下</em>或者<em class="kj">释放</em>的延伸。因此，它不能直接在可交互的。</p><p id="14a3" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">作为一个想法，你也可以实现一个延迟动作，只在用户按住键一段时间后调用。这取决于你的游戏，并且会带来一些复杂的问题(例如，一些东西，比如UI，应该立即被调用)。</p><p id="d9b6" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">这就结束了本周对交互的深入探讨。一如既往，这些简单事物的复杂性不断让我震惊！</p><p id="a92f" class="pw-post-body-paragraph jl jm in jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ig bi translated">我希望这能让你感兴趣。干杯！</p></div></div>    
</body>
</html>