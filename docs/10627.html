<html>
<head>
<title>Interactive Server-Rendered Webapps: You Don’t Need JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交互式服务器呈现的 web 应用:你不需要 JavaScript</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/interactive-server-rendered-webapps-you-dont-need-javascript-32fa847c6a1a?source=collection_archive---------2-----------------------#2022-11-17">https://blog.devgenius.io/interactive-server-rendered-webapps-you-dont-need-javascript-32fa847c6a1a?source=collection_archive---------2-----------------------#2022-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/772ea772406718483d09479ec88ebf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*feM1vqCJOci2Uah5.png"/></div></figure><p id="f03f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你是一个前端开发人员，喜欢了解最新的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>生态系统，你总是在一个疯狂的旅程中。生态系统以惊人的速度前进，有时一路上会出现瓶颈。构建一个现代的 JavaScript 前端通常涉及到<a class="ae ks" href="https://blixtdev.com/you-dont-need-webpack-3-better-alternatives-for-building-your-javascript/" rel="noopener ugc nofollow" target="_blank">一层又一层的工具</a>、<a class="ae ks" href="https://blixtdev.com/all-about-reacts-new-use-hook/" rel="noopener ugc nofollow" target="_blank">越来越不透明的框架</a>，以及各种各样的配置和兼容性问题。</p><p id="8818" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我要告诉你一个小秘密:<strong class="jw ir">你不需要编写 JavaScript 来构建丰富的交互式 web 应用</strong> <em class="kt">。新一代框架让你可以编写看起来和感觉上都像单页应用程序(spa)的 web 应用程序，但是完全由服务器驱动——没有 JavaScript。</em>这种方法是由<a class="ae ks" href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html" rel="noopener ugc nofollow" target="_blank"> LiveView </a>为<a class="ae ks" href="http://elixir-lang.org" rel="noopener ugc nofollow" target="_blank"> Elixir </a>中的<a class="ae ks" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank"> Phoenix framework </a>首创的，但现在也为各种其他语言和框架实现。</p><p id="2c93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了避免给人留下讨厌 JavaScript 的印象，我会注意到我几乎每天都在项目中使用 JavaScript，尤其是那些严重依赖浏览器 API 的项目。这里的重点不是你应该<em class="kt">永远不要</em>使用 JavaScript 来构建 webapp，只是<em class="kt">大多数 web app 不需要服务器+客户端 app 的方法。</em>在本帖中，我们将关注交互式服务器渲染方法，为什么它如此强大，以及一些用多种语言提供这种功能的框架。</p><h1 id="cb1e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">交互式服务器呈现的 web 应用程序是如何工作的？</h1><p id="c255" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">尽管具体细节会因框架而有所不同，LiveView 和类似的产品就像普通的服务器渲染 HTML 方法一样工作，除了当应用程序状态改变时，它们向客户端发送动态更新而无需重新加载页面。</p><p id="3a21" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">LiveView 基于当前服务器状态使用简单的声明性 HTML 呈现。当客户机状态改变时，HTML 模板被重新呈现，任何改变都以小而紧凑的差异发送给客户机。神奇的事情发生在后台，客户端和服务器之间有一个持久的 websocket 连接。</p><p id="0cdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，客户端有一些 JavaScript 来维护 websocket 连接并管理更改，但是这些都是内置在框架中的，不需要开发人员编写一行 JavaScript。</p><p id="ed72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们快速看一个例子，取自 LiveView 文档，但为了演示的目的进行了简化。这里我们构建了一个简单的恒温器组件:</p><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="3a30" class="mg kv iq mc b be mh mi l mj mk">defmodule MyAppWeb.ThermostatLive do <br/>  use Phoenix.LiveView <br/><br/>  # Set initial view state <br/>  def mount(_params, %{}, socket) do <br/>    {:ok, assign(socket, :temperature, 0)} <br/>  end <br/><br/>  # Respond to "increment" event, update state <br/>  def handle_event("increment", _value, socket = %{assigns: assigns) do <br/>    {:noreply, assign(socket, :temperature, assigns.temperature + 1)} <br/>  end <br/><br/>  # Render the view <br/>  def render(assigns) do <br/>    ~H"""<br/>    &lt;div&gt; <br/>      Current temperature: &lt;%= @temperature %&gt; <br/>      &lt;button phx-click="increment"&gt;+&lt;/button&gt; <br/>    &lt;/div&gt;""" <br/>  end <br/>end</span></pre><p id="690a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您不熟悉 Elixir，语法和约定可能会有点奇怪，但它的要点很简单:我们有一个带有初始状态的 LiveView(在 LiveView 中称为<code class="fe ml mm mn mc b">assigns</code>)，一些通过<code class="fe ml mm mn mc b">handle_event</code>修改状态的事件处理，以及一个在<code class="fe ml mm mn mc b">render</code>函数中的模板。特殊的<code class="fe ml mm mn mc b">phx-click</code>属性将按钮点击绑定到后端事件。一旦这个视图呈现在客户机上，任何时候<code class="fe ml mm mn mc b">temperature</code>赋值发生变化，客户机都会自动更新新的 HTML。</p><p id="7e34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个简单的例子展示了如何在没有 JavaScript 代码的情况下实现基本的交互性。我们可以很容易地将这种想法推广到具有附加状态、模板和子组件的更复杂的交互中。</p><h1 id="ee98" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">包含一小部分代码的交互式 web 应用程序</h1><p id="94f0" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">使用像 LiveView 这样的交互式服务器渲染方法并不是为了避免 JavaScript 而避免 JavaScript:它是关于编写比单独构建服务器和客户端应用少得多的代码。让我们来看看一些你<em class="kt">不必</em>用交互式服务器渲染方法编写的代码:</p><ul class=""><li id="fa4e" class="mo mp iq jw b jx jy kb kc kf mq kj mr kn ms kr mt mu mv mw bi translated">客户端状态管理</li><li id="cde8" class="mo mp iq jw b jx mx kb my kf mz kj na kn nb kr mt mu mv mw bi translated">服务器 API</li><li id="1547" class="mo mp iq jw b jx mx kb my kf mz kj na kn nb kr mt mu mv mw bi translated">API 客户端</li><li id="a363" class="mo mp iq jw b jx mx kb my kf mz kj na kn nb kr mt mu mv mw bi translated">客户机/服务器同步逻辑(包括轮询或基于套接字的“推送”)</li><li id="b5c6" class="mo mp iq jw b jx mx kb my kf mz kj na kn nb kr mt mu mv mw bi translated">重复的数据模型</li><li id="5204" class="mo mp iq jw b jx mx kb my kf mz kj na kn nb kr mt mu mv mw bi translated">重复的验证逻辑</li></ul><p id="edcd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然不是每一个基于 JS 的前端都要求你实现列表中的每一项，但是这些都是你需要为大多数单页面应用程序构建和维护的。其中一些项目可能很简单，许多可以借助框架或外部库，但尽管如此，这些基本上都是需要在传统的客户端单页面应用程序中构建和维护的东西。</p><p id="1cf2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过采用交互式的、服务器呈现的方法，您可以实现相同的功能，同时编写和维护更少的代码。</p><h1 id="bdf9" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">框架</h1><p id="00e5" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">交互式服务器呈现方法有多种不同的语言和框架。虽然它们在方法上有所不同，工作方式可能与 LiveView 不完全相同，但它们都实现了相同的核心概念:消除了对基于 JavaScript 的独立前端的需求。</p><h1 id="8da2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">灵药的实时视图</h1><p id="852c" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">开始这一切的服务:<a class="ae ks" href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html" rel="noopener ugc nofollow" target="_blank"> LiveView </a>，作为<a class="ae ks" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank">凤凰框架</a>的一部分，用于<a class="ae ks" href="http://elixir-lang.org" rel="noopener ugc nofollow" target="_blank">仙丹语言</a>。甚至在 LiveView 之外，Phoenix 和 Elixir 提供了惊人的生产力和坚如磐石的高性能基础，所以如果你还没有挑选出另一种语言或框架，我肯定会把 Phoenix 作为我的首选。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/phoenixframework/phoenix_live_view" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">GitHub-phoenix framework/phoenix _ live _ view:丰富的实时用户体验，通过服务器渲染…</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">通过服务器渲染的 HTML-GitHub-phoenix framework/phoenix _ live _ view:Rich…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt js nf"/></div></div></a></div><h1 id="8cb6" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Blazor for C#</h1><p id="7979" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如果你在<a class="ae ks" href="https://dotnet.microsoft.com/en-us/" rel="noopener ugc nofollow" target="_blank">工作。NET 生态系统</a>，你可以从<a class="ae ks" href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor" rel="noopener ugc nofollow" target="_blank"> Blazor </a>获得类似的功能。Blazor 允许你完全用 C#编写 web-app 组件逻辑。除了服务器渲染的方法，Blazor 还支持基于 C#的组件通过<a class="ae ks" href="https://webassembly.org" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>在客户端运行。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/dotnet/aspnetcore" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">GitHub-dot net/aspnetcore:ASP.NET 核心是一个跨平台的。NET 框架来构建现代…</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">ASP。NET Core 是跨平台的。NET 框架，用于在 Windows、Mac 或……上构建基于云的现代 web 应用程序</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt js nf"/></div></div></a></div><h1 id="d0d1" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Java 的 Vaadin</h1><p id="f992" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">对于<a class="ae ks" href="https://www.java.com/en/" rel="noopener ugc nofollow" target="_blank"> Java </a>开发者来说，<a class="ae ks" href="https://vaadin.com" rel="noopener ugc nofollow" target="_blank"> Vaadin </a>框架让你“从 UI 组件构建你的应用，而无需接触 HTML 或 JavaScript”。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/vaadin/platform" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">GitHub-vaadin/platform:vaa din platform 10+是一个基于 vaa din 的 Java web 开发平台…</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Vaadin platform 10+是一个基于 Vaadin web 组件的 Java web 开发平台。如果你不知道去哪…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt js nf"/></div></div></a></div><h1 id="27b5" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">PHP 的 LiveWire</h1><p id="1f45" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如果你使用<a class="ae ks" href="https://www.php.net" rel="noopener ugc nofollow" target="_blank"> PHP </a>作为你的后端，你也可以使用<a class="ae ks" href="https://laravel-livewire.com" rel="noopener ugc nofollow" target="_blank"> LiveWire for Laravel </a>来扩展它以覆盖交互式前端。</p><div class="nc nd gp gr ne nf"><a href="https://laravel-livewire.com/docs/2.x/quickstart" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">快速入门| Livewire</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">包括 PHP。包括 JavaScript(在将使用 Livewire 的每个页面上)。运行以下命令以…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">laravel-livewire.com</p></div></div><div class="no l"><div class="nw l nq nr ns no nt js nf"/></div></div></a></div><h1 id="5957" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">JavaScript 的火山口:</h1><p id="53c9" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">等等——整篇文章不都是在说<em class="kt">而不是</em>使用 JavaScript 吗？是的，但这并不是专门为了避免 JS，而是为了不构建和维护单独的客户端应用程序。如果你想利用交互式服务器渲染的方法，但是<em class="kt">希望</em>在后端使用 JavaScript，你可以！<a class="ae ks" href="https://github.com/calderajs/caldera-react" rel="noopener ugc nofollow" target="_blank"> Caldera </a>让我们用服务器端执行 React 来构建前端。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/calderajs/caldera-react" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">GitHub-calderajs/caldera-React:React 的服务器端执行🌋</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Caldera 是 React 的服务器端执行环境。可以把它想象成 Phoenix LiveView - all 的 Node.js 模拟版…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="nx l nq nr ns no nt js nf"/></div></div></a></div><h1 id="49c2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">概述</h1><p id="8109" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">这些交互式服务器呈现的方法是目前 web 开发中最好的保密方法。LiveView 和类似的框架可以让你用传统单页应用程序的一小部分时间和精力来构建 web 应用程序。本质上，这种方法通过让你构建一个<em class="kt">应用而不是两个<em class="kt">应用(前端和后端)来加速开发，并避免 JavaScript 生态系统的复杂性。</em></em></p><p id="4d67" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您想了解更多关于这种方法的信息，或者想直接使用 LiveView 构建应用程序，请查看以下内容！</p><div class="nc nd gp gr ne nf"><a rel="noopener  ugc nofollow" target="_blank" href="/why-your-next-frontend-might-be-the-backend-b43ff1ca9720"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">为什么你的下一个 Web 应用前端可能是后端</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">LiveView 和其他实时服务器端渲染 HTML 技术如何改变前端的编写方式</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">blog.devgenius.io</p></div></div><div class="no l"><div class="ny l nq nr ns no nt js nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://betterprogramming.pub/real-time-chat-with-phoenix-liveview-in-fewer-than-50-lines-of-code-1b2cf8af7301" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">用不到 50 行代码构建与 Phoenix 和 LiveView 的实时聊天</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Phoenix 和 LiveView 如何简化客户端之间可扩展的实时通信</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better 编程. pub</p></div></div><div class="no l"><div class="nz l nq nr ns no nt js nf"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="fdae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt">原载于 2022 年 11 月 17 日 https://blixtdev.com</em><a class="ae ks" href="https://blixtdev.com/you-dont-need-javascript-to-build-rich-interactive-webapps/" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a><em class="kt">。</em></p><p id="ef71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">乔纳森写了一些关于创业、软件工程和健康科学的文章。如果你喜欢这篇文章，请考虑加入 Medium 来支持 <a class="ae ks" href="https://javascript.plainenglish.io/@jonnystartup/membership" rel="noopener ugc nofollow" target="_blank"> <em class="kt">乔纳森和其他数以千计的作者</em> </a> <em class="kt">。</em></p></div></div>    
</body>
</html>