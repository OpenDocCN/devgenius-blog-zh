<html>
<head>
<title>Microservices [Part 3] — With Maven, Spring Boot, And Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务[第三部分] —与 Maven、Spring Boot 和 Docker 合作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservices-part-3-with-maven-spring-boot-and-docker-e750fd62dce7?source=collection_archive---------1-----------------------#2022-02-25">https://blog.devgenius.io/microservices-part-3-with-maven-spring-boot-and-docker-e750fd62dce7?source=collection_archive---------1-----------------------#2022-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f1af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在微服务系列的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/microservices-part-1-with-maven-spring-boot-and-docker-4888a6bd05b5"> <strong class="jm io"> <em class="kj"> part 1 </em> </strong> </a>和<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/microservices-part-2-with-maven-spring-boot-and-docker-a9e9745180bd"> <strong class="jm io"> <em class="kj"> part 2 </em> </strong> </a>中，我们花了一些时间构建了两个简单的微服务——<strong class="jm io"><em class="kj">学生</em> </strong>和<strong class="jm io"> <em class="kj">抄袭</em> </strong>，并在它们之间建立了 HTTP 通信。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi kk"><img src="../Images/943a641a8ca8f1223eaf322b21b4c704.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/1*ziA9G9dSxiyqeqttbAtd0Q.gif"/></div></figure><p id="1ebc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，当您的应用程序需要伸缩并且您有多个实例在运行时，这可能不是一个好的解决方案。在这种情况下，微服务需要知道该应用程序的所有现有端口。这可能会成为一个相当复杂的问题，并变成一场噩梦。</p><p id="54c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我将向您展示如何使用<strong class="jm io"> <em class="kj">服务注册中心</em> </strong>来解决这个问题。到<strong class="jm io"> <em class="kj">源代码库</em> </strong>的链接将在本教程的末尾添加。</p><h2 id="d364" class="ks kt in bd ku kv kw dn kx ky kz dp la jv lb lc ld jz le lf lg kd lh li lj lk bi translated">Eureka 服务器和客户端</h2><p id="d69b" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">我们不会在这里详细讨论，只是简单地提一下，根据<a class="ae ki" href="https://avinetworks.com/glossary/service-discovery/#:~:text=Service%20discovery%20is%20the%20process,of%20networks%20by%20identifying%20resources." rel="noopener ugc nofollow" target="_blank">术语定义</a>，服务发现是自动检测网络上的设备和服务的过程。</p><p id="f262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Spring Boot，保存所有客户服务应用程序信息的应用程序被称为<strong class="jm io"> <em class="kj">尤里卡服务器</em> </strong>。在这种情况下，微服务可以被称为<strong class="jm io"> <em class="kj">尤里卡客户端</em> </strong>。</p><p id="fcc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，客户端<strong class="jm io"> <em class="kj">向服务器注册</em> </strong>，服务器知道服务运行的确切信息——主机和端口。当微服务想要相互连接时，它们会通过这个服务器进行通信。</p><p id="5bd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，微服务应该做的第一件事是将自己注册为 Eureka 服务器的客户端。<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>实例也应该这样做。如果<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>微服务决定通过 HTTP 与<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>对话，它做的第一件事就是发送服务发现请求，找出<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>的位置。服务器将返回实例(或其中一个实例)的地址，然后，请求将发送到特定的实例<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>。</p><p id="2aa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看到 Eureka 服务器在整个通信游戏中扮演着非常重要的角色。如果因为任何原因宕机，所有这些微服务之间的连接都将丢失。这就是为什么不惜一切代价保持 Eureka 服务器正常运行是非常重要的。</p><h2 id="7737" class="ks kt in bd ku kv kw dn kx ky kz dp la jv lb lc ld jz le lf lg kd lh li lj lk bi translated">春云依赖</h2><p id="3c58" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">你可以导航到 Spring 的<a class="ae ki" href="https://spring.io/projects/spring-cloud" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">官方网页</em></strong></a><strong class="jm io"><em class="kj"/></strong>看看所有的功能<strong class="jm io"> <em class="kj">春云</em> </strong>优惠。现在，让我们从添加<code class="fe lq lr ls lt b"><strong class="jm io">Spring Cloud Dependency</strong></code>到我们的项目开始。</p><p id="f428" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开主<code class="fe lq lr ls lt b"><strong class="jm io">pom.xml</strong></code>文件，并在<code class="fe lq lr ls lt b"><strong class="jm io">dependencyManagement</strong></code>部分添加以下依赖项，以使每个微服务能够选择它想要的依赖项:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="3ab1" class="ks kt in lt b gy ly lz l ma mb">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br/>  &lt;version&gt;${spring.cloud-version}&lt;/version&gt;<br/>  &lt;type&gt;pom&lt;/type&gt;<br/>  &lt;scope&gt;import&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="4b55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在属性部分中声明 spring cloud 版本(该版本可能与您的不同):</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="0fb5" class="ks kt in lt b gy ly lz l ma mb">&lt;spring.cloud-version&gt;2020.0.5&lt;/spring.cloud-version&gt;</span></pre><p id="b97e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重新加载文件以应用更改，让我们继续设置<strong class="jm io"> <em class="kj">服务发现</em> </strong>。</p><h2 id="8c98" class="ks kt in bd ku kv kw dn kx ky kz dp la jv lb lc ld jz le lf lg kd lh li lj lk bi translated">配置 Eurika 服务器</h2><p id="4955" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">在本节中，我们将构建一个服务，负责服务发现、解决端口问题以及将我们的微服务相互连接起来。</p><p id="dfa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在项目中创建一个名为<code class="fe lq lr ls lt b"><strong class="jm io">eurekaserver</strong></code>的新模块:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/9a934c94ec4029f9c34f045412f58b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnpCuzpJU8CLGmqWiFcizQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">在项目中为 eureka 服务器创建一个新模块</figcaption></figure><p id="611d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开这个新创建的模块的<code class="fe lq lr ls lt b"><strong class="jm io">pom.xml</strong></code>文件，并添加以下依赖项:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="ec57" class="ks kt in lt b gy ly lz l ma mb">&lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span></pre><p id="f071" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果按下小<strong class="jm io"> <em class="kj">蓝色按钮</em> </strong>旁边的依赖项</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ml"><img src="../Images/444a183ef369c917ec7966810b343787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTmJ2ZS548WQR7R3ocWprg.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">导航到父库</figcaption></figure><p id="9e1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将导航到相应版本的 spring-cloud-网飞-依赖项(因为我们在父文件<code class="fe lq lr ls lt b"><strong class="jm io">pom.xml</strong></code>中添加了依赖项):</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mm"><img src="../Images/ed3151e371e780c9820cb14e37f1e43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIInX5RXd0LnC-iPbNa4JA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">春云网飞依赖，版本 3.1.1</figcaption></figure><p id="e59f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了依赖关系，在 java 文件夹中创建一个新的包<code class="fe lq lr ls lt b"><strong class="jm io">com.anita.eurekaserver</strong></code>。然后创建一个<code class="fe lq lr ls lt b"><strong class="jm io">EurekaServerApplication</strong></code>类并用<code class="fe lq lr ls lt b"><strong class="jm io">@EnableEurekaServer</strong></code>注释它:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="0837" class="ks kt in lt b gy ly lz l ma mb">package <em class="kj">com.anita.eurekaserver</em>;<br/><br/>import <em class="kj">org.springframework.boot.SpringApplication</em>;<br/>import <em class="kj">org.springframework.boot.autoconfigure.SpringBootApplication</em>;<br/>import <em class="kj">org.springframework.cloud.netflix.eureka.server.EnableEurekaServer</em>;<br/><br/><em class="kj">@SpringBootApplication<br/>@EnableEurekaServer<br/></em>public class <em class="kj">EurekaServerApplication </em>{<br/><br/>    public static void main(<em class="kj">String</em>[] <em class="kj">args</em>) {<br/>        <em class="kj">SpringApplication</em>.<em class="kj">run</em>(<em class="kj">EurekaServerApplication</em>.class, <em class="kj">args</em>);<br/>    }<br/>    <br/>}</span></pre><p id="34f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<code class="fe lq lr ls lt b"><strong class="jm io">application.yml</strong></code>添加到资源文件夹中，并将下面几行粘贴进去:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="439d" class="ks kt in lt b gy ly lz l ma mb">spring:<br/>  application:<br/>    name: eureka-server<br/><br/>server:<br/>  port: 8765<br/>  <br/>eureka:<br/>  client:<br/>    fetch-registry: false<br/>    register-with-eureka: false</span></pre><p id="7f56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果愿意，可以添加自定义的<code class="fe lq lr ls lt b"><strong class="jm io">banner.txt</strong></code>文件:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mn"><img src="../Images/7f3fbe31840b38164d54c04813aac46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qW-5Fb4dH6LpWaFIHauJHg.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">eureka 服务器模块的自定义横幅</figcaption></figure><p id="3440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当应用程序在<code class="fe lq lr ls lt b"><strong class="jm io">port 8765</strong></code>启动时，打开网络浏览器并导航到该端口。您将看到一个代表<strong class="jm io"> <em class="kj"> Eureka 仪表板</em> </strong>的网页，给出了关于服务本身的信息，包括当前向 Eureka 注册的实例(目前没有，因为我们还没有告诉我们的微服务连接到该服务器)。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mo"><img src="../Images/1fbaa57995449aab85625c203cd5d37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgRCOECUJk1foqCqot5sRw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">尤里卡仪表板</figcaption></figure><p id="3c51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个页面现在没有给出很多信息，但是当我们在 Eureka 服务器上注册我们的服务时，这些部分将会更新。</p><h2 id="4efa" class="ks kt in bd ku kv kw dn kx ky kz dp la jv lb lc ld jz le lf lg kd lh li lj lk bi translated">配置 Eureka 客户端</h2><p id="93fc" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">让 Eureka 服务器保持运行，让我们从配置<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>微服务开始。打开它的<code class="fe lq lr ls lt b"><strong class="jm io">pom.xml</strong></code>文件并添加以下依赖项:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="8357" class="ks kt in lt b gy ly lz l ma mb">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="00ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开主<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>类并用<code class="fe lq lr ls lt b"><strong class="jm io">@EnableEurekaClient</strong></code>对其进行注释:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="02ac" class="ks kt in lt b gy ly lz l ma mb">package <em class="kj">com.anita.student</em>;<br/><br/>import <em class="kj">org.springframework.boot.SpringApplication</em>;<br/>import <em class="kj">org.springframework.boot.autoconfigure.SpringBootApplication</em>;<br/>import <em class="kj">org.springframework.cloud.netflix.eureka.EnableEurekaClient</em>;<br/><br/><em class="kj">@SpringBootApplication<br/>@EnableEurekaClient<br/></em>public class <em class="kj">StudentApplication </em>{<br/><br/>    public static void main(<em class="kj">String</em>[] <em class="kj">args</em>) {<br/>        <em class="kj">SpringApplication</em>.<em class="kj">run</em>(<em class="kj">StudentApplication</em>.class, <em class="kj">args</em>);<br/>    }<br/><br/>}</span></pre><p id="47af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开<code class="fe lq lr ls lt b"><strong class="jm io">application.yml</strong></code>并在文件末尾添加以下配置:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="19a8" class="ks kt in lt b gy ly lz l ma mb">eureka:<br/>  client:<br/>    service-url:<br/>      defaultZone: http://localhost:8765/eureka</span></pre><p id="3faa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">启动<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>查看一切正常。从控制台日志中，可以看到<strong class="jm io"> <em class="kj">发现客户端</em> </strong>已经启动:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mp"><img src="../Images/fde72fa21f94327b793223d94e46461c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpahjsd2l4W7yFAi8Lv6qw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">日志通知发现客户端</figcaption></figure><p id="39c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您查看网页，您会看到实例部分也已更新:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mq"><img src="../Images/a67977e5ad189373856d53b15a73ed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ign1IgzJO6lTYQzlA1YkLQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">更新了 Eureka 仪表板上的实例部分</figcaption></figure><p id="4be0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仪表板上应用程序的名称来自于<code class="fe lq lr ls lt b"><strong class="jm io">application.yml</strong></code>文件，因此，给它们起一个合理的名称将极大地帮助您将来区分网页上的应用程序:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/861b187451e5c09c0e73ff7dd9add2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*gAc4BWw01fJ5B68o96uW9w.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">在 application.yml 文件中声明应用程序名称</figcaption></figure><p id="d52a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到 IntelliJ 并打开配置，复制<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>并修改程序参数字段:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/36e6c00078b2b5de42e995e8c2f69e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*HWRGbS_Z4zeJV06IMzqogg.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">应用程序配置菜单</figcaption></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mt"><img src="../Images/075d208ae05d9e2fb295d3b75772c98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtEDBrwA8GyP3ljiJLO7RA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">复制学生应用程序</figcaption></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mu"><img src="../Images/0304741de7e7426fe93dcafc9494d3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzKTH-pLX07N2KFGEhtu_A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">修改新配置的名称和程序参数</figcaption></figure><p id="e03a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication 2</strong></code>并重新加载网页。可用性区域的数量将增加到 2 个，因为我们有两个<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>实例(您还会注意到服务器维护每个实例的地址):</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mq"><img src="../Images/1e9dcfb4aa97908877770535448f2f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWcYMdt1hxJrVdrYuLE77g.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">尤里卡仪表盘上可用区域的数量增加</figcaption></figure><p id="2900" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不再需要<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>的第二个实例，所以您可以停止它并删除配置。</p><p id="0ed3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，为抄袭模块重复同样的过程。用同样的方法修改它的<code class="fe lq lr ls lt b"><strong class="jm io">pom.xml</strong></code>(添加尤里卡客户端依赖)、<code class="fe lq lr ls lt b"><strong class="jm io">application.yml</strong></code>(添加尤里卡服务配置)和<code class="fe lq lr ls lt b"><strong class="jm io">PlagiarismApplication</strong></code>(添加启用尤里卡客户端的注释)文件。</p><p id="582d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您启动所有应用程序并重新加载页面，您将看到一个<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>实例和一个<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>实例:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mv"><img src="../Images/895efef65b5bfa78e160521e6efddbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDVSFI51RF5Xm6RheIjW5A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">仪表板上的学生和剽窃实例</figcaption></figure><h2 id="c1cf" class="ks kt in bd ku kv kw dn kx ky kz dp la jv lb lc ld jz le lf lg kd lh li lj lk bi translated">负载平衡请求</h2><p id="74a2" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">此时，<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>对<code class="fe lq lr ls lt b"><strong class="jm io">StudentService</strong></code>类中的<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>进行网络调用。使用<strong class="jm io"> <em class="kj">服务发现</em> </strong>的主要原因正是为了消除这种需要。我们让 Eureka 服务器处理这些信息，我们只需要我们想要连接的应用程序的名称:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="48fb" class="ks kt in lt b gy ly lz l ma mb">"http://PLAGIARISM/api/v1/plagiarism-check/{studentId}",</span></pre><p id="7422" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">名字<strong class="jm io">抄袭</strong>会解析到对应的 IP 地址。</p><p id="1487" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到学生的<code class="fe lq lr ls lt b"><strong class="jm io">application.yml</strong></code>文件，将<code class="fe lq lr ls lt b"><strong class="jm io">ddl-auto</strong></code>设置从<code class="fe lq lr ls lt b"><strong class="jm io">update</strong></code>修改为<code class="fe lq lr ls lt b"><strong class="jm io">create-drop</strong></code>(当然，我们不希望在您想要保存数据的生产环境中这样做)。从配置中复制<code class="fe lq lr ls lt b"><strong class="jm io">PlagiarismApplication</strong></code>，重启<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>和<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>，打开 Postman，向<code class="fe lq lr ls lt b"><strong class="jm io">Student</strong></code>服务发送如下请求:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="e13b" class="ks kt in lt b gy ly lz l ma mb">{<br/>    "firstName": "Ani",<br/>    "lastName": "Talakhadze",<br/>    "email": "talakhadzeani@gmail.com"<br/>}</span></pre><p id="019f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于未知的内部异常，我们将出现内部错误:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mw"><img src="../Images/a8651ead78b8d6f9cfce2131662cad5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpBJf5nrDARmY_ygwIe68A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">发送请求时，邮递员出现内部服务器错误</figcaption></figure><p id="53a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上，这是因为有两个抄袭实例，RestTemplate 不知道向哪个模板发送请求。为了解决这个问题，我们需要在<code class="fe lq lr ls lt b"><strong class="jm io">StudentConfig</strong></code> <em class="kj"> </em>类<em class="kj"> </em>中为 RestTemplate 添加一个注释<code class="fe lq lr ls lt b"><strong class="jm io">@LoadBalanced</strong></code>，以便能够对请求进行负载平衡:</p><pre class="kl km kn ko gt lu lt lv lw aw lx bi"><span id="8d69" class="ks kt in lt b gy ly lz l ma mb">package <em class="kj">com.anita.student</em>;<br/><br/>import <em class="kj">org.springframework.cloud.client.loadbalancer.LoadBalanced</em>;<br/>import <em class="kj">org.springframework.context.annotation.Bean</em>;<br/>import <em class="kj">org.springframework.context.annotation.Configuration</em>;<br/>import <em class="kj">org.springframework.web.client.RestTemplate</em>;<br/><br/><em class="kj">@Configuration<br/></em>public class <em class="kj">StudentConfig </em>{<br/><br/>    <em class="kj">@Bean<br/>    @LoadBalanced<br/>    </em>public <em class="kj">RestTemplate </em>restTemplate() {<br/>        return new RestTemplate();<br/>    }<br/><br/>}</span></pre><p id="9a13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一次，在重启<code class="fe lq lr ls lt b"><strong class="jm io">StudentApplication</strong></code>之后，当您发送请求时，它不会因为向实例发送请求而混淆:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mx"><img src="../Images/fc97628baca2a4e7117a14b72137f196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m29llRp_0qp_uPM57UoN7A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">邮递员成功发送请求</figcaption></figure><p id="4de5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以检查控制台日志。您将看到只有一个<code class="fe lq lr ls lt b"><strong class="jm io">Plagiarism</strong></code>应用程序日志包含关于学生请求的信息。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="861b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经成功地将新模块集成到我们的项目中，建立了服务注册中心，并通过服务发现连接了微服务。如果你错过了什么，所有代码都可以在我的<a class="ae ki" href="https://github.com/anitalakhadze/microservices_practice" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj"> GitHub 资源库</em> </strong> </a>上找到。</p><p id="abac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对即将到来的博客有任何问题、评论或建议，请告诉我。</p><p id="90d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kj">敬请关注，不要错过以下教程！</em>T25】</strong></p></div></div>    
</body>
</html>