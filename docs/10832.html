<html>
<head>
<title>Can I learn Rust quickly with ChatGPT?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 ChatGPT 可以快速学会 Rust 吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/can-we-learn-rust-quickly-with-chatgpt-1f7295bf6114?source=collection_archive---------4-----------------------#2022-12-03">https://blog.devgenius.io/can-we-learn-rust-quickly-with-chatgpt-1f7295bf6114?source=collection_archive---------4-----------------------#2022-12-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ce5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">OpenAI 发布了聊天机器人 ChatGPT，可以回答编程问题。自从我学习 Rust 以来，我经历了几个棘手的问题，我将用 ChatGPT 来尝试，看看它是否能教会我这些。</p><p id="a803" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们从简单的开始，如何迭代一个循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4922c8e48a19f0a97198d820d393a1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQB2p8pLArgSDM8SS_jeKQ.png"/></div></div></figure><p id="44f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来合法，让我们试试更难的东西。Rust 中如何迭代一个向量？下面是答案。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="a7dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在 Rust 中迭代<code class="fe lb lc ld le b">Vec</code>的元素，可以使用<code class="fe lb lc ld le b">for</code>循环和<code class="fe lb lc ld le b">.iter()</code>方法来获得向量的迭代器。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="af15" class="lj lk in le b be ll lm l ln lo">let vec = vec![1, 2, 3];<br/><br/>for element in vec.iter() {<br/>    // code to be executed<br/>}</span></pre><p id="c4cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将迭代 vector 的元素，并对每个元素执行循环中的代码。在循环的每次迭代中,<code class="fe lb lc ld le b">element</code>变量将被设置为向量中的当前元素。</p><p id="d7a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，您可以使用带有<code class="fe lb lc ld le b">.next()</code>方法的<code class="fe lb lc ld le b">while</code>循环来迭代向量的元素。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="fd9f" class="lj lk in le b be ll lm l ln lo">let mut vec = vec![1, 2, 3];<br/><br/>while let Some(element) = vec.next() {<br/>    // code to be executed<br/>}</span></pre><p id="be4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该代码还将迭代 vector 的元素，并对每个元素执行循环中的代码。在循环的每次迭代中,<code class="fe lb lc ld le b">element</code>变量将被设置为向量中的当前元素。</p><p id="e897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种方法都可以让您访问向量的元素，但是它们在迭代实现的方式上有所不同。<code class="fe lb lc ld le b">for</code>循环更简洁，通常更容易阅读，但是<code class="fe lb lc ld le b">while</code>循环可以更灵活，因为它允许您手动控制迭代。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="47cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来真的很酷，现在让我们认真起来。Rust 中 nalgebra 矩阵如何修改块中的值？开始了。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="43bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要修改 Rust 中<code class="fe lb lc ld le b">nalgebra</code>框中矩阵的值，可以使用<code class="fe lb lc ld le b">mut</code>关键字使矩阵可变，然后使用索引来访问和修改单个元素。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="d27e" class="lj lk in le b be ll lm l ln lo">use nalgebra::Matrix3;<br/><br/>let mut m = Matrix3::new(1, 2, 3,<br/>                         4, 5, 6,<br/>                         7, 8, 9);<br/><br/>// Modify the element at row 0, column 2<br/>m[(0, 2)] = 10;<br/><br/>// Modify the element at row 1, column 1<br/>m[(1, 1)] = 11;</span></pre><p id="5723" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这段代码中，我们用给定的值创建一个新的<code class="fe lb lc ld le b">Matrix3</code>，然后使用索引来修改指定位置的元素。<code class="fe lb lc ld le b">(0, 2)</code>和<code class="fe lb lc ld le b">(1, 1)</code>分别是要修改的元素的行和列索引。</p><p id="1d3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，为了修改矩阵，必须使用<code class="fe lb lc ld le b">mut</code>关键字将它标记为可变的。否则，您将得到一个编译时错误。</p><p id="230e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦您修改了矩阵的元素，您可以使用<code class="fe lb lc ld le b">println!</code>宏或<code class="fe lb lc ld le b">debug</code>方法将其打印出来，并验证所做的更改。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="92ed" class="lj lk in le b be ll lm l ln lo">use nalgebra::Matrix3;<br/><br/>let mut m = Matrix3::new(1, 2, 3,<br/>                         4, 5, 6,<br/>                         7, 8, 9);<br/><br/>// Modify the element at row 0, column 2<br/>m[(0, 2)] = 10;<br/><br/>// Modify the element at row 1, column 1<br/>m[(1, 1)] = 11;<br/><br/>// Print the matrix to the console<br/>println!("{:?}", m);</span></pre><p id="6ab4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将把矩阵打印到控制台，并显示您对元素所做的更改。您也可以使用<code class="fe lb lc ld le b">debug</code>方法通过<code class="fe lb lc ld le b">println!</code>宏打印矩阵，如下所示:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="cf39" class="lj lk in le b be ll lm l ln lo">use nalgebra::Matrix3;<br/><br/>let mut m = Matrix3::new(1, 2, 3,<br/>                         4, 5, 6,<br/>                         7, 8, 9);<br/><br/>// Modify the element at row 0, column 2<br/>m[(0, 2)] = 10;<br/><br/>// Modify the element at row 1, column 1<br/>m[(1, 1)] = 11;<br/><br/>// Print the matrix to the console<br/>println!("{:?}", m.debug());</span></pre><p id="d334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码将产生与前一个例子相同的输出，但是它使用了<code class="fe lb lc ld le b">debug</code>方法来打印矩阵。这两种方法都有效，您可以选择使用哪一种。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="2d8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，这不是不合理的，但不完全是我在寻找的答案。让我们试试别的东西。Rust 中 ndarray 矩阵如何转化为 nalgebra 矩阵？</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="6266" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在 Rust 中将一个矩阵从<code class="fe lb lc ld le b">ndarray</code>格转换到<code class="fe lb lc ld le b">nalgebra</code>格，可以使用<code class="fe lb lc ld le b">nalgebra</code>提供的<code class="fe lb lc ld le b">try_from</code>方法。<code class="fe lb lc ld le b">try_from</code>方法获取对<code class="fe lb lc ld le b">ndarray</code>矩阵的引用，并返回一个包含转换后的<code class="fe lb lc ld le b">nalgebra</code>矩阵的<code class="fe lb lc ld le b">Result</code>，如果转换失败，则返回一个错误。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="1000" class="lj lk in le b be ll lm l ln lo">use ndarray::Array2;<br/>use nalgebra::{Matrix, Matrix3, Dynamic, U3};<br/>use std::convert::TryFrom;<br/><br/>let a = Array2::&lt;f64&gt;::zeros((3, 3));<br/><br/>let m: Matrix3&lt;f64&gt; = Matrix3::try_from(&amp;a).unwrap();</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="b3e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码虽然在 Rust 中不起作用，参考<a class="ae lp" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e3cfb1e6e88ec76f4eb48c2d8fbe0717" rel="noopener ugc nofollow" target="_blank">这个链接</a>。</p><p id="1d56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它还说:</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="e452" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以使用<code class="fe lb lc ld le b">nalgebra</code>提供的<code class="fe lb lc ld le b">into</code>方法将<code class="fe lb lc ld le b">Array2</code>直接转换为<code class="fe lb lc ld le b">Matrix</code>。该方法获得<code class="fe lb lc ld le b">Array2</code>的所有权，并返回具有相同元素值和形状的<code class="fe lb lc ld le b">Matrix</code>。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="db30" class="lj lk in le b be ll lm l ln lo">use ndarray::Array2;<br/>use nalgebra::{Matrix, Matrix3, Dynamic, U3};<br/><br/>let a = Array2::&lt;f64&gt;::zeros((3, 3));<br/><br/>let m: Matrix3&lt;f64&gt; = Matrix3::from_shape_vec((3, 3), a.into_raw_vec()).unwrap();</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="c235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码块有语法错误…我修改到下面，它实际上工作</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="34d5" class="lj lk in le b be ll lm l ln lo">use ndarray::Array2;<br/>use nalgebra::{Matrix, Matrix3, Dynamic, U3};<br/><br/>fn main() {<br/>    let a = Array2::&lt;f64&gt;::zeros((3, 3));<br/>    let m: Matrix3&lt;f64&gt; = Matrix3::from_vec(a.clone().into_raw_vec());<br/>    println!("a {:?}", a);<br/>    println!("m {:?}", m);<br/>}</span></pre><p id="a0b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我刚刚学到了一些新东西，因为我没有想到先把 ndarray 转换成 vector，然后再转换成 nalgebra。<em class="lq">免责声明:我对 ndarray 和 nalgebra 都不是很熟悉。</em></p><p id="b080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试试更抽象的东西。如何在 Rust 中迭代一个向量而不消耗它？答案在下面。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="af8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在 Rust 中迭代<code class="fe lb lc ld le b">Vec</code>的元素而不消耗它，可以使用<code class="fe lb lc ld le b">iter()</code>方法获得一个借用 vector 的迭代器。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="2be5" class="lj lk in le b be ll lm l ln lo">let vec = vec![1, 2, 3];<br/><br/>for element in vec.iter() {<br/>    // code to be executed<br/>}</span></pre><p id="66e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将迭代 vector 的元素，并对每个元素执行循环中的代码。在循环的每次迭代中，<code class="fe lb lc ld le b">element</code>变量将被设置为从向量到当前元素的引用。</p><p id="b7c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，<code class="fe lb lc ld le b">iter()</code>方法返回一个借用向量的迭代器，而不是消耗它。这意味着这个向量在循环之后仍然可以使用，您可以像往常一样继续使用它。</p><p id="82a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，您可以使用一个带有<code class="fe lb lc ld le b">.next()</code>方法的<code class="fe lb lc ld le b">while</code>循环来迭代一个向量的元素，而不消耗它。这里有一个例子:</p><pre class="kj kk kl km gt lf le lg bn lh li bi"><span id="15c0" class="lj lk in le b be ll lm l ln lo">let vec = vec![1, 2, 3];<br/><br/>let mut iter = vec.iter();<br/><br/>while let Some(element) = iter.next() {<br/>    // code to be executed<br/>}</span></pre><p id="e602" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该代码还将迭代 vector 的元素，并对每个元素执行循环中的代码。在循环的每一次迭代中，<code class="fe lb lc ld le b">element</code>变量将被设置为从向量到当前元素的引用。</p><p id="c1d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lb lc ld le b">while</code>循环方法允许你手动控制迭代，并且在如何迭代向量元素上给你更多的灵活性。然而，它通常比使用<code class="fe lb lc ld le b">iter()</code>方法的<code class="fe lb lc ld le b">for</code>循环更冗长，更难阅读。选择哪种方法更适合您的特定需求取决于您。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="1866" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它好像理解了 Rust 里的所有权模型！</p><p id="df7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 ChatGPT 的这个小实验之后，我的结论如下。对于一些基本的功能，它比 stackoverflow 更好，因为 ChatGPT 包含了更多的场景和详细的解释。然而，有时它没有意识到它生成的代码有语法错误。不管怎样，我认为 ChatGPT 是一个好的开始，现在除了 stackoverflow 之外，我又多了一个工具来磨练我的编程技能！</p></div></div>    
</body>
</html>