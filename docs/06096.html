<html>
<head>
<title>The Lesser-Known Java 8 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">鲜为人知的 Java 8 特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-lesser-known-java-8-features-49625a89424b?source=collection_archive---------5-----------------------#2021-12-13">https://blog.devgenius.io/the-lesser-known-java-8-features-49625a89424b?source=collection_archive---------5-----------------------#2021-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0cf733a4bc0c83cb36c5e027bed9b095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MN-03dttv4NpY7p56ll6rA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/s/photos/secret?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@krakenimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> krakenimages </a>拍摄的照片</figcaption></figure><h2 id="dc70" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h2><p id="79dc" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">Java 8 发布了一系列新特性，Streams、Functional Interface 和 Lambda 成为了焦点。</p><p id="ade9" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">直到昨天，我还认为功能界面只能是这样的，</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3068" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">一个接口，有一个抽象方法。</p><p id="5b49" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">但是，功能界面也可以是这样的，</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="138d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">Java 8 引入了一个新概念，除了通常的公共抽象方法之外，接口还可以有一个<em class="mf">默认</em>和<em class="mf">静态</em>方法。</p><p id="f77c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">根据这个定义，<em class="mf"> MyInterface </em>仍然是一个函数接口，因为它只有一个抽象方法，其他两个方法都有一个主体。</p><p id="6fbe" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在本文中，我们将详细分析这两种方法。</p><h2 id="54d5" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">默认方法的角色</h2><p id="cea1" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated"><em class="mf">案例 1: </em>它为实现它的所有类提供了一个默认功能。</p><p id="815b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">假设类 A 和类 B 实现了 MyInterface，并且它们都在 myMethod1()中执行相同的任务。传统的方法是——类 A 和类 B 都通过重写 myMethod1()来实现它们自己的方法，或者为了避免重复代码，可以创建一个 Helper 类来实现这个方法。</p><p id="3e58" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">默认方法将所有的公共功能放在一个地方，避免了创建新类或复制代码的负担。</p><p id="da09" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="mf">案例 2: </em>新的功能可以添加到接口中，而不会影响已经实现它的类。</p><p id="77c1" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">假设 A 类和 B 类实现了 MyInterface。现在，作者决定向该接口添加新功能，该功能对其所有实例都可用。此时，如果我们向接口添加一个抽象方法，我们将不得不通过覆盖这个新方法来修改现有的类。因此，添加一个默认方法是有意义的，该方法可用于具有默认行为的现有类，并且新类可以根据需要覆盖该功能。</p><p id="0e44" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">现有的类可以显示 myMethod1()的默认行为，</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8c69" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">新类可以根据需要覆盖 myMethod1()。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h2 id="5f06" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">静态方法的作用</h2><p id="a6df" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">在上面的例子中，如果作者决定向 MyInterface 添加新功能，并且不希望该功能被覆盖，那么我们可以将该方法设为静态方法。</p><p id="4577" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我能想到的另一个用例是在给定的接口中使用特定的功能，而不用实例化它。</p><p id="031f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">比如，在下面的例子中，</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0dee" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">类可以使用 myMethod2()中提供的功能，而无需实现该接口</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="302f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">执行上述类的输出是</p><pre class="lz ma mb mc gt mg mh mi mj aw mk bi"><span id="0439" class="kd ke iq mh b gy ml mm l mn mo">From Interface</span></pre><h2 id="fc0b" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h2><p id="35ce" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">如果您能想到这两种方法类型在接口中的任何其他可能的用例，请留下评论。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="085b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="mf">更多内容尽在</em><a class="ae kc" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="mf">blog . dev genius . io</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>