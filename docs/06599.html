<html>
<head>
<title>Using async/await in a forEach loop (you can’t)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 forEach 循环中使用 async/await(不能)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-async-await-in-a-foreach-loop-you-cant-c174b31999bd?source=collection_archive---------0-----------------------#2022-01-19">https://blog.devgenius.io/using-async-await-in-a-foreach-loop-you-cant-c174b31999bd?source=collection_archive---------0-----------------------#2022-01-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e71f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我遇到一个抱怨，当你把一个异步 lambda 函数作为回调参数传入每个元素时，forEach 循环是不一致的。从表面上看，这似乎不是一个不切实际的期望，但在本文中，我将尝试解释为什么它不起作用，向您展示开发人员实现这一点的一种流行方式，最后是一种适用于特定场景的优化(这通常是大多数人需要它的场景)。</p><h1 id="4219" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">快速后台(异步/等待)</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/d46b285faac25fc2fc86da71af9b8273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5lcJYyRfqDNagmexbDNqA.png"/></div></div></figure><p id="77ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经掌握了 async/await，你可以跳过这一节。我注意到的另一件事是，就像我一样，大多数人不理解<a class="ae ls" href="https://www.freecodecamp.org/news/javascript-promises-explained/#:~:text=What%20is%20a%20promise%20in,operation%2C%20and%20its%20resulting%20value." rel="noopener ugc nofollow" target="_blank"> javascript 承诺</a>，正因为如此，他们不理解 async-await 语法实际上在做什么。async-await 语法只是 promises API 上的语法糖，函数上的 async 标记只是让 javascript 知道这个函数将返回一个 promise，函数内部的 waiting 告诉解释器停留在函数调用中的这行代码上，直到该行调用的 promise 被完全解析。它让丑陋嵌套。then()调用看起来可读性更好。</p><h1 id="6f66" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题(承诺)</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lt"><img src="../Images/6bb07548bf087c62f4844d42cb71f048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mahu7lj86a4IZ9KI7uG3Yg.png"/></div></div></figure><p id="531c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">forEach 循环不是为使用异步回调函数而构建的，这也是它没有达到预期效果的原因。在继续下一次迭代之前，它不会等待迭代的承诺得到解决。这意味着在 forEach 循环迭代结束时，实际上没有任何东西被推入用户数组(稍后会被推入，但我并不想进入这里的<a class="ae ls" href="https://www.digitalocean.com/community/tutorials/understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript" rel="noopener ugc nofollow" target="_blank">事件循环</a>)。</p><h1 id="6eed" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">流行的解决方案(我们的老一套 for 循环)</h1><p id="33fe" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">仔细观察这个问题，你会发现我们的代码不能正常工作的主要原因是我们试图使用 forEach 循环来做一些它不是为之而创建的事情。我们需要一些东西，让我们迭代数组，并允许我们阻止程序执行，直到我们的承诺得到解决，这就是循环的基础。</p><p id="7f4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用循环的 for…或者旧的 for(让 I = 0；….)类型的 for 循环，但我将在这里使用 for…of，因为我们不需要对迭代过程进行太多控制。</p><p id="1b5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Nore:循环的 for…必须在异步函数中才能在循环中使用 await。除非在运行环境中设置了一些额外的配置，否则不能在程序的顶层使用这种语法。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lt"><img src="../Images/c3fe6635ca2ed0952b13ba16466cdb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3QcBq-3S68-Dvj_pN0pwg.png"/></div></div></figure><p id="1e97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将完全按照您的预期工作，并且已解析的用户将被记录。</p><h1 id="3583" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">优化(我们可以做得更好，不是吗)</h1><p id="48c8" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">从上一节来看我们的解决方案，您可以看到一些可能出现的问题。想象一下，让用户进行 getUser 调用需要 5 秒钟，这意味着记录所有用户需要 25 秒钟，当您从更大的角度来看这个问题时，情况会更糟。</p><div class="lh li lj lk gt ab cb"><figure class="lz ll ma mb mc md me paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><img src="../Images/6d0cc6c66c344c00c7d6bc31c1d2221d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*ot1oZuX3HikONxIyAotVWA.png"/></div></figure><figure class="lz ll mf mb mc md me paragraph-image"><img src="../Images/15775724f37e9f574625965935331d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*VN0sIxpu_Z3gYulmkIzKUQ.png"/></figure></div><p id="9475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这个从用户 id 数组中获取用户的特定场景，您可能会注意到，在开始获取下一个用户之前，我们正在等待返回一个用户，但是我们不需要等待，因为获取下一个用户与上一个调用返回的值无关。我们能不能并行获取它们，这样就可以用 5 秒钟来获取它们？是啊，肯定的。这就是 Promise.all()的用武之地，我们用它来批量解析承诺。</p><div class="lh li lj lk gt ab cb"><figure class="lz ll mg mb mc md me paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><img src="../Images/e8965d9276c278d1298c945e9318e1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*AXkoVJs1GMdWzLbD77oCow.png"/></div></figure><figure class="lz ll mh mb mc md me paragraph-image"><img src="../Images/5d077300027845b167575ea95c330122.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*P2WccozUqn9pqRAexLlsVg.png"/></figure></div><p id="2121" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 Promise.all()，所有的承诺都被并行解析，解析一个承诺所花的时间与解析所有承诺所花的时间相同。需要注意的一点是，只有当所有承诺都被解决时，您才能访问所有已解决的承诺，因此，如果其中一个电话需要 10 秒钟，而其他电话需要 2 秒钟，则您必须等待 10 秒钟。</p><h1 id="30c6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="e403" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我不是一个真正的作家，所以我希望你明白这一点，我完成了。另外，如果你有更好的方法，请在评论中告诉我，我也喜欢学习新东西。</p></div></div>    
</body>
</html>