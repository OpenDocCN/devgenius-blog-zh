<html>
<head>
<title>Microservices: Dead Letter Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务:死信队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/managing-dead-letter-queues-be30672fc73f?source=collection_archive---------0-----------------------#2020-09-18">https://blog.devgenius.io/managing-dead-letter-queues-be30672fc73f?source=collection_archive---------0-----------------------#2020-09-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="580d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用个人死信策略</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bcc4c738a95b2a93ad1b71a1efb01a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QdBcBSPLzkgfArzg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="592d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从一个微服务到另一个微服务交换消息从未如此简单。随着现代 web 框架的出现，我们现在能够以最少的配置从头启动微服务，例如 Spring Boot，它更喜欢传统而不是配置。还值得一提的是 Spring JMS API——JMS 的一个抽象层，它使开发变得更容易，因为所有连接、会话和 JNDI 上下文都被抽象掉了。<strong class="kv io"> <em class="lp"> </em> </strong>将此与 Spring Integration Framework 结合起来，Spring Integration Framework 允许服务通过消息通道进行通信，从而使整个架构松散耦合。</p><p id="0266" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然我提到的这些事情都很好，但我们不能忽视正在进行的权衡。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="1962" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">最终一致性</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/5f1f249f4e7933f88739814101ac1399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4ZQM2G99v-q4vGWLslJPA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在 miro.com 创建的图表</figcaption></figure><p id="b62f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于一个整体中的事务——原子性很容易实现。在 Spring 中，这可能就像用<code class="fe mq mr ms mt b">@Transactional</code>注释一个方法一样简单，但是异步消息传递却不是这样。我们可能会选择将交易限制在有限的范围内，这很好，但我们不能完全避免，即与不同银行的<code class="fe mq mr ms mt b">Fund Transfer</code>相关的功能请求。考虑这样一个场景，其中要转账的金额已经从付款人处借记，但是当试图将其贷记到收款人处时，另一个银行服务发生了异常——我们需要执行某种回滚来实现最终的一致性，为此我们将利用一个<code class="fe mq mr ms mt b">Dead Letter Queue</code>。</p><blockquote class="mu mv mw"><p id="d40c" class="kt ku lp kv b kw kx jo ky kz la jr lb mx ld le lf my lh li lj mz ll lm ln lo ig bi translated">免责声明:我将要演示的解决方案过于简单，不能反映金融系统的复杂业务规则。这篇文章的主要焦点是管理死信队列，我将为任何想学习的人提供一个逐步的指南。</p></blockquote></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="1a7f" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">如何将消息移动到死信队列？</h1><p id="4e43" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">注意:我们将在这个演示中使用 ActiveMQ。</p><p id="143c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当一个消费者尝试处理一条消息并失败了几次时——根据 ActiveMQ，它会尝试七次——如果所有这些尝试都失败了，那么这条消息将被转移到名为<code class="fe mq mr ms mt b">ActiveMQ.DLQ</code>的<code class="fe mq mr ms mt b">Default Dead Letter Queue</code>。</p><p id="4463" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从头开始，一切从头开始。我会在 docker 上安装 ActiveMQ(个人喜好所以很容易删除)。</p><h2 id="e21c" class="nf ly in bd lz ng nh dn md ni nj dp mh lc nk nl mj lg nm nn ml lk no np mn nq bi translated">1.安装 ActiveMQ</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="844c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mq mr ms mt b">JMX broker</code>监听端口 61616，<code class="fe mq mr ms mt b">Web Console</code>监听端口 8161，容器名为 activemq，并作为后台进程(-d)运行。访问 http://localhost:8161 ，您将看到 ActiveMQ 现在已经启动并运行。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/b736d5e6691d380c08aaf29372054730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBmtJ9cCpXnH_wW4TeC0Vg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">启动并运行 ActiveMQ</figcaption></figure><p id="b27f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">既然我们在 ActiveMQ 的 Web 控制台，让我们尝试使用 Web 控制台发送一条消息，为<code class="fe mq mr ms mt b">Receiver</code>服务做准备——这样它将有一条消息可以使用。我们可以通过点击“管理 ActiveMQ 代理”，然后点击“发送”选项卡来访问该工具。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/56091c19431c5b9e8ae37fc2a8b1fc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyYixDTGMdaj0L58djpyag.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">使用 ActiveMQ 发送消息(用于测试目的)</figcaption></figure><p id="6477" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">确保<strong class="kv io">检查</strong>和<code class="fe mq mr ms mt b">Persistent Delivery</code>。默认情况下，非持久性消息不会被路由到死信队列。</p><h2 id="66e1" class="nf ly in bd lz ng nh dn md ni nj dp mh lc nk nl mj lg nm nn ml lk no np mn nq bi translated">2.创建 Spring Boot 应用程序(消费者)</h2><p id="ba19" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">我敢打赌，我们大多数人已经知道如何创建一个 maven/gradle 项目或使用 Spring Initialzr。我将跳过这一部分，继续讨论所需的依赖项和应用程序属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">pom.xml</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">应用程序.属性</figcaption></figure><p id="4487" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，创建主类。如果使用 Spring Initialzr，主类可能已经存在。这个主类没有什么特别值得我们注意的，不管怎样，我会把它包含进来，这样每个人都可以看到不需要任何额外的注释。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Main.java</figcaption></figure><p id="7137" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们使用的是<code class="fe mq mr ms mt b">Spring Integration</code>，所以让我们继续进行允许通过<code class="fe mq mr ms mt b">channels</code>消费消息的配置。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">IntegrationConfig.java</figcaption></figure><p id="e5b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能已经注意到了<code class="fe mq mr ms mt b">line 37</code>上的评论。通过 Spring 集成，这是使用事务回滚消息的方式。</p><p id="6dc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们定义<code class="fe mq mr ms mt b">Receiver</code>服务，在这里我们显式地抛出一个 RuntimeException 来模拟图表中的场景。为 receive 方法添加<code class="fe mq mr ms mt b">@Transactional</code>注释是多余的，因为<code class="fe mq mr ms mt b">receive</code>方法隐式地使用了来自<code class="fe mq mr ms mt b">messageListenerContainer</code>的事务管理。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="292d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设消息出现在<code class="fe mq mr ms mt b">fund.transfer</code>队列中——在运行应用程序时，我们现在应该在名为<code class="fe mq mr ms mt b">ActiveMQ.DLQ</code>的死信队列中看到一条消息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/fd6368404132195c7894afc43438b2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdHEOZH9CPlsb5tGVOTp2A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">ActiveMQ:队列页面</figcaption></figure><p id="8b19" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如前所述，<code class="fe mq mr ms mt b">ActiveMQ.DLQ</code>是默认的死信队列。您可能想知道——如果我们正在处理来自不同队列的几条消息会怎么样？我们如何以不同的方式处理这些信息？—使用<code class="fe mq mr ms mt b">Individual Dead Letter Strategy</code>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="45ec" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">使用个人死信策略</h1><p id="8141" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">假设这种策略已经到位— ActiveMQ 将按照配置中指定的格式，自动为每个队列创建一个单独的死信队列。</p><p id="b038" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在创建配置之前，让我们后退一步，首先确定我们使用的代理(ActiveMQ)是<code class="fe mq mr ms mt b">Embedded</code>还是<code class="fe mq mr ms mt b">External</code>代理。我提到这一点是因为我当时犯了一个错误，假设我能够在应用程序中配置死信策略，而忽略了我正在使用一个<code class="fe mq mr ms mt b">External</code> ActiveMQ 的事实。</p><p id="aaa0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于这个演示——显然我们使用的是通过 Docker 安装的<code class="fe mq mr ms mt b">External</code> ActiveMQ。</p><h2 id="df14" class="nf ly in bd lz ng nh dn md ni nj dp mh lc nk nl mj lg nm nn ml lk no np mn nq bi translated">将 ActiveMQ 配置为使用单独的死信策略</h2><p id="8299" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">让我们访问 dockerized 容器中的 ActiveMQ 安装，并在这个目录中查找名为<code class="fe mq mr ms mt b">activemq.xml</code>的文件:<code class="fe mq mr ms mt b">/opt/apache-activemq-${version}/conf</code>。然后用这个目标策略替换<code class="fe mq mr ms mt b">&lt;broker&gt;</code>元素内的<code class="fe mq mr ms mt b">&lt;destinationPolicy&gt;</code>元素。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">个人死信策略的目的地策略</figcaption></figure><p id="9a08" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免混淆，我只包括了相关的部分，但是如果出于某种原因你想看完整的配置，这里是:<a class="ae ks" href="https://gist.github.com/emyasa/d1cbf7feefe42f008c4f6ff98a246d38" rel="noopener ugc nofollow" target="_blank"> activemq.xml </a>。基于这个配置，每个死信队列现在都有一个前缀<code class="fe mq mr ms mt b">DLQ.</code>。</p><p id="30db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意:重新启动 ActiveMQ 是此配置生效的必要条件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/59b11add304f75286f31f5e4623d863f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQvlz0jj3B8ifswTLtqi9Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">ActiveMQ:使用单独的死信策略</figcaption></figure><p id="e4d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mq mr ms mt b">DLQ.fund.transfer</code>现在出现在队列中。另外，使用死信队列与使用任何其他队列基本上是一样的。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="fe24" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">结论</h1><p id="8ab5" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">在处理异步消息传递时，我们可以使用死信队列来实现最终的一致性。此外，使用单独的死信策略将允许我们为每个队列创建一个单独的死信队列。</p><p id="1b0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你喜欢阅读这篇文章。</p><p id="f1ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编码快乐！</p></div></div>    
</body>
</html>