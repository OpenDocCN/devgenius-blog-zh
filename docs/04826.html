<html>
<head>
<title>Retain Cycles and Weak vs. Unowned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保留周期和弱对无主</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/retain-cycles-and-weak-vs-unowned-643c676821fc?source=collection_archive---------2-----------------------#2021-05-10">https://blog.devgenius.io/retain-cycles-and-weak-vs-unowned-643c676821fc?source=collection_archive---------2-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ad38" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">形影不离的二人组</h2><div class=""/><div class=""><h2 id="eef9" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">什么是保留周期？我为什么要用弱？我什么时候使用无主？</h2></div><h2 id="6e4d" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">在本文中，您将了解到:</h2><ul class=""><li id="677b" class="lj lk iq ll b lm ln lo lp kx lq lb lr lf ls lt lu lv lw lx bi translated">内存管理</li><li id="0225" class="lj lk iq ll b lm ly lo lz kx ma lb mb lf mc lt lu lv lw lx bi translated">自动参考计数</li><li id="639a" class="lj lk iq ll b lm ly lo lz kx ma lb mb lf mc lt lu lv lw lx bi translated">保留周期</li><li id="f4f9" class="lj lk iq ll b lm ly lo lz kx ma lb mb lf mc lt lu lv lw lx bi translated">强对弱对无主的含义，以及何时使用它们</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/9aa8babfad1d72c125ab94e75aa5e58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qfGF_A3rBvePQ6sVQ8tkg.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">保留周期导致你的应用程序抓住它应该放下的东西不放</figcaption></figure><h1 id="3730" class="mt kp iq bd kq mu mv mw kt mx my mz kw kf na kg la ki nb kj le kl nc km li nd bi translated">引入了内存管理</h1><p id="6abd" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">在软件开发中，内存管理是高效、可维护的应用程序的一个重要方面。当我们谈论移动开发时，内存管理绝对是<em class="nr">至关重要的，因为我们的设备拥有更少的资源，并且比他们的嵌入式设备更频繁地消耗这些资源。在iOS世界中，如果你的应用的内存空间达到一个<strong class="ll ja"> <em class="nr">未知</em> <em class="nr">极限</em> </strong>，糟糕的内存管理会导致OS杀死你的应用。</em></p><p id="c63b" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">内存是我们在应用程序中用来临时存储数据的东西。如果你创建了一个类的实例，它会在内存中存储一次。内存是一种有限的资源，通常由Swift妥善管理。这种管理是在后台完成的，使用了一种叫做自动引用计数(ARC)的东西。ARC为我们管理了大量的内存空间，但它不能完成所有的工作。</p><h1 id="21c9" class="mt kp iq bd kq mu mv mw kt mx my mz kw kf na kg la ki nb kj le kl nc km li nd bi translated">自动参考计数</h1><p id="f48c" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">我前面提到过，当你创建一个类的实例时，它只在内存中存储一次。ARC做的是记录这个实例被指向的次数。每指向一次，计数就增加1。当指向它的某个对象被释放时，计数减1。</p><p id="8a82" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">这很有用，因为如果没有保存对实例的引用(也就是当计数达到0时)，它将被从内存中完全删除。这释放了内存空间让其他东西使用，并防止我们达到任何会杀死我们的应用程序的极限！</p><p id="bae6" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">你可能已经意识到，尽可能好地管理你的内存是至关重要的，因为你不知道操作系统什么时候会终止你的应用。糟糕的内存管理也会导致丢帧(不稳定的性能)，奇怪的错误，以及其他的一些问题。所以让我们来学习如何管理这个空间的一部分。</p><h1 id="85c6" class="mt kp iq bd kq mu mv mw kt mx my mz kw kf na kg la ki nb kj le kl nc km li nd bi translated">保留周期</h1><p id="fc6b" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">在某些情况下，ARC会导致两个实例永远保持在一起——即使没有其他东西指向(使用)它们。最常见的情况是，我们有一个类具有一种类型的属性，而它们都有另一种类型的属性。例如，一个家有一个财产所有者，一个财产所有者有一个家。</p><p id="1389" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">如果我们像往常一样建模并创建示例实例，我们可能会得到这样的结果:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5582" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated"><code class="fe nz oa ob oc b">house</code>和<code class="fe nz oa ob oc b">owner</code>属性都是<code class="fe nz oa ob oc b">Strong</code>。<code class="fe nz oa ob oc b">Strong</code>是Swift中的默认值，导致参考计数保存在ARC中。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi od"><img src="../Images/f1ae4f240f1ba8366db44e0f52030695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLU4dXvF9kr_tkEUjhzjtQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Strong具有内存计数器的属性。默认情况下，属性是强的。他们在ARC进行计数</figcaption></figure><p id="9ca6" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">在我们的弧形图中可能是这样的，红色数字是引用计数。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oe"><img src="../Images/a7d74ca5917eb4d13c4dcf665caec6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F-uYhHOC0Rk9O2So"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">在我们的应用程序中，一个家必须有一个产权所有者，产权所有者必须有一个家</figcaption></figure><p id="7318" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">我们对这段代码所做的就是创建一个保留循环。属性所有者将一直保留在内存中，因为它的引用计数至少为1，Home也是如此。</p><p id="d3a8" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">因此，假设这个家是一个住宅和财产所有者的县数据库中的列表，我们的应用程序负责显示所有列表。现在我们可能有一个<code class="fe nz oa ob oc b">Listing</code>类。这个类有一个<code class="fe nz oa ob oc b">Home</code>，(并且记住<code class="fe nz oa ob oc b">Home</code>有一个<code class="fe nz oa ob oc b">PropertyOwner</code>)—</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="35b6" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">这就是我们引用计数的样子。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi of"><img src="../Images/99aa7738b662995cb5f6ed07f7cb42d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*SJfrq3u2bb_ayl751KIjtw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">即使当列表被释放时，Home仍然有一个来自PropertyOwner的强引用</figcaption></figure><p id="9d37" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">好的，记住这是我们应用程序中众多 列表中的<strong class="ll ja"> <em class="nr">之一。假设我们将它显示在一个数组中，其中每个<code class="fe nz oa ob oc b">Listing</code>实例都是可选的。稍后当一个<code class="fe nz oa ob oc b">Listing</code>被释放(从内存中移除)时，将会发生的是我们的家和财产所有者将会保留。通常ARC会看到<code class="fe nz oa ob oc b">Home</code>没有引用计数，两者都会被释放——但是它们指向对方。因为它们指向彼此，所以都不会自动从内存中删除。</em></strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4d68ed93f425885afe240a38bfdb72f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*eI_YQ0KDM8X-nUntHmEW6g.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">列表被释放，但是Home和PropertyOwner仍然保留，因为它们相互引用</figcaption></figure><p id="1b5b" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">所以现在这个<code class="fe nz oa ob oc b">Home</code>和<code class="fe nz oa ob oc b">PropertyOwner</code>仍然在内存中，但是没有在任何地方被使用。这是一个问题——记住，我们有许多<code class="fe nz oa ob oc b">Listing</code>,它们中的任何一个都可能被释放，并且随时会添加更多。假设我们在一个<code class="fe nz oa ob oc b">TableView</code>中展示它们。随着用户滚动，我们将添加新的<code class="fe nz oa ob oc b">Listing</code>实例。当单元格滚动出屏幕时，<code class="fe nz oa ob oc b">Listing</code>将被释放，但是他们的家和财产所有者将保留在内存中。最终，我们可能会撞上iOS内存墙，我们的应用程序会被杀死…或者性能会受到影响。这就是保留循环造成的伤害。</p><h2 id="8a27" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">防止保留周期</h2><p id="926c" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">我们可以通过设置<code class="fe nz oa ob oc b">Home</code>或<code class="fe nz oa ob oc b">PropertyOwner</code> <code class="fe nz oa ob oc b">weak</code>或<code class="fe nz oa ob oc b">unowned</code>中的属性来解决这个问题。为了我们的图，让从<code class="fe nz oa ob oc b">PropertyOwner</code>到<code class="fe nz oa ob oc b">Home</code>的关系变弱可能是最有意义的。但是这两个方向都解决了保留周期问题。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/79ba3bc2f812d4f0889ac4132a0ad4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*2qNuu1u9O9sFX95En4GgPA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">因为从PropertyOwner到Home的关系是弱的，这不再增加Home的引用计数</figcaption></figure><p id="f091" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">当任何属性不再有<code class="fe nz oa ob oc b"><strong class="ll ja"><em class="nr">strong</em></strong></code> <strong class="ll ja"> <em class="nr"> </em> </strong>引用时，它将被标记为解除分配，并在需要时从内存中删除。这意味着当<code class="fe nz oa ob oc b">Listing</code>被移除时，没有任何东西有对<code class="fe nz oa ob oc b">Home</code>的<code class="fe nz oa ob oc b">strong</code>引用——所以<code class="fe nz oa ob oc b">Home</code>被释放。现在，当<code class="fe nz oa ob oc b">Home</code>被释放时，<code class="fe nz oa ob oc b">PropertyOwner</code>的引用计数减少到0，它也被释放。你打破了保留周期！</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oi"><img src="../Images/0231eed695660760562f3acaeb7d4f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NVXkwnQ9JB2dFESJiSihQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">现在，当列表被释放时，每个对象都被释放，因为所有计数都减少到0</figcaption></figure><h1 id="512f" class="mt kp iq bd kq mu mv mw kt mx my mz kw kf na kg la ki nb kj le kl nc km li nd bi translated">软弱？无主？</h1><p id="0678" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated"><code class="fe nz oa ob oc b">Weak</code>和<code class="fe nz oa ob oc b">unowned</code>是向iOS发出信号的两种不同方式，表明我们不希望它为我们管理引用计数。我们希望一旦没有其他东西持有对它的引用，就释放它。</p><h2 id="22f6" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">无力的</h2><p id="e748" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">弱属性是不包含引用计数的可选属性。弱属性可以为零，如果某个对象以“干净”的方式访问一个属性(比如用可选的链接)，执行可以继续。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oj"><img src="../Images/943ac91b4991567fe29c3d2c621fd30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVpdzxqf0lG4t65qDwcLFQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">弱-此可选引用可以随时取消分配。它在ARC中没有计数</figcaption></figure><h2 id="924d" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">无主的</h2><p id="6309" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">像<code class="fe nz oa ob oc b">weak</code>属性一样，<code class="fe nz oa ob oc b">unowned</code>属性也是可选的，不包含计数。但是要注意，与weak不同，它们是隐式展开的(<code class="fe nz oa ob oc b">!</code>)，这意味着它们被暗示总是有一个值。如果有东西访问一个没有主人的零属性，应用程序就会崩溃。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ok"><img src="../Images/2399a32363e37dc85c0fcb96293b5d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zykbDR-yvoXzh6YSq9p7_g.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">无主-如果它没有值，并且您尝试访问它，您的应用程序将会崩溃。类似于强制展开的属性，但它不包含强引用，因此它不包含计数。</figcaption></figure><h1 id="d979" class="mt kp iq bd kq mu mv mw kt mx my mz kw kf na kg la ki nb kj le kl nc km li nd bi translated">如何决定何时使用无主或弱</h1><p id="cae4" class="pw-post-body-paragraph ne nf iq ll b lm ln ka ng lo lp kd nh kx ni nj nk lb nl nm nn lf no np nq lt ij bi translated">unowned和weak之间的主要区别本质上是当一个被访问并且它持有一个nil值时执行会发生什么。因此，你决定使用其中一个而不是另一个应该基于这一点。如果你还没有这样做很长时间，或者像我一样已经被困在有限的用例中很长时间，你可能会问为什么你会<strong class="ll ja"> <em class="nr">曾经</em> </strong>想要你的应用崩溃。安全是一个原因。再一个就是用户体验。</p><p id="bf6c" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">没错，<strong class="ll ja"> <em class="nr">有时候</em> </strong>让应用崩溃比让它继续使用错误的数据更好的用户体验。本质上，如果你想让应用程序在一个属性被访问时崩溃，并且它的值为零，那么就让它成为无主的。否则，弱可能是更安全的选择。还需要考虑设计决策——可选属性会增加复杂性。所以如果你确定它总是有一个非零值，并且你觉得很勇敢，也许可以让它无主，即使没有其他含义。</p><p id="42b7" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">希望我已经给了你一个好主意，如何开始管理你的iOS应用程序的内存，也许是你的应用程序缓慢或不断崩溃的原因。说到这里，<a class="ae ol" href="https://developer.apple.com/library/archive/technotes/tn2434/_index.html" rel="noopener ugc nofollow" target="_blank">剖析工具</a>是一个捕捉内存问题的好方法…但那是以后的事了！</p><p id="efbf" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">无论如何，有了一些知识，你就可以开始决定如何避免你的应用程序中的保留周期，以及为什么有些片段会使用<code class="fe nz oa ob oc b">unowned</code>和<code class="fe nz oa ob oc b">weak</code>。</p><p id="e7f9" class="pw-post-body-paragraph ne nf iq ll b lm ns ka ng lo nt kd nh kx nu nj nk lb nv nm nn lf nw np nq lt ij bi translated">评论里见！⏬</p></div></div>    
</body>
</html>