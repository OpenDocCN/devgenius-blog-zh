<html>
<head>
<title>How to write a good Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写好 Dockerfile 文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-a-good-dockerfile-2a294f04975c?source=collection_archive---------10-----------------------#2022-10-19">https://blog.devgenius.io/how-to-write-a-good-dockerfile-2a294f04975c?source=collection_archive---------10-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e70a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习最佳实践和撰写第一份 docker 文件的 11 个技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/15e49a3ba11a9be16e6a64c8ec9229cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*U709yxwCjjktQWGk7xTzdw.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">码头工人标志由<a class="ae kr" href="https://www.docker.com/company/newsroom/media-resourc" rel="noopener ugc nofollow" target="_blank">码头工人</a></figcaption></figure><h1 id="7883" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">目录</h1><ul class=""><li id="9997" class="lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kr" href="#91ea" rel="noopener ugc nofollow">提示#1: <strong class="lm ir"> </strong>学习一些基本的 Docker 词汇</a>📚</li><li id="df57" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#379a" rel="noopener ugc nofollow">技巧 2:学习如何用 Dockerfile 文件构建图像</a></li><li id="6d62" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#2002" rel="noopener ugc nofollow">提示 3:将 Docker 文件保存在上下文的根目录下</a></li><li id="175c" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#3697" rel="noopener ugc nofollow">提示#4:从一个空目录开始</a></li><li id="2735" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#86ba" rel="noopener ugc nofollow">提示#5: <strong class="lm ir"> </strong>了解 Dockerfile 格式</a></li><li id="b7e0" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#4762" rel="noopener ugc nofollow">提示#6:认为指令是相互独立的</a></li><li id="0cf6" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#cedd" rel="noopener ugc nofollow">提示#7:参考 Docker Hub 页面选择合适的图像变体</a></li><li id="3556" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated">技巧 8:使用。dockerignore </li><li id="38bc" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#917b" rel="noopener ugc nofollow">提示 9:给你的图片起个名字，也可以加上标签</a></li><li id="3075" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#eac7" rel="noopener ugc nofollow">提示#10:理解 Docker 守护进程是如何工作的</a></li><li id="e34a" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="#df45" rel="noopener ugc nofollow">提示#11:尽可能使用构建缓存</a></li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="ebd3" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 1:学习一些基本的 Docker 词汇📚</h2><p id="8b91" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">a<code class="fe nn no np nq b">Dockerfile</code>:Docker 读取并用来构建映像的一组指令。它只是一个文本文档，你可以在其中存储所有你会在命令行上调用的命令来创建一个图像。</p><p id="662e" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">一个<code class="fe nn no np nq b">context</code>目录:指定位置路径或 URL 下的<strong class="lm ir">文件集。<br/>路径是指机器上的本地目录。URL 指向一个 Git 存储库位置。注意:构建上下文是递归处理的。这意味着，给定一个路径或 URL，将处理所有子目录。</strong></p><p id="3dc1" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">一个<code class="fe nn no np nq b">docker build</code>命令:用来构建一个图像的命令。它需要一只<code class="fe nn no np nq b">Dockerfile</code>一只<code class="fe nn no np nq b">context</code>。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="379a" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 2:学习如何用 Dockerfile 文件构建图像</h2><p id="2001" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">要创建一个自动化的构建，您可以使用<code class="fe nn no np nq b">docker build &lt;context&gt;</code>。<br/>我们已经看到了上下文是如何成为本地路径或 git URL 的。如果您想使用您的本地当前目录作为构建上下文，您只需要使用<code class="fe nn no np nq b">.</code></p><p id="8d55" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">一旦您执行了<code class="fe nn no np nq b">docker build &lt;context&gt;</code>命令，它将首先把整个上下文(递归地)发送到 Docker 守护进程。实际上，在执行了 build 命令后，您将看到如下日志:</p><pre class="kg kh ki kj gt nw nq nx ny aw nz bi"><span id="7f72" class="mo kt iq nq b gy oa ob l oc od">$ docker build .</span><span id="9ffa" class="mo kt iq nq b gy oe ob l oc od">Sending build context to Docker daemon 6.51 MB</span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="2002" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 3:将 Docker 文件保存在上下文的根目录下</h2><p id="a568" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">标准的做法是将<code class="fe nn no np nq b">Dockerfile</code>保存在上下文的根位置。但是，如果您需要更改这个位置，您可以用<code class="fe nn no np nq b">-f</code>标志指定新的路径。比如:<code class="fe nn no np nq b">docker build -f /path/to/a/Dockerfile</code>。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="3697" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 4:从一个空目录开始</h2><p id="365c" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">因为上下文的所有内容都被发送到 Docker 守护进程，所以最好从一个空目录开始，作为只有 Docker 文件的上下文。然后，您可以添加构建 Dockerfile 文件所需的文件。</p><p id="f4da" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">⛔️从不使用根目录作为路径，因为这将整个硬盘驱动器转移到 Docker 守护进程。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="86ba" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 5:理解 Dockerfile 文件格式</h2><p id="48f8" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated"><code class="fe nn no np nq b">Dockerfile</code>不区分大小写。然而，最好是将指令大写，以便更容易地将它们与参数区分开来。</p><p id="3395" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">一个<code class="fe nn no np nq b">Dockerfile</code>应该以一个<code class="fe nn no np nq b">FROM</code>指令开始。唯一可能出现在<code class="fe nn no np nq b">FROM</code>指令之前的是:</p><ul class=""><li id="4844" class="lk ll iq lm b ln nr lp ns lr of lt og lv oh lx ly lz ma mb bi translated">注释:以<code class="fe nn no np nq b">#</code>开头的行(除非它们是解析器指令)。</li><li id="2897" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="https://docs.docker.com/engine/reference/builder/#parser-directives" rel="noopener ugc nofollow" target="_blank">解析器指令</a>。</li><li id="2857" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated"><a class="ae kr" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank">全局作用域参数</a>(当声明的参数用于<code class="fe nn no np nq b">FROM</code>指令时)。</li></ul><p id="994b" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated"><code class="fe nn no np nq b">FROM</code>指令指定了正在构建的父映像。所有后续命令都基于该父映像。</p><p id="e44c" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">示例:</p><pre class="kg kh ki kj gt nw nq nx ny aw nz bi"><span id="60e0" class="mo kt iq nq b gy oa ob l oc od">FROM python:3.7</span></pre><p id="b67d" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">带有<code class="fe nn no np nq b">FROM scratch</code>指令的 Dockerfile 不使用父映像，而是创建一个<strong class="lm ir">基础映像</strong>。</p><p id="1af6" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated"><code class="fe nn no np nq b">Dockerfile</code>的格式应该如下:</p><pre class="kg kh ki kj gt nw nq nx ny aw nz bi"><span id="a80a" class="mo kt iq nq b gy oa ob l oc od"># Comment<br/>INSTRUCTION arguments</span></pre><p id="dc3f" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">注释行在 Docker 指令执行前被删除。这意味着你可以写:</p><pre class="kg kh ki kj gt nw nq nx ny aw nz bi"><span id="a947" class="mo kt iq nq b gy oa ob l oc od">RUN echo hello \<br/># comment<br/>world</span></pre><p id="a5a6" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">或者</p><pre class="kg kh ki kj gt nw nq nx ny aw nz bi"><span id="5bd3" class="mo kt iq nq b gy oa ob l oc od">RUN echo hello \<br/>world</span></pre><p id="3ef5" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">是等价的。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="4762" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 6:认为指令是相互独立的</h2><p id="b49b" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">Docker 守护进程逐个运行<code class="fe nn no np nq b">Dockerfile</code>指令。这意味着<code class="fe nn no np nq b">RUN cd /tmp</code>对下一条指令没有任何影响。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="cedd" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 7:参考 Docker Hub 页面来选择合适的图像变体</h2><p id="2ed3" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">有时图像有多种风格，每一种都是为特定的用例设计的。</p><p id="df27" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">例如，<a class="ae kr" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank"> Python Docker 图像</a>以<code class="fe nn no np nq b">python:&lt;version&gt;</code>、<code class="fe nn no np nq b">python:&lt;version&gt;-slim</code>、<code class="fe nn no np nq b">python:&lt;version&gt;-alpine</code>、<code class="fe nn no np nq b">python:&lt;version&gt;-windowsservercore</code>的形式出现。在页面底部，您会发现所有不同标签的描述。</p><p id="4424" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated"><strong class="lm ir">如果不确定，使用标准的，如</strong> <code class="fe nn no np nq b"><strong class="lm ir">python:&lt;version&gt;</strong></code> <strong class="lm ir">。</strong></p><p id="7db0" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">总的来说，你应该知道 Debian 和 Alpine 是两种 Linux 风格。Docker 图像可以基于一个或另一个。您选择哪一个取决于您的需求。</p><p id="4b16" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">这些帖子可能会有所帮助:<a class="ae kr" href="https://forum.astronomer.io/t/difference-between-alpine-and-debian-based-docker-images/737" rel="noopener ugc nofollow" target="_blank">基于 Alpine 和 Debian 的 Docker 映像之间的差异</a>，或者<a class="ae kr" href="https://www.turnkeylinux.org/blog/alpine-vs-debian" rel="noopener ugc nofollow" target="_blank">比较 Debian 和 Alpine 对于容器的差异&amp; Docker 应用</a>，<a class="ae kr" href="https://nickjanetakis.com/blog/the-3-biggest-wins-when-using-alpine-as-a-base-docker-image" rel="noopener ugc nofollow" target="_blank">使用 Alpine 作为基本 Docker 映像的三大优势</a>。</p><p id="7c8e" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">我也觉得这篇文章很有见地:<a class="ae kr" href="https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d#:~:text=In%20short%2C%20the%20difference%20between,is%20the%20underlying%20operating%20system" rel="noopener">阿尔卑斯、苗条、舒展、巴斯特、杰西、靶心 Docker 形象有哪些不同？</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="9a9b" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 8:使用。dockerignore</h2><p id="7bbf" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">您可以向上下文目录添加一个<code class="fe nn no np nq b">.dockerignore</code>文件，以排除特定的文件和目录。这将提高构建的性能，因为 Docker 将考虑给定指令中指定的所有文件/目录。例如，<code class="fe nn no np nq b">COPY .</code>将复制当前目录的所有内容，但很可能并不需要所有文件/目录来构建 Docker 映像。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="917b" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">提示 9:给你的图片起一个名字，也可以选择一个标签</h2><p id="8444" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated"><code class="fe nn no np nq b">docker build</code>最常用的选项之一是使用<code class="fe nn no np nq b">--tag</code>或<code class="fe nn no np nq b">-t</code>为格式为<code class="fe nn no np nq b">name:tag</code>的图像添加名称和可选的标签。图像名称由斜杠分隔的名称组成。</p><p id="8e83" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">示例:<code class="fe nn no np nq b">docker build -t view/apache:2.0 .</code>将图像保存到带有标签<code class="fe nn no np nq b">2.0</code>的存储库<code class="fe nn no np nq b">view/apache</code>(这也是图像名称)。</p><p id="ef25" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">如果不指定任何标签，Docker 会自动分配<code class="fe nn no np nq b">latest</code>一个。</p><p id="6e01" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">默认情况下，Docker 将图像保存在位于<code class="fe nn no np nq b">registry-1.docker.io</code>的公共注册表中。如果你想使用一个私有注册主机名，你可以这样做，只要主机名符合标准的 DNS 规则，并且不包含下划线。此外，您还可以指定格式为<code class="fe nn no np nq b">:8080</code>的端口号。</p><p id="332a" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">示例:<code class="fe nn no np nq b">docker build -t myregistryhist:5000/fedora/httpd:version1.0</code>将私有注册表中的图像推送到带有 stage <code class="fe nn no np nq b">version1.0</code>的<code class="fe nn no np nq b">fedora</code>存储库中。</p><p id="42bd" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">您还可以多次使用<code class="fe nn no np nq b">-t</code>参数将图像标记到多个存储库中。</p><p id="1996" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">示例:<code class="fe nn no np nq b">docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest</code></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="eac7" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧 10:理解 Docker 守护进程是如何工作的</h2><p id="f72e" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">Docker 守护进程负责运行构建(它不是 CLI)。构建过程包括 4 个主要步骤:</p><ul class=""><li id="f730" class="lk ll iq lm b ln nr lp ns lr of lt og lv oh lx ly lz ma mb bi translated">步骤 1:上下文目录的所有内容都被发送到 Docker 守护进程。</li><li id="2b90" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated">步骤 2:Docker 守护进程逐个运行 Docker 文件中的指令，并将每个指令的结果提交给一个新的映像。</li><li id="8206" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated">步骤 Docker 守护进程输出新图像的 ID。</li><li id="4c93" class="lk ll iq lm b ln mc lp md lr me lt mf lv mg lx ly lz ma mb bi translated">步骤 Docker 守护进程自动清理您发送的上下文。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="df45" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">技巧#11:尽可能使用构建缓存</h2><p id="b334" class="pw-post-body-paragraph na nb iq lm b ln lo jr nc lp lq ju nd lr ne nf ng lt nh ni nj lv nk nl nm lx ij bi translated">缓存将大大加快构建过程。如果有东西被缓存，您应该在控制台输出中看到缓存消息。</p><p id="7475" class="pw-post-body-paragraph na nb iq lm b ln nr jr nc lp ns ju nd lr nt nf ng lt nu ni nj lv nv nl nm lx ij bi translated">默认情况下。构建缓存基于您当前正在构建的计算机上创建的先前构建的结果。如果你想要一个外部构建缓存，你可以使用<code class="fe nn no np nq b">--cache-from</code>选项。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="c2b2" class="mo kt iq bd ku mp mq dn ky mr ms dp lc lr mt mu le lt mv mw lg lv mx my li mz bi translated">参考</h2><ul class=""><li id="8d3e" class="lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">档案参考:<a class="ae kr" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/builder/#run</a></li></ul></div></div>    
</body>
</html>