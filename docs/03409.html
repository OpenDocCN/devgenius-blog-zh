<html>
<head>
<title>Unit tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unit-tests-c70618dc1e25?source=collection_archive---------1-----------------------#2020-10-31">https://blog.devgenius.io/unit-tests-c70618dc1e25?source=collection_archive---------1-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义集成和单元测试之间的界限并不容易。我想在这里提出我的看法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4902cec8129aeb7d0955a95a7c090ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjGo27lW34XjfcH-fbANOA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由<a class="ae lb" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=408364" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>提供</figcaption></figure><p id="7b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在<a class="ae lb" href="https://medium.com/dev-genius/why-testing-and-how-d7cf96c7223f" rel="noopener">的博客</a>上写了这个话题，但是一些人告诉我他们不清楚单位的概念。在开始之前，我想区分单元测试和集成测试。<br/>在我看来，最大的不同是单元测试通常不需要任何基础设施来执行。例如，不需要在内存中启动数据库。它们只取决于语言和我们使用的测试框架。我的第二个问题是，与集成测试相比，在单元测试中找到一个bug是多么容易。</p><p id="3c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们差别不大，但却有重大影响:</p><ul class=""><li id="d31c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">单元测试比集成测试快几倍。</li><li id="1339" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">单元测试不与你的代码，你写的代码之外的任何东西耦合。</li><li id="ecb6" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">单元测试告诉我们错误在哪里。</li></ul><h2 id="9525" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">为什么测试套件的响应时间很重要？</h2><p id="e5a5" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">现在让我们想象两个团队:</p><ul class=""><li id="2c3c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">团队“集成”他们代码库中的600个集成测试。他们的集成测试平均每次持续1秒钟。</li><li id="0b12" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">团队“单元”在他们的代码库中有600个单元测试。他们的单元测试平均持续0.1秒。</li></ul><p id="77d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">团队“集成”需要等待10分钟才能通过测试，但是团队“单元”只需要1分钟。你认为这对两个团队执行测试套件的频率有什么影响？<br/>是的，团队“单元”会比团队“集成”更频繁地执行测试。我们知道，有了频繁而快速的反馈，修复bug的<a class="ae lb" href="https://azevedorafaela.com/2018/04/27/what-is-the-cost-of-a-bug/" rel="noopener ugc nofollow" target="_blank">成本</a>就更低了。</p><p id="9a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元测试可以很好地扩展，在你的系统中从600个测试扩展到1200个测试对你的构建时间来说不是一个大问题。</p><h2 id="9d90" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">测试和耦合</h2><p id="4aaa" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">另一方面，我们说过单元测试没有耦合到您应用程序中需要的基础设施。但是为什么这是一个问题呢？。</p><p id="88c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用程序中与供应商合作就像接受他们的条件。现在，根据供应商的重要性和规模，你将成为客户或囚犯。去年，软件行业开始采用干净的架构来避免这些问题。但是我们没有意识到我们的测试也在那里，并且是我们代码库的一部分，对我们的生产代码有效的东西对我们的测试代码也有效。</p><p id="3454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的大部分测试与我们控制之外的第三方库耦合，我们设计低耦合系统的所有努力都将付诸东流。我们的测试是一切仍在工作的保证，如果它们与基础设施相结合，那么改变基础设施就会改变我们的测试。当我们试图在重构的同时改变测试时，很容易引入新的错误。</p><p id="7f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们需要改变大量的测试，那么引入的错误数量将会很高。如果你的大多数测试是单元测试，这不是一个大问题。</p><h2 id="3725" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">那么为什么要讨论集成和单元测试呢？</h2><p id="8588" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">与单元测试相比，集成测试有一个好处，这个好处与这样一个事实有关，即集成测试是用真实组件测试应用程序行为的黑盒测试。这使得开发人员有可能在不改变任何测试的情况下，在行为的中途重构他们的代码。</p><p id="40bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是等等，实际上这是单元测试可以实现的。问题是我们为我们的单位选择的边界。</p><h2 id="8b68" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">单元和行为</h2><p id="9094" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们试着用一个例子来说明这个问题。<br/>假设我们想在员工微服务中开发一个rest服务，给员工发送圣诞礼物。<br/>我们将以这种方式开发我们的新功能:</p><ul class=""><li id="f059" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">主计长给我们所有在职员工发了一份圣诞礼物。</li><li id="a54f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">员工服务，从我们的员工库中检索所有在职员工，并为每个员工发送一份礼物。</li><li id="9e0e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">雇员存储库，它负责与我们的雇员数据库进行对话。</li><li id="e51f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">礼品仓库，将礼品发送给我们的员工。另一个休息服务。</li></ul><p id="fbc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是支持我们行为测试的设计，现在我们有几个选项来测试它。</p><ul class=""><li id="62a5" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">我们可以用内存数据库和rest模拟服务器创建一个集成测试来模拟我们的基础设施。在这种情况下，我们的测试与内存数据库和rest模拟服务器相耦合。对于rest模拟服务器，我们需要假设它是如何工作的:使用哪些命令，预期的结果等等。<br/>因此，在测试我们服务的测试中，我们高度耦合到这个第三方系统。</li><li id="a4b7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">我们可以用集成测试来测试我们的基础设施(控制器、员工库、礼物库)，用单元测试来测试我们的领域(服务)。在这种情况下，我们的基础设施在我们的测试中与其相应的技术相耦合，但是我们的领域在我们的测试中没有与我们的基础设施相耦合。</li><li id="c65c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">其他人</li></ul><p id="78d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二种情况下，我们用单元测试来测试我们的领域，这些单元测试有清晰的边界，我们的存储库。那些存储库必须被测试替身所取代。但是等等，测试替身不是免费的，他们在假设我们真正的合作者会如何表现。我们不会谈论这个，但这是通过<a class="ae lb" href="https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests" rel="noopener ugc nofollow" target="_blank">合同测试</a>的起点。<br/>控制器将通过集成测试进行测试，对EmployeesService的调用将被嘲笑，这样我们就可以通过集成测试来测试我们的基础设施，而不是我们的领域。同样的事情也发生在我们的存储库上，它们将会在没有领域的集成测试中被测试。</p><p id="3f40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在想象一下，作为一项新的要求，我们需要将礼物的价格发送给我们的税务系统。此时，我们已经意识到，为了调用我们的税务系统，我们必须进行一些复杂的计算，因此我们创建了将进行这些计算的税务类，现在我们的员工服务具有:</p><ul class=""><li id="a5ae" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">员工信息库。</li><li id="c406" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">礼物仓库。</li><li id="62f0" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在调用税库之前进行一些计算的税。</li></ul><h2 id="c2ef" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">我们测试中的影响</h2><p id="503d" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">为了在我们的设计中引入Tax，我们决定将其作为合作者，这一决定将对我们的测试产生影响:</p><ul class=""><li id="6ff2" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">我们可以为雇员服务中的测试模拟Tax，并为Tax添加新的测试。</li><li id="f503" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">我们可以试着用真正的税收来测试我们员工的服务。</li></ul><p id="c7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个决定的效果是在税收和我们的员工服务之间创建一个边界。</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="18d2" class="lq lr iq mp b gy mt mu l mv mw">class EmployeeService{<br/>   private Tax tax;<br/>   ...<br/>   public EmployeeService(Tax tax, ....){<br/>       this.tax = tax;<br/>       ...<br/>   }<br/>   public void sendGifts(){<br/>     ...<br/>     tax.informGift(a,b,c);<br/>     ...  <br/>   }<br/>}</span></pre><p id="3fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照第一种方法测试EmployeeService:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="5483" class="lq lr iq mp b gy mt mu l mv mw">class EmployeeServiceTest {</span><span id="7e11" class="lq lr iq mp b gy mx mu l mv mw">    @Test<br/>    public void sendGifts(){<br/>       Tax tax= mock(Task.class);<br/>       <strong class="mp ir">when(tax.informGift(a,b,c)).thenReturn(expectedResult);</strong>       </span><span id="81ba" class="lq lr iq mp b gy mx mu l mv mw">       EmployeeService service = new EmployeeService(tax, ...);<br/>       service.sendGifts();</span><span id="466d" class="lq lr iq mp b gy mx mu l mv mw">       //myAssertions <br/>    }<br/>}</span></pre><p id="8ce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试EmployeeServiceTest.sendGifts，我们假设informGift的行为方式(when部分)，如果这些假设不正确，那么我们将引入错误。现在，如果我们改变Tax.informGift的方法签名，那么我们将不得不改变我们的test doubles，但这也适用于我的test doubles(when)所做的任何假设。<br/>这样，对我领域内部行为的任何重构都会影响我测试中的许多部分。<strong class="jp ir">我的测试通过我创建的测试替身</strong>耦合到税收。在某种程度上，雇员服务中的测试促使我不要重构任何税务内部的东西。</p><p id="a4bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二个选项中，要测试EmployeeService:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="7401" class="lq lr iq mp b gy mt mu l mv mw">class EmployeeServiceTest {</span><span id="5875" class="lq lr iq mp b gy mx mu l mv mw">    @Test<br/>    public void sendGifts(){<br/>       Tax tax= new Tax(...)</span><span id="0a1a" class="lq lr iq mp b gy mx mu l mv mw">       EmployeeService service = new EmployeeService(tax, ...);<br/>       service.sendGifts();</span><span id="28b8" class="lq lr iq mp b gy mx mu l mv mw">       //myAssertions <br/>    }<br/>}</span></pre><p id="9693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个选项中，我们在员工服务测试中没有关于税收的假设。<strong class="jp ir">所以本例中我的单位就是我要测试的行为</strong>，EmployeeService和Tax两者一起。在第二个选项中，更改Tax.informGift中的签名或任何假设对我的单元测试来说都不是问题。Tax.informGift对我的测试是隐藏的。<br/>第二种方法的风险是创建一个<a class="ae lb" href="https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam" rel="noopener ugc nofollow" target="_blank">集成测试</a>，集成测试的结果是测试用例的爆炸。</p><h2 id="9c8f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">测试爆炸</h2><p id="3869" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">为了解释这一点，在我们的示例中想象一下，我们需要5个测试来测试Tax.informGift，另外5个测试来测试EmployeeService.sendGifts中的代码。这是将我们的测试一分为二的唯一原因，5个用于EmployeeService，5个用于Tax。因此，在EmployeeService.sendGifts测试中，我们将模拟Tax.informGift来避免这种爆炸。</p><p id="7180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们开始编写测试时，我们总是可以从第二种方法开始，但是我们只需要意识到测试的爆炸。如果我们开始看到这种爆炸，就回到第一种方法来测试特定的行为。<a class="ae lb" href="https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting" rel="noopener ugc nofollow" target="_blank">实际上，这只是对传统TDD方法的描述</a>。TDD没有说任何关于单元测试和集成测试的事情，使用单元测试或集成测试的原因是基于我在本文开始时解释的。</p><p id="d6b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元测试对那些我们可以很容易改变的东西(我们的领域)是有好处的。集成测试对于我们不能改变的事情(例如sql语言)是有益的。让我们把它们放在正确的地方。</p><p id="7ede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此作为推论，单元测试中不只有一个单元。它映射了你的系统定义的每一个高级行为，不需要任何类型的基础设施，也不会产生<a class="ae lb" href="https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam" rel="noopener ugc nofollow" target="_blank">测试爆炸，</a>这意味着你的行为之间的单元可以不同。</p></div></div>    
</body>
</html>