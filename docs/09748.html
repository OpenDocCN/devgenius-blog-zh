<html>
<head>
<title>Building events distribution system in the wild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在野外建立事件分发系统</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-events-distribution-system-in-the-wild-8bb494081465?source=collection_archive---------10-----------------------#2022-09-09">https://blog.devgenius.io/building-events-distribution-system-in-the-wild-8bb494081465?source=collection_archive---------10-----------------------#2022-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ce62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文介绍了用 Golang 编写的微小事件发布系统。这可以用于例如基于 p2p 的应用中的数据复制；</p><h2 id="2454" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">整体架构</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/5dce5eec3043fd68915232eb368e3c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0kC-cnVSGWcXPRqH6eP_A.png"/></div></div></figure><p id="b1ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我把这个系统命名为“编年史”。如上图所示，Chronica 可以作为各种基于服务器的应用程序之间的中间层来同步一些更新。《出埃及记》节点 A 更新其数据库中的一些记录，然后它向 Chronica hub 发送关于它的确认事件。然后节点 B，C，…接收到确认。然后他们自己决定应该如何处理它(例如简单地同步数据库中记录，或者根据一些规则忽略它。).Chronica 也可以嵌入到相应的服务器应用程序中:只需在接收节点中实现负责接受事件的节点契约，并将事件交给事件分发器；</p><h2 id="0855" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">现在什么不是编年史？</h2><ol class=""><li id="1440" class="ln lo in jm b jn lp jr lq jv lr jz ls kd lt kh lu lv lw lx bi translated">复制事件。如果应用程序运行时，不知何故崩溃，事件丢失；</li><li id="d65a" class="ln lo in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">完整事件持续性。如果某个实例收集了大量未处理的事件，并且有新的事件到达，那么最老的事件将从事件队列中被丢弃；</li></ol><h2 id="dffb" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">那么，背后的核心算法是什么？</h2><p id="19e4" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">当服务器应用程序确认其更新时，为了向其他方发送通知，会发生以下事情:</p><ol class=""><li id="a274" class="ln lo in jm b jn jo jr js jv mg jz mh kd mi kh lu lv lw lx bi translated">事件被发送到 Chronica 分发服务器；</li><li id="d331" class="ln lo in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">则该事件被存储在对应于某个接收节点的每个通道中；</li><li id="ae06" class="ln lo in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">然后，Chronica 尝试将存储的事件刷新到每个通道中的接收节点。如果事件发送成功，那么它将从给定的通道中被丢弃(在我的解决方案中，我称之为“纤程”)，下一个事件将按 FIFO 顺序处理到该节点。否则，该事件将被保存，并且在另一次发送事件时，Chronica 将运行相同的刷新循环。事件可能来自服务器应用程序，也可能是内部事件(当新的事件接收器注册为 ex。—建议新连接的节点接收初始状态)，或者是简单的确认事件；</li></ol><p id="184d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图显示了此流程背后的核心数据结构:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/134be1b073c926480aacfeeffecc0a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*opxPJLbI0nPY9lQ3J00WsA.png"/></div></figure><p id="817d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(是的，事件也是分批打包的，以减少接收事件的节点调用量，因此这是减少网络负载和增加事件交付稳定性的简单方法)</p><h2 id="9c99" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">解决上述问题的单纤 Golang 码</h2><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="2e72" class="ki kj in ml b gy mp mq l mr ms">package lib<br/><br/>import (<br/>	"fmt"<br/>)<br/><br/>const externalSigCapacity = 256<br/><br/>type Fiber struct {<br/>	node            Node<br/>	events          *MatroshkaList<br/>	internalEvents  *MatroshkaList<br/>	externalSigChan chan interface{}<br/>	pendingWorkChan chan struct{}<br/>}<br/><br/>// Creates fiber<br/>// - node: abstract node<br/>// - eventsCapacity: maximum number of event buckets<br/>// - packetCapacity: number of events in bucket<br/>func MakeFiber(node Node, eventsCapacity uint32, packetCapacity uint32) Fiber {<br/>	peerEventsList := MakeMatroshkaList(eventsCapacity, packetCapacity)<br/>	internalEventsList := MakeMatroshkaList(256, 4)<br/>	res := Fiber{<br/>		node:            node,<br/>		events:          &amp;peerEventsList,<br/>		internalEvents:  &amp;internalEventsList,<br/>		externalSigChan: make(chan interface{}, externalSigCapacity),<br/>		pendingWorkChan: make(chan struct{}, 4),<br/>	}<br/><br/>	return res<br/>}<br/><br/>func (self *Fiber) sendEventsImpl(evtsPacket *Matroshka, evtsQueue *MatroshkaList) {<br/>	err := self.node.Send(evtsPacket)<br/>	if err == nil {<br/>		evtsQueue.Pop()<br/>		self.pendingWorkChan &lt;- struct{}{}<br/>	} else {<br/>		fmt.Printf("[CHRONICA] Err =&gt; %s\n", err.Error())<br/>	}<br/>}<br/><br/>// Starts fiber<br/>func (self *Fiber) Run() {<br/>	go func() {<br/>		for {<br/>			var externalSig interface{} = nil<br/><br/>			select {<br/>			case externalSig = &lt;-self.externalSigChan:<br/>			case &lt;-self.pendingWorkChan:<br/>			}<br/><br/>			for len(self.pendingWorkChan) &gt; 0 {<br/>				&lt;-self.pendingWorkChan<br/>			}<br/><br/>			if v, ok := externalSig.(Event); ok {<br/>				if self.events.IsFull() {<br/>					self.events.Pop()<br/>				}<br/><br/>				self.events.Push(v)<br/>			}<br/><br/>			if v, ok := externalSig.(InternalEvent); ok {<br/>				if self.internalEvents.IsFull() {<br/>					self.internalEvents.Pop()<br/>				}<br/><br/>				self.internalEvents.Push(v)<br/>			}<br/><br/>			internalPacket := self.internalEvents.Peek()<br/>			if internalPacket != nil {<br/>				self.sendEventsImpl(internalPacket, self.internalEvents)<br/>				continue<br/>			}<br/><br/>			packet := self.events.Peek()<br/>			if packet != nil {<br/>				self.sendEventsImpl(packet, self.events)<br/>			}<br/>		}<br/>	}()<br/>}<br/><br/>// Acknowledges for node's readiness.<br/>// to flush fiber events into node<br/>func (self *Fiber) AckNodeConnected() {<br/>	self.externalSigChan &lt;- struct{}{}<br/>}<br/><br/>// Keeps event in internal queue.<br/>// Events are then flushed into node in FIFO order<br/>// - evt: event object<br/>func (self *Fiber) SendEvent(evt Event) {<br/>	self.externalSigChan &lt;- evt<br/>}<br/><br/>// Keeps root event (from Chronica system itself) in internal queue.<br/>// Events are then flushed into node in FIFO order<br/>// - evt: event object<br/>func (self *Fiber) SendRootEvent(evt InternalEvent) {<br/>	self.externalSigChan &lt;- evt<br/>}</span></pre><p id="240b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">节点的接口很简单。如前所述，它负责向某个实例发送事件:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="205b" class="ki kj in ml b gy mp mq l mr ms">package lib<br/><br/>// Abstract interface for thing that commits events from internal queue<br/>type Node interface {<br/>	Send(events *Matroshka) error<br/>}</span></pre><h2 id="0eca" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">好，如何绑定这些节点，以便我们可以广播(或单播)事件？</h2><p id="2306" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我创建了另一个名为“光纤管理器”的实体。它是一个入口点，跟踪注册的纤程并将发送的事件传播给它们。下面是它的代码:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="9aab" class="ki kj in ml b gy mp mq l mr ms">package lib<br/><br/>// - Uid: unique descriptive identifier of node<br/>// - Node: node<br/>type FiberParams struct {<br/>	Uid  string<br/>	Node Node<br/>}<br/><br/>type FiberWithId struct {<br/>	id    uint32<br/>	fiber Fiber<br/>}<br/><br/>// An object to distribute events to fibers<br/>type FiberDirector struct {<br/>	externalSigChan chan Signal<br/>	fibers          map[string]*FiberWithId<br/>	fiberIdCounter  uint32<br/>	eventsCapaciry  uint32<br/>	packetCapacity  uint32<br/>	trustToken      string<br/>}<br/><br/>// Creates fiber orchester<br/>// - fiberParams: nodes parameters<br/>// - eventsCapacity: maximum number of event buckets<br/>// - packetCapacity: number of events in bucket<br/>func MakeFiberDirector(<br/>	fibersParams []FiberParams,<br/>	eventsCapacity uint32,<br/>	packetCapacity uint32,<br/>	trustToken string,<br/>) FiberDirector {<br/>	fibers := make(map[string]*FiberWithId, 0)<br/>	var idCounter uint32 = 0<br/><br/>	for _, param := range fibersParams {<br/>		idCounter++<br/>		fib := MakeFiber(param.Node, eventsCapacity, packetCapacity)<br/>		fibers[param.Uid] = &amp;FiberWithId{<br/>			id:    idCounter,<br/>			fiber: fib,<br/>		}<br/>	}<br/><br/>	res := FiberDirector{<br/>		externalSigChan: make(chan Signal, 1024),<br/>		fibers:          fibers,<br/>		fiberIdCounter:  idCounter,<br/>		eventsCapaciry:  eventsCapacity,<br/>		packetCapacity:  packetCapacity,<br/>		trustToken:      trustToken,<br/>	}<br/><br/>	return res<br/>}<br/><br/>// Starts fiber orchester<br/>func (self *FiberDirector) Run() {<br/>	for _, fib := range self.fibers {<br/>		fib.fiber.Run()<br/>	}<br/><br/>	go func() {<br/>		for {<br/>			signal := &lt;-self.externalSigChan<br/><br/>			if v, ok := signal.(SignalNodeConnected); ok {<br/>				fiber := self.fibers[v.Uid]<br/>				fiber.fiber.AckNodeConnected()<br/>				continue<br/>			}<br/><br/>			if v, ok := signal.(SignalNewEvent); ok {<br/>				senderFiber := self.fibers[v.FromUid]<br/>				for _, recvFib := range self.fibers {<br/>					if recvFib.id != senderFiber.id {<br/>						recvFib.fiber.SendEvent(v.Event)<br/>					}<br/>				}<br/>				continue<br/>			}<br/><br/>			if v, ok := signal.(SignalNewRootEvent); ok {<br/>				for _, recvFib := range self.fibers {<br/>					recvFib.fiber.SendRootEvent(v.Event)<br/>				}<br/>				continue<br/>			}<br/><br/>			if v, ok := signal.(SignalNewUnicastEvent); ok {<br/>				senderFiber := self.fibers[v.FromUid]<br/>				receiverFiber := self.fibers[v.ToUid]<br/><br/>				if senderFiber.id != receiverFiber.id {<br/>					receiverFiber.fiber.SendEvent(v.Event)<br/>				}<br/><br/>				continue<br/>			}<br/><br/>			if v, ok := signal.(SignalNewUnicastRootEvent); ok {<br/>				receiverFiber := self.fibers[v.ToUid]<br/>				receiverFiber.fiber.SendRootEvent(v.Event)<br/><br/>				continue<br/>			}<br/>		}<br/>	}()<br/>}<br/><br/>// Dispatches signal to fiber orchester<br/>// - sig: signal object<br/>func (self *FiberDirector) SendSignal(sig Signal) {<br/>	self.externalSigChan &lt;- sig<br/>}<br/><br/>func (self *FiberDirector) RegisterNode(fiberParams FiberParams) {<br/>	fiber := MakeFiber(<br/>		fiberParams.Node,<br/>		self.eventsCapaciry,<br/>		self.packetCapacity,<br/>	)<br/><br/>	self.fiberIdCounter++<br/>	self.fibers[fiberParams.Uid] = &amp;FiberWithId{<br/>		id:    self.fiberIdCounter,<br/>		fiber: fiber,<br/>	}<br/>	fiber.Run()<br/><br/>	go func() {<br/>		uids := make([]string, 0)<br/>		for uid := range self.fibers {<br/>			uids = append(uids, uid)<br/>		}<br/><br/>		event := InternalEvent{<br/>			Action:     InternalEventPullCurrentState,<br/>			TrustToken: self.trustToken,<br/>			Payload:    uids,<br/>		}<br/>		self.externalSigChan &lt;- SignalNewUnicastRootEvent{<br/>			ToUid: fiberParams.Uid,<br/>			Event: event,<br/>		}<br/>	}()<br/>}</span></pre><p id="ee9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(我们需要 uid 来唯一地标识一个节点——它可以在您的自定义协议中指定为 url、id 等。)</p><h2 id="c7d5" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">所有库功能都位于此存储库中:</h2><p id="e272" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated"><a class="ae mt" href="https://gitlab.com/john-byte/chronica-distributor/-/tree/master/lib" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/jbyte777/chronica-distributor</a></p><h2 id="a82d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">使用 Chronica 的基本示例如下:</h2><p id="9fce" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">https://gitlab.com/jbyte777/chronica-server-example<a class="ae mt" href="https://gitlab.com/john-byte/chronica-client-example" rel="noopener ugc nofollow" target="_blank"/></p><p id="7b43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【https://gitlab.com/jbyte777/chronica-client-example T4】</p><p id="106b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mu">就这些。随意留下任何评论；)</em></p></div></div>    
</body>
</html>