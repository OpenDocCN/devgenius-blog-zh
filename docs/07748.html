<html>
<head>
<title>Rearrange the Words of a String in Reverse Order Using Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Stack 以相反的顺序重新排列字符串中的单词</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rearrange-the-words-of-a-string-in-reverse-order-using-stack-6c28ff87684c?source=collection_archive---------6-----------------------#2022-04-20">https://blog.devgenius.io/rearrange-the-words-of-a-string-in-reverse-order-using-stack-6c28ff87684c?source=collection_archive---------6-----------------------#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="abc8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何以相反的顺序重新排列字符串中的单词，而不颠倒单个单词</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21710302f3780cd9327e2b304cfa4392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIkalmJ0ZqlMqtQ7WCk7fw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@talhariaz?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">塔尔哈·里亚兹</a>从<a class="ae kv" href="https://www.pexels.com/photo/black-pen-on-book-2409566/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><h1 id="b3d9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">问题是</h1><p id="643b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">给定一个字符串 S，我们需要反转它而不反转字符串中的单个单词。单词之间用空格隔开。</p><p id="7924" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以，如果我们有一个字符串:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="71a5" class="mu kx iq mq b gy mv mw l mx my">S = “reverse the string”</span></pre><p id="2d31" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">简单地反转字符串将得到以下输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ec86" class="mu kx iq mq b gy mv mw l mx my">Output: “gnirts eht esrever”</span></pre><p id="93a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是我们的目标是在不颠倒单个单词的情况下，以相反的顺序重新排列字符串中的单词。</p><p id="626b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个问题的输出应该是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3a4f" class="mu kx iq mq b gy mv mw l mx my">Output: “string the reverse”</span></pre><p id="9fea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里，单词在字符串中以相反的顺序重新排列。但是个别单词没有反过来。</p><p id="7eb3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">解决这个问题有不同的方法。但是这里我们会用<a class="ae kv" href="https://www.javatpoint.com/data-structure-stack#:~:text=A%20Stack%20is%20a%20linear,topmost%20element%20of%20the%20stack." rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">栈</strong>数据结构</a>来解决。</p><h1 id="cea7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Stack 如何给出解决方案</h1><p id="5281" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们来理解为什么栈数据结构会解决这个问题。</p><p id="07b9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">堆栈遵循<strong class="lq ir">后进先出</strong>原则。这意味着堆栈中输入的最后一个元素将首先被移除。此外，堆栈只有一端，在那里我们可以<strong class="lq ir">推送</strong> (enter) <strong class="lq ir"> </strong>和<strong class="lq ir">弹出</strong> (remove) <strong class="lq ir"> </strong>一个元素。</p><p id="f197" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以从阅读材料中了解更多关于堆栈的信息:</p><div class="mz na gp gr nb nc"><a href="https://python.plainenglish.io/how-to-create-a-stack-in-python-from-scratch-86350d0c15d0" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">如何在 Python 中从头开始创建堆栈</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">在不使用任何库的情况下用 Python 实现堆栈</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">python .平原英语. io</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kp nc"/></div></div></a></div><p id="6f2c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们看看堆栈如何在不反转单个单词的情况下反转字符串。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8d7e" class="mu kx iq mq b gy mv mw l mx my">S = “reverse the string”</span></pre><p id="bf5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们需要把单词分开。单词之间用空格隔开。所以我们可以很容易地把它们分开。</p><p id="1fb7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们需要将每个单词一个一个地推入堆栈。如果我们将包含字符串单词的堆栈可视化，它将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d0c318e76ec07747665649ec604a1f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*MvKmwvQJLqj5nm9datq9uQ.png"/></div></figure><p id="d2db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在从堆栈中一个接一个地弹出单词将会以相反的顺序重新排列它们。</p><h2 id="bb91" class="mu kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">pop("string "):</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/de851bb5f5657a2395ba248555a4a0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*murajhHMXgSpXtMyrQCW-g.png"/></div></figure><h2 id="6ad2" class="mu kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">波普(“the”):</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0c7d7d9979fb6e26ece76a0dc8a768c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*bOeVQ1XsyKwhgH9L20lwpg.png"/></div></figure><h2 id="e768" class="mu kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">pop(“反向”):</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ef4bdd8f6dbbd9fd829ca9a97edbaa10.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*87tU1YP5AIzonkLGfUjqHg.png"/></div></figure><p id="963c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以，我们可以把它分成两个主要部分:</p><ol class=""><li id="79a0" class="og oh iq lq b lr mk lu ml lx oi mb oj mf ok mj ol om on oo bi translated">将单词从字符串中分离出来，并将其放入堆栈中。</li><li id="d937" class="og oh iq lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">从堆栈中一个接一个地弹出单词，并将它们存储在输出字符串中。</li></ol><h1 id="c42b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">该算法</h1><p id="b16f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以开发一个简单的算法描述程序来解决这个问题。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6711" class="mu kx iq mq b gy mv mw l mx my">Step 1: initialize an empty stack: st</span><span id="ed55" class="mu kx iq mq b gy ou mw l mx my">Step 2: Push the individual words of string: S into the stack</span><span id="c662" class="mu kx iq mq b gy ou mw l mx my">Step 3: Pop the words from the stack and concatenate<em class="ov"> </em>them to the string: result</span><span id="feca" class="mu kx iq mq b gy ou mw l mx my">Step 4: Return string: result</span></pre><h1 id="6465" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Python 实现</h1><p id="c7cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们看看该过程的 Python 实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="a219" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe oy oz pa mq b">Stack</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="572c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b460" class="mu kx iq mq b gy mv mw l mx my">string the reverse</span></pre><h1 id="9a9f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">C++实现</h1><p id="b624" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">此过程的 C++实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="fe56" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ecad" class="mu kx iq mq b gy mv mw l mx my">string the reverse</span></pre><h1 id="967a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="5b5e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们讨论了如何使用堆栈数据结构解决字符串问题。这个特殊的问题可能有其他的解决方案。某些解决方案在空间复杂性方面可能比这个更有效。但这让我们很好地理解了如何使用不同的数据结构来解决问题。由此我们也可以理解字符串和堆栈是如何工作的。</p><p id="20de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这对你有帮助。感谢阅读。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="e0ea" class="mu kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">问题来源:</h2><div class="mz na gp gr nb nc"><a href="https://practice.geeksforgeeks.org/problems/reverse-words-in-a-given-string5459/1" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">反转给定字符串中的单词|练习| GeeksforGeeks</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">输入:S = I . like . this . program . very . much 输出:much.very.program.this.like.i 解释:反转整个…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">practice.geeksforgeeks.org</p></div></div><div class="nl l"><div class="pi l nn no np nl nq kp nc"/></div></div></a></div></div></div>    
</body>
</html>