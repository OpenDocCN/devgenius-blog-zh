<html>
<head>
<title>Using Fetch To Make POST Request with React (with Laravel based REST API)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Fetch 通过 React 发出 POST 请求(基于 Laravel 的 REST API)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-fetch-post-with-react-and-laravel-api-c99019367f2e?source=collection_archive---------2-----------------------#2022-02-09">https://blog.devgenius.io/using-fetch-post-with-react-and-laravel-api-c99019367f2e?source=collection_archive---------2-----------------------#2022-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="86cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始使用 React 的开发人员经常会遇到许多教程和片段，这些教程和片段教他们如何使用全局 fetch API 发出 GET 请求。但当涉及到发布请求时，许多人选择退出第三方库 axios，因此准备了相同的指南/教程/课程。</p><p id="e7e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我自己也面临过这个问题，对于刚刚入门的人来说，决定选择哪一个(axios 或 fetch)可能是一个令人困惑的话题。就个人而言，使用 fetch 进行学习，然后转向 axios 等第三方库是我推荐的，我遇到过许多面临同样问题的开发人员。</p><p id="b7ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个使用 React 进行 POST 请求的快速指南，使用由 Laravel 生成的 API 端点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/864084afae6166368f3c6d801ad4bacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MjjcDMi-7gEmArUE"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="78e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">考虑下面的 api 端点</strong></p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="a836" class="lh li iq ld b gy lj lk l ll lm">POST    http://127.0.0.1:8000/api/v1/todos</span></pre><p id="db4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设上面的端点提供了一个 API 来将一个 Todo 项存储到数据库中，让我们来看看用 Laravel 制作的简单 API。</p><h2 id="6d32" class="lh li iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">API 的定义(拉韦勒)</h2><p id="6efa" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">出于本教程的目的，让我们在 routes/api.php 文件中编写整个 API。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="07de" class="lh li iq ld b gy lj lk l ll lm">Route::post('/v1/todos', function(Request $request){</span><span id="5831" class="lh li iq ld b gy mj lk l ll lm">       <!-- -->$validator= $request-&gt;validate([<br/>        'title' =&gt; 'required|unique:todos',<br/>        'description' =&gt; 'required',<br/>       ]);</span><span id="f36c" class="lh li iq ld b gy mj lk l ll lm">        if($validator-&gt;fails())<br/>        {<br/>            return response()-&gt;json([<br/>                'errors' =&gt; $validator-&gt;errors()-&gt;first()<br/>            ], 422);<br/>        }<br/>        Todo::create($request-&gt;all());</span><span id="ddf1" class="lh li iq ld b gy mj lk l ll lm">        return response()-&gt;json(['success' =&gt; 'Todo Added'],200);</span><span id="c848" class="lh li iq ld b gy mj lk l ll lm">});</span></pre><h2 id="e17a" class="lh li iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">在反应中形成组件</h2><p id="1184" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在我们来看看由 todos 表单和 API 实现组成的 react 组件。</p><p id="891b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">表格:</strong></p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="5fb6" class="lh li iq ld b gy lj lk l ll lm">export default function Todos(){</span><span id="40eb" class="lh li iq ld b gy mj lk l ll lm"><br/>return (</span><span id="4294" class="lh li iq ld b gy mj lk l ll lm">const [title, setTitle] = useState("");<br/>const [description, setDescription] = useState("");<br/>const [errors, setErrors] = useState("");<br/>const history = useNavigate();</span><span id="5b52" class="lh li iq ld b gy mj lk l ll lm">function handleSubmit(e) {<br/>    const todo = {title, description};<br/>    e.preventDefault();</span><span id="1450" class="lh li iq ld b gy mj lk l ll lm">      fetch('http://127.0.0.1:8000/api/v1/todos',{<br/>      method: 'POST',<br/>      headers: {<br/>        "Content-Type" : "application/json",<br/>        "accept" : "application/json"},<br/>         body: JSON.stringify(todo)<br/>       }).then(async response =&gt; {<br/>         if (!response.ok) {<br/>         const validation = await response.json();<br/>         setErrors(validation.errors);<br/>         console.log(validation.errors);<br/>       }else{<br/>        history('/categories')<br/>       }<br/>    })<br/>  }</span><span id="ab6f" class="lh li iq ld b gy mj lk l ll lm">&lt;&gt;<br/>&lt;form onSubmit={handleSubmit}&gt;</span><span id="61ba" class="lh li iq ld b gy mj lk l ll lm">&lt;<br/>input <br/>type="text" <br/>placeholder="Title" <br/>value={title} <br/>onChange={(e) =&gt; {<br/>setTitle(e.target.value); <br/>errors.title=null<br/>}} <br/>/&gt;</span><span id="a9e1" class="lh li iq ld b gy mj lk l ll lm">{errors &amp;&amp; (<br/> &lt;span&gt;{errors.title}&lt;/span&gt;<br/>)}</span><span id="ce0d" class="lh li iq ld b gy mj lk l ll lm">&lt;<br/>input <br/>type="text" <br/>placeholder="Description" <br/>value={description} <br/>onChange={(e) =&gt; {<br/>setDescription(e.target.value); <br/>errors.description=null<br/>}} <br/>/&gt;</span><span id="bb67" class="lh li iq ld b gy mj lk l ll lm">{errors &amp;&amp; (<br/> &lt;span&gt;{errors.description}&lt;/span&gt;<br/>)}</span><span id="1402" class="lh li iq ld b gy mj lk l ll lm">&lt;button type="submit"&gt; Submit &lt;/button&gt;</span><span id="9556" class="lh li iq ld b gy mj lk l ll lm">&lt;/form&gt;</span><span id="bf36" class="lh li iq ld b gy mj lk l ll lm">&lt;/&gt;</span><span id="7795" class="lh li iq ld b gy mj lk l ll lm">)</span></pre><p id="9564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里获取的主要部分是上面的 handleSubmit()函数。让我们来看看上述函数的主要代码行。</p><p id="91df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fetch API 的第一个参数是我们的端点。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="f5fd" class="lh li iq ld b gy lj lk l ll lm">fetch('http://127.0.0.1:8000/api/v1/todos',{<br/>....<br/>});</span></pre><p id="b5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个参数是一个对象，它决定了我们要对这个端点做什么。</p><p id="7193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与 axios 不同，fetch API 要求我们在发送之前将 javascript 对象转换为 JSON 字符串。这就是我们在 headers 部分的行中所做的:<code class="fe mk ml mm ld b">body: JSON.stringify(todo).</code>这是作为 JSON 字符串发布的内容，然后由我们的 Laravel API 处理，之后我们处理响应。</p><p id="3679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为 fetch()在默认情况下是异步的，所以我们不需要使用 async 关键字来等待通过 Laravel API 发送的验证响应。</p><p id="1eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有任何服务器端错误，<code class="fe mk ml mm ld b">respose.ok</code>返回 false。</p><p id="79da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们只考虑服务器端的验证错误。这可以进一步用适当的响应代码来检查，比如<code class="fe mk ml mm ld b">if(response.status == 422){...}</code>之类的。但现在，我们会保持干净。</p><p id="87b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mk ml mm ld b">const validation = await response.json();</code>接收响应，在我们的例子中，包含验证错误。然后我们使用我们的<code class="fe mk ml mm ld b">errors</code>状态，并使用<code class="fe mk ml mm ld b">setErrors(validation.errors)</code>设置错误。fetch() api 还要求我们手动将解析主体文本的结果解析为 json，因此<code class="fe mk ml mm ld b">await response.json()</code>会保留在我们的代码中。</p><p id="47af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们的表单由<code class="fe mk ml mm ld b">span </code>标签组成，如果状态中存在错误，就会呈现这些标签。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="8a46" class="lh li iq ld b gy lj lk l ll lm">{errors &amp;&amp; (<br/> &lt;span&gt;{errors.title}&lt;/span&gt;<br/>)}</span><span id="2461" class="lh li iq ld b gy mj lk l ll lm">// And</span><span id="fca3" class="lh li iq ld b gy mj lk l ll lm">{errors &amp;&amp; (<br/> &lt;span&gt;{errors.description}&lt;/span&gt;<br/>)}</span></pre><p id="69b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们工作代码的主要部分如下:</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="cd46" class="lh li iq ld b gy lj lk l ll lm">    method: 'POST',<br/>    headers: {<br/>        "Content-Type" : "application/json",<br/>        "accept" : "application/json"},<br/>         body: JSON.stringify(todo)<br/>       }).then(async response =&gt; {<br/>         if (!response.ok) {<br/>         const validation = await response.json();<br/>         setErrors(validation.errors);<br/>         console.log(validation.errors);<br/>       }else{<br/>        history('/categories')<br/>       }</span></pre><p id="00d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="ccd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，上面的过程需要做大量的工作，但是作为 reactJS 的初学者，这是使用预构建的 fetch() api 用 react 处理 POST 请求的方法。如前所述，可以做更多的工作来改进这里的代码，比如检查正确的响应代码来相应地处理错误，或者使用正确的函数来清除<code class="fe mk ml mm ld b">onchange</code>上的错误状态，等等。但是为了开始使用 react 中的 fetch()处理 POST 请求，这是合适的。API 也不需要特定于 Laravel。无论是谁在处理 API 端点，都一定会确保验证响应作为异常从服务器端抛出，这是一个很好的实践。因此，如果您对 Laravel 的 API 有一个基本的了解，这可能是最好的工作，但是对任何能够使用 API 和处理响应的人都适用。同样，这里的要点是能够使用现有的 fetch() api，而不是第三方库。</p><p id="679a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意评论，并向我提供反馈，告诉我如何改进这段代码。</p></div></div>    
</body>
</html>