<html>
<head>
<title>Top common Memory leaks using C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#时常见的内存泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-common-memory-leaks-using-c-ba80331b62d4?source=collection_archive---------1-----------------------#2020-11-29">https://blog.devgenius.io/top-common-memory-leaks-using-c-ba80331b62d4?source=collection_archive---------1-----------------------#2020-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/e3f5fbb1e9c4268e4d60360b89a79b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*H50eyHcb-7OQoVXC.jpg"/></div></figure><p id="fe95" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">尽管有GC的存在，但还是非常容易造成内存泄漏。并不是垃圾收集器工作不好，只是在托管语言中导致内存泄漏的方式太多了。</p><p id="5bd2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在本文中，我们将讨论内存泄漏的最常见原因。NET程序。所有的例子都是用C#写的。</p><p id="34b4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们从这里开始:</p><h1 id="9d84" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.losure</h1><p id="2159" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">当匿名方法通过闭包捕获一个类的成员时，就会发生泄漏。</p><p id="5747" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1b89" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这段代码中，<code class="fe ly lz ma mb b">_id</code>字段在匿名方法中被捕获，并且实例也被引用。这意味着当<code class="fe ly lz ma mb b">Worker</code>存在并在Do方法中引用作业委托时，它也将引用<code class="fe ly lz ma mb b">Closure</code>的一个实例。</p><p id="37bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解决方法很简单——使用局部变量代替类成员:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a6fe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过使用局部变量的值，不会捕获任何内容，并且可以防止潜在的内存泄漏。</p><h1 id="571b" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.事件</h1><p id="a6c2" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">。NET事件会导致内存泄漏。当您订阅事件时，事件触发对象包含对您的类的引用。如果订阅是通过匿名方法进行的，则不会发生这种情况。<br/>举例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8d0d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果<code class="fe ly lz ma mb b">eventManager</code>对象比<code class="fe ly lz ma mb b">EventLeak</code> <strong class="jt io"> </strong>类存活的时间长，那么就存在内存泄漏。<code class="fe ly lz ma mb b">EventLeak</code> <strong class="jt io"> </strong>的任何实例都被<code class="fe ly lz ma mb b">eventManager</code> <strong class="jt io"> </strong>引用，不会被GC收集。</p><p id="4ecb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如何避免:</p><ol class=""><li id="b1c3" class="mc md in jt b ju jv jy jz kc me kg mf kk mg ko mh mi mj mk bi translated">取消订阅该活动。</li><li id="2e07" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated">使用弱处理程序模式。</li><li id="38da" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated">使用匿名函数订阅，不捕获任何成员。</li></ol><h1 id="e16c" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.静态</h1><p id="8051" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">静态对象位于GC根目录，永远不会被收集器收集。这种行为会导致内存泄漏。静态对象和它们引用的任何东西都不会被垃圾回收。</p><p id="e59e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6fb0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">任何<code class="fe ly lz ma mb b">Static</code>的实例将永远留在内存中，导致内存泄漏。</p><h1 id="b5f4" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.隐藏物</h1><p id="254a" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">如果你缓存所有的东西，你最终会耗尽内存。</p><p id="dd1e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8547" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这段代码可以保存你的数据库，但是会占用你所有的可用内存。</p><p id="3fe1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解决这个问题的一些方法:</p><ol class=""><li id="ab0f" class="mc md in jt b ju jv jy jz kc me kg mf kk mg ko mh mi mj mk bi translated">删除一段时间没有使用的缓存</li><li id="7bb6" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated">限制缓存大小</li><li id="14f3" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated">使用<code class="fe ly lz ma mb b">WeakReference</code>来保存缓存的对象。(<a class="ae mq" href="https://docs.microsoft.com/en-us/dotnet/api/system.weakreference?view=net-5.0" rel="noopener ugc nofollow" target="_blank"> WekReference </a>)</li></ol><h1 id="c671" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">5.线</h1><p id="2464" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">如果你创建了一个无限运行的线程，它什么也不做，却引用了对象，这就是内存泄漏。这很容易发生的一个例子是使用<code class="fe ly lz ma mb b">Timer</code>。</p><p id="bcea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="202b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你不停止定时器，它将在一个单独的线程中运行，引用一个<code class="fe ly lz ma mb b">Threads</code>的实例，阻止它被收集。</p><h1 id="b132" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">6.IDisposable</h1><p id="c9ba" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">IDisposable模式的不正确使用会导致内存泄漏。<br/>如何正确调用Dispose:</p><p id="dc74" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你可以做的一件事是在C#中使用<code class="fe ly lz ma mb b">using</code>语句:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4305" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这适用于<code class="fe ly lz ma mb b">IDisposable</code>类，由编译器翻译成:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="628f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这非常有用，因为即使抛出了异常，<code class="fe ly lz ma mb b">Dispose</code>仍然会被调用。</p><p id="e068" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以做的另一件事是利用<a class="ae mq" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose" rel="noopener ugc nofollow" target="_blank">处置模式</a>。这里有一个如何实现它的例子:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bfc1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这种模式确保了即使没有调用<code class="fe ly lz ma mb b">Dispose</code>，当实例被垃圾收集时，它最终也会被调用。另一方面，如果<code class="fe ly lz ma mb b">Dispose</code> <em class="mr">被</em>调用，那么终结器被取消。抑制终结器很重要，因为终结器<a class="ae mq" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors" rel="noopener ugc nofollow" target="_blank">开销很大</a>并且会导致性能问题。</p><h1 id="80db" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">7.WPF绑定</h1><p id="5a2c" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">WPF绑定会导致内存泄漏。经验法则是总是绑定到一个<code class="fe ly lz ma mb b">DependencyObject</code>或一个<code class="fe ly lz ma mb b">INotifyPropertyChanged</code>对象。当你不这么做的时候，WPF会从一个静态变量创建一个对你的绑定源(ViewModel)的强引用，导致内存泄漏(<a class="ae mq" href="https://stackoverflow.com/a/18543350/1229063" rel="noopener ugc nofollow" target="_blank">解释</a>)。</p><p id="c160" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里有一个例子:</p><pre class="ls lt lu lv gt ms mb mt mu aw mv bi"><span id="fc4c" class="mw kq in mb b gy mx my l mz na">&lt;UserControl x:Class="WpfApp.MyControl"      ae mq" href="http://schemas.microsoft.com/winfx/2006/xaml/presentation" rel="noopener ugc nofollow" target="_blank"&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br/>             xmlns:x="<a class="ae mq" href="http://schemas.microsoft.com/winfx/2006/xaml" rel="noopener ugc nofollow" target="_blank">http://schemas.microsoft.com/winfx/2006/xaml</a>"&gt;<br/>    &lt;TextBlock Text="{Binding Text}"&gt;&lt;/TextBlock&gt;<br/>&lt;/UserControl&gt;</span></pre><p id="3f4a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个视图模型将永远留在内存中:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1963" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然而这种视图模型不会导致内存泄漏:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c6d2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">是否调用<code class="fe ly lz ma mb b">PropertyChanged</code>并不重要，重要的是这个类是从<code class="fe ly lz ma mb b">INotifyPropertyChanged</code>派生出来的。这告诉WPF基础设施不要创建一个强有力的参考。</p><p id="52e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当绑定模式为单向或双向时，会发生内存泄漏。如果绑定是一次性的或单向的，那就不是问题。</p><p id="e64e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当您绑定到集合时，会出现另一个WPF内存泄漏问题。如果这个集合没有实现<code class="fe ly lz ma mb b">INotifyCollectionChanged</code>，那么就会出现内存泄漏。您可以通过使用实现该接口的<code class="fe ly lz ma mb b">ObservableCollection</code>来避免这个问题。</p><h1 id="e13e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">8.非托管内存</h1><p id="b715" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">非托管内存是不由垃圾回收器管理的内存。你需要自己释放内存。</p><p id="3622" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f1f0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上面的方法中，我们使用了<code class="fe ly lz ma mb b">Marshal.AllocHGlobal</code>，它分配一个非托管内存的缓冲区(<a class="ae mq" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Runtime_InteropServices_Marshal_AllocHGlobal_System_Int32_" rel="noopener ugc nofollow" target="_blank">文档</a>)。如果不使用<code class="fe ly lz ma mb b">Marshal.FreeHGlobal</code>手动释放句柄，缓冲内存将被进程的内存堆占用，从而导致内存泄漏。</p><p id="fd10" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了处理这样的问题，您可以添加一个<code class="fe ly lz ma mb b">Dispose</code>方法来释放任何非托管资源，如下所示:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="af6f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">非托管内存泄漏会导致<a class="ae mq" href="https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation" rel="noopener ugc nofollow" target="_blank">内存碎片</a>。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="363e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在您知道了如何避免最常见的内存泄漏问题。</p><p id="7f80" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">感谢阅读！</p></div></div>    
</body>
</html>