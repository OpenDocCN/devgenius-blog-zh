<html>
<head>
<title>Full-Stack React and .NET with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全栈反应和。NET 与 GraphQL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/full-stack-react-and-net-with-graphql-a1bd615c05a0?source=collection_archive---------3-----------------------#2022-06-09">https://blog.devgenius.io/full-stack-react-and-net-with-graphql-a1bd615c05a0?source=collection_archive---------3-----------------------#2022-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0dcb5b81b1f519a65e1ff9c2e7dce193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*9l5YLhMu7Ptilu_XJ1f6UQ.png"/></div></figure><p id="f3a3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">互联网上总是有关于 net 和 HotChocolate 或 Apollo client with React 的教程，但从来没有两者都有。这有几个原因，也许团队不是全栈的，或者根本没有必要这样做，因为技术是分开工作的。这都是真的，但是是时候有个由头到尾了。这将是关于微前端和微应用的不同文章的序言。</p><h1 id="e024" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">演出的明星</h1><p id="6972" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">本教程将有最少的<strong class="jt io">来让堆栈工作。这个教程的结果就是<a class="ae ls" href="https://github.com/enoch3712/GraphQLNetApollo" rel="noopener ugc nofollow" target="_blank">这里的<em class="lt"/>这里的</a> <em class="lt">。</em></strong></p><h2 id="cdea" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">GraphQL</h2><p id="010d" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">文章的中心是 Graphql，我发现了一个很好的引用:</p><blockquote class="mg mh mi"><p id="d238" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated"><a class="ae ls" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL 是一种用于 API 的查询语言，也是一种使用现有数据完成这些查询的运行时。</a></p></blockquote><h2 id="6745" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated"><strong class="ak">数据库(后端)</strong></h2><p id="f99a" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">这里的数据库无关紧要，它是不可知的，只要有它的驱动程序。我将在内存 中使用<a class="ae ls" href="https://entityframeworkcore.com/providers-inmemory" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io">。</strong></a></p><h2 id="ae81" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">EF 核心(后端)</h2><p id="0877" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">NET 生态系统中的 go-to ORM 将被用作我们实体的供应商。您也可以使用列表或任何 IEnumerable。</p><h2 id="520d" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">热巧克力(后端)</h2><blockquote class="mg mh mi"><p id="0d08" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">这是微软的一个开源 GraphQL 服务器。NET 平台，符合最新的 GraphQL 2021 年 10 月 spec +草案，这使得热巧克力兼容所有 graph QL 兼容的客户端，如草莓摇一摇，中继，阿波罗客户端，以及各种其他客户端和工具。</p></blockquote><p id="44c3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对，就是这样。为您的 API 提供强大的 GraphQL 功能。我就不多延伸了，大家都用。</p><h2 id="e254" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">GraphQL 代码生成器(codegen)</h2><p id="b9f5" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">这是一个来自<a class="ae ls" href="https://www.the-guild.dev/" rel="noopener ugc nofollow" target="_blank"> the-guild </a>的<a class="ae ls" href="https://github.com/dotansimha/graphql-code-generator" rel="noopener ugc nofollow" target="_blank">开源</a>项目，它基于后端模式生成模板代码来使用已经创建的查询。我敢打赌，这是一款非常棒的软件，很多人都没有使用它，或者没有充分发挥它的潜力。</p><h2 id="791e" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated"><strong class="ak">阿波罗客户端</strong></h2><p id="800f" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">Apollo 是 GraphQL 各方面的市场领导者。在这种情况下，我们唯一需要的是包<strong class="jt io"> "@apollo/client" </strong>，它将执行请求并缓存我们的对象。</p><p id="44ab" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另一种方法是使用 React Query 和 GraphQL 请求客户端。</p><p id="92e7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> React/NextJS </strong></p><p id="5c99" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这适用于任何 React 风格，所以如果想使用 NextJS 或任何其他风格都没问题。</p><h1 id="7260" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">后端</h1><p id="0781" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">为后端搭建舞台总是以同样的方式开始:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/ede4d42b959d22babb960eb65193ca63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*d32T3rSKQwc-yHVQtKmA9A.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">ASP。带控制器的 NET Core 启动模板</figcaption></figure><h2 id="f3fb" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">模型</h2><p id="7905" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">没有博客文章用例，我们可以做得更好:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/ddb32efd0ae5512c0bcf469a6b87e5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJdxyI3zlJtYfjZIWRal0Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">实体领域模型</figcaption></figure><h2 id="7fb5" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">EF 核心环境</h2><p id="7d5c" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">首先，您需要以下软件包:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi na"><img src="../Images/5b70fa0c962163d6fff07925835543d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*kSb7QztFQjCQjJGCmjHDNQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">必需的 EF 核心 NuGet 包</figcaption></figure><p id="6e76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将使用内存，你很可能会使用任何其他驱动程序。让我们来看一下背景:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/4924e7053ec3f24003f31b89be131ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSgTPDBveOEkDkHhF1xJ_A.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">带有一些种子的上下文</figcaption></figure><p id="713c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们可以将其注册为服务:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nc"><img src="../Images/0d6c1e30bd7902c67c3bbb6bb2724c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XBpCni4hk7QKIJPCav3_Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">内存上下文注册</figcaption></figure><h2 id="2753" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">GraphQL 集成</h2><p id="1a78" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">一般来说，关于依赖注入、对象类型和模式的使用，我将尽可能保持简单。所以 NuGets:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/627cb7b293b970d758278292d53a9a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*3YIY-BSpOv6fmpkfxtgUxw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">热巧克力果仁</figcaption></figure><p id="3ad1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">热巧克力在很多工具中包含优秀的支持，EF Core 或者 Voyager 就是其中的两个。让我们创建一个简单的查询文件来公开我们的实体:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9e1f9c1e267c1020529a6aa216edab52.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*tRCwCfheMSXShUajvCsIog.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">基本查询示例</figcaption></figure><p id="70c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">任何服务都可以被注入到查询中，只要用属性<strong class="jt io">【服务】注册。</strong>在我们的例子中，我们需要 IQueryable 来公开我们的实体，它将用 GraphQL 的其余选项来修饰。为了举例，我们在这里加上“<em class="lt">”</em>:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b2d11ab795f208a47e832af583718da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*QlW0at-WuS6pNaCvE6uzrw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">基于注释</figcaption></figure><p id="86a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码优先的通常更适合更大的项目，但是让我们保持简单，把实体作为一个聚合根。我们现在唯一需要的是将查询添加到启动中:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/85de6f42809c81f52540febfc5c159e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*WHE0oCEY1W5sOjwfbD-tLw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">启动时添加 GraphQL 服务器</figcaption></figure><p id="a9ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们现在可以添加 Voyager，这样我们就可以看到 GraphQL 模式中实体之间的关系。</p><blockquote class="mg mh mi"><p id="0b33" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">&gt; dotnet 添加包 GraphQL。航海家</p></blockquote><p id="c415" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这不是热巧克力，但是你可以用那个。然后你只需要把下面的那行代码添加到 app 之前的<em class="lt"> program.cs </em>。Run() <em class="lt"> : </em></p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0746fbeb4f9f7431a100363b97c1e56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*FH8GBR1ceTksy4yat_YQFA.png"/></div></figure><p id="4e59" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">运行程序，转到“/graphql-voyager”并查看结果:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ni"><img src="../Images/8f97bff55d38d4226590cbd5015e0f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVnLp0G8d6d0aRIZT2DdsQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">航海家号交互图</figcaption></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/00f816cc50f716f1ad5fa3a1a2cc1ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*gTm12J7gXx17j7ePw0-hHg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">失眠</figcaption></figure><p id="4148" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另外，让我们打开 CORS，这样我们就可以在前端测试时不会出现任何问题:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fe35b13c32719b819eed731b4d0de644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*N0IHjVTp0TBg31IqNOLHyg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">后端添加了 Cors 策略</figcaption></figure><h1 id="0f61" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">前端</h1><p id="0a0d" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我将使用<a class="ae ls" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank">创建一个新的 React 应用</a>。此外，将 Typescript 放在那里:</p><blockquote class="mg mh mi"><p id="aa8b" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated"><em class="in">&gt;</em>yarn create react-app my-app—模板打字稿</p></blockquote><p id="085a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是基本模板，它将获得其余的工具，如 Apollo 客户端。</p><blockquote class="mg mh mi"><p id="1d58" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">&gt;纱线添加图表 ql</p><p id="b8e6" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">&gt;纱线添加@阿波罗/客户端</p><p id="b6e3" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">&gt; yarn add @graphql-codegen/cli</p><p id="3513" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated"><em class="in"> &gt;纱加</em><a class="ae ls" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank"><em class="in">@ graph QL</em></a><em class="in">-codegen/typescript</em><a class="ae ls" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank"><em class="in">@ graph QL</em></a><em class="in">-codegen/CLI</em><a class="ae ls" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank"><em class="in">@ graph QL</em></a><em class="in">-codegen/typescript-operations</em><a class="ae ls" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank"><em class="in">@ graph QL</em></a><em class="in">-codegen/typescript-react</em></p></blockquote><p id="5ce2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本教程需要所有这些命令。更多可以在<a class="ae ls" href="https://www.graphql-code-generator.com/docs/getting-started/installation" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ls" href="https://www.youtube.com/watch?v=PYDGjTufGsk&amp;ab_channel=JamieBarton" rel="noopener ugc nofollow" target="_blank">这里</a>找到。现在，在我们做任何事情之前，我们需要用以下命令创建 codegen 配置:</p><blockquote class="mg mh mi"><p id="a33e" class="jr js lt jt b ju jv jw jx jy jz ka kb mj kd ke kf mk kh ki kj ml kl km kn ko ig bi translated">&gt;纱线图 ql-codegen init</p></blockquote><p id="51cc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后查看以下配置:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f910c632fb7863c07e99c27bf05431b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*rR5qG5pvGqofEgju9JOxew.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Peek React 应用</figcaption></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nm"><img src="../Images/fcdd74804925e7841e0cc97874079798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BskU5kwWeoN0FIiqc7kXdA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">我们的 GraphQL 端点</figcaption></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nn"><img src="../Images/132a49a19aa0d0d211bfa1bd9583fc52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIeaFuVTcMeyNaYixJNiaQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">生成模板时要读取哪些文件</figcaption></figure><p id="a5c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个很重要。我们告诉 codegen 在生成模板代码时检查要查看的文件。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi no"><img src="../Images/7369e9d49721f183ce064ad15d4a52a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjGL7CuB6E2wnmJSpMpqxA.png"/></div></div></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi np"><img src="../Images/f56603d982f46de84c32208a60e8ca13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZWx7-MQxMtlMBsHYoEfLg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">生成的代码将存放到的文件</figcaption></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dec8c7be81bc695a31ffbebe68e68460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*UZrLtdgyOQeB9EayCF6oLQ.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">配置的其余部分</figcaption></figure><p id="0f43" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">之后不要忘记运行<strong class="jt io"> npm 安装</strong>或<strong class="jt io">纱线</strong>。这将创建用于创建 GraphQL 请求代码的 codegen 文件。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bf41582693467c5b4630f9185f996f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*nQWTrfgVDWgu1xc1pJj0Wg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">代码文件</figcaption></figure><p id="0830" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在让我们把上面的查询放到一个文件中:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ns"><img src="../Images/d3a23c7c89ad9627b6f83435a82dfd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jkt1_1Lr8Hlehgbn5DgKfQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">GraphQL 查询</figcaption></figure><p id="85fb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们剩下要做的唯一一件事就是用<strong class="jt io"> codegen: </strong>生成代码</p><p id="3287" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">&gt;纱线运行代码</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nt"><img src="../Images/1eef5726d12a0158892f2b9ec4a421ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOqDEDEJuSmUAqPFh8dQiw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">运行命令和结果</figcaption></figure><p id="358a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果一切顺利，您应该会得到下面的结果:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d37695d7d3ece60725725c69aa342524.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*msEcxfbFHGJrdIinx_LghA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">结果文件</figcaption></figure><p id="ee84" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将是一个很大的文件，包含了从类型到钩子的所有内容，我们将在我们的组件中使用它。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nv"><img src="../Images/66e0de7856ad6ea0b178cc6f36893bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFfHHN458ptmHhfoA6tkeg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">生成的挂钩</figcaption></figure><p id="41c7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好吧，让我们做些漂亮的事情。当然，我不会编码，因为我有幸拥有终极懒惰男孩工具——open ai Codex。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/2658cb9fd9bfa045b187e02b522562be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CM2CGpYs0eCNhJFc3N7ICA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">OpenAI Codex 生成的代码</figcaption></figure><p id="66d3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，我们可以走了！嗯，差不多！让我们将 ApolloProvider 添加到我们的应用程序中:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6e3628e48911486d76e6843a6511d61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*6hTXNf62uLVUT4_D0M1VhQ.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使阿波罗应用程序工作的基本配置</figcaption></figure><p id="2105" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们看看结果:</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fd017c949dcc826872dda54970c569df.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*8xNub7Rk-0LTjwEChY5y4w.png"/></div></figure><p id="bc85" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">是的，它确实有效！这可以在将来用作模板，因为它是一个准系统模板。希望你喜欢它，再次，代码是<a class="ae ls" href="https://github.com/enoch3712/GraphQLNetApollo" rel="noopener ugc nofollow" target="_blank">这里</a>:)。</p></div></div>    
</body>
</html>