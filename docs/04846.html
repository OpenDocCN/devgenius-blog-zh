<html>
<head>
<title>A Developer Introduction to Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员对链表的介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-developer-introduction-to-linked-lists-fa748b9964a0?source=collection_archive---------5-----------------------#2021-05-12">https://blog.devgenius.io/a-developer-introduction-to-linked-lists-fa748b9964a0?source=collection_archive---------5-----------------------#2021-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="34d6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">忙碌工程师的链接列表</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b11d6d1aaefc82a4cb5719f0375c1cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9FagCdpbUFIgyK9C"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来自 Unsplash 的强制照片</figcaption></figure><h1 id="aebb" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">观众</h1><p id="9c2e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">任何工程师都可以阅读这篇文章，甚至是那些没有任何链表知识的人。然而，我想说，它对那些至少有短暂理解的人来说是最有用的，并且可以作为对要点的复习。</p><h1 id="3169" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">争吵</h1><p id="b9b8" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">与<a class="ae mg" href="https://jc1175.medium.com/a-developer-revision-of-trees-d2923087b58a" rel="noopener">树</a>不同，树是一种<strong class="lm io">层次</strong>数据结构，链表是<strong class="lm io">线性</strong>。链表有两种类型:<strong class="lm io">单向</strong>链表和<strong class="lm io">双向</strong>链表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/251051c4bab2745d5c4fb17d7c9e8fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZHbr0LgZ6aFNfzeJSWGPw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">上面的图代表一个单向链表，下面的图代表一个双向链表</figcaption></figure><p id="b947" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">在单链表中，每个<strong class="lm io">节点</strong>都有一个值(由上面的<code class="fe mn mo mp mq b">A</code>、<code class="fe mn mo mp mq b">B</code>和<code class="fe mn mo mp mq b">C</code>表示)，以及一个指向下一个节点的<strong class="lm io">指针</strong>(由箭头表示)。列表中的结束节点将指向<code class="fe mn mo mp mq b">null</code>。双向链表是类似的，除了有两个指针:一个指向前面的节点，一个指向后面的节点。</p><p id="7068" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">下面是一个简单的 Java 实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d305" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">通常我们将使用第一个节点(通常称为<strong class="lm io">头</strong>)来表示整个列表。然后我们可以使用指针遍历列表。</p><p id="0083" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">因为我们需要遍历整个列表来查找一个元素，所以我们的搜索时间是<code class="fe mn mo mp mq b">O(n)</code>。插入和删除略有不同。</p><ol class=""><li id="3fbd" class="mt mu in lm b ln mi lq mj lt mv lx mw mb mx mf my mz na nb bi translated">如果给我们一个节点，我们需要在它后面插入，那么我们的复杂度是<code class="fe mn mo mp mq b">O(1)</code>。</li><li id="7052" class="mt mu in lm b ln nc lq nd lt ne lx nf mb ng mf my mz na nb bi translated">如果给我们一个需要删除的节点，那么单向链表的复杂度是<code class="fe mn mo mp mq b">O(n)</code>，而双向链表的复杂度是<code class="fe mn mo mp mq b">O(1)</code>。这就像在一个单链表中，我们需要通过节点回溯来找到我们想要删除的节点的前一个节点。</li><li id="8493" class="mt mu in lm b ln nc lq nd lt ne lx nf mb ng mf my mz na nb bi translated">如果我们需要搜索要插入或删除的节点，那么在所有情况下复杂度都是<code class="fe mn mo mp mq b">O(n)</code>。</li></ol><p id="5660" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">让我们就此展开讨论。</p><h2 id="4c40" class="nh kt in bd ku ni nj dn ky nk nl dp lc lt nm nn le lx no np lg mb nq nr li ns bi translated">插入到单向/双向链表中</h2><p id="5edf" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">对于单链表，主要有两种情况:在列表中间插入和在列表开始插入。在列表末尾插入遵循与在中间插入相同的逻辑，但是“下一个”节点是<code class="fe mn mo mp mq b">null</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/0c0f9a8cf3ce384b05853f28cda36c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66zzlCugLkeeHbQvr_pH8w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">单链表中插入的两种情况</figcaption></figure><p id="52e7" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">上面的图表示插入到一个单链表的中间。我们在<code class="fe mn mo mp mq b">B</code>和<code class="fe mn mo mp mq b">C</code>之间添加了<code class="fe mn mo mp mq b">New</code>节点。为此，我们需要将<code class="fe mn mo mp mq b">B</code>的下一个指针指向<code class="fe mn mo mp mq b">New</code>，然后将<code class="fe mn mo mp mq b">New</code>的下一个指针指向<code class="fe mn mo mp mq b">C</code>。然后擦除<code class="fe mn mo mp mq b">B</code>和<code class="fe mn mo mp mq b">C</code>之间的指针，如虚线所示。</p><p id="9f6d" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">图的下部表示在列表的开始插入。我们需要重新分配头作为我们的新节点，指针现在必须指向前一个头。</p><p id="f0f8" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">让我们把这个编码起来。我们想要一个有两个方法的单链表:<code class="fe mn mo mp mq b">addAtHead</code>和<code class="fe mn mo mp mq b">addAtIndex</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="587c" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">双向链表略有不同，我们现在需要担心两个指针。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/2f2c876ab617306d521a1eae9327c686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jY59opYVGwjWcp5V9kNdVA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">双向链表的三种不同的插入情况。</figcaption></figure><p id="b700" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">前两种情况类似于单链表。首先，我们将前一个节点的下一个指针指向新节点，然后将新节点的前一个指针指向后面。同样，最初的下一个节点将被我们的新节点指向，并反过来指向它。</p><p id="6b98" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">要在头部插入，我们需要将先前的头部指向我们的新节点，并将我们的新节点指向先前的头部。</p><p id="3007" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">要在尾部插入，我们需要将新节点指向前一个尾部，前一个尾部指向新节点。这与单链表不同，因为我们需要意识到<code class="fe mn mo mp mq b">null</code>没有前一个指针的概念。</p><p id="21e2" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">现在让我们把它编码起来。我们想要一个有三种方法的双向链表:<code class="fe mn mo mp mq b">addAtHead</code>、<code class="fe mn mo mp mq b">addAtIndex</code>和<code class="fe mn mo mp mq b">addAtTail</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="76f7" class="nh kt in bd ku ni nj dn ky nk nl dp lc lt nm nn le lx no np lg mb nq nr li ns bi translated">从单向/双向链表中删除</h2><p id="d521" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">掌握了插入的窍门后，我们转向删除。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/e44558c16b4d7a7f5893bf3163c8e68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*J2HzXcCJjVEDWMfV6FPVjA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">单链表中删除的两种情况</figcaption></figure><p id="7883" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">如果我们在列表的中间删除，那么我们需要将前一个节点指向下一个节点，并将指针从要删除的节点上移开。如果我们在头部删除，那么我们需要从当前头部移除指针，并将头部移动到下一个节点。</p><p id="1812" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">让我们把它编码起来。我们这次只会有一个方法，<code class="fe mn mo mp mq b">deleteAtIndex</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bf9b" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">对于双向链表删除，我们需要考虑更多的指针。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/dd669fd5369ecd63d60f0ef4d6f5cb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8jJEA37vhHfmOnsnmBytQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">删除双向链表中节点的三种情况</figcaption></figure><p id="24b8" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">在第一种情况下，我们从队列中间删除。我们需要将前一个节点指向下一个节点，反之亦然。</p><p id="7d65" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">在我们从队列的头部删除的情况下，我们需要移除所有指向和来自要删除的节点的指针，然后将头部移动到下一个节点。</p><p id="c9ba" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">在最后一个场景中，我们也必须这样做，尽管我们不再关心头部。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="41f3" class="nh kt in bd ku ni nj dn ky nk nl dp lc lt nm nn le lx no np lg mb nq nr li ns bi translated">指针问题</h2><p id="7573" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">每当我在使用链表时遇到问题，我会想到“指针”。在链表上使用两个指针并以不同的速度迭代至少可以解决两个问题:在链表中查找循环，以及扩展，查找循环的开始。</p><p id="01b7" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">最初的挑战是通过链表发送两个指针来解决的，一个一次移动一步，另一个一次移动两步。如果指针找到了列表的末尾，就没有循环。如果指针相交，那么就有。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="921a" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">寻找循环的起点稍微复杂一些。这要求我们首先找到节点冲突的地方(如前所述)，然后返回一个指向列表开头的指针，同时继续迭代另一个。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c845" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">我们要解决的最后一个问题是反转一个链表。我们可以这样做:遍历列表，将当前节点指向前一个节点，然后移动头部。下面是一个直观的表示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/441588ff799db1b69a8e26d4bcda4454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Id7KJSbkfk7Sx_ExKWXHzw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">遍历列表并反转指针</figcaption></figure><p id="21eb" class="pw-post-body-paragraph lk ll in lm b ln mi jo lp lq mj jr ls lt mk lv lw lx ml lz ma mb mm md me mf ig bi translated">这体现在下面的编码解决方案中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="1233" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">结论</h1><p id="793e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">总之，我们已经介绍、探索和实现了链表，解决了各种问题。</p></div></div>    
</body>
</html>