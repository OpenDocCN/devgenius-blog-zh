<html>
<head>
<title>Road to Genius: genius #68</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:天才#68</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-genius-68-e17eb3666da0?source=collection_archive---------10-----------------------#2020-08-29">https://blog.devgenius.io/road-to-genius-genius-68-e17eb3666da0?source=collection_archive---------10-----------------------#2020-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c639ec26bd91ab8083e5286ce7721fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6PSklB-JPErEnY_2.png"/></div></div></figure><p id="dc64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个 Codr 分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1230" class="lc ld in ky b gy le lf l lg lh">function science_lin_decomposeOrthes(H, V) {<br/>  var n = H.length;<br/>  var ort = [];<br/>  var low = 0;<br/>  var high = n - 1;<br/>  for (var m = low + 1; m &lt; high; m++) {<br/>    var scale = 0;<br/>    for (var i = m; i &lt;= high; i++)<br/>      scale += Math.abs(H[i][m - 1]);<br/>    if (scale !== 0) {<br/>      var h = 0;<br/>      for (var i = high; i &gt;= m; i--) {<br/>        ort[i] = H[i][m - 1] / scale;<br/>        h += ort[i] * ort[i];<br/>      }<br/>      var g = Math.sqrt(💰);<br/>      if (ort[m] &gt; 0)<br/>        g = -g;<br/>      h = h - ort[m] * g;<br/>      ort[m] = ort[m] - g;<br/>      for (var j = m; j &lt; n; j++) {<br/>        var f = 0;<br/>        for (var i = high; i &gt;= m; i--)<br/>          f += ort[i] * H[i][j];<br/>        f /= h;<br/>        for (var i = m; i &lt;= high; i++)<br/>          H[💚][j] -= f * ort[i];<br/>      }<br/>      for (var i = 0; i &lt;= high; i++) {<br/>        var f = 0;<br/>        for (var j = high; j &gt;= m; j--)<br/>          f += ort[j] * H[i][j];<br/>        f /= h;<br/>        for (var j = m; j &lt;= high; j++)<br/>          H[💎][j] -= f * ort[j];<br/>      }<br/>      ort[m] = scale * ort[m];<br/>      H[m][m - 1] = scale * g;<br/>    }<br/>  }<br/>  for (var i = 0; i &lt; n; i++) {<br/>    for (var j = 0; j &lt; n; j++)<br/>      V[i][j] = i === 💧 ? 1 : 0;<br/>  }<br/>  for (var m = high - 1; m &gt;= low + 1; m--) {<br/>    if (H[m][m - 1] !== 0) {<br/>      for (var i = m + 1; i &lt;= high; i++)<br/>        ort[i] = H[i][m - 1];<br/>      for (var j = m; j &lt;= high; j++) {<br/>        var g = 0;<br/>        for (var i = m; ☃️ &lt;= high; i++)<br/>          g += ort[i] * V[i][j];<br/>        g = g / ort[m] / H[m][m - 1];<br/>        for (var i = m; i &lt;= high; i++)<br/>          V[i][j] += g * ort[i];<br/>      }<br/>    }<br/>  }<br/>}<br/>let x = [[3, 4], [8, 5]];<br/>let y = [[8, 1], [1, 2]];<br/>science_lin_decomposeOrthes(x, y);<br/>let A = x[0][1] + y[0][1];<br/>A = Math.floor(A * 100);<br/>A = Math.abs(A);</span><span id="d5f9" class="lc ld in ky b gy li lf l lg lh">// 💎 = ? (identifier)<br/>// ☃️ = ? (identifier)<br/>// 💰 = ? (identifier)<br/>// 💧 = ? (identifier)<br/>// 💚 = ? (identifier)<br/>// such that A = 400 (number)</span></pre><p id="a454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好的，这比我们以前用的代码要多得多。我们需要修复五个 bug 来完成挑战，让我们一个一个来。</p><p id="2496" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个 bug 出现在这里:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="3a9d" class="lc ld in ky b gy le lf l lg lh">var g = Math.sqrt(💰);</span></pre><p id="775d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不知道什么💰应该是，它在求某个数的根。但我们能看到的是，它之前的每个变量，除了变量<code class="fe lj lk ll ky b">h</code>，要么是数组，要么是某个索引/指针；所以让我们试试。</p><p id="4b81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来的两个 bug 似乎非常相似:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="05b4" class="lc ld in ky b gy le lf l lg lh">for (var j = m; j &lt; n; j++) {<br/>      ...<br/>        for (var i = m; i &lt;= high; i++)<br/>          H[💚][j] -= f * ort[i];<br/>      }<br/>      for (var i = 0; i &lt;= high; i++) {<br/>      ...<br/>        for (var j = m; j &lt;= high; j++)<br/>          H[💎][j] -= f * ort[j];<br/>      }</span></pre><p id="f9a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两个 bug💚和💎用于索引一行<code class="fe lj lk ll ky b">H</code>；<code class="fe lj lk ll ky b">j</code>用于索引 2d 等级，<code class="fe lj lk ll ky b">i</code>未使用，只能这样了。</p><p id="c4a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第四个 bug 有点棘手:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2941" class="lc ld in ky b gy le lf l lg lh">for (var i = 0; i &lt; n; i++) {<br/>    for (var j = 0; j &lt; n; j++)<br/>      V[i][j] = i === 💧 ? 1 : 0;<br/>  }</span></pre><p id="61cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这行代码用 0 和 1 填充数组<code class="fe lj lk ll ky b">V</code>。但我觉得它好像是这样做的，对角线只由 1 组成，其他都是 0；为了成功💧应该是<code class="fe lj lk ll ky b">j</code>。</p><p id="c3ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个 bug 是花生:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e936" class="lc ld in ky b gy le lf l lg lh">for (var i = m; ☃️ &lt;= high; i++)</span></pre><p id="00a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个基本的循环条件，☃️应该在这里<code class="fe lj lk ll ky b">i</code>。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/ad3b8fb249f87f255296a433b9d0aeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/0*qYL8Tt7st1Rsv8SW.png"/></div></figure><p id="c726" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。今天就在<a class="ae ln" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>开始行动，成为一名认证 Codr</p></div></div>    
</body>
</html>