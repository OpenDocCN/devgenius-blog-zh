# 微服务的简单介绍

> 原文：<https://blog.devgenius.io/a-simple-introduction-to-microservices-ecd031973117?source=collection_archive---------12----------------------->

🚀 [**打造分层微服务**](https://learnbackend.dev/books/build-layered-microservices) 这本书出来了！现在就在 [learnbackend.dev](https://learnbackend.dev/books/build-layered-microservices) 购买你自己的副本。

> 任何设计系统的组织都会产生一个设计，其结构是组织的沟通结构的复制。
> —康威定律

![](img/3fa9716295518e5ef76f5d1e3330ef2d.png)

在软件工程中, **monolith** 是一个单层应用程序，其中用户界面、业务逻辑和数据层都被合并到一个实体中，这意味着软件的所有功能都被捆绑在一起。

当产品处于早期阶段，工程师团队非常小，团队中的每个成员共享前端和后端的知识和责任时，通常使用这种类型的架构。

相反，在高绩效组织中，通常会发现多个团队，每个团队都是**长期团队**、**自治团队**和**跨职能团队**。

因此，由松散耦合的团队组成的组织需要松散耦合的架构，这就是所谓的**微服务架构**。

本质上，微服务架构背后的想法是将一个单片应用程序分解成松散耦合的组件，每个组件被称为 T21 服务，每个服务满足一个非常具体的业务需求，例如:处理支付方式、发送电子邮件或管理客户账户。

[](https://www.youtube.com/channel/UCct07fMiEnBP2AER50uTaHw/videos) [## 拉兹万·卢多萨努

### 👋嗨，我是拉兹万！我是法国巴黎的高级软件工程师。我分解计算机科学和后端…

www.youtube.com](https://www.youtube.com/channel/UCct07fMiEnBP2AER50uTaHw/videos) 

# 松耦合

松散耦合意味着并意味着一些事情。

第一件事是，通过共享一个组件对另一个组件的最小程度的直接知识，组件在最少的可行程度上相互依赖。

与整体架构不同，一个组件或微服务不应该知道另一个组件的内部工作方式——它需要知道的只是如何使用它的 **API** 调用它。

这确实很有意义，因为它不是代码内部调用代码，而是服务通过诸如 HTTP 或 AMQP 之类的协议调用其他服务。

正因为如此，偶尔用通过相同接口提供相同服务的替代实现替换组件变得相当容易，几乎不会引入对代码库的破坏性更改。

简而言之，我们可以说松耦合:

*   使系统更加高效和灵活。
*   允许断开或重新配置组件之间的关系。
*   在压力过大的情况下，通过生成一个或多个服务实例来帮助应对负载，而不必纵向扩展整个基础架构。
*   通过让开发人员为每个服务选择正确的技术栈或框架，促进新模式的实现。

例如，对于微服务，您可以在同一个系统中使用 Python 编写一个运行 Flask 的服务，使用 Node.js 编写另一个运行 Express.js 的服务，而使用单一方法，不同的技术不可能混合使用，因为每个组件都是同一个代码库的一部分。

# 隔离

我在介绍中提到的微服务的第二个属性是**隔离**的概念，可以分为以下四个维度。

## **隔离空间**

*空间隔离*意味着微服务被独立部署并在一个单独的进程中执行——比如在 Docker 上，每个服务都在自己的容器中运行。

它允许单独管理每个服务，这意味着启动、停止、重新部署或扩展，而不必关闭整个基础架构，而且可以更快地推出生产功能和修复，因为事实上，更新通常涉及少数服务，而不是整个代码库。

## **隔离状态**

状态的*隔离意味着微服务对其存储的数据完全负责，这意味着两件事。*

从外部对这些数据的任何访问都是通过服务的 API 专门执行的，从而创建了一个防火墙，防止数据在服务不知道更改的情况下被修改。

通过扩展，服务因此可以自由选择使用哪种技术来持久化状态，而不必适应它们的消费者——例如，一个服务可以将其数据存储在 Postgres 数据库中，另一个存储在 MongoDB 中。

## **隔离时间**

*时间隔离*意味着微服务可以将其同步调用仅限于快速响应的服务。

由于组件不在同一个进程中，通过 RabbitMQ 或 Amazon MQ 这样的消息代理异步进行耗时的调用，调用者可以通过一次启动几个调用(而不是顺序启动)来避免空闲等待时间，最终提高资源利用率。

## **故障隔离**

最后，*故障隔离*也称为*弹性*意味着即使一个或多个微服务由于某种原因崩溃，应用程序的其余部分仍将运行。

事实上，在整体架构中，如果错误处理不当，单个失败的组件会导致整个应用程序崩溃是很常见的。

但是，由于微服务运行在不同的进程上，如果一个崩溃，它将对其他用户不可用，而不会将错误传播到整个系统。

# 复杂性

所有这些优势都是有代价的，这就是复杂性。

在不涉及太多细节的情况下，让我简要概述一下与这种架构相关的挑战。

## 技术传播

虽然每个微服务都有一个更小的代码库，本质上也更简单，但是现在有一个潜在的需求，为每个微服务维护多个技术栈、多个项目和多个文档。

## CI/CD

随之而来的事实是，我们需要确保每个服务都正确地连接到自己的部署管道，以实现持续集成和持续开发。

## 测试

测试变得更具挑战性，尤其是当服务之间存在许多依赖关系时——与大多数调用都是内部调用的 monolith 相比——现在这些相同的调用是通过网络远程进行的。

## 网络

谈到网络，网络延迟也是一个新问题，因为我们现在必须在服务之间插入额外的通信机制，无论是无状态的(如 HTTP)还是异步的(如 AMQP)。

如果不仔细设计，每个网络调用的每个延迟都会使系统完全失去平衡。

## 数据完整性

对应用程序执行的一些操作可能需要调用多个服务，这些服务将执行多个业务事务，从而导致执行多个数据库操作…这需要数据的最终一致性或复杂的回滚机制，以确保系统始终处于一致的状态。

# 下一步是什么？

不要忘记👏🏻x50 如果你喜欢读我的作品！

👉你喜欢这种内容？请在 [https://learnbackend.dev](https://learnbackend.dev/) 查看《 **构建分层微服务** 一书，了解如何使用 Express framework 构建生产就绪的分层认证微服务，从第一行代码到最后一行文档，该服务符合开发实践和软件架构方面的行业标准。