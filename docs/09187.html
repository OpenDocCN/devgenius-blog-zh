<html>
<head>
<title>Singleton Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singleton-design-pattern-582709d578af?source=collection_archive---------11-----------------------#2022-08-04">https://blog.devgenius.io/singleton-design-pattern-582709d578af?source=collection_archive---------11-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="a1f6" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">基本概述:</h1><p id="fc6e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">单例设计模式用于创建一个类的单个实例并重用它。</p><p id="dd9d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用单例设计模式，我们可以节省大量的内存，因为我们只创建了一个类的实例。</p><h2 id="5ede" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">简单的单例类:</h2><p id="8012" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了创建一个简单的单例类，我们需要两件基本的东西:</p><ol class=""><li id="2539" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">私有构造函数:因为我们不希望任何其他类创建 singleton 类的实例。</li><li id="579b" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated"><strong class="kk io">静态函数:</strong>我们使用静态函数，因为它的内存只被分配一次，使用它我们返回我们创建的对象</li></ol><h2 id="d596" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">简单单例类的不同初始化方式:</h2><p id="74c9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="ml">懒惰初始化:</em></p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/7d52e5dd3abda604ca4e0a665065aea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tODTkrkXcyv02m4KrvBy_A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">简单单例类</figcaption></figure><p id="8c63" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><em class="ml">急切初始化:</em></p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/d7daa663cf9d958a1ecb9fe060ff3f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOSO-wYQqJscDf_ZfS8k_Q.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">急切初始化</figcaption></figure><p id="8d4d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">急切初始化的优点:</strong></p><ol class=""><li id="8bec" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">类的实例是在类加载时创建的</li><li id="d809" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">我们不会有任何线程安全问题</li><li id="fb70" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">我们依靠 JVM 在装入类时创建类的唯一实例。</li></ol><p id="0b8d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">急切初始化的缺点:</strong></p><ol class=""><li id="6ea7" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">即使我们不使用它，实例也会被创建</li><li id="8da7" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">没有异常处理的方法</li><li id="721b" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">如果单例类没有使用大量资源，则工作正常</li></ol><h1 id="47e8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">简单单例类的问题:</h1><p id="e869" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们创建的 singleton 类对于简单的场景工作良好，但是当我们包含</p><ul class=""><li id="c40a" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf nd md me mf bi translated">多线程操作</li><li id="fa7a" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf nd md me mf bi translated">反序列化</li><li id="0410" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf nd md me mf bi translated">克隆</li><li id="68ec" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf nd md me mf bi translated">反射</li></ul><p id="e1f1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">它不像创建类的单个实例的概念那样工作。</p><h2 id="a26c" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">解决与多线程相关的问题:</h2><p id="29cb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，如果两个或多个线程正在处理这个类，而我们不能应用急切初始化，因为这将是一个资源密集型类，那么我们将不得不同步我们的函数，以便只允许一个线程访问类函数</p><p id="3b59" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这样我们拥有单个实例的概念就不会被违反。</p><p id="6c89" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因此，我们将做以下更改，以便为多线程优化我们的 singleton 类。</p><blockquote class="ne nf ng"><p id="def8" class="ki kj ml kk b kl lg kn ko kp lh kr ks nh li kv kw ni lj kz la nj lk ld le lf ig bi translated">双重检查锁定</p></blockquote><ol class=""><li id="9f74" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated"><strong class="kk io">使用 Volatile 关键字创建实例:</strong></li></ol><p id="b0ea" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Volatile 关键字<strong class="kk io">用于通过不同的线程</strong>修改变量的值。它也用于使类线程安全。这意味着多个线程可以毫无问题地同时使用这些类的一个方法和实例。</p><p id="1ff0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">2.<strong class="kk io">使用同步:</strong></p><p id="34f7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用同步，我们将允许我们的类是线程安全的，因为只有一个线程可以使用 singleton 类。</p><p id="2bb8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">此外，我们将只同步我们的函数时，我们的对象是空的，因为之后没有必要同步，因为每个线程，我们将传递相同的值。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nk"><img src="../Images/429ea20a5602b1bb6cd8a8e441abe83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iI4dS1i87STYVosKuholrQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">线程安全单例类</figcaption></figure><h2 id="592e" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">解决与<strong class="ak">反序列化</strong>相关的问题:</h2><p id="1a8c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我们序列化一个对象并再次反序列化它时，会生成不同的哈希代码值，即创建不同的类对象。因此，在对象序列化/反序列化的情况下，我们的 Singleton 原则也发生了变化。</p><p id="c93a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了解决这个问题，我们用 Serializable 接口实现了我们的类</p><p id="0b58" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们实现了<a class="ae nl" href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/input.html#5903" rel="noopener ugc nofollow" target="_blank"> readResolve () </a>方法</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nm"><img src="../Images/af876ad03afe4aedb5497f87a64de552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDUpUk1QhJIZWjnRR-J_TA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">可序列化的安全单例类</figcaption></figure><h2 id="afc9" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">解决与克隆相关的问题:</h2><p id="2f5b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以在 java 中使用 clone 函数来克隆一个类的实例。</p><p id="765c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">但是这将违反我们的单例原则，因为我们不想要任何其他副本</p><p id="2042" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因此为了摆脱这种情况，我们用可克隆的接口实现我们的类，并抛出<a class="ae nl" href="https://docs.oracle.com/javase/8/docs/api/java/lang/CloneNotSupportedException.html" rel="noopener ugc nofollow" target="_blank">cloneotupportdexception()</a></p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nn"><img src="../Images/9993d42792f1dcd3bf0b8f7c1a6974c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUzS0_0nSE8hysKE89wrLw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">克隆自适应单例类</figcaption></figure><h2 id="e56d" class="ll jl in bd jm lm ln dn jq lo lp dp ju kt lq lr jy kx ls lt kc lb lu lv kg lw bi translated">解决与反思相关的问题:</h2><p id="041b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在反射期间，我们在运行时创建实例的副本</p><p id="8f02" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以这违反了我们的单身原则，需要处理。</p><p id="17e5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了避免反思，我们抛出了一个异常<a class="ae nl" href="https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html" rel="noopener ugc nofollow" target="_blank">illegalsstatexception</a>。</p><p id="33b9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以基本上，如果我们的对象已经被创建，那么我们抛出这个异常</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi no"><img src="../Images/236f5cb7f7eb413a7bbb3104dc1ae155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXSrs0Is-jN7o0Hv15xyfA.png"/></div></div></figure><p id="14ed" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，我们终于涵盖了我们的对象可能被复制或者可能出现在不同情况下的所有情况</p><p id="6b66" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因此，我们最终的完全单例类将是:</p><pre class="mn mo mp mq gt np nq nr ns aw nt bi"><span id="df5e" class="ll jl in nq b gy nu nv l nw nx">package org.example.singleton;<br/><br/>import java.io.Serializable;<br/>import java.util.Objects;<br/><br/>public class CompleteSingleton implements Cloneable , Serializable {<br/>    //volatile static object<br/>    private volatile static CompleteSingleton <em class="ml">object</em>;<br/>    // private Constructor throwing IllegalStateException<br/>    private CompleteSingleton(){<br/>         if(Objects.<em class="ml">nonNull</em>(<em class="ml">object</em>)){<br/>              throw new IllegalStateException("object already created!");<br/>         }<br/>    }<br/>   // Synchronized Function for Getting Object<br/>    private static CompleteSingleton getInstance(){<br/>         if(Objects.<em class="ml">isNull</em>(<em class="ml">object</em>)){<br/>              synchronized (CompleteSingleton.class){<br/>                   if(Objects.<em class="ml">isNull</em>(<em class="ml">object</em>)){<br/>                        <em class="ml">object </em>= new CompleteSingleton();<br/>                   }<br/>              }<br/>         }<br/>         return <em class="ml">object</em>;<br/>    }<br/>    // readResolve() method to avoid object creation during Serialization / De Serialization<br/>    protected Object readResolve(){<br/>        return  <em class="ml">object</em>;<br/>    }<br/><br/>   // throwing CloneNotSupportedException so that cloning is not supported<br/>    protected Object clone() throws CloneNotSupportedException{<br/>        throw  new CloneNotSupportedException();<br/>    }<br/><br/>}</span></pre><p id="e7fa" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以基本上总体上，我们可以说一个完整的单例类</p><ol class=""><li id="d0f7" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">易失性静态对象</li><li id="fa75" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">引发 IllegalStateException 以避免在反射期间复制对象的私有构造函数</li><li id="560b" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">当对象为空时，使用同步块来初始化函数，这样就不会出现多线程问题</li><li id="a34f" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">readResolve()方法，以避免在序列化/反序列化期间创建对象</li><li id="8b98" class="lx ly in kk b kl mg kp mh kt mi kx mj lb mk lf mc md me mf bi translated">函数的作用是:抛出 CloneNotSupportedException，这样就不会发生实例的克隆</li></ol></div></div>    
</body>
</html>