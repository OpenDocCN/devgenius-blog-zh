<html>
<head>
<title>How to improve the build time of your Backend Application using Docker Multi-Stage Build?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Docker 多阶段构建来缩短后端应用程序的构建时间？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-improve-the-build-time-of-your-backend-application-using-docker-multi-stage-build-23557da7862f?source=collection_archive---------1-----------------------#2021-10-30">https://blog.devgenius.io/how-to-improve-the-build-time-of-your-backend-application-using-docker-multi-stage-build-23557da7862f?source=collection_archive---------1-----------------------#2021-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cf5d80083f97b2b19f05204d8afb504d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO-Mf55PiRod_fCZLoeHcg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Shaah Shahidh 在<a class="ae jz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="132b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你知道后端工程师最沮丧的事情是什么吗？你猜怎么着？正是 docker 构建时间耗尽了他们的耐心，伤害最大。因此，我写了这篇文章，试图改善我的 Go 应用程序的 docker 构建时间，并学习如何使用 docker 多阶段构建。</p><blockquote class="ky kz la"><p id="54ce" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">如果你生来就是为了解决问题，那么你来对地方了！</p></blockquote><h1 id="8909" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><ol class=""><li id="2565" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated">熟悉“码头工人”这个词</li><li id="621c" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">了解后端应用程序的部署流程</li><li id="b8eb" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">想不出别的:)</li></ol><h1 id="db48" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">码头文件</h1><p id="2f34" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">编写<em class="lb"> Dockerfiles </em>时最具挑战性的任务是尽可能缩小 docker 图像的尺寸。当图像大小增加时，维护图像并使用该图像执行容器变得很困难。此外，我们必须将 docker 图像存储在云上(可能是 AWS ECR ),如果图像太大，这可能会导致更多的成本。</p><p id="34ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当每个指令在<em class="lb"> Dockerfile </em>中执行时，它会向图像添加一个新层。因此，为了优化 Dockerfiles，我们可以保持较小的映像大小，并尽量减少 docker files 中写入的每条指令的执行次数。</p><h1 id="bc68" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">单阶段 docker 构建有什么问题？</h1><p id="4ed2" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">“构建器模式”通常在早期用于为他们的应用程序编写 docker 文件。但是等等，这个“构建模式”是什么？让我们看一看。</p><blockquote class="mw"><p id="3481" class="mx my in bd mz na nb nc nd ne nf kx dk translated">对于开发环境，我们只有一个 docker 文件，它包含了构建应用程序所需的一切。然后我们精简这个 docker 文件以用于生产环境，这样它只包含应用程序和运行它所需的东西。这种设计基础是基于“构建模式”。</p></blockquote><pre class="ng nh ni nj nk nl nm nn no aw np bi"><span id="6c92" class="nq lg in nm b gy nr ns l nt nu">FROM golang:1.10<br/><br/>WORKDIR $GOPATH/src/github.com/codefresh-contrib/go-sample-app<br/><br/>COPY . .<br/><br/>RUN go get -d -v ./... &amp;&amp; go install -v ./...<br/><br/>EXPOSE 8080<br/><br/>CMD ["go-your-app"]</span></pre><p id="b916" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你注意到上面的<em class="lb"> Dockerfile </em>，我们已经使用'<em class="lb"> &amp; &amp; </em> ' ( <em class="lb"> Bash 操作符</em>)压缩了两个<em class="lb"> RUN </em>命令。这有助于我们防止在图像中创建额外的层。因此，保持图像尺寸较小。但是这种设计容易出错，维护起来也很困难，尤其是当<em class="lb">运行</em>命令的数量增加时。</p><p id="161f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题的解决方案是 docker <em class="lb">多阶段构建，</em>让我们接下来讨论这个问题，并改进构建时间。</p><h1 id="71c7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Docker 中的多阶段构建是什么？</h1><p id="4c11" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated"><em class="lb">多阶段</em> Docker 构建是指我们在<em class="lb">Docker 文件</em>中使用多个<em class="lb"> FROM </em>语句的构建。<em class="lb">docker 文件</em>中的每个 FROM 指令使用不同的基础(阶段),并开始构建的新阶段。在多阶段构建中，我们可以明确地将工件从一个阶段复制到另一个阶段，并跳过最终图像中不需要的所有内容。请查看下面的<em class="lb">文档</em>并观察<em class="lb">文档</em>中的不同阶段。</p><pre class="nv nw nx ny gt nl nm nn no aw np bi"><span id="aa18" class="nq lg in nm b gy nr ns l nt nu">FROM golang:1.12-alpine AS build_base<br/><br/>RUN apk add --no-cache git<br/><br/>WORKDIR /tmp/your-go-app<br/><br/>COPY go.mod .<br/>COPY go.sum .<br/><br/>RUN go mod download<br/><br/>COPY . .<br/><br/>RUN CGO_ENABLED=0 go test -v<br/><br/>RUN go build -o ./out/your-go-app .<br/><br/>FROM alpine:3.9 <br/>RUN apk add ca-certificates<br/><br/>COPY --from=build_base /tmp/go-sample-app/out/your-go-app /app/your-go-app<br/><br/>EXPOSE 8080<br/><br/>CMD ["/app/your-go-app"]</span></pre><p id="9609" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的文件是一个多阶段构建的例子。我们可以看到这里有两个 FROM 语句/指令，它们执行两个容器“golang”和“alpine”。因此，我们只需要一个 docker 文件，只需运行“docker build”。</p><pre class="nv nw nx ny gt nl nm nn no aw np bi"><span id="634e" class="nq lg in nm b gy nr ns l nt nu">$ docker  build  -t  image_name:tag_name .</span></pre><figure class="nv nw nx ny gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8534108ce0d02f6516690913dd003bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*e42uC5NLU1yoQCXoiz0ehg.png"/></div></figure><p id="b84e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们不需要创建任何中间图像，也不需要将任何工件提取到我们的本地机器。我们得到的结果是一个非常小的产品图像，复杂度大大降低。</p><h2 id="f000" class="nq lg in bd lh oa ob dn ll oc od dp lp kl oe of lt kp og oh lx kt oi oj mb ok bi translated">但是上面的 Dockerfile 到底是怎么工作的呢？</h2><p id="4dc5" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">上述<em class="lb"> Dockerfile </em>中的第二个“FROM”指令以“alpine: latest”为基础开始新的构建阶段。语句“COPY-from=0”将构建工件从早期阶段复制到新阶段。</p><h1 id="803e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不知道如何命名构建阶段？</h1><p id="242e" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">默认情况下，不会给出每个多级 docker 构件的名称。</p><p id="e092" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">默认情况下，在多阶段构建中不命名阶段</em>。我们通常用从 0( <em class="lb">零</em>)开始的整数来指代它们，从指令的第一个“<em class="lb">”开始，依此类推。但是，我们可以通过在来自</em>指令的<em class="lb">中添加“<em class="lb">作为&lt;名称&gt; </em>来命名每个阶段。然后我们可以在<em class="lb">复制</em>指令中使用这个阶段名。这样，<em class="lb">副本</em>不会中断，即使我们稍后决定重新排序<em class="lb"> Dockerfile </em>中的指令。</em></p><h1 id="578e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们能停止一个特定的 docker 构建阶段吗？</h1><p id="c28e" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">当<em class="lb"> Dockerfile、</em>中有多个阶段或语句时，我们可能不必构建一个包含所有阶段的完整<em class="lb"> Dockerfile </em>。我们可以只指定目标构建阶段并停止其他阶段。正如您在下面的命令中看到的</p><pre class="nv nw nx ny gt nl nm nn no aw np bi"><span id="7831" class="nq lg in nm b gy nr ns l nt nu">$ docker build --target build_base -t image_name:tag_name.</span></pre><p id="f6b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用多阶段 docker 构建完成以下任务:</p><ul class=""><li id="119a" class="md me in kc b kd ke kh ki kl ol kp om kt on kx oo ml mm mn bi translated">为了调试特定的阶段，我们可以在特定的阶段停止。</li><li id="9cde" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated">我们可以在测试阶段使用它，方法是填充测试数据，并使用不同的阶段构建产品。</li></ul><h1 id="3477" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">问候！🙂</h1><p id="6958" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">多阶段构建可以显著简化复杂 Docker 映像的构建。它们允许您涉及多个相互连接的构建步骤，这些步骤可以向前传递输出工件。</p><figure class="nv nw nx ny gt jo gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e29e9a2abda4a46c2024cf8bde898e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*wtl45RFNUil26IUAXoRHSg.gif"/></div></figure><ul class=""><li id="623c" class="md me in kc b kd ke kh ki kl ol kp om kt on kx oo ml mm mn bi translated"><em class="lb">多阶段构建非常适合部署生产就绪型应用程序。</em></li><li id="da04" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated"><em class="lb">多阶段构建只使用一个 docker 文件。</em></li><li id="82db" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated">它允许我们构建更小的图像，Dockerfile 将它们分成不同的构建阶段。</li><li id="3cbe" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated"><em class="lb">我们要学习统一的语法。</em></li><li id="6424" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated"><em class="lb">多阶段构建工作在本地机器和 CI(持续集成)服务器上进行。</em></li></ul><h1 id="dea7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="70de" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了这篇文章的完整性，让我们快速回顾一下到目前为止我们所学的内容。</p><ul class=""><li id="ddbc" class="md me in kc b kd ke kh ki kl ol kp om kt on kx oo ml mm mn bi translated">了解了如何缩小 docker 图像的尺寸。</li><li id="d5e8" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oo ml mm mn bi translated">我们了解了为什么我们需要多阶段构建而不是单阶段 docker 构建。</li></ul><blockquote class="mw"><p id="aae2" class="mx my in bd mz na oq or os ot ou kx dk translated">如果你喜欢这篇文章，别忘了为它鼓掌！</p></blockquote><figure class="ng nh ni nj nk jo gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a7d8c1ca5201216f8856b10e902b2fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/1*L2RLgwJSAbkkDfTKTb5G8A.gif"/></div></figure><p id="b216" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请随时在<a class="ae jz" href="https://www.linkedin.com/in/shubham-kaushik-temp/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">Linkedin</strong></a><strong class="kc io"/>上 ping 我，敬请期待下一期！</p></div></div>    
</body>
</html>