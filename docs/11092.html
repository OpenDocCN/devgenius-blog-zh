<html>
<head>
<title>What are Interactive Islands? Get started with the Fresh framework!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是互动岛？开始使用全新的框架！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-are-interactive-islands-get-started-with-the-fresh-framework-d5824948a356?source=collection_archive---------2-----------------------#2022-12-18">https://blog.devgenius.io/what-are-interactive-islands-get-started-with-the-fresh-framework-d5824948a356?source=collection_archive---------2-----------------------#2022-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e7766fc43ac4d56ad102cf0dee94deee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7C1tj372UBZFhNYvEM-rew.png"/></div></div></figure><p id="8ea3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">交互岛或“岛架构”是前端中的一个概念，更具体地说，是用户体验(UX)领域中的一个概念，其中 HTML 是在服务器端生成的，本质上是动态的组件在客户端独立地被<strong class="jx io">水合</strong>。因此，用户不必等待整个页面被加载，并可以立即开始与加载的组件进行交互。</p><p id="5bf5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将通过使用<a class="ae kt" href="https://fresh.deno.dev/" rel="noopener ugc nofollow" target="_blank"> Fresh Framework </a>的实际演示来了解什么是交互岛，这是用<a class="ae kt" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>构建的下一代全栈 web 框架。</p><h1 id="51c2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">内容</h1><ol class=""><li id="3447" class="ls lt in jx b jy lu kc lv kg lw kk lx ko ly ks lz ma mb mc bi translated"><a class="ae kt" href="#0299" rel="noopener ugc nofollow">什么是互动岛？</a></li><li id="9017" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#d17d" rel="noopener ugc nofollow">新鲜框架介绍</a></li><li id="ed5e" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#6d5e" rel="noopener ugc nofollow">创建一个新的新鲜项目</a></li><li id="2eb0" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#b188" rel="noopener ugc nofollow">项目结构</a></li><li id="c697" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#9068" rel="noopener ugc nofollow">互动岛屿演示</a></li><li id="cdfb" class="ls lt in jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><a class="ae kt" href="#3b47" rel="noopener ugc nofollow">结论</a></li></ol><h1 id="0299" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是互动岛？</h1><p id="2f99" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">基本上，应该是可交互的组件最初作为占位符发送，然后在客户端用 JavaScript 处理这些占位符，以使其可交互。</p><p id="2c7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种体系结构的优点是用户不必为了与加载的组件交互而等待整个页面加载。这就是组件被称为“孤岛”的原因，这些组件本质上是孤立呈现的，而不是相互依赖的。</p><p id="060a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将在这个博客中使用 Fresh 来回顾这实际上是如何工作的。但首先，我们先了解一下什么是新鲜的框架！</p><h1 id="d17d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Fresh 框架简介</h1><p id="a3d0" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Fresh 是一个相对较新的框架，旨在解决传统框架的问题，同时牢记“孤岛架构”。</p><h2 id="038e" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">后端的 Deno</h2><p id="3955" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Fresh 是一个开源的全栈框架，它使用<a class="ae kt" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>作为后台框架，并带有现成的 TypeScript！</p><p id="f692" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>，众所周知是一个安全的 JavaScript 运行时，支持开箱即用的类型脚本。本质上是 NodeJS 的继承者，因为它是由 Node 的创始人 Ryan Dahl 创建的。</p><h2 id="790e" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">预先行动而不是反应</h2><p id="acf8" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><a class="ae kt" href="https://fresh.deno.dev/" rel="noopener ugc nofollow" target="_blank"> Fresh </a>是构建在<a class="ae kt" href="https://preactjs.com/" rel="noopener ugc nofollow" target="_blank"> Preact </a>之上的下一代 web 框架之一，可以帮助您构建健壮且可伸缩的 web 应用程序，同时确保最终用户体验符合标准。</p><p id="293c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为 Fresh 使用 Preact，react 的最小版本具有 React 的大多数重要 API，这使它变得轻量级和高性能！</p><h2 id="67a8" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">顺风 CSS</h2><p id="4b01" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Fresh 还提供了在创建新项目时使用预配置的<a class="ae kt" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风 CSS </a>的选项。</p><h2 id="5960" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">具有客户端水合作用的服务器端</h2><p id="764f" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">默认情况下，Fresh 中的所有页面都是在服务器端呈现的，但是在客户端中，这些岛是在服务器端呈现的。我们将在本博客的演示部分深入探讨这个问题。</p><p id="acf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Fresh 在服务器端本身使用 JIT (Just in Time)编译过程，这不仅减少了客户端的处理，而且还根据请求发送 HTML 内容，这对于搜索引擎爬虫来说是惊人的！</p><h2 id="4b38" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">文件系统路由</h2><p id="f67f" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Fresh 提供了一种叫做<strong class="jx io">文件系统路由</strong>的机制，这也是<a class="ae kt" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> NextJS </a>提供的一个特性。</p><p id="4ee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本质上，您的文件系统或文件夹结构定义了您的应用程序的路径。要了解更多信息，请阅读这里的文档。这种机制只是在项目中构造路线的一种直观而简单的方式。下面是 fresh 在他们的<a class="ae kt" href="https://fresh.deno.dev/docs/concepts/routing" rel="noopener ugc nofollow" target="_blank">文档</a>中是如何描述的！</p><h1 id="6d5e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建一个新的项目</h1><p id="bb4a" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">理论说够了，让我们直接进入<a class="ae kt" href="https://fresh.deno.dev/docs/getting-started/create-a-project" rel="noopener ugc nofollow" target="_blank">创造一个新的新鲜项目</a>！</p><p id="3495" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行以下命令创建一个新项目:</p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="2c70" class="ng kv in nc b be nh ni l nj nk">deno run -A -r https://fresh.deno.dev &lt;project-name&gt;</span></pre><p id="435c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的命令会询问我们是否要在项目中使用 TailwindCSS 我将选择“是”选项，但这并不要求您遵循这篇文章。</p><p id="97f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦上面的命令完成，您应该会看到一个样例项目，它包含了开箱即用的所有最佳实践和约定！这只是帮助我们作为新来者理解 Fresh 的开发者是如何看待它被使用的。</p><p id="6a14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在对代码进行任何更改之前，让我们通过运行以下命令来查看它创建的默认应用程序:</p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="e816" class="ng kv in nc b be nh ni l nj nk">deno task start</span></pre><p id="38ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应用程序应该在<code class="fe nl nm nn nc b"><a class="ae kt" href="http://localhost:8000/!" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></code> <a class="ae kt" href="http://localhost:8000/!" rel="noopener ugc nofollow" target="_blank">开始！</a></p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/add9eec622cc6df86f67591e5949f1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVk59s9LS_VLYy9un_dDBg.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">默认新项目</figcaption></figure><h1 id="b188" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">项目结构</h1><p id="0e84" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这是您创建新项目时将看到的文件夹结构:</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/ec335234c3033b660ed7068200ae6bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ryioRJZDhY8ypLlLlUHv2Q.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">全新的默认项目文件夹结构</figcaption></figure><h2 id="f056" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">Deno 配置文件</h2><p id="a462" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nl nm nn nc b">deno.json</code> &amp; <code class="fe nl nm nn nc b">deno.lock</code>这两个文件是 Deno 服务器需要的配置文件。对于 Rails 开发人员来说,<code class="fe nl nm nn nc b">deno.lock</code>文件应该很熟悉，它包含了关于项目中安装的包的元数据，我们通常不会乱用它。<code class="fe nl nm nn nc b">deno.json</code>和 NodeJS 的<code class="fe nl nm nn nc b">package.json</code>很像</p><blockquote class="nu nv nw"><p id="4001" class="jv jw nx jx b jy jz ka kb kc kd ke kf ny kh ki kj nz kl km kn oa kp kq kr ks ig bi translated">使用基本项目时，不需要对上述文件进行任何更改。</p></blockquote><h2 id="f9b9" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">新鲜的基本文件</h2><p id="0691" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nl nm nn nc b">dev.ts</code>是本地开发的入口点文件，而<code class="fe nl nm nn nc b">main.ts</code>是生产环境的入口点文件。</p><p id="0b4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nc b">fresh.gen.ts</code>是一个自动生成的文件，包含与应用程序的<code class="fe nl nm nn nc b">routes</code>和<code class="fe nl nm nn nc b">islands</code>相关的元数据信息。</p><p id="b5e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nc b">import_map.json</code>顾名思义，是您的新项目的依赖项部分的导入映射。</p><h2 id="901f" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">组件文件夹</h2><p id="d77b" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这是一个我们可以放<strong class="jx io">可重用组件</strong>的文件夹。这就是我喜欢 Fresh 的地方，开发人员试图明确约定，这样我们就不必绞尽脑汁试图找出如何正确设置项目。</p><h2 id="3ab2" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">岛屿文件夹</h2><p id="2a30" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这是我们应该拥有<strong class="jx io">小部件</strong>(岛屿)的文件夹；这些基本上是在服务器端呈现的组件，但是在客户端独立地进行了处理。</p><p id="7703" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 NextJS 等其他框架也支持的特性，但不是核心特性。新的框架是以 Islands 架构为核心构建的。</p><h2 id="1ce2" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">路线文件夹</h2><p id="9b25" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">最后但同样重要的是，<code class="fe nl nm nn nc b">routes</code>文件夹。如前所述，这个文件夹负责所有的应用程序页面。路由是由文件文件夹名称&amp;处理的。</p><h1 id="9068" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">互动岛屿演示</h1><p id="a3f8" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">现在我们已经理解了 Fresh 的核心概念，让我们来看看我用 Fresh 创建的一个示例项目，并理解交互的<strong class="jx io">岛</strong>概念<strong class="jx io"> </strong>是如何工作的。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/554b3fa5deeeea7a6f83f3c3acd98977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROcJPOUuqrMLgZJT2jvSpw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">互动岛屿演示</figcaption></figure><p id="533f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的图片是我创建的示例应用程序的屏幕截图。如您所见，这是一个简单的单页应用程序，由四个由不同背景颜色描述的孤岛组件组成。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c5c99b37c04f51f4512041f8cd43af6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*oq-CoQxwbWJVFeXWZEVB0g.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">岛屿文件夹列表</figcaption></figure><p id="1e29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是 islands 文件夹的样子，如上所述，它包含 4 个组件。<code class="fe nl nm nn nc b">Table</code>岛是第一个部件，<code class="fe nl nm nn nc b">Button</code>是第二个部件(从左上到右，然后是底部)。然后<code class="fe nl nm nn nc b">Form</code>岛是第三个小部件，<code class="fe nl nm nn nc b">Steps</code>是最后一个。我在博客后面提到这个顺序是为了参考理解一个概念，所以要注意这个！</p><blockquote class="nu nv nw"><p id="bf1c" class="jv jw nx jx b jy jz ka kb kc kd ke kf ny kh ki kj nz kl km kn oa kp kq kr ks ig bi translated">注意到我是如何称它们为部件而不是组件的吗？因为正如我们之前讨论的，它们不是正常的组件，它们是孤岛！接下来，我将互换使用小部件和岛，只要记住我指的是同一个东西。</p></blockquote><p id="46fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们进入开发控制台！在网络选项卡中，确保切换<code class="fe nl nm nn nc b">JS</code>过滤器。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi od"><img src="../Images/28b7cd3b4ecaf8e44959061a9deabee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*fT794O2mdilMA8WNajdWhA.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">网络选项卡—水合作用在起作用</figcaption></figure><p id="b8b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面的图片中看到的，所有的小部件都有自己的 JavaScript 文件，这些文件是由客户端获取的。加载后，Fresh 会在后台处理独立的再水合过程。</p><blockquote class="nu nv nw"><p id="90ed" class="jv jw nx jx b jy jz ka kb kc kd ke kf ny kh ki kj nz kl km kn oa kp kq kr ks ig bi translated">请注意，文件的顺序与组件在视图中的放置顺序相同。</p></blockquote><p id="5102" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来证实一下这个理论吧！我将把第四个小部件移到前两个小部件上面。基本上，重新排序。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/9c6e7d19f7509c4597bba13fa93b1dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MpdTP7O-OOGRUlnpUq9Gw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">互动岛屿演示—重新排序后</figcaption></figure><p id="2664" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们再看一下“网络”选项卡。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi od"><img src="../Images/4ba5e5f70aa409241a53d3d9de5ab12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*O0EbXkh07sigY6wpCcnlog.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">网络选项卡-水合作用-重新排序后</figcaption></figure><p id="83d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，首先获取的是<code class="fe nl nm nn nc b">steps</code>小部件。由此，我们可以得出结论，当涉及到新鲜的框架时，被水合的部件的顺序很重要！</p><h2 id="99ae" class="ml kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">水合优先</h2><p id="0e0f" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">组件在代码中的排列顺序就是组件在前端进行水合(即，使其可交互)的顺序。这完全有道理，也很直观！</p><p id="c2b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很神奇吧？！这就是为什么我提到交互岛的概念更确切地说是用户体验(UX)领域的一个概念。</p><h1 id="3b47" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="f63f" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Fresh 号称是下一代 web 框架，绝对是你在构建下一个项目时应该考虑的框架。它使用了现成的 Deno &amp; TypeScript，这意味着它也有集成 tRPC 的潜力！这是我们稍后可以进入的另一个主题:)它还使用 Preact，react 的一个更轻量级的版本。</p><p id="0892" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总而言之，它确实是下一代全栈 web 框架之一，可以帮助您构建一个健壮的应用程序。</p><p id="0bca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，谢谢你能走到这一步！如果你喜欢这样的内容，请关注我。如果你想更多地了解我，你可以访问我的网站:<a class="ae kt" href="https://karanjagtiani.com" rel="noopener ugc nofollow" target="_blank">https://karanjagtiani.com</a>。下次见！</p></div></div>    
</body>
</html>