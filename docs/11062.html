<html>
<head>
<title>Declare once, deploy anywhere: A Serverless Approach to Managing REST API Integrations with IngestLess — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一次声明，随处部署:管理 REST API 与 IngestLess 集成的无服务器方法——第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/declare-once-deploy-anywhere-a-serverless-approach-to-managing-rest-api-integrations-with-c73ec84c0cce?source=collection_archive---------10-----------------------#2022-12-15">https://blog.devgenius.io/declare-once-deploy-anywhere-a-serverless-approach-to-managing-rest-api-integrations-with-c73ec84c0cce?source=collection_archive---------10-----------------------#2022-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4bf40f34a0c25c266156ad799cd85ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HvRbr4eyFgIMh5YQ"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="5990" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是实现新的无服务器 REST API 集成框架概念验证的系列文章的第二部分</p><p id="631b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-for-rest-integration-c916dcafe769"> <strong class="kc io">系列文章的第一部分</strong> </a>中，我们定义了声明性 REST API 集成工作流的需求，阐述了高级组件架构，以及我们实现的一些指导原则。</p><h1 id="7606" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实现 YAML 模板解析器</h1><p id="7848" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在今天的文章中，我们看一个选项来实现将接收我们的文件的<code class="fe mb mc md me b">TemplateParser</code>,应用模式验证步骤来检查正确性，并将 YAML 配置解析为一组具有定义的接口的类，这些接口将允许所有下游服务愉快地解析、编排、编译和部署它到我们正在寻找的最终 IaC 输出。</p><p id="1c09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要<strong class="kc io">大致满足这些要求</strong>:</p><ul class=""><li id="a831" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">可以从给定的文件路径加载 YAML 文件</li><li id="9555" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">可以对照目标模式验证文件模式</li><li id="078b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">使未来的模式版本能够并行使用</li><li id="675f" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">将配置解析成我们可以进一步优化的内部表示</li></ul><p id="a759" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一次概念验证中，我们很可能会忽略这些要求:</p><ul class=""><li id="9cff" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">可以向用户突出显示模板中的配置错误</li><li id="1db3" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">可以对典型的拼写错误提供拼写纠正</li></ul><h2 id="13f8" class="mt kz in bd la mu mv dn le mw mx dp li kl my mz lm kp na nb lq kt nc nd lu ne bi translated">定义模式</h2><p id="1b9a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">因为 Kubernetes 已经为我们实现了这个结构，所以我将从重用模板部分的主要思想开始。</p><p id="37af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过概述样本模板 YML 文件中的主要部分，我们可以迭代我们的构造之间的主要交互，直到我们对初始结果满意为止。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f1efc9515e581472a2895b62a6a27c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuMZFwaicLuu1igkMZ018w.png"/></div></div></figure><p id="2628" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在以下面的部分结束<strong class="kc io">:</strong></p><ol class=""><li id="9e39" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx nk ml mm mn bi translated"><strong class="kc io">版本</strong>:标识用于模板解析器的模式版本</li><li id="05f6" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx nk ml mm mn bi translated"><strong class="kc io">种类</strong>:标识已定义构造类型的关键字。这使我们能够在将来将模板文件分解成一组子结构，以防我们的整体定义变得太长。主要考虑从输出和解析器声明中扩展端点定义，因为它们本身将来可能会收集很多属性。</li><li id="3a54" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx nk ml mm mn bi translated"><strong class="kc io">元数据</strong>:元数据</li><li id="5a58" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx nk ml mm mn bi translated"><strong class="kc io">配置</strong>:它保存了我们在这里定义的<code class="fe mb mc md me b">Construct</code>的总体<code class="fe mb mc md me b">kind</code>中定义的任何可行的<code class="fe mb mc md me b">Construct</code>定义对象。现在，我们将把它保留在<code class="fe mb mc md me b">endpoints</code>、<code class="fe mb mc md me b">params</code>、<code class="fe mb mc md me b">resolvers</code>和<code class="fe mb mc md me b">outputs</code>的列表中</li></ol><h2 id="61ee" class="mt kz in bd la mu mv dn le mw mx dp li kl my mz lm kp na nb lq kt nc nd lu ne bi translated">配置部分</h2><p id="8d5f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我们的模板中，配置部分是最需要参数化的元素，这也是大部分验证工作要做的地方。</p><p id="f787" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">endpoint</code>配置:</p><ul class=""><li id="aecd" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">一个<code class="fe mb mc md me b">Endpoint</code>可以是一个<code class="fe mb mc md me b">baseurl</code>或一个<code class="fe mb mc md me b">relativeurl</code>建立在一个引用的 relativeurl 之上</li><li id="703a" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">一个<code class="fe mb mc md me b">baseurl</code>可能包含一个参数，但在我看来，为了保持逻辑的纯粹性并包含对<code class="fe mb mc md me b">relativeurl</code>的参数化，它不应该包含参数</li><li id="9de9" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">在<code class="fe mb mc md me b">relativeurl</code>‘相对’路径属性中使用的每个变量必须映射到链接到<code class="fe mb mc md me b">parameter</code>结构的<code class="fe mb mc md me b">params</code></li><li id="52dd" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">每个<code class="fe mb mc md me b">relativeurl</code>可以输出到一个或多个<code class="fe mb mc md me b">outputs</code>目标，同样像<code class="fe mb mc md me b">params</code>一样，这需要映射到下面定义的实际<code class="fe mb mc md me b">output</code></li></ul><p id="8963" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">params</code>配置:</p><ul class=""><li id="bc69" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">一个<code class="fe mb mc md me b">parameter</code>需要被一个<code class="fe mb mc md me b">resolver</code>解析，该构造采取行动从一个专用的源收集参数项，并将其提供给<code class="fe mb mc md me b">endpoint</code>的执行环境，后者将在其 API 请求中使用它</li><li id="c98b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">它需要定义它所解析的变量<code class="fe mb mc md me b">type</code>,以便在稍后阶段验证输入的预期结构</li></ul><p id="86d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">resolvers</code>配置:</p><ul class=""><li id="a028" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">一个<code class="fe mb mc md me b">resolver</code>标识一个可执行文件(想想无服务器功能),它包含连接、验证和检索特定源类型数据的逻辑。</li><li id="ea30" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">kind</code>标识要使用的源，每种解析器都提供自己类型的参数接口。</li></ul><p id="f638" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">outputs</code>配置:</p><ul class=""><li id="5751" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated"><code class="fe mb mc md me b">kind</code>再次选择合适的存储类型提供者，以便定义多个自变量接口</li><li id="20c2" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">配置的其余部分目前在 WIP 中，将在以后更新。通常，它应该为每种存储类型提供一个配置接口，以配置资源标识符、身份验证和配置参数。</li></ul><p id="885c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">TemplateParser</code>类:</p><p id="f0c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们看看如何利用 JSONSchema 验证框架来卸载我们所有的验证需求。</p><p id="0e3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们创建一个模式文件，首先定义模板模式的所有部分。这将有助于我们在深入细节之前，对预期的结构保持清晰的了解。</p><pre class="ng nh ni nj gt nl me nm bn nn no bi"><span id="973f" class="np kz in me b be nq nr l ns nt">"""<br/>Defines the JSONSchema object schemata <br/>expected in a given version of the code<br/>"""<br/><br/>TemplateSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "version": {"type": "string"},<br/>        "kind": {"type": "string"},<br/>        "metadata": {"type": "object"},<br/>        "config": {"type": "object"},<br/>    },<br/>    "required": ["version", "kind", "config"]<br/>}</span></pre><p id="a154" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们跟进每个属性字典的细节，以防我们想要扩展只包含单个构造的模板文件的编译。我们可以定义<code class="fe mb mc md me b">params</code>、<code class="fe mb mc md me b">endpoint</code>和<code class="fe mb mc md me b">resolver</code>的细节，因为我们进一步细化了框架，它的大小需要进一步细分，因为我们从 K8s 中知道它。现在，重点在于组件交互的结构和架构，我们不需要担心这些细节。</p><p id="5404" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，配置的实现只针对模板和元数据模式 ATM 进行扩展。</p><pre class="ng nh ni nj gt nl me nm bn nn no bi"><span id="18a3" class="np kz in me b be nq nr l ns nt"><br/><br/>MetadataSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "name": {"type": "string"},<br/>    },<br/>}<br/><br/>ConfigSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "endpoints": {<br/>            "type": "array",<br/>            "items": {<br/>                "type": "object",<br/>                "properties":{<br/>                    "kind" : {"type": "string"},<br/>                    "url" : {"type": "string"},<br/>                    "base" : {"type": "string"},<br/>                    "relative": {"type": "string"},<br/>                    "params": {<br/>                        "type": "array",<br/>                        "items": {<br/>                            "type": "object",<br/>                            "properties": {<br/>                                "name" : {"type": "string"}<br/>                            }<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>            },<br/>        "params": {"type": "object"},<br/>        "resolvers": {"type": "object"},<br/>    },<br/>    "required": ["endpoints", "params", "resolvers"]<br/>}<br/><br/># <br/>ParamsSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "name" : {"type": "object"},<br/>        "name" : {"type": "string"},<br/>        "name" : {"type": "string"},<br/>        "name" : {"type": "string"},<br/>    },<br/>}<br/><br/>#TODO: Define schema<br/>EndpointSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "name" : {"type": "string"},<br/>    },<br/>}<br/><br/>#TODO: Define schema<br/>ResolverSchema = {<br/>    "type": "object",<br/>    "properties": {<br/>        "name" : {"type": "string"},<br/>    },<br/>}<br/><br/></span></pre><p id="eab5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">switch-dict 将这一切联系起来，因此我们可以选择在 TemplateParser 类中验证哪个模板。</p><pre class="ng nh ni nj gt nl me nm bn nn no bi"><span id="1f7b" class="np kz in me b be nq nr l ns nt"># Mapping dictionary to facilitate resolution of schema to keys<br/>schema_mapping = {<br/>    'template': TemplateSchema,<br/>    'metadata': MetadataSchema,<br/>    'config': ConfigSchema,<br/>    'endpoints': EndpointSchema,<br/>    'params': ParamsSchema,<br/>    'resolvers': ResolverSchema<br/>}</span></pre><p id="0b1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑到我们可以将所有繁重的工作转移到 JSONSchema 验证器上，我们的类只是一个瘦逻辑接口，支持 YAML 解析，并使用 jsonschema python 绑定进行验证。</p><pre class="ng nh ni nj gt nl me nm bn nn no bi"><span id="aae9" class="np kz in me b be nq nr l ns nt">"""<br/>Template Parser<br/><br/>Enables the YAML based declarative definition of resources to be created<br/>and managed by the RestMap framework. <br/><br/>Along the lines of the Kubernetes API, the files can be stored in a local<br/>folder structure and parsed using this class.<br/><br/>It drives the file input, linting, structure parsing, component validation<br/>and class conversion of the read attributes into schema elements to be exported<br/>further for scheduling.<br/>"""<br/><br/>from pathlib import Path<br/>from typing import Union, List, Dict<br/><br/>from dataclasses import dataclass, field<br/>import jsonschema<br/>from utils import io as ioutils<br/>from enums import StatusCode<br/><br/>@dataclass<br/>class MetadataDict:<br/>    name: str = ''<br/>    tags: list[str] = field(default_factory=list)<br/><br/>@dataclass <br/>class ConfigurationDict:<br/>    endpoints: dict<br/>    params: dict <br/>    resolvers: dict<br/>@dataclass<br/>class TemplateSchema:<br/>    """<br/>    Defines the base class for the component schema classes<br/>    """<br/>    version: str<br/>    kind: str<br/>    metadata: MetadataDict<br/>    config: ConfigurationDict<br/><br/>class TemplateParser:<br/>    """<br/>    Implements the parser interface<br/>    """<br/><br/>    def __init__(self) -&gt; None:<br/>        pass       <br/>    <br/>    # PUBLIC API______________<br/>    def load(self, path: Union[str, Path]) -&gt; TemplateSchema:<br/>        """<br/>        Attempts to verify and load a Template from a given file location.<br/>        """<br/>        path = ioutils.ensure_path(path)<br/>        try:<br/>            template_dict = self._read_template_file(path)<br/>            # Validate required components are defined. Raises if it fails<br/>            self._validate(template_dict)<br/>            # Load all components and lint component schemata<br/>            template: TemplateSchema = self._parse(template_dict)<br/>            return template<br/>        except FileNotFoundError:<br/>            raise FileNotFoundError("The file provided does not exist")<br/><br/>    # INTERNAL API_______________-<br/>    def _read_template_file(self, path: Path):<br/>        """<br/>        Reads the given file, ensures it is valid yaml and loads it<br/>        """<br/>        import yaml<br/>        file = path.read_text()<br/>        template_dict = yaml.safe_load(file)<br/>        return template_dict<br/>        <br/>   </span></pre><p id="f455" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">验证逻辑归结为对 jsonschema.validate 的简单调用，模板的每个部分都根据其定义的 jsonschema 副本进行验证。就这么简单。这是一个省时的方法，我们刚刚抓住了这个漂亮的验证框架的源头。</p><p id="a1d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这对你来说是新的，一定要试试用<a class="ae jz" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSONSchema </a>可以实现的强大表达能力。在早期的项目中，我设计了一个模式验证框架，该框架可以自动从物联网传感器数据样本中提取超过 4k 列的模式，并将其转换为 JSONSchema 表示，以半自动地设置验证要求，并根据这些要求验证新的传入物联网流。它简单明了，易于使用。爱死了！</p><pre class="ng nh ni nj gt nl me nm bn nn no bi"><span id="22b2" class="np kz in me b be nq nr l ns nt">def _validate(self, template_dict: dict) -&gt; bool:<br/>        """<br/>        Ensure the file template confirms with expected<br/>        file schema<br/>        @template_string: Parsed dict from yaml input<br/>        """<br/>        from restmap.templateParser.schemata import schema_mapping<br/>        # Validate overall schema first<br/>        try:<br/>            jsonschema.validate(template_dict, schema_mapping['template'])<br/>            for key, values in template_dict.items():<br/>                if key in schema_mapping:<br/>                    jsonschema.validate(values, schema_mapping[key])<br/>        except jsonschema.ValidationError as e:<br/>            raise e<br/>        return True<br/><br/>    def _parse(self, template_dict: dict ) -&gt; TemplateSchema:<br/>        """<br/>        Parse a yaml template string into a TemplateSchema instance<br/>        <br/>        Does currently hardcode the structure of the expected template<br/>        schema. <br/>        """<br/>        metadata_dict = MetadataDict(template_dict['metadata'])<br/>        config_dict = ConfigurationDict(**template_dict['config'])<br/>        template_dict['metadata'] = metadata_dict<br/>        template_dict['config'] = config_dict<br/>        return TemplateSchema(<br/>            **template_dict<br/>        )</span></pre><p id="d0a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总的来说，我们从最少的代码中获得了用例的大量功能，并且拥有了一个可以随着模板中配置需求的增长而扩展的结构。</p><h1 id="76ea" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一个</h1><p id="abdd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">今天，我们看了一个模板解析和验证逻辑的解决方案，以一种简单但强大的 YAML 格式驱动我们的配置界面，我们都已经习惯了 K8s。</p><p id="7a2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一篇文章中，我们将研究如何实现<code class="fe mb mc md me b">Resolver</code>,它将接受我们的配置，并确保我们的定义中跨结构的依赖性实际上可以得到正确的解决。这不仅意味着每个链接的构造在模板中实际上有一个适当的配置块，而且还意味着在<code class="fe mb mc md me b">endpoints</code>和<code class="fe mb mc md me b">resolver</code>中使用的参数的解析可以一直解析回一组独立的基本函数，这些基本函数没有上游依赖性。最后，我们的构造必须被定义为 DAG(没有循环依赖的图)，否则我们将找不到解决方案。</p><p id="72c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将实现一个简单的<code class="fe mb mc md me b">ResolutionGraph</code>作为树结构，并用一个类来表示模板中的每个构造，以在树的最终遍历过程中对每个组件实现一个 resolve 方法。</p><p id="27ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望共享元素被表示为指向<code class="fe mb mc md me b">ResolutionGraph</code>中公共节点的指针，这样我们可以进一步将它们的依赖关系编码到基础设施中，最终能够真正<code class="fe mb mc md me b">resolve</code>我们的配置中引用的参数。</p><p id="be53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想直接进入当前 PoC 的混乱状态，请访问:</p><p id="a058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/data-native/ingestless/restmap" rel="noopener ugc nofollow" target="_blank">https://github.com/data-native/ingestless</a></p><p id="6c5f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个爱好项目，如果你喜欢这个想法，你可以通过评论、鼓掌和在 GitHub 项目上提出问题来支持它。</p></div></div>    
</body>
</html>