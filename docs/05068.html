<html>
<head>
<title>Event Driven Microservices with Spring Cloud Stream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Spring云流的事件驱动微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/event-driven-microservices-with-spring-cloud-stream-e034eee3f394?source=collection_archive---------0-----------------------#2021-06-11">https://blog.devgenius.io/event-driven-microservices-with-spring-cloud-stream-e034eee3f394?source=collection_archive---------0-----------------------#2021-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e692" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Spring Cloud Stream和Apache Kafka消息代理发布和使用消息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3f82432d1d22a49f480f8bca853ffcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-oZdRYkOId_JSIAj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">弗朗兹·卡夫卡的雕像，照片由桑德罗·冈萨雷斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2373" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ea72" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事件驱动架构需要深谋远虑，创建脚手架以集成流行的事件流平台可能会变得复杂。Spring Cloud Stream是一个消息驱动的微服务应用框架，它为各种消息代理、RabbitMQ、Apache Kafka、Kafka Streams、Amazon Kinesis等提供绑定器实现。该框架可以简化事情，并允许我们轻松地为不同的平台构建消息发布和消费，方法是避开所选平台的特定实现细节，并使用已经熟悉的Spring习惯用法和Spring接口。</p><p id="ee8e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这篇文章中，我们将使用Apache Kafka消息代理。</p><blockquote class="mp mq mr"><p id="7639" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">杰伊·克雷普斯(Jay Kreps)选择以作者弗朗兹<strong class="lq ir">卡夫卡</strong>的名字给软件命名，因为它是“一个为写作而优化的系统”，他喜欢<strong class="lq ir">卡夫卡的</strong>作品。<br/>来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Apache_Kafka#:~:text=Kafka%20was%20originally%20developed%20by,and%20he%20liked%20Kafka's%20work." rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="29bc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我的上一篇文章中，我们使用Spring应用程序事件在每次客户预订时触发电子邮件发送。</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/automate-emails-using-spring-application-events-apache-freemarker-eeccf0c56b75"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用Spring应用程序事件和Apache FreeMarker自动化电子邮件</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用FreeMarker模板引擎发送包含动态HTML内容的电子邮件</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">blog.devgenius.io</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div><p id="1359" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们将在此基础上构建，以了解Spring云流架构。我们将把该应用程序分成两个通过消息进行通信的微服务。我们将创建用户服务，这将处理用户管理和通知服务，将负责发送不同的通知，在这种情况下，电子邮件。</p><p id="3e30" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用户服务将成为消息生产者(发布者)，它将在每次创建新用户帐户时向Kafka主题发布消息。通知服务将成为消息使用者，它将使用消息队列中的消息并对这些消息做出反应，而无需由用户服务显式调用。<br/>通过使用消息通信，我们还可以添加新功能，通过让用户监听消息队列中的消息来对用户服务的变化做出反应，并允许我们的服务进行扩展。</p><h1 id="807d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">属国</h1><p id="098c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Spring Cloud Stream应用程序具有一个中间件中立的核心，并通过<em class="ms">绑定</em>在由外部代理公开的目的地之间进行通信。建立绑定所需的代理特定细节由<em class="ms">绑定器</em>实现处理。将卡夫卡绑定器实现添加到User服务和Notification服务中的<code class="fe no np nq nr b">gradle.build</code>或<code class="fe no np nq nr b">pom.xml</code>文件以及其他需要的依赖项中。</p><pre class="kg kh ki kj gt ns nr nt nu aw nv bi"><span id="8260" class="nw kx iq nr b gy nx ny l nz oa">dependencies <strong class="nr ir">{<br/>  ...</strong><br/>   implementation 'org.springframework.cloud:spring-cloud-stream'<br/>   implementation 'org.springframework.cloud:spring-cloud-stream-binder-kafka'<br/>  ...<br/><strong class="nr ir">}</strong></span></pre><h1 id="7aea" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">通知业务</h1><p id="f384" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于Notification服务将使用由User服务发布的消息，让我们创建一个<code class="fe no np nq nr b">Consumer</code> bean。Consumer表示接受单个输入参数的操作。在这种情况下<code class="fe no np nq nr b">UserDto</code>将持有关于注册用户的信息，比如他的名字和电子邮件地址。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="47ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">绑定是源和目标之间的桥梁，在函数式编程模型中，绑定名称默认为:</p><ul class=""><li id="ece0" class="od oe iq lq b lr mk lu ml lx of mb og mf oh mj oi oj ok ol bi translated">投入— <code class="fe no np nq nr b">&lt;functionName&gt; + -in- + &lt;index&gt;</code></li><li id="846d" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">产出— <code class="fe no np nq nr b">&lt;functionName&gt; + -out- + &lt;index&gt;</code></li></ul><p id="70a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ms">其中</em> <code class="fe no np nq nr b"><em class="ms">in</em></code>和<em class="ms">以及</em> <code class="fe no np nq nr b"><em class="ms">out</em></code>分别对应T21的绑定类型、输入或输出。</p><p id="a58d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了提高可读性，我们可以通过使用以下属性将<em class="ms">隐式绑定名称</em>映射到<em class="ms">显式绑定名称</em>，为绑定提供更具描述性的名称:</p><pre class="kg kh ki kj gt ns nr nt nu aw nv bi"><span id="6b5c" class="nw kx iq nr b gy nx ny l nz oa">spring.cloud.stream.bindings.eventConsumer-in-0.destination= notification-events</span></pre><h1 id="1fd4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用户服务程序</h1><p id="62b9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于这是一个按需事件，我们需要注入一个<code class="fe no np nq nr b">StreamBridge</code> bean，它将允许我们将数据发送到一个输出绑定，从而在非流应用程序和Spring Cloud Stream之间创建一个桥梁。为了触发源绑定的创建，我们使用<code class="fe no np nq nr b">spring.cloud.stream.source=supplier</code>属性，其中我们声明了源的名称。然后，我们使用<code class="fe no np nq nr b">spring.cloud.stream.bindings.supplier-out-0.destination=notification-events</code>属性为其提供与Notification服务中相同的显式名称。对于<code class="fe no np nq nr b">streamBridge.send()</code>方法，我们传递一个POJO，它将经过相同的例程，就好像它来自于Function或Supplier一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="3ffc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">码头工人</h1><p id="79d3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了运行它，你需要安装卡夫卡和Zookeeper，我使用Docker来运行卡夫卡和Zookeeper以及其他的微服务。下面是一段<code class="fe no np nq nr b">docker-compose.yml</code>片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="eabf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用微服务<code class="fe no np nq nr b">application.proeprties</code>中的<code class="fe no np nq nr b">spring.cloud.stream.kafka.binder.brokers=kafka</code>属性提供Kafka binder所连接的代理列表。默认是<code class="fe no np nq nr b">localhost</code>。如果你运行Kafka的端口不是默认的<code class="fe no np nq nr b">9092</code>，你可以使用<code class="fe no np nq nr b">spring.cloud.stream.kafka.binder.defaultBrokerPort</code>属性。</p><p id="01fd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">设置好一切后，我们现在可以向用户服务发送请求了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/02290accdef2b816f6f86dd399b02d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*2D-RCpqt_kUNYQh09H1QZA.png"/></div></div></figure><p id="214a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以在通知服务的日志中看到它收到了消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/4718acb78110e08e9dc27887b3bef21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSXXoY1Yz4XLTdO7X266ww.png"/></div></div></figure><p id="34f8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">电子邮件成功到达</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/79bc46159f89cd6425586057c77baed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fP-hc7iyL9Vk-bxvNr8FNg.png"/></div></div></figure><p id="b743" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ms">注意，Spring Cloud Stream使用Spring Retry库，每当消息处理过程中出现异常时，框架都会多次尝试重试相同的消息(默认为3次)。</em></p><h1 id="d210" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最后的话</h1><p id="0cb6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Spring Cloud Stream让处理异步消息变得很容易。它采用函数式编程模型，用Java的函数接口将Kafka生产者、消费者和加工者定义为供应者、消费者和函数。您只需定义一个供应商、消费者或功能Spring Beans，Binder将处理与所选代理的集成，允许您的代码专注于业务逻辑并保持中间件中立。</p><p id="7d17" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">完整演示项目的源代码可在<a class="ae kv" href="https://github.com/Milena92/event-driven-ms" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>