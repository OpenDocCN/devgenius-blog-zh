<html>
<head>
<title>Preact — Shallow Rendering, Pretty Print, and External DOM Mutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Preact —浅渲染、漂亮打印和外部DOM突变</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/preact-shallow-rendering-pretty-print-and-external-dom-mutations-15f396cb28f1?source=collection_archive---------3-----------------------#2021-02-14">https://blog.devgenius.io/preact-shallow-rendering-pretty-print-and-external-dom-mutations-15f396cb28f1?source=collection_archive---------3-----------------------#2021-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/97f934d82cffd3afad38a101cc387fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tpomfVsvAP189N2Y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@techouse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Klemen tuar</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="56b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Preact是一个前端web框架，类似于react。</p><p id="cee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它比React小，也不复杂。</p><p id="ced6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何开始使用Preact进行前端开发。</p><h1 id="33ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浅层渲染</h1><p id="1ea2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只能用浅渲染来浅渲染组件的一个级别。</p><p id="2904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6a9e" class="mn lc iq mj b gy mo mp l mq mr">import { shallowRender } from "preact-render-to-string";<br/>import { h } from "preact";</span><span id="6dcb" class="mn lc iq mj b gy ms mp l mq mr">const Foo = () =&gt; &lt;div&gt;foo&lt;/div&gt;;<br/>const App = (<br/>  &lt;div class="foo"&gt;<br/>    &lt;Foo /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="7ca7" class="mn lc iq mj b gy ms mp l mq mr">console.log(shallowRender(App));</span></pre><p id="5105" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">呈现<code class="fe mt mu mv mj b">App</code>组件而不呈现<code class="fe mt mu mv mj b">Foo</code>组件。</p><p id="f8b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们记录返回的字符串时，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="89fe" class="mn lc iq mj b gy mo mp l mq mr">'&lt;div class="foo"&gt;&lt;Foo&gt;&lt;/Foo&gt;&lt;/div&gt;'</span></pre><p id="3f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><h1 id="7d41" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">漂亮模式</h1><p id="c505" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">pretty</code>选项以更人性化的方式呈现字符串。</p><p id="4b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它，我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa64" class="mn lc iq mj b gy mo mp l mq mr">import { render } from "preact-render-to-string";<br/>import { h } from "preact";</span><span id="2cba" class="mn lc iq mj b gy ms mp l mq mr">const Foo = () =&gt; &lt;div&gt;foo&lt;/div&gt;;<br/>const App = (<br/>  &lt;div class="foo"&gt;<br/>    &lt;Foo /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="b657" class="mn lc iq mj b gy ms mp l mq mr">console.log(render(App, {}, { pretty: true }));</span></pre><p id="20a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="223b" class="mn lc iq mj b gy mo mp l mq mr">&lt;div class="foo"&gt;<br/> &lt;div&gt;foo&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="4f64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><h1 id="c0d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX模式</h1><p id="7e61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们做任何类型的快照测试，JSX渲染模式是有用的。</p><p id="c161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它呈现的输出就好像是用JSX写的一样。</p><p id="cfa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d450" class="mn lc iq mj b gy mo mp l mq mr">import render from "preact-render-to-string/jsx";<br/>import { h } from "preact";</span><span id="ecea" class="mn lc iq mj b gy ms mp l mq mr">const App = &lt;div data-foo={true} /&gt;;</span><span id="4e33" class="mn lc iq mj b gy ms mp l mq mr">console.log(render(App));</span></pre><p id="0f5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1a4a" class="mn lc iq mj b gy mo mp l mq mr">&lt;div data-foo={true}&gt;&lt;/div&gt;</span></pre><p id="37da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><h1 id="233c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">外部DOM突变</h1><p id="81b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在组件中添加外部DOM突变代码。</p><p id="2d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们必须禁用虚拟DOM渲染和区分算法，这样它就不会撤销组件中的任何外部DOM操作。</p><p id="4953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19d1" class="mn lc iq mj b gy mo mp l mq mr">import { Component, render } from "preact";</span><span id="03fc" class="mn lc iq mj b gy ms mp l mq mr">class Example extends Component {<br/>  shouldComponentUpdate() {<br/>    return false;<br/>  }</span><span id="e85e" class="mn lc iq mj b gy ms mp l mq mr">  componentDidMount() {<br/>    let thing = document.createElement("maybe-a-custom-element");<br/>    this.base.appendChild(thing);<br/>  }</span><span id="87fc" class="mn lc iq mj b gy ms mp l mq mr">  componentWillUnmount() {}</span><span id="fe31" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return &lt;div class="example" /&gt;;<br/>  }<br/>}</span><span id="0120" class="mn lc iq mj b gy ms mp l mq mr">const App = () =&gt; &lt;Example /&gt;;</span><span id="3a4a" class="mn lc iq mj b gy ms mp l mq mr">if (typeof window !== "undefined") {<br/>  render(&lt;App /&gt;, document.getElementById("root"));<br/>}</span></pre><p id="af97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回<code class="fe mt mu mv mj b">shouldComponentUpdate</code>中的<code class="fe mt mu mv mj b">false</code>来禁用虚拟DOM差分算法。</p><p id="8565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe mt mu mv mj b">componentDidMount</code>中，我们调用<code class="fe mt mu mv mj b">document.createElement</code>向DOM中添加一个新元素。</p><h1 id="7f19" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8db6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以浅渲染和漂亮地打印字符串中呈现的组件。</p><p id="4112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在Preact组件中直接操作DOM。</p></div></div>    
</body>
</html>