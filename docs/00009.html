<html>
<head>
<title>Learn RxSwift (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 RxSwift(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-rxswift-part-1-d69ed8461e8f?source=collection_archive---------0-----------------------#2018-06-29">https://blog.devgenius.io/learn-rxswift-part-1-d69ed8461e8f?source=collection_archive---------0-----------------------#2018-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/65595261132ab59bfb96982f5dda5ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*if1JnzE0CgFoK59d"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@richtervet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rich Tervet </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5fe7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Rx 在这些日子里蓬勃发展，我认为如果每个开发人员都使用它会更好，所以什么是<strong class="kc io"> RxSwift？</strong></p><h1 id="fcc3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">RxSwift</h1><p id="080d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><strong class="kc io"> Rx </strong> =反应式编程，这是一种与<strong class="kc io">数据流</strong>和<strong class="kc io">变化传播</strong>有关的声明式编程范例，例如，在<em class="mb">命令式</em>编程设置<code class="fe mc md me mf b"><strong class="kc io">a = b+c</strong></code>中，这意味着<code class="fe mc md me mf b"><strong class="kc io">a</strong></code>正在被分配<strong class="kc io"> </strong> <code class="fe mc md me mf b"><strong class="kc io">b+c</strong></code> <strong class="kc io">、</strong>和更高版本的结果，可以改变<code class="fe mc md me mf b"><strong class="kc io">b</strong></code> <strong class="kc io"> </strong>和<code class="fe mc md me mf b"><strong class="kc io">c</strong></code> <strong class="kc io"> </strong>的值，而对该值没有影响 但是在<em class="mb">反应式</em>编程中，每当<code class="fe mc md me mf b"><strong class="kc io">b</strong></code> <strong class="kc io"> </strong>或<code class="fe mc md me mf b"><strong class="kc io">c</strong></code> <strong class="kc io"> </strong>的值改变时，<code class="fe mc md me mf b"><strong class="kc io">a</strong></code> <strong class="kc io"> </strong>的值就会自动更新，而无需程序重新执行语句<code class="fe mc md me mf b"><strong class="kc io">a:=b+c</strong></code> <strong class="kc io"> </strong>来确定<code class="fe mc md me mf b"><strong class="kc io">a</strong></code> <strong class="kc io">的当前赋值。 </strong> <a class="ae jz" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><blockquote class="mg mh mi"><p id="e596" class="ka kb mb kc b kd ke kf kg kh ki kj kk mj km kn ko mk kq kr ks ml ku kv kw kx ig bi translated"><strong class="kc io">react vex</strong>结合了<br/>观察者模式、迭代器模式和函数式编程的最佳理念。</p><p id="db03" class="ka kb mb kc b kd ke kf kg kh ki kj kk mj km kn ko mk kq kr ks ml ku kv kw kx ig bi translated"><strong class="kc io">react vex</strong>不仅仅是一个 API，它是编程的一个理念和突破。它启发了其他一些 API、框架，甚至编程语言。</p></blockquote><h1 id="ff81" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可观察量</h1><p id="dff8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在 ReactiveX 中，一个观察者订阅一个可观察的。然后，观察者对可观察物发出的任何项目或项目序列做出反应。这种模式有助于并发操作，因为它不需要在等待可观察对象发射对象时阻塞，而是以观察器的形式创建一个岗哨，随时准备在可观察对象发射对象时做出适当的反应。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/1c3eef1e85b00692536a5b0dbd54c152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9HjN7iA7k6QQm_l7MaP9w.png"/></div></div></figure><p id="5372" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 ReactiveX 中，许多指令可以并行执行，它们的结果稍后被捕获，你定义一种机制来检索和转换数据，以“可观察”的形式，然后<em class="mb">为它订阅</em>一个观察者，在这一点上，先前定义的机制启动，观察者站岗捕捉并响应它的发射，只要它们准备好。</p><p id="5b80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的一个优点是，当您有一堆互不依赖的任务时，您可以同时开始它们，而不是等到每个任务完成后再开始下一个任务，这样，您的整个任务包只需要完成该任务包中最长的任务。</p><h2 id="847d" class="mr kz in bd la ms mt dn le mu mv dp li kl mw mx lm kp my mz lq kt na nb lu nc bi translated">热点观察</h2><p id="0d0f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">一创建就发射物品，因此任何后来订阅该可观察物的观察者可以在中间的某个地方开始观察该序列。</p><h2 id="f128" class="mr kz in bd la ms mt dn le mu mv dp li kl mw mx lm kp my mz lq kt na nb lu nc bi translated">冷观察</h2><p id="33a5" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">一直等到观察者订阅了它，它才开始发射物品，因此这样的观察者可以保证从头看到整个序列。</p><h1 id="dcfd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">但是我们为什么要用 RxSwift 呢？！</h1><p id="715f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">RxSwift 非常强大，节省了大量开发人员的时间和精力，可用于:</p><p id="291e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1-绑定</strong></p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="bcef" class="mr kz in mf b gy nh ni l nj nk">Observable.combineLatest(firstName.rx.text, lastName.rx.text) { $0 + " " + $1 }<br/>    .map { "Greetings, \($0)" }<br/>    .bind(to: greetingLabel.rx.text)</span></pre><p id="2fba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2 位代表</strong></p><p id="92eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而不是做那些乏味的、没有表达力的事情:</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="e393" class="mr kz in mf b gy nh ni l nj nk">public func scrollViewDidScroll(scrollView: UIScrollView) { [weak self]<br/>    self?.leftPositionConstraint.constant = scrollView.contentOffset.x<br/>}</span></pre><p id="a010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…写</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="07e1" class="mr kz in mf b gy nh ni l nj nk">self.resultsTableView<br/>    .rx.contentOffset<br/>    .map { $0.x }<br/>    .bind(to: self.leftPositionConstraint.rx.constant)</span></pre><p id="02d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3- KVO </strong></p><p id="8ba2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而不是:</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="3b18" class="mr kz in mf b gy nh ni l nj nk">-(void)observeValueForKeyPath:(NSString *)keyPath<br/>                     ofObject:(id)object<br/>                       change:(NSDictionary *)change<br/>                      context:(void *)context</span></pre><p id="35f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mc md me mf b">rx.observe</code>和<code class="fe mc md me mf b">rx.observeWeakly</code></p><p id="5749" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是它们的使用方法:</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="d147" class="mr kz in mf b gy nh ni l nj nk">view.rx.observe(CGRect.self, "frame")<br/>    .subscribe(onNext: { frame in<br/>        print("Got new frame \(frame)")<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="6c87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="7785" class="mr kz in mf b gy nh ni l nj nk">someSuspiciousViewController<br/>    .rx.observeWeakly(Bool.self, "behavingOk")<br/>    .subscribe(onNext: { behavingOk in<br/>        print("Cats can purr? \(behavingOk)")<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="b8d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4-通知</strong></p><p id="bacc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不使用:</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="d578" class="mr kz in mf b gy nh ni l nj nk">@available(iOS 4.0, *)<br/>public func addObserverForName(name: String?, object obj: AnyObject?, queue: NSOperationQueue?, usingBlock block: (NSNotification) -&gt; Void) -&gt; NSObjectProtocol</span></pre><p id="2182" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…只是写</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="0d2b" class="mr kz in mf b gy nh ni l nj nk">NotificationCenter.default<br/>.rx.notification(NSNotification.Name.UITextViewTextDidBeginEditing, object: myTextView)<br/>    .map {  /*do something with data*/ }</span></pre><p id="895a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 5-异步自动完成搜索框</strong></p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="4674" class="mr kz in mf b gy nh ni l nj nk">searchTextField.rx.text<br/>    .throttle(0.3, scheduler: MainScheduler.instance)<br/>    .distinctUntilChanged()<br/>    .flatMapLatest { query in<br/>        API.getSearchResults(query)<br/>            .retry(3)<br/>            .startWith([]) // clears results on new search term<br/>            .catchErrorJustReturn([])<br/>    }<br/>    .subscribe(onNext: { results in<br/>      // bind to ui<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="957e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">6-成分处理</strong></p><p id="2536" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你需要在单元格中下载图像时，当单元格可见时，会发送下载图像的请求，所以如果用户快速滑动，可能会有很多请求被触发和取消。如果我们可以限制并发图像操作的数量，那就更好了，RxSwift 可以轻松处理这一点。</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="5a49" class="mr kz in mf b gy nh ni l nj nk">let imageSubscription = imageURLs<br/>    .throttle(0.2, scheduler: MainScheduler.instance)<br/>    .flatMapLatest { imageURL in<br/>        API.fetchImage(imageURL)<br/>    }<br/>    .observeOn(operationScheduler)<br/>    .map { imageData in<br/>        return decodeAndBlurImage(imageData)<br/>    }<br/>    .observeOn(MainScheduler.instance)<br/>    .subscribe(onNext: { blurredImage in<br/>        imageView.image = blurredImage<br/>    })<br/>    .disposed(by: reuseDisposeBag)</span></pre><p id="b05a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 7-聚合网络请求</strong></p><p id="bd09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您需要触发两个请求并在它们都完成后聚合结果时，RxSwift 可以出色地处理这一点</p><pre class="mn mo mp mq gt nd mf ne nf aw ng bi"><span id="feab" class="mr kz in mf b gy nh ni l nj nk">let userRequest: Observable&lt;User&gt; = API.getUser("me")<br/>let friendsRequest: Observable&lt;[Friend]&gt; = API.getFriends("me")<br/><br/>Observable.zip(userRequest, friendsRequest) { user, friends in<br/>    return (user, friends)<br/>}<br/>.subscribe(onNext: { user, friends in<br/>    // bind them to the user interface<br/>})<br/>.disposed(by: disposeBag)</span></pre><p id="0a8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 8-MVVM -单向数据流</strong></p><p id="92f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 9-轻松整合</strong></p><h1 id="6e67" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">利益</h1><ul class=""><li id="b744" class="nl nm in kc b kd lw kh lx kl nn kp no kt np kx nq nr ns nt bi translated">可组合的——因为 Rx 是组合的昵称</li><li id="f43f" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated">可重复使用——因为它是可组合的</li><li id="ec66" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated"><strong class="kc io">声明性的</strong>——因为定义是不可变的，只有数据会改变</li><li id="173f" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated"><strong class="kc io">可理解和简洁</strong>——提高抽象层次，消除瞬态</li><li id="43eb" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated"><strong class="kc io">稳定</strong> -因为 Rx 代码经过了彻底的单元测试</li><li id="d3ea" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated"><strong class="kc io">状态更少</strong>——因为您将应用程序建模为单向数据流</li><li id="a833" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated"><strong class="kc io">无泄漏</strong> -因为资源管理很容易</li></ul><p id="8b67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们讨论了什么是 RxSwift，它如何依赖于 Observer 设计模式，为什么我们应该使用它，以及它如何节省大量时间。<br/>如何创建 RxSwift 观察值<a class="ae jz" href="https://medium.com/@deda9/learn-rxswift-part2-3d99583417bf" rel="noopener">(第二部分)</a></p><p id="b338" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a></p><p id="b382" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">无功编程</a></p><p id="a1f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a></p></div></div>    
</body>
</html>