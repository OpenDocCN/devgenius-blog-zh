<html>
<head>
<title>Kotlin Programming Langauge The Complete Learning Guide [2022] 6/6 Advanced Fundamentls in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林编程语言完全学习指南[2022] 6/6 科特林高级基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-programming-langauge-the-complete-learning-guide-2022-6-6-advanced-fundamentls-in-kotlin-e20b511e2fff?source=collection_archive---------11-----------------------#2022-12-04">https://blog.devgenius.io/kotlin-programming-langauge-the-complete-learning-guide-2022-6-6-advanced-fundamentls-in-kotlin-e20b511e2fff?source=collection_archive---------11-----------------------#2022-12-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2b6224e98c323e1a7a65216cd1b0dfd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZpK5ANDkCnEBIvdMmsGzw.png"/></div></div></figure><p id="5798" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">学习 Kotlin 这种最强大和最有用的编程语言之一，并准备好开始开发 powerfull 原生移动应用程序和其他平台开发</p><h1 id="ec65" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">目录</h1><blockquote class="lr ls lt"><p id="3330" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">数组</em></p><p id="ec5b" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">列表</em></p><p id="352a" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">设定&amp;地图</em></p><p id="7626" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">数组列表</em></p><p id="860f" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">λ表达式</em></p><p id="e876" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">访问修饰符</em></p><p id="fd42" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">内部&amp;嵌套类</em></p><p id="d87b" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><em class="in">异常处理</em></p></blockquote><h1 id="38a2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数组</h1><p id="d652" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">就像我们之前看到的一样。它是保存数据集合的数据类型，所以让我们创建一个数组</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="50ac" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums : IntArray = intArrayOf (1,2,3,4,5,6,7,8,9,10)<br/>}</span></pre><p id="952a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们知道是科特林，我们可以让这个声明更简单</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="df8d" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = intArrayOf (1,2,3,4,5,6,7,8,9,10)<br/>}</span></pre><p id="88ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，编译器知道它是一个整数数组，否则我们也可以像下面这样做</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="e978" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>}</span></pre><p id="08ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的都是一样的，但是我们让它变得更简单</p><blockquote class="lr ls lt"><p id="3da9" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意:数组数据类型是数组第一个元素的引用，引用是变量在内存中的位置，所以数组保存它的元素的第一个元素的引用，让我们看看</p></blockquote><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="d124" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>    println(nums)<br/>}//output <br/>//[Ljava.lang.Integer;@8efb846</span></pre><p id="38cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">产量是多少？这就是我们所说的，它打印的是数组第一个元素的位置，而不是。值，还记得我们在 oop 部分讨论类时，让我们创建一个类，并尝试打印它来解释引用</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="30d7" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val ref :ExplainRefrence = ExplainRefrence("Mohab")<br/>    print(ref)<br/>}<br/><br/>class ExplainRefrence (name : String ){<br/>    val name : String<br/>    init {<br/>        this.name=name<br/>    }<br/>}//output ExplainRefrence@7adf9f5f</span></pre><p id="23e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它没有打印人类可读的东西，对吧，这个引用“这个对象在内存中的存储位置”对数组来说也是一样，如果我们想打印一个数组，我们不这样做</p><p id="e3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为它是 kotlin，所以它在数组中有一个名为<strong class="jx io"><em class="lu">content tostring</em>()</strong>的方法，该方法将打印数组的内容</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="4d2d" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>    println(nums.contentToString())<br/><br/>}// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><p id="4bb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们尝试使用我们之前看到的 for 循环来逐项打印</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="7093" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>for (i in nums ){<br/>    println(i)<br/>}<br/>}//1<br/>//2<br/>//3<br/>//4<br/>//5<br/>//6<br/>//7<br/>//8<br/>//9<br/>//10</span></pre><blockquote class="lr ls lt"><p id="3107" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:数组中第一个元素从<strong class="jx io"> 0 </strong>开始，所以<strong class="jx io"> (1) </strong>索引是<strong class="jx io"> 0 </strong>而不是<strong class="jx io"> (1) </strong>计算机从 0 开始计数，请看下面的例子</p></blockquote><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="4a29" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>println(nums[0])<br/>}//output <br/>//1</span></pre><p id="7419" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以重新分配这些值，如下所示</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="59c9" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/>    println(nums[5])<br/>    nums [5]= 100<br/>    println(nums[5])<br/>}</span></pre><p id="bd4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一定要确保传递[]中的现有索引，不要像下面这样做</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="0c38" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val  nums  = arrayOf (1,2,3,4,5,6,7,8,9,10)<br/><br/>    println(nums[12])<br/>}</span></pre><p id="4793" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">线程“main”Java . lang . arrayindexoutofboundsexception 中出现异常:MainKt.main(Main.kt:4)处长度为 10 的索引 12 超出界限<br/>mainkt . main(main . kt)处的<br/></strong></p><p id="2be4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实是，这个数组只有 10 个元素，那么我们怎么能打印出一个元素存在于第 12 个元素中，而这个元素是不存在的呢</p><p id="5c99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一些在数组内部存储的例子</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="4993" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val  nums  = arrayOf (1,2,3,4,5,6,7,8,9,false )<br/>val strgns = arrayOf("Mohab","Messi","Neymar")<br/>val bools = arrayOf(false , true )<br/>var mixed = arrayOf(false , 123.0,11123,"Mohab" )<br/>}</span></pre><p id="3663" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以创建自己的类型，并将其存储在数组中</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="1d6d" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val type1 =MyOwntype("Mohab")<br/>    val type2 =MyOwntype(false )<br/>    val type3 =MyOwntype(122 )<br/>val myArray = arrayOf(type1,type2,type3)<br/><br/>    print(myArray[0].toString())<br/>}<br/><br/>data class MyOwntype (val anyType : Any )<br/><br/>//output MyOwntype(anyType=Mohab)</span></pre><h1 id="eb34" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">列表</h1><p id="8511" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">也存储一种类型或多种类型</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="ab32" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = listOf("Messi","Neymar","Ronaldo")<br/>    print(players[0])<br/>}//Messi</span></pre><p id="8da4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以在上面循环</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="f286" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = listOf("Messi","Neymar","Ronaldo")<br/>    for (player in players){<br/>        println(player)<br/>    }<br/>}//<br/>//Messi<br/>//Neymar<br/>//Ronaldo</span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="50d5" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = listOf("Messi","Neymar","Ronaldo")<br/>players.forEach( ){<br/>    println(it)<br/>}<br/>}//Messi<br/>//Neymar<br/>//Ronaldo</span></pre><p id="b7e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">它</strong> →引用列表里面的元素它喜欢的<strong class="jx io">玩家【n】</strong></p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="d8b1" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = listOf("Messi","Neymar","Ronaldo")<br/>println(players.size)<br/>}//3</span></pre><p id="0e9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在这个列表是不可变的，我们不能向它添加元素</p><p id="4ffe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们可以把它转换成不可变的</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="c920" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = listOf("Messi","Neymar","Ronaldo")<br/> val mutablePlayers =    players.toMutableList()<br/><br/>    mutablePlayers.add("Mohab")<br/>    println(mutablePlayers[3])<br/>}//Mohab</span></pre><p id="ac55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以创建一个类似下面的列表</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="eaee" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = mutableListOf&lt;String &gt;("Messi","Neymar","Ronaldo")<br/>    players.add("hakimi")<br/><br/>}</span></pre><p id="beca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是泛型，它告诉编译器，这是一个只有字符串的可变列表，是可选的</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="217e" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = mutableListOf("Messi","Neymar","Ronaldo")<br/>    players.add("hakimi")<br/>}</span></pre><p id="c6fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在编译器也知道这是一个字符串的可变列表，泛型在下一个例子中很有用</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="234e" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = mutableListOf&lt;Any&gt;("Messi","Neymar","Ronaldo")<br/>    players.add(111.213)<br/>}</span></pre><p id="d1e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们把它做成一个<any>的列表，这样我们就可以存储任何类型，让我们看看如何让列表变空或者移除元素</any></p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="9d0a" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val players = mutableListOf&lt;Any&gt;("Messi","Neymar","Ronaldo")<br/>println(players)<br/>    players.remove("Messi")<br/>    println(players)<br/>players.removeAt(1)<br/>println(players)<br/>players.removeAll(players)<br/> println(players)<br/>}// output <br/>//[Messi, Neymar, Ronaldo]<br/>//[Neymar, Ronaldo]<br/>//[Neymar]<br/>//[]</span></pre><h1 id="3442" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设置</h1><p id="f4bd" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">移除重复元素的集合类型，不是排序集合，也有可变和不可变类，<strong class="jx io"> mutableSetOf() setOf() </strong></p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="ecfc" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val players = setOf ("Messi","Messi","Messi","Ronaldo")<br/>    println(players.size)<br/>}//output <br/>//2</span></pre><p id="ca7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，我们存储了 4 个元素，但实际上它们只有 2 个是唯一的，这就是 set 如何移除重复的元素，<strong class="jx io">“就像在学校学数学”</strong></p><p id="cb9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们试着分类</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="7dab" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val players = setOf ("Ronaldo","Messi","Messi","Messi","Abou Trika")<br/>    println(players.sorted())<br/>}//[Abou Trika, Messi, Ronaldo]</span></pre><p id="441f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它按字母顺序排序，让它可变</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="5782" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val players = setOf ("Ronaldo","Messi","Messi","Messi","Abou Trika")<br/>    println(players.sorted())<br/>    val mutablePlayers = mutableSetOf("Ronaldo","Messi","Messi","Messi","Abou Trika")<br/>    mutablePlayers.add("Ronaldinho")<br/>    mutablePlayers.add("Neymar")<br/>    println(mutablePlayers.sorted())<br/><br/>}//output <br/>//[Abou Trika, Messi, Ronaldo]<br/>//[Abou Trika, Messi, Neymar, Ronaldinho, Ronaldo]</span></pre><h1 id="0195" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">地图</h1><p id="269f" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">也是一种集合类型，以键和值对的形式存储数据，就像每个值都有它的键，以便在内存中存储的映射中找到它</p><p id="49c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个键都是唯一的，不能重复，每个键只能保存一个值</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="15bd" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf(11 to "Neymar",10 to "Messi",22 to "Abou trika")<br/><br/>}</span></pre><p id="95de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们如何声明一个地图，我们说内马尔(值)有一个 11(键)，但如果我们用相同的键存储两个值会发生什么，如下所示？</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="0f17" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf(11 to "Neymar",10 to "Messi",22 to "Abou trika",11 to "Ronaldo")<br/>    print(playersMap[11])<br/>}// Ronaldo</span></pre><p id="566a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具有重复键的第一个值将被覆盖以存储新值</p><blockquote class="lr ls lt"><p id="9b42" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">下面是如何使用键访问地图中的值</p></blockquote><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="823d" class="mm ku in mi b be mn mo l mp mq">print(playersMap[11]) </span></pre><p id="0f74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以像下面一样访问所有的键或值，</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="c540" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf(11 to "Neymar",10 to "Messi",22 to "Abou trika",11 to "Ronaldo")<br/><br/>    for (key in playersMap.keys){<br/>        println(key)<br/>    }<br/>}// output <br/>//11<br/>//10<br/>//22</span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="9ba2" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf(11 to "Neymar",10 to "Messi",22 to "Abou trika",11 to "Ronaldo")<br/><br/>    for (player in playersMap.values){<br/>        println(player)<br/>    }<br/>}//<br/>//Ronaldo<br/>//Messi<br/>//Abou trika</span></pre><p id="b1a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以访问这两者</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="64d7" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf(11 to "Neymar",10 to "Messi",22 to "Abou trika",11 to "Ronaldo")<br/><br/>    for (key in playersMap.keys){<br/>        println("in your map $key holds ${playersMap[key]}")<br/>    }<br/>}//output <br/>//in your map 11 holds Ronaldo<br/>//in your map 10 holds Messi<br/>//in your map 22 holds Abou trika</span></pre><p id="0d98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">键可以是任何类型的数据，不仅是整型，</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="a5f3" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>val playersMap = mapOf("11" to "Neymar","10" to "Messi","22" to "Abou trika","11" to "Ronaldo")<br/><br/>    for (key in playersMap.keys){<br/>        println("in your map $key holds ${playersMap[key]}")<br/>    }<br/>}//<br/>//in your map 11 holds Ronaldo<br/>//in your map 10 holds Messi<br/>//in your map 22 holds Abou trika</span></pre><p id="7c53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看，我们也把它改成了字符串，让它变得可变</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="2ff0" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/><br/>    val mutablePLayersMap= mutableMapOf("11" to "Neymar","10" to "Messi","22" to "Abou trika","11" to "Ronaldo")<br/>    mutablePLayersMap.putIfAbsent("1","Cassialls")<br/>    print(mutablePLayersMap)<br/>}// <br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Cassialls}</span></pre><p id="819f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">putIfAbsent()如果传递给它的键不存在，它将把它放在映射的内部</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="6369" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/><br/>    val mutablePLayersMap= mutableMapOf("11" to "Neymar","10" to "Messi","22" to "Abou trika","11" to "Ronaldo")<br/>    mutablePLayersMap.putIfAbsent("1","Cassialls")<br/>    println(mutablePLayersMap)<br/>    mutablePLayersMap.putIfAbsent("1","Neuer")<br/>    println(mutablePLayersMap)<br/>}//<br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Cassialls}<br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Cassialls}</span></pre><p id="d95b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一次把它放进去，因为键不存在，但是在它没有放进去之后，让我们看看 put()</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="9fbe" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/><br/>    val mutablePLayersMap= mutableMapOf("11" to "Neymar","10" to "Messi","22" to "Abou trika","11" to "Ronaldo")<br/>    mutablePLayersMap.putIfAbsent("1","Cassialls")<br/>    println(mutablePLayersMap)<br/>    mutablePLayersMap.putIfAbsent("1","Neuer")<br/>    println(mutablePLayersMap)<br/>    mutablePLayersMap.put("1","Neuer")<br/>    println(mutablePLayersMap)<br/><br/>}//output <br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Cassialls}<br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Cassialls}<br/>//{11=Ronaldo, 10=Messi, 22=Abou trika, 1=Neuer}</span></pre><p id="df1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">put 会将它添加到映射中，即使它覆盖了具有相同键的相同值</p><h1 id="f0d6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数组列表</h1><p id="9a34" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">动态分配，意味着它的大小可以增加或减少，我们也可以读和写，也可以添加元素，也可以有重复的元素</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="bc52" class="mm ku in mi b be mn mo l mp mq">val myList = ArrayList&lt;Any&gt;() // empty arrayList </span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="8647" class="mm ku in mi b be mn mo l mp mq">val myList = ArrayList&lt;Any&gt;(100) // array with limted size of 100 elements only </span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="3286" class="mm ku in mi b be mn mo l mp mq">myList.add()//add an element to arrayList</span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="a2e7" class="mm ku in mi b be mn mo l mp mq">myList.clear()// clears the arrayList</span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="5caa" class="mm ku in mi b be mn mo l mp mq">myList.get(0) // get the eleemnt of [n] index</span></pre><pre class="mr mh mi mj bn mk ml bi"><span id="7d68" class="mm ku in mi b be mn mo l mp mq">myList.remove("mohab")// removes eleemtns from arrayList</span></pre><h1 id="3dd3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">λ表达式</h1><p id="14a1" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">允许我们写简短的代码，没有 nam 的函数(不是 anonymus)这个函数没有 delcared，它作为一个表达式传递，函数体写在-&gt;(那个箭头)叫做 lambda 之后</p><p id="a159" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看返回 int 类型值的普通函数</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="3259" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(add(1,2))<br/>    <br/>}<br/>fun add (x : Int , y : Int ):Int {<br/>    return  x+y ;<br/>}<br/>//output <br/>//3</span></pre><p id="35d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">λ函数</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="a1de" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(lambdaAdd(1,2))<br/>    <br/>}<br/>val lambdaAdd: (Int , Int )-&gt;Int = {a:Int , b : Int -&gt;a+b}</span></pre><p id="a54c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以像下面这样重新输入</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="0455" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(shorterLambdaAdd(1,2))<br/>}<br/>val shorterLambdaAdd = {x : Int , y : Int -&gt;x+y }</span></pre><p id="824d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">甚至更短，</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="be7a" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(shorterLambdaAdd)<br/>}<br/>val shorterLambdaAdd = {x : Int , y : Int -&gt; println(x+y ) }</span></pre><h1 id="103a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">访问修饰符(可见性修饰符)</h1><p id="76e1" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">它们用于限制类、类间成员的使用，可用于方法和类</p><p id="ef08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">公共、私有、内部、受保护</p><blockquote class="lr ls lt"><p id="ac1b" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">可以从项目内部的任何地方访问，在 kotlin 中，一切都是公开的，除非我们限制</p><p id="d16f" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io"> private </strong> →只能从声明成员的块中访问，不能在我们所在的作用域之外访问</p><p id="61c8" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">内部</strong> →“不在 java 中”使成员只在实现它的文件或模块内部可见</p></blockquote><p id="5e13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得我们在讨论继承时说过，在 kotlin 中所有的类都是 final 类，所以没有类可以继承，除非我们把它开放</p><blockquote class="lr ls lt"><p id="58e3" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">如果这个类是开放的，那么它可以被继承，protected 使超类只对它的孩子可见</p></blockquote><h1 id="7b57" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">嵌套类和内部类</h1><p id="8260" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在另一个类中创建的类，不管有没有关键字 inner，我知道在它们自己的文件中创建独立的类总是更好，但是如果只是想让一个类使用另一个类，那么创建一个嵌套在外部类中的类会更好</p><p id="c87d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">嵌套类</strong></p><p id="ca78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它是该类的一个<strong class="jx io">静态</strong>，因此外部类成员可以访问它，而无需从</p><p id="21ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内部类不能访问外部类成员</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="15cc" class="mm ku in mi b be mn mo l mp mq">class OuterClass {<br/>    private var name : String ="Mohab"<br/><br/>    class InnerClass (){<br/>var jobTitle : String = "Programmer"<br/>        private var age : Int  = 24<br/>        fun printData (){<br/>            println(" iam $name and i work as a  $jobTitle ")<br/>        }<br/>    }<br/>}// error Unresolved reference: name</span></pre><p id="cf06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该错误是因为内部不能访问外部类成员</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="c237" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(OuterClass.InnerClass().jobTitle)<br/>    OuterClass.InnerClass().printData()<br/>}<br/><br/><br/>class OuterClass {<br/>    private var name : String ="Mohab"<br/><br/>    class InnerClass (){<br/>var jobTitle : String = "Programmer"<br/>        private var age : Int  = 24<br/>        fun printData (){<br/>            println("  i work as a  $jobTitle ")<br/>        }<br/>    }<br/>}</span></pre><p id="5392" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以从内部类创建一个对象</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="4254" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(OuterClass.InnerClass().jobTitle)<br/>    OuterClass.InnerClass().printData()<br/>    var innerObject = OuterClass.InnerClass()<br/>    <br/>}</span></pre><p id="dfec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“内部”键不能创建在接口或非内部类中，但它比嵌套的“它可以访问外部成员”有更大的威力</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="fa72" class="mm ku in mi b be mn mo l mp mq">class OuterClass {<br/>    private var name : String ="Mohab"<br/><br/> inner    class InnerClass (){<br/>var jobTitle : String = "Programmer"<br/>        private var age : Int  = 24<br/>        fun printData (){<br/>            println(" hello iam $name i work as a  $jobTitle ")<br/>        }<br/>    }<br/>}// now it works </span></pre><p id="54f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是现在它不是静态的，所以我们需要从外部获取一个对象来访问内部</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="d928" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>println(OuterClass().InnerClass().jobTitle)<br/>    OuterClass().InnerClass().printData()<br/>    var innerObject = OuterClass().InnerClass()<br/><br/>}</span></pre><h1 id="af17" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异常处理</h1><p id="91e1" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">处理程序运行时可能出现的运行时问题</p><blockquote class="lr ls lt"><p id="cabb" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">异常</strong> →运行时问题导致程序终止，例如一个数字被减 0 或内存耗尽或没有网络…等等</p><p id="ad9d" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">现在 exeption handeling 允许我们处理这个错误，这样计算机或电话就可以继续运行程序而不用终止它</p><p id="d183" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io"> Throwable (throw) </strong> →一个使用关键字(throw)抛出异常(无论是来自 kotlin 还是我们自己类型的异常)的类，也允许我们知道错误发生在哪里</p><p id="ad32" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io"> try{} </strong> →这是一段代码{}，我们在其中添加了可能导致错误的代码，以便编译器尝试在其中执行任何操作</p><p id="0dc0" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io"> catch(e:Exception ){} </strong> →总是出现在 try 块之后，其中的代码只有在 try {}抛出错误时才执行，所以我们告诉计算机，捕捉这个错误，并执行代码来处理它</p><p id="d4e7" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">最后</strong> - &gt;它告诉我们编译器是否处理了异常</p></blockquote><p id="c6cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看异常的例子</p><blockquote class="lr ls lt"><p id="2e7d" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">算术异常→ </strong>当数字减少 0 时</p><p id="d0b8" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">ArrayIndexOutOfBoundExceptions→</strong>当我们调用数组中不存在的索引时</p><p id="23cb" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated"><strong class="jx io">NullPointerException(NPE)</strong>→当我们使用空值时</p></blockquote><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="8c71" class="mm ku in mi b be mn mo l mp mq">try {}catch(e:ArithmeticException){}</span></pre><p id="78b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个例子</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="c761" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val zero : Int = 0<br/>    val no : Int = 10<br/>    println(no/zero)<br/>    println("I Was Called After Dividng is done ")<br/>}</span></pre><p id="3098" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">线程“main”中出现异常 Java . lang . arithmetic Exception:/by zero<br/>at mainkt . main(main . kt:5)<br/>at mainkt . main(main . kt)</strong></p><p id="5323" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看到它甚至没有完成线后，没有打印，但让我们尝试处理它</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="d5c8" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val zero : Int = 0<br/>    val no : Int = 10<br/>try {    println(no/zero)<br/>}catch (e:ArithmeticException){<br/>    println("An Error Occured but it was handled you tried to divide a number by zero")<br/>}<br/>    println("I Was Called After Dividng is done ")<br/>}//output <br/>//An Error Occured but it was handled you tried to divide a number by zero<br/>//I Was Called After Dividng is done</span></pre><p id="78e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们试图做很多可能导致错误的事情，我们也可以有 n 个异常处理</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="35e4" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    val zero : Int = 0<br/>    val no : Int = 10<br/>    val myArray = arrayOf("Mohab")<br/>try {<br/>    println(myArray[1])<br/>    println(no/zero)<br/>}catch (e : ArrayIndexOutOfBoundsException){<br/>    println("An Error Occured but it was handled you tried to call an  index is not exist")<br/><br/>}<br/><br/>catch (e:ArithmeticException){<br/>    println("An Error Occured but it was handled you tried to divide a number by zero")<br/>}<br/>    println("I Was Called After Dividng is done ")<br/>}//output <br/>An Error Occured but it was handled you tried to call an  index is not exist<br/>I Was Called After Dividng is done </span></pre><p id="5903" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看到它停在第一个 catch 块<strong class="jx io">“ArrayIndexOutOfBoundsException”</strong></p><p id="8da3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看一个例子，在 finally 中，什么将被错误地执行，或者没有错误</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="1a66" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>    try {<br/>        println(10 / 5)<br/>    } catch (e: ArithmeticException) {<br/>        println("An Error Occured but it was handled you tried to call an  index is not exist")<br/>    }finally {<br/>        println(" I Will Work anyway ")<br/>    }<br/><br/>}</span></pre><p id="cede" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看投掷</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="ab9f" class="mm ku in mi b be mn mo l mp mq">fun main() {<br/>var myAge : Int = 0<br/>countAge(myAge)<br/>    println("I will be printed  whenever  your func is done ")<br/>}<br/>fun countAge (age : Int ){<br/>    if (age&lt;=0){<br/>        throw CustomException("No one can have negative or zero years")<br/>    }<br/>}<br/>class CustomException(message: String?) : Exception(message) {<br/>}</span></pre><p id="a6e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">线程“main”中的异常客户异常:在 MainKt.countAge(Main.kt:10)的<br/>在 MainKt.main(Main.kt:5)的<br/>在 MainKt.main(Main.kt)的<br/>中，任何人都不能有负数或零年</p><p id="81aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这是 kotlin 编程语言完整指南的最后一部分，等待下一个指南</strong></p><p id="08c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果这篇文章真的对你有帮助，请为我鼓掌</strong></p><p id="aa43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，等待您的评论和回复…</p></div></div>    
</body>
</html>