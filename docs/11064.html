<html>
<head>
<title>Write Better Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写更好的 Dockerfile</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/write-better-dockerfile-f134ce7a5128?source=collection_archive---------1-----------------------#2022-12-16">https://blog.devgenius.io/write-better-dockerfile-f134ce7a5128?source=collection_archive---------1-----------------------#2022-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="affa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">循序渐进和逻辑</p><p id="21d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天我将讨论如何编写一个更安全、构建更快、容量更少并且第一次运行更快的 Dockerfile。</p><p id="6e30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但在这之前，我会一步一步地讨论为什么我们需要它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21b9cdb323bb40084414659a6cb7856a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYeccjueqcfSu139Wj3c6Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">文章封面</figcaption></figure><h1 id="0c20" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么我们需要一个文档？</h1><p id="1b88" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">Docker 是一个容器化工具，它允许我们创建一个包含所有必要依赖项的容器来运行我们的应用程序。</p><h2 id="3f32" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">什么是容器？</h2><p id="7463" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">容器是在主机上运行的虚拟机。它是一个比虚拟机更轻的虚拟机，因为它没有完整的操作系统，只有运行我们的应用程序所必需的依赖项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/2699f56eaa012405ffbd9eb6a96ef810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxGrIZLUsBaWTBWYrxqBfw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">什么是容器？</figcaption></figure><h2 id="7d5b" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">集装箱有什么？</h2><p id="24ec" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">该容器具有运行我们的应用程序所必需的依赖关系。它可以是数据库、web 服务器、编程语言等。</p><p id="7df4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多关于容器:<a class="ae mo" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">什么是容器？</a></p><h1 id="db77" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是 Dockerfile？</h1><p id="a55a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">Dockerfile 是一个文件，它包含构建将用于创建容器的映像的指令。</p><h2 id="218f" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">什么是码头工人形象？</h2><p id="665e" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">图像是一个模板，包含运行我们的应用程序所需的所有依赖项。</p><p id="449c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上它是容器的快照。</p><h1 id="23b2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何写一个基本的 Dockerfile？</h1><p id="924f" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在这一节中，我们将看到如何创建一个简单的 Dockerfile 文件。</p><h2 id="e2ea" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第一步:使用基本图像</h2><p id="e7f5" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们需要做的第一件事是选择一个基础图像。基础图像是将用于创建容器的图像。</p><h2 id="1c90" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第二步:复制文件</h2><p id="1819" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是将文件复制到容器中。将要复制的文件是将用于运行应用程序的文件。</p><h2 id="dc96" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 3:安装依赖项</h2><p id="cfd6" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是安装依赖项。依赖项是将用于运行应用程序的依赖项。</p><h2 id="52aa" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 4:暴露端口</h2><p id="5813" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是暴露端口。端口是将用于运行应用程序的端口。</p><h2 id="630b" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 5:运行应用程序</h2><p id="a973" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是运行应用程序。</p><h2 id="2c98" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">例子</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="5d58" class="mu kz in mq b be mv mw l mx my"># Use a base image<br/>FROM golang:1.19-alpine<br/><br/># Copy the files<br/>COPY . /app<br/><br/># Install the dependencies<br/>RUN go mod download<br/><br/># Expose the port<br/>EXPOSE 8080<br/><br/># Run the application<br/>CMD ["go", "run", "main.go"]</span></pre><h2 id="e069" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">我们在这里做了什么？</h2><p id="f868" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们创建了一个 Dockerfile，它将<code class="fe mz na nb mq b">golang:1.19-alpine</code>映像作为基础映像，复制文件，安装依赖项，暴露端口 8080 并运行应用程序。</p><p id="eb65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，我们在这里创建的应用程序从来都不是生产的首选环境。</p><p id="f746" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这里 golang 是作为运行时运行的。然而，golang 是一种可以为我们提供可执行程序的语言。如果我们生产一个可执行程序，事情会变得更安全更快。</p><h1 id="6cd1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何写一个 Dockerfile 或 Production？</h1><p id="c240" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在这一节中，我们将关注一个比上一节更好的例子。</p><h2 id="97bb" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第一步:使用基本图像</h2><p id="bae9" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们需要做的第一件事是选择一个基础图像。基础图像是将用于创建容器的图像。</p><h2 id="0a3e" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第二步:复制文件</h2><p id="e889" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是将文件复制到容器中。将要复制的文件是将用于运行应用程序的文件。</p><h2 id="2035" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 3:安装依赖项</h2><p id="66e7" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是安装依赖项。依赖项是将用于运行应用程序的依赖项。</p><h2 id="b750" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 4:构建应用程序</h2><p id="d472" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是构建应用程序。</p><h2 id="c6e9" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 5:暴露端口</h2><p id="1eb4" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是暴露端口。端口是将用于运行应用程序的端口。</p><h2 id="8288" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 6:运行应用程序</h2><p id="1e89" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是运行应用程序。</p><h2 id="6e13" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">例子</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="d7b4" class="mu kz in mq b be mv mw l mx my">FROM golang:1.19-alpine<br/><br/># Copy the files<br/>COPY . /app<br/><br/># Install the dependencies<br/>RUN go mod download<br/><br/># Build the application<br/>RUN go build -o main .<br/><br/># Expose the port<br/>EXPOSE 8080<br/><br/># Run the application<br/>CMD ["./main"]</span></pre><h2 id="a8f2" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">我们在这里做了什么？</h2><p id="e41b" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们创建了一个 Dockerfile，它使用<code class="fe mz na nb mq b">golang:1.19-alpine</code>映像作为基础映像，复制文件，安装依赖项，构建应用程序，公开端口 8080 并运行应用程序。</p><p id="66d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上，这种方法在生产中也有人使用。然而，这还不够。</p><p id="ecc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这里我们用 golang 创建了一个可执行文件，当我们的容器运行时，我们执行这个可执行文件。但是 golang 继续与我们的容器共存。此外，随着项目的增长，我们可能不需要在产品中包含各种文件。所以我们有更好的方法。</p><h1 id="ab28" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何写出更好的 Dockerfile？</h1><p id="cccd" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在这一节中，我们将学习如何创建一个 docker 文件来创建一个真正安全、快速和轻量级的 docker 容器。</p><h2 id="ed85" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第一步:使用基本图像</h2><p id="3fae" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们需要做的第一件事是选择一个基础图像。基础图像是将用于创建容器的图像。</p><h2 id="26c3" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 2:使用多阶段构建</h2><p id="8329" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">多阶段构建是一种允许我们创建具有多个阶段的 Dockerfile 文件的技术。每个阶段都是一个 Dockerfile 文件，将用于创建容器。最后一个阶段将用于创建运行应用程序的容器。</p><h2 id="04b0" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 3:使用一个. dockerignore 文件</h2><p id="3b8a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated"><code class="fe mz na nb mq b">.dockerignore</code>文件是一个包含在构建映像时将被忽略的文件和文件夹的文件。</p><h2 id="a5a0" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">例子</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="184e" class="mu kz in mq b be mv mw l mx my"># Use a smaller base image<br/>FROM golang:1.19-alpine AS builder<br/><br/># Copy the files<br/>COPY . /app<br/><br/># Install the dependencies<br/>RUN go mod download<br/><br/># Build the application<br/>RUN go build -o main .<br/><br/># Use a smaller base image<br/>FROM alpine:3.14 AS runner<br/><br/># Copy the files<br/>COPY --from=builder /app/main /app/main<br/><br/># Expose the port<br/>EXPOSE 8080<br/><br/># Run the application<br/>CMD ["./app/main"]</span></pre><h2 id="0da1" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">我们在这里做了什么？</h2><p id="9cbf" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们创建了一个 Dockerfile，它使用<code class="fe mz na nb mq b">golang:1.19-alpine</code>映像作为基础映像，复制文件，安装依赖项，构建应用程序，使用<code class="fe mz na nb mq b">alpine:3.14</code>映像作为基础映像，复制文件，暴露端口 8080 并运行应用程序。</p><h1 id="4b2d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何建立和运行映像？</h1><p id="6004" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在本节中，我们将看到如何使用我们创建的 Docker 文件创建和运行 Docker 映像。</p><h2 id="3e8e" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 1:构建图像</h2><p id="53d8" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们需要做的第一件事是建立形象。该图像是将用于创建容器的图像。</p><h2 id="a3c3" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 2:运行容器</h2><p id="19b9" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是运行容器。容器是将用于运行应用程序的容器。</p><h2 id="2f60" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">例子</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="2e55" class="mu kz in mq b be mv mw l mx my"># Build the image<br/>docker build -t go-docker .<br/><br/># Run the container<br/>docker run -p 8080:8080 go-docker</span></pre><h1 id="9f39" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">怎么分辨是快是轻？</h1><p id="eec8" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在这一节中，我们将学习如何通过 Docker 文件的改变来判断我们是否真的改变了 Docker 中的某些东西。</p><h2 id="50b0" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 1:检查图像的大小</h2><p id="aa12" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们需要做的第一件事是检查图像的大小。图像的大小是将用于创建容器的图像的大小。</p><h2 id="aa2a" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第二步:检查容器的大小</h2><p id="8854" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是检查容器的大小。容器的大小是将用于运行应用程序的容器的大小。</p><h2 id="f694" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 3:检查构建映像所需的时间</h2><p id="c79c" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是检查构建映像所需的时间。构建映像所需的时间就是构建将用于创建容器的映像所需的时间。</p><h2 id="714f" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 4:检查运行容器所需的时间</h2><p id="ba39" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一步是检查运行容器所需的时间。运行容器所需的时间就是运行将用于运行应用程序的容器所需的时间。</p><h2 id="0c13" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">例子</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="ed7c" class="mu kz in mq b be mv mw l mx my"># Check the size of the image<br/>docker images<br/><br/># Check the size of the container<br/>docker ps -s<br/><br/># Check the time it takes to build the image<br/>docker build -t ssibrahimbas.com/fast-dockerfile .<br/><br/># Check the time it takes to run the container<br/>docker run -p 8080:8080 ssibrahimbas.com/fast-dockerfile</span></pre><h1 id="5cf2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我的结果</h1><p id="2ce7" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在本节中</p><h2 id="7baa" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 1:检查图像的大小</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="7d82" class="mu kz in mq b be mv mw l mx my">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE<br/>ssibrahimbas.com/fast-dockerfile    latest    1b1b1b1b1b1b   1 second ago     9.28MB</span></pre><h2 id="dd7f" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">第二步:检查容器的大小</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="a42e" class="mu kz in mq b be mv mw l mx my">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                    NAMES<br/>1b1b1b1b1b1b   ssibrahimbas.com/fast-dockerfile "./app/main"              1 second ago     Up 1 second</span></pre><h2 id="9ff0" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 3:检查构建映像所需的时间</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="dcf9" class="mu kz in mq b be mv mw l mx my">[+] Building 0.5</span></pre><h2 id="66de" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">步骤 4:检查运行容器所需的时间</h2><pre class="kj kk kl km gt mp mq mr bn ms mt bi"><span id="bdc4" class="mu kz in mq b be mv mw l mx my">[+] Building 0.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/f589e8c2eb25bcdbe81dcbc579125a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*in9w8qZk8mrKt9W65wgKUw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我的结果</figcaption></figure><h1 id="2f6d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="4bbc" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在本文中，我们学习了如何为生产编写 Dockerfile，如何编写一个更安全、构建更快、体积更小并且第一次运行速度更快的 Dockerfile，如何构建映像，如何运行容器，以及如何判断它是否快速和轻便。</p></div></div>    
</body>
</html>