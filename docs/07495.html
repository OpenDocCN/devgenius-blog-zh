<html>
<head>
<title>Caching 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/caching-101-634ef4f8ed1b?source=collection_archive---------7-----------------------#2022-03-30">https://blog.devgenius.io/caching-101-634ef4f8ed1b?source=collection_archive---------7-----------------------#2022-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e0d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论<strong class="jm io">云</strong>概念的系列文章的一部分，面向的是入门知识有限的读者。这篇文章属于<em class="ki">中级</em>系列，因为它涉及到构建一般的缓存原则。</p><p id="9eaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云系列中的一些早期博客如下。</p><p id="2f6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/load-balancing-101-8251350c033f"> <strong class="jm io">负载均衡 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/disaster-recovery-on-aws-cloud-building-blocks-e013bffd6244"><strong class="jm io">AWS 云上的灾难恢复</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/disaster-recovery-on-azure-cloud-building-blocks-6ff826adbc8b"><strong class="jm io">Azure 云上的灾难恢复</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/disaster-recovery-on-google-cloud-building-blocks-b2a232a9ec"><strong class="jm io">Google 云上的灾难恢复</strong> </a></p><h1 id="e2c7" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是缓存</h1><p id="5b2f" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">高速缓存是一个过程，通过该过程，通过在称为高速缓存的存储位置(<strong class="jm io"> <em class="ki">【本地/远程】</em> </strong>)存储多个副本来优化对数据<strong class="jm io"> <em class="ki">(文件、图像、脚本等)</em> </strong> <em class="ki"> </em>的读取访问。缓存旨在通过减少数据库服务器上的读取负载来扩展分布式应用程序的需求，从而改善读取 API 延迟。缓存使用<strong class="jm io"> TTL(生存时间)</strong>的概念来保持数据刷新，以防止与主数据库服务器不一致。</p><h1 id="7647" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">缓存是如何工作的</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/fca719954b00e5cd8285b584dea68397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*Tsr6mHxEtcExXtz7Zx__3w.png"/></div></figure><h2 id="ffce" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">顺序流程</h2><ol class=""><li id="08c8" class="mh mi in jm b jn li jr lj jv mj jz mk kd ml kh mm mn mo mp bi translated">应用服务器在缓存中寻找缓存的资产。在<a class="ae kj" href="https://www.techopedia.com/definition/6306/cache-hit#:~:text=A%20cache%20hit%20occurs%20when,is%20considered%20a%20cache%20hit." rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">缓存命中场景</strong> </a>的情况下，数据已经存在于远程缓存中。</li><li id="a346" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">缓存服务器将数据返回给应用服务器，并加载到业务流中。</li><li id="bff5" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">如果数据不是以缓存副本的形式出现，则从数据库服务器获取数据。这被称为<a class="ae kj" href="https://hazelcast.com/glossary/cache-miss/#:~:text=A%20cache%20miss%20is%20an,successfully%20retrieved%20from%20the%20cache." rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">高速缓存未命中场景。</strong>T48】</a></li><li id="81ca" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">数据被更新回缓存服务器，这取决于所选择的整体缓存策略(<a class="ae kj" href="https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Strategies.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">【直写或延迟加载】</em> </strong> </a>)</li></ol><h1 id="6a2a" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为什么高速缓存更快</h1><p id="d1dc" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">就整体易失性而言，高速缓冲存储器的工作方式类似于 RAM 存储器。然而，由于两个主要原因，高速缓冲存储器对于数据访问更快</p><ol class=""><li id="6dfd" class="mh mi in jm b jn jo jr js jv mv jz mw kd mx kh mm mn mo mp bi translated">高速缓存使用<a class="ae kj" href="https://en.wikipedia.org/wiki/Static_random-access_memory" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">静态 RAM </strong> </a>，不像<a class="ae kj" href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">动态 RAM </strong> </a>需要刷新。由于刷新时间得到优化，数据访问变得更快。</li><li id="d3ec" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">除了存储数据，高速缓冲存储器还存储进一步处理所需的指令，使整体操作比存储在 RAM 中更快。</li></ol><h1 id="6633" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">数据库缓存的分类</h1><h2 id="1724" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">服务器位置</h2><p id="bc35" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">缓存的数据既可以存储在本地<strong class="jm io"><em class="ki"/></strong>即与运行的应用程序相同的服务器上，也可以存储在远程服务器 上。</p><h2 id="9eb3" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated"><strong class="ak">本地缓存</strong></h2><p id="f39d" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">缓存的数据存储在与应用服务器相同的计算实例上。本地缓存提供了更好的 SLA，因为网络往返次数减少了，但是在应用服务器重启的情况下，它会丢失数据。</p><h2 id="0a87" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated"><strong class="ak">远程缓存。</strong></h2><p id="7c28" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">缓存的数据存储在远程服务器上，该服务器可以是单个实例，也可以以<a class="ae kj" href="https://en.wikipedia.org/wiki/Master/slave_(technology)" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">主从配置运行。</em> </strong> </a>远程缓存提供了更好的可用性，并且能够抵御数据丢失，但是基于计算-缓存路径中的网络延迟，整体往返速度较慢。</p><h2 id="3232" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">缓存回收策略</h2><p id="fe62" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">根据高速缓存引擎中数据的驱逐/删除，高速缓存可以进一步分为以下类型</p><h2 id="35a9" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">先进先出</h2><p id="35dc" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">在该策略中，首先加载的缓存数据首先被收回。</p><h2 id="39d7" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">最近最少使用</h2><p id="eeb6" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">在此策略中，基于时间戳最近的缓存数据首先被逐出。就缓存未命中情况而言，这优于 FIFO，并且是一种向后看而不是向前看的策略。</p><h2 id="06c9" class="lv kl in bd km lw lx dn kq ly lz dp ku jv ma mb ky jz mc md lc kd me mf lg mg bi translated">最佳方法</h2><p id="ffd4" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">在该策略中，将来不会用于最大时间戳的数据首先被替换。因为这需要关于数据访问的知识，所以这个策略更加理论化，并且在真实的客户场景中很难实现。</p><h1 id="c0f0" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">摘要</h1><p id="8c72" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">根据缓存更新策略，缓存可以进一步分为<strong class="jm io"> <em class="ki">、直写缓存、延迟加载缓存、回写缓存等</em> </strong>。然而，这个主题需要一个详细的解释，所以我们将在云系列的后续专家博客中讨论这些内容。</p><p id="4be7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论是公共云还是私有云，缓存都是分布式可扩展部署中的重要组成部分。每个云供应商都提供了一系列缓存解决方案，这些解决方案使用了上述模式的组合。其中比较流行的有以下几种——<a class="ae kj" href="https://aws.amazon.com/caching/aws-caching/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">AWS 缓存</strong> </a> <strong class="jm io">，</strong> <a class="ae kj" href="https://azure.microsoft.com/en-in/services/cache/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Azure 缓存</strong> </a> <strong class="jm io">和</strong> <a class="ae kj" href="https://cloud.google.com/memorystore" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> GCP 缓存。</strong>T19】</a></p><p id="6a10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>