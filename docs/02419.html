<html>
<head>
<title>How to Decouple a Legacy System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分离遗留系统</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-decouple-a-legacy-system-b4ea10db2642?source=collection_archive---------1-----------------------#2020-08-03">https://blog.devgenius.io/how-to-decouple-a-legacy-system-b4ea10db2642?source=collection_archive---------1-----------------------#2020-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ff30" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">改进遗留代码的练习</h2></div><p id="264a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有很多文章解释如何做出好的设计以及遵循什么规则。在本笔记中，我们将看到一个如何将 <a class="ae kz" href="https://en.wikipedia.org/wiki/Legacy_system" rel="noopener ugc nofollow" target="_blank"> <em class="ky">传统设计</em> </a> <em class="ky">转化为更好设计的具体例子。</em></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/d170bc993e2bdbac1c4ad85319d19de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOCI5_cUIBum5ixz"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@danieldotfox?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·福克斯</a>在<a class="ae kz" href="https://unsplash.com/s/photos/rust?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ebbf" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">问题是</h1><p id="fa74" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">许多现有系统存在耦合问题。因此，它们的可维护性降低了。改变这种类型的系统会带来巨大的连锁反应。</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/coupling-the-one-and-only-software-design-problem-869e293a9f04" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">耦合:唯一的软件设计问题</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">对我们软件的所有故障进行根本原因分析，会发现一个有多种伪装的单一罪魁祸首。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne lk mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://medium.com/dev-genius/code-smell-16-ripple-effect-c5a2db81f37e" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">代码气味 16 —连锁反应</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">微小的变化会产生意想不到的问题。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne lk mq"/></div></div></a></div><p id="51e3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们假设我们有一个现有的过程。</p><p id="a360" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该系统应用各种算法来推导监督学习模型的<a class="ae kz" href="https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)" rel="noopener ugc nofollow" target="_blank">超参数</a>。</p><p id="2825" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">提出了新的要求:</p><blockquote class="ng nh ni"><p id="07ed" class="kc kd ky ke b kf kg jo kh ki kj jr kk nj km kn ko nk kq kr ks nl ku kv kw kx ig bi translated">能够在生产中实时查看每个策略的性能数据。</p></blockquote><h2 id="0cc3" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">解除系统耦合</h2><p id="5682" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">让我们看看流程入口点:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e147" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…监督学习课程:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0dd0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和调用的方法:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7f6c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在生产系统的情况下，我们必须做的第一件事是识别它当前的覆盖范围。该系统有一系列自动化的单元和功能测试。</p><p id="3aba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了测量覆盖率，我们将使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Mutation_testing" rel="noopener ugc nofollow" target="_blank">突变测试技术</a>。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fe85" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，只有一个测试失败了，所以我们发现这个过程没有包括在内，我们看到 Michael Feathers 的格言被可悲地应用:</p><blockquote class="oa"><p id="1b1a" class="ob oc in bd od oe of og oh oi oj kx dk translated">“继承的系统是没有测试的系统”</p></blockquote><p id="5610" class="pw-post-body-paragraph kc kd in ke b kf ok jo kh ki ol jr kk kl om kn ko kp on kr ks kt oo kv kw kx ig bi translated">重构继承系统的策略是在做任何改变之前覆盖现有的功能。</p><h2 id="e149" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">1-创建延迟测试。</h2><p id="44cc" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">编写测试揭示了对象之间良好的设计接口。由于当前的解决方案及其包含的耦合，编写测试非常困难。</p><p id="3bdd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，如果没有事先编写测试，我们就不能重构来编写测试。似乎我们正面临一个恶性循环。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/8e5b253853173841ba879efe1fd9789d.png" data-original-src="https://miro.medium.com/v2/0*vY4jw8pCHmPrr_kT"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@jkcphotos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈家</a>在<a class="ae kz" href="https://unsplash.com/s/photos/no-exit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="cd8f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个死锁的可能解决方案是声明性地编写测试<strong class="ke io"/>，从而生成更好的接口。</p><p id="3aa5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将手动运行它们，直到耦合得到解决。</p><h2 id="ae0e" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">2-我们编写测试来覆盖预先存在的功能。</h2><p id="9930" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">可以用来自 xUnit 家族的工具编写带有错误断言的测试(它们总是失败)。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1f72" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在涵盖了(目前是手动地)必要的案例之后，我们可以开始重构了。</p><h2 id="dd87" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">3-类名不代表双射中的真实名称。</h2><p id="8442" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">帮助者不存在于现实世界中，也不应该存在于任何可计算的模型中。</p><p id="f38d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑一下在<a class="ae kz" href="https://codeburst.io/what-is-software-9a78c1172cf9" rel="noopener" target="_blank">映射器</a>中选择名称的责任。</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">唯一的软件设计原则</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">如果我们在一个单一的规则上建立我们的整个范式，我们可以保持它的简单并做出优秀的模型。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="oq l nb nc nd mz ne lk mq"/></div></div></a></div><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="171b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在这个名字已经足够好了，它让我们了解了你的实例在现实世界中的职责。</p><h2 id="4182" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">4-该类是单例类。</h2><p id="f319" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">没有正当的理由使用单例。这个事实，除了产生这里描述的所有问题之外:</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/singleton-the-root-of-all-evil-8e59ca966243" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">辛格尔顿:万恶之源</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">允许的全局变量和假定的内存节省</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="or l nb nc nd mz ne lk mq"/></div></div></a></div><p id="ff61" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">产生一个非常易实现的调用(耦合到<em class="ky"> getInstance() </em>)而不是非常具有声明性...</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4f4b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将更改为:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f7ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">留下如下的类定义:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c674" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个重要的设计规则是:</p><blockquote class="ng nh ni"><p id="9ea6" class="kc kd ky ke b kf kg jo kh ki kj jr kk nj km kn ko nk kq kr ks nl ku kv kw kx ig bi translated">不要继承具体的类。</p></blockquote><p id="9a1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果语言允许这样做，我们显式声明它:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="92cc" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">5-所有方法中的参数相同。</h2><p id="07c6" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">对象被创建，然后它获得一个神奇的参数，设置要优化的流程的标识符。这个论点通过各种方法传播。</p><p id="d7e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个<em class="ky">代码气味</em>建议我们检查该参数和流程之间的<strong class="ke io">内聚性</strong>。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f23a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下双射，我们得出结论，没有过程就没有算法。我们不想让一个带有<em class="ky"> setters </em>的类变异它:</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/dev-genius/nude-models-part-i-setters-77ac784a91f3" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">裸体模特第一部分:模特</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">旧的可靠数据结构及其有争议的(写)访问。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="os l nb nc nd mz ne lk mq"/></div></div></a></div><p id="7ddf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们将在建造过程中通过所有的<strong class="ke io">基本</strong>属性。</p><p id="96e1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">知道一个属性是否<strong class="ke io">必要的</strong>的方法是去掉与该对象相关的所有责任。如果它不能再执行它的职责，那是因为该属性属于<a class="ae kz" href="https://en.wikipedia.org/wiki/Maximal_and_minimal_elements" rel="noopener ugc nofollow" target="_blank">最小属性集</a>。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c51b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，这个战略在本质上是<strong class="ke io">不可改变的</strong>，以及它带给我们的所有好处。</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/the-evil-powers-of-mutants-f803281ef82e" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">变种人的邪恶力量</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">变异就是进化。它是由查尔斯·达尔文爵士提出的，我们在软件行业中使用它。但是有些事情是…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="ot l nb nc nd mz ne lk mq"/></div></div></a></div><h2 id="7d60" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">6 —我们找到一种设计模式。</h2><p id="7e15" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">根据双射理论，这个过程模拟了真实世界的过程。这似乎符合<a class="ae kz" href="https://en.wikipedia.org/wiki/Command_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">命令</strong> </a> <strong class="ke io"> </strong>的模式。</p><p id="7e39" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，我们认为它更接近于一个<a class="ae kz" href="https://refactoring.guru/replace-method-with-method-object" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">方法对象</strong> </a>，其中有一个有序的执行序列，对算法的不同步骤进行建模。</p><h2 id="1ec1" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">7-可互换行为类似于另一种模式。</h2><p id="ec9e" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">正如我们根据其职责分配给对象的名称所暗示的那样，这个过程模拟了一个将与其他多态策略竞争的执行策略。</p><p id="2ef7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是<a class="ae kz" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略模式</a>的意图。</p><p id="3c36" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">名称应该与观察到的职责相匹配。</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/dev-genius/what-exactly-is-a-name-part-i-the-quest-b812a4b1e0bf" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">名字到底是什么？—第一部分:探索</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我们都同意:好名声永远是最重要的。让我们找到他们。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="ou l nb nc nd mz ne lk mq"/></div></div></a></div><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/c7b758777cbd80bb7b4403d082b2381f.png" data-original-src="https://miro.medium.com/v2/0*kGHoCXi7dUPP9UGk"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">尼古拉斯·霍伊泽在<a class="ae kz" href="https://unsplash.com/s/photos/athletics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="63e8" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">8 —我们消除空值。</h2><p id="a982" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">从来没有一个有效的理由使用空。<strong class="ke io"> Null </strong>在现实生活中是不存在的。</p><p id="2c1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">违反了<strong class="ke io">双射</strong>的原理，在函数调用方和实参之间产生耦合。此外，它会生成不必要的<strong class="ke io">if</strong>，因为<strong class="ke io"> null </strong>与任何其他对象都不是多态的。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7414" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将参数的缺失更改为布尔真值。</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/null-the-billion-dollar-mistake-c2918c92f7e0" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">Null:十亿美元的错误</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">他不是我们的朋友。它不会简化生活，也不会让我们更有效率。只是更懒。是时候停止了…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="ov l nb nc nd mz ne lk mq"/></div></div></a></div><h2 id="c0f7" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">9-我们删除默认参数。</h2><p id="5244" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">上例中的私有函数有一个默认参数。</p><p id="d6d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认参数产生<strong class="ke io">耦合</strong>和涟漪效应。它们可供懒惰的程序员使用。因为它是一个私有函数，所以替换作用域是同一个类。我们将其显式化，替换所有调用:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><div class="mn mo gp gr mp mq"><a href="https://mcsee.medium.com/code-smell-19-optional-arguments-c0714855dbbb" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">代码味道 19 —可选参数</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">伪装成友好的快捷方式是另一种耦合气味。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">mcsee.medium.com</p></div></div><div class="mz l"><div class="ow l nb nc nd mz ne lk mq"/></div></div></a></div><h2 id="1892" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">10-我们移除硬编码的常数。</h2><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ab9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些耦合在代码中的常量不允许我们“操纵时间”来做好测试。</p><p id="0ccc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，测试必须<strong class="ke io">控制整个环境</strong>，时间是<strong class="ke io">全局</strong>和<strong class="ke io">脆弱</strong>以匹配测试。</p><p id="1ff2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，它将是对象创建的必要参数(通过<a class="ae kz" href="https://refactoring.guru/es/add-parameter" rel="noopener ugc nofollow" target="_blank">添加参数进行重构</a>是一项安全的任务，任何现代 IDE 都可以完成。</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/@mcsee/code-smell-02-constants-and-magic-numbers-d6c320eef90b" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">代码气味 02——常数和幻数</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">本文是 CodeSmell 系列的一部分。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="ox l nb nc nd mz ne lk mq"/></div></div></a></div><h2 id="3d50" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">11 —我们将日志解耦。</h2><p id="0e2b" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">日志存储生产中有关策略执行的相关信息。像往常一样，使用一个<em class="ky">单例</em>作为全局引用。</p><p id="32c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种新的结合使我们无法测试它。这个<em class="ky"> Singleton </em>在另一个我们无法控制的模块中，所以我们将使用包装技术。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bac7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了是单例的，日志还使用了静态的类消息。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b0cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们记住:</p><blockquote class="ng nh ni"><p id="c143" class="kc kd ky ke b kf kg jo kh ki kj jr kk nj km kn ko nk kq kr ks nl ku kv kw kx ig bi translated">一个类应该包含的唯一协议是与其单一职责相关的协议(S 代表 Solid):创建实例。</p></blockquote><p id="bec5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为引用的是静态方法，所以我们不能用多态方法替换类调用。相反，我们将使用匿名函数。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8895" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们可以通过减少耦合，从策略中产生更好的内聚性，并有利于它的可测试性，来分离对日志的引用，并从类中提取它。</p><p id="0996" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以将该对象与几种不同类型的记录器一起使用(比如<a class="ae kz" href="https://en.wikipedia.org/wiki/Test_double" rel="noopener ugc nofollow" target="_blank"> tests doubles </a>)。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="371d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过生产代码的调用:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bf90" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">测试的结果是:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="a7e2" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">12 —我们具体化对象。</h2><p id="33b3" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">在我们重构的过程中，我们发现了一些对持久数据的修复。这种数据以内聚的方式传输，因此将它视为具有现实责任的对象是有意义的:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="df86" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过创造新的概念，我们处于建立一个贫血模型的危险之中。让我们看看你有哪些隐藏的责任:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><div class="mn mo gp gr mp mq"><a href="https://medium.com/dev-genius/code-smell-01-anemic-models-f9fb5a1323b3" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">代码气味 01——贫血模型</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">你的对象是一堆没有行为的公共属性。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="oy l nb nc nd mz ne lk mq"/></div></div></a></div><h2 id="5325" class="nm lr in bd ls nn no dn lw np nq dp ma kl nr ns mc kp nt nu me kt nv nw mg nx bi translated">13 —我们完成了覆盖范围。</h2><p id="ae22" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们没有忘记编写我们在开始时无法编写的测试程序。因为我们有一个耦合度更低的设计，所以现在很容易做到。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3ebf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与我们发现它时相比，我们的系统更少“遗留”。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/3593b74c480573a2bf2697973b025c15.png" data-original-src="https://miro.medium.com/v2/0*jNhMzxNDId9bToIr"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">凯利·西克玛在<a class="ae kz" href="https://unsplash.com/s/photos/tidy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="dcd2" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">摘要</h1><p id="eb87" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">经过艰苦的迭代和增量工作，通过简短的步骤，我们在以下几个方面实现了更好的解决方案:</p><ul class=""><li id="a4bc" class="oz pa in ke b kf kg ki kj kl pb kp pc kt pd kx pe pf pg ph bi translated">耦合更少。</li><li id="87d1" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">不变性。</li><li id="93cc" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">更好的名字。</li><li id="0d2d" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">没有 setter/getter。</li><li id="c25d" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">没有如果。</li><li id="d6f2" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">没有 Null。</li><li id="406f" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">没有单身人士。</li><li id="9e7b" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">没有默认参数。</li><li id="63a8" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">更好的测试覆盖率。</li><li id="b90d" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">遵循开放/封闭原则(Solid 的 O ),能够添加新的多态算法。</li><li id="54ee" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">遵循单一责任原则(S 为固体)。</li><li id="be8c" class="oz pa in ke b kf pi ki pj kl pk kp pl kt pm kx pe pf pg ph bi translated">而不用协议使类过载。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/ff0a0ab2fb307dcdb0166cc6987d2a35.png" data-original-src="https://miro.medium.com/v2/0*Q5WDWMSL9QK9aAkI"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@zacfarmerart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Zac 农民</a>在<a class="ae kz" href="https://unsplash.com/s/photos/very-old?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="866f" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结论</h1><p id="96bf" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">考虑到清晰的设计规则并采取小步骤，通过改进设计来修改现有系统是可能的。我们必须有专业的责任感和勇气来做出相关的改变，留下一个比我们找到它时好得多的解决方案。</p><p id="4ae9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以使用这些技术在遗留系统上进行 TDD。</p><div class="mn mo gp gr mp mq"><a href="https://mcsee.medium.com/how-to-squeeze-test-driven-development-on-legacy-systems-3e66625c4fb1" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">如何在遗留系统上挤压测试驱动开发</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我们都喜欢 T.D.D .我们知道它的好处，我们已经阅读了一千篇关于如何使用它来构建系统的教程…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">mcsee.medium.com</p></div></div><div class="mz l"><div class="pn l nb nc nd mz ne lk mq"/></div></div></a></div></div><div class="ab cl po pp hr pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="ig ih ii ij ik"><p id="1f86" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一系列文章的部分目标是为软件设计的辩论和讨论提供空间。</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/@mcsee/object-design-checklist-47c63d351352" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">目标设计清单</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">这是已经发表的软件设计文章的索引。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="pv l nb nc nd mz ne lk mq"/></div></div></a></div><p id="1470" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们期待着对这篇文章的评论和建议。</p><p id="4500" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章还有西班牙语版本<a class="ae kz" href="https://medium.com/dise%C3%B1o-de-software/c%C3%B3mo-desacoplar-un-sistema-heredado-e7fca5ffe628" rel="noopener">这里</a>。</p></div></div>    
</body>
</html>