# 避免 Java 通配符导入…但是为什么呢？

> 原文：<https://blog.devgenius.io/avoid-java-wildcard-imports-but-why-f219644cdd97?source=collection_archive---------6----------------------->

![](img/de5f071491bb5b369d9365edc35e9643.png)

十到角落口袋？照片由[克里斯蒂安·威迪格](https://unsplash.com/@christianw?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

为了组织 Java 程序需要的各种类和接口，我们可以将它们放在包中。然后，您可以根据 Java 类或接口来自的包来完全限定它的名称。举个例子，

```
**java.util.**List<**java.util.**Currency> currencies 
        = new **java.util.**ArrayList<**java.util.**Currency>();
```

会很快变老。所以 Java 也提供了 Import 语句。

```
package org.example.currency;**import java.util.ArrayList;
import java.util.Currency;
import java.util.List;**public class CurrencyUtils { // etc., etc.}
```

然后，利用导入和“钻石”语法(Java 7 和更高版本)，我们可以简化`currencies`的声明:

```
**List<Currency>** currencies = new **ArrayList<>**();
```

为什么停在那里？我们可以更进一步，删除更多的行。

```
package org.example.currency;**import java.util.*;**public class CurrencyUtils { // etc., etc.}
```

这种类型的导入语句称为“通配符”导入。你们中那些年龄足够大，还记得 DOS 的人可能还记得输入类似“dir *”的命令。xml”(该示例也适用于 Windows 10 命令行，它列出了目录中的 XML 文件，但省略了列表中带有其他扩展名的文件)。

示例导入并不意味着`java.util`包中的所有东西都会被导入。只有`CurrencyUtils`类的花括号中实际引用的`java.util`类和接口(但不是完全限定的)会被通配符导入引入。

存在命名冲突的可能性。虽然这实际上并不是通配符导入的最糟糕的问题，但是几乎每个人都会首先提到这个问题。假设您有`java.awt`和`java.util`的通配符导入。

那么编译器将不知道您所说的“`List`”是什么意思，而您的集成开发环境(IDE)会让您知道:

![](img/6d53eb7aa6667a5d032f7ef6b3dab4c8.png)

IntelliJ IDEA 的屏幕截图告诉您，由于通配符导入冲突，引用不明确。

您的 IDE 可能建议了一种解决这一困难的方法:

```
import java.awt.*;
import java.util.*;
**import java.util.List;**
```

如果您的类合法地需要从`java.awt`导入几乎所有的东西，只留下`List`和那个包中的一两件其他东西，那么通配符导入是值得的。

但是……真的有必要从`java.awt`进口几乎所有东西吗？或者，就此而言，从`java.util`开始，不同东西的大杂烩应该是三个或四个独立的包？

因为 Java 虚拟机并没有真正看到“子包”，所以对`java.util`的通配符导入实际上并没有从`java.util.regex`、`java.util.concurrent`等处得到任何东西。

在我看来，一揽子导入的最大问题是它模糊了程序员的意图。如果您没有使用通过通配符导入引入的包中的所有内容，那么就很难记住为什么要将该导入放在第一位。

不管是否使用导入，都可能是这种情况，尽管这当然会有所不同。例如，假设您打开了一个已经有一段时间没有使用的项目，您注意到在项目中一个不太充实的类中有一些未使用的导入。

假设其中一个导入是对`java.time`的通配符导入，另一个是对`java.util`的通配符导入。您可能希望`java.time`用时间戳或时间间隔做一些事情。

但是`java.util`导入几乎可以用于任何事情:也许您需要一些集合，比如著名的`ArrayList<E>`，或者也许您需要地区和货币数据，或者也许您需要一些按位操作。

甚至有可能是你想让`java.util`使用备受争议的`Date`和日历类。不过，可能不是 64 进制的东西。那个包裹装得太多了。

即使实际上使用了通配符导入，程序员的意图仍然不像特定导入那样清晰。

使用包中的单个类或接口就足以将通配符导入视为已使用。然后，确定什么来自什么包的唯一方法是逐个删除通配符导入，并查看每个删除的通配符导入会导致什么错误。

实际上，还有另一种方法，但是太费时间了，不值得:转到每个提到的类型并导航到声明(你应该能够在任何主要的 ide 中做到这一点)。例如，在 NetBeans 中有一种稍微简单的方法:

![](img/21c1565d39d130c00a73d6cb0b60a828.png)

在这个 NetBeans 截图中，我们看到图形环境类来自 Java 的抽象窗口工具包(AWT)包。

但是这仍然需要一行一行地仔细检查源文件，寻找那些你不记得它们来自哪个包的类型。

作为一个非常粗略的准则，只有当您需要包中一半以上的类和接口时，才使用通配符导入(枚举类型是一种特殊的类)。

如果你确实需要导入一个包中的所有东西，这可能意味着你正在处理的类应该在你要导入的包中。

这可能表明违反了适用于包的单一责任原则，因为一个包有多个责任(`java.util`就是一个恰当的例子)。

或者，这也可能意味着违反了适用于类的单一责任原则，因为类有多个责任，如果它只有一个责任，它可能需要更少的导入。

最后，不要担心忘记从一个给定的包中编写一个特定的导入，然后在某个时候想起回到源文件的顶部会分散你的注意力。在这种情况下，您的 IDE 可能会有所帮助。

例如，假设您已经从`java.io`导入了几个类，但是没有从`IOException`导入。然后，您需要调用抛出`IOException`的东西，这是一个检查过的异常。

继续编写那个调用。那么您的 IDE 可能会提供添加一个 Throws 子句或者用 Try-Catch 块包围调用。如果您接受其中一个建议，您的 IDE 可能还会添加必要的特定导入。至少 IntelliJ 会。

另一方面，如果您放弃 ide，转而使用像 Vim 这样的文本编辑器并在命令行上编译，您可能会更加关心通配符导入带来的重构便利性。

例如，假设你认为你需要`java.util.Map<K, V>`和`java.util.TreeMap<K, V>`。但是之后你决定使用`HashMap<K, V>`而不是`TreeMap<K, V>`。

有了`java.util.*`的通配符导入，即使没有 IDE 的帮助，这种改变也容易得多。您甚至可以决定使用只有一个类型参数而不是两个的标准集合。

支持通配符导入的另一个理由是，它使得与被导入的包的耦合更松散。松耦合是一件好事。假设包 *B* 中的类 *C* 从包 *A* 中导入了某种东西，松耦合意味着在不破坏类 *C* 的情况下对包 *A* 进行修改更容易。

但是通配符导入真的放松了耦合吗，还是仅仅掩盖了耦合的紧密性？

假设包 *A* 中的类 *D* 在该包的最新版本中被弃用。例如，如果包 *B* 中的类 *C* 有 20 个对类 *D* 的引用，那么如果这 20 个引用中有一个是特定的导入，那么差别就很小。

即使使用通配符导入，本例中的 *C* 与 *D* 的耦合也过于紧密。如果在下一个版本中 *D* 被完全删除，那么不需要删除 *C* 中的一个特定导入是一个非常小的便利。

这是 IDE 更容易做到的事情之一。在 IDE 中，不推荐使用的类或接口标有删除线，通配符导入除外。我肯定这些在记事本中不会被这样标记，我也怀疑 Vim 会标记不推荐使用的项目。

尽可能多地引用 *D* 的超类或接口可能对松散耦合更有帮助。例如，如果 *J* 是 *D* 的抽象超类或者是 *D* 实现的接口，那么“ *J x* `= new` *D* `()`”对 *D* 的耦合比“ *D x* `= new` *D* `()`更松散

Java 中的通配符导入提供了一些短期便利。但是这种便利是以清晰为代价的，并且减少了程序员的深思熟虑的印象。

出于这个原因，而不是因为担心与像`java.awt.List`这样晦涩的类发生命名冲突，Java 中的通配符导入通常应该避免。