<html>
<head>
<title>Working with StencilJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模板 JS</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-stenciljs-a4d75f7b1131?source=collection_archive---------1-----------------------#2021-09-23">https://blog.devgenius.io/working-with-stenciljs-a4d75f7b1131?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8eae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">StencilJS 如何简化 Web 组件的使用</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fcd4b8484a924f2475bd084d2aa38e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qr4q4-m31oqnbunEzpLFgQ.jpeg"/></div></div></figure><p id="24e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇文章中，我们了解了什么是 web 组件，以及像 StencilJS 这样的工具链的需求是什么。</p><div class="ku kv gp gr kw kx"><a href="https://medium.com/@kkakroo/what-are-web-components-cbfdf08c35a9" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">什么是 Web 组件</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">什么是 Web 组件以及如何开始使用它们。</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="4644" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将看到 Stencil 提供了什么，以及我们如何开始使用它。</p><blockquote class="lm ln lo"><p id="4013" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated">Stencil 是一个工具链，用于构建可重用、可扩展的设计系统。生成运行在每个浏览器上的小型、超快的、100%基于标准的 Web 组件。</p></blockquote></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="9611" class="ma mb in bd mc md me dn mf mg mh dp mi jv mj mk ml jz mm mn mo kd mp mq mr ms bi translated">什么是模板</h2><p id="82f8" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">它是一个帮助我们构建 Web 组件的编译器，它将多个框架的最佳概念整合到一个简单的构建时工具中。</p><p id="ed6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是由 Ionic 框架团队创建的，让 web 兼容开箱即用，以更快地构建跨多个框架工作的组件。</p><p id="b4a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它有很多惊人的功能，但我最喜欢的三个是</p><ul class=""><li id="5772" class="mz na in jm b jn jo jr js jv nb jz nc kd nd kh ne nf ng nh bi translated">虚拟 Dom- DOM 操作是昂贵的。</li><li id="b738" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">JSX-简单直观，非常容易上手。</li><li id="6474" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">打字稿——必须在编译时抓住它们(^-^).)</li></ul><p id="4b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Stencil 提供了一个不错的开发人员体验，包括一个 cli、实时重载和一个内置在编译器中的开发服务器。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="4993" class="ma mb in bd mc md me dn mf mg mh dp mi jv mj mk ml jz mm mn mo kd mp mq mr ms bi translated">探索模具 CLI</h2><p id="a31d" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">为了创建一个模板项目，我们使用下面的命令</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a117" class="ma mb in no b gy ns nt l nu nv">npm init stencil</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f94e0ab00ff65a746ab2cb97579c052d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7W006Z-ajzZFGwnaw57YjQ.gif"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">使用模具 CLI</figcaption></figure><p id="07db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在将继续使用组件库，并将选择第三个选项。</p><p id="bed6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它生成如下所示的项目结构。我们将浏览项目结构，并试图理解它是如何组织的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/83db6faecf331e6d34457fd27feaa6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*5TKg1nOuUE7g2kTNj7K_iA.png"/></div></figure><p id="5203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">src</code>文件夹包含<code class="fe oc od oe no b">components</code>，它有一个默认生成的样本组件<code class="fe oc od oe no b">my-component</code>。我们稍后将详细讨论它。</p><p id="20de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">utils</code>文件夹中有<code class="fe oc od oe no b">util.ts</code>文件，这只是一个展示我们如何为多个组件提供通用功能的例子。</p><p id="0707" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">components.d.ts</code>拥有这个项目中所有组件的类型声明。这个文件是自动生成的。</p><p id="cae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">index.html</code>用于测试我们已经创建的 web 组件，而<code class="fe oc od oe no b">index.ts</code>是入口点。</p><p id="5389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">www</code>包含<code class="fe oc od oe no b">build</code>文件夹，其中包含所有组件的<code class="fe oc od oe no b">esm.js</code>和<code class="fe oc od oe no b">js</code>包</p><p id="a4ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">stencil.config.ts</code>是一个重要的文件，让我们与编译器交互，调整它生成的输出，进行框架集成等等。它不需要任何更新，除非我们试图做一些具体的事情。</p><p id="ef79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过运行来运行解决方案</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="07c5" class="ma mb in no b gy ns nt l nu nv">npm run start</span></pre><p id="7971" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这会运行项目，我们会得到如下的默认输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/25c65147f64e5fe39a479e107e984df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*QvmDLJfQuKxRI_gOq_sjoA.png"/></div></figure><p id="87b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是从<code class="fe oc od oe no b">index.html</code>文件渲染的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="398c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于第 8 行<em class="lp">中的模块导入，<code class="fe oc od oe no b">my-component</code>被注册为 web 组件。</em></p><p id="bc44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们使用这个<code class="fe oc od oe no b">js</code>文件作为导入，我们就可以使用这些 web 组件，而不用考虑框架，并且我们每次都会有一致的行为。</p><p id="5197" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以尝试自己添加下面的<code class="fe oc od oe no b">src</code>标签到任何项目，并使用<code class="fe oc od oe no b">my-component</code>标签。</p><p id="9b42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">样品反应项目消耗<code class="fe oc od oe no b">my-component</code>可以在这里找到<a class="ae my" href="https://codesandbox.io/s/stencil-web-component-with-react-ujfjz" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6329" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这有一个非常强大的应用程序，因为<code class="fe oc od oe no b">js</code>文件不是消费项目的一部分，可以从外部更新，从而利用这些 web 组件对项目进行零部署更新。</p><p id="efe8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像<a class="ae my" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank"> single-spa </a>(使用 System.js)和<a class="ae my" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">module Federation</a>(web pack 的一个特性)这样的技术正在通过远程模块解决微前端开发的方法。</p><p id="b0dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以创建一个模板项目的 npm 包，如果我们愿意的话，就这样使用它。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="100f" class="ma mb in bd mc md me dn mf mg mh dp mi jv mj mk ml jz mm mn mo kd mp mq mr ms bi translated">创建自定义组件</h2><p id="eaaf" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">现在我们将创建一个样本徽章组件<code class="fe oc od oe no b">kk-badge</code>，并尝试理解模板必须提供什么。</p><p id="0b56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过运行命令来实现这一点。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="4dd3" class="ma mb in no b gy ns nt l nu nv">npm run generate</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1c4a68c52ef462fcfe0a7b8ff688a122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*SfPae1uSQUV_qXrZTetQpg.gif"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8982" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">模板组件看起来像是多个框架的混合。我们有 angular 常见的<code class="fe oc od oe no b">decorators</code>和 React 用的<code class="fe oc od oe no b">JSX</code>。</p><p id="afe0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第 3 行，我们可以看到装饰器声明了一个新的 web 组件。</p><p id="37e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lp">第 12 行</em>用<code class="fe oc od oe no b">@Prop()</code> decorator 定义了一个属性，它声明了一个暴露的属性/特性。道具的任何变化都会触发重新渲染。默认情况下，道具是不可变的。</p><p id="6022" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">@State()</code>是声明组件内部状态的装饰器。状态的变化也会触发重新渲染。</p><p id="13dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">Host</code>是模板公开的虚拟组件，用于设置元素的属性。</p><p id="0256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe oc od oe no b">&lt;slot&gt;</code>用于渲染特定位置的动态子对象。在这里，我们可以通过<code class="fe oc od oe no b">&lt;kk-badge type='info'&gt;Info&lt;/kk-badge&gt;</code>使用这个槽，它将文本<em class="lp">信息</em>呈现在徽章内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/eac49f3ba1e0aeb6d0187a7df2229fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:110/format:webp/1*A8PoY7EEhO0XeitLZELqFA.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">kk-徽章渲染</figcaption></figure><p id="3cb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用<a class="ae my" href="https://quirky-babbage-abdccd.netlify.app/kk-component-library/kk-component-library.esm.js" rel="noopener ugc nofollow" target="_blank"> this </a>作为带有<code class="fe oc od oe no b">type="module"</code>的<code class="fe oc od oe no b">script</code>标签的 src，自己尝试一下。这里可以找到工作示例<a class="ae my" href="https://codesandbox.io/s/badge-consume-x5myu?file=/index.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="af9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它们有组件生命周期方法，通过这些方法，我们可以在组件渲染/重新渲染的不同阶段执行不同的操作。</p><p id="fc34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Stencil 还为组件提供了一个 API 来发出事件，并使用<code class="fe oc od oe no b">Event()</code>和<code class="fe oc od oe no b">Listen()</code>装饰器来监听它们。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="250a" class="ma mb in bd mc md me dn mf mg mh dp mi jv mj mk ml jz mm mn mo kd mp mq mr ms bi translated">框架绑定</h2><p id="a0e0" class="pw-post-body-paragraph jk jl in jm b jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">这些 web 组件可以在具有不同框架的现有应用程序中使用，但是在使用 web 组件时有一定的限制。</p><p id="e361" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里阅读更多关于这个<a class="ae my" href="https://custom-elements-everywhere.com/" rel="noopener ugc nofollow" target="_blank">的内容</a></p><p id="87a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些问题可以通过模板中的<em class="lp">框架绑定</em>来解决，它创建了特定于框架的包装器。</p><p id="db76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以一次创建你的组件，然后(在一些配置之后)stencil 会生成特定于框架的库，这些库可以帮助用户享受所有的特性。</p><p id="cd2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一篇文章中，我们将看看框架绑定如何在模板中工作。</p><div class="ku kv gp gr kw kx"><a rel="noopener  ugc nofollow" target="_blank" href="/react-wrappers-with-stenciljs-6b574500f6f6"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">用 StencilJS 反应包装器</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">我们如何从模板组件库中自动创建 react 包装器包？</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">blog.devgenius.io</p></div></div><div class="lg l"><div class="ok l li lj lk lg ll ks kx"/></div></div></a></div></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="269f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你喜欢这篇文章。如有任何建议或问题，可在<a class="ae my" href="https://www.linkedin.com/in/kkakroo/" rel="noopener ugc nofollow" target="_blank"><em class="lp">LinkedIn</em></a><em class="lp">与我联系或在下方评论。</em></p></div></div>    
</body>
</html>