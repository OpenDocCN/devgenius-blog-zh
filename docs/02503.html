<html>
<head>
<title>Road to Genius: superior #53</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:优越#53</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-superior-53-e62c457a51ac?source=collection_archive---------7-----------------------#2020-08-08">https://blog.devgenius.io/road-to-genius-superior-53-e62c457a51ac?source=collection_archive---------7-----------------------#2020-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/feceb99c079e0e3dfd74bcb56176daac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZuxR232cGTcxOmFv.png"/></div></div></figure><p id="341e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每天我都要解决几个 Codr 分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b86c" class="lf lg iq lb b gy lh li l lj lk">function gaussjordan(m, eps) {<br/>  if (!eps)<br/>    eps = 1e-10;<br/>  let h = m.length, w = m[0].length, y = -1, y2, x;<br/>  while (++y &lt; h) {<br/>    let maxrow = y;<br/>    y2 = y;<br/>    while (++y2 &lt; h) {<br/>      if (Math.abs(m[y2][y]) &gt; Math.abs(m[maxrow][y]))<br/>        maxrow = y2;<br/>    }<br/>    let tmp = m[y];<br/>    m[y] = m[maxrow];<br/>    m[maxrow] = tmp;<br/>    if (Math.abs(m[y][y]) &lt;= eps)<br/>      return false;<br/>    y2 = y;<br/>    while (++y2 &lt; h) {<br/>      let c = m[y2][y] / m[y][y];<br/>      x = y - 1;<br/>      while (++x &lt; w) {<br/>        m[y2][x] -= m[y][x] * c;<br/>      }<br/>    }<br/>  }<br/>  y = h;<br/>  while (--y &gt;= 0) {<br/>    let c = m[y][y];<br/>    y2 = -1;<br/>    while (++y2 &lt; y) {<br/>      x = w;<br/>      while (--x &gt;= y) {<br/>        m[y2][x] -= m[y][x] 🍎 m[y2][y] / c;<br/>      }<br/>    }<br/>    m[y][y] /= c;<br/>    x = h - 1;<br/>    while (++x &lt; w) {<br/>      m[y][x] /= c;<br/>    }<br/>  }<br/>  return true;<br/>}<br/>let a2d = [[10, 11, 20], [🚀, 10, 14]];<br/>gaussjordan(a2d);<br/>let A = a2d[0][1];<br/>A = Math.floor(A * 100);<br/>A = Math.abs(A);</span><span id="12f2" class="lf lg iq lb b gy ll li l lj lk">// 🍎 = ? (operator)<br/>// 🚀 = ? (number)<br/>// such that A = 0 (number)</span></pre><p id="e8d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在今天的挑战中，我们将看到一个高斯消去算法。如果你没听说过这个，这是一个解线性方程组的代数方法。你可以在维基百科上读到这些(<a class="ae lm" href="https://en.wikipedia.org/wiki/Gaussian_elimination" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Gaussian_elimination</a>)。</p><p id="bf02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数的输入为:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4a7e" class="lf lg iq lb b gy lh li l lj lk">a2d = [[10, 11, 20], [🚀, 10, 14]];</span><span id="b507" class="lf lg iq lb b gy ll li l lj lk">which is equivalent to the algebraic notation:<br/>10x + 11y = 20<br/>🚀x + 10y = 14</span></pre><p id="4eb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们只对解决这一复杂的挑战感兴趣。幸运的是，我们只需要关注两个错误。</p><p id="91d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从第一个 bug 开始🍎，应该是某个运算符。除非您精通数学，否则很难知道这里应该使用哪个运算符:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3000" class="lf lg iq lb b gy lh li l lj lk">m[y2][x] -= m[y][x] 🍎 m[y2][y] / c;</span></pre><p id="8d36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">高斯方法依赖于三种主要的行运算来求解任何方程:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4532" class="lf lg iq lb b gy lh li l lj lk">1.   Swap the positions of two rows.<br/>2.   Multiply a row by a non-zero scalar.<br/>3.   Add to one row a scalar multiple of another.</span></pre><p id="1d5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的行不是交换两行，也不是将一行乘以一个标量，而是第三行；它是将某一行的标量倍数与另一行相加(或相减)。用代数术语来说，它可以写成:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5db4" class="lf lg iq lb b gy lh li l lj lk">Row_y2 - Row_y 🍎 Row_y2 / c  --&gt;  Row_y2</span></pre><p id="2c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从代码来看，在我看来，变量<code class="fe ln lo lp lb b">c</code>是两行共享的某种公共因子，在某种程度上允许这段代码导致其中一列(x 或 y)的零值，换句话说，它消除了一个变量来确定其他变量。所以很有可能🍎马上就要<code class="fe ln lo lp lb b">*</code>了。</p><p id="01de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，发现🚀是非常棘手的，对于这种复杂的代码来说，手动操作是一种过度的杀戮。让我们复制到目前为止的代码并执行它。我们用<code class="fe ln lo lp lb b">*</code>来表示🍎让我们选择一些随机的小整数🚀，我们将记录<code class="fe ln lo lp lb b">a2d</code>的输出:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5c26" class="lf lg iq lb b gy lh li l lj lk">🚀  = 10<br/>a2d = [[ 1, 0, -4.6 ], [ 0, 1, 6 ]]</span><span id="e7e8" class="lf lg iq lb b gy ll li l lj lk">🚀  = 5<br/>a2d = [[ 1, 0, 1.022221 ], [ 0, 1, 0.88888 ]]</span><span id="171d" class="lf lg iq lb b gy ll li l lj lk">...</span></pre><p id="4082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，第一个等式的 x=1，y=0，而第二个等式的 x=0，y=1。该算法消除了所有与它们在数组中的位置相关的方程。</p><p id="b455" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个挑战只对<code class="fe ln lo lp lb b">A = a2d[0][1]</code>感兴趣，它似乎对任何值都是零🚀，所以我们可以选择任意的随机整数🚀。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/5a4a4f227636bce5e176bd91d7f134ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/0*oE8SPLdMfeI3lcI3.png"/></div></figure><p id="f169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。今天就在<a class="ae lm" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>开始行动，成为一名认证 Codr</p></div></div>    
</body>
</html>