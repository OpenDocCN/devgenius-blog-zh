<html>
<head>
<title>Distribution Patterns, DTO and Remote Facade</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布模式，DTO和远程门面</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/distribution-patterns-dto-and-remote-facade-b277b48b16f5?source=collection_archive---------8-----------------------#2020-07-20">https://blog.devgenius.io/distribution-patterns-dto-and-remote-facade-b277b48b16f5?source=collection_archive---------8-----------------------#2020-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="40f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个故事中，我将介绍分布模式、数据传输对象和远程外观的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bc817b312b0a1228eb5c9e9d8cadadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p20xMw8Po2aDI_sv2KGhZw.jpeg"/></div></div></figure><h1 id="0f3f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">数据传输对象</h1><p id="4521" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我很确定你已经听说过DTO(也称为值对象)，并且在你的软件开发生涯中至少创建了一个DTO类。</p><p id="a640" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您使用远程接口(例如，web服务)时，对它的每次调用都是昂贵的。因此，您需要减少调用次数，这意味着您应该使用d to来聚合数据，以便在每次调用中传输更多的数据。</p><p id="2dca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据传输对象不应该包含任何业务逻辑，它需要是可序列化的，以便通过连接。通常，汇编器也称为映射器，用于域对象和DTO对象之间的数据传输。</p><p id="7a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看DTO类的例子。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1513" class="mc kv in ly b gy md me l mf mg">public class Article {<br/>    private long id;<br/>    private long authorId;<br/>    private String text;<br/>    private Timestamp publishTimestamp;</span><span id="44b4" class="mc kv in ly b gy mh me l mf mg">    // getters and setters<br/>}<br/><br/>public class Author {<br/>    private long id;<br/>    private String name;<br/>    private String profileUrl;<br/>    private String profileImageUrl;</span><span id="daf5" class="mc kv in ly b gy mh me l mf mg">    // getters and setters<br/>}<br/><br/>public class ArticleDTO {<br/>    private long id;<br/>    private String text;<br/>    private AuthorDTO author;<br/>    private Timestamp publishTimestamp;<br/>    <br/>    // getters and setters<br/>}<br/><br/>public class AuthorDTO {<br/>    private String name;<br/>    private String profileUrl;<br/>    private String profileImageUrl;</span><span id="d17c" class="mc kv in ly b gy mh me l mf mg">    // getters and setters<br/>}</span></pre><h1 id="5bc2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">远程外观</h1><p id="db1b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">远程外观旨在最小化应用程序中远程调用的数量。这个模式包含一个或几个<strong class="jm io">细粒度</strong>对象的<strong class="jm io">粗粒度</strong>接口。远程facade模式不包含业务逻辑，它只在底层细粒度方法中翻译粗粒度方法。远程Facade模式与数据传输对象模式相结合是常见的情况。</p><p id="41ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个非常简单的例子..</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2da5" class="mc kv in ly b gy md me l mf mg">public class StorageManager {<br/>    public boolean isItemAvailable(int itemId) {<br/>        // implementation...<br/>    }<br/>}<br/><br/>public class Packager {<br/>    public void packItem(int itemId) {<br/>        // implementation...<br/>    }<br/>}<br/><br/>public class RemoteStore {<br/>    private final StorageManager storageManager;<br/>    private final Packager packager;<br/><br/>    public RemoteStore(StorageManager storageManager, <br/>                       Packager packager) {<br/>        this.storageManager = storageManager;<br/>        this.packager = packager;<br/>    }<br/><br/>    public void buyItem(int itemId) {<br/>        if (storageManager.isItemAvailable(itemId)) {<br/>            packager.packItem(itemId);<br/>        }<br/>        // implementation ...<br/>    }<br/>}</span></pre><p id="42f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看数据传输对象和远程外观模式结合时的图形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/0c81c063540ea9a94b8182c151d86bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HF0kVlevfvl0dx8QpZFgtw.png"/></div></div></figure></div></div>    
</body>
</html>