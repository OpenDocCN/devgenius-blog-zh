<html>
<head>
<title>Update and Range Queries using BitSet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用位集更新和范围查询</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/update-and-range-queries-using-bitset-e725d680f7ee?source=collection_archive---------26-----------------------#2020-07-13">https://blog.devgenius.io/update-and-range-queries-using-bitset-e725d680f7ee?source=collection_archive---------26-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a0a3512b01e0b8f87054ed184d8a61a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gn-IDhzpJoWLh6Ha"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@aleskrivec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ales Krivec </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="cccf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在竞争性编程中，人们一定遇到过这样的问题:需要更新数组中的特定索引，还需要为多个查询找到给定范围内元素的总和。解决这类问题的一种方法是段树，但也有一种简单的技术可以优化解决这类问题，这就是所谓的位集。</p><p id="3c79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们看看什么是位集。BitSet创建一个由布尔值表示的位数组。BitSet只为每个布尔值占用1位空间，因此BitSet占用的空间小于布尔数组或向量。BitSet在C++和Java中都可用，但我将用Java来解释。BitSet也有一些限制，但让我们先看一个例子。</p><p id="bd35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给你一个大小为N的数组，有Q个查询。每个查询属于以下类型- <br/>类型1:计算给定范围内奇数的个数。<br/>类型2:统计给定范围内偶数的个数。<br/>类型3:用给定的数字替换索引X处的元素。</p><p id="c900" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种强力方法是对每个查询的范围内的偶数或奇数进行计数，但是对于n大小的10⁵和10⁵数量的查询，每个查询的最坏情况可以是O(N*Q ),其等于O(N*N ),这将导致TLE。</p><p id="2b11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你知道如何使用细分树，它显然是一个很好的解决方案。但是让我们在这里使用BitSet。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bcb3" class="lh li in ld b gy lj lk l ll lm">import java.io.*;<br/>import java.util.*;</span><span id="35c1" class="lh li in ld b gy ln lk l ll lm">class Main {<br/> public static void main (String[] args) {<br/>  Scanner in = new Scanner(System.in);<br/>  int N = in.nextInt();<br/>  int arr[] = new int[N];<br/>  for(int i = 0; i &lt; N; i++){<br/>      arr[i] = in.nextInt();<br/>  }<br/>  // Initializing the BitSet of size N<br/>  BitSet B = new BitSet(N);<br/>  for(int i = 0; i &lt; N; i++){<br/>      if(arr[i] % 2 == 1)<br/>      // Making the ith bit set where arr[i] is odd<br/>      B.set(i);<br/>  }<br/>  int Q = in.nextInt();<br/>  while(Q-- != 0){<br/>      int type = in.nextInt();<br/>      int X = in.nextInt();<br/>      int Y = in.nextInt();<br/>      if(type == 1){<br/>          // Making new BitSet of given range<br/>          BitSet B1 = B.get(X-1,Y);<br/>          // Count no. of index whose bit is set<br/>          System.out.println(B1.cardinality());<br/>      }<br/>      else if(type == 2){<br/>          // Making new BitSet of given range<br/>          BitSet B2 = B.get(X-1,Y);<br/>          // Count no. of index whose bit is unset<br/>          System.out.println((Y-X+1) - B2.cardinality());<br/>      }<br/>      else{<br/>          // If previous element at index X is even and<br/>          // new element is odd then set the bit at index X<br/>          if(arr[X-1] % 2 == 0 &amp;&amp; Y % 2 == 1) <br/>          B.set(X-1);<br/>          // If previous element at index X is odd and<br/>          // new element is even then unset the bit at index X<br/>          else if(arr[X-1] % 2 == 1 &amp;&amp; Y % 2 == 0) <br/>          B.flip(X-1);<br/>      }<br/>  }<br/> }<br/>}</span></pre><p id="1ea0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个与数组大小相同的位集，如果第I个元素是奇数，则设置第I位。对于类型1查询，使用<a class="ae jz" href="https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html#get%28int,%20int%29" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">get</strong></a>(int from index，int toIndex)方法从原始位集生成给定范围的新位集。使用<a class="ae jz" href="https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html#cardinality%28%29" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">基数</strong> </a>()方法打印该范围内奇数个元素的数量。Cardinality方法给出了位集中集合位的计数。位集代替段树的原因是基数方法的时间复杂度是O(1 ),并且它不给出TLE。</p><p id="ce31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似地，对于类型2查询，为了找到给定范围内偶数元素的数量，从原始位集生成该范围的新位集，并从该范围内的元素数量中减去该位集的基数，以获得答案。</p><p id="6654" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于类型3的查询，检查要被替换的元素是否是偶数，新元素是否是奇数，然后在该索引处设置该位，否则，如果要被替换的元素是奇数，新元素是偶数，则在该索引处翻转该位。</p><p id="31a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，使用BitSet，这个问题以一种简单而又优化的方式解决了。请注意，类似的位集函数在C++中也是可用的。</p><p id="2456" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于任何特定问题，您也可以使用位集数组。假设，给你一串小写字母，你必须对每个字符进行一些更新和范围查询，然后你可以根据问题使用位集数组，然后你可以使用各种位集方法来解决问题。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1442" class="lh li in ld b gy lj lk l ll lm">BitSet B[] = new BitSet[26];<br/>for(int i = 0; i &lt; 26; i++){<br/>    // BitSet of size of length of string for each character<br/>    B[i] = new BitSet(N);<br/>}</span></pre><p id="84b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据问题的不同，BitSet可以用在许多其他地方，您可以使用它来优化解决方案。</p><p id="e3e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！</p></div></div>    
</body>
</html>