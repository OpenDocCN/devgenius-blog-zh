<html>
<head>
<title>Better JavaScript — Floating-Point and Coercions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的 JavaScript——浮点和强制</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-floating-point-and-coercions-b16ff3a48443?source=collection_archive---------4-----------------------#2020-10-09">https://blog.devgenius.io/better-javascript-floating-point-and-coercions-b16ff3a48443?source=collection_archive---------4-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8cabcf66ba5d32e6808996f8946a37eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HdtFwsnf2m1EVMHE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@leorivas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">利奥·里瓦斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d4ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进 JavaScript 代码的方法。</p><h1 id="bfe3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浮点数</h1><p id="1a2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于舍入的原因，浮点数在 JavaScrtipt 中很棘手。</p><p id="5eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dd9f" class="mn lc iq mj b gy mo mp l mq mr">0.1 + 0.2;</span></pre><p id="1512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ee1c" class="mn lc iq mj b gy mo mp l mq mr">0.30000000000000004</span></pre><p id="a1e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">双精度浮点数只能表示有限的一组数，而不能表示无限的一组实数。</p><p id="dc3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着浮点运算只能产生有限的结果。</p><p id="2b9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在一个或多个操作中舍入时，舍入误差会累积。</p><p id="149e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得结果越来越不准确。</p><p id="748f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像加法这样的数学运算是结合律，所以(x + y) + z = x + (y + z)。</p><p id="0d38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是浮点运算却不是这样。</p><p id="2107" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7680" class="mn lc iq mj b gy mo mp l mq mr">(0.1 + 0.2) + 0.3; </span></pre><p id="e340" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="919b" class="mn lc iq mj b gy mo mp l mq mr">0.6000000000000001</span></pre><p id="4742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="304a" class="mn lc iq mj b gy mo mp l mq mr">0.1 + (0.2 + 0.3);</span></pre><p id="0306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回 0.6。</p><p id="aa12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于整数，我们必须确保每个结果的范围在<code class="fe ms mt mu mj b">-2 ** 53</code>和<code class="fe ms mt mu mj b">2 ** 53</code>之间。</p><h1 id="455e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">隐性胁迫</h1><p id="c84b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须意识到隐性胁迫。</p><p id="4098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们写 JavaScript 时，它们会成为我们的一个问题。</p><p id="a945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="05d8" class="mn lc iq mj b gy mo mp l mq mr">2 + true;</span></pre><p id="dcb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">得到 3。</p><p id="6602" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">true</code>被转换成 1 所以我们得到 3。</p><p id="270a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些情况下，如果我们使用了错误的类型，JavaScript 会给出错误。</p><p id="4e5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6281" class="mn lc iq mj b gy mo mp l mq mr">"foo"(1);</span></pre><p id="aec0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到“未捕获的类型错误:“foo”不是函数”。</p><p id="32fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe ms mt mu mj b">undefined.x</code>得到我们‘未捕获的类型错误:无法读取未定义的属性‘x’。</p><p id="888e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多其他情况下，JavaScript 将值强制为它认为应该是的值。</p><p id="a9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1a57" class="mn lc iq mj b gy mo mp l mq mr">2 + 1;</span></pre><p id="1e2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后 JavaScritp 假设我们正在添加 2 个数字。</p><p id="a0a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7251" class="mn lc iq mj b gy mo mp l mq mr">"foo" + " bar";</span></pre><p id="dd8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们连接两个字符串。</p><p id="e814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把一个数字和一个字符串结合起来，那就更混乱了。</p><p id="43dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="966c" class="mn lc iq mj b gy mo mp l mq mr">1 + 2 + "3";</span></pre><p id="ce21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8700" class="mn lc iq mj b gy mo mp l mq mr">(1 + 2) + "3";</span></pre><p id="8c0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe ms mt mu mj b">'33'</code>。</p><p id="61e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0cab" class="mn lc iq mj b gy mo mp l mq mr">1 + "2" + 3;</span></pre><p id="9da2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe ms mt mu mj b">“123”</code>。</p><p id="d8f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是根据自己的规则转换成类型，所以不太容易预测。</p><p id="bd6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型强制隐藏了错误，所以只有当代码没有达到我们的预期时，我们才知道我们有一个 bug。</p><p id="1729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有抛出异常，而是看到了我们没有预料到的结果。</p><p id="9aaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，<code class="fe ms mt mu mj b">NaN</code>被认为不等于自身，比较混乱。</p><p id="caeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须调用<code class="fe ms mt mu mj b">isNaN</code>来检查<code class="fe ms mt mu mj b">NaN</code>。</p><p id="4e3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="15f0" class="mn lc iq mj b gy mo mp l mq mr">isNaN(NaN); </span></pre><p id="82c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe ms mt mu mj b">true</code>。</p><p id="844f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5ca" class="mn lc iq mj b gy mo mp l mq mr">let x = NaN; <br/>x === NaN;</span></pre><p id="9ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe ms mt mu mj b">false</code>。</p><p id="af6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静默强制使调试变得更加困难，因为它掩盖了错误，使错误更难被发现。</p><p id="1f3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当计算出错时，我们必须检查每个变量，检查哪里出错了。</p><p id="3078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象也可以被强制为原语。</p><p id="a6ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bc64" class="mn lc iq mj b gy mo mp l mq mr">'' + Math</span></pre><p id="39ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe ms mt mu mj b">“[object Math]”</code>。</p><p id="65e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f55e" class="mn lc iq mj b gy mo mp l mq mr">'' + JSON</span></pre><p id="afd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe ms mt mu mj b">“[object JSON]”</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/98c5c2219c96e4f87705f3a6daaf61a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ANJvxUDeMcNNkWq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@byadonia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ahin yesilyaprak</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d792" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3454" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">浮点运算和数据类型强制对 JavaScript 来说都很棘手。</p><p id="d0ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须确保尽可能少地强制数据类型，以减少令人沮丧的错误的机会。</p></div></div>    
</body>
</html>