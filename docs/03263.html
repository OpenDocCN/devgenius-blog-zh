<html>
<head>
<title>Better JavaScript — Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的 JavaScript——原型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-prototypes-e9db07269119?source=collection_archive---------8-----------------------#2020-10-17">https://blog.devgenius.io/better-javascript-prototypes-e9db07269119?source=collection_archive---------8-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6e4b637204d506ef7c104cf8c869e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5zLsMAGNvz1i1G-K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Viktor Forgacs 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进 JavaScript 代码的方法。</p><h1 id="62a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Object.getPrototypeOf 或 __proto__</h1><p id="c524" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从 ES6 开始，<code class="fe me mf mg mh b">__proto__</code>已经成为一个对象的标准属性。</p><p id="fee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像获取和设置任何其他属性一样获取和设置它。</p><p id="2d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a641" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};</span><span id="4add" class="mq lc iq mh b gy mv ms l mt mu">console.log(obj.__proto__);</span></pre><p id="013c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">才能得到<code class="fe me mf mg mh b">obj</code>的原型。</p><p id="7f74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">__proto__</code>属性得到对象的原型。</p><p id="6d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0005" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>obj.__proto__ = {<br/>  foo: 1<br/>};</span><span id="5516" class="mq lc iq mh b gy mv ms l mt mu">console.log(obj.__proto__);</span></pre><p id="c28b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了原型<code class="fe me mf mg mh b">{foo: 1}</code>。</p><p id="2567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想用原型创建一个对象，我们也可以用原型调用<code class="fe me mf mg mh b">Object.create</code>。</p><p id="df33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="23f4" class="mq lc iq mh b gy mr ms l mt mu">const obj = Object.create({<br/>  foo: 1<br/>})</span></pre><p id="f47d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了同样的结果。</p><p id="88fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">Object.getPrototypeOf</code>方法来获得一个对象的原型。</p><p id="1b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="187a" class="mq lc iq mh b gy mr ms l mt mu">Object.getPrototypeOf(obj)</span></pre><p id="dddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的结果与得到<code class="fe me mf mg mh b">__proto__</code>属性的结果相同。</p><p id="d8ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性是标准的，所以我们可以安全地使用它来获取和设置原型。</p><h1 id="240b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使构造函数成为新不可知论者</h1><p id="8c4d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在创建一个构造函数，那么我们可以把它作为一个函数来调用。</p><p id="1855" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d740" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="1be7" class="mq lc iq mh b gy mv ms l mt mu">const p = Person('james');<br/>console.log(this.name)</span></pre><p id="0423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">this</code>是全局对象并且<code class="fe me mf mg mh b">name</code>属性具有值<code class="fe me mf mg mh b">'james'</code>。</p><p id="e28f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这绝对不是我们想要的。</p><p id="d983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有严格模式，那么<code class="fe me mf mg mh b">this</code>将会是顶层的<code class="fe me mf mg mh b">undefined</code>，所以我们不会意外地创建全局变量。</p><p id="b984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="40b3" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  "use strict";<br/>  this.name = name;<br/>}</span><span id="3a35" class="mq lc iq mh b gy mv ms l mt mu">const p = Person('james');</span></pre><p id="2499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到错误“未捕获的类型错误:无法设置 undefined 的属性“name”。</p><p id="9232" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为我们提供了一些保护，使我们免于像常规函数一样调用构造函数。</p><p id="e7e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使检查更加可靠，我们可以在构造函数中添加一个实例检查:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e5d4" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  if (!(this instanceof Person)) {<br/>    return new Person(name);<br/>  }<br/>  this.name = name;<br/>}</span></pre><p id="9c45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，不管有没有<code class="fe me mf mg mh b">new</code>，我们仍然得到返回的<code class="fe me mf mg mh b">Person</code>实例。</p><p id="b5ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好的方法是使用类语法。</p><p id="5822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将构造函数重写为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d808" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="be1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们在没有<code class="fe me mf mg mh b">new</code>的情况下调用<code class="fe me mf mg mh b">Person</code>，我们会得到错误‘未捕获的类型错误:没有‘new’就不能调用类构造函数 Person’。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b52d3db0b3a43d4f540280647ff8077b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3eR7qilJ3ZtLtV4Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@uxstore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> UX 店</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="b1bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4f95" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有多种方法可以获得和设置原型。</p><p id="e30c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，类语法是创建构造函数的最健壮的方法。</p></div></div>    
</body>
</html>