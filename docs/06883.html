<html>
<head>
<title>Testing tools for Kotlin. Quick recap in 2022.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的测试工具。快速回顾 2022 年。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/testing-tools-for-kotlin-quick-recap-in-2022-1c2b0d4e179a?source=collection_archive---------6-----------------------#2022-02-09">https://blog.devgenius.io/testing-tools-for-kotlin-quick-recap-in-2022-1c2b0d4e179a?source=collection_archive---------6-----------------------#2022-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0899f81dbdd8796199d713862dd71932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CflGO8BG3d7fJvQ_f3agyw.png"/></div></div></figure><p id="2a0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以将测试工具分为三大类:</p><ol class=""><li id="acff" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">框架</strong></li><li id="0e1a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">嘲笑</strong></li><li id="c4cc" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">断言</strong></li></ol><h1 id="2107" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1)框架</h1><h2 id="163f" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://github.com/junit-team/junit4/wiki/Getting-started" rel="noopener ugc nofollow" target="_blank">6 月 4 日</a></h2><p id="b653" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">刚刚好，足以工作，没有任何酷的功能。在 Android 项目中仍然是默认的，因为下一个版本(JUnit5)需要 Java8，由于编译时间的原因，Java 8 仍然不是 Android 的默认版本。</p><h2 id="7336" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://junit.org/junit5/docs/current/user-guide/" rel="noopener ugc nofollow" target="_blank">6 月 5 日</a></h2><p id="19e7" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">这就是未来。可以与旧的 JUnit4 测试一起工作。这里提到的所有其他框架都需要这样才能工作。你可以用这个实现所有其他的行为。所有您知道的，所有新功能都在一个地方。<br/>我个人不需要比这更多的东西。</p><p id="2e6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主要特性:</p><p id="186b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">嵌套测试</strong>——您可以构建漂亮的测试层次结构，并根据需要对它们进行分组。例如，您可以按照 BDD 风格将它们分组，如下所示。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b4e2" class="mf li in nc b gy ng nh l ni nj"><em class="nk">@Nested<br/></em>inner <strong class="nc io">class</strong> `GIVEN (...)`{<br/>    <em class="nk">@Nested<br/>    </em>inner <strong class="nc io">class</strong> `WHEN (...)`{<br/>        <em class="nk">@Test<br/>        </em><strong class="nc io">fun</strong> `THEN (...)`() {<br/>        <em class="nk">@Test<br/>        </em><strong class="nc io">fun</strong> `THEN (...)`() {</span></pre><p id="8995" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> assertAll </strong> —在抛出错误之前断言所有断言。您不必重新运行测试来检查其他断言是否有效！</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="bffd" class="mf li in nc b gy ng nh l ni nj">assertAll( <br/>    { assertTrue(...) }, <br/>    { assertFalse(..) } <br/>)</span></pre><p id="e37f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以像人一样在测试结束时测试异常。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="aeb3" class="mf li in nc b gy ng nh l ni nj">assertThrows&lt;NullPointerException&gt; { nullPointerFunc() }</span></pre><p id="5788" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> @ParameterizedTest </strong> —不同场景不用复制&amp;粘贴测试。在测试中感受数据类参数的力量！</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="92f9" class="mf li in nc b gy ng nh l ni nj">@ParameterizedTest <br/>@ValueSource(strings = ["racecar", "radar", "able was I ere I saw elba"]) <br/>fun palindromes(candidate: String?) {<br/>    assertTrue(StringUtils.isPalindrome(candidate)) <br/>}</span></pre><p id="45ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">@ DisplayName</strong>——我知道在 Kotlin 中你可以用句子作为名字，但是对于 display name 你可以用表情符号。是的，很可能你永远也不会用到它。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="38e9" class="mf li in nc b gy ng nh l ni nj">@Test <br/>@DisplayName("Test name with emoji: 😅 😂 🤣 ") <br/>fun testWithDisplayNames() {</span></pre><p id="3a65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">边注</strong> s: <br/> 1。要在 Android 上使用以上所有的好处，你必须使用一个外部插件:<a class="ae mr" href="https://github.com/mannodermaus/android-junit5" rel="noopener ugc nofollow" target="_blank">https://github.com/mannodermaus/android-junit5</a><br/>2。JUnit5 不使用<code class="fe nl nm nn nc b">@Rules</code>，你需要使用扩展，但它们非常简单:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="eaf8" class="mf li in nc b gy ng nh l ni nj">@ExtendWith(<br/>    MockitoExtension::class, //Mockito have extensions<br/>    InstantExecutorExtension::class <br/>//Android have only rule, but rewrite it as extension is dead simply<br/>)</span><span id="7709" class="mf li in nc b gy no nh l ni nj">//Here you have extension<br/>class InstantExecutorExtension : <br/>BeforeEachCallback, AfterEachCallback {<br/>    override fun beforeEach(context: ExtensionContext?) {<br/>        ArchTaskExecutor.getInstance()<br/>            .setDelegate(<br/>                object : TaskExecutor() {<br/>                    override fun executeOnDiskIO(runnable: Runnable<br/>                         = runnable.run()<br/>                    override fun postToMainThread(runnable:Runnable)                         <br/>                         = runnable.run()<br/>                    override fun isMainThread(): Boolean = true<br/>                }<br/>            )<br/>    }</span><span id="9c69" class="mf li in nc b gy no nh l ni nj">    override fun afterEach(context: ExtensionContext?) {<br/>        ArchTaskExecutor.getInstance().setDelegate(null)<br/>    }<br/>}</span></pre><h2 id="42e9" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://www.spekframework.org/" rel="noopener ugc nofollow" target="_blank"> Spek </a></h2><p id="2880" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">核心概念是将测试写成嵌套的 lambdas。他们强制进行 BDD 风格的测试，这很好，但是你不需要他们来实现。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="97ba" class="mf li in nc b gy ng nh l ni nj">object MyTest: Spek({<br/>    group("a group") {<br/>        test("a test") {<br/>            ...<br/>        }<br/><br/>        group("a nested group") {<br/>            test("another test") {<br/>                ...<br/>            }<br/>        }<br/>    }<br/>})</span><span id="f2d9" class="mf li in nc b gy no nh l ni nj">object SetFeature: Spek({<br/>    Feature("Set") {<br/>        val set by memoized { mutableSetOf&lt;String&gt;() }<br/><br/>        Scenario("adding items") {<br/>            When("adding foo") {<br/>                set.add("foo")<br/>            }<br/><br/>            Then("it should have a size of 1") {<br/>                assertEquals(1, set.size)<br/>            }<br/><br/>            Then("it should contain foo") {<br/>                assertTrue(set.contains("foo"))<br/>            }<br/>        }</span></pre><h2 id="37dd" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://kotest.io/" rel="noopener ugc nofollow" target="_blank"> Kotest </a></h2><p id="ef83" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">与上面的非常相似，但是 Kotest 给了你更多的可能性。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="64f2" class="mf li in nc b gy ng nh l ni nj">class MyTests : StringSpec({<br/>    "strings.length should return size of string" {<br/>        "hello".length shouldBe 5<br/>    }<br/>})</span><span id="ed76" class="mf li in nc b gy no nh l ni nj">class MyTests : BehaviorSpec({<br/>    given("a broomstick") {<br/>        `when`("I sit on it") {<br/>            then("I should be able to fly") {<br/>                // test code<br/>            }<br/>        }<br/>        `when`("I throw it away") {<br/>            then("it should come back") {<br/>                // test code<br/>            }<br/>        }<br/>    }<br/>})</span></pre><p id="327d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能的测试样式列表:<br/>* Fun Spec:ScalaTest<br/>* Describe Spec:Javascript frameworks 和 RSpec<br/>* Should Spec:A Kotest original<br/>* String Spec:A Kotest original<br/>* Behavior Spec:BDD frameworks<br/>* Free Spec Spec:ScalaTest<br/>* Word Spec:ScalaTest<br/>* Feature Spec:cumber<br/>* Expect Spec Spec:A Kotest original<br/>* Annotation Spec:JUnit</p><h1 id="13b0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2)模拟</h1><h2 id="0c3b" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank">莫奇托</a></h2><p id="ba5c" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">最流行的嘲笑事物的工具。<strong class="jx io">用 Java </strong>编写，但仍然是一个非常好的工具，即使是在 Koltin 项目中。对于 Kotlin，你也有一个小助手库 Mockito-Kotlin，它允许你用<code class="fe nl nm nn nc b">whenever</code>:<br/><a class="ae mr" href="https://github.com/nhaarman/mockito-kotlin" rel="noopener ugc nofollow" target="_blank">https://github.com/nhaarman/mockito-kotlin<br/></a>替换你的`<code class="fe nl nm nn nc b">when</code>,它有你需要的一切。差不多了。这只是 Java Libray 的一个覆盖，它不支持 Kotlin 多平台。前一段时间，我在使用<code class="fe nl nm nn nc b">suspend</code>功能时也遇到了一些问题。如果你想和协程一起使用，请查看 GitHub 上的<a class="ae mr" href="https://github.com/mockito/mockito-kotlin/issues" rel="noopener ugc nofollow" target="_blank">问题。</a></p><p id="ae06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当您在项目中使用协程时，如果您想使用 Kotlim 多平台，最好选择 MockK。</p><h2 id="c8be" class="mf li in bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated"><a class="ae mr" href="https://mockk.io/" rel="noopener ugc nofollow" target="_blank">莫克</a></h2><p id="f8d2" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">这也是一个非常好的嘲讽工具，但是纯粹是用 Kotlin 语言写的。与 Mockito 相比，MockK 有两个主要优势:</p><ol class=""><li id="6fd6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">100%支持<code class="fe nl nm nn nc b">suspend</code>功能支持</li><li id="040b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用 Kotlin 多平台</li></ol><p id="8da4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于以上原因，我选择它作为新 Kotlin 项目中的默认嘲讽工具。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="2ea3" class="mf li in nc b gy ng nh l ni nj">val mock = mockk&lt;ObjectToMock&gt;()<br/>every <strong class="nc io">{ </strong>mock.function() <strong class="nc io">} </strong>returns value //simple mock<br/>coEvery <strong class="nc io">{ </strong>mock.suspendFunction() <strong class="nc io">} </strong>returns value //suspend mock</span></pre><h1 id="24c6" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3)断言</h1><p id="9324" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">可能的库列表:</p><p id="2384" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://kotest.io/docs/assertions/assertions.html" rel="noopener ugc nofollow" target="_blank">Kotest</a>——是的，这个来自框架，也有一个独立的断言库。这是最受欢迎的。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6425" class="mf li in nc b gy ng nh l ni nj">name shouldBe "sam"<br/>user.name shouldNotBe <strong class="nc io">null</strong></span></pre><p id="2e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://markusamshove.github.io/Kluent/" rel="noopener ugc nofollow" target="_blank">Kluent</a>——和上面那个很像，第二受欢迎。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6c54" class="mf li in nc b gy ng nh l ni nj">"hello" shouldBeEqualTo "hello"<br/>"hello" shouldNotBeEqualTo "world"</span></pre><p id="919d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://strikt.io/" rel="noopener ugc nofollow" target="_blank"> Strikt </a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8512" class="mf li in nc b gy ng nh l ni nj">expectThat(subject)<br/>    .hasLength(35)<br/>    .matches(Regex("[\\w\\s]+"))<br/>    .startsWith("T")</span></pre><p id="1da6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/robstoll/atrium" rel="noopener ugc nofollow" target="_blank">中庭</a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="ef12" class="mf li in nc b gy ng nh l ni nj">expect(x).toBe(9)</span></pre><p id="6c38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/npryce/hamkrest" rel="noopener ugc nofollow" target="_blank">火腿蛋糕</a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d109" class="mf li in nc b gy ng nh l ni nj">assertThat("xyzzy", <br/>    startsWith("x") and endsWith("y") and !containsSubstring("a")<br/>)</span></pre><p id="3e08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="http://winterbe.github.io/expekt/" rel="noopener ugc nofollow" target="_blank"> Expekt </a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="2489" class="mf li in nc b gy ng nh l ni nj">23.should.equal(23)<br/>“Kotlin”.should.not.contain(“Scala”)<br/>listOf(1, 2, 3).should.have.size.above(1)</span></pre><p id="ece7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://www.kotlinresources.com/library/assertk/" rel="noopener ugc nofollow" target="_blank">资产者</a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="cf8a" class="mf li in nc b gy ng nh l ni nj">assertThat(person.name).isEqualTo(“Alice”)</span></pre><p id="aa35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我最大的问题是选择什么。就我个人而言，我喜欢 Kotest 的方法，它看起来很好，也很受欢迎。依我看，所有这些都是个人喜好的问题。</p><h1 id="8d89" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">摘要</h1><p id="e979" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">我希望我帮助您快速浏览了 Kotlin 中可能的测试工具。我使用 JUnit5 和带有 Kotest 的 MockK 作为断言库。<br/>你在项目中使用什么或者你想尝试什么？</p><p id="9fc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">加入我的<strong class="jx io">代码端</strong>！<br/>万事如意，<br/>阿图尔</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="1861" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk">最初发表于 2020 年的</em><a class="ae mr" href="https://www.thecodeside.com/2020/10/13/testing-tools-for-kotlin-quick-recap-in-2020/" rel="noopener ugc nofollow" target="_blank"><em class="nk"/></a>，但这次没有太大变化。</p></div></div>    
</body>
</html>