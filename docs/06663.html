<html>
<head>
<title>Painless &amp; Powerful -Nx/Next/Keystone/GraphQL/Prisma2/Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无痛且强大——Nx/Next/Keystone/graph QL/prisma 2/Postgres</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/painless-powerful-nx-nest-keystone-graphql-prisma2-postgres-139805eee2b?source=collection_archive---------4-----------------------#2022-01-24">https://blog.devgenius.io/painless-powerful-nx-nest-keystone-graphql-prisma2-postgres-139805eee2b?source=collection_archive---------4-----------------------#2022-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b1e66d29b69fda401fd6562cdeac4b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C7WDXdDJlhis-Wcn"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">阿瑟尼·托古列夫在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="302d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，对于一个博客标题来说，这是很多技术词汇——但是，嘿，它把你带到了这里，对吗？因此，让我告诉你如何让一个强大的单一定义模型系统与这个技术堆栈一起运行。</p><p id="7812" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">早些时候我在这里写了关于使用 Nx/Prisma &amp; GraphQL <a class="ae jz" href="https://javascript.plainenglish.io/nx-nest-prisma-graphql-single-data-model-definition-e601eaa372c6" rel="noopener ugc nofollow" target="_blank">的文章</a> : <a class="ae jz" href="https://javascript.plainenglish.io/nx-nest-prisma-graphql-single-data-model-definition-e601eaa372c6" rel="noopener ugc nofollow" target="_blank">让我们创建下一个，Nx，GraphQL，Prisma 单一数据模型定义</a>——这篇文章是对那篇文章的更新/替换。</p><p id="5247" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将分享我如何通过将一个新的技术堆栈元素(<a class="ae jz" href="https://keystonejs.com/" rel="noopener ugc nofollow" target="_blank"> KeystoneJS v6 </a>)分层来改进我早期的方法，该元素处理大量繁重的工作，并为数据管理提供了一个很好的起点。我倾向于编写大量的公司内部应用程序来管理信息和知识，下面概述的方法使我能够更灵活、更快速地进行操作和开发。</p><h1 id="92a3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">第 1 部分:设置</strong></h1><p id="a436" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">本节将涵盖:</p><ul class=""><li id="f2de" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">生成 Nx 工作空间</li><li id="e613" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">在 docker 中调出 postgres DB 实例</li><li id="e07f" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">在您的 Nx 工作空间中生成一个 NextJS 应用程序</li></ul><p id="2067" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第 2 部分介绍了 KeystoneJS 中的分层。</p><p id="d0f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Nx 工作空间</strong></p><p id="e813" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成一个 Nx 工作空间(或者，如果您已经有了一个工作空间，您可以跳过下一步，但我建议您使用或升级到 v13+)。有关设置 Nx mono repo 工作区的更详细信息，请参见位于<a class="ae jz" href="https://nx.dev" rel="noopener ugc nofollow" target="_blank"> Nx.dev </a>的文档。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f58d" class="my kz in mu b gy mz na l nb nc">&gt; <strong class="mu io">npx create-nx-workspace@latest</strong><br/>Need to install the following packages:<br/>  create-nx-workspace@latest<br/>Ok to proceed? (y) y<br/>✔ Workspace name (e.g., org name)     · <strong class="mu io">krispy.example</strong><br/>✔ What to create in the new workspace · <strong class="mu io">next</strong><br/>✔ Application name                    · <strong class="mu io">ksexample</strong><br/>✔ Default stylesheet format           · <strong class="mu io">css</strong><br/>✔ Use Nx Cloud? (It's free and doesn't require registration.) · <strong class="mu io">No</strong></span><span id="f789" class="my kz in mu b gy nd na l nb nc">✔ Installing dependencies with npm<br/>✔ Nx has successfully created the workspace.<br/><br/> &gt;  NX   Nx is creating your v13.5.1 workspace.</span><span id="05d9" class="my kz in mu b gy nd na l nb nc">To make sure the command works reliably in all environments, and that the preset is applied correctly,<br/>   Nx will run "npm install" several times. Please wait.</span><span id="6912" class="my kz in mu b gy nd na l nb nc">✔ Installing dependencies with npm<br/>✔ Nx has successfully created the workspace.</span></pre><p id="1935" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您已经有了一个正在使用的 Nx 工作空间，那么您可以使用以下代码生成一个 Next.js 应用程序:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="09ca" class="my kz in mu b gy mz na l nb nc">npx nx g @nrwl/next:app ksexample</span></pre><p id="6c8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你以前没有在你的工作空间中生成过 nextjs 应用程序(可能你的工作空间是为 pure node 或 express 等设置的。)那么您可能需要在您的工作区中 npm install @nrwl/next。</p><p id="6cf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">在 Docker 中运行 Postgres 实例</strong></p><p id="aae2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了有效地使用 keystone，postgres db 应该在某个地方运行。在本地，docker 实例是最快的方法。稍后，在生产环境中，您可能会在另一个云提供商上使用 GCP 云 SQL (postgres)或同等工具，但这超出了本文的讨论范围。</p><p id="c288" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用卷装载运行 postgres 的本地 docker 实例，以在实例重新启动之间保存数据。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dd38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">postgres 的连接字符串(示例)—您将在第 2 部分中使用它—显然您应该使用不同的用户名/密码。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8af6" class="my kz in mu b gy mz na l nb nc">postgres://app_admin:sup3rs3cr3t@localhost:11032/app_db</span></pre><p id="f0d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时，您应该有一个 docker 实例正在运行，并且有一个生成了 Next.js 应用程序的 Nx 工作空间可供使用。这两件事之间还没有联系(这将在第 2 部分中介绍)。您可以通过执行以下命令来验证您的 next.js 应用程序是否正确生成:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1433" class="my kz in mu b gy mz na l nb nc">npx nx serve ksexample</span></pre><p id="2a22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行此操作应该会在您的终端中显示以下内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3b88" class="my kz in mu b gy mz na l nb nc">&gt; <strong class="mu io">nx run ksexample:serve</strong></span><span id="3cc9" class="my kz in mu b gy nd na l nb nc">We detected TypeScript in your project and reconfigured your tsconfig.json file for you. Strict-mode is set to false by default.</span><span id="ff5b" class="my kz in mu b gy nd na l nb nc">The following suggested values were added to your tsconfig.json. These values can be changed to fit your project's needs:</span><span id="9eff" class="my kz in mu b gy nd na l nb nc">- incremental was set to true</span><span id="7857" class="my kz in mu b gy nd na l nb nc">info  - automatically enabled Fast Refresh for 1 custom loader<br/>event - compiled client and server successfully in 2.3s (173 modules)<br/>[ ready ] on <a class="ae jz" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank">http://localhost:4200</a></span></pre><p id="6c8f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在浏览器中访问<a class="ae jz" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>应该会显示默认生成的下一个应用。如果这对您有用，那么是时候继续第 2 部分了，我们将在第 2 部分中加入 KeystoneJS headless CMS。</p><h1 id="b217" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第 2 部分:密钥(Keystone 应用生成和配置)</h1><p id="b081" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为什么选择 KeystoneJS，它到底能为我们做什么？</p><p id="0535" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://keystonejs.com/" rel="noopener ugc nofollow" target="_blank"> KeystoneJS </a>是(在撰写本文时，v6 刚刚发布)一款成熟的无头 CMS，它结合了<a class="ae jz" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>、GraphQL 和<a class="ae jz" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next </a>来提供一个强大的系统，您可以在其上快速构建数据/信息应用程序。它通过为开发人员提供在单一位置以编程方式指定模型定义的能力来实现这一点，它生成 prisma 模式，管理数据库迁移(是的，如果您已经有了数据库模式，它还具有自省功能)，生成具有 ACL 支持的数据管理，并在开箱即用的 graphql 模式中生成数据模型的 ORM 排列。</p><p id="35fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在文章的这一部分，我们将在之前生成的 NextJs 应用程序中生成一个 Keystone 层。</p><p id="ed89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong> : <em class="ng"> KeystoneJS 应用程序可以独立于现有的 NextJS 应用程序生成——您可以使用 KeystoneJS 构建一个完整的应用程序，而无需 Nx 或本文中提到的其他东西</em>。</p><p id="a7f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤 1:在终端 cd 中，从 Nx 工作区的根目录进入 apps/ksexample 目录。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e1ed" class="my kz in mu b gy mz na l nb nc">cd apps/ksexample</span></pre><p id="3bc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第 2 步:在 apps/ksexample 目录下创建一个 package.json，内容如下</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="785d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三步:在<code class="fe nh ni nj mu b">apps/ksexample</code>目录下创建一个<code class="fe nh ni nj mu b">keystone.ts</code>文件，内容如下。注意:这是我们使用前面的 postgres 连接字符串的地方:<code class="fe nh ni nj mu b">postgres://app_admin:sup3rs3cr3t@localhost:11032/app_db</code>参见 config 对象中的 url 属性。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1bf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦创建了这两个文件(<code class="fe nh ni nj mu b">package.json</code>和<code class="fe nh ni nj mu b">keystone.ts</code>)并且运行了 postgres docker 容器。在<code class="fe nh ni nj mu b">apps/ksexample</code>目录中，在您的终端中执行一个<code class="fe nh ni nj mu b">npm i</code>。您的终端输出应该如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="21a9" class="my kz in mu b gy mz na l nb nc">npm i</span><span id="c58c" class="my kz in mu b gy nd na l nb nc">&gt; ksexmple@1.0.0 postinstall<br/>&gt; keystone postinstall</span><span id="d921" class="my kz in mu b gy nd na l nb nc">Your Prisma and GraphQL schemas are not up to date<br/>✔ Would you like to update your Prisma and GraphQL schemas? … yes<br/>✨ GraphQL and Prisma schemas are up to date</span><span id="dddd" class="my kz in mu b gy nd na l nb nc">up to date, audited 708 packages in 13s</span></pre><p id="f2a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤 4:将 keystone 添加到 next.js 配置中</p><p id="cc5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编辑<code class="fe nh ni nj mu b">apps/ksexample </code>目录中的<code class="fe nh ni nj mu b">next.config.js</code>文件，如下所示:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8d2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个<code class="fe nh ni nj mu b">&lt;workspace&gt;/apps/ksexample/.gitignore</code>文件并添加:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1d4b" class="my kz in mu b gy mz na l nb nc">.keystone<br/>node_modules</span></pre><p id="c4c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们需要修改<code class="fe nh ni nj mu b">apps/ksexample directory</code>中的<code class="fe nh ni nj mu b">project.json</code>文件。请注意添加的两个目标“<code class="fe nh ni nj mu b">keystone</code>”和“<code class="fe nh ni nj mu b">devserve</code>”:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0af5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">严格地说，你不需要这两个目标——“梯形”目标就足够了。我将“devserve”目标作为替代方法的一个例子。</p><p id="39ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你猜怎么着，你现在可以运行应用程序了，keystone + ksexample 将会启动。从工作区根目录在终端中执行以下操作。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d21f" class="my kz in mu b gy mz na l nb nc">npx nx keystone ksexample</span></pre><p id="7b4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该会看到类似于以下内容的输出:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e047" class="my kz in mu b gy mz na l nb nc">npx nx keystone ksexample</span><span id="f43d" class="my kz in mu b gy nd na l nb nc">&gt; nx run ksexample:keystone</span><span id="f627" class="my kz in mu b gy nd na l nb nc">&gt; ksexmple@1.0.0 postinstall<br/>&gt; keystone postinstall</span><span id="8146" class="my kz in mu b gy nd na l nb nc">✨ GraphQL and Prisma schemas are up to date</span><span id="1879" class="my kz in mu b gy nd na l nb nc">&gt; ksexmple@1.0.0 dev<br/>&gt; npx next dev</span><span id="d953" class="my kz in mu b gy nd na l nb nc">ready - started server on 0.0.0.0:3000, url: <a class="ae jz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>✨ Generated GraphQL and Prisma schemas<br/>event - compiled client and server successfully in 520 ms (127 modules)<br/>✨ Starting Keystone<br/>⭐️ Dev Server Starting on <a class="ae jz" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a><br/>⭐️ GraphQL API Starting on <a class="ae jz" href="http://localhost:8000/api/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/graphql</a><br/>✨ Generating GraphQL and Prisma schemas<br/>✨ The database is already in sync with the Prisma schema.<br/>✨ Connecting to the database<br/>✨ Creating server<br/>✅ GraphQL API ready<br/>✨ Generating Admin UI code<br/>✨ Preparing Admin UI app<br/>event - compiled client and server successfully in 3.7s (960 modules)<br/>✅ Admin UI ready<br/>wait  - compiling /api/__keystone_api_build...<br/>event - compiled client and server successfully in 244 ms (973 modules)</span></pre><p id="2d69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时，您可以访问<a class="ae jz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>并查看下一个正在运行的应用程序，您也可以访问<a class="ae jz" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>正在运行。这些还没有完全与数据联系起来，但我们将从 Keystonejs.com 提供的例子中借用(此处<a class="ae jz" href="https://keystonejs.com/docs/walkthroughs/embedded-mode-with-sqlite-nextjs" rel="noopener ugc nofollow" target="_blank">为</a>)。在本文中，我们不会深入探讨 keystone 的建模方面，但是这个例子应该清楚地表明它有多么强大，因为您可以使用在 nextjs 应用程序代码中定义的 keystone 模型中生成的所有模型。</p><p id="babb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关闭正在运行的实例(终端中的 ctl+c)。</p><p id="6fda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<code class="fe nh ni nj mu b">apps/ksexample/pages/index.tsx</code>编辑成:<br/>注意:下面的代码是直接从 Keystone 教程<a class="ae jz" href="https://keystonejs.com/docs/walkthroughs/embedded-mode-with-sqlite-nextjs" rel="noopener ugc nofollow" target="_blank">这里</a>复制过来的。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f3fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建新文件:<code class="fe nh ni nj mu b">apps/ksexample/pages/post/[slug].tsx</code></p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8edc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重新启动开发服务器:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9e75" class="my kz in mu b gy mz na l nb nc">npx nx keystone ksexample</span></pre><p id="62d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在转到<a class="ae jz" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>创建一个帖子记录(当然也可以创建多个帖子)。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/a01553846c87b0c4cf6474289742e01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Pq-6IVLVoQQ1G0JzfEDfQ.png"/></div></div></figure><p id="8826" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦您创建了至少一个，请访问<a class="ae jz" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000。</a></p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/436cf0c46d2bea3a230a851814c836cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*CS4d_ilzB1P-YHqbT0HYbg.png"/></div></figure><p id="4f8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击你的文章标题会显示内容:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5c6f41c6d4abad12bfe1b19bd6919509.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*Rd9CQ5LS_5UxepSzCO7iuw.png"/></div></figure><h1 id="ade1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第 3 部分:为什么这很有用</h1><p id="cd33" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在这个示例应用的<code class="fe nh ni nj mu b">keystone.ts</code>中，我们定义了一个简单的模型。这篇文章已经很长了，所以下次我会更深入地解释可以实现的更复杂的建模。现在，让我们看看 Keystone 和 GraphQL 的开箱即用——我们在 Nx/Next 应用程序中分层的东西。</p><p id="4472" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你的应用服务器还在运行，尝试访问<a class="ae jz" href="http://localhost:8000/api/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/API/graph QL</a></p><p id="1e77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该会看到一个 GraphQL 沙箱，您可以用它做一些显而易见的事情:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/ca77584780aca9e43fcf6dfa205e6907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ecEjFVq9IPtQpHcA33TBQA.png"/></div></div></figure><p id="e0fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，很标准的东西。但是请注意，我们不需要显式设置 GraphQL 绑定。还要注意，从开发人员设置的角度来看，这要简单得多。我去年写的方法需要更多复杂的配置。</p><p id="39df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尝试运行这种查询:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4364" class="my kz in mu b gy mz na l nb nc">{<br/>  posts(where:{title:{startsWith:"Testing"}}) {<br/>    id<br/>    title<br/>    slug<br/>    content<br/>  }<br/>}</span></pre><p id="ee9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，我们得到了 where 子句！还有更多。想点成绩？</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="faf5" class="my kz in mu b gy mz na l nb nc">{<br/>  posts(orderBy:{id:desc}) {<br/>    id<br/>    title<br/>    slug<br/>    content<br/>  }<br/>}</span></pre><p id="6b8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也许你只想要一个结果？</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="330b" class="my kz in mu b gy mz na l nb nc">{<br/>  posts(take:1) {<br/>    id<br/>    title<br/>    slug<br/>    content<br/>  }<br/>}</span></pre><p id="9580" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者跳过一些结果？</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="748c" class="my kz in mu b gy mz na l nb nc">{<br/>  posts(skip:1) {<br/>    id<br/>    title<br/>    slug<br/>    content<br/>  }<br/>}</span></pre><p id="86b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，您也可以将这些结合起来:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="92e2" class="my kz in mu b gy mz na l nb nc">{<br/>  posts(where:{title:{startsWith:"Testing"}}, orderBy:{id:desc} take,: 1, skip:1) {<br/>    id<br/>    title<br/>    slug<br/>    content<br/>  }<br/>}</span></pre><p id="1a94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的要点是，通过使用 Keystone 及其所有特性，您可以获得巨大的收益。使用 keystone DSL 进行数据建模会生成一个 prisma ORM 层，您不需要接触它。GraphQL 模式生成得到了扩展，可以用所有标准类型的过滤和查询/变异支持来映射您的模型——您不再需要手动检查这些样板文件，也不需要担心如何生成它。</p><p id="ecc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将 Keystone 填充到 NextJS 应用程序中，可以在您的“后端”和前端之间利用相同的模型定义和数据访问，而无需进行端口映射等。现在，如果您的数据模型发生变化，您将知道它是否破坏了您的前端。</p><h1 id="5e79" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包扎</h1><p id="3cd0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本文中，我们生成了一个 Nx 工作区，生成了一个 NextJS 应用程序，在 docker 中引导了一个 Postgres 12 db，在 Keystone 中填充了一个数据建模和管理应用程序层，在后端和前端之间共享了一个模型，在 Nx 构建和服务管道中进行了连接。关于 Keystone 强大的建模功能，还有更多的内容需要介绍。我希望现在对你来说很明显——如果这在某种程度上对你有所帮助，我总是感谢一两次鼓掌。</p><p id="2ff8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我有更多的时间时，我计划写一些更复杂的建模，这些建模已经在使用这种技术堆栈构建的几个应用程序中运行。让我在评论中知道什么样的模型会有帮助，我会尝试去涵盖这些。</p></div></div>    
</body>
</html>