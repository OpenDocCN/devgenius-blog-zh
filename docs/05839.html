<html>
<head>
<title>A Step By Step Guide to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的逐步指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-step-by-step-guide-to-kubernetes-4524dad98d2a?source=collection_archive---------2-----------------------#2021-11-08">https://blog.devgenius.io/a-step-by-step-guide-to-kubernetes-4524dad98d2a?source=collection_archive---------2-----------------------#2021-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="85b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本帖中，我们将讨论如何使用Kubernetes以及如何在Kubernetes集群中部署您的微服务。我将介绍基本原理，因此如果您是初学者，这将是学习Kubernetes的一个很好的分步指南。因为我们将构建一个docker化的容器应用程序，你可以从使用docker-compose 的完整指南<a class="ae ki" href="https://betterjavacode.com/docker/the-complete-guide-to-use-docker-compose" rel="noopener ugc nofollow" target="_blank">开始。</a></p><h1 id="7486" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">什么是Kubernetes？</h1><p id="ee9d" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">根据<a class="ae ki" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank">原始来源</a> — <em class="lm"> Kubernetes是一个用于自动化部署、扩展和管理容器化应用的开源系统。Kubernetes是一个容器编排平台。</em></p><p id="c62f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，一旦有了容器化的应用程序，就可以在Kubernetes集群上部署它。具体来说，集群包含多台机器或服务器。</p><p id="fd2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在传统的Java应用程序中，人们会构建一个jar文件并将其部署在服务器上。有时，甚至在多台机器上部署相同的应用程序来进行水平扩展。最重要的是，有了Kubernetes，您不必担心服务器机器。显然，Kubernetes允许创建一个机器集群，并在其上部署容器化的应用程序。</p><p id="3c69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，使用Kubernetes，您可以</p><ul class=""><li id="6e8a" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated">跨多台主机协调容器</li><li id="8262" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">控制和自动化应用程序部署</li><li id="5e42" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">更好地管理服务器资源</li><li id="70d1" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">通过自动放置、自动重启、自动复制和自动扩展，对您的应用进行运行状况检查和自我修复</li></ul><p id="090c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，Kubernetes集群包含两个部分</p><p id="c286" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具体来说，节点(物理机或虚拟机)使用Kubernetes API与控制平面进行交互。</p><ul class=""><li id="5e3f" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jm io">控制平面</strong> —控制Kubernetes节点的进程集合。</li><li id="5f71" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jm io">节点</strong> —执行通过流程分配的任务的机器。</li><li id="29c3" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jm io"> Pod </strong> —部署在单个节点上的一组一个或多个容器。pod上的所有容器共享资源和IP地址。</li><li id="fd99" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jm io">服务</strong> —一种将运行在一组pod上的应用程序公开为网络服务的抽象方式。</li><li id="2886" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jm io">kube let</strong>—kube let是在每个节点上运行的主节点代理。它读取容器清单并跟踪容器的启动和运行。</li><li id="2471" class="ln lo in jm b jn lw jr lx jv ly jz lz kd ma kh ls lt lu lv bi translated">kube CTL—Kubernetes的命令行配置工具</li></ul><h1 id="a162" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">如何创建集群？</h1><p id="2fb7" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">此后，根据您的环境，下载<a class="ae ki" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>。我使用的是Windows环境。</p><p id="b368" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将创建一个新的Kubernetes集群。</p><p id="89b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果您想查看更详细的仪表板，您可以使用命令<code class="fe mb mc md me b">minikube dashboard</code>。该命令将在浏览器中启动Kubernetes仪表板。(<a class="ae ki" href="http://127.0.0.1:60960/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/)" rel="noopener ugc nofollow" target="_blank">T11】http://127 . 0 . 0 . 1:60960/API/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/)</a></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/1fce3022ff1091cbebf64e3ece403cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*F1lrXBGIVyBFXyvk"/></div></figure><h1 id="5be5" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">向Kubernetes部署微服务的演示</h1><h2 id="7ba5" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">创建容器化的微服务</h2><p id="c4f4" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">此外，让我们创建一个简单的微服务，我们最终将在集群中部署它。我将使用Spring Boot创建一个微服务，为REST API调用返回产品列表。</p><p id="f137" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该微服务将在通话中返回产品列表。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="1c7d" class="mn kk in me b gy nd ne l nf ng">package com.betterjavacode.kubernetesdemo.controllers;<br/><br/>import com.betterjavacode.kubernetesdemo.dtos.ProductDTO;<br/>import com.betterjavacode.kubernetesdemo.services.ProductService;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>import java.util.List;<br/><br/>@RestController<br/>@RequestMapping("/v1/products")<br/>public class ProductController<br/>{<br/>    @Autowired<br/>    public ProductService productService;<br/><br/>    @GetMapping<br/>    public List getAllProducts()<br/>    {<br/>        return productService.getAllProducts();<br/>    }<br/>}</span></pre><p id="34bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，<code class="fe mb mc md me b">ProductService</code>将有一个返回所有产品的方法。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="4e77" class="mn kk in me b gy nd ne l nf ng">package com.betterjavacode.kubernetesdemo.services;<br/><br/>import com.betterjavacode.kubernetesdemo.dtos.ProductDTO;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@Component<br/>public class ProductService<br/>{<br/><br/>    public List getAllProducts ()<br/>    {<br/>        List productDTOS = new ArrayList&lt;&gt;();<br/><br/>        ProductDTO toothbrushProductDTO = new ProductDTO("Toothbrush", "Colgate", "A toothbrush " +<br/>                "for " +<br/>                "all");<br/>        ProductDTO batteryProductDTO = new ProductDTO("Battery", "Duracell", "Duracell batteries " +<br/>                "last long");<br/><br/>        productDTOS.add(toothbrushProductDTO);<br/>        productDTOS.add(batteryProductDTO);<br/>        return productDTOS;<br/><br/>    }<br/>}</span></pre><p id="25f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我故意不使用任何数据库，而是使用一个静态的产品列表来进行演示。</p><p id="2e4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在构建docker映像之前，运行</p><p id="9004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">minikube docker-env</code>T3】</p><h2 id="32a7" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">构建docker映像</h2><p id="4cba" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们为刚刚创建的微服务构建一个<a class="ae ki" href="https://betterjavacode.com/docker/the-complete-guide-to-use-docker-compose" rel="noopener ugc nofollow" target="_blank"> docker </a>映像。首先，在项目的根目录下创建一个dockerfile。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="9bda" class="mn kk in me b gy nd ne l nf ng">FROM openjdk:8-jdk-alpine <br/>VOLUME /tmp COPY ./build/libs/*.jar app.jar <br/>ENTRYPOINT ["java", "-jar", "/app.jar"]</span></pre><p id="722a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们使用这个docker文件构建一个docker映像。</p><p id="2ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">docker build -t kubernetesdemo .</code></p><p id="a198" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将创建一个带有最新标签的<code class="fe mb mc md me b">kubernetesdemo</code> docker图像。</p><p id="c1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想在您的本地环境中试验这个映像，您可以使用以下命令运行它:</p><p id="bef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">docker run --name kubernetesdemo -p 8080:8080 kubernetesdemo</code></p><p id="449f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在端口8080上运行我们的<a class="ae ki" href="https://betterjavacode.com/programming/revisiting-docker-how-to-use-docker-container-in-ecs" rel="noopener ugc nofollow" target="_blank">微服务Docker映像</a>。无论如何，在部署到kubernetes之前，我们需要将这个docker映像推送到docker hub容器注册中心，以便Kubernetes可以从hub中提取。</p><p id="22b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">docker login</code> -使用您的用户名和密码从终端登录docker hub。</p><p id="0197" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦登录成功，我们需要为docker图像创建一个标签。</p><p id="8775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">docker tag kubernetesdemo username/kubernetesdemo:1.0.0</code>。</p><p id="e0c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用您的docker hub用户名。</p><p id="4018" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将使用以下命令将该映像推送到docker hub:</p><p id="b586" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">docker push username/kubernetesdemo:1.0.0</code>。</p><p id="ffad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们的docker图像在容器注册表中。</p><h2 id="1ec1" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">Kubernetes部署</h2><p id="f61b" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Kubernetes是一个容器编排器，旨在运行考虑到可伸缩性的复杂应用程序。</p><p id="621f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器编排器管理服务器周围的容器。这就是简单的定义。如前所述，我们将使用以下命令在windows机器上创建一个本地集群</p><p id="4252" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">minikube start</code>。</p><p id="c933" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦集群启动，我们可以使用命令查看集群信息</p><p id="cd65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">kubectl get cluster-info</code>。</p><p id="c151" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，为了在Kubernetes中部署我们的微服务，我们将使用声明式接口。</p><h2 id="f0da" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">声明部署文件</h2><p id="bf25" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在你的项目根目录下创建一个<code class="fe mb mc md me b">kube</code>目录。添加一个名为<code class="fe mb mc md me b">deployment.yaml</code>的<code class="fe mb mc md me b">yaml</code>文件。</p><p id="48b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该文件将如下所示:</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="d379" class="mn kk in me b gy nd ne l nf ng">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: kubernetesdemo<br/>spec:<br/>  selector:<br/>    app: kubernetesdemo<br/>  ports:<br/>    - port: 80<br/>      targetPort: 8080<br/>  type: LoadBalancer<br/><br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: kubernetesdemo<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: kubernetesdemo<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: kubernetesdemo<br/>    spec:<br/>      containers:<br/>      - name: kubernetesdemo<br/>        image: username/kubernetesdemo:1.0.0<br/>        imagePullPolicy: IfNotPresent<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="ceae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很快，我们将检查这个部署文件的每个部分。</p><p id="3566" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们运行这个部署文件，它将创建一个容器和一个服务。我们先来看<code class="fe mb mc md me b">Deployment</code>。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="2f32" class="mn kk in me b gy nd ne l nf ng">apiVersion: apps/v1 kind: Deployment <br/>metadata: <br/>  name: kubernetesdemo</span></pre><p id="ee87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这几行声明我们使用版本v1和名称<code class="fe mb mc md me b">kubernetesdemo</code>创建了一个类型<code class="fe mb mc md me b">Deployment</code>的资源。</p><p id="79cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">replicas: 3</code>表示我们正在运行容器的3个副本。但是这里的容器只不过是一个豆荚。pod是包裹容器的包装材料。单个pod可以运行多个容器，而这些容器共享pod的资源。请记住，pod是Kubernetes中最小的部署单位。</p><p id="a1b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">template.metadata.labels</code>定义了运行应用程序<code class="fe mb mc md me b">kubernetesdemo</code>容器的pod的标签。</p><p id="c17a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">containers</code>的部分是不言自明的。如果不清楚，这就是我们声明我们计划在pod中运行的容器的地方。容器的名称<code class="fe mb mc md me b">kubernetesdemo</code>和该容器的图像为<code class="fe mb mc md me b">username/kubernetesdemo:1.0.0</code>。我们将公开这个容器的端口8080，我们的微服务将在这里运行。</p><h2 id="1f31" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">服务定义</h2><p id="4c17" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在，让我们来看看这个部署文件的前面部分。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="2cf3" class="mn kk in me b gy nd ne l nf ng">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: kubernetesdemo<br/>spec:<br/>  selector:<br/>    app: kubernetesdemo<br/>  ports:<br/>    - port: 80<br/>      targetPort: 8080<br/>  type: LoadBalancer</span></pre><p id="e2e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们正在创建一个类型为<code class="fe mb mc md me b"> Service</code>的资源。</p><p id="d167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务允许pod与其他pod通信。但是它也允许外部用户访问pod。没有服务，你就不能进入豆荚。我们在这里定义的服务类型将允许我们将流量转发到特定的pod。</p><p id="452d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此声明中，<code class="fe mb mc md me b">spec.selector.app</code>允许我们选择名为<code class="fe mb mc md me b">kubernetesdemo</code>的pod。服务将暴露这个pod。到达端口80的请求将被转发到所选Pod的目标端口8080。</p><p id="8497" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，服务的类型是<code class="fe mb mc md me b">LoadBalancer</code>。基本上，在我们的Kubernetes集群中，服务将充当负载平衡器，将流量转发到不同的pods。服务确保应用程序的持续可用性。如果一个单元崩溃，另一个单元会启动，服务会确保相应地路由流量。</p><p id="8f42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务跟踪您在群集中运行的所有副本。</p><h2 id="57c8" class="mn kk in bd kl mo mp dn kp mq mr dp kt jv ms mt kx jz mu mv lb kd mw mx lf my bi translated">运行部署</h2><p id="36e3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">到目前为止，我们已经构建了一个部署配置来在集群中创建资源。但是我们还没有部署任何东西。</p><p id="8883" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要运行部署，请使用</p><p id="b1d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">kubectl apply -f deployment.yaml</code></p><p id="6efc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以直接跑</p><p id="c9e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">kubectl apply -f kube</code>它将从<code class="fe mb mc md me b">kube</code>目录中获取部署文件。</p><p id="28eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对此命令的响应将是</p><p id="072f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">service/kubernetesdemo configured<br/> deployment.apps/kubernetesdemo created</code></p><p id="7144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">kubectl get pods</code>将显示吊舱的状态</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/8503a85a89ee6ccd65cf502e9b7852c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*N9ZhOl7zsh8vocJa"/></div></figure><p id="b547" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在要查看集群和服务运行的实际情况，我们可以使用</p><p id="81f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">minikube dashboard</code>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi mf"><img src="../Images/b1411c34436a0339778845704f5ab23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*s2NmZk_Jp1YqjvU7"/></div></div></figure><p id="be25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到有3个pod在为我们的微服务<code class="fe mb mc md me b">kubernetesdemo</code>运行。</p><p id="9ea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您运行<code class="fe mb mc md me b">kubectl get services</code>，我们将看到所有的服务都在运行。现在要访问我们的应用程序，我们必须找到服务url。在这种情况下，服务(不是微服务)的名称是<code class="fe mb mc md me b">kubernetesdemo</code>。</p><p id="f6c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">minikube service kubernetesdemo --url</code>会在终端窗口显示一个URL。</p><p id="1bc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在如果使用这个URL <code class="fe mb mc md me b">http://127.0.0.1:49715/v1/products</code>，我们可以在浏览器中看到输出</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/4e4a2f5cb8a2906c76ec9be1e2749416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*DSG9cYmZi4daf3h7"/></div></figure><h1 id="c75c" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">如何缩放？</h1><p id="c83e" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">使用Kubernetes，很容易扩展应用程序。我们已经使用了3个副本，但是我们可以使用一个命令来减少或增加数量:</p><p id="3ef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">kubectl scale --replicas=4 deployment/kubernetesdemo</code>。</p><p id="cae9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您有控制面板，您将看到第4个复制副本正在启动。仅此而已。</p><h1 id="a982" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="c3b3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">哇，我们在这个演示中已经讲了很多。我希望我能够一步一步地解释Kubernetes的基本概念。如果你想了解更多，请评论这篇文章。如果你想学习Spring安全概念，你可以买我的书<a class="ae ki" href="https://yogsma.gumroad.com/l/VgSdH" rel="noopener ugc nofollow" target="_blank">简化Spring安全</a>。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="ced3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lm">原载于2021年11月8日</em><a class="ae ki" href="https://betterjavacode.com/programming/learn-kubernetes-step-by-step" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://betterjavacode.com</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>