<html>
<head>
<title>How to Implement a Binary Heap (Javascript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现二进制堆(Javascript)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-implement-a-binary-heap-javascript-d3a0c54112fa?source=collection_archive---------1-----------------------#2020-07-20">https://blog.devgenius.io/how-to-implement-a-binary-heap-javascript-d3a0c54112fa?source=collection_archive---------1-----------------------#2020-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6e7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读完这篇文章后，你会有:</p><ul class=""><li id="96e2" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">堆数据结构的坚实基础。</li><li id="ef97" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">用 javascript 实现了一个最小堆。</li></ul><p id="c9ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二进制堆</strong>是一个从头开始实现的更复杂的数据结构。话虽如此，但它被广泛应用于各种算法中，例如:</p><ul class=""><li id="49da" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">图形遍历</li><li id="4e87" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">整理</li><li id="7bd2" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">寻路</li></ul><p id="4a73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，当计算从 A 点到 b 点的最短路线时，Google Maps(我们都知道并喜欢它)使用某种类型的二进制堆。</p></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="f6b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">把二进制堆想象成一堆橘子:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/461d505bb4675fd22bf09d6e51c88395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-T7axk-IX3IgZ-BewZGlQ.jpeg"/></div></div></figure><p id="0d13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们想从一堆橘子中取出一个时，我们会抓住最上面的一个，原因有两个:</p><ol class=""><li id="3083" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lp ko kp kq bi translated">如果我们从底部抓起一个橘子，那这堆橘子就会倒塌。</li><li id="f475" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lp ko kp kq bi translated">顶部元素被认为是“最有价值的”。</li></ol><p id="caa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着我们沿着水果堆往下走，橘子的价值或 T2 优先级会降低。</p><p id="7360" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样的想法也适用于二进制堆。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/978edb08cc8b3f7915bc4a01ebded5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*xJOocKUumjmBK2SXcPHHvA.jpeg"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">最大堆</figcaption></figure><p id="a288" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与水果堆不同，二进制堆由节点组成，每个节点保存一个值，可以是数字、字符串或对象。每个节点最多有 2 个子节点(因此命名为“二进制堆”)，但如上所示，一个节点可能有 1 个子节点，也可能没有子节点。</p><p id="d33c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和以前一样，我们只能从堆中提取最顶端的元素，它被认为是<strong class="jm io">“最高优先级”</strong>。</p><p id="4e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有父节点都大于或等于子节点的堆称为<strong class="jm io">最大堆</strong>。而所有父节点都小于或等于子节点的堆被称为<strong class="jm io">最小堆</strong>。</p><p id="5ee9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要注意的是<strong class="jm io">二进制堆应该总是一个完整的二叉树</strong>。这意味着在每一层，除了可能的最后一层，所有节点都被完全填充，并且所有节点都尽可能地靠左。</p><p id="480e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整二叉树的一个例子:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lv"><img src="../Images/79498309c518e39ae04f0a0a6eab919c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALHzfY6L-0lk3OraNaqUVw.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">完全二叉树</figcaption></figure><p id="8826" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不完整二叉树的示例:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lw"><img src="../Images/d26b5d229d6009112b0796b7882859eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgU3j4zTDT0T3dLiHTWeuQ.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">不完全二叉树</figcaption></figure></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="5f22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入代码之前的最后一步是理解如何用数组表示一棵树。</p><ul class=""><li id="3c8d" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">树的根将位于数组的位置 1。</li><li id="bea8" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">在位置 n 的任何给定节点的左子节点将位于 2n。</li><li id="4d5d" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">位置 n 的节点的右子节点将位于位置 2n + 1。</li><li id="e86b" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">位置 n 处的节点的父节点在位置 n/2 处。</li></ul><p id="fb4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整二叉树的数组表示:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lx"><img src="../Images/2e594191fc332248cf47e58148e58ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmUkCk1HOhVIo8SaztTh8Q.jpeg"/></div></div></figure><pre class="le lf lg lh gt ly lz ma mb aw mc bi"><span id="aa0f" class="md me in lz b gy mf mg l mh mi">[0 ,21, 64, 3, 123, 92, 32, 8, 51, 6, 2]</span></pre><p id="2012" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mj">提示</em> </strong> <em class="mj">:一棵完整的二叉树，当表示为数组时，除了位置 0 的第一个元素外，将没有空值。</em></p><h1 id="0ea7" class="mk me in bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">二进制堆中的操作</h1><p id="67c4" class="pw-post-body-paragraph jk jl in jm b jn nh jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd nl kf kg kh ig bi translated">我们的二进制堆将支持以下两种操作:</p><ol class=""><li id="9e6f" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lp ko kp kq bi translated">插入元素。</li><li id="a543" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lp ko kp kq bi translated">提取元素。</li></ol></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><h1 id="f81e" class="mk me in bd ml mm nm mo mp mq nn ms mt mu no mw mx my np na nb nc nq ne nf ng bi translated">代码(最小堆)</h1><p id="2156" class="pw-post-body-paragraph jk jl in jm b jn nh jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd nl kf kg kh ig bi translated">现在我们明白了二叉堆也是完全二叉树。让我们仔细看看堆操作的实现。</p><p id="c93f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从定义一个 javascript 类开始:</p><pre class="le lf lg lh gt ly lz ma mb aw mc bi"><span id="980b" class="md me in lz b gy mf mg l mh mi">export class MinHeap {</span><span id="5e52" class="md me in lz b gy nr mg l mh mi">   constructor(<em class="mj">selector</em>) {</span><span id="ab2d" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.items = [];</span><span id="3022" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.selector = selector;</span><span id="0e9d" class="md me in lz b gy nr mg l mh mi">   }</span><span id="b260" class="md me in lz b gy nr mg l mh mi">   push(){}</span><span id="e1d5" class="md me in lz b gy nr mg l mh mi">   pop(){}</span><span id="b343" class="md me in lz b gy nr mg l mh mi">}</span></pre><p id="4e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，selector 是用户提供的一个函数，它应该返回存储在堆中的每个元素的值表示。这样做是为了我们以后可以比较存储的元素/对象。</p><p id="ee52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">插入</strong></p><p id="e6d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个堆中，每个元素都被插入到树中的元素处，使得它<strong class="jm io">仍然是一个完整的二叉树</strong>。</p><p id="c667" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在数组表示中，我们只需在数组末尾添加新元素。</p><p id="16aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将 8 插入最小堆的图示:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ns"><img src="../Images/844b1c514baf99272fd9fa0c2e54de7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zKZza7bLQOoe09Mp-0qyA.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">一个新的黄色节点被添加到堆中</figcaption></figure><p id="10cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们继续“冒泡”节点。这意味着我们只是与新插入节点的父节点交换，直到它的父节点小于或等于它。这保存了我们的完整二叉树，使其保持最小堆。</p><p id="6697" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插图:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nt"><img src="../Images/ad5eafddcf54849fd0a29f731f011fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmSMPMtHPvme2ml4zHeWzw.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">8 和 31 被交换，因为它是一个最小堆</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nu"><img src="../Images/fdf2b9591f743e025adda9c2dde6c19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_V8cI8__R-qxbNd3joT2g.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">15 和 8 被交换，堆属性被保留</figcaption></figure><p id="4fb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码:</p><pre class="le lf lg lh gt ly lz ma mb aw mc bi"><span id="b145" class="md me in lz b gy mf mg l mh mi">export class MinHeap {</span><span id="4ada" class="md me in lz b gy nr mg l mh mi">   constructor(<em class="mj">selector</em>) {</span><span id="2568" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.items = []; </span><span id="6939" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.selector = selector;</span><span id="369c" class="md me in lz b gy nr mg l mh mi">   }</span><span id="156b" class="md me in lz b gy nr mg l mh mi">   insert() {</span><span id="8d73" class="md me in lz b gy nr mg l mh mi">      let i = <em class="mj">this</em>.items.length;</span><span id="1ea8" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.items.push(item);<br/></span><span id="1e57" class="md me in lz b gy nr mg l mh mi">      let parentIndex = Math.floor((i + 1) / 2 - 1);<br/></span><span id="6c5a" class="md me in lz b gy nr mg l mh mi">      if (parentIndex &lt; 0) parentIndex = 0;<br/></span><span id="a68d" class="md me in lz b gy nr mg l mh mi">      let parentVal = <em class="mj">this</em>.selector(<em class="mj">this</em>.items[parentIndex]);</span><span id="ba4c" class="md me in lz b gy nr mg l mh mi">      const pushedVal = <em class="mj">this</em>.selector(<em class="mj">this</em>.items[i]);<br/></span><span id="023b" class="md me in lz b gy nr mg l mh mi">      while (i &gt; 0 &amp;&amp; parentVal &gt; pushedVal) {</span><span id="b324" class="md me in lz b gy nr mg l mh mi">         parentIndex = Math.floor((i + 1) / 2 - 1);</span><span id="49f4" class="md me in lz b gy nr mg l mh mi"><em class="mj">         this</em>.swap(i, parentIndex);</span><span id="6178" class="md me in lz b gy nr mg l mh mi">         i = parentIndex;</span><span id="45a2" class="md me in lz b gy nr mg l mh mi">         parentVal = <em class="mj">this</em>.selector(</span><span id="9d0a" class="md me in lz b gy nr mg l mh mi"><em class="mj">         this</em>.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]</span><span id="36ef" class="md me in lz b gy nr mg l mh mi">         );</span><span id="89da" class="md me in lz b gy nr mg l mh mi">      }</span><span id="b334" class="md me in lz b gy nr mg l mh mi">   }</span><span id="17eb" class="md me in lz b gy nr mg l mh mi">}</span></pre></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="1792" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">移除</strong></p><p id="8bbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，从堆中移除元素包括获取最顶层的元素，然后调整堆，以便:</p><ol class=""><li id="1c89" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lp ko kp kq bi translated">它仍然是一棵完整的二叉树。</li><li id="7cd3" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lp ko kp kq bi translated">它仍然是一个有效的最小堆。</li></ol><p id="bd77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是通过将堆中的最后一个元素放在最上面，然后“向下冒泡”以保留最小堆属性来实现的。</p><p id="b38f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">逐步说明:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nv"><img src="../Images/efc3c2dd943716c09b2ab57e95e4973e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unO3kxOQwfPj5QMyPq3xhw.jpeg"/></div></div></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nv"><img src="../Images/48968e28bf713bae34114fad8a1a358a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoFCwWoHpzPBJqh6q2lOIg.jpeg"/></div></div></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ns"><img src="../Images/c4da9b0800fcc91099a265b8c5c92d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_vU2y-lgkrUOf3jnHeIBA.jpeg"/></div></div></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nw"><img src="../Images/a34c023957ec910a4e72948c26a4b3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMPo2N9_2t7cExtF-0-PGg.jpeg"/></div></div></figure><p id="1bd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码:</p><pre class="le lf lg lh gt ly lz ma mb aw mc bi"><span id="5a3b" class="md me in lz b gy mf mg l mh mi">export class MinHeap {</span><span id="798e" class="md me in lz b gy nr mg l mh mi">   constructor(<em class="mj">selector</em>) { </span><span id="169b" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.items = [];</span><span id="0287" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.selector = selector;</span><span id="162c" class="md me in lz b gy nr mg l mh mi">   }<br/></span><span id="bc68" class="md me in lz b gy nr mg l mh mi">   remove() {</span><span id="abf6" class="md me in lz b gy nr mg l mh mi">      if (<em class="mj">this</em>.items.length &lt;= 1) return <em class="mj">this</em>.items.pop();</span><span id="4cdc" class="md me in lz b gy nr mg l mh mi">      const ret = <em class="mj">this</em>.items[0]; // What we will return</span><span id="1c32" class="md me in lz b gy nr mg l mh mi">      let temp = <em class="mj">this</em>.items.pop();</span><span id="e10a" class="md me in lz b gy nr mg l mh mi"><em class="mj">      this</em>.items[0] = temp; // Place last element in array at front</span><span id="3c68" class="md me in lz b gy nr mg l mh mi">      let i = 0; // We adjust heap from top to down<br/></span><span id="c0e9" class="md me in lz b gy nr mg l mh mi">      while (true) {</span><span id="214a" class="md me in lz b gy nr mg l mh mi">         let rightChildIndex = (i + 1) * 2;</span><span id="2970" class="md me in lz b gy nr mg l mh mi">         let leftChildIndex = (i + 1) * 2 - 1;</span><span id="2402" class="md me in lz b gy nr mg l mh mi">         let lowest = rightChildIndex;<br/></span><span id="6736" class="md me in lz b gy nr mg l mh mi">         if (</span><span id="abe7" class="md me in lz b gy nr mg l mh mi">         leftChildIndex &gt;= <em class="mj">this</em>.items.length &amp;&amp;</span><span id="fe82" class="md me in lz b gy nr mg l mh mi">         rightChildIndex &gt;= <em class="mj">this</em>.items.length</span><span id="637b" class="md me in lz b gy nr mg l mh mi">         )</span><span id="c9a3" class="md me in lz b gy nr mg l mh mi">         break;</span><span id="9d05" class="md me in lz b gy nr mg l mh mi">         if (leftChildIndex &gt;= <em class="mj">this</em>.items.length) lowest =        rightChildIndex;</span><span id="f40d" class="md me in lz b gy nr mg l mh mi">         if (rightChildIndex &gt;= <em class="mj">this</em>.items.length) lowest =    leftChildIndex;</span><span id="129c" class="md me in lz b gy nr mg l mh mi">         if (!(leftChildIndex &gt;= <em class="mj">this</em>.items.length) &amp;&amp;</span><span id="c38d" class="md me in lz b gy nr mg l mh mi">         !(rightChildIndex &gt;= <em class="mj">this</em>.items.length)</span><span id="cf49" class="md me in lz b gy nr mg l mh mi">          ) {</span><span id="d5a9" class="md me in lz b gy nr mg l mh mi">         lowest =</span><span id="f930" class="md me in lz b gy nr mg l mh mi"><em class="mj">         this</em>.selector(<em class="mj">this</em>.items[rightChildIndex]) &lt;</span><span id="6041" class="md me in lz b gy nr mg l mh mi"><em class="mj">         this</em>.selector(<em class="mj">this</em>.items[leftChildIndex])</span><span id="4350" class="md me in lz b gy nr mg l mh mi">         ? rightChildIndex</span><span id="6868" class="md me in lz b gy nr mg l mh mi">         : leftChildIndex;</span><span id="8541" class="md me in lz b gy nr mg l mh mi">         } // Find the smallest child</span><span id="a2f4" class="md me in lz b gy nr mg l mh mi">         // If the parent is greater than the smallest child: swap</span><span id="40cf" class="md me in lz b gy nr mg l mh mi">         if (<em class="mj">this</em>.selector(<em class="mj">this</em>.items[i]) &gt;                         <em class="mj">this</em>.selector(<em class="mj">this</em>.items[lowest])) {</span><span id="835e" class="md me in lz b gy nr mg l mh mi"><em class="mj">         this</em>.swap(i, lowest);</span><span id="c0b0" class="md me in lz b gy nr mg l mh mi">         i = lowest;</span><span id="1870" class="md me in lz b gy nr mg l mh mi">         } else break; // We have finished setting up the heap</span><span id="51e5" class="md me in lz b gy nr mg l mh mi">       }</span><span id="b240" class="md me in lz b gy nr mg l mh mi">   // Return topmost element</span><span id="1816" class="md me in lz b gy nr mg l mh mi">   return ret;</span><span id="ea4a" class="md me in lz b gy nr mg l mh mi">   }</span><span id="ef86" class="md me in lz b gy nr mg l mh mi">}</span></pre><p id="6cb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此之后，您可以添加其他操作来满足您的需求，例如:isEmpty()、peek()等。这些应该很容易添加。</p><p id="13c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有它！这是 javascript 中二进制堆的简单实现。</p><p id="cb9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您对严重依赖堆数据结构的应用程序感兴趣，我构建了一个在线图形算法可视化平台，您可以查看一下。<a class="ae nx" href="https://luisalfonsopreciado.github.io/Graph-Algorithms-Visualization/" rel="noopener ugc nofollow" target="_blank">链接此处</a></p></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="1784" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mj">最初发布于</em><a class="ae nx" href="https://luispreciado.blog/posts/programming/javascript/how-to-implement-a-binary-heap-javascript" rel="noopener ugc nofollow" target="_blank"><em class="mj">my blog</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>