<html>
<head>
<title>Using threads and messages to load data in a GTK4 widget</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用线程和消息在 GTK4 小部件中加载数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-threads-and-messages-to-load-data-in-a-gtk4-widget-5e1da3b0621d?source=collection_archive---------1-----------------------#2022-04-02">https://blog.devgenius.io/using-threads-and-messages-to-load-data-in-a-gtk4-widget-5e1da3b0621d?source=collection_archive---------1-----------------------#2022-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/32101adf1429718c91c1f70cb1e1e03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XRYuvZppd_lCUQoG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@raymondo600?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷·哈灵顿</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5ec5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e">教程</a>的最后一部分，在这里我们学习了如何使用<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025"> libadwaita </a>和 GTK4 编写一个非常简单的 RSS 阅读器应用程序。到目前为止，我们已经学习了很多 GTK 和用户界面的概念，每一个都以自己的方式有趣而有用。从<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-models-to-bind-data-to-gtk4-custom-widgets-in-rust-379dd9d1bf4d">数据模型</a>到<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/event-handling-for-gtk4-widgets-in-rust-d3c3f89b092f">信号</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">属性</a>，每一个工具都建立在另一个之上，创建了一个能够支持任何 UI 应用的坚实平台。</p><p id="a91b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们构建的应用程序，一个普通的未完成的 RSS 阅读器，经历了很多变化，越来越多的扩展，以至于它不能再被认为是一个有教育意义的例子。如果有人直接看这最后一篇文章的代码，他们肯定会感到困惑。这就是为什么我建议从头到尾遵循整个教程。和往常一样，这些代码可以在 github 上找到。</p><p id="23ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们让应用程序在<code class="fe lb lc ld le b">FeedList</code>小部件上处理<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/event-handling-for-gtk4-widgets-in-rust-d3c3f89b092f">点击事件</a>。当我们从<code class="fe lb lc ld le b">FeedList</code>中选择一个 RSS 提要时，我们用与<code class="fe lb lc ld le b">FeedList</code>选择相关的随机数据填充<code class="fe lb lc ld le b">ArticleList</code>。我们现在要做的是从<code class="fe lb lc ld le b">FeedList</code>选择的条目 URL 中加载实际的 RSS 数据，并在<code class="fe lb lc ld le b">ArticleList</code>中显示可用的文章。为了做到这一点，我们需要避免 UI 在加载数据时没有响应。让我们看看怎么做。</p><h2 id="e40c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">为多线程设置代码</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/1b5a6038c56b23e9be833fccf75299e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbRO2ssaYSs7NUqO4jCx7g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的适度的和迄今为止无用的 RSS 阅读器应用程序</figcaption></figure><p id="baae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们谈到了线程，因为我们试图避免在单独的线程上处理 GTK 事件。但是这一次，我们需要设置应用程序来处理这个问题，因为如果我们在主线程上发出 HTTP 请求，应用程序在等待 HTTP 调用返回时不能做任何事情。它在处理 HTTP 请求时所做的所有工作都发生在主窗口线程上，使它没有响应。这实质上意味着窗口将在等待 HTTP 调用返回时冻结。</p><p id="eeeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们开始产生线程，Rust 将开始创建越来越困难的检查，阻碍我们访问我们创建的几乎任何局部变量，包括我们对<code class="fe lb lc ld le b">FeedList</code>、<code class="fe lb lc ld le b">ArticleList</code>的引用以及我们从 HTTP 调用中获得的答案。那么这一切有什么用呢？</p><p id="35ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GTK4 提供了一种机制来避免这种情况。它被称为 MPSC 频道 API，位于<code class="fe lb lc ld le b">glib</code>机箱中。它有几个部分:第一，沟通渠道:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="7601" class="lf lg iq le b gy mh mi l mj mk">let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);</span></pre><p id="1ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，一个消息枚举来保存我们的消息类型:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="386f" class="lf lg iq le b gy mh mi l mj mk">enum Message {<br/>  UpdateArticleList(Channel),<br/>  FeedSelected(String, String),<br/>}</span></pre><p id="5f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两种类型的消息:<code class="fe lb lc ld le b">FeedSelected</code>用于通知在<code class="fe lb lc ld le b">FeedList</code>上发生了点击，而<code class="fe lb lc ld le b">UpdateArticleList</code>用于通知我们读取 RSS 数据的 HTTP 调用返回了数据。</p><p id="fce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">消息处理程序:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="4b30" class="lf lg iq le b gy mh mi l mj mk">receiver.attach(None, move |x| match x {<br/>  Message::UpdateArticleList(data) =&gt; {<br/>    let mut article_model = vec![];</span><span id="ad8f" class="lf lg iq le b gy ml mi l mj mk">    for item in data.items() {<br/>      article_model.push(<br/>        ArticleItem::new(<br/>          &amp;item.title.clone().unwrap(),    <br/>          &amp;item.description.clone().unwrap()));<br/>    }</span><span id="2e39" class="lf lg iq le b gy ml mi l mj mk">    article_list_clone.set_model(article_model);<br/>    return Continue(true);<br/>  }<br/>  Message::FeedSelected(_, url) =&gt; {<br/>    let sender_clone = sender.clone();</span><span id="9124" class="lf lg iq le b gy ml mi l mj mk">    thread::spawn(move || {<br/>      let response = Request::get(&amp;url).send().unwrap();<br/>      let body = response.body.unwrap();<br/>      let rss_content = body.as_bytes();<br/>      let rss_channel = Channel::read_from(&amp;rss_content[..]);</span><span id="81a9" class="lf lg iq le b gy ml mi l mj mk">      let _ = sender_clone.send(<br/>        Message::UpdateArticleList(rss_channel.unwrap()));<br/>    });</span><span id="00a0" class="lf lg iq le b gy ml mi l mj mk">    return Continue(true);<br/>  }<br/>});</span></pre><p id="3c0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将处理程序附加到<code class="fe lb lc ld le b">receiver</code>对象，并处理两条消息:<code class="fe lb lc ld le b">UpdateArticleList</code>接收 RSS 数据，而<code class="fe lb lc ld le b">FeedSelected</code>接收文章<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">url</code>。我们没有对文章<code class="fe lb lc ld le b">name</code>做任何事情，所以我们使用<code class="fe lb lc ld le b">_</code>丢弃了那个变量。<code class="fe lb lc ld le b">UpdateArticleList</code>处理程序简单地读取 RSS <code class="fe lb lc ld le b">items</code>数组并将它们添加到<code class="fe lb lc ld le b">article_model</code>中，然后将模型设置为<code class="fe lb lc ld le b">article_list</code>。</p><p id="d745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FeedSelected</code>处理程序正在创建一个线程，它在这个线程上向提要的 URL 发出 HTTP 请求。该请求使用<code class="fe lb lc ld le b">curio</code>板条箱。它使用<code class="fe lb lc ld le b">rss</code>箱解析接收到的 RSS 数据。你在这里看到的<code class="fe lb lc ld le b">Channel</code>结构与 MPSC 频道 API 无关，它只是一个 RSS 频道:一个 RSS 文章的容器。解析完 RSS 数据后，<code class="fe lb lc ld le b">FeedSelected</code>处理器发送一条消息，宣布我们可以更新文章列表了。</p><h2 id="7a99" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">改进的提要选择事件</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/b1f0499dcc025c8519dd4ba53aa73aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzxIHVAUAjwiDtodcV6RDg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">重构后的代码结构一瞥</figcaption></figure><p id="9998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重构了所有这些代码后，我们的<code class="fe lb lc ld le b">FeedList</code> click 事件处理程序现在简单多了:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="811b" class="lf lg iq le b gy mh mi l mj mk">let feed_model_clone = feed_model.clone();<br/>self.feed_list.connect_local("changed", false, <br/>  clone!(@strong feed_model_clone =&gt; move |values| {<br/>    let value: String = values[1].get().unwrap();<br/>    let selection = feed_model_clone.iter()<br/>      .find(|x| x.property::&lt;String&gt;("name") == value).unwrap();</span><span id="98c8" class="lf lg iq le b gy ml mi l mj mk">    let feed_name:String = selection.property::&lt;String&gt;("name");<br/>    let feed_url:String = selection.property::&lt;String&gt;("url");</span><span id="312f" class="lf lg iq le b gy ml mi l mj mk">    let _ = sender_clone<br/>      .send(Message::FeedSelected(feed_name, feed_url));</span><span id="6df5" class="lf lg iq le b gy ml mi l mj mk">    None<br/>  }),<br/>);</span></pre><p id="0353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里所做的就是获取选定的提要信息:T1 和 T2，并通过在我们的 MPSC 频道上发送消息来宣布我们有了一个新的选择。就是这样。</p><h2 id="f7b6" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">太容易了</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/c17a525c053bcef6a4e1e57001cbe97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KJqKnUbONv0_B2JU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="f28c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我让一切听起来太简单了，当然房间里有一头大象。看看那些克隆的变量。似乎每次我们想在线程或事件处理程序中使用变量时，即使它应该在本地线程上工作，我们也总是克隆变量。还有另一个奇怪的情况:如果我们克隆了<code class="fe lb lc ld le b">feed_model</code>、用于<code class="fe lb lc ld le b">channel</code>的<code class="fe lb lc ld le b">sender</code>变量和其他所有东西:为什么它仍然工作？为什么<code class="fe lb lc ld le b">receiver</code>仍然从克隆的<code class="fe lb lc ld le b">sender</code>中获取消息？难道不应该是一个不同的实例吗？为什么他们还联系在一起？</p><p id="40b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些都与不同的 Rust 语言机制有关，需要一整篇文章来解决。简而言之，是的，我们克隆了变量:但是如果你仔细观察，我们总是在一个闭包里捕获它们。这种特定于 Rust 的语法允许整个机制工作，即使它看起来不应该工作。</p><p id="3f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果你为 The Verge 和 Ars Technica 运行应用程序，不幸的是，它们不使用 RSS，而是使用 Atom 格式的提要。应用程序不会为这些返回任何东西，你也不会看到文章。我很晚才在教程中意识到这一点，我决定不切换到其他提要:你可以使用任何你喜欢的 RSS 提要，随意更改 URL。</p><p id="5794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，这次我们的项目只修改了两个文件。第一个是<code class="fe lb lc ld le b">Cargo.toml</code>，用于增加两个板条箱:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="20be" class="lf lg iq le b gy mh mi l mj mk">[package]<br/>name = "gtk-rss-reader"<br/>version = "0.1.0"<br/>edition = "2021"</span><span id="73a5" class="lf lg iq le b gy ml mi l mj mk">[dependencies]<br/>libadwaita = "*"<br/>gtk4 = "*"<br/>glib = "*"<br/>rss = "*"<br/>curio = "*"</span><span id="20fc" class="lf lg iq le b gy ml mi l mj mk">[build-dependencies]<br/>libadwaita = "*"</span></pre><p id="7b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个<code class="fe lb lc ld le b">main_window</code>档:<code class="fe lb lc ld le b">template.rs</code>。基本上，这里的代码是对<code class="fe lb lc ld le b">MainWindow</code>模板代码的主要重构。请在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-threads" rel="noopener ugc nofollow" target="_blank"> github </a>随意查看这些变化。如果我包含整个<code class="fe lb lc ld le b">template.rs</code>文件，那会浪费很多空间，因为它实在太大了。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="5ac6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我感谢你们在整个旅程中与我同行。这篇文章完成了 GTK4 和 libadwaita 教程，我希望它是有用的，读起来有趣，对你们所有人都有意思。如果我错过了什么或者我解释得不好，请随时使用评论区。</p><p id="7013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有更好的文字，更容易理解的解释，更好地理解整个教程中所描述的内容，请留下评论，我会尽力做得更好。我希望这篇教程尽可能的有用，尽可能的让更多的开发者了解 GTK。最好的问候，并留下来为其他系列！</p></div></div>    
</body>
</html>