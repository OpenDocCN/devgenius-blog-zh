<html>
<head>
<title>Making “Steps” component with React Transforming element APIs.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 React 转换元素 API 制作“步骤”组件。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-steps-component-with-reacts-transforming-element-apis-acceb7fce100?source=collection_archive---------11-----------------------#2022-07-24">https://blog.devgenius.io/make-steps-component-with-reacts-transforming-element-apis-acceb7fce100?source=collection_archive---------11-----------------------#2022-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转换元素 API 是 React 顶级 API 的一部分。这些 API 用于操作 react 元素，利用组合模式，对于创建可重用组件非常有用。</p><p id="cd11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是三个转换元素 API</p><p id="877f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React.cloneElement()</p><p id="18b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React.isValidElement()</p><p id="d67a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">做出反应。儿童</p><p id="7f89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一个一个地快速浏览一下。</p><p id="531e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> React.cloneElement(): </strong></p><p id="92bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以用它克隆任何 react 元素，并向它们添加新的属性。基本上就是给组件注入道具。</p><p id="f498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看这篇<a class="ae ki" href="https://blog.logrocket.com/using-react-cloneelement-function/" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多详情。</p><p id="4649" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> React.isValidElement(): </strong></p><p id="5984" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它验证对象是否是 React 元素。返回真或假。</p><p id="3d46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">做出反应。儿童:</strong></p><p id="7553" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它提供了处理<code class="fe kj kk kl km b">props.children</code>的实用方法。我们可以用它对<code class="fe kj kk kl km b">props.children</code>进行迭代、映射、计数和其他操作。</p></div><div class="ab cl kn ko hr kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ig ih ii ij ik"><p id="64c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">组件实现:</strong></p><p id="4fce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经有了这些 API 的基本知识，让我们一起使用它们来创建<strong class="jm io">步骤</strong>组件。</p><p id="1abe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开始实现之前，看看我们组件的最终 API。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="5ea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看啊！！多么简单美好。不是吗？😁</p><p id="89d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要制作两个组件。一个包装器<strong class="jm io">步骤</strong>组件，它将负责管理状态并呈现页眉和页脚；一个容器<strong class="jm io">步骤</strong>组件，它的唯一职责是基于状态显示和隐藏其子组件。</p><p id="25ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在看一下步骤组件的代码。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="a572" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个组件中有很多东西。让我一步一步地解释，让事情变得简单。</p><p id="c5cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先创建用于识别活动步骤的状态。然后我们使用<code class="fe kj kk kl km b">React.Children</code> API 提供的计数方法来计算这个<strong class="jm io">步骤</strong>组件将拥有的子组件的数量。之后，我们定义下一个和上一个处理程序来改变活动步骤的状态。</p><p id="9f18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想更多地关注组件的这一部分，因为主要的魔法发生在这里。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lb"><img src="../Images/a538a2e6e264b75571a7db0e33e600bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwteYILqjB2jbHxF4ehQQA.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">步骤组件的一部分</figcaption></figure><p id="8e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们使用的是另一种方法<code class="fe kj kk kl km b">React.Children</code> API。就像<code class="fe kj kk kl km b">Array.prototype.map</code>一样，通过<code class="fe kj kk kl km b">React.Children.map</code>，我们可以映射子节点并返回它们的修改版本。它需要两个参数，<code class="fe kj kk kl km b">props.children</code>对象和一个回调函数。在 map 方法的回调函数中，首先我们用<code class="fe kj kk kl km b">React.isValidElement</code>验证每个子元素是否是有效的 react 元素，然后我们克隆每个子元素并在其中注入两个道具<code class="fe kj kk kl km b">id</code>和<code class="fe kj kk kl km b">activeStep</code>，用于隐藏或显示子元素。</p><p id="10d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">步骤</strong>组件的子组件中没有发生太多的事情，那就是<strong class="jm io">步骤</strong>组件。看看它的代码。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="b59c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这个组件是<strong class="jm io">步骤</strong>组件的子组件，我们可以访问通过<code class="fe kj kk kl km b">React.cloneElement</code>注入的道具。首先，我们检查这些道具是否存在，如果它们不存在，这意味着这个组件没有被用作<strong class="jm io">步骤</strong>组件的子组件，所以我们抛出错误。然后，我们使用这些道具来处理隐藏和显示逻辑。</p><p id="6d0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的一个逃生出口是我们必须忽略道具类型的<em class="lm">类型脚本</em>。原因是<em class="lm"> TypeScript </em>不知道这些道具是从它的父元素注入的，它会对我们大喊来定义这些道具的类型。但是我们不能定义这些道具的类型，因为我们不希望这个组件的消费者传递这些道具，因为它们是由其父组件自动传递的。</p><p id="ab88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！！</p><p id="0894" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae ki" href="https://codesandbox.io/s/stepper-component-made-with-react-children-and-react-cloneelement-57wcyp?file=/src/Steps/index.tsx:657-1092" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>上查看完整的例子。</p><p id="8479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最终想法:</strong></p><p id="d3ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使本教程简单，我特意用最少的功能制作了这个组件。我们可以通过使用上下文 API 或渲染道具来扩展其功能，以暴露下一个和上一个处理程序，供组件的消费者使用。或者，我们可以通过接受<code class="fe kj kk kl km b">activeStep</code> prop，将处理状态的全部责任交给消费者，而不是在本地管理它。</p><p id="026f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望您已经通过这篇文章学到了一些新东西，并且对这些 API 有了很好的理解。</p><p id="05ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考文献:</strong></p><p id="7f42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> React 官方文档:</strong><a class="ae ki" href="https://reactjs.org/docs/react-api.html%23transforming-elements" rel="noopener ugc nofollow" target="_blank">https://React js . org/docs/React-API . html # transforming-elements</a></p><p id="4528" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> React.cloneElement 博客:</strong><a class="ae ki" href="https://blog.logrocket.com/using-react-cloneelement-function" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/using-react-cloneelement-function</a></p></div></div>    
</body>
</html>