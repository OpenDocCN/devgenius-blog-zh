<html>
<head>
<title>Create a multi-step form in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 中创建多步表单</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-a-multi-step-form-in-react-d55a3ebde8f9?source=collection_archive---------1-----------------------#2020-07-13">https://blog.devgenius.io/create-a-multi-step-form-in-react-d55a3ebde8f9?source=collection_archive---------1-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9ec7c28af67da633bc35d9ba0fce016a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn_kdgFY8eoqlkv-2KugdQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">太多的流浪汉！</figcaption></figure><p id="50c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有时当我们创建一个表单时，可能会有很多我们想要的信息。如果你把所有的字段都放在一个页面上，可能会惹恼用户，他可能会在完成表单之前离开。如果想提高用户体验，可以做多步表单。</p><p id="25f8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我将讲述如何在 React 中创建多步表单。这是一份报名表。第一步，我会收集用户的组织信息；然后第二步，我会收集用户的个人信息。一旦全部完成，它将向您显示一条成功(或失败)的消息。</p><h1 id="4cc9" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们需要一个容器组件！</h1><p id="f447" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">解决这个问题的非常直观的方法是创建三个不同的组件来完成我想分三步做的事情。确实如此！但是，想一想，我需要三个不相关的组件吗？不要！</p><p id="89a4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所有这三个组成部分都是我注册过程的一部分，它们有一些共同之处。例如，在第二步中，它将提交从第二个和第一个组件获得的信息。提交后，第三个组件将根据您是否提交成功显示提示。</p><p id="d03f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如何在三个不同的组件之间共享所有这些信息？答案是:<strong class="kb io">使用容器组件！</strong></p><p id="f24b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有了顶部的父组件，我们可以拥有以下优势:</p><ol class=""><li id="591f" class="ma mb in kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">父组件可以包含所有子组件共享的公共方法和变量，方法是将它们作为道具传递下去。所以，你可以保持代码干爽(不要重复)！当您需要更改所有三个组件都将使用的方法或变量时，代码维护会更容易。</li><li id="15cf" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">此外，当一个孩子改变一个家长的状态字段时，其他孩子也会得到通知，因为他们共享同一个家长！这样，您就不必手动地将新输入的信息传递给所有组件，这是非常容易出错的。</li><li id="2ba8" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">子组件可以用函数组件而不是类组件来编写。这样，它将提高应用程序的性能，因为功能组件只是没有生命周期的无状态普通 JavaScript 函数。这样可以节省渲染时进行生命周期相关检查的时间。</li></ol><h1 id="b9a3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实现子组件</h1><p id="cfec" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">正如我们刚刚谈到的，所有的子组件都是功能组件。它们不处理任何业务逻辑，而只是显示或接受从父组件传来的任何属性(变量)。</p><p id="8917" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">典型的子组件如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1977" class="mx ky in mt b gy my mz l na nb">import React from "react"</span><span id="ba30" class="mx ky in mt b gy nc mz l na nb">const CompanyInfo = props =&gt;{<br/>  const { values, handleChange, next} = props<br/>  return(<br/>      &lt;&gt;<br/>        &lt;label for="companyName" &gt;<br/>          Company Name<br/>          &lt;input<br/>            type="text"<br/>            name="companyName"<br/>            value={values.companyName}<br/>            // to invoke the handleChange method, you need to specify a name to it so that the state will change accordingly<br/>            onChange={handleChange('companyName')}<br/>          /&gt;<br/>        &lt;/label &gt;&lt;br /&gt;<br/>        &lt;label for="companyAddress"&gt;<br/>          Company Address<br/>          &lt;input<br/>            type="text"<br/>            name="companyAddress"<br/>            value={values.companyAddress}<br/>            // to invoke the handleChange method, you need to specify a name to it so that the state will change accordingly<br/>            onChange={handleChange('companyAddress')}<br/>          /&gt;<br/>        &lt;/label &gt;&lt;br /&gt;<br/>    </span><span id="15ce" class="mx ky in mt b gy nc mz l na nb">      &lt;button onClick={next}&gt;Next&lt;/button&gt;//since it is in first step, so only one "Next" button<br/>    &lt;/&gt;<br/>  )</span><span id="0415" class="mx ky in mt b gy nc mz l na nb">}</span><span id="9fee" class="mx ky in mt b gy nc mz l na nb">export default CompanyInfo;</span></pre><p id="80d2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通常，除了第一步，它会返回<strong class="kb io">输入框和两个按钮</strong>。这两个按钮是“下一步”和“上一步”,您可以使用它们在表单的不同部分之间来回切换。</p><p id="c494" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是因为是在第一步，所以只有一个“下一步”按钮，在最后一步，两个按钮是“返回”和“提交”。</p><p id="9589" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该组件将通过父组件传递的 props 得到字段的<code class="fe nd ne nf mt b">handleChange</code>方法、<code class="fe nd ne nf mt b">next</code>方法和<code class="fe nd ne nf mt b">values</code>(因为它是 React 的一种受控形式)以正确运行。</p><h1 id="fd93" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实现父组件</h1><p id="3480" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">父组件需要保存字段的<code class="fe nd ne nf mt b">handleChange</code>方法、<code class="fe nd ne nf mt b">next</code>方法、<code class="fe nd ne nf mt b">back</code>方法、<code class="fe nd ne nf mt b">handleSubmit</code>方法和<code class="fe nd ne nf mt b">values</code>，以便根据需要传递给不同的子组件。</p><p id="bab4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我的父组件如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3cec" class="mx ky in mt b gy my mz l na nb">// pages/signup.js<br/>import React from "react"<br/>import Layout from "../components/layout";<br/>import CompanyInfo from "../components/signupComponents/companyInfo";<br/>import UserInfo from "../components/signupComponents/userInfo";<br/>import AfterSubmit from "../components/signupComponents/afterSubmit";<br/>// import "../components/style/signUp.css"</span><span id="bf3f" class="mx ky in mt b gy nc mz l na nb">export default class signUp extends React.Component {<br/>  state = {<br/>    step: 1,<br/>    companyName: "",<br/>    companyAddress: "",<br/>    name: "",<br/>    phone:"",<br/>    signupSuccess: false  <br/>  }</span><span id="9dcd" class="mx ky in mt b gy nc mz l na nb">// process to next step<br/>  next = () =&gt; {<br/>    // update state.step by adding to previous state<br/>    this.setState(prevState =&gt; {<br/>      return {step: prevState.step + 1<br/>    }})<br/>  }<br/>  <br/>  // process to previous step<br/>  back = () =&gt; {<br/>    // update state.step by minus 1 from previous state<br/>    this.setState(prevState =&gt; {<br/>      return {step: prevState.step - 1<br/>    }})<br/>  }<br/> <br/>  //handle all the field changes<br/>  handleChange = input =&gt; e =&gt; {<br/>    this.setState({<br/>      [input]: e.target.value<br/>    })<br/>    console.log(this.state)<br/>  }</span><span id="5b3e" class="mx ky in mt b gy nc mz l na nb">//handle form submit<br/>  handleSubmit = () =&gt;{<br/>    //connect to the database, depending on the returned state, <br/>    //will change the state.signupSuccess to be true<br/>    //and then render success component<br/>    this.setState({<br/>      signupSuccess: true<br/>    }, () =&gt; this.next())<br/>  }<br/>  <br/>  render(){<br/>    const { step } = this.state<br/>    const { companyName, companyAddress, name, phone,signupSuccess } = this.state<br/>    const values = { companyName, companyAddress, name, phone,signupSuccess }</span><span id="99f5" class="mx ky in mt b gy nc mz l na nb">switch (step) {<br/>      case 1:<br/>        return (<br/>        &lt;Layout&gt;<br/>          &lt;CompanyInfo <br/>          values = {values} <br/>          handleChange = {this.handleChange}<br/>          next = {this.next}<br/>          /&gt;<br/>        &lt;/Layout&gt;<br/>        )</span><span id="b030" class="mx ky in mt b gy nc mz l na nb">      case 2:<br/>        return (<br/>          &lt;Layout&gt;<br/>          &lt;UserInfo <br/>          values = {values} <br/>          handleChange = {this.handleChange}<br/>          back = {this.back}<br/>          handleSubmit = {this.handleSubmit}<br/>          /&gt;<br/>        &lt;/Layout&gt;<br/>        )<br/>      <br/>      case 3:<br/>        return &lt;AfterSubmit signupSuccess = {values.signupSuccess}/&gt;<br/>    }<br/>  }</span><span id="60c1" class="mx ky in mt b gy nc mz l na nb">}</span></pre><h2 id="3eb2" class="mx ky in bd kz ng nh dn ld ni nj dp lh kk nk nl ll ko nm nn lp ks no np lt nq bi translated">使用“步骤”渲染不同的组件</h2><p id="d813" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">如您所见，我添加了一个<code class="fe nd ne nf mt b">step</code>状态字段来控制我想要呈现哪个组件。它默认为“1”，所以当指向我的注册页面时，它将呈现<code class="fe nd ne nf mt b">CompanyInfo</code>组件。</p><p id="3027" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们改变另一个组件的方法是改变<code class="fe nd ne nf mt b">step</code>的值。这就是为什么<code class="fe nd ne nf mt b">next</code>和<code class="fe nd ne nf mt b">back</code>方法基本上都是改变<code class="fe nd ne nf mt b">step</code>的状态，这样父组件就会相应地改变组件。</p><h2 id="1825" class="mx ky in bd kz ng nh dn ld ni nj dp lh kk nk nl ll ko nm nn lp ks no np lt nq bi translated">使用“注册成功”来控制表单提交后发生的事情</h2><p id="d021" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">我还在这里添加了另一个<code class="fe nd ne nf mt b">signupSuccess</code>来控制表单提交后表单应该做什么。</p><p id="2a5e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如您所见，在<code class="fe nd ne nf mt b">handleSubmit</code>方法中，它将连接到数据库并尝试创建一个用户(我没有将代码放在那里，因为这不是本文的重点)。</p><p id="a4c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦完成，您可以根据服务器返回的内容更改<code class="fe nd ne nf mt b">signupSuccess</code>值:如果成功返回，您将设置状态的<code class="fe nd ne nf mt b">signupSuccess</code>为真。并且还调用回调，这里是<code class="fe nd ne nf mt b">next</code>方法。这将改变状态的<code class="fe nd ne nf mt b">step</code>,以便呈现<code class="fe nd ne nf mt b">AfterSubmit</code>组件。</p><p id="08b8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">AfterSubmit</code>可以访问<code class="fe nd ne nf mt b">signupSuccess</code>并且会有类似这样的东西来控制流量:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f291" class="mx ky in mt b gy my mz l na nb">{props.signupSuccess ? &lt;SuccessComponnet /&gt; : &lt;FailedComponent /&gt;</span></pre><p id="c37d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这样，我们成功地在 React 中创建了一个多步表单！感谢阅读！</p><h1 id="ace7" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束</h1></div></div>    
</body>
</html>