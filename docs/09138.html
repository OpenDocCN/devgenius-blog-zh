<html>
<head>
<title>Goroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈鲁廷斯</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/goroutines-da7ed6ced8a1?source=collection_archive---------12-----------------------#2022-08-01">https://blog.devgenius.io/goroutines-da7ed6ced8a1?source=collection_archive---------12-----------------------#2022-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d198" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从基础开始</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c73904fe087296a5265763d9cf0e45ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbdp4-9Wksv4-ipDh7197Q.png"/></div></div></figure><p id="4ec8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以将 goroutine 定义为<em class="lk">“定义要运行的程序或函数的逻辑执行单元，它还包含与 goroutine 相关的重要信息，如堆栈内存，其中的机器/线程正在运行 goroutine 和堆栈跟踪”。</em></p><p id="742e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简而言之，goroutine 是一个与主 goroutine 同时执行的函数。</p><p id="18d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 go 编程语言中，一个新的“线程”是在函数调用之前由关键字“Go”生成的。</p><p id="3145" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ll"><img src="../Images/48c8e7b1e1f018d975bc371f29c0472c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5qgsAyNdCeoK6Uo5F4hSw.png"/></div></div></figure><p id="3dac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">输出:</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lm"><img src="../Images/7b7e21a42e880533baf5243959011991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2Ps639inRwEpWNVETh4gA.png"/></div></div></figure><p id="a6ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如图所示，代码定义了两个 goroutines 一个在第 11 行调用“sendAlert”函数，第二个使用匿名函数定义。</p><p id="d7e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我们现在正在创建的 goroutines！。</p><p id="6175" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在接下来的章节中，我们将了解哪些组、互斥体和通道将有助于我们编写更复杂的 goroutines。</p><p id="2def" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">下一步:</em> </strong> <a class="ae ln" href="https://medium.com/@josueparra2892/golang-waitgroups-2cd6c5b4306d" rel="noopener"> <strong class="kq io"> <em class="lk">如何实现 WaitGroup </em> </strong> </a></p><blockquote class="lo lp lq"><p id="e0d0" class="ko kp lk kq b kr ks jo kt ku kv jr kw lr ky kz la ls lc ld le lt lg lh li lj ig bi translated">本文与 Golang 并发教程相关，您可以在以下链接中找到该教程:</p><p id="92b1" class="ko kp lk kq b kr ks jo kt ku kv jr kw lr ky kz la ls lc ld le lt lg lh li lj ig bi translated"><a class="ae ln" href="https://medium.com/@josueparra2892/concurrency-in-go-bf93e23bebd4" rel="noopener">https://medium . com/@ josueparra 2892/concurrency-in-go-BF 93 e 23 bebd 4</a></p></blockquote></div></div>    
</body>
</html>