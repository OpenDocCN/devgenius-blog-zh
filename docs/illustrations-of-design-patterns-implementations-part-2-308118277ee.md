# 设计模式实现示例:第 2 部分

> 原文：<https://blog.devgenius.io/illustrations-of-design-patterns-implementations-part-2-308118277ee?source=collection_archive---------11----------------------->

![](img/f7ef200d183f12e76c74b75b026a7782.png)

感谢 Ricardo Gomes 的这张照片:[https://unsplash.com/@rgaleria](https://unsplash.com/@rgaleria)

欢迎学习设计模式实现的第二部分。

在这篇文章中，我们将看看两个不难理解的模式。我个人用过的其中一个就是开发电报机器人。至于另一种模式——我将分享如何在 React 开发中使用它的想法。

# 示例 1:策略

策略是最容易理解和实现的模式之一。

> 策略是一种行为设计模式，它允许你创建算法类别，并在运行时根据条件选择任何算法*。*

所以，基本上我们只是把我们的算法移到单独的类中(一个类—一个算法)。它提醒了一个伟大的编程原则——单一责任(来自 SOLID 的字母 S)。

在我们开始讨论这个模式之前，我想先描述一下这个机器人。这个机器人的想法是向用户呈现不同的图像和音频。这个机器人的**大脑**正在解析带有照片和音频的网站，然后将这些文件的 URL 发送回用户(它们已经自动变成图像和音频文件)。

让我们称这个机器人的大脑为解析器。该解析器的简化版本如下所示:

是**红宝石**对了。伟大的编程语言。

为了解析网站，我使用了诸如 **nokogiri** 和**http party**这样的 gem(库、包)。如您所见，我们有一个类——解析器。它内部有两个方法——**load _ photos _ URLs**和 **load_audios_urls** 。我们不会一行一行地钻研这些方法，也不会讨论 **Ruby** 语法，你只需要知道它们解析给定的 HTML 页面，从解析的 HTML 页面中获取特定的字符串(图像、音频的 URL)，并将这些 URL 保存到变量 **audio_urls** 和 **photo_urls** 中。

乍一看，这个类看起来不错——它做了我们可能需要的一切。我们还能做些什么吗？我们为什么要对这门课做些别的事情呢？

这个班的问题是人多。到时候我想给这个类添加一个视频解析方法——它会变得更大。如果我想添加其他东西的解析，结果是一样的，这个类会变得更大。而且维护起来会更难。如果有多个开发人员在这个类上工作，实现新的特性可能会导致合并冲突。这就是为什么我们需要把我们的解析器分成更小的部分。

我们的解析器做两件事——用图像解析网站，用音频解析网站。我们能做的就是将这些解析方法转移到不同的类中。

现在，我们有两个不同的类，它们以不同的方式实现了相同的方法 **load_urls** 。(顺便说一句，我们还可以为它们创建一个父类，以移出构造函数并去掉重复的代码)

让我们看看解析器类现在是什么样子:

我们的解析器现在有了一个方法 **set_parser_strategy** ，它允许我们在运行时切换解析机制。 **get_urls** 方法检查是否设置了任何解析器策略，然后返回该策略的 URL。请注意，我们的解析器类也变得比以前小了很多。

现在我们可以这样使用这个解析器:

从现在开始，每当我们想给我们的解析器添加一个新的解析算法时——我们只需为它创建一个单独的类，然后将它注入解析器。

顺便说一下，谈到注入——因为上面的例子是用动态类型化的编程语言编写的，所以我们忽略了一件很酷的事情。让我们用 Typescript 稍微重写一下解析器类:

这里我定义了一个接口 **ParserStrategy** — ，在这里我公开了一个方法 **loadUrls** 和 **urls** 变量。这是一个很好的技巧，因为如果我们的策略中有更多的方法或变量，我们不会告诉我们的解析器类，我们不希望我们的类知道它不需要知道的事情，我们不希望我们的解析器类依赖于特定的东西，我们希望它依赖于一些抽象。是 SOLID 的一个字母 D(依存倒置原理)。从现在开始，我们所有新的解析策略都必须符合这个接口— **ParserStrategy** 。

这就是策略设计模式的大部分内容。

# 示例 2:状态

状态是一个在 React 中经常使用的术语，但是很少有 React 开发人员意识到他们正在使用 GoF 设计模式本身。

> 状态是一种行为设计模式，允许对象根据其“状态”做出不同的行为*。*

我们有一个对象，这个对象有一个状态，取决于它处于什么状态，这个对象以不同的方式执行操作。就这么简单。

让我们创建一个简单的 React 应用程序。这个应用程序的想法是，它允许我们从不同的 URL 提供服务中加载不同的文件名及其扩展名(是的，几乎和前面的例子一样)。但关键是这些提供 URL 的服务以不同的格式获取 URL，我们需要为每个服务编写格式化逻辑。下面是 API 调用的模拟函数:

根据我们想要获取的文件类型，它将返回特定的字符串数组。

现在让我们看看我们的第一个组件。

这个**应用**组件只有一些可点击的段落，点击它们我们就可以改变我们想要获取的文件类型。

现在我将向您展示一个组件，它列出了加载的文件名。

你可能会说这是一个很大的组成部分。你是对的。该组件接收一个**文件提取器**，根据这个**文件提取器**的类型，它将加载文件并以不同的方式解析它们。看看 **fetchFiles** 方法。根据什么是**文件提取器**道具，它做不同的事情。

这本身是状态模式的一种实现。但是关于状态模式，你需要知道的另一件事是，它允许你摆脱所有这些条件语句。

> 有些人可能会说，代码中的条件语句越多，代码就越糟糕。虽然这并不总是真的。

对于状态模式，我们还需要实现代表不同状态的类。在我们开始实现它们之前，让我们定义一个接口，它将代表我们的类:

现在，我们说我们所有的状态类都将实现相同的方法。但是不一样。

现在，在我们将所有的状态分成不同的类之后，让我们看看如何重写我们的 **FileViewer** 和 **App** 组件。

我们实例化了我们的状态类，而不是将枚举值传递给状态，而是传递这些类的实例。

如果你看一下 **fetchFiles** 方法，你会发现现在只有两行代码(没有空行)，而在此之前有很多逻辑在里面。你看多态多美？这就是状态模式的全部意义。我们将状态的逻辑移到了不同的类中，现在我们的组件根据状态以不同的方式运行，并且代码更少。

感谢您阅读这篇文章。如果您有任何意见、问题，认为有些地方解释错误或可以解释得更好，请通过电子邮件***islamrustamov @ rambler . ru***或下面的评论与我联系。

资源:

*维基百科—*[*https://www.wikipedia.org/*](https://www.wikipedia.org/)

*我的头*