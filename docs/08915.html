<html>
<head>
<title>This Small Code in Java Caused Our Build Pipeline to Fail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的这段小代码导致我们的构建管道失败</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/this-small-code-in-java-caused-our-build-pipeline-to-fail-bd0c88abb0b0?source=collection_archive---------11-----------------------#2022-07-18">https://blog.devgenius.io/this-small-code-in-java-caused-our-build-pipeline-to-fail-bd0c88abb0b0?source=collection_archive---------11-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="28ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">方案</h2></div><p id="bc22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的工作中，我们有一段代码从属性文件中获取一个字符串。这个字符串指定了一个包名，我们将使用它来构造一个文件路径。为简单起见，代码如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b2fe" class="lk ll iq lg b gy lm ln l lo lp">final String myPackage = "com.dntech.demo";<br/><br/>final String samplePath = "myFolder" + "\\\\" + myPackage.replaceAll("\\.", "\\\\") + "\\\\" + "myFile";<br/><br/>FileInputStream fileInputStream = new FileInputStream(samplePath);</span></pre><p id="0592" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面看到的，我们有一个 myFolder 前缀，后跟一个路径分隔符，我们用路径分隔符替换包字符串中的所有点，最后添加文件名。最后，我们使用字符串来访问文件。</p><p id="cf77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的同事将代码从本地提交到远程存储库时，远程构建<strong class="kh ir">失败了</strong>。</p><h2 id="44ff" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">你能想到构建失败的原因吗？</h2><p id="3a47" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这和<strong class="kh ir">跨平台</strong>有关。</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/c2f80cf2dc1a00310757dd1555ddf518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xg0UP4Mh-z_oyjaHKA3azw.png"/></div></div></figure><p id="4aab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的团队中，我们被给予<strong class="kh ir"> Windows </strong>平台来开发我们的应用程序。在某人完成了他们的代码之后，他/她将推送到 BitBucket repo，这将触发我们公司的内部构建管道来构建应用程序。然而，构建我们的应用程序的系统不再是 Windows，而是 Linux。</p><p id="ee14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们使用 Java 库<strong class="kh ir"> <em class="mu">文件</em></strong>——来获取路径分隔符，这样 JVM 将帮助我们基于操作系统获取相应的分隔符。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="78dd" class="lk ll iq lg b gy lm ln l lo lp">final String PATH_SEPARATOR = File.<em class="mu">separator</em>;<br/>final String myPackage = "com.dntech.demo";<br/><br/>final String samplePath = "myFolder" + PATH_SEPARATOR + myPackage.replaceAll("\\.", PATH_SEPARATOR) + PATH_SEPARATOR + "myFile";<br/><br/>FileInputStream fileInputStream = new FileInputStream(samplePath);</span></pre><p id="867e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单！</p><p id="4c28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先在本地运行应用程序…</p><p id="ae2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">什么？一个错误？</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4b1ef27eaeaaf591e4844d5121679e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*h1UVE9iYoG9mB6aphuduvw.png"/></div></figure><p id="36b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它说:“线程中的异常”main“Java . lang . illegalargumentexception:缺少要转义的字符”。</p><blockquote class="mw"><p id="7675" class="mx my iq bd mz na nb nc nd ne nf la dk translated">在这里暂停。你能找出原因吗？</p></blockquote><p id="82d0" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">在 Windows 中，路径分隔符是反斜杠(" \ ")。</p><p id="e776" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式里看着眼熟吗？同一字符在正则表达式中用作转义字符。因此，当我们调用<em class="mu"> replaceAll() </em>方法时，反斜杠被视为转义字符，它希望它后面的某个字符进行转义。</p><p id="c3d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如 Matcher.java 文档中提到的<em class="mu"> replaceAll() </em>方法:</p><blockquote class="nl nm nn"><p id="8c96" class="kf kg mu kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">请注意，替换字符串中的反斜线(\)和美元符号($)可能会导致结果与被视为文字替换字符串时不同。如上所述，美元符号可以被视为对捕获的子序列的引用，并且反斜杠用于对替换字符串中的文字字符进行转义。</p></blockquote><h2 id="3c5d" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">那我们怎么解决呢？</h2><p id="55ee" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">不使用正则表达式替换字符串字符，我们可以只使用 char sequence —使用<em class="mu"> replace() </em>而不是<em class="mu"> replaceAll() </em>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c428" class="lk ll iq lg b gy lm ln l lo lp">final String samplePath = "myFolder" + PATH_SEPARATOR + myPackage.replace(".", PATH_SEPARATOR) + PATH_SEPARATOR + "myFile";</span></pre><p id="f609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以看到结果被正确打印出来，并且能够跨平台工作:</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/23e888e28e0225da075f4d3b937d6292.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*uYZIsGHXzVTzvqyG1NtFmw.png"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="3fda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章对你有所帮助。如果你像我一样，渴望学习 Java 和更多关于后端工程的知识，请关注我的频道，了解我在日常工作和生活中获得的灵感。</p><blockquote class="nl nm nn"><p id="8a19" class="kf kg mu kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">阅读更多:</em> </strong> <em class="iq"> <br/> </em> <a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/a-case-about-java-static-keyword-during-my-job-53cebb6af597"> <em class="iq">一个关于 Java 静态关键字在职期间的案例</em></a><em class="iq"><br/></em><a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/how-can-you-solve-this-java-multithreading-interview-problem-8e6ec53fab27"><em class="iq">如何解决这个 Java 多线程面试问题？</em> </a></p></blockquote></div></div>    
</body>
</html>