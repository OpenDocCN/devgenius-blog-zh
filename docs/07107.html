<html>
<head>
<title>How To Implement Cache LFU Algorithm With Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Swift 实现缓存 LFU 算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-implement-cache-lfu-algorithm-with-swift-a372e107def7?source=collection_archive---------6-----------------------#2022-02-26">https://blog.devgenius.io/how-to-implement-cache-lfu-algorithm-with-swift-a372e107def7?source=collection_archive---------6-----------------------#2022-02-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="80b8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">介绍</h2></div><p id="1cb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">缓存 LFU(最不常用)类似于字典/哈希表，它以键/值对的形式存储元素。缓存 LFU 算法用于管理有限的存储/内存空间，根据维基百科</p><blockquote class="ky kz la"><p id="3a62" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">最少使用(LFU)是一种用于管理计算机内存的缓存算法。这种方法的标准特征包括系统跟踪内存中块被引用的次数。当缓存已满并需要更多空间时，系统将清除引用频率最低的项目。</p></blockquote><p id="8b1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么这意味着什么呢？。简而言之，当系统耗尽资源并希望释放一些内存来存储新对象时，它会查看已经存储的对象，并删除最不常用的元素来释放一些空间。</p><p id="a04d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">缓存 LFU 是一种缓存算法，这意味着它可以在任何缓存系统中使用(取决于系统需求)。像 CDN <strong class="ke io">内容交付网络</strong>一样，它可以利用 LFU 来缓存图像/资产，以便为其他用户更快地交付这些图像。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h2 id="94e4" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">先决条件</h2><p id="f29e" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我将使用双向链表和字典(哈希表)实现缓存 LFU，所以我想你应该熟悉这些数据结构。最好也知道<strong class="ke io">高速缓存 LRU(最近最少使用)</strong>，但是理解这个算法不是强制性的。</p><h2 id="cbd4" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">它是如何工作的</h2><p id="1bf8" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我们将把我们的数据和它的键存储在一个链表节点中，所以每个节点都有它唯一的值和唯一的键。那么我们如何跟踪每个节点呢？我们还将添加<em class="lb"> frequency </em>属性来跟踪每个对象的频率。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/ae348b16f7e641676a98ae1b9af89ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58UGPsJGjsLOIp325ED-fg.jpeg"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">主 LFU</figcaption></figure><p id="cce2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">头:是我们的缓存，它将跟踪每一个项目</p><p id="7f4d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">圆圈:表示包含数据(值和键)的节点。</p><p id="fba5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">方块:代表链表的头部(上面的数字是它的频率)</p><p id="8430" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们第一次将数据添加到缓存中时，其频率为 1，并且对于我们对其进行的任何操作，该频率都会增加，例如检索(读取)其值或更改给定键的相关值。</p><p id="431f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">#示例</strong>:假设我们的缓存容量为 6 项(如上图)</p><ol class=""><li id="3ce5" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">将(c)添加到我们的缓存中，然后添加(b)，现在(c .)和(b)的频率为 1。</li><li id="05d3" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">连续 4 次读取(c .)和(b)的值，现在(c .)和(b)的频率为 5。</li><li id="bbfb" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">将(z)和(a)添加到我们的缓存中，现在(z)和(a)的频率为 1。(c .)和(b)仍然在频率 5。</li><li id="bf54" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">改变(c .)的值，它的频率现在变成 6。然后读它的值三次，现在(c .)频率是 9。</li><li id="1faf" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">读取(z)和(a)值一次，现在它们的频率是 2，(b)仍然是 5，(c)是 9</li><li id="e48f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">将(y)和(x)添加到缓存中，它们的频率现在是 1。当然，旧节点的频率仍然相同。</li></ol><ul class=""><li id="d5bd" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx no ng nh ni bi translated">如果你在这些步骤中迷路了(可惜不是视频看不清楚:/)，试着用纸笔直观地模拟这些步骤。</li></ul><p id="229f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们的缓存充满了 6 个元素，看起来就像上面的图片一样，现在如果我们尝试添加新元素会发生什么呢？。我们的缓存将寻找存储在其中的最小频率(在我们的例子中是 1 ),并获取该频率的列表，并删除其尾部的元素(最少使用的项目)以释放空间。</p><p id="7288" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，缓存将从频率 1(最小频率)的列表中删除元素，但是是哪个元素呢？(x)还是(y)？。基本上它会删除(y)，但是为什么呢？因为它是(最近最少使用的)元素。</p><p id="4c94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，我们先添加(y ),然后添加(x ),所以(x)是列表中最新的元素，而(y)是最老的元素，所以(y)被称为列表中最近最少使用的元素。</p><p id="2ef2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们必须从一个有这么多元素的列表中删除元素，我们删除列表中最不常用的(最老的)元素。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h2 id="6616" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">履行</h2><p id="7917" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">为了简单起见，我将使用整数作为数据，整数作为这些数据的键，当然您可以指定您想要的数据和键类型，并且可以使它通用，甚至可以存储您的自定义数据类型，但是在这个实现中我将只使用整数。</p><p id="97d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">#创建链表节点。</strong></p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="9250" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">关联值的键。</li><li id="e7b6" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">将被存储的值。</li><li id="f150" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">存储节点的频率(跟踪每个节点的频率，当缓存满时，我们将删除频率最低的节点)。</li><li id="20a0" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">跟踪当前节点的下一个和上一个节点(这是一个双向链表)</li><li id="a662" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">用键和值初始化节点，我们还将它的频率设置为 1，因为它是新节点，即将被使用。</li></ol><p id="8655" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们设计我们的链表。链表可以有各种各样的功能，但我们将创建函数，这将有助于我们的缓存算法，不需要一个完整的链表实现。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="be95" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里没有做太多的事情，我们创建了一个名为“list”的链表，它有三个属性“size”来跟踪列表中节点的数量，“head”和“tail”来存储第一个和最后一个元素，以使我们对列表的操作更加简单。</p><p id="14e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> #添加在前面:</strong>我们需要一个方法在列表中添加一个新元素。我们将它添加到头部以符合缓存 LFU 策略，现在将这段代码添加到我们的 List 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="9498" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们让链表头指向新的链表头，并将链表的大小增加 1，我们将这段代码添加到一个“defer”块中，以确保这段代码在函数即将返回时被执行。</li><li id="ef0b" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们检查我们的列表是否有一个头(不是 nil ),如果是 nil，我们也为我们的新节点设置尾部,“我们已经在过去的步骤中为新节点设置了列表头”,然后返回，现在新节点同时是列表的头和尾(这将是列表中第一个节点的情况)。</li><li id="d12e" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">如果列表已经有了一个头，那么我们就把新的节点链接到旧的头。</li></ol><p id="2a1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> # Remove Node: </strong>这个方法在我们的实现中非常有用，对于两个用例，当我们检索或更改一个值时，现在我们应该增加节点频率，将其从旧列表中删除，并将其添加到一个频率更高的列表中，现在这个方法来拯救。将这段代码添加到 List 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="a9d1" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">跟踪将被删除的节点的下一个和前一个引用，然后将其下一个和前一个引用设置为零(移除它们)并将列表大小/计数减 1。</li><li id="4ff2" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">当我们从列表中删除一个节点时，我们应该更新列表的头和尾，这一点非常重要，因为被删除的节点可能是列表的尾或头。</li><li id="14d3" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将前一个节点的 next 链接到被删除节点的 next，将下一个节点的 previous 链接到被删除节点的 previous。</li></ol><p id="4366" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> # Remove Last: </strong>当缓存已满，想要删除最小频率列表(最少使用)元素中最近最少使用的元素时，这个方法非常有用。将这段代码添加到我们的 List 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="0e0a" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们检查列表是否有尾部，如果有，我们继续，如果没有，返回零。</li><li id="d23f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">引用尾部的前一个节点，并使列表尾部引用前一个节点。</li><li id="6a57" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">检查列表大小是否等于 1，如果是，我们将列表头设置为 0(在这种情况下，列表中没有节点)，然后减少列表大小。</li><li id="1dfc" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">此<code class="fe nr ns nt nu b">tail</code>的值与<code class="fe nr ns nt nu b">self.tail</code>的值不同。这是旧的<code class="fe nr ns nt nu b">tail</code>的值，它来自这个方法开始时<code class="fe nr ns nt nu b">guard</code>中的可选绑定。</li></ol></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h2 id="a993" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">缓存 LFU</h2><p id="4b68" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">现在是时候实现我们的缓存了。记住这个<em class="lb">缓存像字典一样存储与键相关的数据</em>。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="367c" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们将把节点(键/值对)存储在这个字典中，以便更快地读取。</li><li id="76ed" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">在这个字典中，我们将存储包含节点的列表，关键字是列表的频率，值是列表本身。</li><li id="11a0" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">几个有用的属性将帮助我们跟踪缓存的最大大小、当前大小和最小频率。</li><li id="fa28" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">用需要的容量初始化我们的缓存。</li></ol><p id="148b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> # Get Value: </strong>使用<code class="fe nr ns nt nu b">get</code>方法，我们可以检索特定键的元素。每当我们检索一个元素，我们应该更新节点的频率(包含我们的元素的节点)。将这段代码添加到我们的 LFUCache 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="6797" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们检查“keyNodeDic”字典是否有与给定键相关联的值，如果没有，函数返回-1。</li><li id="c6f0" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">如果 keyNode 字典中有一个值，我们首先在一个名为“updateFreqListDic”的独立函数中更新包含它的节点，这个方法将在后面讨论，然后返回它的值。</li></ol><p id="9a24" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> # Put Value: </strong>通过方法<code class="fe nr ns nt nu b">put</code>，我们可以为特定的键添加/更新一个元素。将这段代码添加到我们的 LFUCache 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dea5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生了很多事情，我们来分解一下。</p><ol class=""><li id="7d9a" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们检查缓存容量是否大于 0，以防一些用户用 0 容量实例化我们的缓存类。</li><li id="c9ef" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们检查 keyNodeDic(我们的节点存储)中是否存储有与给定键相关联的节点，如果有，我们用新值更新它(节点),然后在“updateFreqListDic”方法中更新节点频率及其列表频率，如果没有，我们继续。</li><li id="5a48" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们检查是否达到了最大值，如果是，我们将获得缓存的最小频率列表。</li><li id="007f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们移除列表中具有最小频率的最后一个(最近最少使用的)元素。然后从“keyNodeDic”字典(我们的节点存储)中删除该节点，并将当前大小减 1。</li><li id="8c21" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将当前大小增加 1(因为我们将要在缓存中存储新元素)。然后将最小频率设置为 1，因为有一个新元素进入我们的缓存。</li><li id="e5a2" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们创建一个空链表，然后检查是否有一个与存储在“frequentListDic”字典(我们的列表存储)中的最小频率相关联的列表，如果有，我们将新列表设置为等于该列表，如果没有，我们继续。</li><li id="5d17" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们从给定的键/值对创建新的节点。</li><li id="aebe" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将新节点添加到列表中(在前面)。</li><li id="d560" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将新节点添加到我们的节点存储(keyNodeDic 字典)并更新或添加它的列表到我们的列表存储(frequentListDic 字典)。</li></ol><p id="32e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> #更新节点:</strong>现在来看我们最后一个更新特定节点的方法。请记住，我们使用这个方法两次，当我们读取一个节点的值和当我们更新一个节点的值。将此代码添加到 LFUCache 类中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="afe3" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx nf ng nh ni bi translated">我们从它的旧列表中删除该节点(以将其添加到它的新频率列表中)。</li><li id="ee46" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">这是重要的一步，我们检查节点的频率是否是最小频率，以及它的列表是否没有元素，如果这两个条件都为真，那么我们将最小频率增加 1，并从“frequentListDic”字典(我们的列表存储)中删除该列表。</li><li id="8b2f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们创建空链表，然后检查是否有与存储在‘frequentListDic’字典(我们的列表存储)中的节点的新频率相关联的列表，如果有，我们将新列表设置为等于该列表，如果没有，我们继续。</li><li id="f420" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将节点的频率增加 1。</li><li id="99ea" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们以更高的频率将节点添加到下一个链表中。</li><li id="e060" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将更新节点更新/添加到我们的节点存储(keyNodeDic 字典)中，并将它的列表更新或添加到我们的列表存储(frequentListDic 字典)中。</li></ol></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="3f48" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">时间复杂度:</strong></p><ul class=""><li id="2b18" class="na nb in ke b kf kg ki kj kl nc kp nd kt ne kx no ng nh ni bi translated">O(1)获取/读取数据。</li><li id="80a3" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx no ng nh ni bi translated">O(1)放新数据。</li></ul><p id="2fcd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所看到的，这是这个实现中非常有效的算法，事实上，这个实现是基于 Ketan Shah 教授的论文“实现 LFU 缓存驱逐方案的 O(1)算法”(你可以在这里查看<a class="ae nv" href="http://dhruvbird.com/lfu.pdf" rel="noopener ugc nofollow" target="_blank"/>)，其中他们解释了一个 LFU 缓存的实现，其所有操作的运行时复杂度为<code class="fe nr ns nt nu b">O(1)</code>，包括插入、访问和删除(驱逐)。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="32f3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们的缓存 LFU。你可以在 GitHub gist <a class="ae nv" href="https://gist.github.com/AymanAtallahAhmed/f95483ee7aa7e5ea8ba26bf2f683bad0" rel="noopener ugc nofollow" target="_blank"> <em class="lb">这里</em> </a> <em class="lb">找到完整的代码实现。</em></p><p id="24d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管现在我们有大量的内存可供应用程序使用。但我们可能需要容量有限的缓存来节省内存空间，或者将该算法用于需要缓存的系统，如 CDN。</p><p id="c807" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。很抱歉我的英语不好，我不是母语(我认为这是显而易见的:D)。</p><p id="c084" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请给一些掌声，并分享它。祝你愉快，再见。</p></div></div>    
</body>
</html>