<html>
<head>
<title>BST Implementation In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 中的 BST 实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bst-implementation-in-golang-fb92309fe96a?source=collection_archive---------5-----------------------#2022-11-01">https://blog.devgenius.io/bst-implementation-in-golang-fb92309fe96a?source=collection_archive---------5-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c2452c1b3c06827d7bc151584fbb5edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH7SfgsjlOILy2VvGNMaXw.png"/></div></div></figure><h1 id="98df" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">定义</h1><blockquote class="kt ku kv"><p id="73ad" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="kz io">二叉查找树:</strong> <em class="in">一种二叉树，其中每个节点的左子树的关键字少于该节点的关键字，而每个右子树的关键字多于该节点的关键字。</em></p><p id="0ae3" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="kz io">二叉树:</strong> <em class="in">每个节点最多有两个孩子的树。</em></p></blockquote><h1 id="6f84" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结构体</h1><p id="1d60" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">结构是用户定义的数据类型，其中包含几个元素。就像许多其他语言一样。 ) struct 是 golang 中处理自定义类型的默认方式。</p><blockquote class="kt ku kv"><p id="1572" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="kz io"> <em class="in">节点:</em> </strong> <em class="in">由实际数据和指向左右后续节点的指针组成。</em></p><p id="ca5c" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="kz io"> <em class="in"> BST: </em> </strong> <em class="in">它由根节点组成。</em></p><p id="2e88" class="kw kx ky kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">BST 可以通过树的高度、树的级别和树中节点的数量等参数进一步优化…</p></blockquote><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="52af" class="mm jw in mi b be mn mo l mp mq">type node struct {<br/>    left  *node<br/>    data  int<br/>    right *node<br/>}<br/>type bst struct {<br/>    root *node<br/>}</span></pre><h1 id="eb0e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">服务人员</h1><p id="33b3" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">服务器可以与同类型关联的方法的实现进行比较。一般我们创建一个构造函数来初始化一个类型，类似于其他语言中的一个<strong class="kz io"> <em class="ky"> new </em> </strong>关键字。</p><p id="7a1b" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lx lj lk ll lz ln lo lp mb lr ls lt lu ig bi translated">这避免了直接操纵数据，使变量成为私有变量。方法是唯一可用于操作与类型关联的数据的方法。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="8839" class="mm jw in mi b be mn mo l mp mq">type BSTService interface {<br/>    Insert(data int) *bst<br/>    GetRoot() *node<br/>    Search(key int) bool<br/>}</span></pre><h1 id="e06a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">方法</h1><p id="5552" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">方法是在特定类型实例上调用的关联函数。方法“消耗”调用者对象的资源。</p><h2 id="b02d" class="mr jw in bd jx ms mt dn kb mu mv dp kf lx mw mx kj lz my mz kn mb na nb kr nc bi translated">什么时候使用方法？</h2><p id="7f13" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">这很容易与类方法相比较。当需要对特定类型进行操作时，最好实现与该类型相关联的方法。</p><h2 id="3de3" class="mr jw in bd jx ms mt dn kb mu mv dp kf lx mw mx kj lz my mz kn mb na nb kr nc bi translated">搜索</h2><p id="a86a" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">我们定义了两种搜索方法。这两种方法都绑定到不同的类型。一个是<em class="ky"> bst 型</em>一个是<em class="ky">节点型</em>。搜索方法检查根。如果根满足键，立即返回。否则，调用节点类型搜索在后续节点中查找键。</p><h2 id="6bfd" class="mr jw in bd jx ms mt dn kb mu mv dp kf lx mw mx kj lz my mz kn mb na nb kr nc bi translated">插入</h2><p id="9174" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">插入方法类似于搜索。唯一不同的是，它不检查键的存在；它通过在树中创建一个新节点来将键添加到树中。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="36eb" class="mm jw in mi b be mn mo l mp mq">func (tree *bst) Insert(data int) *bst {<br/>    if tree.root == nil {<br/>        tree.root = &amp;node{<br/>            data: data,<br/>        }<br/>    } else {<br/>        tree.root.insert(data)<br/>    }<br/>    return tree<br/>}<br/>func (nd *node) insert(data int) {<br/>    if nd == nil {<br/>        return<br/>    } else if data &lt; nd.data {<br/>        if nd.left == nil {<br/>            nd.left = &amp;node{<br/>                data: data,<br/>            }<br/>        } else {<br/>            nd.left.insert(data)<br/>        }<br/>    } else {<br/>        if nd.right == nil {<br/>            nd.right = &amp;node{<br/>                data: data,<br/>            }<br/>        } else {<br/>            nd.right.insert(data)<br/>        }<br/>    }<br/>}<br/>func (tree *bst) Search(key int) bool {<br/>    var keyFound bool<br/>    if tree.root == nil {<br/>        keyFound = false<br/>    } else if tree.root.data != key {<br/>        keyFound = tree.root.search(key)<br/>    } else {<br/>        keyFound = true<br/>    }<br/>    return keyFound<br/>}<br/>func (nd *node) search(key int) bool {<br/>    var keyFound bool<br/>    if nd == nil {<br/>        keyFound = false<br/>    } else if key == nd.data {<br/>        keyFound = true<br/>    } else {<br/>        if nd.data &gt; key {<br/>            keyFound = nd.left.search(key)<br/>        } else {<br/>            keyFound = nd.right.search(key)<br/>        }<br/>    }<br/>    return keyFound<br/>}<br/>func (tree *bst) GetRoot() *node {<br/>    return tree.root<br/>}</span></pre><h1 id="b055" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">功能</h1><p id="4fad" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">另一方面，函数是独立的，不绑定到任何类型。接受一个对象作为参数，并在其上进行计算。</p><h2 id="64b5" class="mr jw in bd jx ms mt dn kb mu mv dp kf lx mw mx kj lz my mz kn mb na nb kr nc bi translated">何时使用函数？</h2><p id="2731" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">这取决于你想如何组织你的程序。将函数与类型绑定会产生一个方法。但是当涉及到多种类型的操作时，方法是最少的。</p><p id="033c" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lx lj lk ll lz ln lo lp mb lr ls lt lu ig bi translated">函数是程序中任何时候都需要调用的东西。使它成为关联函数总是需要一个对象来进行函数调用。对于不需要保存在内存中的东西来说，这是多余的。</p><p id="a8a4" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lx lj lk ll lz ln lo lp mb lr ls lt lu ig bi translated">简单来说，<strong class="kz io"> <em class="ky">输入- &gt;处理- &gt;输出</em></strong>；就是一个函数是为<strong class="kz io">T5 制作的，在这里它只执行一个单一的任务 </strong>。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="1ce7" class="mm jw in mi b be mn mo l mp mq">func preOrderTraversal(root *node) {<br/>    if root == nil {<br/>        return<br/>    }<br/>    fmt.Print(root.data, " ")<br/>    preOrderTraversal(root.left)<br/>    preOrderTraversal(root.right)<br/>}<br/>func inOrderTraversal(root *node) {<br/>    if root == nil {<br/>        return<br/>    }<br/>    inOrderTraversal(root.left)<br/>    fmt.Print(root.data, " ")<br/>    inOrderTraversal(root.right)<br/>}<br/>func postOrderTraversal(root *node) {<br/>    if root == nil {<br/>        return<br/>    }<br/>    postOrderTraversal(root.left)<br/>    postOrderTraversal(root.right)<br/>    fmt.Print(root.data, " ")<br/>}<br/>func printTree(root *node, space int) {<br/>    if root == nil {<br/>        return<br/>    }<br/>    space += COUNT<br/>    printTree(root.right, space)<br/>    for i := COUNT; i &lt; space; i++ {<br/>        fmt.Printf(":")<br/>    }<br/>    fmt.Printf("[")<br/>    fmt.Printf("%v", root.data)<br/>    fmt.Println("]")<br/>    printTree(root.left, space)<br/>}</span></pre><h1 id="beb1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">构造器</h1><p id="5a2f" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">构造函数是初始化树对象的函数。</p><pre class="md me mf mg gt mh mi nd ne aw nf bi"><span id="e3a9" class="mr jw in mi b gy ng nh l ni mq">func NewBST() BSTService {<br/>    return &amp;bst{}<br/>}</span></pre><h1 id="3278" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">主要的</h1><p id="4c7f" class="pw-post-body-paragraph kw kx in kz b la lv lc ld le lw lg lh lx ly lk ll lz ma lo lp mb mc ls lt lu ig bi translated">定义测试和验证二叉查找树的主函数。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="f7da" class="mm jw in mi b be mn mo l mp mq">package main<br/>import "fmt"<br/>const (<br/>    COUNT int = 5<br/>)<br/>func main() {<br/>    tree := NewBST()<br/>    tree.Insert(10)<br/>    tree.Insert(5)<br/>    tree.Insert(15)<br/>    tree.Insert(4)<br/>    tree.Insert(16)<br/>    tree.Insert(6)<br/>    tree.Insert(13)<br/>    tree.Insert(1)<br/>    tree.Insert(12)<br/>    tree.Insert(2)<br/>    tree.Insert(20)<br/>    printTree(tree.GetRoot(), 0)<br/>    fmt.Printf("Pre-Order: ")<br/>    preOrderTraversal(tree.GetRoot())<br/>    fmt.Printf("\nIn-Order: ")<br/>    inOrderTraversal(tree.GetRoot())<br/>    fmt.Printf("\nPost-Order: ")<br/>    postOrderTraversal(tree.GetRoot())<br/>    fmt.Println()<br/>    fmt.Println("20 Exists:", tree.Search(20))<br/>    fmt.Println("21 Exists:", tree.Search(21))<br/>}<br/>/* Output<br/>:::::::::::::::[20]<br/>::::::::::[16]<br/>:::::[15]<br/>::::::::::[13]<br/>:::::::::::::::[12]<br/>[10]<br/>::::::::::[6]<br/>:::::[5]<br/>::::::::::[4]<br/>::::::::::::::::::::[2]<br/>:::::::::::::::[1]<br/>Pre-Order: 10 5 4 1 2 6 15 13 12 16 20 <br/>In-Order: 1 2 4 5 6 10 12 13 15 16 20 <br/>Post-Order: 2 1 4 6 5 12 13 20 16 15 10<br/>20 Exists: true<br/>21 Exists: false<br/>*/</span></pre></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="e541" class="pw-post-body-paragraph kw kx in kz b la lb lc ld le lf lg lh lx lj lk ll lz ln lo lp mb lr ls lt lu ig bi translated"><em class="ky">希望这篇文章有助于对 golang 的树结构有一个基本的了解。如有错误或进一步建议，请在下方评论。谢谢！</em></p></div></div>    
</body>
</html>