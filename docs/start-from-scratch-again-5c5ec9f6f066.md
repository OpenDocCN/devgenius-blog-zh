# 从头再来

> 原文：<https://blog.devgenius.io/start-from-scratch-again-5c5ec9f6f066?source=collection_archive---------3----------------------->

为什么我们认为重写一个产品的所有代码会更好？

![](img/9ef5726515a8da2a317298c2178aa0ee.png)

我认为很多开发者都有这样的感觉，如果他们可以重新开始一个产品，他们会做得更好，因为他们会做出正确的决定。这是一种思维方式上的傲慢。我们真的比所有参与当前系统的人了解更多吗？

我认为能让一个公司做出重写一个产品代码的决定的更重要的原因之一是[偶然的复杂性](https://www.youtube.com/watch?v=WSes_PexXcA&t=4s)。
事实上，偶然的复杂性是最终的原因，但让你这样想的是你在开发团队中看到的效果。
团队通常会慢下来很多，bug 数量非常多，我们花在修复东西上的时间比花在特性上的时间还多。

在这种情况下，当市场变化时，我们有一个竞争对手，或者我们想扩展到另一个国家，我们只能在那里看到解决方案。从头再来，看看这次我们是否做得更好。

## 什么叫从头开始？

从某种意义上说，从头开始就像是任何人都不想做的最后一个决定，我们说我们上次失败了。根据我的经验，当我们创建不可维护的代码时，就会出现这个问题。我不确定为什么我们如此肯定这次我们会做得更好，我认为这与[邓宁-克鲁格](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)效应有很大关系。

如果我们决定采用这种方法，我们必须考虑与从头开始相关的几个问题:

*   何时从一个系统切换到另一个系统
*   如何迁移数据
*   [特性奇偶性](https://www.thoughtworks.com/radar/techniques/legacy-migration-feature-parity)
*   我们对旧平台上的东西一无所知

如果我们从头开始写一个系统，我们选择了立刻改变一切。这是一个非常冒险的方法，迫使你开始比较两个系统，以确保你的新系统没有让你赔钱。但是，如果您将两个系统与真实用户进行比较，您将需要找到一种在它们之间共享数据的方法，这可能很棘手，甚至会迫使您使用旧的数据库(这在新的设计方面限制了您很多)。

为了比较两个系统，我们可以考虑 A/B 测试，但是比较复杂的系统意味着比较许多变量，所以我们不会真正理解为什么新系统的性能比旧系统差。当这种情况发生时，我们进入一个兔子洞。我们通常认为这是因为新系统需要旧系统所具有的特性。因此，我们开始添加更多的东西来实现功能奇偶校验。

功能对等会带来越来越多的延迟，如果我们长时间比较两个系统，也许有些人会要求改进旧系统，修复一些错误或添加公司需要的新功能。所以我们开始了一场新系统在数量上无法与旧系统竞争的竞赛。
事实上功能对等是一个坏主意，我们知道用户对功能的使用遵循帕累托原则， **80%的用户只使用应用程序的 20%的功能。**所以如果我们在这种情况下，识别出客户真正感兴趣的 20%的特性并把它们转移到新系统中会更有效率。

遗留系统的另一个大问题是，我们并不真正理解系统中做出的一些决策，以及为什么做出这些决策。在软件架构中，“为什么”比“如何”更重要，为了避免这种情况再次发生，我们可以使用 [ADR 的](https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records)。

## 这次我们如何做得更好？

我认为我们通常倾向于在新项目中引入所有我们知道的新奇技术和架构，但是我们不会改变我们的工作方式。

> 许多高级开发人员年复一年地构建相同类型的应用程序，对这种单调感到厌倦。大多数开发人员宁愿写一个框架，也不愿用框架来创造有用的东西:元工作比工作更有趣。工作是无聊的、平凡的、重复的，然而创造新的东西是令人兴奋的。这体现在两个方面。首先，许多高级开发人员开始编写其他开发人员使用的基础设施，而不是使用现有的(通常是开源的)软件。
> 构建进化架构

Demmings 说，我们依赖工具，但不依赖过程:

> *“系统性能 95%的变化是由系统本身引起的；只有 5%是人民造成的。”*
> 
> *W. Edwards Deming，*团队手册简介

如果这次我们想做得更好，我们需要改变我们的工作方式，因为这种工作方式会导致重写整个产品。但是改变意味着什么呢？根据我的经验，这意味着与质量一起工作，质量必须是一等公民。
最终目标不是再次重写应用，最终目标应该是将组织改为[避免再次重写应用](https://martinfowler.com/articles/patterns-legacy-displacement/#ChangeTheOrganizationToAllowThisToHappenOnAnOngoingBasis)。

## 有替代方案吗？

我认为有一个更好的选择，重写整个产品。但这也是很昂贵的，基本上是支付产品的技术债务。开始完全支付，但分阶段支付。重构遗留代码是困难的，但有时比重写一切更便宜，它迫使你以另一种方式工作，理解产品并讨论某样东西是否有用。

有时我们需要[发展架构](https://www.thoughtworks.com/books/building-evolutionary-architectures)。例如，如果我们想要引入一种新的编程语言，我们可以在我们的遗留系统中创建一个有界的上下文，与系统的其余部分进行清晰的交互，然后这就完成了。将代码转移到另一个使用另一种语言的项目中，然后你可以决定这个部分是否是微服务，或者你如何将旧系统与新系统连接起来。

有一些事情你总是需要重构代码，**测试**。如果你想知道如何处理遗留代码，我推荐你[有效地处理遗留代码。](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)