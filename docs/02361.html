<html>
<head>
<title>Software Design : A Black Art!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计:一门黑色艺术！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/software-design-a-black-art-48c366e747c8?source=collection_archive---------14-----------------------#2020-07-30">https://blog.devgenius.io/software-design-a-black-art-48c366e747c8?source=collection_archive---------14-----------------------#2020-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/002f743b1cd3ef67aab6d2369f8d5d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YU4NVsbk3CC0_zrk"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">布莱克·康纳利在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9fba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">软件设计仍然是一门黑色艺术。对于如何设计软件或者一个好的设计应该是什么样子，基本上没有一致的意见。当人们谈论软件工程时，他们大多谈论软件工具、测试和过程，但是当谈到设计软件的基本行为时，我们几乎没有交谈。通过这篇文章，我们将讨论一些设计软件的基础知识，看看我们是否能以某种方式增加软件社区中的设计意识。</p><p id="737e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">计算机科学中最重要的思想之一是“问题分解”，根据定义，这是将一个复杂的问题或系统分割成可以独立构建和维护的部分。</p><p id="c9af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">优秀软件设计的10个高级抽象概念</p><ul class=""><li id="1cc5" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">工作代码是不够的:必须最小化复杂性</li><li id="238b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">复杂性来自依赖性和模糊性</li><li id="b3fd" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">战略与战术编程</li><li id="bdb9" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">课要深</li><li id="3085" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">通用类更深入</li><li id="6d04" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">新的层次，新的抽象</li><li id="fc0c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">注释应该描述代码中不明显的东西</li><li id="4907" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">定义不存在的错误</li><li id="4d29" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">降低复杂性</li></ul><h2 id="5fe4" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">课要深</h2><p id="a998" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">把一个类想象成一个矩形，矩形的面积是类提供给系统其余部分的功能，上边是类的接口。我所说的接口，是指人们为了使用这个类而必须记住的所有东西。不仅仅是函数的签名，还有副作用和依赖性。这是该类强加给系统其余部分的复杂性成本。所以你需要最小的接口(成本)，最大的面积(收益)。与之相反的是所谓的浅类，它要么没有很多功能，要么接口很复杂，或者两者兼而有之。这些类没有给我们任何杠杆，事实上，额外的接口开销增加了比你隐藏在下面的更多的复杂性。我们想要的是一个深层次的类，它由一个非常简单的接口和大量的功能组成。这是对抽象的另一种思考方式，它提供了一种简单的方法来访问一些非常复杂的东西。所以深类是很好的抽象。这个概念可以应用于类、方法、接口或任何有接口或实现的东西</p><h2 id="fa65" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">典型浅层方法</h2><p id="3aa0" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">private void addNullValueForAttribute(String属性){</p><p id="3141" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">data.put(属性，null)；</p><p id="6c76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">}</p><h2 id="88dd" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">相对浅薄的阶级</h2><p id="5423" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">列表很容易操作，因为我们知道指针藏在列表下面的某个地方。那是一个浅薄的阶层。现在你不能总是淘汰浅类。你知道吗，有时候你最多只能上一堂很浅的课。但是请记住，肤浅的类不会帮助你战胜复杂性。使用浅类源于类和方法应该小的概念。开发人员被告知每一个超过n行的方法都应该被砍掉。听起来很熟悉？在java世界中，创建小类已经成为许多开发人员的目标，尽管java并不要求这样做，例如，如果你想打开和读取一个文件，你需要三个对象，随着你的项目变得越来越大，这带来了巨大的复杂性。在管理复杂性时，你想让普通的情况变得真正简单。所以长度不是根本问题，最重要的是抽象。</p><h2 id="8f17" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">深度接口的一个例子</h2><p id="c387" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">Unix文件I/O接口五个简单的函数覆盖了每个函数的简单接口，唯一的复杂性是标志和权限。想想这个简单的界面背后隐藏着什么？这通常需要数十万行代码和许多其他底层接口，从而产生了令人惊叹的五个函数(打开、关闭、读取、写入和查找)。</p><h2 id="c9bb" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">定义不存在的错误</h2><p id="d179" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">所以我们都知道异常是系统复杂性的巨大来源。例如，在RAMCloud存储系统中，开发人员认为他们正在构建一个低延迟的存储系统，这意味着我们将花费大部分时间来使事情变得非常快。但事实上，他们90%的时间都在进行崩溃恢复。大多数程序员认为抛出更多的异常会带来更好的防御。但是他们并不知道谁来处理这些错误。这导致必须捕获和处理的异常激增。然后异常本身会产生更多的错误。因此，您将添加辅助异常来处理这些异常。</p><p id="82ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们建议尽量减少处理这些异常的地方。例如，windows中的文件删除至少在早期，如果您试图删除某个文件，而某个进程打开了该文件，这是不允许的，Linux有一个漂亮可爱的解决方案，可以消除这个错误。在Unix中，如果在文件打开时删除它，会发生的情况是从目录和名称空间中删除该文件。它不再出现在文件系统中的任何地方。但是文件的实际内容仍然存在，所以使用该文件的进程仍然继续访问该文件。然后当文件的最后一个实例关闭时，它会清理并丢弃。在第二个例子中，在java中，各种方法将从字符串中提取一个子字符串。而这些方法都是非常异常快乐的。如果任一索引超出子字符串的范围并引发异常。这可能是一个巨大的痛苦，通常在调用Java substring命令之前，您不得不编写自己的代码来将我的索引裁剪到字符串的范围，所以您不会得到这些异常。更好的解决方案是返回您指定的索引和字符串的可用内容之间的重叠部分。因此，如果两个索引都在字符串的范围之外，它将返回一个空字符串。这将消除人们不得不编写的大量额外代码，以及许多运行时异常，因为人们在调用命令之前忘记将他们的索引裁剪到字符串的范围。所以这里的总体想法是尝试减少人们必须处理异常的地方的数量。</p><p id="37a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我看来，优秀设计的最大障碍是心态。如果你没有正确的心态，你就永远不会做出好的设计。我认为有两种方法接近编程或设计过程，即战术方法和战略方法。大多数人采取的是战术性的方法，也就是让一些东西工作起来，比如修复一个bug或者引入一个新的特性。这种方法的问题是，当你有一种想法，我会尝试有一个干净的运行代码。但是如果在你的源代码中有一些不干净的代码，它将开始在你的团队将跟随的地方建立。过了一段时间，你开始重新考虑你之前的决定，但是现在你不能再做了，因为还有一个截止日期。一个星期后，这种情况会越来越多，使得重新访问代码的任何部分都变得不可能。因此，系统将很快变得非常复杂。复杂性不是你犯的一个错误，而是许多人在一段时间内犯的成百上千个错误。战术程序员的极端情况是，程序员产出大量相当劣质的代码，80%的代码都能正常工作，但留下的却是一片废墟。工作代码是不够的，那不能是你唯一的目标！。一个更好的方法可能是战略方法，目标是一个伟大的设计。一个好的设计可以帮助团队在未来更快地发展。这就像投资代码以获得未来的速度回报，不要担心，只管去做吧。为了实现这一点，你应该有一个零容忍的方法，你不能让这些小棉绒蠕变。</p><p id="f8eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你看看今天的初创公司，他们是100%战术性的，因为他们正在经历的最后期限的压力，这导致了极其难以修复的损害。</p><h1 id="f5b7" class="mk ln in bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">好的设计应该投入多少时间？</h1><p id="2ee5" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">首先，如果可能的话，进行10-20%或更多的小额投资。我敢打赌，几乎每个人都可以每天放慢速度，意识到你会把所有的都拿回来。在为你的模块设计接口时，遵循迭代的方法。尽量想出深类。在进行单元测试时编写文档。然后每当你做出改变时，要意识到你不可能第一次就做对。假设每次你在这个系统中，你都必须改进。通常，当人们更改代码时，他们通常会选择尽可能少的代码行，因为有时他们害怕或不理解这一点。当你从零开始构建这个系统的时候，试着找到一个干净的方法来做这件事。但是，有时你实际上不能这样做，因为这可能超出了你能做的范围。但是你应该尽力适应你的变化。</p><p id="07f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是希望你喜欢阅读这篇文章！</p><p id="91e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章是基于约翰·奥斯特胡特的“软件设计哲学”演讲</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="94c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其他资源:</p><ul class=""><li id="88e5" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">约翰·奥特的软件设计哲学</li></ul></div></div>    
</body>
</html>