<html>
<head>
<title>Python or Filtering in Queries: sorting JSON responses from an Oracle Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 或查询中的过滤:对来自 Oracle 数据库的 JSON 响应进行排序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-or-filtering-in-queries-sorting-json-responses-from-an-oracle-database-95cbf023153a?source=collection_archive---------0-----------------------#2022-05-23">https://blog.devgenius.io/python-or-filtering-in-queries-sorting-json-responses-from-an-oracle-database-95cbf023153a?source=collection_archive---------0-----------------------#2022-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="86cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://followthecoffee.com/wtforms-flask-oracle-rest-apis-ords/" rel="noopener ugc nofollow" target="_blank">最近的一篇文章</a>中，我讨论了从我的支持 REST 的数据库表中获取 JSON 响应(如下所示):</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b79d60fe5ba40c9866b092703f4a3eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CszFQKW7sfwcfIWYfHot-Q.png"/></div></div></figure><p id="01e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在之后对这些城市<em class="kv">进行排序，我执行了一个 GET 请求(使用了一些 python 代码)。然而，经过最近的讨论和来自<a class="ae ki" href="https://www.thatjeffsmith.com/" rel="noopener ugc nofollow" target="_blank">jeffsmith</a>的建议，我想我应该分享<em class="kv">另一种</em>方法，你可以从数据源</em>对这些数据<em class="kv">进行排序。</em></p><h1 id="514c" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">背景</h1><p id="f4f2" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如果您还记得，我的 python 代码中:</p><ol class=""><li id="1033" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">执行 GET 请求，</li><li id="9bd9" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">将城市提取到列表中，并</li><li id="2bc3" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">将它们按升序排序，</li></ol><p id="91c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">…看起来像这样:</p><pre class="kk kl km kn gt mn mo mp mq aw mr bi"><span id="c68e" class="ms kx in mo b gy mt mu l mv mw">def city_choices_python(): <br/>    import requests<br/>    import json <br/>    city_list = []</span><span id="18fb" class="ms kx in mo b gy mx mu l mv mw">    URL = 'https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/'<br/>   <br/>    response = requests.get(URL)<br/>    r = json.loads(response.text)<br/>    for nestedArr in r['items']:<br/>        city_list.append(nestedArr['city'])<br/>    return sorted(city_list)</span></pre><p id="9216" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，在这个版本中，ORDS 提供的 URI 保持不变。我只是使用这个简单的“sorted(city_list)”函数来返回一个按升序排序的城市列表(仅供参考:这是这个代码块的最后一行)。</p><h1 id="4ba8" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">查询中的过滤</h1><p id="7807" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">这种方法在我的情况下工作得很好，但是我现在…开悟了…</p><p id="ff30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，我现在意识到我还有其他选择。在 get 请求时，我并没有真正想到可以在查询中过滤<em class="kv">。</em></p><blockquote class="my mz na"><p id="8c1f" class="jk jl kv jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">筛选是通过在多个页面资源上使用基于请求的动态筛选器定义来限制集合资源的过程，其中每个页面都包含完整集合中的项目子集。过滤可以有效地遍历大型集合。</p><p id="8b98" class="jk jl kv jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated"><a class="ae ki" href="https://docs.oracle.com/en/database/oracle/oracle-rest-data-services/19.2/aelig/developing-REST-applications.html#GUID-091748F8-3D14-402B-9310-25E6A9116B47" rel="noopener ugc nofollow" target="_blank"> <em class="in"> ORDS 文档</em> </a></p></blockquote><p id="4ecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢的是，查询中的过滤不需要对原始 URI 进行任何更改。这意味着，您不需要返回(在我的例子中，我使用…)数据库操作来修改任何东西。您只需在 URI 中包含过滤器。</p><p id="a201" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的例子中，它看起来像这样:</p><pre class="kk kl km kn gt mn mo mp mq aw mr bi"><span id="14d2" class="ms kx in mo b gy mt mu l mv mw"><a class="ae ki" href="https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/?q={%22$orderby%22:{%22city%22:%22asc%22}}" rel="noopener ugc nofollow" target="_blank">https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/?q={"$orderby":{"city":"asc"}}</a></span></pre><h1 id="1b27" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">暂停！</h1><p id="6775" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">这会让你头脑混乱，所以听好了。引号(例如“<br/>”)不能通过互联网传输，因此需要转换为 ASCII 字符集。</p><p id="408d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">HTML-5 中的引用在 URL 中将看起来像“%22”。因此，如果您复制上面的 URL，然后再次粘贴它，它可能会在您浏览器的地址栏中显示如下:</p><pre class="kk kl km kn gt mn mo mp mq aw mr bi"><span id="e468" class="ms kx in mo b gy mt mu l mv mw"><a class="ae ki" href="https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/?q={%22$orderby%22:{%22city%22:%22asc%22}}" rel="noopener ugc nofollow" target="_blank">https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/?q={%22$orderby%22:{%22city%22:%22asc%22}}</a></span></pre><p id="485a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将从 UTF-8 编码(引号)开始，在某个时候您会看到 ASCII 编码(它是%和十六进制编码的组合)。</p><p id="79df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我之所以提到这一点，是因为我注意到当我将更新后的 URL 复制到我的 VS 代码编辑器中时，它看起来像这样:</p><pre class="kk kl km kn gt mn mo mp mq aw mr bi"><span id="02ca" class="ms kx in mo b gy mt mu l mv mw">def city_choices_ords(): <br/>    import requests<br/>    import json <br/>    city_list = []</span><span id="868a" class="ms kx in mo b gy mx mu l mv mw">    URL = 'https://gf641ea24ecc468-dbmcdeebyface.adb.us-ashburn-1.oraclecloudapps.com/ords/pythondev/cities/?q={%22$orderby%22:{%22city%22:%22asc%22}}'</span><span id="1424" class="ms kx in mo b gy mx mu l mv mw">    response = requests.get(URL)<br/>    r = json.loads(response.text)<br/>    for nestedArr in r['items']:<br/>        city_list.append(nestedArr['city'])<br/>    return(city_list)</span></pre><p id="aa80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要惊慌，一切都还正常。但是查询看起来像这样:</p><pre class="kk kl km kn gt mn mo mp mq aw mr bi"><span id="1682" class="ms kx in mo b gy mt mu l mv mw">?q={%22$orderby%22:{%22city%22:%22asc%22}}</span></pre><h1 id="e0d6" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这是什么话？</h1><p id="96dd" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">上面的查询请求根据“城市”列对城市表进行升序(“asc”)排序。如果您将浏览器指向它，就可以看到这一点。它将显示如下:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/b0e084f8d32e6875867149e50bdd583d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RsIukBH7U29dSrUx.png"/></div></div></figure><p id="76b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">排序并不是你能做的唯一的过滤类型，它的组合是无限的…</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/82e0d9e23f835acc4dccedbafdc8c36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*faU09pONzSDJLvZpfZF-Qw.gif"/></div></figure><p id="9cb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">… <a class="ae ki" href="https://docs.oracle.com/en/database/oracle/oracle-rest-data-services/18.3/aelig/developing-REST-applications.html#GUID-091748F8-3D14-402B-9310-25E6A9116B47" rel="noopener ugc nofollow" target="_blank">看一看</a>。</p><h1 id="b564" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">比较性能</h1><p id="4cdf" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">最后一件事…我进行了一个非常粗略的 A/B 性能测试，比较了两个代码版本。</p><p id="a894" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，没有明显的区别。我应该提醒一下，我正在使用一个<strong class="jm io"> <em class="kv">非常</em> </strong>小的数据库对象(一个有 2 列 18 个城市的表)。因此，如果存在这样或那样的差异，那也是微不足道的。</p><p id="7336" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还是为了好玩录了测试。您将看到十个请求(每个版本五个)，运行时间基本上是相同的。我知道这在统计学上不合理，但这样做是为了满足我自己的好奇心。我们的文档实际上说明了过滤对于遍历大型对象是有利的，所以这可能是一个糟糕的例子。随着请求的增加，我不得不在查询中进行图像过滤。</p><p id="359a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管如此，请自己看看结果:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="c5bd" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结束了</h1><p id="015b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">现在，在使用支持 REST 的表(或其他对象)时，您有了几个排序选项。好的一面是，用 ORDS 设置这些端点仍然可以通过简单的鼠标点击来完成。</p><p id="95da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，请记住，在查询中过滤时，排序不是唯一可以完成的事情。还有很多其他功能，不胜枚举。但是我会把这一页标上书签<a class="ae ki" href="https://docs.oracle.com/en/database/oracle/oracle-rest-data-services/19.2/aelig/developing-REST-applications.html#GUID-091748F8-3D14-402B-9310-25E6A9116B47" rel="noopener ugc nofollow" target="_blank">,这样你以后可以参考。</a></p><p id="161e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不想说你可以过滤掉<em class="kv">所有的东西</em>，但是看起来确实如此。对于像我这样的 python 新手来说，这可能是更好的前进方式。</p><p id="e298" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，我在代码中添加“sort()”函数的那一天正是我观看“python 技巧”视频的同一天(实际上是那天早上的早些时候)，视频中提到了排序。这纯粹是运气。</p><p id="6d14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果没有那个视频，我至少还会困在那里一天，去想如何给我的清单排序。</p><p id="8ae2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿，至少现在我知道我不会被限制在基于我知道或不知道的 python 函数来过滤什么。我不能是唯一一个…对吗？</p><h1 id="7d96" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">跟随</h1><p id="5e32" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">一定要跟着一起寻找更多乐趣:</p><ul class=""><li id="b65a" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh ni mf mg mh bi translated"><a class="ae ki" href="https://followthecoffee.com/" rel="noopener ugc nofollow" target="_blank">我的博客</a></li><li id="6f68" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://twitter.com/chrishoina%29" rel="noopener ugc nofollow" target="_blank">推特</a></li><li id="f29d" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://mastodon.technology/web/@chrishoina" rel="noopener ugc nofollow" target="_blank">乳齿象</a></li><li id="8f0e" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://www.youtube.com/user/chrishoina/" rel="noopener ugc nofollow" target="_blank"> YouTube </a></li><li id="7a2f" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://github.com/chrishoina" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="4c9c" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://discord.gg/seYeAPgq9E" rel="noopener ugc nofollow" target="_blank">不和谐</a></li><li id="6432" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://www.linkedin.com/in/chrishoina/" rel="noopener ugc nofollow" target="_blank">领英</a></li><li id="9407" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://stackoverflow.com/users/9552864/chris-hoina" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></li><li id="079e" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh ni mf mg mh bi translated"><a class="ae ki" href="https://tealfeed.com/chrishoina" rel="noopener ugc nofollow" target="_blank"> Tealfeed </a></li></ul></div></div>    
</body>
</html>