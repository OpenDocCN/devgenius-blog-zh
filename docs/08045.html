<html>
<head>
<title>A quick guide about Dependency Injection (in Angular/React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入快速指南(在 Angular/React 中)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-quick-guide-about-dependency-injection-in-angular-react-2ff26fe57bd0?source=collection_archive---------3-----------------------#2022-05-13">https://blog.devgenius.io/a-quick-guide-about-dependency-injection-in-angular-react-2ff26fe57bd0?source=collection_archive---------3-----------------------#2022-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b06f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，DI(依赖注入)是一个超级简单的概念，广泛应用于软件开发中。它的基本意思是，当一个组件需要一些道具来渲染时，这些道具是从这个组件的外部传递过来的，而不是直接在这个组件内部创建这些道具。这些道具被称为依赖。当这个组件即将运行时，需要有人把这些道具<strong class="jm io">传递给它(或者我们把这些道具注入到组件中)。道具可以是对象或功能。</strong></p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="a963" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">反应部分:</strong></p><p id="3efa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个 react 示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="7473" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以通过这个链接访问这个例子:<a class="ae kw" href="https://react-ts-fjrt4f.stackblitz.io" rel="noopener ugc nofollow" target="_blank">https://react-ts-fjrt 4 f . stack blitz . io</a></p><p id="8725" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">NameComponent 需要 personInfo 对象和 getNameFunction 来呈现。personInfo 和 getNameFunc 是依赖项，它们需要被注入到 NameComponent 中。</p><p id="e8b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">依赖注入(DI)的目的是分离我们的应用程序，使测试每个组件变得容易。</p><p id="5057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么？</p><p id="f2ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为当我们测试这个组件时，我们只关心组件本身的内部逻辑，即它是否会在一个段落 html 标签中返回名称。没必要关心我们是怎么得到这个名字的。我们可以简单地模仿 getNameFunc 并将其传递给 NameComponent。NameComponent 的单元测试可以写成这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kx"><img src="../Images/574a4cc46cba75cc832d1a79d02dbd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wGhvy2izfibCt3fZeQR7g.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">NameComponent 的单元测试</figcaption></figure><p id="26d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">getName 函数可以像这样独立地进行单元测试:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi li"><img src="../Images/1d1ff8d4c74fdfaa6e46ab615f5544fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_Ng2IY5ethXhXajvRsCAQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">getName 函数的单元测试</figcaption></figure><p id="31a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将来，如果业务逻辑对我们如何获得名称有重大改变。只需要更改 getName 函数，而不需要更改 NameComponent。</p><p id="7d23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有没有注意到我们实际上有一个潜在的问题？</p><p id="0285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图片我们有另一个名为 OrderComponent 的组件，它是 NameComponent 的父组件。我们如何将 getNameFunc 属性传递给 NameComponent？我们必须在 OrderComponent 中手动完成，如在 OrderComponent 中导入它，并将其传递(或注入)到 NameComponent。大概是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ca"><img src="../Images/1f3834887908a00f62067d2827b432f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZhaLKabT1Ja3K93P0SoxA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">OrderComponent 和 NameCompoent 的示例</figcaption></figure><p id="4f3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，它看起来没问题。没那么糟。<strong class="jm io">如果 NameComponent 实际上需要某些类的三个实例呢？我们必须在 OrderComponent 中创建三个实例并将其传递给 NameComponent 吗？</strong></p><p id="a590" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有人能够在 NameComponent 需要的时候为我提供 getNameFunc 或实例，生活将会变得更加轻松和美好。如果可能的话，就不需要导入 getName 函数或在 OrderComponent 中创建这些实例，并将它们传递给 NameComponent。NameComponent 可以从某个地方获取它们。</p><p id="40b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解决方法是使用容器。容器的目的是为我自动创建一个实例，并将这些实例传递给任何需要它的组件。</strong></p><p id="0fc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是容器创建了一个实例(或 props ),而不是我们手动创建/导入这些实例。我们把控制权从我们身上转移到了容器上。它也被称为控制反转。这项技术广泛应用于角形。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="3a43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">角形部分:</strong></p><p id="ffc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 angular 中，当一个组件需要这些实例(或者我们称之为服务)时，angular 框架会为我们做这些。它创建这个实例并将其传递给组件。这样的实例(或服务)用可注入的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lj"><img src="../Images/911f5a38c67018c1fa3916e4b76bbc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4kP0Jwa2PzoMpOyfwfdnA.png"/></div></div></figure><p id="17bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">UserComponent 需要一个名为 UserService 的依赖项，但是我们作为开发人员没有手动创建 UserService 的新实例。angular 框架会自动为我们完成这项工作。它将首先在组件中本地查找 UserService，然后在模块(我指的是 ngModule)中查找，然后尝试全局查找。</p><p id="66eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">依赖关系总是单一的吗？</strong></p><p id="41b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">号码</p><p id="4266" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它可以是全局可用的，也可以只对模块或组件可用。</p><ol class=""><li id="d740" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">如果全局可用，那么它是单例的(app 只有一个实例)；</li><li id="5383" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">如果依赖关系只适用于一个组件或一个模块，那么我们可以有多个实例。</li></ol><h1 id="5231" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><strong class="ak">结论</strong></h1><ol class=""><li id="1b74" class="lk ll in jm b jn mw jr mx jv my jz mz kd na kh lp lq lr ls bi translated">依赖注入的目的是分离应用程序，使其易于测试。</li><li id="4de3" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">Angular 本身支持依赖注入，但在 react 中，我们手动或借助第三方库来实现。</li><li id="74a0" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">依赖并不总是单一的。这取决于如何定义这种依赖的范围。在 angular 中，如果一个服务在根中是可注入的，那么它就是单例的，否则可能有多个实例。</li></ol></div></div>    
</body>
</html>