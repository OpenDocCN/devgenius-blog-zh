<html>
<head>
<title>Laravel Events and Listeners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel 事件和侦听器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/laravel-events-and-listeners-5965b5cadcef?source=collection_archive---------1-----------------------#2020-07-19">https://blog.devgenius.io/laravel-events-and-listeners-5965b5cadcef?source=collection_archive---------1-----------------------#2020-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/174a0abdf95e9b6b379b32c229e6d043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ac0dNvKuaAZ_A715J49lrg.png"/></div></div></figure><p id="2859" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以前，我写过关于 Laravel 观察者的文章，并提到它是我喜欢的 Laravel 框架的一个特性，因为我偶然发现了它。</p><blockquote class="kt ku kv"><p id="e0f7" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在这里阅读<a class="ae la" href="https://medium.com/@elishaukpongson/introducing-laravel-observers-8f0198c6c9c" rel="noopener">这里</a></p></blockquote><p id="dbc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我将阐明 Laravel 框架中另一个我也感兴趣的部分，事件和听众。</p><p id="e0ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事件只是提醒您的应用程序某个动作已经发生的方式，事件可以在您的应用程序、控制器、模型、中间件的任何位置被分派，甚至在刀片文件中(您不应该这样做，但您明白我的意思)。</p><p id="ce8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顾名思义，侦听器侦听应用程序中发生的事件，但它们不只是侦听任何事件，每个侦听器都必须映射到一个事件，然后才能侦听该事件。</p><p id="06c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于响应调度事件的侦听器，侦听器类必须映射到特定的事件类。这些映射发生在 EventServiceProvider 类中，该类可以在<em class="kw"> app\Providers </em>文件夹中找到。</p><p id="65d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个事件可以有多个侦听器映射到它，当调度它时，所有侦听器类将按照它映射的顺序被连续触发。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3ac6" class="lk ll in lg b gy lm ln l lo lp">//Default EventServiceProvider Class</span><span id="a309" class="lk ll in lg b gy lq ln l lo lp"><br/>&lt;?php<br/><br/>namespace App\Providers;<br/><br/>use Illuminate\Auth\Events\Registered;<br/>use Illuminate\Auth\Listeners\SendEmailVerificationNotification;<br/>use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;<br/>use Illuminate\Support\Facades\Event;<br/><br/>class EventServiceProvider extends <em class="kw">ServiceProvider<br/></em>{<br/>    <em class="kw">/**<br/>     * The event listener mappings for the application.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@var </em></strong><em class="kw">array<br/>     */<br/>    </em>protected $listen = [<br/>        Registered::class =&gt; [<br/>            SendEmailVerificationNotification::class,<br/>        ],<br/>    ];<br/><br/>    <em class="kw">/**<br/>     * Register any events for your application.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function boot()<br/>    {<br/>        parent::<em class="kw">boot</em>();<br/><br/>        //<br/>    }<br/>}</span></pre><h1 id="1d54" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建事件和侦听器类</h1><p id="75c9" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">要创建一个事件类，使用<strong class="jx io"><em class="kw">make:event</em></strong>artisan 命令:</p><blockquote class="kt ku kv"><p id="c8cf" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">php 工匠制作:事件<event name=""/></p></blockquote><p id="1386" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令将在应用程序的<em class="kw"> app\Events </em>文件夹中创建一个新类，这就是创建事件类所需的全部内容。</p><p id="5f1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建一个监听器类，使用<strong class="jx io"><em class="kw">make:listener</em></strong>artisan 命令:</p><blockquote class="kt ku kv"><p id="17e1" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">php artisan make:listener <listener name=""/></p></blockquote><p id="496d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与事件创建中一样，该命令将在应用程序的<em class="kw"> app\Listeners </em>文件夹中创建一个新类，这就是创建侦听器类所需的全部内容。</p><p id="1687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建事件和侦听器的另一种方法，甚至可以说比前面提到的方法更简单，就是在 EventServiceProvider 类中注册事件和侦听器，然后运行:</p><blockquote class="kt ku kv"><p id="3592" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">php artisan 事件:生成</p></blockquote><p id="c073" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令将扫描 EventServiceProvider 类，并根据注册生成缺少的事件和侦听器。</p><p id="5800" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经在想如何注册一个事件并将一个侦听器映射到它，是吗？为此，请遵循以下模式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a927" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">//Event Service Provider Class</em></span><span id="db0e" class="lk ll in lg b gy lq ln l lo lp"><em class="kw">/**<br/> * The event listener mappings for the application.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@var </em></strong><em class="kw">array<br/> */<br/></em>protected $listen = [<br/>    'Event Class' =&gt; [<br/>        'Listener Class',<br/>        'Another Listener Class',<br/>        'Yet Another Listener Class',<br/>    ],<br/>];</span></pre><p id="2df6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我前面说过的，您可以将多个侦听器映射到一个特定的事件，它将按照它们被映射的顺序被连续处理。</p><h1 id="bb86" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">调度事件</h1><p id="9383" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">在撰写本文时，我知道有两种方法可以分派您的事件并触发侦听器:</p><ul class=""><li id="d8f4" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">event(new event class())；</li><li id="5b95" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">event class::dispatch()；</li></ul><blockquote class="kt ku kv"><p id="71b0" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">如果您的事件使用了<code class="fe nh ni nj lg b"><em class="in">Illuminate\Foundation\Events\Dispatchable</em></code>特征，您可以在事件上调用静态的<code class="fe nh ni nj lg b"><em class="in">dispatch</em></code>方法。传递给<code class="fe nh ni nj lg b"><em class="in">dispatch</em></code>方法的任何参数都将被传递给事件的构造函数。</p></blockquote><p id="9a71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该注意到，在事件类中声明的<strong class="jx io">公共</strong>属性可以在映射到它的监听器类中访问。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ddab" class="lk ll in lg b gy lm ln l lo lp">//Registered Event using in register controller.</span><span id="35ab" class="lk ll in lg b gy lq ln l lo lp">&lt;?php<br/><br/>namespace Illuminate\Auth\Events;<br/><br/>use Illuminate\Queue\SerializesModels;<br/><br/>class Registered<br/>{<br/>    use SerializesModels;<br/><br/>    <em class="kw">/**<br/>     * The authenticated user.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@var </em></strong><em class="kw">\Illuminate\Contracts\Auth\Authenticatable<br/>     */<br/>    </em>public $user;<br/><br/>    <em class="kw">/**<br/>     * Create a new event instance.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@param  </em></strong><em class="kw">\Illuminate\Contracts\Auth\Authenticatable  $user<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function __construct($user)<br/>    {<br/>        $this-&gt;user = $user;<br/>    }<br/>}</span></pre></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><pre class="lf lg lh li aw lj bi"><span id="68f6" class="lk ll in lg b gy nr ns nt nu nv ln l lo lp">&lt;?php<br/><br/>namespace App\Listeners;<br/><br/>use Illuminate\Contracts\Queue\ShouldQueue;<br/>use Illuminate\Queue\InteractsWithQueue;<br/><br/>class RegisteredListener<br/>{<br/>    <em class="kw">/**<br/>     * Create the event listener.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function __construct()<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="kw">/**<br/>     * Handle the event.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@param  </em></strong><em class="kw">object  $event<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function handle($event)<br/>    {<br/>        $event-&gt;user <br/>        //this will have the content of the user property from the             event class<br/>    }<br/>}</span></pre><h1 id="f87e" class="lr ll in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">用例</h1><p id="533e" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">事件和侦听器的一个非常简单的用例是 Laravel 框架上的默认用户创建流。</p><p id="b327" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于许多应用程序来说，在用户创建后可能会有许多进程，在控制器方法中包含所有这些逻辑，可能不仅仅是聚集控制器方法，而是在用户注册我的应用程序后，我想采取的每个额外的进程。</p><p id="2c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将不得不回到那个方法，做一些违背 S.O.L.I.D 原则的打开/关闭和单一责任原则的编辑，事件和监听器来拯救。</p><blockquote class="kt ku kv"><p id="3c0a" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">什么是 S.O.L.I.D 原则？</strong></p><p id="2ab1" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">南 O.L.I.D 是一个首字母缩写词，代表面向对象编程和代码设计的五个原则，由我们敬爱的 Bob 叔叔(Robert C. Martin)在 2000 年提出理论。作者 Michael Feathers 创造了这个缩写词:</p><p id="9984" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">【S】</strong>单一责任原则<br/><strong class="jx io">【O】</strong>笔/闭原则<br/><strong class="jx io">【L】</strong>伊斯科夫替代原则<br/><strong class="jx io">【I】</strong>界面分离原则<br/><strong class="jx io">【D】</strong>依赖倒置原则</p><p id="743f" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">单一责任原则(SRP) </strong> —一个类应该有且只有一个改变的理由。</p><p id="e053" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">打开/关闭原则(OCP)  —你应该能够扩展一个类的行为，而不用修改它。</p><p id="e600" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">节选自:<a class="ae la" href="https://medium.com/@mari_azevedo/s-o-l-i-d-principles-what-are-they-and-why-projects-should-use-them-50b85e4aa8b6" rel="noopener">https://medium . com/@ mari _ aze vedo/s-o-l-I-d-principles-what-them-and-why-projects-should-use-them-50 b 85 E4 aa 8 b 6</a></p></blockquote><p id="1fe1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在默认的 Register 控制器上，您会看到使用了一个名为 RegisterUsers 的特性，它包含了用户创建的大部分逻辑。在特征内部，有一个注册方法，这将是我们所关心的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6b94" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">/**<br/> * Handle a registration request for the application.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@param  </em></strong><em class="kw">\Illuminate\Http\Request  $request<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">\Illuminate\Http\Response<br/> */<br/></em>public function register(Request $request)<br/>{<br/>    $this-&gt;validator($request-&gt;all())-&gt;validate();<br/><br/>    <strong class="lg io">event(new Registered($user = $this-&gt;create($request-&gt;all())));</strong><br/><br/>    $this-&gt;guard()-&gt;login($user);<br/><br/>    if ($response = $this-&gt;registered($request, $user)) {<br/>        return $response;<br/>    }<br/><br/>    return $request-&gt;wantsJson()<br/>                ? new Response('', 201)<br/>                : redirect($this-&gt;redirectPath());<br/>}</span></pre><p id="de0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，请注意加粗的代码行，这将调度一个名为 Registered 的事件，每次用户在您的应用程序上注册时，都可以通过创建一个侦听器类并将其映射到 EventServiceProvider 中的事件来侦听。</p><p id="874e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我正在构建一个学生门户，当学生注册后，我必须:</p><ul class=""><li id="637e" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">给学生分配一个班级</li><li id="7f1e" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">给学生分配班级中的一个座位</li><li id="aa1b" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">给学生分配一个实验搭档</li><li id="0ff2" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">给学生发一张借书证，这样的例子不胜枚举。</li></ul><p id="1dcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一种典型的方法是将所有逻辑转储到寄存器控制器方法中，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="67de" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">/**<br/> * Handle a registration request for the application.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@param  </em></strong><em class="kw">\Illuminate\Http\Request  $request<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">\Illuminate\Http\Response<br/> */<br/></em>public function register(Request $request)<br/>{<br/>    $this-&gt;validator($request-&gt;all())-&gt;validate();<br/><br/>    event(new Registered($user = $this-&gt;create($request-&gt;all())));</span><span id="4230" class="lk ll in lg b gy lq ln l lo lp">   //Assign the student a class<br/>   //Assign the student a seat in the class<br/>   //Assign the student a lab partner<br/>   //Assign the student a library card<br/>   //more</span><span id="a057" class="lk ll in lg b gy lq ln l lo lp">    $this-&gt;guard()-&gt;login($user);<br/><br/>    if ($response = $this-&gt;registered($request, $user)) {<br/>        return $response;<br/>    }<br/><br/>    return $request-&gt;wantsJson()<br/>                ? new Response('', 201)<br/>                : redirect($this-&gt;redirectPath());<br/>}</span></pre><p id="c454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这可能行得通，但它打破了前面提到的不止一个原则。解决这个问题的一种方法是创建侦听器，并将其映射到注册的事件。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="066b" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">//Event Service Provider Class</em></span><span id="811c" class="lk ll in lg b gy lq ln l lo lp"><em class="kw">/**<br/> * The event listener mappings for the application.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@var </em></strong><em class="kw">array<br/> */<br/></em>protected $listen = [<br/>    Registered::class =&gt; [<br/>        AssignClassToStudent::class,<br/>        AssignSeatToStudent::class,<br/>        AssignLabPartnerToStudent::class,<br/>        AssignLibraryCardToStudent::class,<br/>    ],<br/>];</span></pre><p id="faaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了我们的提供者提供的上述内容，<em class="kw"> php artisan event:generate </em>命令将在<em class="kw"> app\Listener </em>文件夹中生成 4 个监听器类，但是为了简洁起见，我将继续使用一个类 assignClassToStudent 监听器</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ad92" class="lk ll in lg b gy lm ln l lo lp">&lt;?php<br/><br/>namespace App\Listeners;<br/><br/>use Illuminate\Contracts\Queue\ShouldQueue;<br/>use Illuminate\Queue\InteractsWithQueue;<br/><br/>class assignClassToStudent<br/>{<br/>    <em class="kw">/**<br/>     * Create the event listener.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function __construct()<br/>    {<br/>        //<br/>    }<br/><br/>    <em class="kw">/**<br/>     * Handle the event.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@param  </em></strong><em class="kw">object  $event<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">void<br/>     */<br/>    </em>public function handle($event)<br/>    {<br/>        $event-&gt;user-&gt;assignClassToStudentLogic();<br/>    }<br/>}</span></pre><p id="ce22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">遵循这种模式意味着，如果在用户注册后有更多的逻辑要做，您不需要编辑 register 方法，您只需要启动一个新的侦听器并将其映射到事件。这样，register 方法只处理学生注册，其他侦听器处理其他职责。</p><p id="0985" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结束了。</p><p id="a8d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢吗？拍手和朋友分享。</p><p id="8b23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在推特上关注我:https://twitter.com/drumzminister<a class="ae la" href="https://twitter.com/drumzminister" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>