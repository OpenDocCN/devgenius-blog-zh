<html>
<head>
<title>Build an Apollo Federated API in Rust — From the view of a JS Dev</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 JS 开发人员的角度，在 Rust 中构建一个 Apollo 联邦 API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-an-apollo-federated-api-in-rust-from-the-view-of-a-js-dev-6dde83b795d7?source=collection_archive---------1-----------------------#2022-03-12">https://blog.devgenius.io/build-an-apollo-federated-api-in-rust-from-the-view-of-a-js-dev-6dde83b795d7?source=collection_archive---------1-----------------------#2022-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="27bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！感谢您的加入。</p><p id="c1c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我想分享一个用 Rust 构建的联合 API 的快速示例。</p><p id="ab9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在过去的一个月里，我一直在利用我的空闲时间慢慢学习一些关于 Rust 的知识。为此，我想尝试创建一个简单的小联邦 API 来帮助巩固我到目前为止学到的技能。</p><p id="8268" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从一个熟悉 JS 的人的角度来看，下面是如何构建一个支持 Apollo 联邦的 Rust GraphQL API。我还会附上一些阅读推荐、回复和提示，以避免陷入和我一样的困境。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2fb83a8c924e4a8c12665f0b5280d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbuelP_dGqHDNL4aKAWdAQ.png"/></div></div></figure><h1 id="269c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们将建造什么</h1><p id="c9ed" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这个 API 将提供两个服务，包括一个<code class="fe lx ly lz ma b">users</code>服务和一个<code class="fe lx ly lz ma b">dogs</code>服务。为了演示联邦规范，<code class="fe lx ly lz ma b">dogs</code>服务将从<code class="fe lx ly lz ma b">users</code>服务扩展<code class="fe lx ly lz ma b">user</code>类型。</p><h1 id="c992" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">项目设置</h1><h2 id="6d51" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">初始化项目子图</h2><p id="3095" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">使用 Cargo，一个类似于<code class="fe lx ly lz ma b">npm</code>的管理器，让你的 rust 项目开始。我们将为 API 创建一个新的目录，以及两个子图/微服务来管理这个 API 的数据。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="8dfc" class="mb kv in ma b gy mr ms l mt mu">mkdir dogs-api<br/>cd dogs-api<br/>cargo new users<br/>cargo new dogs</span></pre><h2 id="8269" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">安装子图依赖项</h2><p id="71a8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">就像 Node 一样，我们将使用依赖关系来帮助我们创建每个子图。与 node 不同，我们不从 cli 安装依赖项——相反，我们编辑每个子图服务的<code class="fe lx ly lz ma b">Cargo.toml</code>文件。</p><p id="96d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向每个子图服务添加以下五个依赖项:</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="8c22" class="mb kv in ma b gy mr ms l mt mu">[dependencies]<br/>tokio = { version = "1.0.2", features = ["macros", "rt-multi-thread"] }<br/>warp = "0.3"<br/>http = "0.2"<br/>async-graphql = "3.0.34"<br/>async-graphql-warp = "3.0.34"</span></pre><ul class=""><li id="0d75" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh na nb nc nd bi translated"><code class="fe lx ly lz ma b">tokio</code>是 rust 的异步运行时，允许我们使用异步等待语法</li><li id="ea6f" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated"><code class="fe lx ly lz ma b">warp</code>是我们将开始允许传入和传出请求的服务器。</li><li id="5e99" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated"><code class="fe lx ly lz ma b">http</code>提供了可以在我们的代码库中使用的类型，以确保一切安全。</li><li id="8789" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated"><code class="fe lx ly lz ma b">async-graphql</code>和<code class="fe lx ly lz ma b">async-graphql-warp</code>将允许我们执行 graphql 查询和变异，以及启用 API 的联邦方面。</li></ul><h2 id="559a" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">创建异步主函数</h2><p id="f228" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">调用 main 函数来启动项目。开箱即用，这个函数内部没有任何东西是异步的。如您所知，处理服务器需要一些异步/等待功能。为了启用这个特性，我们需要引入<code class="fe lx ly lz ma b">tokio</code>运行时。</p><p id="e93e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe lx ly lz ma b">src/main.rs</code>中，添加以下宏以启用 main 函数中的 async/await 语法。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="f925" class="mb kv in ma b gy mr ms l mt mu">#[tokio::main]<br/>async fn main() {<br/>  println!("hello world");<br/>}</span></pre><h2 id="19d7" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">声明模块</h2><p id="3779" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">为了方便使用，如果你正在编写你自己的服务器，这里是我们需要引入的导入/模块。在本文的其余部分，您可以随意复制粘贴或简单地用作参考。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="f8d4" class="mb kv in ma b gy mr ms l mt mu">use async_graphql::{<br/>    http::{playground_source, GraphQLPlaygroundConfig},<br/>    EmptyMutation, EmptySubscription, Object, Schema, SimpleObject,<br/>};<br/>use async_graphql_warp::{GraphQLBadRequest, GraphQLResponse};<br/>use http::StatusCode;<br/>use std::convert::Infallible;<br/>use warp::{http::Response as HttpResponse, Filter, Rejection};</span></pre><h1 id="32d7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建服务器</h1><p id="94d1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">就正在发生的事情而言，我们今天创建的服务器与典型的<code class="fe lx ly lz ma b">apollo-server-express</code>设置没有太大的不同。不同之处在于语法。让我们比较一下<code class="fe lx ly lz ma b">apollo-server-express</code>服务器和 rust 服务器的设置过程。</p><h2 id="cb0b" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">典型的 Apollo Server Express 设置</h2><p id="be16" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在 Rust 中创建 GraphQL 服务器类似于在 Node 中使用<code class="fe lx ly lz ma b">apollo-server-express</code>创建 GraphQL 服务器。</p><p id="3075" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe lx ly lz ma b">apollo-server-express</code>，您需要:</p><ol class=""><li id="36d2" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh nj nb nc nd bi translated">创建快递服务器— <code class="fe lx ly lz ma b">app</code></li><li id="05e6" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">创建 Apollo 服务器来处理 GraphQL 请求</li><li id="7352" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">将 express <code class="fe lx ly lz ma b">app</code>作为中间件应用到<code class="fe lx ly lz ma b">apollo-server</code></li><li id="c1e6" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">启动 express 服务器。</li></ol><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="6315" class="mb kv in ma b gy mr ms l mt mu">// Node Example</span><span id="b745" class="mb kv in ma b gy nk ms l mt mu">const app = express();</span><span id="20d7" class="mb kv in ma b gy nk ms l mt mu">const startServer = async () =&gt; {<br/>  const apolloServer = new ApolloServer({<br/>    schema,<br/>  });<br/>  await apolloServer.start();<br/>  apolloServer.applyMiddleware({ app });<br/>};</span><span id="7c6b" class="mb kv in ma b gy nk ms l mt mu">startServer();</span><span id="765e" class="mb kv in ma b gy nk ms l mt mu">app.listen(port, () =&gt; console.log(`Service ready at port ${port}!`));</span></pre><p id="bc33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用最基本的术语来说，<code class="fe lx ly lz ma b">apollo-server</code>处理 graphql 方面，express 服务器处理传入和传出的请求。</p><h2 id="a5dd" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">在 Rust 中使用 Warp 和 Async GraphQL</h2><p id="c6b8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">对于铁锈，有一个非常相似的过程。</p><ol class=""><li id="c296" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh nj nb nc nd bi translated">定义<code class="fe lx ly lz ma b">graphql_post</code>变量来处理 GraphQL Post 请求(就像启动<code class="fe lx ly lz ma b">apollo-server</code>)。</li><li id="071f" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">将该函数作为路径应用于 warp 服务器</li><li id="d870" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">创建并启动 warp 服务器</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2afd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确保自定义服务器启动的端口。例如，上面的服务器在端口 5011 上启动。</p><h1 id="37dc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">该模式</h1><p id="9ab3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">正如您可能已经注意到的，schema 变量应用于服务器，就像在<code class="fe lx ly lz ma b">apollo-server</code>示例中一样。</p><p id="d094" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先让我们创建模式，然后我们将定义<code class="fe lx ly lz ma b">typeDefs</code>和<code class="fe lx ly lz ma b">resolvers</code>。在 main 函数的顶部定义 schema 变量，这样它就可以应用到我们上面写的代码中。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="bf7a" class="mb kv in ma b gy mr ms l mt mu">#[tokio::main]<br/>async fn main() {<br/>  let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();</span><span id="c0b0" class="mb kv in ma b gy nk ms l mt mu">  // Start The Server....<br/>}</span></pre><h2 id="8e67" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">TypeDefs 和解析器</h2><p id="f504" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在<code class="fe lx ly lz ma b">main</code>功能之上(甚至在另一个模块中！)，我们将为每个服务定义<code class="fe lx ly lz ma b">typeDefs</code>和<code class="fe lx ly lz ma b">resolvers</code>的 rust 当量。</p><p id="f2c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lx ly lz ma b">async-graphql</code>箱提供了宏，我们可以用它来定义类型定义、实体、扩展等等。先分解一下，然后我一起给你看。</p><h2 id="8902" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">定义查询</h2><p id="a683" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在联邦 api 中，我们需要扩展已定义的查询。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="361c" class="mb kv in ma b gy mr ms l mt mu">// Node<br/>extend type Query {<br/>  getDog: () =&gt; {<br/>    return {<br/>      color: "Tri Color",<br/>      name: "Oakley",<br/>      age: 3,<br/>      id: 1,<br/>      owner: { id: 1, __typename: "User" }<br/>    }<br/>  }<br/>}</span><span id="ff00" class="mb kv in ma b gy nk ms l mt mu">// Rust<br/>struct Query</span><span id="a6fe" class="mb kv in ma b gy nk ms l mt mu">#[Object(extends)]<br/>impl Query {<br/>  async fn get_dog(&amp;self) -&gt; Dog {<br/>    Dog {<br/>      color: "Tri Color".to_string(),<br/>      name: "Oakley".to_string(),<br/>      age: 3,<br/>      id: 1,<br/>      owner: User { id: 1 },<br/>    }<br/>  }<br/>}</span></pre><h2 id="c53a" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">创建类型</h2><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="88c6" class="mb kv in ma b gy mr ms l mt mu">// Node<br/>type User {<br/>  name: String!<br/>  id: Int!<br/>}</span><span id="4b69" class="mb kv in ma b gy nk ms l mt mu">// Rust<br/>#[derive(SimpleObject)]<br/>struct User {<br/>    name: String,<br/>    id: i32,<br/>}</span></pre><h1 id="f9c3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">启用联盟</h1><p id="3c50" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">就像在 Node 中一样，我们需要扩展类型，以便在整个联邦图中使用它们。</p><h2 id="13c4" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated"><strong class="ak">扩展类型和@外部指令</strong></h2><p id="4cd5" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe lx ly lz ma b">#[Object(extends)]</code>宏可用于扩展 Rust 中的一个类型。<code class="fe lx ly lz ma b">@key</code>指令现在被定义为一个实现的功能，它也利用了<code class="fe lx ly lz ma b">#[graphql(external)]</code>宏。</p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="0d1b" class="mb kv in ma b gy mr ms l mt mu">// The Dogs Subgraph Extends a User</span><span id="1592" class="mb kv in ma b gy nk ms l mt mu">// Node<br/>extend type User @key(fields: "id") {<br/>  id: Int! @external<br/>  dogs: [Dog!]!<br/>}</span><span id="71a5" class="mb kv in ma b gy nk ms l mt mu">// Rust<br/>#[Object(extends)]<br/>impl User {<br/>    #[graphql(external)]<br/>    async fn id(&amp;self) -&gt; &amp;i32 {<br/>        &amp;self.id<br/>    }</span><span id="3d6a" class="mb kv in ma b gy nk ms l mt mu">    async fn dogs(&amp;self) -&gt; Vec&lt;Dog&gt; {<br/>        // Find and Return Vector of Dogs<br/>    }<br/>} </span></pre><h2 id="941f" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">解析实体</h2><p id="7f3a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">为了在联合架构中使用<code class="fe lx ly lz ma b">async-graphql</code>服务，我们需要创建一个函数来解析<code class="fe lx ly lz ma b">entity.</code></p><pre class="kj kk kl km gt mn ma mo mp aw mq bi"><span id="7507" class="mb kv in ma b gy mr ms l mt mu">#[Object(extends)]<br/>impl Query {<br/>    #[graphql(entity)]<br/>    async fn resolve_user(&amp;self, id: i32) -&gt; User {<br/>        User { id }<br/>    }<br/>}</span></pre><h1 id="417d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">最终结果</strong></h1><h2 id="3b66" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">用户子图</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0f3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">狗子图</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="026a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">下一步和一些阅读</h1><h2 id="11cb" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">启动服务器</h2><p id="b714" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们可以简单地通过运行<code class="fe lx ly lz ma b">cargo run</code>来启动服务器。确保在不同的端口启动每台服务器。</p><h2 id="5c8e" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">启动网关</h2><p id="45fa" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">本文并不打算介绍如何创建一个 apollo 联邦网关——但是它非常简单！查看我关于如何创建网关的文章——也有一个完整的网关回购，如果你愿意，你可以克隆并使用它。</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/build-or-clone-a-federated-api-pt-1-the-gateway-ad75dad21459"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">构建或克隆—一个联合 API — Pt。1:网关++</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">构建它或克隆 Repo——一个具有全局授权上下文和静态文件服务的 Apollo 网关</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.devgenius.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><h2 id="5cc6" class="mb kv in bd kw mc md dn la me mf dp le jv mg mh li jz mi mj lm kd mk ml lq mm bi translated">查看更多示例</h2><p id="467e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我上面展示的很多内容都来自于通读源代码示例、文档和 github 问题！以下是一些对我有帮助的资料。</p><ol class=""><li id="615b" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh nj nb nc nd bi translated">帮助我运行这个的最好的联邦例子实际上来自于由<code class="fe lx ly lz ma b">async-graphql</code> — <a class="ae of" href="https://github.com/async-graphql/graphgate" rel="noopener ugc nofollow" target="_blank"> GraphGate </a>的维护者创建的一个 repo</li><li id="43bf" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">另一个精彩演讲和联邦回购示例—<a class="ae of" href="https://www.youtube.com/watch?v=hMIL12Mj7Pw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=hMIL12Mj7Pw</a></li><li id="529d" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">当然，检查出板条箱文件和<code class="fe lx ly lz ma b">async-graphql</code>书</li></ol></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="61d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿——谢谢你今天能来！对我来说，这是一个非常有趣的周末项目，可以学到更多关于 rust 的知识。我想我在让联邦方面工作时比 rust 语法更容易出错，这感觉很好。不管怎样，希望你会觉得有趣，如果你有任何 rust graphql 的提示和技巧想分享，请告诉我。</p></div></div>    
</body>
</html>