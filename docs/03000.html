<html>
<head>
<title>Game Design with Singleton Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单例模式的游戏设计</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/game-design-with-singleton-pattern-21685f7a43bb?source=collection_archive---------4-----------------------#2020-09-19">https://blog.devgenius.io/game-design-with-singleton-pattern-21685f7a43bb?source=collection_archive---------4-----------------------#2020-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1d03" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">只能有一个，所以要让它有价值</h2></div><p id="6533" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是游戏设计与编程模式系列的第 6 篇文章，着眼于编程的游戏设计方面。试试 <a class="ae kz" href="https://ovenfresh.itch.io/a-game-designers-thoughts-on-programming-patterns" rel="noopener ugc nofollow" target="_blank"> <em class="ky">中的例题实验互动补充</em> </a> <em class="ky">！</em></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/4a31f126c0b2f5a0fb4cf719f1211b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fyLv7sxl73OfV6OT"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e413" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">是什么格局？</strong></h1><p id="2fe2" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">单例模式对象有两个属性:它们被限制为自身的一个实例，并提供对自身方法和数据的全局访问。一旦创建，对单例对象的任何后续引用都将是那个对象——它从不创建多个实例。此外，程序的任何其他部分都可以使用该对象，因为它是全局可访问的。Singleton 的开放性让它可以在程序的其余部分提供数据和服务。结果，仓促应用的单例产生的问题比它们解决的问题更多，导致单例拥有的信息或行为比合理的多。当需要单一的唯一性和访问时，通过仔细考虑来避免产生不必要的问题。</p><h1 id="f7f7" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">我如何使用它</strong></h1><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi mn"><img src="../Images/299e98c3b5990f96f82368f48cb33a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Tsx23yDeVlhFJddHwTT59w.gif"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">singleton 将在左下角的 UI 中跟踪场景内外的点击。|点击场景中的立方体使其跳跃</figcaption></figure><p id="00be" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个统计追踪者，独生子女的本质对我来说最有意义。通过进入 singleton 场景，创建了一个相当简单的 stat 跟踪 singleton 实例。它计算场景内外的鼠标点击次数，以及应用程序运行的总秒数。可以通过底部的按钮告诉单例用户重置点击计数，并在重置后继续跟踪。一旦单例场景被加载，对象将继续跟踪点击和时间。将这些统计信息存储在 singleton 中可以保持它们的持久性和全局性。</p><h1 id="b766" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">设计印象</strong></h1><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">在 Unity 中创建单例很容易。决定何时创建一个是困难的</figcaption></figure><p id="0b57" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">单例是为我们游戏的其他部分提供可靠的工具和信息的最好地方。将单例的焦点缩小到点击或计时等元数据，可以让它在游戏空间之外操作，同时仍然连接到游戏空间内的对象。Singleton 可以保存对与其自身相关的服务或方法的引用，并试图防止其他对象过于依赖它。这是避免糟糕的单例场景的基本原则，在这种场景中，它们与其他对象和系统纠缠不清。</p><h1 id="d0c6" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">前进</strong></h1><p id="1ccc" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">单例对象应该被用来解决游戏进程中一致的和不变的需求，并且它们应该可靠地满足这些需求。它们最适合独立于特定游戏的系统。像游戏渲染、调试或统计跟踪系统这样的系统都告诉我们如何构建一个好的单例，也就是说，不包含任何关键的逻辑函数。相反，它们应该包含互补的过程和信息。保存对其他对象的引用、处理玩家输入或包含关于游戏的“通用”信息都是单例对象的良好候选对象。受限于外部领域，单例模式在实现细节中找到了自己的位置，而不是在实际的游戏设计中。</p><p id="5ef8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">往期:</strong><a class="ae kz" href="https://medium.com/dev-genius/game-design-with-prototype-pattern-d9a839814ef0" rel="noopener">T5】原型 </a></p><p id="e4e2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">接下来:</strong> <a class="ae kz" href="https://medium.com/dev-genius/game-design-with-state-pattern-2844e5f75ba4" rel="noopener"> <strong class="ke io">状态</strong> </a></p><p id="480a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">代码</strong>:<a class="ae kz" href="https://github.com/jasonzli/game-programming-study" rel="noopener ugc nofollow" target="_blank">https://github.com/jasonzli/game-programming-study</a></p><p id="fbfd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">参考:</strong>游戏编程模式，<em class="ky"> Nystrom，Robert 2014</em><a class="ae kz" href="http://gameprogrammingpatterns.com/command.html" rel="noopener ugc nofollow" target="_blank"><em class="ky">http://gameprogrammingpatterns.com/singleton.html</em></a></p></div></div>    
</body>
</html>