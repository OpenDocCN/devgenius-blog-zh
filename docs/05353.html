<html>
<head>
<title>7 Bottlenecks That Hurt the Scalability of Your System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">损害系统可扩展性的7个瓶颈</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-bottlenecks-that-hurt-the-scalability-of-your-system-4aa8b75627bf?source=collection_archive---------0-----------------------#2021-07-25">https://blog.devgenius.io/7-bottlenecks-that-hurt-the-scalability-of-your-system-4aa8b75627bf?source=collection_archive---------0-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="10f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">可扩展性是指系统在保持相同延迟的同时处理增加的工作负载的能力。</p><p id="004d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您的系统需要X秒来响应用户的请求。它应该花费相同的时间来响应百万并发用户请求中的每一个。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/de5ad8c82f3ace9a030ae331839bbcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYiFvPczcEJ8rGjwbWuO_A.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">可扩展应用程序(<a class="ae lk" href="https://www.8bitmen.com" rel="noopener ugc nofollow" target="_blank"> Img源</a></figcaption></figure><p id="1850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个web应用程序来说，有7个常见的错误会成为瓶颈并损害可伸缩性。</p><h1 id="efa1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">糟糕的代码质量</h1><p id="db81" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">低效、非结构化的代码有可能降低生产中整个服务的速度。具体来说:</p><ul class=""><li id="48e6" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">编写紧密耦合的代码(又名<strong class="jp ir">意大利面条</strong>)</li><li id="516c" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">使用不必要的循环或嵌套循环</strong></li><li id="fb12" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">使用效率低、复杂度更高的<em class="nc">Big-O</em>算法</li></ul><h1 id="e472" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">选择错误的数据库类型</h1><p id="8035" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">选择错误的数据库可能是致命的。我们需要清楚不同类型的数据库技术的优缺点。</p><p id="3d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于基于SQL的(关系型)数据库，我们针对以下方面进行了优化:</p><ul class=""><li id="b858" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">事务性的</li><li id="eee7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">强一致性</li></ul><p id="fdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于非SQL数据库:</p><ul class=""><li id="aa55" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">没有强烈的一致性要求</li><li id="b8f3" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">水平可扩展性</li></ul><p id="0d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们还需要确保数据库本身也是可扩展的。我们选择的数据库应该能够在多个数据库服务器上快速进行分区、分片和部署。</p><h1 id="5a93" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在数据库中嵌入业务逻辑</h1><p id="3f6a" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">大多数时候，数据库不是添加业务逻辑的地方，比如就地计算或验证。</p><p id="92e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加这些逻辑将显著增加单独升级DB或App的难度。此外，它还增加了数据库的工作负载，而这并不是它的优化目标。</p><p id="97d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有这种高度耦合的系统可能会让数据库重构或迁移工作成为一场噩梦。</p><h1 id="3a64" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">缓存不足</h1><p id="001b" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">通常，缓存应该拦截大多数数据库请求。</p><p id="d9d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用适当的回收逻辑，在所有必要的应用程序层部署缓存将显著提高响应时间。</p><h1 id="6a0a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">负载平衡器配置</h1><p id="cf95" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">取决于流量和服务器数量，我们需要随着系统规模调整LB的数量。</p><p id="7e35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LB是我们应用程序的网关。拥有适量的LB对于系统的延迟是至关重要的。</p><h1 id="eb1f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">错误的API</h1><p id="5a3e" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">API的效率也决定了流量增加时的延迟。对于web应用程序，以下是主流API的优缺点:</p><p id="f655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> #1 REST API: </strong></p><ul class=""><li id="718e" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">易于实施和发现</li><li id="3938" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">矮胖的反应</li></ul><p id="1dcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> #2图表QL: </strong></p><ul class=""><li id="255d" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">灵活查询</li><li id="6e72" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">客户端和服务器上的额外设置时间</li></ul><p id="c87b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> #3 RPC(gRPC)带协议缓冲:</strong></p><ul class=""><li id="47d4" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">编码和压缩的二进制数据性能更佳</li><li id="b0bb" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">要求客户机和服务器都支持数据模式</li></ul><h1 id="89ed" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">同步与异步</h1><p id="f8a9" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">随着系统的扩展，用不同的管道处理同步任务和异步任务可以降低系统的复杂性和延迟。</p><p id="c670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，要处理像“处理用户日志数据”或“发送通知”这样应该异步完成的任务，我们可以使用一个<strong class="jp ir">基于异步消息传递的框架(像Kafka) </strong>。它的订阅者/监听器模型非常适合处理这种类型的工作。</p><h1 id="d612" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="0cde" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">诊断系统的瓶颈可能具有挑战性。用合适的工具装备自己，了解典型的错误会使这个过程更容易管理。</p></div></div>    
</body>
</html>