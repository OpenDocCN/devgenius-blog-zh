<html>
<head>
<title>Refactoring Using Cognitive Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用认知复杂性进行重构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/refactoring-using-cognitive-complexity-7e55197335b6?source=collection_archive---------1-----------------------#2020-12-14">https://blog.devgenius.io/refactoring-using-cognitive-complexity-7e55197335b6?source=collection_archive---------1-----------------------#2020-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/456c3bc04483dc0414b1870dadfc3753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vwGDyhYiW1dN0ZIZ.jpg"/></div></div></figure><p id="8dc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重构代码是软件开发过程的重要部分。但是，有时很难确定应该重构什么以及为什么要重构。判断什么需要重构的一个标准是认知复杂性。</p><p id="1548" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">认知复杂性是SonarSource开发的一种度量标准，sonar source是我们在AWH使用的代码质量工具的开发者，该工具名为<a class="ae kt" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> SonarQube </a>。SonarQube挂钩到一个项目的CI管道，并对其执行代码质量分析。SonarQube能找到的问题类型从简单的事情(这个变量从来不用，把它去掉)到更复杂的重构(这个方法太复杂，重构一下)。为了确定一个方法是否太复杂，是否应该重构，需要计算一个认知复杂性得分。</p><h1 id="2ff8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">定义复杂性</h1><p id="6611" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">编程和计算机科学中的复杂性有几种含义。大多数程序员可能都熟悉圈复杂度，它试图告诉我们测试或维护一个方法有多困难。它通过为一个方法中的每个分支创建一个分数来做到这一点。像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a849" class="mg kv in mc b gy mh mi l mj mk">public static string HowMany(int n) // +1 (at least one path through each method)<br/>{<br/>    switch (n)<br/>    {<br/>        case 1: // +1<br/>            return "One";</span><span id="4254" class="mg kv in mc b gy ml mi l mj mk">        case 2: // +1<br/>            return "A couple";</span><span id="525f" class="mg kv in mc b gy ml mi l mj mk">        case 3: // +1<br/>            return "A few";</span><span id="981c" class="mg kv in mc b gy ml mi l mj mk">        case 4: // +1<br/>            return "Several";</span><span id="1845" class="mg kv in mc b gy ml mi l mj mk">        default:<br/>            return "Many";<br/>    }</span><span id="3846" class="mg kv in mc b gy ml mi l mj mk">    // Cyclomatic Complexity = 5<br/>}</span></pre><p id="2071" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然圈复杂度很好地告诉了我们一个方法在测试时有多复杂(分数通常是覆盖一个方法所需的最小测试数)，但它并没有很好地告诉我们代码的<em class="mm">可维护性</em>或<em class="mm">可理解性</em>如何。认知复杂性建立在圈复杂性的基础上，并适应圈复杂性，给我们一个更好的分数，这个分数更多地与理解和可维护性有关，而不是测试。</p><blockquote class="mn mo mp"><p id="12dc" class="jv jw mm jx b jy jz ka kb kc kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ks ig bi translated">请注意，认知复杂性并不特定于任何编程语言或风格。这篇文章中的所有例子都使用C#。</p></blockquote><h1 id="5942" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">计算复杂性</h1><p id="25e5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">关于计算认知复杂性，你首先应该知道的是，你不需要自己去做。sonar cube将你的代码作为CI/CD管道的一部分进行分析，它不仅仅是一个认知复杂性分析的好工具。但是学习如何计算分数会有助于以更易维护的方式构建你的代码。</p><blockquote class="mn mo mp"><p id="aee6" class="jv jw mm jx b jy jz ka kb kc kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ks ig bi translated">这篇文章只给出计算认知复杂性的基础知识。要了解全部细节，请查看SonarSource的白皮书。</p></blockquote><p id="8104" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是计算认知复杂性得分的基本规则:</p><ol class=""><li id="e138" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">代码控制结构中的每一个断点都增加分数。</li><li id="0b4b" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">对于每一级嵌套的控制结构断点，再次增加分数。</li><li id="1122" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">忽略有助于可读性的简写结构。</li></ol><p id="a3a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们再细分一下。</p><h2 id="e3c3" class="mg kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated"><strong class="ak">控制结构中的中断</strong></h2><p id="94ef" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这是圈复杂度最基本的规则。循环和条件会增加流程中每个断点的分数。不过，有一些警告。</p><ul class=""><li id="c22d" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks ns mz na nb bi translated"><strong class="jx io"><em class="mm"/></strong><strong class="jx io"><em class="mm">最后</em> </strong>块被忽略，但是<strong class="jx io"> <em class="mm"> catch </em> </strong>会递增分数，尽管不管捕获多少种类型的异常都只有一次。</li><li id="eebc" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated">一个<strong class="jx io"> <em class="mm">开关</em> </strong> <em class="mm"> </em>只会把分数加1，不管处理了多少个案件。这与圈复杂度不同，这样做是因为一个开关通常比一组等价的<strong class="jx io"><em class="mm">if/else if/else</em></strong><em class="mm"/>语句更容易扫描和读取。</li><li id="ccdc" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated">逻辑运算符序列被组合在一起。考虑一下<strong class="jx io"><em class="mm">a&amp;&amp;b&amp;&amp;c&amp;&amp;d</em></strong>和<strong class="jx io"><em class="mm">a&amp;&amp;b | | c&amp;&amp;d</em></strong>的区别。第一个将增加1，而第二个将增加3，因为它更难读取。</li><li id="2302" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated">递归被认为是一种循环，可以增加分数。</li><li id="be25" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated">跳转(<strong class="jx io"> <em class="mm">中断、继续、</em> </strong>等)会增加分数，但提前<strong class="jx io"> <em class="mm">返回</em> </strong>则不会。</li></ul><blockquote class="mn mo mp"><p id="0d9b" class="jv jw mm jx b jy jz ka kb kc kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ks ig bi translated">因为关于<strong class="jx io"> <em class="in">切换</em> </strong> <em class="in"> </em>语句的规则，上面的<strong class="jx io"><em class="in">how much</em></strong>方法只有一个认知复杂度得分1。</p></blockquote><h2 id="bee3" class="mg kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated"><strong class="ak">嵌套控制结构</strong></h2><p id="7d04" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">过度嵌套是非常讨厌的<a class="ae kt" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">代码气味</a>。认知复杂性通过在嵌套的每一层中增加每一个控制结构来实现这一点。不过，跳转不受嵌套额外增量的影响。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c79a" class="mg kv in mc b gy mh mi l mj mk">public string DoSomething(string str)<br/>{<br/>    var newStr = string.Empty;</span><span id="1c7f" class="mg kv in mc b gy ml mi l mj mk">    if (str == null) // +1<br/>    {<br/>        for (var i == 0; i &lt; str.Length; i++) // +1 (+1 for nesting)<br/>        {<br/>            if (str[i] == 'a') // +1 (+2 for nesting)<br/>                newStr += 'A';<br/>            else if (str[i] == 'x') // +1 (+2 for nesting)<br/>                continue; // +1<br/>            else<br/>                newStr = str[i];<br/>        }<br/>    }</span><span id="f552" class="mg kv in mc b gy ml mi l mj mk">    return newStr;<br/>}</span><span id="62f9" class="mg kv in mc b gy ml mi l mj mk">// Cognitive Complexity = 10</span></pre><h2 id="e381" class="mg kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated"><strong class="ak">忽略速记结构</strong></h2><p id="0ecb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">认知复杂性分数意在奖励良好的编码实践，因此速记结构和语句不计入分数。最值得注意的是，像零合并操作符这样的东西是使用语言降低复杂性的好方法，如下面的例子所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2806" class="mg kv in mc b gy mh mi l mj mk">// Not good, increments the score<br/>var myString == string.Empty;<br/>if (someObj == null)<br/>    myString = someObj.StringProperty;</span><span id="b760" class="mg kv in mc b gy ml mi l mj mk">// Good, does not increment the score<br/>var myString = someObj?.StringProperty ?? string.Empty;</span></pre><h1 id="f2d2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">例子</h1><p id="77d2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们使用这些规则并重构一些东西。利用我们所知道的，我们可以确定一些简单的方法来降低复杂性，使方法更容易阅读和维护。让我们从一个大的、讨厌的方法开始，确定最复杂的区域:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1ee8" class="mg kv in mc b gy mh mi l mj mk">public async Task ParseAsync(string startingUrl, bool recurse = false, bool verbose = false)<br/>{<br/>    startingUrl = CleanUrl(startingUrl);<br/>    _rootUrl = new Uri(startingUrl).GetLeftPart(UriPartial.Authority);</span><span id="bdb3" class="mg kv in mc b gy ml mi l mj mk">    var urls = new Dictionary&lt;string, int&gt;();<br/>    urls.Add(startingUrl, 0);</span><span id="5b05" class="mg kv in mc b gy ml mi l mj mk">    while (urls.Any(x =&gt; x.Value == 0))<br/>    {<br/>        // Grab any URLs from the dictionary that we have not checked. If we are recursing,<br/>        // new URLs will be added with a status code of 0 and we will pick them up on the<br/>        // next pass.<br/>        var urlsToProcess = urls.Where(x =&gt; x.Value == 0).Select(x =&gt; x.Key).ToList();</span><span id="6479" class="mg kv in mc b gy ml mi l mj mk">        foreach (var url in urlsToProcess)<br/>        {<br/>            var displayUrl = url.Length &gt; (Console.BufferWidth - 10)<br/>                ? $"{url.Substring(0, Console.BufferWidth - 10)}..."<br/>                : url;<br/>            Console.Write(displayUrl);</span><span id="c6e3" class="mg kv in mc b gy ml mi l mj mk">            HttpResponseMessage response;</span><span id="0088" class="mg kv in mc b gy ml mi l mj mk">            try<br/>            {<br/>                response = await _httpClient.GetAsync(url);<br/>            }<br/>            catch (HttpRequestException ex)<br/>            {<br/>                urls[url] = -1;</span><span id="53bc" class="mg kv in mc b gy ml mi l mj mk">                Console.ForegroundColor = ConsoleColor.Red;<br/>                Console.WriteLine($" [{ex.Message}]");<br/>                Console.ResetColor();<br/>                continue;<br/>            }</span><span id="dd99" class="mg kv in mc b gy ml mi l mj mk">            urls[url] = (int)response.StatusCode;</span><span id="6b67" class="mg kv in mc b gy ml mi l mj mk">            if (response.IsSuccessStatusCode)<br/>            {<br/>                if (verbose)<br/>                {<br/>                    Console.ForegroundColor = ConsoleColor.Green;<br/>                    Console.WriteLine($" [{(int)response.StatusCode}]");<br/>                    Console.ResetColor();<br/>                }<br/>                else<br/>                {<br/>                    // Clear the current line<br/>                    Console.SetCursorPosition(0, Console.CursorTop);<br/>                    Console.Write(new string(' ', Console.BufferWidth - 1));<br/>                    Console.SetCursorPosition(0, Console.CursorTop);<br/>                }<br/>            }<br/>            else<br/>            {<br/>                // Write the error code and exit the loop early<br/>                Console.ForegroundColor = ConsoleColor.Red;<br/>                Console.WriteLine($" [{(int)response.StatusCode}]");<br/>                Console.ResetColor();<br/>                continue;<br/>            }</span><span id="db31" class="mg kv in mc b gy ml mi l mj mk">            // Exit early if we are not recursing unless we are checking the starting URL<br/>            if (!recurse &amp;&amp; url != startingUrl)<br/>                continue;</span><span id="07be" class="mg kv in mc b gy ml mi l mj mk">            // Exit early if the URL is external or if the content is not HTML<br/>            if (!IsInternalUrl(url) || !response.Content.Headers.ContentType.MediaType.StartsWith("text/html"))<br/>                continue;</span><span id="5821" class="mg kv in mc b gy ml mi l mj mk">            try<br/>            {<br/>                // If we made it this far, we will parse the HTML for links<br/>                var html = await response.Content.ReadAsStringAsync();</span><span id="b0e9" class="mg kv in mc b gy ml mi l mj mk">                // We add each link to the dictionary with a status code of 0. Since<br/>                // we are using a dictionary, URLs that are already checked or slated<br/>                // to be checked will be ignored.<br/>                GetUrlsFromHtml(html).ForEach(x =&gt; urls.TryAdd(x, 0));<br/>            }<br/>            catch<br/>            {<br/>                Console.WriteLine(url);<br/>                Console.WriteLine($"\tUnable to parse HTML.");<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="5998" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些正在发生的事情的背景将是很好的，对不对？这是我做的一个名为<a class="ae kt" href="https://github.com/amoscardino/linky" rel="noopener ugc nofollow" target="_blank"> Linky </a>的小项目的主要方法。这是一个命令行应用程序，用于扫描网站并尝试识别断开的链接。我在这里省略了一些助手方法，所以我们可以把注意力集中在需要重构的大方法上。</p><p id="c4f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始之前，让我们试着确定一些问题。首先，最多有4层嵌套。这很糟糕，应该是我们的主要目标。还有一些输出到控制台的模板代码可以被抽象掉。这不会对我们的复杂度评分有太大帮助，但是会使方法更容易阅读。</p><p id="f4aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我计算出认知复杂性得分为31。SonarQube建议方法不要超过15个。</p><p id="bf8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以做哪些改变来降低这个分数？我将首先提取<strong class="jx io"> <em class="mm">大foreach </em> </strong>循环内容作为新方法。这将减少2个循环中的嵌套，这将是一个巨大的胜利。然后，我会将各种控制台输出提取到一些新方法中。在某些情况下，这可以提取一些控制流中断，进一步减少嵌套。</p><p id="2637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看这一切是如何形成的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="638a" class="mg kv in mc b gy mh mi l mj mk">public async Task ParseAsync(string startingUrl, bool recurse = false, bool verbose = false)<br/>{<br/>    _startingUrl = CleanUrl(startingUrl);<br/>    _rootUrl = new Uri(_startingUrl).GetLeftPart(UriPartial.Authority);<br/>    _recurse = recurse;<br/>    _verbose = verbose;</span><span id="37a1" class="mg kv in mc b gy ml mi l mj mk">    var urls = new Dictionary&lt;string, int&gt;();<br/>    urls.Add(_startingUrl, 0);</span><span id="d168" class="mg kv in mc b gy ml mi l mj mk">    while (urls.Any(x =&gt; x.Value == 0))<br/>    {<br/>        // Grab any URLs from the dictionary that we have not checked. If we are recursing,<br/>        // new URLs will be added with a status code of 0 and we will pick them up on the<br/>        // next pass.<br/>        var urlsToProcess = urls.Where(x =&gt; x.Value == 0).Select(x =&gt; x.Key).ToList();</span><span id="6ed7" class="mg kv in mc b gy ml mi l mj mk">        foreach (var url in urlsToProcess)<br/>            await ProcessUrlAsync(url, urls);<br/>    }<br/>}</span><span id="15e5" class="mg kv in mc b gy ml mi l mj mk">private async Task ProcessUrlAsync(string url, Dictionary&lt;string, int&gt; urls)<br/>{<br/>    DisplayUrl(url);</span><span id="76c6" class="mg kv in mc b gy ml mi l mj mk">    HttpResponseMessage response;</span><span id="1ce2" class="mg kv in mc b gy ml mi l mj mk">    try<br/>    {<br/>        response = await _httpClient.GetAsync(url);<br/>    }<br/>    catch (HttpRequestException ex)<br/>    {<br/>        urls[url] = -1;</span><span id="59b5" class="mg kv in mc b gy ml mi l mj mk">        DisplayErrorCode(ex.Message);<br/>        return;<br/>    }</span><span id="dfad" class="mg kv in mc b gy ml mi l mj mk">    urls[url] = (int)response.StatusCode;</span><span id="3de7" class="mg kv in mc b gy ml mi l mj mk">    if (response.IsSuccessStatusCode)<br/>        DisplaySuccessCode(urls[url]);<br/>    else<br/>    {<br/>        // Write the error code and exit the loop early<br/>        DisplayErrorCode(urls[url].ToString());<br/>        return;<br/>    }</span><span id="6e48" class="mg kv in mc b gy ml mi l mj mk">    // Exit early if we are not recursing unless we are checking the starting URL<br/>    if (!_recurse &amp;&amp; url != _startingUrl)<br/>        return;</span><span id="988b" class="mg kv in mc b gy ml mi l mj mk">    // Exit early if the URL is external or if the content is not HTML<br/>    if (!IsInternalUrl(url) || !response.Content.Headers.ContentType.MediaType.StartsWith("text/html"))<br/>        return;</span><span id="2cb2" class="mg kv in mc b gy ml mi l mj mk">    try<br/>    {<br/>        // If we made it this far, we will parse the HTML for links<br/>        var html = await response.Content.ReadAsStringAsync();</span><span id="0c49" class="mg kv in mc b gy ml mi l mj mk">        // We add each link to the dictionary with a status code of 0. Since<br/>        // we are using a dictionary, URLs that are already checked or slated<br/>        // to be checked will be ignored.<br/>        GetUrlsFromHtml(html).ForEach(x =&gt; urls.TryAdd(x, 0));<br/>    }<br/>    catch<br/>    {<br/>        Console.WriteLine(url);<br/>        Console.WriteLine($"\tUnable to parse HTML.");<br/>    }<br/>}</span><span id="306b" class="mg kv in mc b gy ml mi l mj mk">private void DisplayUrl(string url)<br/>{<br/>    var displayUrl = url.Length &gt; (Console.BufferWidth - 10)<br/>        ? $"{url.Substring(0, Console.BufferWidth - 10)}..."<br/>        : url;</span><span id="0ab1" class="mg kv in mc b gy ml mi l mj mk">    Console.Write(displayUrl);<br/>}</span><span id="86e0" class="mg kv in mc b gy ml mi l mj mk">private void DisplaySuccessCode(int statusCode)<br/>{<br/>    if (_verbose)<br/>    {<br/>        Console.ForegroundColor = ConsoleColor.Green;<br/>        Console.WriteLine($" [{statusCode}]");<br/>        Console.ResetColor();<br/>    }<br/>    else<br/>    {<br/>        // Clear the current line<br/>        Console.SetCursorPosition(0, Console.CursorTop);<br/>        Console.Write(new string(' ', Console.BufferWidth - 1));<br/>        Console.SetCursorPosition(0, Console.CursorTop);<br/>    }<br/>}</span><span id="d324" class="mg kv in mc b gy ml mi l mj mk">private void DisplayErrorCode(string errorCode)<br/>{<br/>    Console.ForegroundColor = ConsoleColor.Red;<br/>    Console.WriteLine($" [{errorCode}]");<br/>    Console.ResetColor();<br/>}</span></pre><h2 id="744a" class="mg kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated">我们表现如何？</h2><ul class=""><li id="6fe5" class="mt mu in jx b jy ls kc lt kg nt kk nu ko nv ks ns mz na nb bi translated">主方法，<strong class="jx io"> <em class="mm"> ParseAsync </em> </strong>现在的分值是3。🎉</li><li id="36c2" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated"><strong class="jx io"><em class="mm">processurlsync</em></strong>是现在最大的方法，但是由于没有嵌套在两个循环中，所以得分只有7。🎉🎉</li><li id="bdfd" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated"><strong class="jx io"> <em class="mm"> DisplayUrl </em> </strong>和<strong class="jx io"><em class="mm">display success code</em></strong>各1分。<strong class="jx io"><em class="mm">display error code</em></strong>得分为0。</li><li id="5944" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks ns mz na nb bi translated">一些参数现在被分配给私有字段。这对分数没有影响，但是保持了代码的可读性，因为我们不需要到处传递它们。</li></ul><p id="34c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从功能上讲，代码的执行和输出与以前完全一样。唯一的区别是我们如何构建我们正在做的事情。我们创建了更小、更集中的方法，更容易理解，因此也更容易维护。认知复杂性帮助我们确定方法中最复杂的部分在哪里，这样我们就可以在最需要的地方进行重构。</p></div></div>    
</body>
</html>