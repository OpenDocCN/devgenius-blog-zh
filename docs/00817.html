<html>
<head>
<title>Go — Composite Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">go-复合模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-composite-pattern-393caaa0b105?source=collection_archive---------11-----------------------#2020-06-17">https://blog.devgenius.io/go-composite-pattern-393caaa0b105?source=collection_archive---------11-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3370d388e6eb6de83f727d2d9555c7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKrobfggEx9DhRoD5gbSjQ.png"/></div></div></figure><h1 id="786d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">先决条件</strong></h1><p id="c471" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在阅读本文之前，请确保您对<a class="ae lu" href="https://medium.com/@haluan/interface-in-go-language-fe3c13ce1355" rel="noopener"> Go接口</a>有很好的理解。</p><h1 id="f69d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">简介</strong></h1><p id="fb47" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">复合模式属于结构设计模式。基于<em class="lv">设计模式</em>【Gamma等人】一书，这个模式的意图是:</p><blockquote class="lw"><p id="d198" class="lx ly iq bd lz ma mb mc md me mf lt dk translated">将对象组成树结构来表示部分-整体层次结构。Compositelets客户端统一处理单个对象和对象的组合。</p><p id="6d84" class="lx ly iq bd lz ma mb mc md me mf lt dk translated">—设计模式[Gamma等人]第163页</p></blockquote><p id="a953" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这种模式对于动态构建对象结构非常有效。描述它的最简单方法是想象一组对象组成一个层次结构。例如，它可以是一个组织的层次结构。</p><p id="ccb4" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">在本文中，您将了解到:</p><ul class=""><li id="068a" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated">如何实现基本组合模式来构建组织层次结构</li><li id="7e2f" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">如何为另一个层次问题重用复合模式</li></ul><h1 id="25cf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">实现</strong></h1><p id="47cd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们从虚构的朋友康德开始这段旅程，他是一家网店公司的程序员。他的任务是建立公司的组织层级。</p><p id="bc5a" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">康德开始编写组件接口，这是他的代码的基础:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="db43" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">然后，他继续创建继承了<em class="lv">组件</em>接口的员工模型:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c327" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><strong class="ky ir">为了简单起见，我们将使用控制台打印，并通过直接硬编码值来简化输入。此外，我们可以忽略通常在Go中使用的成功/错误(结果，错误)模式。</strong></p><p id="314e" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">在康德写完雇员模型之后，他开始写复合结构。这个结构成为<strong class="ky ir">层次定义的基础</strong>。Kant意识到，可以将组织层次结构视为类似于一个树形数据结构，因此他创建了用于添加和显示组织人员的逻辑，如下所示:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a059" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">让我们歇一会儿，因为我会解释康德在那里做了什么。</p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="9d25" class="np jz iq nl b gy nq nr l ns nt">type Composite struct {<br/>   component Component<br/>   leaves    []Component<br/>}</span></pre><p id="8e90" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">正如我们看到的，复合结构有两个属性:</p><ul class=""><li id="aaeb" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated">组件:树的根/组织的头</li><li id="0eb6" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">树叶:树/组织下属的树叶</li></ul><p id="b98c" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">另外，请注意以下代码:</p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="f1d0" class="np jz iq nl b gy nq nr l ns nt">func (c Composite) Display() {...</span></pre><p id="0f0d" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">该代码将使<em class="lv">复合</em>结构继承<em class="lv">组件</em>接口。</p><p id="22c6" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">此外，康德刚刚意识到，在他工作的公司，有这么多的部门，每个部门可能有子部门。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b69997df50c9898e0a6d5b59e0bda3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*B9fVvF7iAnbz082hBm4n_g.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">以简单的方式划分公司层级</figcaption></figure><p id="de38" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">因此，他开始构建如下所示的公司层级结构:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="35f8" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">康德做了什么:</p><ul class=""><li id="2d91" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated">建立理想主义者副总裁办公室的等级制度</li><li id="369f" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">建立现实主义副总裁办公室的等级制度</li><li id="8132" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">建立公司的层级结构，增加首席执行官和两个副总裁办公室</li></ul><p id="d96d" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">我们记得，在<strong class="ky ir"> composite.go </strong>中我们有<code class="fe nz oa ob nl b">Display()</code>:</p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="2c33" class="np jz iq nl b gy nq nr l ns nt">func (c Composite) Display() {<br/>   c.component.Display()<br/>   if len(c.leaves) == 0 {<br/>      return<br/>   }<br/>   fmt.Println("===List of Subordinates===")<br/>   for _, leaf := range c.leaves {<br/>      leaf.Display()<br/>   }<br/>   fmt.Println("===End===")<br/>}</span></pre><p id="3664" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">因此，该方法将迭代并打印组件，并从以下位置离开:</p><ul class=""><li id="25e2" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated">理想主义者的副总裁</li><li id="0083" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">现实主义副总裁</li><li id="7cff" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">首席执行官(公司级别)</li></ul><p id="d808" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">如果我们在<code class="fe nz oa ob nl b">main.go</code>中运行<code class="fe nz oa ob nl b">composite.ShowEmployeeHierarchy()</code>，结果将是:</p><p id="9215" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><strong class="ky ir">理想主义者副总裁办公室:</strong></p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="87b0" class="np jz iq nl b gy nq nr l ns nt">=====Display Office of VP of Idealist=====<br/>ID: ID-2<br/>Name: Plato<br/>===List of Subordinates===<br/>ID: ID-4<br/>Name: Hegel<br/>===End===</span></pre><p id="8228" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">现实主义者副总裁办公室:</p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="8b22" class="np jz iq nl b gy nq nr l ns nt">=====Display Office of VP of Realist=====<br/>ID: ID-3<br/>Name: Aristotle<br/>===List of Subordinates===<br/>ID: ID-5<br/>Name: Hume<br/>===End===</span></pre><p id="0c55" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><strong class="ky ir">首席执行官办公室:</strong></p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="20a3" class="np jz iq nl b gy nq nr l ns nt">=====Display Company=====<br/>ID: ID-1<br/>Name: Socrates<br/>===List of Subordinates===<br/>ID: ID-3<br/>Name: Aristotle<br/>===List of Subordinates===<br/>ID: ID-5<br/>Name: Hume<br/>===End===<br/>ID: ID-2<br/>Name: Plato<br/>===List of Subordinates===<br/>ID: ID-4<br/>Name: Hegel<br/>===End===<br/>===End===</span></pre><h1 id="c583" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复用性</h1><p id="9cd2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在康德完成他的任务后，他的项目经理找到他，问他是否能以分层的方式建立购物目录。30分钟后是最后期限。也许对于一些程序员而不是他自己，会抗议截止日期。但是，因为这个康德，我们敬爱的程序员，他只是点点头，然后用笑脸把脸转回到他的电脑上。</p><p id="caa7" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">我们记得，康德已经创造了<code class="fe nz oa ob nl b">composite.go</code>，这是解决购物项目目录的可靠方案。</p><p id="8aca" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">他需要做的一件事只是编写产品目录，让我们把它抽象成这样:</p><ul class=""><li id="ac1a" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated"><strong class="ky ir">项目类别模型</strong></li></ul><p id="3c8b" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">该模型继承了<em class="lv">组件</em>接口。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="289c" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated"><strong class="ky ir">购物物品型号</strong></li></ul><p id="d6db" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">该模型继承了<em class="lv">组件</em>接口。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="5904" class="mq mr iq ky b kz ml ld mm lh ms ll mt lp mu lt mv mw mx my bi translated"><strong class="ky ir">撰写购物目录</strong></li></ul><p id="8136" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">通过重用<code class="fe nz oa ob nl b">composite.go</code>，这段代码非常简单。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ad33" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">然后在30分钟过期之前，康德打电话给他的总理。他的项目经理和团队为他鼓掌，因为他能快速完成新任务。</p><h1 id="4c24" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="c3ac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们观察康德所做的之后，我们可以通过实施复合设计模式获得很多好处。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4cb0a05b765c50122d785f0c4cc77e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*smjVWdCzHyHOyPWlzMn9Tw.png"/></div></figure><p id="a26a" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><strong class="ky ir">我们得到适应性</strong>，代码有清晰的路径来定义层次结构。通过利用接口，我们可以隐藏代码的实现细节，使其适应变化。</p><p id="1aad" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><strong class="ky ir">我们得到可重用性</strong>，代码可以重用到另一个问题上。只要问题有相似的模式。</p><p id="abe3" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">我们得到了敏捷性，敏捷性是软件开发的一个重要点。我们有自适应的代码和可重用的组件，这将随着时间的推移给我们带来优势，避免每次出现新功能时都要重新发明轮子，这与我们昨天所做的事情有着共同的问题。</p><p id="2b8b" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">复合图案可与<a class="ae lu" href="https://medium.com/swlh/go-decorator-pattern-2379974077b1" rel="noopener">装饰图案</a>结合。</p><blockquote class="lw"><p id="8994" class="lx ly iq bd lz ma mb mc md me mf lt dk translated">当decorators和composites一起使用时，它们通常会有一个公共的父类。所以decorators必须支持像Add、Remove和GetChild这样的组件接口操作。—设计模式[Gamma等人]第173页</p></blockquote><p id="2eeb" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">使用设计模式的好处是，我们可以将一个设计与另一个设计合并，这将在适应性、可重用性和敏捷性方面给我们带来巨大的好处。</p><p id="3abc" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">通过定义细粒度的代码和可重用的组件，团队生产力可以指数级地增长，从而为公司的利益创造新的特性。</p><p id="8093" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated">我想现在你已经对复合模式如何有益于康德的作品有了一些了解。现在，因为康德可以更快更灵活地做任何事情来丰富许多功能，他的队友开始叫他伊曼纽尔·坎(没有<code class="fe nz oa ob nl b">t</code>)。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="2da6" class="pw-post-body-paragraph kw kx iq ky b kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp mp lr ls lt ij bi translated"><em class="lv">额外说明:Gopher是Go Language吉祥物(在本文中用作图片封面的一部分)，由Renee French创作。知识共享署名3.0许可。</em></p></div></div>    
</body>
</html>