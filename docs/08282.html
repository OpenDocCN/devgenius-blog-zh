<html>
<head>
<title>Not all testing is equal, or useful, and some is even damaging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不是所有的测试都是相同的，或者有用的，有些甚至是有害的</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/not-all-testing-is-equal-or-useful-and-some-is-actually-damaging-9b2b130f96f3?source=collection_archive---------6-----------------------#2022-06-02">https://blog.devgenius.io/not-all-testing-is-equal-or-useful-and-some-is-actually-damaging-9b2b130f96f3?source=collection_archive---------6-----------------------#2022-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="9e38" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">软件/测试</h2><div class=""/><div class=""><h2 id="d837" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">让我们来探索一些流行的关于测试的信念是如何伤害我们的测试效率的，以及我们能做些什么。</h2></div><p id="b896" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">如果你从事编写代码的工作，你很有可能也会为它编写测试。可能大部分都是单元测试。单元测试很小，相对容易，甚至写起来很有趣。跑得快，他们给人这种即时的满足感。哦，我喜欢看那个“绿色酒吧”！</p><p id="5ee5" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">很难低估测试在实现质量方面的重要性。但是，正如标题所说，并不是所有的测试都是平等的，或者有用的，有些甚至是有害的。在这篇文章中，我们将探索如何让天平向我们这边倾斜。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/1f47fef683dddbce3a2bbdf3617f2b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG1smjIKRBi3AIKLhkNC6g.jpeg"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">寻找平衡(图片由斯蒂芬·凯勒拍摄)</figcaption></figure><h1 id="b3f1" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">单元测试给了修改代码的信心</h1><p id="6e07" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">作为<a class="ae lx" href="https://en.wikipedia.org/wiki/White-box_testing" rel="noopener ugc nofollow" target="_blank">白盒</a>，单元测试可以作为变化检测器。<br/>当无意中做出改变时，这可能是有益的。<br/>但是当你想有目的的修改一段代码，几十次测试都失败了怎么办？</p><p id="efae" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">问每个开发者什么代码比较容易改？</p><ul class=""><li id="2e93" class="mv mw in kn b ko kp kr ks ku mx ky my lc mz lg na nb nc nd bi translated">几乎没有其他代码依赖它的代码</li><li id="6648" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">有很多其他代码依赖于它的代码</li></ul><p id="f65b" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">任何有经验的人都会认识到，依赖性小的代码更容易修改，因为会出错的地方更少。这意味着我们得到的恰恰与我们试图实现的相反。编写单元测试类似于在代码基础上浇水泥，因为每一个代码的改变都需要测试的协调改变。</p><blockquote class="nj nk nl"><p id="667a" class="kl km nm kn b ko kp jx kq kr ks ka kt nn kv kw kx no kz la lb np ld le lf lg ig bi translated">有人声称，有一种方法可以编写测试，当底层代码发生变化时，它们不需要改变。我不知道这些测试在测试什么，但它不是底层功能，因此没有什么价值。</p></blockquote><h1 id="9117" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">单元测试加速开发</h1><p id="496d" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">测试不是免费的。测试是代码。我们将它们排列成包和模块。这需要设计和维护。一些研究表明，对于一些团队来说，单元测试可能会多花 30%的开发时间。这里最好有一个很好的投资回报，对吗？</p><p id="2ad6" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">继续阅读关于最大化单元测试 ROI 的技巧。</p><h1 id="c756" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">测试比代码更容易理解</h1><p id="a093" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">这与一个常见的误解有关，即您可以编写比测试代码更简单的测试。一个测试不能比它测试的代码简单。因为它携带的信息比代码少，这样的测试不可能测试底层的代码。除此之外，我们还需要添加所有的‘T8’连线来运行测试(模拟、固定装置、期望等)。)我们最终会得到比被测代码多得多的测试代码。</p><p id="e7f4" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">请看下一节来理解为什么拥有大量的测试代码是不好的。</p><h1 id="87d0" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">测试比代码更可靠(包含更少的错误)</h1><p id="9cab" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">有时我们会看到这样的说法，你可以在编写测试时更加小心，以使它们没有 bug。不管我们愿不愿意，对于任何数量的代码，我们都会引入一定数量的错误。<br/>不同的统计数据显示，每 1KLOC 有 3 到 50 个错误。<br/>在任何情况下，你的测试代码都会包含与生产代码相同比例的 bug。因为我们知道，通常情况下，我们的测试代码比生产代码多——测试代码比生产代码的失败率高。这意味着在任何给定的时间点，一些测试应该失败，但他们没有失败，或者测试甚至没有测试我们认为它测试的东西，因为有 bug。<br/>这不会让你对绿色条的含义有不同的看法吗，嗯？</p><p id="4a51" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">对于那些声称能够更好地集中注意力并编写比代码更少 bug 的测试的人来说，一个很好的建议是——在产品代码本身上使用相同的技术。</p><blockquote class="nq"><p id="3590" class="nr ns in bd nt nu nv nw nx ny nz lg dk translated">如果我修改了代码，在修改之后，我运行了测试，这个条变成了绿色，这意味着什么？</p></blockquote><figure class="ob oc od oe of lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi oa"><img src="../Images/581f4a4a44b8e724cb1996c9b2d8289c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbb8Mt_L0vr51dxtDy_-EQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">“如果我更改了代码，在更改代码后我运行了测试，但该条变成了绿色，这意味着什么？”</figcaption></figure><h1 id="7622" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">我们编写单元测试，因为它有助于我们发现错误</h1><p id="cfe6" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">我们必须认识到，大多数时候我们只做部分的和随机的单元测试。问问你自己你怎么知道什么时候停止写测试？<br/>当你想不出要写更多的测试，或者是时候转移到下一个特性的时候？最终，我们都使用一些(通常是不同的和任意的)“完整性”的概念，比如“每一行至少到达一次”。<br/>问题是覆盖每一行并不能说明代码是否做了它应该做的事情。</p><p id="9135" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">但是如何知道它应该做什么呢？</p><p id="50c9" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">解决方案的关键在于认识到我们不能既是编写代码的人，又是正确代码行为的先知。没有一个外部的、独立的正确行为的预言，我们只是随意猜测要写哪些测试。</p><h1 id="8067" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">如果你是一个面向对象的开发者，你的单元不是一个类</h1><p id="8ee5" class="pw-post-body-paragraph kl km in kn b ko mq jx kq kr mr ka kt ku ms kw kx ky mt la lb lc mu le lf lg ig bi translated">当我们大多数人用“OO”语言的一个变种来写的时候，我们陷入了在我们的“单元测试”中实际测试的单元是什么的陷阱。问题是在我们软件的组成单元(类)和我们可以测试的实际代码单元(方法/函数)之间存在阻抗不匹配。因此，虽然我们不能执行一个类，但我们可以执行一个函数。<br/>但是最有趣和最有价值的错误发生在函数之间(在运行时调用函数的调用图来完成任务)。</p><h1 id="89f8" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">总结:不幸的是，大多数单元测试并没有那么有用</h1><ul class=""><li id="40eb" class="mv mw in kn b ko mq kr mr ku og ky oh lc oi lg na nb nc nd bi translated">追逐报道会适得其反</li><li id="1ac2" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">测试不能比代码本身更简单</li><li id="543a" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">单元测试会使改变底层代码变得困难</li><li id="cb75" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">测试不能保证某样东西有效</li><li id="32eb" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">测试充其量只是取样</li></ul><h1 id="fcc0" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">最大化单元测试 ROI 的技巧</h1><ul class=""><li id="0b7c" class="mv mw in kn b ko mq kr mr ku og ky oh lc oi lg na nb nc nd bi translated">集中精力为关键算法编写单元测试，因为这些算法有第三方的正确性预言。系统的这些部分通常是核心，因此很少改变，所以改变的成本随着时间的推移而分摊。</li><li id="82fa" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">删除您无法链接到业务价值的任何测试(如果该测试失败意味着什么)</li><li id="8130" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">回归测试，其中回归被定义为“在产品中发现并通过测试重现的 Bug”</li><li id="1561" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">删除经常失败的测试</li><li id="9574" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">删除根本没有失败的测试</li><li id="dcb8" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">如果某些东西可以用系统测试或单元测试来测试——最好用系统测试</li></ul></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="f33f" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">此处引用的阅读材料启发了本文:</p><ul class=""><li id="3dec" class="mv mw in kn b ko kp kr ks ku mx ky my lc mz lg na nb nc nd bi translated">我最伟大的老师和导师之一詹姆斯·科普林的文章<a class="ae lx" href="https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf" rel="noopener ugc nofollow" target="_blank">在这里</a>和<a class="ae lx" href="https://rbcs-us.com/documents/Segue.pdf" rel="noopener ugc nofollow" target="_blank">在这里</a></li><li id="bcfa" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated"><a class="ae lx" href="https://www.researchgate.net/publication/4279048_A_Comparative_Case_Study_on_the_Impact_of_Test-Driven_Development_on_Program_Design_and_Test_Coverage" rel="noopener ugc nofollow" target="_blank">测试驱动开发对程序设计和测试覆盖率影响的对比案例研究</a></li><li id="e9a5" class="mv mw in kn b ko ne kr nf ku ng ky nh lc ni lg na nb nc nd bi translated">杰里·温伯格的《完美软件》</li></ul></div></div>    
</body>
</html>