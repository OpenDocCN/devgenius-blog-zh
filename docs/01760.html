<html>
<head>
<title>Create an Amazon EKS Cluster with Managed Node Group using Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform创建一个包含受管节点组的亚马逊EKS集群</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-an-amazon-eks-cluster-with-managed-node-group-using-terraform-a3b50d276b13?source=collection_archive---------0-----------------------#2020-07-11">https://blog.devgenius.io/create-an-amazon-eks-cluster-with-managed-node-group-using-terraform-a3b50d276b13?source=collection_archive---------0-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eecb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在AWS VPC中设置Kubernetes集群，将应用服务器部署到专用子网中的节点组，并通过LB服务访问它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/14718aee0a6c263a6daf91d656b84ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COfqAsVnpDijYcVyEurBLQ.png"/></div></div></figure><p id="769c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我最近的文章中，我展示了如何在VPC的私有子网中的ECS Fargate上部署一个容器化的应用程序，以及如何通过API Gateway安全地公开部署的应用程序。这一次，我想探索AWS必须提供的另一个COE(容器编排引擎),亚马逊EKS。两者都是可管理的、高度可用和高度可扩展的容器平台。然而，EKS本质上是Kubernetes即服务，因此需要了解强大的引擎及其组件，以便充分利用它。尽管有一些相似之处，但它比具有更复杂体系结构的ECS具有更陡峭的学习曲线。ECS的可扩展性有限，而EKS有各种各样的第三方和社区附加组件。</p><p id="877a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将使用Terraform创建一个具有公共和私有网络模式的集群，一直到在集群中部署一个应用程序，并通过一个负载均衡器公开访问它。</p><p id="4ce2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章中的代码片段将只包含主要的资源。为了更好地理解所有东西是如何组合在一起的，请从<a class="ae ln" href="https://github.com/LukeMwila/aws-eks-platform" rel="noopener ugc nofollow" target="_blank">这里</a>克隆源代码库。</p><p id="fbce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae ln" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️</a>😃。</p><p id="0fd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是我在AWS比勒陀利亚会议上关于同一主题的演讲的视频记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h1 id="ec7b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">鸟瞰图</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/348a37b9d130379a810792513bfccee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70nXM3UsoTGjeEfMvGaAkA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">我们的EKS集群设置</figcaption></figure><h1 id="3ab2" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">先决条件</h1><p id="403c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我认为，如果你采取亲身实践的方法，这篇文章将对你最有益。为此，请确保您具备以下条件:</p><ul class=""><li id="c222" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">Kubernetes和<a class="ae ln" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank"> Kubernetes集群架构</a>的基础知识</li><li id="f375" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/" rel="noopener ugc nofollow" target="_blank"> AWS账户</a></li><li id="eaf6" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">安装了AWS CLI工具(<a class="ae ln" href="https://docs.aws.amazon.com/cli/latest/userguide/install-linux.html" rel="noopener ugc nofollow" target="_blank"> Linux </a>、<a class="ae ln" href="https://docs.aws.amazon.com/cli/latest/userguide/install-macos.html" rel="noopener ugc nofollow" target="_blank"> macOS </a>、<a class="ae ln" href="https://docs.aws.amazon.com/cli/latest/userguide/install-windows.html" rel="noopener ugc nofollow" target="_blank"> Windows </a>)</li><li id="a804" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank">使用CLI配置AWS配置文件</a></li><li id="3305" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">安装了Docker CLI (如果您在ECR中已经有了一个容器映像，则不相关)</li><li id="39f8" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank">安装地形</a>和<a class="ae ln" href="https://terragrunt.gruntwork.io/docs/getting-started/install/" rel="noopener ugc nofollow" target="_blank">地形</a></li><li id="3101" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">Kubernetes命令行工具(<a class="ae ln" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>)</li></ul><h1 id="e316" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">亚马逊EKS和集群设置概述</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/44e2addae3565575a2184d88fe4f3ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gz-Ky-E8D2dW7ksvLQjueg.png"/></div></div></figure><p id="7820" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亚马逊EKS(用于Kubernetes的亚马逊弹性容器服务)是一项托管服务，使您可以轻松地在AWS上运行Kubernetes，而无需设置、供应或维护您自己的控制平面。它符合Kubernetes标准，并有一个受管理的控制平面。<br/> <br/> AWS负责跨多个AWS AZs(可用性区域)供应、运行、管理和自动扩展K8s主节点和etcd节点，以实现高可用性。<br/>客户负责添加和管理EC2工作节点。<br/>亚马逊EKS集群在亚马逊VPCs内运行。为了与群集通信，您必须将其配置为具有公共端点访问控制和/或私有端点访问控制。我们稍后将更详细地讨论这个问题。</p><h1 id="dd90" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">定价</h1><p id="ec32" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在开始创建EKS集群之前，您应该了解AWS提供的一个免费层没有涵盖的价格。在我写这篇文章的时候，亚马逊EKS集群的价格是每小时0.10美元。此外，您还负责其他资源成本，如EC2、EBS等。请务必<a class="ae ln" href="https://aws.amazon.com/eks/pricing/" rel="noopener ugc nofollow" target="_blank">查看本页</a>了解该服务的最新价格。</p><h1 id="b490" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">将容器图像推送到ECR</h1><p id="020b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我不打算详细介绍这一步，因为我已经在另一篇文章中介绍过了，你可以参考同一副标题下的<a class="ae ln" href="https://medium.com/swlh/deploy-container-in-ecs-fargate-behind-api-gateway-nlb-for-secure-optimal-accessibility-with-95542d5867c3" rel="noopener">这里的</a>。这仍然是重要的一步，因为它详细描述了我将从私有子网节点组中的pod中提取的映像。</p><p id="f2da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我所做的只是为NodeJS应用服务器创建一个Docker映像，它只有一条路由<code class="fe nh ni nj nk b">/test</code>，返回一个带有文本<em class="nl">的响应“正在工作！”</em>。</p><p id="f2aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在ECR中已经有一个图像，那么您可以跳过这一步。</p><h1 id="8e1f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">设置我们的VPC网络配置</h1><p id="b38b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当您创建一个Amazon EKS集群时，您必须为您的集群指定要使用的VPC和子网。亚马逊EKS需要至少两个az中的子网。在此设置中，我们将同时拥有公共子网和私有子网。公共子网将用于创建公共负载平衡器，将流量导向运行在私有子网中工作节点上的pod。根据子网内的流量是否通过<a class="ae ln" href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Internet_Gateway.html" rel="noopener ugc nofollow" target="_blank">互联网网关</a>路由，子网是公共的还是私有的。如果子网的流量没有通过互联网网关的默认路由，则该子网被视为专用子网。</p><p id="84cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在配置有互联网网关的子网内，具有公共或弹性IP地址的节点允许来自VPC外部的进入。您的VPC必须支持DNS主机名和DNS解析。否则，您的工作节点将无法向您的群集注册。</p><p id="08b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建亚马逊EKS集群(1.15版之前)时，亚马逊EKS会标记包含您指定的子网的VPC，以便Kubernetes可以发现它。我们将在我们的Terraform代码中添加这个标签，并使用以下键和值:</p><ul class=""><li id="d809" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">key——其中<em class="nl"> cluster-name </em>值与您的亚马逊EKS集群的名称相匹配的<code class="fe nh ni nj nk b">kubernetes.io/&lt;cluster-name&gt;</code>。</li><li id="8e72" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">value—<code class="fe nh ni nj nk b">shared</code>值允许多个集群使用该VPC。</li></ul><p id="33f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，VPC子网也有标记要求。您的群集用于资源的所有子网(公共和专用)也应该具有上述标记。此外，公共和私有子网都应该有特定的标签，告诉Kubernetes在哪里部署内部(私有)和外部负载平衡器(公共)。</p><p id="3696" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">公共子网标签:</p><ul class=""><li id="aea0" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">关键— <code class="fe nh ni nj nk b">kubernetes.io/role/elb</code></li><li id="ce51" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">值— <code class="fe nh ni nj nk b">1</code></li></ul><p id="30cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">专用子网标记:</p><ul class=""><li id="9a34" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">关键— <code class="fe nh ni nj nk b">kubernetes.io/role/internal-elb</code></li><li id="5c51" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">值— <code class="fe nh ni nj nk b">1</code></li></ul><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="064c" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_vpc" "custom_vpc" {<br/>  cidr_block       = var.vpc_cidr_block<br/>  # Your VPC must have DNS hostname and DNS resolution support. <br/>  # Otherwise, your worker nodes cannot register with your cluster. <br/>  enable_dns_support = true<br/>  enable_dns_hostnames = true</span><span id="b5c4" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "${var.vpc_tag_name}-${var.environment}"<br/>    <strong class="nk ir">"kubernetes.io/cluster/${var.eks_cluster_name}" = "shared"</strong><br/>  }<br/>}</span><span id="3c24" class="nq lr iq nk b gy nv ns l nt nu">### VPC Network Setup</span><span id="9df4" class="nq lr iq nk b gy nv ns l nt nu"># Create the private subnet<br/>resource "aws_subnet" "private_subnet" {<br/>  vpc_id            = "${aws_vpc.custom_vpc.id}"<br/>  cidr_block = var.private_subnet_cidr_block</span><span id="cbd1" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    <strong class="nk ir">"kubernetes.io/cluster/${var.eks_cluster_name}" = "shared"<br/>    "kubernetes.io/role/internal-elb" = 1</strong><br/>  }<br/>}</span><span id="1372" class="nq lr iq nk b gy nv ns l nt nu"># Create the public subnet<br/>resource "aws_subnet" "public_subnet" {<br/>  count = length(var.availability_zones)<br/>  vpc_id            = "${aws_vpc.custom_vpc.id}"<br/>  cidr_block = "${element(var.public_subnet_cidr_blocks, count.index)}"<br/>  availability_zone = "${element(var.availability_zones, count.index)}"</span><span id="4c3a" class="nq lr iq nk b gy nv ns l nt nu">  tags = {<br/>    <strong class="nk ir">"kubernetes.io/cluster/${var.eks_cluster_name}" = "shared"<br/>    "kubernetes.io/role/elb" = 1</strong><br/>  }</span><span id="8753" class="nq lr iq nk b gy nv ns l nt nu">  map_public_ip_on_launch = true<br/>}</span><span id="5e80" class="nq lr iq nk b gy nv ns l nt nu"># Create IGW for the public subnets<br/>resource "aws_internet_gateway" "igw" {<br/>  vpc_id = "${aws_vpc.custom_vpc.id}"<br/>}</span><span id="8982" class="nq lr iq nk b gy nv ns l nt nu"># Route the public subnet traffic through the IGW<br/>resource "aws_route_table" "main" {<br/>  vpc_id = "${aws_vpc.custom_vpc.id}"</span><span id="bbd9" class="nq lr iq nk b gy nv ns l nt nu">route {<br/>    cidr_block = "0.0.0.0/0"<br/>    gateway_id = "${aws_internet_gateway.igw.id}"<br/>  }</span><span id="f56a" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "${var.route_table_tag_name}-${var.environment}"<br/>  }<br/>}</span><span id="3e91" class="nq lr iq nk b gy nv ns l nt nu"># Route table and subnet associations<br/>resource "aws_route_table_association" "internet_access" {<br/>  count = length(var.availability_zones)<br/>  subnet_id      = "${aws_subnet.public_subnet[count.index].id}"<br/>  route_table_id = "${aws_route_table.main.id}"<br/>}</span></pre><h1 id="fcdb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">网络模式配置</h1><p id="b52e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在创建集群之前，我们必须考虑的另一个重要的初步步骤是决定网络模式或端点访问控制。您可以配置端点访问控制，以确定是否可以通过互联网(公共访问)、VPC(私有访问)或两者(公共和私有访问)访问您的群集。工作节点和被管理的Kubernetes控制平面之间的通信由网络模式配置决定。阅读<a class="ae ln" href="https://aws.amazon.com/blogs/containers/de-mystifying-cluster-networking-for-amazon-eks-worker-nodes/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多细节。在我们的例子中，我们将配置我们的集群网络，使其具有公共和私有端点访问控制。</p><p id="c63f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亚马逊EKS代表您创建了一个亚马逊Route 53 <a class="ae ln" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/hosted-zones-private.html" rel="noopener ugc nofollow" target="_blank">私有托管区域</a>，然后仅将该私有托管区域与您集群的VPC相关联。私人托管区域由亚马逊EKS管理，该区域不会出现在您帐户的Route 53资源中。因此，该配置将实现以下功能:</p><ul class=""><li id="be8c" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">集群的VPC中的Kubernetes API请求(比如worker节点到控制平面的通信)使用私有的VPC端点。</li><li id="bcf3" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">集群API服务器可以通过互联网访问。</li></ul><h1 id="44c5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">VPC端点</h1><p id="4bdb" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">由于我们选择了公共和私有网络模式，我们的工作节点不需要出站互联网访问来进行集群自检或节点注册。通信通过托管EKS VPC接口端点进行。一个<a class="ae ln" href="https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html" rel="noopener ugc nofollow" target="_blank">接口端点</a>是一个弹性网络接口，具有来自您的子网IP地址范围的私有IP地址，作为去往受支持服务的流量的入口点。</p><p id="83fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">VPC端点允许您的VPC和AWS服务中的实例之间的通信，而不会对您的网络流量带来可用性风险或带宽限制。在这种设置下，运行在私有子网中的工作节点还需要访问除受管EKS控制平面之外的其他AWS服务。我们将使用VPC端点将我们的VPC私下连接到其他AWS服务，即ECR、EC2和S3。</p><p id="8ff8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将为以下服务设置VPC端点:</p><ul class=""><li id="0cb1" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">AWS PrivateLink endpoint for ECR —这允许VPC中的实例进行身份验证并与ECR通信，以下载映像清单</li><li id="d842" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">亚马逊S3的网关VPC端点-这允许实例从托管它们的底层私有<a class="ae ln" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3 </a>桶下载图像层。</li><li id="407f" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">EC2的AWS专用链接端点</li></ul><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="38c6" class="nq lr iq nk b gy nr ns l nt nu"># ECR<br/>resource "aws_vpc_endpoint" "ecr_dkr" {<br/>  vpc_id       = "${aws_vpc.custom_vpc.id}"<br/>  service_name = "com.amazonaws.${var.region}.ecr.dkr"<br/>  vpc_endpoint_type = "Interface"<br/>  private_dns_enabled = true<br/>  subnet_ids          = flatten([["${aws_subnet.private_subnet.id}"], aws_subnet.public_subnet.*.id])</span><span id="1ae0" class="nq lr iq nk b gy nv ns l nt nu">security_group_ids = [aws_security_group.endpoint_ecr.id]</span><span id="fc19" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "ECR Docker VPC Endpoint Interface - ${var.environment}"<br/>    Environment = var.environment<br/>  }<br/>}</span><span id="8201" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_vpc_endpoint" "ecr_api" {<br/>  vpc_id       = "${aws_vpc.custom_vpc.id}"<br/>  service_name = "com.amazonaws.${var.region}.ecr.api"<br/>  vpc_endpoint_type = "Interface"<br/>  private_dns_enabled = true<br/>  subnet_ids          = flatten([["${aws_subnet.private_subnet.id}"], aws_subnet.public_subnet.*.id])</span><span id="6e62" class="nq lr iq nk b gy nv ns l nt nu">security_group_ids = [aws_security_group.endpoint_ecr.id]</span><span id="8c47" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "ECR API VPC Endpoint Interface - ${var.environment}"<br/>    Environment = var.environment<br/>  }<br/>}</span><span id="a5da" class="nq lr iq nk b gy nv ns l nt nu"># EC2<br/>resource "aws_vpc_endpoint" "ec2" {<br/>  vpc_id       = "${aws_vpc.custom_vpc.id}"<br/>  service_name = "com.amazonaws.${var.region}.ec2"<br/>  vpc_endpoint_type = "Interface"<br/>  private_dns_enabled = true<br/>  subnet_ids          = flatten([["${aws_subnet.private_subnet.id}"], aws_subnet.public_subnet.*.id])</span><span id="161c" class="nq lr iq nk b gy nv ns l nt nu">security_group_ids = [aws_security_group.endpoint_ec2.id]</span><span id="b367" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "EC2 VPC Endpoint Interface - ${var.environment}"<br/>    Environment = var.environment<br/>  }<br/>}</span><span id="1a9b" class="nq lr iq nk b gy nv ns l nt nu"># S3<br/>resource "aws_vpc_endpoint" "s3" {<br/>  vpc_id       = "${aws_vpc.custom_vpc.id}"<br/>  service_name = "com.amazonaws.${var.region}.s3"<br/>  vpc_endpoint_type = "Gateway"<br/>  route_table_ids = [var.main_pvt_route_table_id]</span><span id="d7d4" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "S3 VPC Endpoint Gateway - ${var.environment}"<br/>    Environment = var.environment<br/>  }<br/>}</span></pre><h1 id="3352" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">VPC端点安全组</h1><p id="f50c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们还想创建安全组，并将它们附加到我们的VPC端点接口组件。我们希望允许VPC端点网络接口和VPC中与其他AWS服务通信的资源之间的通信。</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="b796" class="nq lr iq nk b gy nr ns l nt nu"># EC2 VPC Endpoint security groups<br/>resource "aws_security_group" "endpoint_ec2" {<br/>  name   = "endpoint-ec2-sg"<br/>  vpc_id = aws_vpc.custom_vpc.id<br/>}</span><span id="c80f" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "endpoint_ec2_443" {<br/>  security_group_id = aws_security_group.endpoint_ec2.id<br/>  type              = "ingress"<br/>  from_port         = 443<br/>  to_port           = 443<br/>  protocol          = "tcp"<br/>  cidr_blocks = flatten([[var.private_subnet_cidr_block], var.public_subnet_cidr_blocks])<br/>}</span><span id="cd4f" class="nq lr iq nk b gy nv ns l nt nu"># ECR VPC Endpoint security groups<br/>resource "aws_security_group" "endpoint_ecr" {<br/>  name   = "endpoint-ecr-sg"<br/>  vpc_id = aws_vpc.custom_vpc.id<br/>}</span><span id="c014" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "endpoint_ecr_443" {<br/>  security_group_id = aws_security_group.endpoint_ecr.id<br/>  type              = "ingress"<br/>  from_port         = 443<br/>  to_port           = 443<br/>  protocol          = "tcp"<br/>  cidr_blocks = flatten([[var.private_subnet_cidr_block], var.public_subnet_cidr_blocks])<br/>}</span></pre><h1 id="d904" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">创建EKS集群</h1><p id="43f0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们正进入我们计划要做的核心阶段。在创建集群之前，我们需要创建一个具有特定IAM策略的IAM角色，因为由Amazon EKS管理的Kubernetes集群代表我们调用其他AWS服务来管理服务使用的资源。因此它需要正确的权限来成功执行这些调用。</p><p id="9c34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，一旦创建了角色，我们就可以继续创建集群。之后，我们需要为控制平面和工作节点组创建安全组，以允许集群的Kubernetes控制平面和工作节点组之间的通信。</p><p id="7a76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亚马逊EKS <a class="ae ln" href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html" rel="noopener ugc nofollow" target="_blank">托管节点组</a>自动配置为使用集群安全组，但您可以限制集群流量，并限制控制平面和工作节点之间的开放端口，这就是我们将要做的。</p><p id="d4b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在这一部分，我们将创建以下内容:</p><ul class=""><li id="0f8f" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">EKS集群IAM角色</li><li id="7aef" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">EKS集群</li><li id="2148" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">EKS集群和工作节点安全组</li></ul><h2 id="8f3a" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">EKS集群IAM角色</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="4c16" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_iam_role" "eks_cluster" {<br/>  name = "${var.eks_cluster_name}-cluster-${var.environment}"</span><span id="b17f" class="nq lr iq nk b gy nv ns l nt nu">assume_role_policy = &lt;&lt;POLICY<br/>{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Service": "eks.amazonaws.com"<br/>      },<br/>      "Action": "sts:AssumeRole"<br/>    }<br/>  ]<br/>}<br/>POLICY<br/>}</span><span id="0d5a" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "aws_eks_cluster_policy" {<br/>  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"<br/>  role       = "${aws_iam_role.eks_cluster.name}"<br/>}</span><span id="aec7" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "aws_eks_service_policy" {<br/>  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSServicePolicy"<br/>  role       = "${aws_iam_role.eks_cluster.name}"<br/>}</span></pre><h2 id="f81c" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">EKS集群</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="ec82" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_eks_cluster" "main" {<br/>  name     = var.eks_cluster_name<br/>  role_arn = "${aws_iam_role.eks_cluster.arn}"</span><span id="c391" class="nq lr iq nk b gy nv ns l nt nu">vpc_config {<br/>    security_group_ids      = [aws_security_group.eks_cluster.id, aws_security_group.eks_nodes.id]<br/>    endpoint_private_access = var.endpoint_private_access<br/>    endpoint_public_access  = var.endpoint_public_access<br/>    subnet_ids = var.eks_cluster_subnet_ids<br/>  }</span><span id="8314" class="nq lr iq nk b gy nv ns l nt nu"># Ensure that IAM Role permissions are created before and deleted after EKS Cluster handling.<br/>  # Otherwise, EKS will not be able to properly delete EKS managed EC2 infrastructure such as Security Groups.<br/>  depends_on = [<br/>    "aws_iam_role_policy_attachment.aws_eks_cluster_policy",<br/>    "aws_iam_role_policy_attachment.aws_eks_service_policy"<br/>  ]<br/>}</span></pre><h2 id="7203" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">EKS集群安全组</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="2f90" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_security_group" "eks_cluster" {<br/>  name        = var.cluster_sg_name<br/>  description = "Cluster communication with worker nodes"<br/>  vpc_id      = var.vpc_id</span><span id="f952" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = var.cluster_sg_name<br/>  }<br/>}</span><span id="e3f8" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "cluster_inbound" {<br/>  description              = "Allow worker nodes to communicate with the cluster API Server"<br/>  from_port                = 443<br/>  protocol                 = "tcp"<br/>  security_group_id        = aws_security_group.eks_cluster.id<br/>  source_security_group_id = aws_security_group.eks_nodes.id<br/>  to_port                  = 443<br/>  type                     = "ingress"<br/>}</span><span id="2a51" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "cluster_outbound" {<br/>  description              = "Allow cluster API Server to communicate with the worker nodes"<br/>  from_port                = 1024<br/>  protocol                 = "tcp"<br/>  security_group_id        = aws_security_group.eks_cluster.id<br/>  source_security_group_id = aws_security_group.eks_nodes.id<br/>  to_port                  = 65535<br/>  type                     = "egress"<br/>}</span></pre><h2 id="b7eb" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">EKS工作节点组安全组</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="7734" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_security_group" "eks_nodes" {<br/>  name        = var.nodes_sg_name<br/>  description = "Security group for all nodes in the cluster"<br/>  vpc_id      = var.vpc_id</span><span id="1614" class="nq lr iq nk b gy nv ns l nt nu">egress {<br/>    from_port   = 0<br/>    to_port     = 0<br/>    protocol    = "-1"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="a0b7" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name                                        = var.nodes_sg_name<br/>    "kubernetes.io/cluster/${var.eks_cluster_name}" = "owned"<br/>  }<br/>}</span><span id="3bbf" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "nodes" {<br/>  description              = "Allow nodes to communicate with each other"<br/>  from_port                = 0<br/>  protocol                 = "-1"<br/>  security_group_id        = aws_security_group.eks_nodes.id<br/>  source_security_group_id = aws_security_group.eks_nodes.id<br/>  to_port                  = 65535<br/>  type                     = "ingress"<br/>}</span><span id="3342" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_security_group_rule" "nodes_inbound" {<br/>  description              = "Allow worker Kubelets and pods to receive communication from the cluster control plane"<br/>  from_port                = 1025<br/>  protocol                 = "tcp"<br/>  security_group_id        = aws_security_group.eks_nodes.id<br/>  source_security_group_id = aws_security_group.eks_cluster.id<br/>  to_port                  = 65535<br/>  type                     = "ingress"<br/>}</span></pre><h1 id="959b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">创建工作节点组</h1><p id="98b1" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">与创建集群类似，我们首先需要为附加了特定IAM策略的工作节点创建一个IAM角色，然后才能启动使用它们。这种特殊情况下的原因是什么？worker节点上的守护进程kubelet代表我们调用AWS APIs，节点需要这个角色和必要的策略来拥有这些API调用的正确权限。</p><p id="4373" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本节中，我们将创建以下内容:</p><ul class=""><li id="0c9d" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">工作节点组IAM角色</li><li id="6956" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">公共和私有子网的工作节点组</li></ul><h2 id="cec4" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">工作节点组IAM角色</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="d51e" class="nq lr iq nk b gy nr ns l nt nu">resource "aws_iam_role" "eks_nodes" {<br/>  name                 = "${var.eks_cluster_name}-worker-${var.environment}"</span><span id="eb6c" class="nq lr iq nk b gy nv ns l nt nu">assume_role_policy = data.aws_iam_policy_document.assume_workers.json<br/>}</span><span id="3390" class="nq lr iq nk b gy nv ns l nt nu">data "aws_iam_policy_document" "assume_workers" {<br/>  statement {<br/>    effect = "Allow"</span><span id="fe6f" class="nq lr iq nk b gy nv ns l nt nu">actions = ["sts:AssumeRole"]</span><span id="e327" class="nq lr iq nk b gy nv ns l nt nu">principals {<br/>      type        = "Service"<br/>      identifiers = ["ec2.amazonaws.com"]<br/>    }<br/>  }<br/>}</span><span id="e0be" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "aws_eks_worker_node_policy" {<br/>  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"<br/>  role       = aws_iam_role.eks_nodes.name<br/>}</span><span id="a6b5" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "aws_eks_cni_policy" {<br/>  policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"<br/>  role       = aws_iam_role.eks_nodes.name<br/>}</span><span id="dfc5" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "ec2_read_only" {<br/>  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"<br/>  role       = aws_iam_role.eks_nodes.name<br/>}</span><span id="58ca" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_role_policy_attachment" "cluster_autoscaler" {<br/>  policy_arn = aws_iam_policy.cluster_autoscaler_policy.arn<br/>  role = aws_iam_role.eks_nodes.name<br/>}</span><span id="a870" class="nq lr iq nk b gy nv ns l nt nu">resource "aws_iam_policy" "cluster_autoscaler_policy" {<br/>  name        = "ClusterAutoScaler"<br/>  description = "Give the worker node running the Cluster Autoscaler access to required resources and actions"</span><span id="d53c" class="nq lr iq nk b gy nv ns l nt nu">policy = &lt;&lt;EOF<br/>{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "autoscaling:DescribeAutoScalingGroups",<br/>                "autoscaling:DescribeAutoScalingInstances",<br/>                "autoscaling:DescribeLaunchConfigurations",<br/>                "autoscaling:DescribeTags",<br/>                "autoscaling:SetDesiredCapacity",<br/>                "autoscaling:TerminateInstanceInAutoScalingGroup"<br/>            ],<br/>            "Resource": "*"<br/>        }<br/>    ]<br/>}<br/>EOF<br/>}</span></pre><h2 id="4b9b" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">公共和私有子网的工作节点组</h2><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="e31d" class="nq lr iq nk b gy nr ns l nt nu"># Nodes in private subnets<br/>resource "aws_eks_node_group" "main" {<br/>  cluster_name    = aws_eks_cluster.main.name<br/>  node_group_name = var.node_group_name<br/>  node_role_arn   = aws_iam_role.eks_nodes.arn<br/>  subnet_ids      = var.private_subnet_ids</span><span id="f10a" class="nq lr iq nk b gy nv ns l nt nu">ami_type       = var.ami_type<br/>  disk_size      = var.disk_size<br/>  instance_types = var.instance_types</span><span id="12a7" class="nq lr iq nk b gy nv ns l nt nu">scaling_config {<br/>    desired_size = var.pvt_desired_size<br/>    max_size     = var.pvt_max_size<br/>    min_size     = var.pvt_min_size<br/>  }</span><span id="10b4" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = var.node_group_name<br/>  }</span><span id="988d" class="nq lr iq nk b gy nv ns l nt nu"># Ensure that IAM Role permissions are created before and deleted after EKS Node Group handling.<br/>  # Otherwise, EKS will not be able to properly delete EC2 Instances and Elastic Network Interfaces.<br/>  depends_on = [<br/>    aws_iam_role_policy_attachment.aws_eks_worker_node_policy,<br/>    aws_iam_role_policy_attachment.aws_eks_cni_policy,<br/>    aws_iam_role_policy_attachment.ec2_read_only,<br/>  ]<br/>}</span><span id="4a7a" class="nq lr iq nk b gy nv ns l nt nu"># Nodes in public subnet<br/>resource "aws_eks_node_group" "public" {<br/>  cluster_name    = aws_eks_cluster.main.name<br/>  node_group_name = "${var.node_group_name}-public"<br/>  node_role_arn   = aws_iam_role.eks_nodes.arn<br/>  subnet_ids      = var.public_subnet_ids</span><span id="f2bd" class="nq lr iq nk b gy nv ns l nt nu">ami_type       = var.ami_type<br/>  disk_size      = var.disk_size<br/>  instance_types = var.instance_types</span><span id="0a7e" class="nq lr iq nk b gy nv ns l nt nu">scaling_config {<br/>    desired_size = var.pblc_desired_size<br/>    max_size     = var.pblc_max_size<br/>    min_size     = var.pblc_min_size<br/>  }</span><span id="75e9" class="nq lr iq nk b gy nv ns l nt nu">tags = {<br/>    Name = "${var.node_group_name}-public"<br/>  }</span><span id="360f" class="nq lr iq nk b gy nv ns l nt nu"># Ensure that IAM Role permissions are created before and deleted after EKS Node Group handling.<br/>  # Otherwise, EKS will not be able to properly delete EC2 Instances and Elastic Network Interfaces.<br/>  depends_on = [<br/>    aws_iam_role_policy_attachment.aws_eks_worker_node_policy,<br/>    aws_iam_role_policy_attachment.aws_eks_cni_policy,<br/>    aws_iam_role_policy_attachment.ec2_read_only,<br/>  ]<br/>}</span></pre><h1 id="3676" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">部署和展示Pod</h1><p id="7e2e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">假设您已经运行了<code class="fe nh ni nj nk b">terragrunt apply</code>或<code class="fe nh ni nj nk b">terraform apply</code>,并且您的集群已成功创建，节点组也已注册到集群，那么我们现在可以进入下一步，在集群上测试应用程序。为了与我的集群通信，我将使用kubectl。第一步是为我们的容器创建一个Pod来运行，然后使用一个服务来公开(让公众可以访问)这个容器化的应用程序。</p><p id="234e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">吊舱——部署的基本单位；它代表一个计划单元的运行进程，是一个或多个组合在一起的容器的包装。每个pod都分配有一个唯一的IP地址，并且可以公开端口。标签用于从逻辑上识别符合标准的pod</p><p id="55e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务——服务是一组pod之上的抽象对象，就像负载平衡器一样。它们以循环方式将流量路由到pod。有三种类型的服务:</p><ul class=""><li id="2975" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">ClusterIP —只能从集群内部访问。</li><li id="f773" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">负载平衡器—将pod暴露给外部客户端流量。暴露在外部负载平衡器上。</li><li id="cffc" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">节点端口—可从公开的节点端口访问。</li></ul><h2 id="08bd" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">连接到EKS集群</h2><p id="4eb0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">确保您已经安装了正确版本的AWS CLI。您可以通过运行以下命令进行检查:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="e368" class="nq lr iq nk b gy nr ns l nt nu">aws --version</span></pre><p id="0ab2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您已经安装了AWS CLI和kubectl，那么您可以通过运行以下命令来确保您已经获得了正确的AWS概要文件，并配置了必要的权限:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="4c50" class="nq lr iq nk b gy nr ns l nt nu"> aws sts get-caller-identity</span></pre><p id="60ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要为集群创建或更新kubeconfig文件，请运行以下命令:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="2524" class="nq lr iq nk b gy nr ns l nt nu">aws eks --region region update-kubeconfig --name <strong class="nk ir">your-cluster-name</strong></span></pre><p id="f38a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该已经准备好调用集群的公共API端点了。如果你愿意，你可以在这里阅读更多关于管理集群认证<a class="ae ln" href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html" rel="noopener ugc nofollow" target="_blank">的信息。运行以下命令检查当前正在运行的工作节点:</a></p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="1ff8" class="nq lr iq nk b gy nr ns l nt nu">kubectl get nodes</span></pre><h2 id="90f2" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">标签节点</h2><p id="de53" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我想将我的Pod专门分配给在专用子网中运行的节点。标签只是一个键/值对。为此，我使用以下命令标记节点:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="83ab" class="nq lr iq nk b gy nr ns l nt nu">kubectl label nodes <strong class="nk ir">&lt;your-node-name&gt;</strong> nodeType=privateNode</span></pre><p id="6943" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为确保成功标记节点，您可以运行以下命令来检查每个节点的标签:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="9c5e" class="nq lr iq nk b gy nr ns l nt nu">kubectl get nodes --show-labels</span></pre><p id="bbce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，您可以查看您标记的特定节点的详细信息:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="4f54" class="nq lr iq nk b gy nr ns l nt nu">kubectl describe node <strong class="nk ir">&lt;your-node-name&gt;</strong></span></pre><p id="9f96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了绑定到这些节点，我们将利用<code class="fe nh ni nj nk b">nodeSelector</code>，这是推荐的最简单的节点选择约束形式。<code class="fe nh ni nj nk b">nodeSelector</code>是PodSpec的一个字段。</p><h2 id="fafb" class="nq lr iq bd ls nw nx dn lw ny nz dp ma la oa ob mc le oc od me li oe of mg og bi translated">创建Pod和服务</h2><p id="4166" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">接下来，我将使用从ECR存储库中的映像构建的容器创建一个pod。下面是正在创建的pod的清单文件，以及将公开它的服务。</p><p id="eedf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">吊舱</strong></p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="f992" class="nq lr iq nk b gy nr ns l nt nu">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nodejs-express-pod<br/>  labels:<br/>    app: nodejs-express<br/>spec:<br/>  containers:<br/>  - name: nodejs-express-container<br/>    image: <strong class="nk ir">&lt;image&gt;</strong><br/>    ports:<br/>      - containerPort: 8080<br/>  nodeSelector:<br/>    nodeType: privateNode # specify the node constraint which the pod should run on</span></pre><p id="692f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">服务</strong></p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="354e" class="nq lr iq nk b gy nr ns l nt nu">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: nodejs-service<br/>spec:<br/>  selector:<br/>    app: nodejs-express<br/>  type: LoadBalancer<br/>  ports:<br/>  - protocol: TCP<br/>    port: 8080<br/>    targetPort: 8080</span></pre><p id="5628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦保存了清单文件，就可以使用以下命令一次创建一个文件:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="7e65" class="nq lr iq nk b gy nr ns l nt nu">kubectl apply -f <strong class="nk ir">&lt;manifest-file-name&gt;.yml</strong></span></pre><p id="fc58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要测试pod和服务是否都正常运行，您可以运行以下命令:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="2017" class="nq lr iq nk b gy nr ns l nt nu">kubectl get pods<br/>kubectl get services</span></pre><p id="a760" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们将服务创建为LoadBalancer类型，因此将在您的AWS帐户中创建一个经典负载平衡器，它将具有一个外部或公共IP地址和一个DNS名称，您可以使用它在指定的服务端口上访问您的应用程序。在我的例子中，API请求将被发送到以下地址:</p><pre class="kg kh ki kj gt nm nk nn no aw np bi"><span id="6a5a" class="nq lr iq nk b gy nr ns l nt nu">&lt;prefix-characters-for-domain-name&gt;.&lt;aws-region&gt;.elb.amazonaws.com:8080/test</span></pre></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="6cac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我在开始提到的，这篇文章的所有源代码都可以在这里找到。我希望这篇文章已经为你提供了足够的知识，当你寻找一个引擎来满足一个特定的用例时，与这里的<a class="ae ln" href="https://github.com/LukeMwila/aws-eks-platform" rel="noopener ugc nofollow" target="_blank">相比</a>。</p><p id="e1d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像往常一样，快乐编码💻！</p></div></div>    
</body>
</html>