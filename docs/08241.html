<html>
<head>
<title>Stacks Part 2 — Infix to Postfix in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈第 2 部分—Go 中后缀的中缀</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stacks-part-2-infix-to-postfix-in-go-610da8776be?source=collection_archive---------12-----------------------#2022-05-29">https://blog.devgenius.io/stacks-part-2-infix-to-postfix-in-go-610da8776be?source=collection_archive---------12-----------------------#2022-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8caf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到<em class="ki">围棋数据结构简介</em>！正如我所承诺的，我们将研究堆栈的一个特殊应用。具体来说，我们将探讨如何将中缀表达式转换成它们的后缀等价物。后缀符号可能一开始看起来不直观，但是在阅读了这篇文章之后，它会变得更加清晰。</p><h1 id="3dd6" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">简明入门</h1><p id="4a4c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">“Jacob，距离你上次发帖已经整整一周了。我不记得这些是什么了。”好的，让我们从解释这些是什么开始。</p><p id="9edb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在数学课上学到了表达式是术语和运算符的组合，通常以这种格式编写。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="652d" class="lv kk in lr b gy lw lx l ly lz">a + b</span></pre><p id="0ea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是所谓的<em class="ki">中缀</em>符号。这是因为运算符是在操作数之间的中的<strong class="jm io">。</strong></p><p id="33bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还用另外两种符号来计算表达式。它们是<em class="ki">前缀</em>和<em class="ki">后缀</em>符号。以下是三种表达方式的对比。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f69f" class="lv kk in lr b gy lw lx l ly lz">Infix: &lt;operand&gt;&lt;operator&gt;&lt;operand&gt;<br/>Prefix: &lt;operator&gt;&lt;operand&gt;&lt;operand&gt;<br/>Postfix: &lt;operand&gt;&lt;operand&gt;&lt;operator&gt;</span></pre><p id="95b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的表达式<code class="fe ma mb mc lr b">a + b</code>，也可以这样写:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="dffd" class="lv kk in lr b gy lw lx l ly lz">Infix: a+b<br/>Prefix: +ab<br/>Postfix: ab+</span></pre><p id="497e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用中缀符号是因为它易于理解。但是通常对我们人类来说容易的事情对计算机来说却很难。想象一下，写一个程序来计算一个表达式。像<code class="fe ma mb mc lr b">a + b</code>这样简单的表达足够简单。然而，想象一下如果表达式变得更复杂。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="91b0" class="lv kk in lr b gy lw lx l ly lz">{(a*b) + (c*d)} - e</span></pre><p id="0ef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当有很多括号和运算符时，你可以看到难度增加得有多快。我们不仅需要处理操作，还需要跟踪操作的顺序。因为有嵌套的括号，我们必须先前后跳转来计算括号内的表达式。跟踪我们在哪里将是一场噩梦。</p><p id="652c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在看看这个。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="65e0" class="lv kk in lr b gy lw lx l ly lz">ab*cd*+e-</span></pre><p id="bcf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后缀符号更容易理解，因为我们只需要从左到右扫描表达式就可以得到结果。</p><h1 id="2050" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">我们如何评估一个后缀表达式？</h1><p id="3bb3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们来看看这个表情:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="87ea" class="lv kk in lr b gy lw lx l ly lz">ab*cd*+e-<br/>a = 2<br/>b = 5<br/>c = 3<br/>d = 1<br/>e = 4</span></pre><p id="80d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先从左向右扫描。当我们看到一个操作员时，我们会停下来。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3ab1" class="lv kk in lr b gy lw lx l ly lz">2 5 * 3 1 * + 4 -<br/>    ^</span></pre><p id="3292" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们看到操作员，我们就后退两步。每次我们回去的时候，我们都会记下数字。然后，我们评估表达式。在这种情况下，我们在乘法运算符<code class="fe ma mb mc lr b">*</code>处停止，然后后退两步。我们跟踪这些数字，它们是<code class="fe ma mb mc lr b">2</code>和<code class="fe ma mb mc lr b">5</code>。要进行评估，我们需要做的就是<code class="fe ma mb mc lr b">2 * 5</code>，这就产生了<code class="fe ma mb mc lr b">10</code>。应用操作的顺序很重要。例如:如果我们的操作符是<code class="fe ma mb mc lr b">-</code>而不是<code class="fe ma mb mc lr b">*</code>，那么<code class="fe ma mb mc lr b">2 - 5</code>应该会产生<code class="fe ma mb mc lr b">-3</code>，但是做<code class="fe ma mb mc lr b">5 - 2</code>会产生<code class="fe ma mb mc lr b">3</code>。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e741" class="lv kk in lr b gy lw lx l ly lz">2 5 * 3 1 * + 4 -<br/>    ^<br/>Numbers: 5, 2<br/>Evaluation: 2 * 5 = 10</span><span id="271f" class="lv kk in lr b gy md lx l ly lz">Result:<br/>10 3 1 * + 4 -</span></pre><p id="f428" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了。我们现在需要做的就是重复上述步骤，直到完成。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="60bc" class="lv kk in lr b gy lw lx l ly lz">10 3 1 * + 4 -<br/>       ^<br/>Numbers: 1, 3<br/>Evaluation: 3 * 1 = 3</span><span id="f626" class="lv kk in lr b gy md lx l ly lz">Result:<br/>10 3 + 4 -</span><span id="4931" class="lv kk in lr b gy md lx l ly lz">10 3 + 4 -<br/>     ^<br/>Numbers: 3, 10<br/>Evaluation: 3 + 10 = 13</span><span id="c5b3" class="lv kk in lr b gy md lx l ly lz">Result:<br/>13 4 -</span><span id="7195" class="lv kk in lr b gy md lx l ly lz">13 4 -<br/>     ^<br/>Numbers: 4, 13<br/>Evaluation: 13 - 4 = 9</span><span id="d078" class="lv kk in lr b gy md lx l ly lz">Result:<br/>9</span></pre><p id="5f61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们最终得到了<code class="fe ma mb mc lr b">9</code>。为了仔细检查，让我们计算一下中缀表达式。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="99eb" class="lv kk in lr b gy lw lx l ly lz">Evaluate {(a*b) + (c*d)} - e, given these conditions:<br/>a = 2, b = 5, c = 3, d = 1, e = 4</span><span id="c2d0" class="lv kk in lr b gy md lx l ly lz">{(2 * 5) + (3 * 1)} - 4 <br/>= {10 + 3} - 4 <br/>= 13 - 4 <br/>= 9</span></pre><p id="4e9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">瞧。我们已经成功评估了后缀表达式。</p><p id="f6dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意我们跟踪的<code class="fe ma mb mc lr b">Numbers</code>是如何像堆栈一样运行的吗？当我们看到一个运算符时，我们回溯两次，并将这些数字推入<code class="fe ma mb mc lr b">Numbers</code>堆栈。然后，我们弹出这些数字并应用操作。</p><h1 id="53b3" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">将其转换为手动方式</h1><p id="8f4f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们可以使用堆栈将中缀符号转换成后缀等价符号。在我们讨论如何将其写入 Go 之前，理解该过程背后的逻辑很重要。</p><p id="91c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们需要转换这个表达式:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ce8c" class="lv kk in lr b gy lw lx l ly lz">a+b*c</span></pre><p id="e004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们应该做的是跟踪运算符，类似于我们在前面的例子中跟踪操作数的方式。</p><p id="dab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们从左向右扫描。当我们看到一个操作数时，我们把它写到边上。当我们看到一个运算符时，我们将其添加到我们的运算符列表中。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a7a7" class="lv kk in lr b gy lw lx l ly lz">a + b * c<br/>^<br/>Operators:<br/>Result: a</span><span id="cede" class="lv kk in lr b gy md lx l ly lz">a + b * c<br/>  ^<br/>Operators: +<br/>Result: a</span><span id="149a" class="lv kk in lr b gy md lx l ly lz">a + b * c<br/>    ^<br/>Operators: +<br/>Result: ab</span><span id="4c35" class="lv kk in lr b gy md lx l ly lz">a + b * c<br/>      ^<br/>Operators: +, *<br/>Result: ab</span></pre><p id="d6ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是最重要的部分。</p><ul class=""><li id="fa4d" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">当添加运算符时，我们需要检查我们所指向的运算符是否比列表顶部的运算符具有更高的优先级。这里，我们所指向的运算符<code class="fe ma mb mc lr b">*</code>优先于列表顶部的运算符<code class="fe ma mb mc lr b">-</code>。乘法优先于减法。</li><li id="615e" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">如果它确实优先，我们只需要将指向的运算符添加到我们的运算符列表中。</li><li id="c067" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">但是，如果它没有优先，我们弹出列表，并将列表中的运算符附加到结果字符串中。我们继续这样做，直到我们指向的运算符优先于列表顶部的运算符。在所有这些之后，我们将运算符添加到列表中。</li></ul><p id="a6b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3045" class="lv kk in lr b gy lw lx l ly lz">a + b * c<br/>        ^<br/>Operators: +, *<br/>Result: abc</span></pre><p id="d8a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们到达最后，我们弹出操作符列表，并将项目附加到结果字符串中，如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="dd2b" class="lv kk in lr b gy lw lx l ly lz">Result: abc*+</span></pre><p id="6deb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们再看一个例子。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="932f" class="lv kk in lr b gy lw lx l ly lz">a * b + c<br/>^<br/>Operators:<br/>Result: a<br/>---</span><span id="0f4a" class="lv kk in lr b gy md lx l ly lz">a * b + c<br/>  ^<br/>Operators: *<br/>Results: a</span><span id="4699" class="lv kk in lr b gy md lx l ly lz">---</span><span id="bd54" class="lv kk in lr b gy md lx l ly lz">a * b + c<br/>    ^<br/>Operators: *<br/>Results: ab</span><span id="58b3" class="lv kk in lr b gy md lx l ly lz">---</span><span id="55fa" class="lv kk in lr b gy md lx l ly lz">a * b + c<br/>      ^<br/>Operators: * // check for precedence before you add +!<br/>Results: ab</span></pre><p id="6f0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们以第二种情况结束。由于<code class="fe ma mb mc lr b">+</code>不优先于<code class="fe ma mb mc lr b">*</code>，我们需要弹出操作符列表，直到<code class="fe ma mb mc lr b">+</code>优先。在这种情况下，我们需要弹出它，直到列表中没有任何内容。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7072" class="lv kk in lr b gy lw lx l ly lz">a * b + c<br/>      ^<br/>Operators: + // + is pushed in after * is popped out<br/>Results: ab* // * is popped and appended into the result string</span></pre><p id="7f9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">剩下的就简单了。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="6da9" class="lv kk in lr b gy lw lx l ly lz">a * b + c<br/>        ^<br/>Operators: +<br/>Results: ab*c</span><span id="d791" class="lv kk in lr b gy md lx l ly lz">---</span><span id="2e8a" class="lv kk in lr b gy md lx l ly lz">Results: ab*c+</span></pre><p id="4a80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看最后一个例子。这一次，我们将转换一个带括号的表达式。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2382" class="lv kk in lr b gy lw lx l ly lz">{(a*b) + (c*d)} - e</span></pre><p id="cd8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">别担心，我们只需要再添加一条规则。</p><ul class=""><li id="3d45" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">如果它是一个左括号，我们把它添加到我们的操作符列表中。</li><li id="d45f" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">如果是右括号，我们弹出列表，直到弹出相应的括号。</li><li id="972c" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">我们不需要在结果字符串后面加上括号。后缀符号不需要。</li></ul><p id="4694" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一步一步来！</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0f1d" class="lv kk in lr b gy lw lx l ly lz">{ ( a * b ) * c - d } - e<br/>    ^<br/>Operators: {, (<br/>Result: a</span><span id="8a98" class="lv kk in lr b gy md lx l ly lz">---</span><span id="9185" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>      ^<br/>Operators: {, (, *<br/>Result: a</span><span id="3bca" class="lv kk in lr b gy md lx l ly lz">---</span><span id="7160" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>        ^<br/>Operators: {, (, *<br/>Result: ab</span><span id="7427" class="lv kk in lr b gy md lx l ly lz">---</span><span id="9c34" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>          ^<br/>Operators: { // pop until the corresponding parenthesis is popped<br/>Result: ab* // * is appended</span><span id="d99d" class="lv kk in lr b gy md lx l ly lz">---</span><span id="8f31" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>            ^<br/>Opeartors: {, *<br/>Result: ab*</span><span id="a556" class="lv kk in lr b gy md lx l ly lz">---</span><span id="26f0" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>              ^<br/>Operators: {, *<br/>Result: ab*c</span><span id="fa2f" class="lv kk in lr b gy md lx l ly lz">---</span><span id="bd03" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>                ^<br/>Operators: {, - // - doesn't take precedence over *<br/>Result: ab*c* // * is popped and appended</span><span id="59ad" class="lv kk in lr b gy md lx l ly lz">---</span><span id="b1ec" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>                  ^<br/>Operators: {, -<br/>Result: ab*c*d</span><span id="1705" class="lv kk in lr b gy md lx l ly lz">---</span><span id="4f92" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>                    ^<br/>Operators: <br/>Result: ab*c*d-</span><span id="19da" class="lv kk in lr b gy md lx l ly lz">---</span><span id="6664" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>                      ^<br/>Operators: -<br/>Result: ab*c*d-</span><span id="7562" class="lv kk in lr b gy md lx l ly lz">---</span><span id="1440" class="lv kk in lr b gy md lx l ly lz">{ ( a * b ) * c - d } - e<br/>                        ^<br/>Operators: -<br/>Result: ab*c*d-e</span><span id="77ff" class="lv kk in lr b gy md lx l ly lz">---</span><span id="e749" class="lv kk in lr b gy md lx l ly lz">Result: ab*c*d-e-</span></pre><p id="f643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它看起来很复杂，只是因为我们一步一步慢慢来。逻辑本身非常简单。</p><p id="a15b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，操作符列表的作用就像一个堆栈，因为我们不断地从堆栈中推出和取出。</p><h1 id="ba6e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">去把它写在 Go 里</h1><p id="f7a1" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">太好了！现在我们已经理解了高级逻辑是如何工作的，我们可以开始在 Go 中实现它了。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="94fa" class="lv kk in lr b gy lw lx l ly lz">type Stack struct {<br/>    items []float64<br/>}</span><span id="4690" class="lv kk in lr b gy md lx l ly lz">func (s *Stack) Push(data float64) {<br/>    s.items = append(s.items, data)<br/>}</span><span id="b3c8" class="lv kk in lr b gy md lx l ly lz">func (s *Stack) Pop() {<br/>    if s.IsEmpty() {<br/>        return<br/>    }<br/>    s.items = s.items[:len(s.items)-1]<br/>}</span><span id="9bc9" class="lv kk in lr b gy md lx l ly lz">func (s *Stack) Top() (float64, error) {<br/>    if s.IsEmpty() {<br/>        return 0.0, fmt.Errorf("stack is empty")<br/>    }<br/>    return s.items[len(s.items)-1], nil<br/>}</span><span id="0d31" class="lv kk in lr b gy md lx l ly lz">func (s *Stack) IsEmpty() bool {<br/>    if len(s.items) == 0 {<br/>        return true<br/>    }<br/>    return false<br/>}</span><span id="c52d" class="lv kk in lr b gy md lx l ly lz">func (s *Stack) Print() {<br/>    for _, item := range s.items {<br/>        fmt.Print(item, " ")<br/>    }<br/>}</span></pre><p id="aeaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用上一篇文章中的堆栈实现。这个堆栈可以容纳<code class="fe ma mb mc lr b">float64</code>个类型。</p><p id="0fa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们先来看看如何计算一个后缀表达式。</p><h2 id="f28e" class="lv kk in bd kl ms mt dn kp mu mv dp kt jv mw mx kx jz my mz lb kd na nb lf nc bi translated">评估后缀表达式</h2><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2c89" class="lv kk in lr b gy lw lx l ly lz">func evaluatePostfix(exp string) (float64, error) {<br/>    operands := new(Stack)<br/>    chars := strings.Split(exp, " ")</span><span id="2b67" class="lv kk in lr b gy md lx l ly lz">    for _, char := range chars {<br/>        if !isOperator(char) {<br/>            op, err := strconv.ParseFloat(char, 64)<br/>            if err != nil {<br/>                return 0.0, err<br/>            }<br/>            operands.Push(op)<br/>        } else {<br/>            operand2, err := operands.Top()<br/>            if err != nil {<br/>                return 0.0, err<br/>            }<br/>            operands.Pop()</span><span id="a693" class="lv kk in lr b gy md lx l ly lz">            operand1, err := operands.Top()<br/>            if err != nil {<br/>                return 0.0, err<br/>            }<br/>            operands.Pop()</span><span id="d55a" class="lv kk in lr b gy md lx l ly lz">            calculated, err := calculate(char, operand1, operand2)<br/>            if err != nil {<br/>                return 0.0, err<br/>            }</span><span id="b7e8" class="lv kk in lr b gy md lx l ly lz">            operands.Push(calculated)<br/>        }<br/>    }<br/>    result, err := operands.Top()<br/>    if err != nil {<br/>        return 0.0, err<br/>    }</span><span id="e493" class="lv kk in lr b gy md lx l ly lz">    return result, nil<br/>}</span></pre><p id="0d1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先通过空格将表达式分割成单独的字符。表达式应该是操作数和运算符的组合，每个都用空格分隔。我们现在可以遍历得到的字符片段。</p><p id="28f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于每个字符，我们想通过使用<code class="fe ma mb mc lr b">isOperator</code>辅助函数来检查它是操作数还是运算符。如果一个字符是一个操作数，我们把它压入堆栈。</p><p id="9caf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果角色是一个操作符，我们弹出堆栈中最上面的两个项目，将它们保存为<code class="fe ma mb mc lr b">operand2</code>和<code class="fe ma mb mc lr b">operand1</code>。然后，我们使用<code class="fe ma mb mc lr b">calculate</code>辅助函数对表达式求值。一旦计算完成，我们就把它推到堆栈中。</p><p id="62fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">迭代完表达式后，我们从堆栈中获取最顶端的项，这是我们的最终结果。</p><p id="278e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是助手函数的定义。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="83fa" class="lv kk in lr b gy lw lx l ly lz">func isOperator(char string) bool {<br/>    switch char {<br/>    case "+":<br/>        return true<br/>    case "-":<br/>        return true<br/>    case "*":<br/>        return true<br/>    case "/":<br/>        return true<br/>    default:<br/>        return false<br/>    }<br/>}</span><span id="58bc" class="lv kk in lr b gy md lx l ly lz">func calculate(operator string, operand1, operand2 float64) (float64, error) {<br/>    result := 0.0<br/>    switch operator {<br/>    case "+":<br/>        result = operand1 + operand2<br/>    case "-":<br/>        result = operand1 - operand2<br/>    case "*":<br/>        result = operand1 * operand2<br/>    case "/":<br/>        result = operand1 / operand2<br/>    default:<br/>        return 0.0, fmt.Errorf("invalid operator")<br/>    }</span><span id="2c6b" class="lv kk in lr b gy md lx l ly lz">    return result, nil<br/>}</span></pre><p id="8000" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以看看如何编写中缀到后缀的转换函数。</p><h2 id="c862" class="lv kk in bd kl ms mt dn kp mu mv dp kt jv mw mx kx jz my mz lb kd na nb lf nc bi translated">将中缀转换为后缀</h2><p id="54be" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们将改变堆栈，使其存储<code class="fe ma mb mc lr b">string</code>类型，而不是<code class="fe ma mb mc lr b">float64</code>类型。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1c54" class="lv kk in lr b gy lw lx l ly lz">func infixToPostfix(exp string) (string, error) {<br/>    operators := new(StringStack)<br/>    chars := strings.Fields(exp)<br/>    result := ""</span><span id="9468" class="lv kk in lr b gy md lx l ly lz">    for _, char := range chars {<br/>        if isOpeningParenthesis(char) {<br/>            operators.Push(char)<br/>        } else if isClosingParenthesis(char) {<br/>            for !operators.IsEmpty() &amp;&amp; !isMatchingParenthesis(ignoreError(operators.Top()), char) {<br/>                top, err := operators.Top()<br/>                if err != nil {<br/>                    return "", err<br/>                }<br/>                result += top<br/>                operators.Pop()<br/>            }<br/>            operators.Pop()<br/>        } else if !isOperator(char) {<br/>            result += char<br/>        } else if isOperator(char) {<br/>            for !operators.IsEmpty() &amp;&amp; hasHigherPrecedence(ignoreError(operators.Top()), char) &amp;&amp; !isOpeningParenthesis(ignoreError(operators.Top())) {<br/>                top, err := operators.Top()<br/>                if err != nil {<br/>                    return "", err<br/>                }<br/>                result += top<br/>                operators.Pop()<br/>            }<br/>            operators.Push(char)<br/>        }<br/>    }</span><span id="5b1f" class="lv kk in lr b gy md lx l ly lz">    for !operators.IsEmpty() {<br/>        top, err := operators.Top()<br/>        if err != nil {<br/>            return "", err<br/>        }<br/>        result += top</span><span id="3d14" class="lv kk in lr b gy md lx l ly lz">        operators.Pop()<br/>    }</span><span id="af1b" class="lv kk in lr b gy md lx l ly lz">    return result, nil<br/>}</span></pre><p id="5c3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开头也差不多。我们创建一个字符串片段来保存所有拆分的字符。这里的新内容是我们需要处理四个案例。</p><ul class=""><li id="13bd" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">当字符是一个左括号时，我们把它压入堆栈。</li><li id="9cc7" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">当字符是右括号时，我们弹出所有的操作符，直到弹出一个匹配的左括号。</li><li id="b95e" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">当字符是一个操作数时，我们把它附加到结果字符串中。</li><li id="1382" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">当字符是一个操作符时，我们检查优先级。如果栈中最顶端的操作符的优先级高于字符，我们就弹出直到找到左括号。然后，我们将字符推入堆栈。</li></ul><p id="8113" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们将堆栈中剩余的内容刷新到结果字符串中。</p><p id="1aaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是助手函数的定义。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0bae" class="lv kk in lr b gy lw lx l ly lz">func isOpeningParenthesis(char string) bool {<br/>    switch char {<br/>    case "(":<br/>        return true<br/>    case "{":<br/>        return true<br/>    case "[":<br/>        return true<br/>    default:<br/>        return false<br/>    }<br/>}</span><span id="2bfc" class="lv kk in lr b gy md lx l ly lz">func isClosingParenthesis(char string) bool {<br/>    switch char {<br/>    case ")":<br/>        return true<br/>    case "}":<br/>        return true<br/>    case "]":<br/>        return true<br/>    default:<br/>        return false<br/>    }<br/>}</span><span id="bc83" class="lv kk in lr b gy md lx l ly lz">func isMatchingParenthesis(opening, closing string) bool {<br/>    switch opening {<br/>    case "(":<br/>        if closing == ")" {<br/>            return true<br/>        }<br/>    case "{":<br/>        if closing == "}" {<br/>            return true<br/>        }<br/>    case "[":<br/>        if closing == "]" {<br/>            return true<br/>        }<br/>    default:<br/>        return false<br/>    }<br/>    return false<br/>}</span><span id="3ede" class="lv kk in lr b gy md lx l ly lz">func hasHigherPrecedence(target, source string) bool {<br/>    if (target == "*" || target == "/") &amp;&amp; (source == "+" || source == "-") {<br/>        return true<br/>    } else {<br/>        return false<br/>    }<br/>}</span><span id="ac2a" class="lv kk in lr b gy md lx l ly lz">func ignoreError(val string, err error) string {<br/>    return val<br/>}</span></pre><p id="54a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，忽略错误不是一个好习惯。我用它来处理恼人的错误返回，因为我不能将<code class="fe ma mb mc lr b">operators.Top()</code>传递给<code class="fe ma mb mc lr b">hasHigherPrecedence</code>或<code class="fe ma mb mc lr b">isMatchingParenthesis</code>，因为它返回两个值，其中一个是错误。如果您必须忽略这样的错误，您也可以定义一个类似于<code class="fe ma mb mc lr b">stack.TopNoError()</code>的 struct 方法，它将返回没有任何错误变量的最上面的值。</p><h1 id="d9b6" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="f774" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">感谢您的阅读！那是一篇很长的文章，但是我为你能忍受我而感到骄傲。您通常不会遇到必须将中缀表达式显式转换为后缀表达式的情况，因为编译器会为您处理它。然而，这是一个学习栈如何工作的好方法，我认为这也是一个非常有趣的话题。下周我会带着一份关于排队的报告回来。到时候见！</p><p id="d96d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae nd" href="https://dev.to/jpoly1219/stacks-part-2-infix-to-postfix-in-go-2oam" rel="noopener ugc nofollow" target="_blank">发展到</a>和<a class="ae nd" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>