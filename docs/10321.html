<html>
<head>
<title>Build a Dynamic Configuration Loader in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Node.js 中构建一个动态配置加载器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-dynamic-configuration-loader-in-node-js-2d4d2117d750?source=collection_archive---------0-----------------------#2022-10-24">https://blog.devgenius.io/build-a-dynamic-configuration-loader-in-node-js-2d4d2117d750?source=collection_archive---------0-----------------------#2022-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/efe984f8ea7af69887911a6f19a1fa9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqBIwdRZtRDwEgAjVG7I3w.png"/></div></div></figure><p id="32ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在编程中，<em class="ky">配置</em>是一个键值对列表，用于配置计算机程序的参数和初始设置，以定制它们的行为。</p><p id="19d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Node.js 中，这些值通常在流程的<em class="ky">环境</em>中定义，可以通过全局<code class="fe kz la lb lc b">process.env</code>对象访问。</p><p id="237c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然实用，但这种方法有两个缺点:</p><ol class=""><li id="889c" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">它迫使程序依赖于目标机器的波动环境，其变量可以被其他开发人员或程序覆盖或删除。</li><li id="29af" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">它迫使开发人员在每次想要改变应用程序的部署环境时覆盖这些值(<code class="fe kz la lb lc b">development</code>、<code class="fe kz la lb lc b">staging</code>、<code class="fe kz la lb lc b">production</code>等等)。</li></ol><p id="f7fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的方法是使用几个配置文件——每个部署环境一个——它们在流程启动时加载。</p><h1 id="8af5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">节点环境变量</h1><p id="896a" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><code class="fe kz la lb lc b">NODE_ENV</code>变量是由 Express framework 推广的环境变量，它指定了应用程序运行的部署环境，如<code class="fe kz la lb lc b">development</code>或<code class="fe kz la lb lc b">staging</code>。</p><p id="0fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像任何其他环境变量一样，它可以通过全局<code class="fe kz la lb lc b">process.env</code>对象访问，并使用一个选项标志来运行一段特定的代码，或者作为一个动态参数来改变应用程序的行为，例如打开和关闭调试。</p><p id="3ef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个变量可以通过在命令之前声明来本地设置，这意味着它只对那个程序可见。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="e425" class="my ls iq lc b gy mz na l nb nc">$ NODE_ENV=development node index.js</span></pre><p id="6df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者全局使用导出实用程序，这意味着它将对所有程序可见。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="2eef" class="my ls iq lc b gy mz na l nb nc">$ export NODE_ENV=development</span></pre><p id="f4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明这一点，我们可以创建一个名为<code class="fe kz la lb lc b">index.js</code>的脚本，它将简单地记录这个<code class="fe kz la lb lc b">NODE_ENV</code>变量的值。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="9669" class="my ls iq lc b gy mz na l nb nc">// index.js</span><span id="6008" class="my ls iq lc b gy nd na l nb nc">console.log(process.env.NODE_ENV);</span></pre><p id="e82b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在新的终端窗口中运行以下命令进行测试。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="833d" class="my ls iq lc b gy mz na l nb nc">$ NODE_ENV=development node index.js<br/>development<br/>$ NODE_ENV=production node index.js<br/>production</span></pre><h1 id="a09c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">dotenv 包装</h1><p id="f3a2" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><code class="fe kz la lb lc b">dotenv</code>是一个零依赖 Node.js 包，它将环境变量从一个文件加载到正在运行的进程的环境中。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="93f7" class="my ls iq lc b gy mz na l nb nc">$ npm install dotenv</span></pre><p id="48d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由<code class="fe kz la lb lc b">dotenv</code>模块公开的<code class="fe kz la lb lc b">config()</code>函数将默认尝试解析位于项目顶层目录中的<code class="fe kz la lb lc b">.env</code>文件的内容。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="8903" class="my ls iq lc b gy mz na l nb nc">var_1=123<br/>var_2=hello</span></pre><p id="5d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，它将把它的值赋给全局<code class="fe kz la lb lc b">process.env</code>对象，或者返回一个包含带有加载内容的<code class="fe kz la lb lc b">parsed</code>键的对象，或者返回一个<code class="fe kz la lb lc b">error</code>键。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="c5c9" class="my ls iq lc b gy mz na l nb nc">const { config } = require('dotenv');</span><span id="8408" class="my ls iq lc b gy nd na l nb nc">const env = config();</span><span id="b120" class="my ls iq lc b gy nd na l nb nc">if (env.error) {<br/>  throw env.error;<br/>}<br/>console.log(env.parsed);</span></pre><p id="83fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，如果我们想以不同的方式命名我们的配置文件，我们可以通过向<code class="fe kz la lb lc b">config()</code>函数传递一个带有<code class="fe kz la lb lc b">path</code>属性的可选对象来告诉<code class="fe kz la lb lc b">dotenv</code>加载哪个文件。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="ee8c" class="my ls iq lc b gy mz na l nb nc">const { config } = require('dotenv');</span><span id="423d" class="my ls iq lc b gy nd na l nb nc">const env = config({<br/>  path: '/path/to/config'<br/>});</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><div class="kn ko kp kq gt nl"><a href="https://learnbackend.dev/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">构建分层微服务|学习后端</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这是一个循序渐进的大师班，面向初学者和初级开发人员，致力于 Node.js 中的实用编程</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">learnbackend.dev</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kw nl"/></div></div></a></div></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="acfd" class="lr ls iq bd lt lu oa lw lx ly ob ma mb mc oc me mf mg od mi mj mk oe mm mn mo bi translated">配置加载器模块</h1><p id="f2f0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">正如简介中提到的，现实世界中的应用程序必须能够在多个部署环境之间切换，因此可以根据上下文加载适当的配置文件——这可以通过使用<code class="fe kz la lb lc b">NODE_ENV</code>环境变量和<code class="fe kz la lb lc b">dotenv</code>包的组合来轻松实现。</p><p id="4fc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从创建两个名为<code class="fe kz la lb lc b">.env.development</code>和<code class="fe kz la lb lc b">.env.production</code>的配置文件开始，这两个文件将包含一个名为<code class="fe kz la lb lc b">SERVER_PORT</code>的变量，该变量表示服务器将监听传入请求的端口号。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="9071" class="my ls iq lc b gy mz na l nb nc">$ echo "SERVER_PORT=3000" &gt; .env.development<br/>$ echo "SERVER_PORT=80" &gt; .env.production</span></pre><p id="dab8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个名为<code class="fe kz la lb lc b">loadenv.js</code>的模块，它导出一个工厂函数:</p><ol class=""><li id="4a18" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">使用<code class="fe kz la lb lc b">dotenv</code>包加载由以下字符串插值定义的指定文件；如果<code class="fe kz la lb lc b">NODE_ENV</code>变量为<code class="fe kz la lb lc b">undefined</code>，则默认为<code class="fe kz la lb lc b">".env.development"</code>。</li><li id="7f1e" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">如果文件不存在或由于某种原因无法访问，将引发错误。</li><li id="8f87" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">基于分析的数据返回格式化的对象。</li></ol><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="ab41" class="my ls iq lc b gy mz na l nb nc">// loadenv.js</span><span id="41c5" class="my ls iq lc b gy nd na l nb nc">const { config } = require('dotenv');</span><span id="818f" class="my ls iq lc b gy nd na l nb nc">module.exports = () =&gt; {<br/>  const env = config({  // (1)<br/>    path: `./.env.${process.env.NODE_ENV || 'development'}`,<br/>  });</span><span id="5691" class="my ls iq lc b gy nd na l nb nc">  if (env.error) {  // (2)<br/>    throw env.error;<br/>  }</span><span id="884c" class="my ls iq lc b gy nd na l nb nc">  return {  // (3)<br/>    server: {<br/>      port: parseInt(env.parsed.SERVER_PORT, 10),<br/>    },<br/>  };<br/>};</span></pre><p id="b1f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个名为<code class="fe kz la lb lc b">index.js</code>的脚本，它导入配置加载器模块并记录调用它时返回的对象。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="f802" class="my ls iq lc b gy mz na l nb nc">// index.js</span><span id="6f04" class="my ls iq lc b gy nd na l nb nc">const Env = require('./loadenv');</span><span id="6272" class="my ls iq lc b gy nd na l nb nc">try {<br/>  const env = Env();<br/>  console.log(env);<br/>} catch(error) {<br/>  console.error(error);<br/>  process.exit(1);<br/>}</span></pre><p id="a9b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们通过在终端窗口中运行以下命令来测试加载器模块，这将根据按照<code class="fe kz la lb lc b">NODE_ENV</code>环境变量定义的部署环境打印出正确的<code class="fe kz la lb lc b">SERVER_PORT</code>值。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="6484" class="my ls iq lc b gy mz na l nb nc">$ NODE_ENV=development node index.js<br/>{ server: { port: 3000 } }<br/>$ NODE_ENV=production node index.js<br/>{ server: { port: 80 } }<br/>$ node index.js<br/>{ server: { port: 3000 } }</span></pre><p id="953a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以轻松地将新变量添加到配置文件中。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="5ce3" class="my ls iq lc b gy mz na l nb nc"># .env.development</span><span id="9569" class="my ls iq lc b gy nd na l nb nc">SERVER_PORT=3000<br/>DATABASE_NAME=project<br/>DATABASE_USER=user<br/>DATABASE_PASSWORD=password</span></pre><p id="36a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在由配置加载器返回的对象内的公共关键字下对它们进行重新分组。</p><pre class="kn ko kp kq gt mu lc mv mw aw mx bi"><span id="7873" class="my ls iq lc b gy mz na l nb nc">// loadenv.js</span><span id="2558" class="my ls iq lc b gy nd na l nb nc">// ...<br/>return {<br/>  server: {<br/>    port: parseInt(env.parsed.SERVER_PORT, 10),<br/>  },<br/>  database: {<br/>    name: env.parsed.DATABASE_NAME,<br/>    user: env.parsed.DATABASE_USER,<br/>    password: env.parsed.DATABASE_PASSWORD,<br/>  },<br/>};</span></pre><h1 id="92f1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">下一步是什么？</h1><p id="30e2" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">👉你喜欢这种内容？请查看本书<a class="ae kl" href="https://learnbackend.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="ky">构建分层微服务</em> </strong> </a>，网址为<a class="ae kl" href="https://learnbackend.dev" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>了解如何使用 Express framework 构建生产就绪的分层认证微服务，从第一行代码到最后一行文档，该服务在开发实践和软件架构方面符合行业标准。</p></div></div>    
</body>
</html>