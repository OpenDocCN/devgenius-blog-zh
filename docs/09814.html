<html>
<head>
<title>Let’s Dance on the “Redis-Floor”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在“红色地板”上跳舞</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-dance-on-the-redis-floor-d93e02828bef?source=collection_archive---------4-----------------------#2022-09-15">https://blog.devgenius.io/lets-dance-on-the-redis-floor-d93e02828bef?source=collection_archive---------4-----------------------#2022-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e487" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好。！在当今世界，一切都是动态的，这意味着数据无处不在，并且在快速增长。为了管理这种快速的步伐，我们必须以同样的速度处理它，这就是“Redis”是我们用数据做自由式快速移动的舞池的地方。</p><p id="3c17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前几天，我在用文档数据库做一些数据工程任务</p><blockquote class="ki kj kk"><p id="3d08" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">何时… </strong></p><p id="463e" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">查理·普斯 pinged 我:</strong></p><p id="77b4" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">这种情况持续多久了？:(</strong></p><p id="2b4c" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">然后……</strong></p><p id="93a2" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">肖恩·蒙德兹回答道:</strong></p><p id="bb56" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">没有什么可以阻挡你回去使用</strong><a class="ae kp" href="https://redis.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Redis</strong></a><strong class="jm io">:)</strong></p></blockquote><p id="9ae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">于是我放了同一首歌，设了高低音，在 Redis 舞池里跳了起来。数据以快节奏狂舞，地板是这样的…</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/7c591bd6bfb5bcbb496919bf2ceeff25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LaQuBfsKDQKxXqC3YZ4MuA.jpeg"/></div></div></figure><p id="c239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，一旦你使用 Redis，上面的例子是非常正确的，但是这些事情是怎么发生的呢？<strong class="jm io">为什么</strong> 𝐑𝐞𝐝𝐢𝐬 <strong class="jm io">那么𝐟𝐚𝐬𝐭？</strong></p><p id="8ea1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在本文中，我们将深入探究解释 Redis 的<strong class="jm io"> Fast </strong> word 的事实。但在重点讨论这一部分之前，我们先请 Redis 介绍一下自己:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lc"><img src="../Images/b7aace763bcbe505bf6bf4a5c347d5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*og0rQ01xv6I7e1LpSbNIVQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae kp" href="https://redis.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lh">官方标志:Redis </strong> </a></figcaption></figure><blockquote class="ki kj kk"><p id="beae" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">雷迪斯:</strong></p><p id="38e5" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">我是一个开源的内存数据结构存储系统，我可以用作数据库、缓存和消息中间件。</p><p id="7147" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">我支持多种类型的数据结构，如字符串、哈希、列表、集合、有序集合或 ZSet 和范围查询、位图、超对数和地理空间索引半径查询。常见的数据结构类型有字符串、列表、集合、散列和 ZSet。</strong></p><p id="9426" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">我内置了复制(replication)、LUA 脚本(LUA scripting)、LRU 驱动事件(LRU 驱逐)、事务(transactions)和不同级别的磁盘持久化(persistence)，并通过 Redis 哨兵和自动分区(Cluster)提供高可用性。</strong></p><p id="7633" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">我还提供了持久化的选项，这些选项允许用户将他们的数据保存到磁盘上进行存储。根据实际情况，可以在某个时间将数据集导出到磁盘(快照)，或者追加到命令日志中(AOF 只追加文件)，我会在执行写命令的时候将执行的写命令复制到硬盘上。也可以关闭持久化，将 me 作为高效的网络数据缓存功能。</p><p id="6a26" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">我不使用表，他的数据库也不会预定义或强制用户关联存储在我这里的不同数据。</strong></p></blockquote><p id="122f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们谈谈它的快速处理，或者试着找出这个问题的答案:为什么𝐑𝐞𝐝𝐢𝐬如此𝐟𝐚𝐬𝐭？</p><p id="b8d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kl">这里我们来关注一下:</em> </strong></p><p id="9e3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据库的工作模式可以分为硬盘数据库和内存数据库。Redis 将数据存储在内存中，读写数据时不受硬盘 I / O 速度的限制，所以速度极快。</p><blockquote class="ki kj kk"><p id="a50c" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><em class="in">所以我们有 3 个部分来报道这个故事:</em></p><p id="f2fb" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">Redis 有多快？</strong></p><p id="c96d" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">详细说明 Redis 业绩高的原因。</strong></p><p id="dd4a" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">影响 Redis 业绩的因素。</strong></p></blockquote><h1 id="5c13" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Redis 有多快:</h1><p id="a1d0" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">要了解 Redis 的发展速度，你需要有一个评估工具。其次，Redis 需要一些平台经验数据来评估 Redis 在数量级上的性能。好在 Redis 提供了这样一个工具，并给出了一些常用硬件平台的体验数据。</p><p id="b2b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一篇长文，核心观点如下:</p><ol class=""><li id="28e1" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">Redis 基准可以用来评估 Redis 的性能。命令行提供了在正常/管道模式和不同压力下评估特定命令性能的功能。</li><li id="9dc4" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">Redis 性能优异。作为键值系统，最大负载水平为 10W / s，set 和 get 耗时水平分别为 10ms 和 5ms。使用管道可以提高 Redis 操作的性能。</li></ol><p id="8938" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果不关心具体数据，可以直接跳转到第二部分了解 Redis 表现优异的原因。</p><h1 id="97d1" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Redis 绩效评估工具:</h1><p id="ff76" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Redis 包括 Redis benchmark 实用程序，可以模拟 n 个客户端同时发送 total queries 的 m 个运行命令(类似 Apache AB 实用程序)。您可以使用 Redis 基准来评估 Redis 的性能。</p><p id="d45c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">支持以下选项:</p><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="7cd4" class="nd lj in mz b gy ne nf l ng nh">Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;]<br/><br/> -H &lt; hostname &gt; server hostname (default 127.0.0.1)</span><span id="1cbe" class="nd lj in mz b gy ni nf l ng nh"> -P &lt; port &gt; server port (default 6379)</span><span id="dee9" class="nd lj in mz b gy ni nf l ng nh"> -S &lt; socket &gt; server socket (covering host and port)</span><span id="38c8" class="nd lj in mz b gy ni nf l ng nh"> -A &lt; password &gt; server authentication key</span><span id="ab20" class="nd lj in mz b gy ni nf l ng nh"> -C &lt; clients &gt; number of clients started (parallelism) (default 50)</span><span id="3070" class="nd lj in mz b gy ni nf l ng nh"> -N &lt; requests &gt; total requests (default 100000)</span><span id="63c8" class="nd lj in mz b gy ni nf l ng nh"> -D &lt; size &gt; get and set request data size (default 2 bytes)</span><span id="1e52" class="nd lj in mz b gy ni nf l ng nh"> --DB number selected by dbnum &lt; DB &gt; (default 0)</span><span id="c94c" class="nd lj in mz b gy ni nf l ng nh"> -K &lt; Boolean &gt; 1 = keep alive 0 = connect (default 1)</span><span id="6ea0" class="nd lj in mz b gy ni nf l ng nh"> -R &lt; keyspacelen &gt; use random key value in set / get / incr and random VA in Sadd</span><span id="6bf2" class="nd lj in mz b gy ni nf l ng nh"> -P &lt; numreq &gt; the number of requests contained in a pipeline. The default value is 1 (pipeline is not used)</span><span id="cb3f" class="nd lj in mz b gy ni nf l ng nh"> -Q quiet mode. Only show QPS value</span><span id="97b2" class="nd lj in mz b gy ni nf l ng nh"> --CSV output in CSV format</span><span id="82e0" class="nd lj in mz b gy ni nf l ng nh"> -L generate loop to execute test permanently</span><span id="162c" class="nd lj in mz b gy ni nf l ng nh"> -T &lt; tests &gt; make the command of test command, and the command list is separated by commas</span><span id="5671" class="nd lj in mz b gy ni nf l ng nh"> -I idle mode, only open n idle connections and wait</span></pre><p id="3e50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开始基准测试之前，您需要有一个正在运行的 Redis 实例。我尝试了一个带有默认参数的例子:</p><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="8044" class="nd lj in mz b gy ne nf l ng nh">D:\data\soft\redis-windows&gt;redis-benchmark.exe<br/>.....<br/>====== SET ======<br/>  100000 requests completed in 0.81 seconds<br/>  50 parallel clients<br/>  3 bytes payload<br/>  keep alive: 1<br/><br/>99.90% &lt;= 1 milliseconds<br/>99.93% &lt;= 2 milliseconds<br/>99.95% &lt;= 78 milliseconds<br/>99.96% &lt;= 79 milliseconds<br/>100.00% &lt;= 79 milliseconds<br/>123609.39 requests per second<br/><br/>====== GET ======<br/>  100000 requests completed in 0.70 seconds<br/>  50 parallel clients<br/>  3 bytes payload<br/>  keep alive: 1<br/><br/>100.00% &lt;= 0 milliseconds<br/>142045.45 requests per second<br/><br/>====== INCR ======<br/>  100000 requests completed in 0.71 seconds<br/>  50 parallel clients<br/>  3 bytes payload<br/>  keep alive: 1<br/><br/>99.95% &lt;= 1 milliseconds<br/>99.95% &lt;= 2 milliseconds<br/>100.00% &lt;= 2 milliseconds<br/>140252.45 requests per second<br/>.....</span></pre><p id="c18f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，set / get / incr 的测试结果被截取。</p><p id="724b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试结果包括测试的环境参数(请求数量、客户端数量、有效负载)和请求时间的 TP 值。</p><blockquote class="ki kj kk"><p id="9b61" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">默认情况下，Redis 基准测试使用 100000 个请求、50 个客户端和 3 个字节的有效负载进行测试。</strong></p><p id="a05f" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">返回的结果显示，set /get / incr 命令在 100000 次请求下的总请求时间小于 0.1s。以 QPS = 10W 为例，计算出的平均时间约为 2ms (1 / (10W / 50))。</strong></p></blockquote><p id="fb9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis 的性能与许多因素有关，这些因素将在第三部分详细介绍。比如客户端的网络状态，是否使用流水线，链接的客户端。为了展示 Redis 的速度有多快，我们使用了 Redis benchmark 在其官网上测试的一组数据。</p><blockquote class="ki kj kk"><p id="7812" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">警告:</em> </strong> <em class="in">请注意，与今天的标准相比，以下大多数基准测试都是几年前使用较旧的硬件获得的。页面应该会更新，但在许多情况下，使用硬件状态，您将会看到两倍的数字。此外，在许多工作负载中，redis 4.0 比 2.6 更快</em></p></blockquote><h2 id="5e6f" class="nd lj in bd lh nj nk dn ln nl nm dp lr jv nn no lv jz np nq lz kd nr ns md nt bi translated">硬件环境和软件配置:</h2><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="d8fd" class="nd lj in mz b gy ne nf l ng nh">The test was done by 50 clients executing 2 million requests at the same time.</span><span id="d7d8" class="nd lj in mz b gy ni nf l ng nh">All tests are run on redis 2.6.14.</span><span id="d56c" class="nd lj in mz b gy ni nf l ng nh">The test was performed using the loopback address (127.0.0.1).</span><span id="5d93" class="nd lj in mz b gy ni nf l ng nh">Perform the test using a million key space.</span><span id="8c77" class="nd lj in mz b gy ni nf l ng nh">Perform tests with and without a pipeline (16 command pipelines).<br/>Intel(R) Xeon(R) CPU E5520 @ 2.27GHz</span></pre><h2 id="f5c6" class="nd lj in bd lh nj nk dn ln nl nm dp lr jv nn no lv jz np nq lz kd nr ns md nt bi translated">Redis 系统负载:</h2><ol class=""><li id="9613" class="mk ml in jm b jn mf jr mg jv nu jz nv kd nw kh mp mq mr ms bi translated"><strong class="jm io"> <em class="kl">无管道测试结果:</em> </strong></li></ol><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="321f" class="nd lj in mz b gy ne nf l ng nh">$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q</span><span id="4d03" class="nd lj in mz b gy ni nf l ng nh">SET: 122556.53 requests per second<br/>GET: 123601.76 requests per second<br/>LPUSH: 136752.14 requests per second<br/>LPOP: 132424.03 requests per second</span></pre><p id="51f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kl"> 2。使用管道测试结果:</em> </strong></p><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="c8a7" class="nd lj in mz b gy ne nf l ng nh">$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q -</span><span id="94d3" class="nd lj in mz b gy ni nf l ng nh">P 16</span><span id="9ffb" class="nd lj in mz b gy ni nf l ng nh">SET: 195503.42 requests per second<br/>GET: 250187.64 requests per second<br/>LPUSH: 230547.55 requests per second<br/>LPOP: 250815.16 requests per second</span></pre><blockquote class="ki kj kk"><p id="28f3" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">从上面可以看出，Redis 作为一个关键值系统，其读写负载约为 10W + QPS。</p><p id="7922" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">使用流水线技术可以显著提高读写性能。</p></blockquote><h2 id="bd75" class="nd lj in bd lh nj nk dn ln nl nm dp lr jv nn no lv jz np nq lz kd nr ns md nt bi translated">耗时(没有管道的测试结果):</h2><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="8127" class="nd lj in mz b gy ne nf l ng nh">$ redis-benchmark -n 100000<br/><br/>====== SET ======<br/>  100007 requests completed in 0.88 seconds<br/>  50 parallel clients<br/>  3 bytes payload<br/>  keep alive: 1<br/><br/>58.50% &lt;= 0 milliseconds<br/>99.17% &lt;= 1 milliseconds<br/>99.58% &lt;= 2 milliseconds<br/>99.85% &lt;= 3 milliseconds<br/>99.90% &lt;= 6 milliseconds<br/>100.00% &lt;= 9 milliseconds<br/>114293.71 requests per second<br/><br/>====== GET ======<br/>  100000 requests completed in 1.23 seconds<br/>  50 parallel clients<br/>  3 bytes payload<br/>  keep alive: 1<br/><br/>43.12% &lt;= 0 milliseconds<br/>96.82% &lt;= 1 milliseconds<br/>98.62% &lt;= 2 milliseconds<br/>100.00% &lt;= 3 milliseconds<br/>81234.77 requests per second<br/>....</span></pre><blockquote class="ki kj kk"><p id="0dcf" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">所有 set 操作在 10ms 内完成，get 操作小于 5ms。</strong></p></blockquote><h1 id="73a1" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Redis 为什么这么快:</h1><p id="1976" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Redis 是一个单线程应用程序，这意味着 Redis 使用单线程来处理客户端的请求。但是不能用单线程的方式使用多核 CPU 性能，但是可以通过在一台机器上打开多个 Redis 实例来提高！</p><h1 id="6301" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">Redis 高性能的原因:</strong></h1><p id="04c5" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">嗯，我们有三个主要的原因让 Redis 快速和愤怒:</p><ol class=""><li id="a0bb" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">在存储器中</li><li id="7ad1" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">IO 多路复用和单线程实施</li><li id="a493" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">优化的低层数据结构</li></ol><p id="58e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以让我们深入看看这三个原因:</p><h1 id="636e" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">内存存储:</strong></h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6d0d8d6e7d9dbc642344cd07920fd838.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*6-Ue0fEaau4cXChg59_G7w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">Redis 中的内存存储说明(Credit: ByteByteGo) </strong></figcaption></figure><p id="9840" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis 很快，因为它是一个内存数据库。内存访问比随机磁盘 I/O 快几个数量级。纯内存访问提供高读写吞吐量和低延迟。代价是数据集不能大于内存。就代码而言，内存中的数据结构也比磁盘上的数据结构更容易实现。这使得代码简单，并且有助于 Redis 坚如磐石的稳定性。</p><h1 id="d389" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">IO 多路复用和单线程实施:</h1><p id="96d1" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Redis 快速的另一个原因有点不直观。它主要是单线程的，这带来了一些问题。</p><p id="33a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么单线程设计会带来高性能？如果它使用线程来利用所有的 CPU 内核，不是会更快吗？</p><p id="e90b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多线程应用程序需要锁或其他同步机制。众所周知，他们很难讲道理。在许多应用程序中，增加的复杂性容易导致错误，并且牺牲了稳定性，因此很难证明性能提升的合理性。对于 Redis，单线程代码路径很容易理解。</p><p id="ecce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单线程代码库如何同时处理成千上万的传入请求和传出响应？线程在单独等待每个请求完成时不会被阻塞吗？</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/041f292a6ae0d7a905180ea675a9d40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*F3m_vyEeTmN0BoZk74I3eQ.png"/></div></figure><p id="b8eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是 I/O 多路复用发挥作用的地方。通过 I/O 多路复用，操作系统允许单个线程同时等待多个套接字连接。传统上，这是通过选择或轮询系统调用来完成的。当有成千上万个连接时，这些系统调用的性能不是很好。在 Linux 上，Epoll 是 I/O 多路复用的一个高性能变体，它在恒定时间内支持成千上万个连接。这种单线程设计的一个缺点是，它不能利用现代硬件中所有可用的 CPU 内核。对于某些工作负载，在一台服务器上运行多个 Redis 实例以利用更多 CPU 内核的情况并不少见。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/017193fe1921827b8f1117a045c031ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*GjDv1lF2n4CF7u7ZtYSeJw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">IO 复用图解&amp;单线程执行(Credit: ByteByteGo) </strong></figcaption></figure><p id="5c9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看 Redis 是如何处理客户端连接的。</p><p id="a294" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，Redis 使用一个反应器设计模式，封装了多个实现(select、epoll、kqueue 等。)来多路复用 IO 以处理来自客户端的请求。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oa"><img src="../Images/d8a85bce9f922236f83ec65ee629381c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3eI5WjhMbkwbc07RH4B_Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">复用反应堆模式示意图</strong></figcaption></figure><p id="0a0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反应器设计模式通常用于实现事件驱动。此外，Redis 封装了不同的库，用于在不同平台上复用 io。流程如下:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ob"><img src="../Images/edf6baf50bc17fd8e21ddd24a0d6ba25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEi1ZZCxQ29J7dH8dIU6wQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">Redis</strong>中复用 I / O 不同库的封装示意图</figcaption></figure><p id="5483" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为 Redis 需要在多个平台上运行，为了最大化执行的效率和性能，会根据不同的编译平台选择不同的 I / O 复用函数作为子模块。</p><p id="0498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis 会优先选择时间复杂度为 O (1)的 I / O 复用函数作为底层实现，包括 Solaris 10 中的 evport，Linux 中的 epoll，Mac OS / FreeBSD 中的 kqueue。这些函数都使用内核的内部结构，可以服务于成千上万的文件描述符。</p><p id="276c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果当前的编译环境不具备上述功能，将选择 select 作为替代。由于它在使用时会扫描所有被监控的描述符，时间复杂度较差 o (n)，同时只能服务 1024 个文件描述符，所以一般不作为第一种方案使用。</p><h1 id="6ec6" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">优化的底层数据结构:</h1><p id="70ba" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Redis 提供了丰富的数据结构和不同场景下的不同实现。</p><p id="f00f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis 是一个关键的价值系统。不同类型的键对应不同的操作，或者操作对应不同的实现。同一个键也会有不同的实现。Redis 对 key 进行操作时，会检查类型，调用不同的实现。</p><p id="76ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决上述问题，Redis 建立了自己类型的系统。该系统的主要功能包括:</p><p id="1b52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redisobject 对象。<br/>基于重对象的类型检查。<br/>基于 redisobject 对象的显式多态函数。<br/>再贴现的分配、共享和销毁机制。</p><pre class="kr ks kt ku gt my mz na nb aw nc bi"><span id="71f2" class="nd lj in mz b gy ne nf l ng nh">/*<br/> *Redis object<br/> */<br/>typedef struct redisObject {<br/><br/>    //Type<br/>    unsigned type:4;<br/><br/>    //Alignment bit<br/>    unsigned notused:2;<br/><br/>    //Coding method<br/>    unsigned encoding:4;<br/><br/>    //LRU time (relative to server.lruclock )<br/>    unsigned lru:22;<br/><br/>    //Reference count<br/>    int refcount;<br/><br/>    //Value to object<br/>    void *ptr;<br/><br/>} robj;</span></pre><blockquote class="ki kj kk"><p id="8658" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">类型、编码和 PTR 是三个最重要的属性。Redis 分别支持 4 种类型和 8 种编码:</strong></p></blockquote><p id="6d96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 redisobject，可以轻松实现特定键的操作过程:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oc"><img src="../Images/cac89fff55d45932f94de1152721163d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7Yn8gQ25Ps3EXNi1tRL9A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">高效低层数据结构的说明(Credit: ByteByteGo) </strong></figcaption></figure><p id="b3fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们提到了 Redis 速度快的第三个原因。由于 Redis 是一个内存数据库，它可以利用几种有效的低级数据结构，而不用担心如何有效地将它们持久化到磁盘上——链表、跳表和哈希表就是一些例子。确实有人试图实现新的 Redis 兼容服务器，以从单个服务器中挤出更多的性能。凭借 Redis 的易用性、坚如磐石的稳定性和性能，我们认为 Redis 仍然提供了市场上最佳的性能和稳定性权衡。</p><blockquote class="ki kj kk"><p id="9860" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">Redis 除了提供丰富高效的数据结构，还提供 hyperloglog、geo index 等高效算法。</strong></p></blockquote><p id="eee3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们可以得出结论，Redis 是一个非常流行的内存数据库。它坚如磐石，易于使用，而且速度很快。根据 Stack Overflow 的年度开发人员调查，这些属性解释了为什么它是最受欢迎的数据库之一</p><p id="dc14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着…</p><p id="901e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">“让我们在 Redis 地板上跳舞”</strong>意思是...</p><p id="0a7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">“为我跳舞，为我跳舞，为我跳舞，哦，哦，哦！!"</strong></p><p id="b773" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道 Redis 快速性能的弦理论(嗯，我们已经探索了 WH 词的所有 10 个维度)，所以<strong class="jm io">“不要忘记尝试</strong><a class="ae kp" href="http://redis.com" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Redis</strong></a><strong class="jm io">”</strong>并继续关注即将到来的文章，我们将有一个<strong class="jm io">架构——乘坐 Redis 的过山车</strong>！！</p><p id="191a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">丁咚:这篇文章是与 Redis 合作的。 </p><h1 id="2c0a" class="li lj in bd lh lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">看到一些很酷的参考:)</h1><ul class=""><li id="101f" class="mk ml in jm b jn mf jr mg jv nu jz nv kd nw kh od mq mr ms bi translated"><a class="ae kp" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank">免费试用 Redis 云</a></li><li id="cb7b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh od mq mr ms bi translated"><a class="ae kp" href="https://redis.info/3Ga9YII" rel="noopener ugc nofollow" target="_blank">观看此视频，了解 Redis 云相对于其他 Redis 提供商的优势</a></li><li id="5895" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh od mq mr ms bi translated"><a class="ae kp" href="https://redis.info/3LC4GqB" rel="noopener ugc nofollow" target="_blank"> Redis 开发者中心——关于 Redis 的工具、指南和教程</a></li><li id="18c2" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh od mq mr ms bi translated"><a class="ae kp" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank"> RedisInsight 桌面图形用户界面</a></li></ul><p id="10c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非常感谢你的支持。再见！！</p></div></div>    
</body>
</html>