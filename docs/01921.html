<html>
<head>
<title>Node.js Tips — Async Functions, Read Files from S3, and Closing Servers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—异步函数、从S3读取文件和关闭服务器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-async-functions-read-files-from-s3-and-closing-servers-56d9ca08aa8f?source=collection_archive---------14-----------------------#2020-07-14">https://blog.devgenius.io/node-js-tips-async-functions-read-files-from-s3-and-closing-servers-56d9ca08aa8f?source=collection_archive---------14-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/47af0251a2eb2df26d2ee3b60769c1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pKZXxHEsKwSaZKvl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@moob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ayla Verschueren </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fdf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="cf33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免在新的Promise()构造函数反模式中使用async/await</h1><p id="d7eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避免在<code class="fe me mf mg mh b">Promise</code>构造函数反模式中使用<code class="fe me mf mg mh b">asyhc</code>和<code class="fe me mf mg mh b">await</code>。</p><p id="c720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="84a0" class="mq lc iq mh b gy mr ms l mt mu">const createPromise = () =&gt; {<br/>  return new Promise(async (resolve, reject) =&gt; {<br/>    const val = await Promise.resolve(100);<br/>    //..<br/>  });<br/>}</span></pre><p id="d503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要在承诺中包含一个<code class="fe me mf mg mh b">async</code>函数，因为我们不应该在<code class="fe me mf mg mh b">Promise</code>构造函数中包含承诺。</p><p id="7288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>函数已经返回承诺，所以我们不需要<code class="fe me mf mg mh b">Promise</code>构造函数将代码转换成承诺。</p><p id="b20e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将<code class="fe me mf mg mh b">async</code>函数从<code class="fe me mf mg mh b">Promise</code>中移除，并原样使用。</p><h1 id="6026" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Socket.io更新所有客户端</h1><p id="a158" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">emit</code>方法用socket.io更新所有客户端。</p><p id="a2b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2e8b" class="mq lc iq mh b gy mr ms l mt mu">socket.emit('message', 'hello');</span></pre><p id="ed0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向所有客户端发出内容为<code class="fe me mf mg mh b">'hello'</code>的<code class="fe me mf mg mh b">message</code>事件。</p><p id="1e98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe me mf mg mh b">io.sockets.emit</code>方法向所有套接字发出。</p><p id="f96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="df95" class="mq lc iq mh b gy mr ms l mt mu">io.sockets.emit('<!-- -->message<!-- -->', 'hello');</span></pre><p id="911d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">broadcast</code>属性来做同样的事情。</p><p id="c771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它向除了发送事件的套接字之外的所有人发送消息:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0d5e" class="mq lc iq mh b gy mr ms l mt mu">socket.broadcast.emit('<!-- -->message<!-- -->', 'hello');</span></pre><h1 id="2c17" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从Node.js中的S3 getObject获得响应</h1><p id="995e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">getObject</code>方法来获得我们想要的项目，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7993" class="mq lc iq mh b gy mr ms l mt mu">const aws = require('aws-sdk');<br/>const s3 = new aws.S3();</span><span id="b3f1" class="mq lc iq mh b gy mv ms l mt mu">const getParams = {<br/>  Bucket: 'abc',<br/>  Key: 'abc.txt'<br/>}</span><span id="44a8" class="mq lc iq mh b gy mv ms l mt mu">s3.getObject(getParams, (err, data) =&gt; { <br/>  if (err) {<br/>    return err;<br/>  }</span><span id="a435" class="mq lc iq mh b gy mv ms l mt mu">  const objectData = data.Body.toString('utf-8');<br/>});</span></pre><p id="4723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">aws.S3</code>构造函数来创建一个新的客户端。</p><p id="5deb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们设置设置桶和键的参数，也就是文件路径。</p><p id="5679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用<code class="fe me mf mg mh b">getObject</code>来获取桶中给定路径的文件。</p><p id="1275" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">err</code>是错误对象。</p><p id="d11d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">data</code>是文件的内容。</p><p id="99a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">toString</code>和正确的编码将它转换成一个字符串。</p><h1 id="8c2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正确关闭Express服务器</h1><p id="ae09" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">http</code>服务器实例上调用<code class="fe me mf mg mh b">close</code>，而不是<code class="fe me mf mg mh b">app</code>实例。</p><p id="1f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3262" class="mq lc iq mh b gy mr ms l mt mu">app.get('/foo', (req, res) =&gt; {<br/>  res.redirect('/');<br/>  setTimeout(() =&gt; {<br/>    server.close();<br/>  }, 3000)<br/>});</span><span id="25b0" class="mq lc iq mh b gy mv ms l mt mu">const server = app.listen(3000);</span></pre><p id="1970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">server</code>上调用<code class="fe me mf mg mh b">close</code>，这是<code class="fe me mf mg mh b">http</code>服务器实例。</p><p id="0f36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.listen</code>返回<code class="fe me mf mg mh b">http</code>服务器实例。</p><h1 id="5a50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js调用JSON API</h1><p id="445d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">http</code>模块的<code class="fe me mf mg mh b">get</code>方法向服务器发出GET请求。</p><p id="561d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2029" class="mq lc iq mh b gy mr ms l mt mu">const url = 'https://api.agify.io/?name=michael';</span><span id="a1c8" class="mq lc iq mh b gy mv ms l mt mu">http.get(url, (res) =&gt; {<br/>  let body = '';<br/>  res.on('data', (chunk) =&gt; {<br/>    body += chunk;<br/>  });</span><span id="44f9" class="mq lc iq mh b gy mv ms l mt mu">  res.on('end', () =&gt; {<br/>    const response = JSON.parse(body);<br/>    console.log(response.name);<br/>  });<br/>})<br/>.on('error', (e) =&gt; {<br/>  console.log(e);<br/>});</span></pre><p id="05ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过传入回调来调用<code class="fe me mf mg mh b">get</code>。</p><p id="46c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调监听获取数据的<code class="fe me mf mg mh b">data</code>事件。</p><p id="c1a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当流发送完数据后，我们监听<code class="fe me mf mg mh b">end</code>事件来解析JSON。</p><p id="0e76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">end</code>回调中，我们用<code class="fe me mf mg mh b">JSON.parse</code>解析JSON。</p><p id="ead4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还监听<code class="fe me mf mg mh b">error</code>事件来记录任何可能存在的错误。</p><h1 id="6bca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为MongoDB中填充的文档选择字段</h1><p id="ab8d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">populate</code>方法来填充我们想要的字段并返回它。</p><p id="5249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7626" class="mq lc iq mh b gy mr ms l mt mu">Model<br/>.findOne({ _id: '...' })<br/>.populate('age', 'name')</span></pre><p id="9147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过<code class="fe me mf mg mh b">_id</code>获取项目，填充<code class="fe me mf mg mh b">age</code>并返回<code class="fe me mf mg mh b">name</code>。</p><h1 id="b5a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查函数是否是异步的</h1><p id="58cb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">Symbol.toStringTag</code>属性来检查一个函数是否是异步的。</p><p id="08ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6cb9" class="mq lc iq mh b gy mr ms l mt mu">asyncFn[Symbol.toStringTag] === 'AsyncFunction'</span></pre><p id="9dec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以检查它是否是带有<code class="fe me mf mg mh b">instanceof</code>的<code class="fe me mf mg mh b">AsyncFunction</code>的实例。</p><p id="abf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="474d" class="mq lc iq mh b gy mr ms l mt mu">const AsyncFunction = (async () =&gt; {}).constructor;<br/>const isAsyncFunc = asyncFn instanceof AsyncFunction;</span></pre><p id="73d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获得了带有<code class="fe me mf mg mh b">constructor</code>属性的异步函数的构造函数。</p><p id="13d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">instanceof</code>操作符进行检查。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e5ce69a1838755239183c5233daa720f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SH5lEj97s8wZgCRy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">罗伯特·格拉姆纳在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="fc1d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ad59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该将异步函数放在<code class="fe me mf mg mh b">Promise</code>构造函数中。</p><p id="67a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">getObject</code>方法从S3桶中读取一个文件。</p><p id="d85f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用<code class="fe me mf mg mh b">http</code>模块发出HTTP请求。</p><p id="62a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在<code class="fe me mf mg mh b">app.listen</code>返回的<code class="fe me mf mg mh b">http</code>服务器实例上调用<code class="fe me mf mg mh b">close</code>。</p><p id="6221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以检查一个函数是否是异步的。</p></div></div>    
</body>
</html>