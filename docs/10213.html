<html>
<head>
<title>What makes Kafka so performant?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让卡夫卡如此富有表演性？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-makes-kafka-so-performant-df5dbecb7f3a?source=collection_archive---------0-----------------------#2022-10-16">https://blog.devgenius.io/what-makes-kafka-so-performant-df5dbecb7f3a?source=collection_archive---------0-----------------------#2022-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/bc87f30861432fc1d7a8644ed31f25b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6BHqzQOgmz5O23OOOzFig.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">由弗洛里安·施梅兹在<a class="ae ja" href="https://unsplash.com/s/photos/podium?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="8e32" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使 Kafka 实现高吞吐量和低延迟的设计选择</p><p id="69ce" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我之前的博客中，我写了卡夫卡是什么。在这篇博客中，我们将介绍使 Kafka 以相当低的延迟提供高吞吐量的设计选择。</p><blockquote class="ky"><p id="8ba1" class="kz la jd bd lb lc ld le lf lg lh kx dk translated">尽管 Kafka 将数据存储在磁盘上，但由于 1。顺序输入输出 2。页面缓存 3。内存映射 4。零拷贝数据传输。</p></blockquote><h2 id="0fa1" class="li lj jd bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">顺序输入输出</h2><blockquote class="mb mc md"><p id="74b4" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">磁盘中的顺序访问比内存中的随机访问快。</p></blockquote><p id="0361" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Kafka 利用了上述事实，并使用一个<strong class="kc je">只附加日志</strong>作为其主要数据结构。它将新数据添加到文件的末尾，从而使写入顺序进行。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/f06c881d1bd6c6c6c4fbf1998a4fd78f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxGdTycFYot3VzE7t5yedw.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">顺序访问与随机访问</figcaption></figure><h2 id="0567" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">利用 Linux 页面缓存</h2><blockquote class="mb mc md"><p id="5504" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">当进程对文件执行读/写操作时，页面缓存用于缓存文件系统上的文件数据。</p></blockquote><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/609011a26dcb3f3253d4fe6cbc76e233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*u7g42pxAYnHpnC-jAXpNgQ.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">页面缓存</figcaption></figure><p id="32b0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">卡夫卡利用了上述事实。卡夫卡的数据<strong class="kc je">不是实时写入硬盘的。</strong>当代理接收数据时，它首先将数据写入页面缓存，然后异步地将数据刷新到磁盘。写入页面缓存具有以下优势:</p><ul class=""><li id="dc8f" class="mt mu jd kc b kd ke kh ki kl mv kp mw kt mx kx my mz na nb bi translated">I/O 调度程序将连续的小逻辑写入批量处理成较大的物理写入，从而提高吞吐量</li><li id="1426" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">I/O 调度程序尝试对写入进行重新排序，以最大限度地减少磁头的移动，从而提高吞吐量</li><li id="27e0" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">它自动使用机器上所有的空闲内存(非 JVM 内存)。</li><li id="74b3" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">如果消耗率和生产率相当，数据甚至不需要通过物理磁盘进行交换，可以直接通过页面缓存读取。</li></ul><h2 id="7d7b" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">零拷贝数据传输</h2><p id="4471" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">有两种方法可以实现与 Kafka 相关的零拷贝数据传输。</p><blockquote class="mb mc md"><p id="b4da" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">发送文件+ DMA <br/> mmap +写入</p></blockquote><p id="ff55" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于 Kafka 在其生命周期中保持数据的相同(二进制)格式，因此它不需要将数据加载到应用程序缓冲区，而是直接将数据从页面缓存复制到 NIC 缓冲区。Linux 的系统调用减少了字节复制(跨内核和用户空间)和上下文切换，从而加快了进程。该副本使用 DMA(直接内存访问),这意味着不涉及 CPU，这使得处理方式更加高效(将时间缩短了约 60 %)。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d8f01a845a4f9ab579e440e09c26bca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*NPx4DqMFFx4o6t3ZQCPRoQ.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">零拷贝—绿色箭头表示 DMA 传输</figcaption></figure><blockquote class="mb mc md"><p id="3766" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">内存映射文件—内存上的操作反映在磁盘文件中。</p></blockquote><p id="c8d9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Mmap 将内核中的读缓冲区映射到用户空间中的用户缓冲区。这个过程消除了将数据从内核复制到用户缓冲区的需要。Mmap 改善了大文件的 I/O。Kafka 使用内存映射文件作为索引和时间索引。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/8e32801c2e84c9e44d7470c6df883d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nogqr-JY2z6wAvE3.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">内存映射文件</figcaption></figure><p id="8069" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="me">注意:当启用 SSL 时，零拷贝优化会丢失，因为代理需要解密和加密数据。</em></p><h2 id="326f" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">定量</h2><p id="047b" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">Kafka 的客户和经纪人在通过网络发送记录之前，会批量积累多条记录，既有读的也有写的。记录的批处理分摊了网络往返的开销，使用了更大的数据包并提高了带宽效率。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/67a88fc8550a573be6dddedabe46655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_dRSTEfkjJ52uJj-XTtYw.png"/></div></div></figure><h2 id="b5bb" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">压缩</h2><p id="806b" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">生产者将数据压缩后发送给代理，以降低网络传输的成本。目前，支持的压缩算法包括 Snappy、Gzip 和 LZ4。作为一种优化工具，数据压缩通常与批处理结合使用。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/4a5f5880cc23cd2a785718ff20a2c741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnAfA3jkXAbUIcdfFdM53g.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">发送到代理之前的生产者批处理和压缩</figcaption></figure><h2 id="3821" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">压紧</h2><p id="1ecf" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">日志压缩确保 Kafka 将只保留单个主题分区的数据日志中每个消息键的最新已知值。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/cb699806dea0a898e48dc1471ce7f8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*tDbhO-NIaw-K4ZoithCbqw.png"/></div></figure><h2 id="13c1" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">基于主题划分的并行性</h2><p id="4c02" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">每个分区都有一个专门的领导者，因此任何重要的主题(有多个分区)都可以利用整个代理集群进行读写。消费者还可以消费来自驻留在任何代理中的任何分区的消息，从而有效地使用整个集群。我们甚至可以将同一节点上的不同分区配置为驻留在不同的磁盘上。这样，我们可以利用多个磁盘的并行处理。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d6d66a787454bb5795650526ef3c43dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*DxcBJxaT6decY05g.jpg"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><em class="nw">图片来源:</em> <a class="ae ja" href="https://www.tutorialspoint.com/apache_kafka/images/fundamentals.jpg" rel="noopener ugc nofollow" target="_blank"> <em class="nw">教程-点</em> </a></figcaption></figure><h2 id="8780" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated">代理上没有序列化/反序列化</h2><p id="fb1c" class="pw-post-body-paragraph ka kb jd kc b kd nh kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ig bi translated">在记录到达服务器/代理之前，大量的工作是在客户端执行的。这包括在累加器中暂存记录、散列记录键以获得正确的分区索引、对记录进行校验和以及压缩记录批次。客户端知道集群元数据，并定期刷新该元数据，以跟上代理拓扑的任何变化。这让客户端做出低级转发决定；生产者客户机将把写操作直接转发给分区主机，而不是盲目地把记录发送给集群，并依赖集群把它转发给适当的代理节点。类似地，消费者客户端在获取记录时能够做出明智的决策，在发出读取查询时可能会使用地理位置更靠近客户端的副本。</p><h2 id="b2f3" class="li lj jd bd lk ll mn dn ln lo mo dp lq kl mp ls lt kp mq lv lw kt mr ly lz ma bi translated"><strong class="ak">优化总结</strong></h2><ul class=""><li id="9bf7" class="mt mu jd kc b kd nh kh ni kl nx kp ny kt nz kx my mz na nb bi translated">顺序读写，充分利用商用磁盘</li><li id="f6ec" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">数据传输的零拷贝技术</li><li id="c995" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">索引和时间索引文件的 Mmap 文件映射</li><li id="6e91" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">批量生产、散装压缩</li><li id="ded8" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">缓冲写操作</li><li id="cf95" class="mt mu jd kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">利用代理硬件的分区级并行性</li></ul><p id="aa27" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这是有帮助的！！</p></div></div>    
</body>
</html>