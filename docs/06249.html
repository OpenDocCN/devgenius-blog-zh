<html>
<head>
<title>An epic tale: comparing JDBC and R2DBC in a real-world scenario (Part 2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">史诗般的故事:现实世界中 JDBC 和 R2DBC 的比较(下)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-part-2-2-d908df49651c?source=collection_archive---------2-----------------------#2021-12-25">https://blog.devgenius.io/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-part-2-2-d908df49651c?source=collection_archive---------2-----------------------#2021-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e849" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">整个探索围绕着一个简单但难以回答的问题:“使用 R2DBC 有意义吗？”</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/644bed3c0b10e5420a975068bf67fc26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xdHoyT8Jh5N-p5uy"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@gcvphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gowrisha CV </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="823f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文的第一部分中，我通过测量 GET 请求不同场景下的总吞吐量，展示了一个<strong class="ky ir"> spring boot JDBC </strong>阻塞应用程序和一个<strong class="ky ir"> spring boot R2DBC </strong>反应应用程序的不同性能。</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-a536db512834"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">史诗般的故事:现实世界中 JDBC 和 R2DBC 的比较</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">整个探索围绕着一个简单但难以回答的问题:“使用 R2DBC 有意义吗？”</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">blog.devgenius.io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="9342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我得到的结果清楚地表明，R2DBC 仅在特殊情况下比 JDBC 快:在单次调用中需要从数据库中检索超过 6k 行，并且超过 100 个并发用户到达端点。</p><p id="b9dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在本文中，我将通过测量两个应用程序的性能来继续分析 HTTP-Bombing 3 端点:</strong></p><ol class=""><li id="7479" class="mk ml iq ky b kz la lc ld lf mm lj mn ln mo lr mp mq mr ms bi translated"><strong class="ky ir">获取/书籍</strong> →从数据库中获取越来越多的项目(书籍)</li><li id="b053" class="mk ml iq ky b kz mt lc mu lf mv lj mw ln mx lr mp mq mr ms bi translated"><strong class="ky ir"> POST /books → </strong>在 books 数据库表上创建一个新行</li><li id="972d" class="mk ml iq ky b kz mt lc mu lf mv lj mw ln mx lr mp mq mr ms bi translated"><strong class="ky ir">发布/订单</strong> →创建一个新订单，该订单链接一本书和一个用户</li></ol><p id="089f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库本身是一个 POSTGRES 容器映像，它通过将一个 shell 脚本(<strong class="ky ir"> init-db.sh </strong>)复制到一个特定的文件夹来初始化，如下面的 Dockerfile 片段所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6934" class="nd ne iq mz b gy nf ng l nh ni">FROM postgres<br/>COPY init-db.sh /docker-entrypoint-initdb.d/init-db.sh<br/>RUN sed -i -e 's/\r$//' /docker-entrypoint-initdb.d/init-db.sh</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/38885e7559079e4f1a8371b69e60cc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*cZ17QC-maPogHvdP.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">数据库库模式</figcaption></figure><p id="6164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这两个应用程序，我试图实现三个端点，使它们尽可能相似。举例来说，在下面的片段中给出了第一个端点。如您所见，唯一真正的区别在于编程风格。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从 JDBC 和 R2DBC 获取所有行</figcaption></figure><p id="8ee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与第一篇文章一样，负载测试是在运行一个<strong class="ky ir">临时 K6 容器</strong>的情况下执行的，通过指定不同的 ENV 参数来改变不同的执行:用于在 JDBC 或 R2DBC 应用程序之间切换的“<strong class="ky ir">类型</strong>，以及通过端点循环的并发虚拟用户的数量“<strong class="ky ir">用户</strong>”。下面的代码片段展示了使用的主要测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在 docker 容器中运行这个测试，我需要一个 docker-compose 服务，配置如下:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b163" class="nd ne iq mz b gy nf ng l nh ni">k6:<br/>  container_name: k6<br/>  image: loadimpact/k6:latest<br/>  ports:<br/>    - "6565:6565"<br/>  environment:<br/>    - K6_OUT=influxdb=http://influxdb:8086/k6<br/>  volumes:<br/>    - ./js:/k6-scripts</span></pre><p id="493a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令运行:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fb84" class="nd ne iq mz b gy nf ng l nh ni">docker-compose run --rm <br/>  k6 run /k6-scripts/load-test.js <br/>  -e TYPE=jdbc|r2dbc -e USERS=10|20... </span></pre><p id="e604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>容器将在<a class="ae kv" href="https://www.influxdata.com/" rel="noopener ugc nofollow" target="_blank"> InfluxDB </a>上写入结果，该结果用作<a class="ae kv" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>的数据源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/54004235fdec2f6789dd0f04093d879a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*6OwyLQzES0Xp5kkwwPdgaA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">简化的负载测试架构。</figcaption></figure><p id="7bda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定从 NGINX 传递，而不是直接调用两个 spring boot 应用程序暴露的端口，以便能够添加容器的副本，并依赖于<a class="ae kv" href="https://docs.docker.com/v17.09/engine/userguide/networking/configure-dns/" rel="noopener ugc nofollow" target="_blank"> Docker 的嵌入式 DNS 服务器</a>，该服务器将使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Round-robin_DNS" rel="noopener ugc nofollow" target="_blank">循环</a>实现来基于服务名称解析 DNS 请求，并将它们分发到各个 Docker 容器副本。</p><p id="e83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我必须配置 NGINX，使其不成为瓶颈，并且能够处理大量的并发请求，如下面的代码片段所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Nginx 配置使它能够处理大量并发 HTTP 请求！</figcaption></figure><p id="2010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文末尾链接的 Github 库提供了所用实现的其他细节，以及如何运行测试的详细说明。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="dd42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们开始评估性能</strong>:只有一个分配了 2 个 CPU 和最大 2GB 内存的容器，考虑两个应用程序的吞吐量。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="da68" class="nd ne iq mz b gy nf ng l nh ni">- Concurrency: 1000 / 750 / 250 / 100 / 10<br/>- Containers: 1<br/>- Resources:<br/>    - CPU: 2<br/>    - RAM: 2 gb<br/>    - POOL size: 20<br/>    <em class="nu"><br/></em>- R2DBC: 5178 / 5210 / 4709 / 5184 / 5167<br/>- JDBC:  6099 / 6271 / 5631 / 5617 / 6648</span></pre><p id="8a90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在低并发的情况下，JDBC 阻塞驱动程序的性能要好得多(用第二个斜率表示),这也是意料之中的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/7f150be40cc290c138d93ae5393eddd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uxpPwCVXzyAeX5saegbcQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">每秒请求数 R2DBC(左)JDBC(右)</figcaption></figure><p id="4c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将并发用户增加到 1000 人，性能比较仍然非常相似，JDBC 总是领先。</p><p id="9d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，考虑另一个场景，其中我们将使用的 CPU 减少到 1，并增加更多的并发性。奇怪的事情发生了。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5add" class="nd ne iq mz b gy nf ng l nh ni">- Concurrency: 1000 / 1500<br/>- Containers: 1<br/>- Resources:<br/>  - CPU: 1<br/>  - RAM: 1 gb<br/>  - POOL size: 20</span><span id="f566" class="nd ne iq mz b gy nw ng l nh ni">- R2DBC: 2724 / 4557<br/>- JDBC:  2622 / 4104</span></pre><p id="cf16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 JDBC 的情况，从下图可以看到有 1000 个请求，由于请求超时(60 秒)，我们开始遇到一些错误。这些错误只占完成的请求的 2%。我本可以将超时设置得更长，但是我认为将一个简单的 web 请求的 60 秒视为错误是正确的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/875d8278f7d901fbe0074f87431a988c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PNzHwpX0utAgX9CNUaTDg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Grafana 仪表板显示 1K 虚拟用户同时点击 3 个 JDBC 端点的性能。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/860c7e4f2e02d68f08b4d5faec824fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*eBqEPHCSFffngF2lcO0Mfg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">2% JDBC 请求达到 60 秒限制，导致错误</figcaption></figure><p id="0ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，对于 R2DBC 的情况，我们最终得到了稍微好一点的结果，具有相同的错误百分比(2%)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/ac05d6f181887177fd174380baf6bbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9dOv5uDGcbdpf1EO6PDyQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Grafana 仪表板显示 1K 虚拟用户同时点击 3 个 R2DBC 端点的性能。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/76fb89b221865f1e8961c1d95a212528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*t1mSDUpiKnwX8D0sCm8vHw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">2%的 2DBC 请求达到了 60 秒的限制，导致了错误</figcaption></figure><p id="7421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，对于 1500 个并发用户，我们可以看到高并发真正意味着什么。正如您在下图中看到的，在 JDBC 的情况下，我们有超过 31%的请求达到 60 秒(从而导致错误)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/ec99225e34e9cbc409315a780691621d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfXSYU93hWmhMvUnNMTiCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在 1500 个并发用户的情况下，每秒的错误和请求数达到 3 个 JDBC 端点。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1f2d00f13bed5cefe0c95bf3d547f3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*yn28V4OiC_SRbZ6TVPsztQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">31%的 JDBC 请求达到了 60 秒的限制，导致了错误。</figcaption></figure><p id="c46b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，在 R2DBC 不阻止实现的情况下，只有 11%的请求达到了 60 秒的限制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/4e0521ff6c59d8d4af3ddab2372de1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkoE5K7xqCZS7jsgwl4gig.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在 1500 个并发用户的情况下，命中 3 个 R2DBC 端点的每秒错误数和请求数。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d443cbd16b71f0be7e12b70e4bc3a146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*U2Vuo0iaTQhVEiFvIyFRkw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">11%的 R2DBC 请求达到了 60 秒的限制，导致了错误。</figcaption></figure><p id="b944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这是否意味着 R2DBC 在高并发时确实表现更好？不，这只是意味着 R2DBC 在这种特殊和非常具体的情况下更好。</strong></p><p id="6de5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们将 CPU 增加到 3，并且仍然考虑 1500 个并发用户:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="629f" class="nd ne iq mz b gy nf ng l nh ni">- Concurrency: 1500<br/>- Containers: 1<br/>- Resources:<br/>  - CPU: 3<br/>  - RAM: 2 gb<br/>  - POOL size: 20</span><span id="5d06" class="nd ne iq mz b gy nw ng l nh ni">- R2DBC: 5437 complete and 7% errors<br/>- JDBC:  7664 complete and 2% errors</span></pre><p id="8cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阻塞堆栈似乎又快了。</p><p id="a377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要记住，测试的 3 个终点同样是独特的，非常具体。现在我们来了:这篇文章的真正目的只是给你一个真正的机会(只修改几行代码)来测试你自己的特殊场景，并独自面对 JDBC 和 R2DBC。</p><p id="15b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">您可以定制 spring boot 容器的副本数量、数据库池的大小、使用的 CPU 数量、到达端点的并发用户数量以及端点本身。</strong>尽可能具体地模仿您认为您的应用程序流会是什么样子(您已经知道这是:D 最复杂的部分),阻塞和解除阻塞堆栈之间的选择对您来说很简单。</p><div class="ls lt gp gr lu lv"><a href="https://github.com/GaetanoPiazzolla/spring-boot-jdbc-vs-r2dbc" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">GitHub-GaetanoPiazzolla/spring-boot-JDBC-vs-r2dbc</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">这个库包含的代码能够测试不同的性能之间的弹簧引导阻塞…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="of l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="3b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Post Scriptum: </strong>在选择时，请考虑非阻塞代码很难看，而且读起来很复杂(IMHO)。例如，在下面的代码片段中，可以看到在 JDBC 和 R2DBC 堆栈中实现的相同应用程序逻辑之间的差异。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">额外订单示例，JDBC vs R2DBC</figcaption></figure><p id="1c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过嘿，这只是我个人的看法。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="913c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢您的阅读。</p></div></div>    
</body>
</html>