<html>
<head>
<title>Unit Testing Memory Leaks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试内存泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unit-testing-memory-leaks-265f8d9777fb?source=collection_archive---------3-----------------------#2021-05-29">https://blog.devgenius.io/unit-testing-memory-leaks-265f8d9777fb?source=collection_archive---------3-----------------------#2021-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e83b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">通过避免保留周期来提高性能</h2><div class=""/><div class=""><h2 id="f3dc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在一瞬间找到这个难以捉摸的浪费时间的人</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1dc505f0f83caa5cf6bb2e3e2334fd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de1D5qwRqJlcpDkj_iM4QQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">呃，漏码</figcaption></figure><p id="8024" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在Swift中，通过ARC我们可以非常高效地处理内存。基本上，引用对象(比如类)记录了它们被引用的次数。当计数达到0时，该项被标记为释放，并在系统需要空间时从内存中移除。</p><p id="c4d9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是，如果我们不小心，我们可能会遇到这样的情况，因为我们创建了一个保留循环，所以内存空间从来没有被标记为释放。不幸的是，对我们来说，这些可能是相当棘手的跟踪。</p><p id="c652" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本教程中，您将实现一个单元测试，该单元测试可以测试任何对象，以查看它是否被正确发布。</p><p id="5177" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有关内存管理、保留周期以及如何避免它们的更多信息，我写了这篇文章:</p><div class="ma mb gp gr mc md"><a rel="noopener  ugc nofollow" target="_blank" href="/retain-cycles-and-weak-vs-unowned-643c676821fc"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ja gy z fp mi fr fs mj fu fw iz bi translated">保留周期和弱对无主</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">什么是保留周期？我为什么要用弱？我什么时候使用无主？</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">blog.devgenius.io</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ky md"/></div></div></a></div><h1 id="5bb0" class="ms mt iq bd mu mv mw mx my mz na nb nc kf nd kg ne ki nf kj ng kl nh km ni nj bi translated">公共保留周期</h1><p id="8879" class="pw-post-body-paragraph le lf iq lg b lh nk ka lj lk nl kd lm ln nm lp lq lr nn lt lu lv no lx ly lz ij bi translated">偷偷摸摸的保留周期最常见的地方之一是当我们在闭包中捕获<code class="fe np nq nr ns b">self</code>时。本质上，<code class="fe np nq nr ns b">self</code>指向闭包，那么如果闭包调用<code class="fe np nq nr ns b">self</code>，闭包就有对<code class="fe np nq nr ns b">self</code>的引用。因为他们互相指着对方，所以很有可能两个人都不会被释放。</p><p id="11a3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">继续开始一个新项目，并选中包含单元测试的复选框。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/07de09e241b71be79c9d202ee0aa11b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ykiVNfJbHPte9lpTfvy9A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">记得检查包含测试</figcaption></figure><p id="fbe2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来，实现下面的类。您可以使用默认的ViewController或创建自己的view controller。在<code class="fe np nq nr ns b">ViewController</code>中，我们简单地使用闭包来增加一个整数。</p><p id="c98f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">确保实现所需的init，而不是使用默认的<code class="fe np nq nr ns b">fatalError</code>，否则你的应用会崩溃。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="75f7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你自己打出来，并且在<code class="fe np nq nr ns b">numberOfTimes</code>前没有包含<code class="fe np nq nr ns b">self</code>，编译器会给出一个关于捕获语义的错误。我认为编译器让你在这里显式引用<code class="fe np nq nr ns b">self</code>来提醒你，你可能正在创建一个保留循环。在这里打破保持循环是微不足道的，我们将在本文的后面讨论这一点。现在，我们只是有一个内存泄漏💧</p><h1 id="be6e" class="ms mt iq bd mu mv mw mx my mz na nb nc kf nd kg ne ki nf kj ng kl nh km ni nj bi translated">让我们直入主题，证明我们有一个保留周期</h1><p id="17e1" class="pw-post-body-paragraph le lf iq lg b lh nk ka lj lk nl kd lm ln nm lp lq lr nn lt lu lv no lx ly lz ij bi translated">继续打开<code class="fe np nq nr ns b">YourProjectNameTests.swift</code>，你会看到一堆样板代码。去掉所有这些，创建一个名为<code class="fe np nq nr ns b">testRetainCycle</code>的函数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/85ac881402d472e11442e4d4cc891f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThS-SqNonHR6_lHr2zZv0g.png"/></div></div></figure><p id="cea4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过创建ViewController的实例，运行<code class="fe np nq nr ns b">countIt()</code>，并断言<code class="fe np nq nr ns b">numberOfTimes</code>为1，来测试您的方法是否有效。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="60c7" class="nx mt iq bd mu ny nz dn my oa ob dp nc ln oc od ne lr oe of ng lv og oh ni iw bi translated">通过点击方法签名旁边的菱形来运行测试，测试应该会通过</h2><p id="1d40" class="pw-post-body-paragraph le lf iq lg b lh nk ka lj lk nl kd lm ln nm lp lq lr nn lt lu lv no lx ly lz ij bi translated">现在你需要做的是证明你有一个保持周期，在测试运行后检查并查看<code class="fe np nq nr ns b">vc</code>是否为零。它应该为零，因为它只在测试范围内有效。如果不为零，则存在保留周期。</p><p id="818d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">单元测试有特定于<code class="fe np nq nr ns b">XCTestCase</code>类的<code class="fe np nq nr ns b">setup</code>和<code class="fe np nq nr ns b">teardown</code>方法。这些方法在每次测试之前和之后都会被调用。要检查保留周期/内存泄漏，只需检查测试运行后实例是否被释放。</p><p id="d296" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">即使这个类有一个拆卸方法，也要在你的<code class="fe np nq nr ns b">testRetainCycle</code>方法中实现<code class="fe np nq nr ns b">addTearDownBlock</code>。这是一个特殊的方法，只在调用后调用本地函数，而不是为每个测试函数调用。当我们不需要在我们测试的所有东西上运行时，这是很有用的。在<code class="fe np nq nr ns b">addTearDownBlock</code>闭包中，简单断言<code class="fe np nq nr ns b">vc</code>就是<code class="fe np nq nr ns b">nil</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5aad" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">运行测试，它失败了！就像任何其他闭包一样，<code class="fe np nq nr ns b">self</code>通过局部作用域拥有/指向<code class="fe np nq nr ns b">addTeardownBlock</code>。然后检查闭包中的<code class="fe np nq nr ns b">vc</code>是否为零，vc是在闭包之前由局部作用域创建/指向的，所以现在闭包和vc通过局部作用域相互指向对方。这是一个保留周期…</p><h1 id="23d7" class="ms mt iq bd mu mv mw mx my mz na nb nc kf nd kg ne ki nf kj ng kl nh km ni nj bi translated">打破循环</h1><p id="67f0" class="pw-post-body-paragraph le lf iq lg b lh nk ka lj lk nl kd lm ln nm lp lq lr nn lt lu lv no lx ly lz ij bi translated">我之前说过，打破循环是微不足道的，我没有撒谎。闭包带有一个捕获列表。在捕获列表中，我们声明了想要在闭包中使用的外部对象。我们可以给属性添加修饰符，所以我们可以像这样<code class="fe np nq nr ns b">addTearDownBlock { [weak vc] in</code>我们的<code class="fe np nq nr ns b">vc</code>属性。由于引用计数不计入弱属性，我们打破了保留循环！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6caa" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是如果你运行单元测试，它仍然失败。这是为什么呢？</p><p id="140d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">嗯，我们只解决了一个保留周期——我们刚刚创建的单元测试中的那个。我们还需要回到<code class="fe np nq nr ns b">countIt</code>方法中的<code class="fe np nq nr ns b">ViewController</code>和<code class="fe np nq nr ns b">weakify</code> <code class="fe np nq nr ns b">self</code>。当你这样做的时候，你应该得到一些编译错误。这是因为<code class="fe np nq nr ns b">self</code>现在是可选的。为了避免这种情况，你可以让<code class="fe np nq nr ns b">self</code>成为无主，但是弱是更安全的选择——无主就像强制解包。</p><p id="355a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以随意打开<code class="fe np nq nr ns b">self</code>，但是如果您强制打开，您也可以使用<code class="fe np nq nr ns b">unowned</code>。我选择了可选链接。也就是说，在这个特殊的例子中，self拥有闭包，不涉及其他类，所以<em class="oi">我认为</em>使用unowned是安全的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/6f5676a024e841d05c50298d96db0996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbJ3UrW1P7MkDkxyadcLEg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">展开弱变量，它们是可选的！</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">你刚刚把[软弱的自己]加入了你的捕获列表，打破了保留循环。</figcaption></figure><p id="bcfe" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，如果您运行您的单元测试，您将看到保留循环被打破。既然您已经知道在闭包中创建(和打破)保持循环是多么容易，那么希望您可以开始测试捕获<code class="fe np nq nr ns b">self</code>的闭包。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/008f8b1c2d744dbb723352b29e6b5a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*FiBN7Gv0_aa9nr3YGYVcgg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/c181832bdf41b11b34b6a4a48597031b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QoeWKeOpO1EFtmgN.png"/></div></div></figure><h2 id="da44" class="nx mt iq bd mu ny nz dn my oa ob dp nc ln oc od ne lr oe of ng lv og oh ni iw bi translated">使其可重复使用</h2><p id="9bb4" class="pw-post-body-paragraph le lf iq lg b lh nk ka lj lk nl kd lm ln nm lp lq lr nn lt lu lv no lx ly lz ij bi translated">这对于一次性测试来说很好，但是如果您有一堆引用对象，并且您想确保在代码的其他地方没有保留循环，该怎么办呢？嗯，由于本地<code class="fe np nq nr ns b">addTeardownBlock</code>和<code class="fe np nq nr ns b">XCTAssert</code>的可选行和文件属性，你可以很容易地做到这一点！行和文件属性将错误冒泡到发生错误的特定测试中，而不是将错误保存在helper方法中。</p><p id="3d73" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">继续并在<code class="fe np nq nr ns b">testRetainCycle</code>后添加该方法</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8a27" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">那就叫它代替<code class="fe np nq nr ns b">addTearDownBlock</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/b94edaacfd8899c61a446db98f9567cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1J8TvcxlJP2Lggj5.png"/></div></div></figure><p id="111d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">发生保留周期最常见的地方之一是在ViewController中使用URLSession之类的HTTP客户端。因此，对于您的下一步，为什么不研究期望和测试异步方法，然后看看您是否可以创建一个HTTP客户端的保留循环，测试它，并打破它。</p><p id="2a5a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">评论里见！⏬</p></div></div>    
</body>
</html>