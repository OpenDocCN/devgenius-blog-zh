<html>
<head>
<title>Example of Spring Cloud Function with AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 AWS Lambda 的 Spring 云函数示例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/example-of-spring-cloud-function-with-aws-lambda-25af76c82916?source=collection_archive---------10-----------------------#2022-01-23">https://blog.devgenius.io/example-of-spring-cloud-function-with-aws-lambda-25af76c82916?source=collection_archive---------10-----------------------#2022-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ed4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们将学习 Spring Cloud 函数，并将在 AWS Lambda 上部署一个 Spring Cloud 函数的示例。在这篇文章的结尾，我们将对无服务器功能有更多的了解。如果你想了解更多关于无服务器架构的知识，这篇文章将带你开始。</p><h1 id="3d91" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">什么是春云函数？</h1><p id="df50" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">春云功能是<a class="ae ki" href="https://betterjavacode.com/spring-boot/spring-cloud-tutorial-for-beginners" rel="noopener ugc nofollow" target="_blank">春云</a>的特色之一。它允许开发人员编写具有 Spring 特性的云无关函数。这些函数可以是独立的类，可以很容易地部署在任何云平台上来构建一个无服务器的框架。Spring Cloud 提供了一个库<a class="ae ki" href="https://search.maven.org/classic/#search%7Cga%7C1%7Cg%3A%22org.springframework.cloud%22%20AND%20a%3A%22spring-cloud-starter-function-web%22" rel="noopener ugc nofollow" target="_blank"><em class="lm">Spring-Cloud-starter-function-web</em></a>允许构建具有 Spring 特性的函数，它带来了所有必要的依赖。</p><h1 id="04f0" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">为什么要用 Spring Cloud 函数？</h1><p id="f150" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这个问题更多的是什么时候使用 Spring Cloud 功能。基本上，Spring Cloud 函数库允许创建可以在 AWS Lambda 上轻松部署的功能应用程序。这些函数遵循 Java 8 的模式<code class="fe ln lo lp lq b">Supplier</code>、<code class="fe ln lo lp lq b">Consumer</code>和<code class="fe ln lo lp lq b">Function</code>。</p><p id="d9d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">spring-cloud-starter-function-web</code>该库为处理请求、流提供了本地交互。</p><h1 id="5d0d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">弹簧云函数的特征</h1><p id="5e36" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Spring Cloud 功能的主要优势是它提供了 Spring Boot 的所有功能，如<code class="fe ln lo lp lq b">autoconfiguration</code>、<code class="fe ln lo lp lq b">dependency injection</code>。但是还有更多的功能:</p><ul class=""><li id="8c26" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh lw lx ly lz bi translated">输入和输出的透明类型转换</li><li id="c87b" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">POJO 函数</li><li id="7be1" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">REST 支持将函数公开为 HTTP 端点</li><li id="4a71" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">通过 Spring Cloud Stream 框架向/从函数传输数据</li><li id="c4fd" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">将函数部署为独立的 jar 文件</li><li id="7f39" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">AWS Lambda、谷歌云平台、微软 Azure 的适配器</li></ul><h1 id="4c83" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">演示</h1><p id="b593" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">作为这篇文章的一部分，我们将创建 Spring Cloud 函数并将其部署在 AWS Lambda 中。一旦我们创建了一个常规的 spring boot 应用程序，在您的 Gradle 文件中添加以下依赖项:</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="f77e" class="mn kk in lq b gy mo mp l mq mr">dependencies {<br/>	implementation 'org.springframework.boot:spring-boot-starter'<br/>	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'<br/>	implementation 'org.springframework.cloud:spring-cloud-function-adapter-aws:3.2.1'<br/>	implementation "com.amazonaws:aws-lambda-java-events:${awsLambdaEventsVersion}"<br/>	implementation "com.amazonaws:aws-lambda-java-core:${awsLambdaCoreVersion}"<br/>	runtimeOnly 'com.h2database:h2'<br/>	testImplementation 'org.springframework.boot:spring-boot-starter-test'<br/>}</span></pre><p id="d162" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意依赖关系<code class="fe ln lo lp lq b">spring-cloud-function-adapter-aws</code>允许我们将 Spring Cloud 函数与<a class="ae ki" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>集成。</p><p id="2110" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序的一个主类如下所示:</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="3548" class="mn kk in lq b gy mo mp l mq mr">package com.betterjavacode.springcloudfunctiondemo;<br/><br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.cloud.function.context.FunctionalSpringApplication;<br/><br/>@SpringBootApplication<br/>public class SpringcloudfunctiondemoApplication {<br/><br/>	public static void main(String[] args) {<br/>		FunctionalSpringApplication.run(SpringcloudfunctiondemoApplication.class, args);<br/>	}<br/><br/>}</span></pre><p id="3327" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与常规的 Spring Boot 应用程序相比，有一点不同。我们使用<code class="fe ln lo lp lq b">FunctionalSpringApplication</code> it 作为切入点。这是一种编写 beans 的函数式方法，有助于启动时间。</p><p id="9ea9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以编写三种类型的函数<code class="fe ln lo lp lq b">Function</code>、<code class="fe ln lo lp lq b">Consumer</code>或<code class="fe ln lo lp lq b">Supplier</code>。作为演示的一部分，我们将了解每个函数的作用以及如何使用它。</p><p id="1e4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，让我们创建一个 POJO 模型类<code class="fe ln lo lp lq b">Customer</code>。</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="eb01" class="mn kk in lq b gy mo mp l mq mr">package com.betterjavacode.springcloudfunctiondemo.models;<br/><br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.Id;<br/>import javax.persistence.Table;<br/><br/>@Entity<br/>@Table(name= "customer")<br/>public class Customer<br/>{<br/>    @Id<br/>    @GeneratedValue(generator = "UUID")<br/>    private Long id;<br/><br/>    private String name;<br/><br/>    private int customerIdentifier;<br/><br/>    private String email;<br/><br/>    private String contactPerson;<br/><br/>    public Customer(String name, int customerIdentifier, String email, String contactPerson)<br/>    {<br/>        this.name = name;<br/>        this.customerIdentifier = customerIdentifier;<br/>        this.email = email;<br/>        this.contactPerson = contactPerson;<br/>    }<br/><br/>    public String getName ()<br/>    {<br/>        return name;<br/>    }<br/><br/>    public void setName (String name)<br/>    {<br/>        this.name = name;<br/>    }<br/><br/>    public int getCustomerIdentifier ()<br/>    {<br/>        return customerIdentifier;<br/>    }<br/><br/>    public void setCustomerIdentifier (int customerIdentifier)<br/>    {<br/>        this.customerIdentifier = customerIdentifier;<br/>    }<br/><br/>    public String getEmail ()<br/>    {<br/>        return email;<br/>    }<br/><br/>    public void setEmail (String email)<br/>    {<br/>        this.email = email;<br/>    }<br/><br/>    public String getContactPerson ()<br/>    {<br/>        return contactPerson;<br/>    }<br/><br/>    public void setContactPerson (String contactPerson)<br/>    {<br/>        this.contactPerson = contactPerson;<br/>    }<br/><br/>    public Long getId ()<br/>    {<br/>        return id;<br/>    }<br/><br/>    public void setId (Long id)<br/>    {<br/>        this.id = id;<br/>    }<br/>}</span></pre><p id="099e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们的 spring cloud 函数将执行一些与这个模型相关的业务逻辑<code class="fe ln lo lp lq b">Customer</code>。</p><h1 id="5a3e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">消费者功能</h1><p id="1ea5" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们创建一个<code class="fe ln lo lp lq b">Consumer</code>函数。<code class="fe ln lo lp lq b">Consumer</code>函数通常接受输入，并执行一些对数据有副作用的业务逻辑。它不会产生任何输出。所以更像是一个<code class="fe ln lo lp lq b">void</code>的方法。</p><p id="b5d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的演示，它将如下所示:</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="65aa" class="mn kk in lq b gy mo mp l mq mr">package com.betterjavacode.springcloudfunctiondemo.functions;<br/><br/>import com.betterjavacode.springcloudfunctiondemo.models.Customer;<br/>import com.betterjavacode.springcloudfunctiondemo.repositories.CustomerRepository;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.stereotype.Component;<br/>import java.util.Map;<br/>import java.util.function.Consumer;<br/><br/>@Component<br/>public class CustomerConsumer implements Consumer&lt;Map&lt;String, String&gt;&gt;<br/>{<br/>    public static final Logger LOGGER = LoggerFactory.getLogger(CustomerConsumer.class);<br/><br/>    @Autowired<br/>    private CustomerRepository customerRepository;<br/><br/>    @Override<br/>    public void accept (Map&lt;String, String&gt; map)<br/>    {<br/>        LOGGER.info("Creating the customer", map);<br/>        Customer customer = new Customer(map.get("name"), Integer.parseInt(map.get(<br/>                "customerIdentifier")), map.get("email"), map.get("contactPerson"));<br/>        customerRepository.save(customer);<br/>    }<br/><br/>}</span></pre><p id="4656" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个<code class="fe ln lo lp lq b">CustomerConsumer</code>函数实现<code class="fe ln lo lp lq b">Consumer</code>函数类型，并接受类型<code class="fe ln lo lp lq b">Map&lt;String, String&gt;</code>的输入。作为接口契约的一部分，需要实现方法<code class="fe ln lo lp lq b">accept</code>。该方法将接受<code class="fe ln lo lp lq b">map</code>输入并执行一些业务逻辑。需要理解的一点是，Spring Cloud 函数将处理来自原始输入流的类型转换和函数声明的类型。如果该函数不能推断类型信息，它将转换为通用类型<code class="fe ln lo lp lq b">map</code>。</p><p id="d1e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数为客户获取 DTO 对象的地图，并将其保存在数据库中。对于数据库，我们使用 H2 内存数据库。人们总是可以添加更多的业务逻辑，但是出于演示的目的，我们展示一个简单的例子。</p><h1 id="d96f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">供应商职能</h1><p id="6ee6" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">supplier 函数的作用类似于 GET 端点。该函数不接受输入，但返回数据。</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="78df" class="mn kk in lq b gy mo mp l mq mr">package com.betterjavacode.springcloudfunctiondemo.functions;<br/><br/>import com.betterjavacode.springcloudfunctiondemo.models.Customer;<br/>import com.betterjavacode.springcloudfunctiondemo.repositories.CustomerRepository;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.List;<br/>import java.util.function.Supplier;<br/><br/>@Component<br/>public class CustomerSupplier implements Supplier<br/>{<br/>    public static final Logger LOGGER = LoggerFactory.getLogger(CustomerSupplier.class);<br/><br/>    @Autowired<br/>    private CustomerRepository customerRepository;<br/><br/>    @Override<br/>    public Customer get ()<br/>    {<br/>        List customers = customerRepository.findAll();<br/>        LOGGER.info("Getting the customer of our choice - ", customers);<br/>        return customers.get(0);<br/>    }<br/>}</span></pre><h1 id="aa81" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">用 AWS Lambda 配置 Spring Cloud 函数</h1><p id="fae4" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">一个 AWS Lambda 将只执行一个函数。如果有多个 Spring Cloud 函数 beans，可以通过 lambda 配置执行哪个函数。添加<code class="fe ln lo lp lq b">application.properties</code>中的属性如下:</p><p id="3953" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">spring.cloud.function.definition=customerConsumer</code></p><p id="3840" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">人们可以使用 AWS Lambda 轻松部署单个 jar 文件，并使用<code class="fe ln lo lp lq b">Spring Profiles</code>在<code class="fe ln lo lp lq b">application.properties</code>中传递不同的函数。</p><h1 id="d8f7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">建筑遮阳罐</h1><p id="fa20" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">要在具有 Spring Cloud 功能的 AWS Lambda 中部署应用程序，您将需要一个带阴影的 jar。为了构建这个 jar，我们将使用<a class="ae ki" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank"> gradle shadow 插件</a>。构建文件将如下所示:</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="c1c4" class="mn kk in lq b gy mo mp l mq mr">buildscript {<br/>	ext {<br/>		springBootVersion = '2.6.2'<br/>		wrapperVersion = '1.0.17.RELEASE'<br/>		shadowVersion = '5.1.0'<br/>	}<br/>	repositories {<br/>		mavenLocal()<br/>		jcenter()<br/>		mavenCentral()<br/>		maven { url "https://repo.spring.io/snapshot" }<br/>		maven { url "https://repo.spring.io/milestone" }<br/>	}<br/>	dependencies {<br/>		classpath "com.github.jengelman.gradle.plugins:shadow:${shadowVersion}"<br/>		classpath("org.springframework.boot.experimental:spring-boot-thin-gradle-plugin:${wrapperVersion}")<br/>		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")<br/>		classpath("io.spring.gradle:dependency-management-plugin:1.0.8.RELEASE")<br/>	}<br/>}<br/>apply plugin: 'java'<br/>apply plugin: 'maven-publish'<br/>apply plugin: 'eclipse'<br/>apply plugin: 'com.github.johnrengelman.shadow'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>group = 'com.betterjavacode'<br/>version = '0.0.1-SNAPSHOT'<br/>sourceCompatibility = '1.8'<br/>targetCompatibility = '1.8'<br/><br/>repositories {<br/>	mavenLocal()<br/>	mavenCentral()<br/>	maven { url "https://repo.spring.io/snapshot" }<br/>	maven { url "https://repo.spring.io/milestone" }<br/>}<br/><br/>ext {<br/>	springCloudFunctionVersion = "3.2.1"<br/>	awsLambdaEventsVersion = "2.0.2"<br/>	awsLambdaCoreVersion = "1.2.1"<br/>}<br/><br/>assemble.dependsOn = [shadowJar]<br/><br/>jar {<br/>	manifest {<br/>		attributes 'Main-Class': 'com.betterjavacode.springcloudfunctiondemo.SpringcloudfunctiondemoApplication'<br/>	}<br/>}<br/><br/>import com.github.jengelman.gradle.plugins.shadow.transformers.*<br/><br/>shadowJar {<br/>	classifier = 'aws'<br/>	dependencies {<br/>		exclude(<br/>				dependency("org.springframework.cloud:spring-cloud-function-web:${springCloudFunctionVersion}"))<br/>	}<br/>	// Required for Spring<br/>	mergeServiceFiles()<br/>	append 'META-INF/spring.handlers'<br/>	append 'META-INF/spring.schemas'<br/>	append 'META-INF/spring.tooling'<br/>	transform(PropertiesFileTransformer) {<br/>		paths = ['META-INF/spring.factories']<br/>		mergeStrategy = "append"<br/>	}<br/>}<br/><br/>dependencyManagement {<br/>	imports {<br/>		mavenBom "org.springframework.cloud:spring-cloud-function-dependencies:${springCloudFunctionVersion}"<br/>	}<br/>}<br/><br/>dependencies {<br/>	implementation 'org.springframework.boot:spring-boot-starter'<br/>	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'<br/>	implementation 'org.springframework.cloud:spring-cloud-function-adapter-aws:3.2.1'<br/>	implementation "com.amazonaws:aws-lambda-java-events:${awsLambdaEventsVersion}"<br/>	implementation "com.amazonaws:aws-lambda-java-core:${awsLambdaCoreVersion}"<br/>	runtimeOnly 'com.h2database:h2'<br/>	testImplementation 'org.springframework.boot:spring-boot-starter-test'<br/>}<br/><br/>test {<br/>	useJUnitPlatform()<br/>}</span></pre><p id="9191" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行命令<code class="fe ln lo lp lq b">./gradlew clean build</code>，它将构建一个阴影罐子。一个优步 Jar 包含来自依赖关系的多个 Jar 的内容。阴影 jar 提供了一种创建超级 jar 和重命名来自优步 Jar 的包的方法。现在要在 AWS Lambda 中部署我们的 jar，我们必须确保包含一个依赖项<code class="fe ln lo lp lq b">com.amazonaws:aws-lambda-java-core</code>。</p><h1 id="f6b0" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">在 AWS 中创建 AWS Lambda</h1><p id="aa85" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">不管怎样，让我们在 AWS 中创建一个 AWS Lambda。</p><figure class="mf mg mh mi gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2a9adacc63129c8ea693b53a039f92c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*BNj06_7MDKqDjgDc"/></div></figure><p id="cfca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提供一个描述性的名称— <code class="fe ln lo lp lq b">SpringCloudFunctionDemo</code>。</p><p id="a2b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上传阴影罐子。</p><figure class="mf mg mh mi gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/c71df1b87553daf10f3ce4968bf346ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*u8ZNQ-WFfR1yFm8n"/></div></figure><p id="78d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在更新 AWS Lambda 中的运行时设置，以指示 Lambda 将如何调用我们的函数。Spring 提供了一个带有泛型方法<code class="fe ln lo lp lq b">handleRequest</code>的类<code class="fe ln lo lp lq b">FunctionInvoker</code>，作为库<code class="fe ln lo lp lq b">spring-cloud-function-aws-adapter</code>的一部分。</p><figure class="mf mg mh mi gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6d956057197734781a687a553450817d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*baJqq9-_eeHzGAkB"/></div></figure><p id="45b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们运行 AWS Lambda，我们将看到我们的<code class="fe ln lo lp lq b">consumer</code>函数的执行。我们将使用 JSON 数据加载测试我们的<code class="fe ln lo lp lq b">consumer</code>函数:</p><pre class="mf mg mh mi gt mj lq mk ml aw mm bi"><span id="724a" class="mn kk in lq b gy mo mp l mq mr">{<br/>  "name": "ABC Company",<br/>  "customerIdentifier": "1",<br/>  "email": "support@abccompany.com",<br/>  "contactPerson": "John Doe"<br/>}</span><span id="4d68" class="mn kk in lq b gy mw mp l mq mr">Log from Lambda Execution</span><span id="c73b" class="mn kk in lq b gy mw mp l mq mr">2022-01-23 06:45:08.987  INFO 9 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...<br/>2022-01-23 06:45:09.391  INFO 9 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.<br/>2022-01-23 06:45:09.455  INFO 9 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect<br/>2022-01-23 06:45:10.289  INFO 9 --- [           main] org.hibernate.tuple.PojoInstantiator     : HHH000182: No default (no-argument) constructor for class: com.betterjavacode.springcloudfunctiondemo.models.Customer (class must be instantiated by Interceptor)<br/>2022-01-23 06:45:10.777  INFO 9 --- [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]<br/>2022-01-23 06:45:10.800  INFO 9 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'<br/>2022-01-23 06:45:12.832  INFO 9 --- [           main] lambdainternal.LambdaRTEntry             : Started LambdaRTEntry in 8.239 seconds (JVM running for 8.868)<br/>2022-01-23 06:45:12.919  INFO 9 --- [           main] o.s.c.f.adapter.aws.FunctionInvoker      : Locating function: 'customerConsumer'<br/>2022-01-23 06:45:12.931  INFO 9 --- [           main] o.s.c.f.adapter.aws.FunctionInvoker      : Located function: 'customerConsumer'<br/>2022-01-23 06:45:12.940  INFO 9 --- [           main] o.s.c.f.adapter.aws.FunctionInvoker      : Received: {"name":"ABC Company","customerIdentifier":"1","email":"support@abccompany.com","contactPerson":"John Doe"}<br/>2022-01-23 06:45:13.146  INFO 9 --- [           main] o.s.c.f.adapter.aws.AWSLambdaUtils       : Incoming JSON Event: {"name":"ABC Company","customerIdentifier":"1","email":"support@abccompany.com","contactPerson":"John Doe"}<br/>2022-01-23 06:45:13.146  INFO 9 --- [           main] o.s.c.f.adapter.aws.AWSLambdaUtils       : Incoming MAP: {name=ABC Company, customerIdentifier=1, email=support@abccompany.com, contactPerson=John Doe}<br/>2022-01-23 06:45:13.166  INFO 9 --- [           main] o.s.c.f.adapter.aws.AWSLambdaUtils       : Incoming request headers: {id=042ab9bc-211d-fa47-839c-888720ec35d4, timestamp=1642920313144}<br/>2022-01-23 06:45:13.184  INFO 9 --- [           main] c.b.s.functions.CustomerConsumer         : Creating the customer<br/>END RequestId: b8352114-77f6-414c-a2dc-63d522a9eef4<br/>REPORT RequestId: b8352114-77f6-414c-a2dc-63d522a9eef4	Duration: 710.53 ms	Billed Duration: 711 ms	Memory Size: 512 MB	Max Memory Used: 251 MB	Init Duration: 8986.65 ms</span></pre><p id="452a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面的日志中看到的，有一个日志<code class="fe ln lo lp lq b">Creating the customer</code>来自我们的代码。此外，您将看到 Lambda 执行的响应为<code class="fe ln lo lp lq b">Ok</code>。</p><p id="85fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此演示的代码可从<a class="ae ki" href="https://github.com/yogsma/betterjavacode" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="4aea" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="bcf2" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">AWS Lambda 是构建无服务器框架的非常强大的服务。通过 Spring Cloud 和 AWS 的结合，人们可以利用多种特性构建更简单的服务来处理复杂的业务需求。这是另一个关于连接<a class="ae ki" href="https://betterjavacode.com/programming/spring-boot-connect-aws-dynamo-db" rel="noopener ugc nofollow" target="_blank"> Spring Boot 应用程序和 AWS Dynamo DB </a>的帖子。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="22c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lm">原载于 2022 年 1 月 23 日 https://betterjavacode.com</em><em class="lm">T21</em><a class="ae ki" href="https://betterjavacode.com/programming/example-spring-cloud-function-aws-lambda" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>