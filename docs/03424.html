<html>
<head>
<title>JavaScript: Merge Sort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:合并排序算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-merge-sort-algorithm-bf46d42f175?source=collection_archive---------3-----------------------#2020-11-02">https://blog.devgenius.io/javascript-merge-sort-algorithm-bf46d42f175?source=collection_archive---------3-----------------------#2020-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3641b1479787e681d6776063c662fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Xl0wf6WZnVfinVPUn81bw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.programiz.com/dsa/merge-sort" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/dsa/merge-sort</a></figcaption></figure><h1 id="77a3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是排序？</h1><p id="e4de" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">排序是将一组数据重新排列成特定的顺序，如数字从升序到降序，反之亦然。排序算法接受给定的数组或列表，并输出排序后的数组或列表。</p><p id="e4d5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">排序无处不在。当我们在一个网站上按最低价格到最高价格、评级等对列表进行排序时。或者在图书馆找一本书。排序的概念使数据集的排列变得更容易，从而使搜索变得更容易。</p><h1 id="d35d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">排序算法的类型</h1><p id="29ba" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">排序算法有很多种。排序技术主要通过<a class="ae jz" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/#:~:text=Time%20complexity%20of%20an%20algorithm,the%20length%20of%20the%20input." rel="noopener ugc nofollow" target="_blank">时间复杂度和空间复杂度来区分。</a>顾名思义，时间复杂度是算法运行所需的时间，它是输入长度的函数，而空间复杂度是输入长度所需的空间或内存量。下面列出了几种不同类型的排序算法:</p><ul class=""><li id="d159" class="mb mc in la b lb lw lf lx lj md ln me lr mf lv mg mh mi mj bi translated">快速排序</li><li id="f3af" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">冒泡排序</li><li id="877b" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><strong class="la io">合并排序</strong></li><li id="f1d2" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">插入排序</li><li id="fad7" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">堆排序</li></ul><div class="mp mq gp gr mr ms"><a href="https://www.interviewbit.com/tutorial/sorting-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">排序算法- InterviewBit</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">排序算法是将大量项目重新组织成某种特定顺序的方法，例如从高到低…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.interviewbit.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jt ms"/></div></div></a></div><h1 id="4aaa" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是合并排序？</h1><p id="23f8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">本文涵盖了合并排序。合并排序是一种基于分而治之的排序技术。最坏情况的时间复杂度是 O(n log(n))，空间复杂度是 O(n)。</p><p id="a2ce" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">合并排序是一种非常流行的排序算法，它使用递归方法。</p><h1 id="23aa" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">合并排序是如何工作的？</strong></h1><p id="f05f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">要使合并排序起作用，需要执行以下递归步骤:</p><ol class=""><li id="9d65" class="mb mc in la b lb lw lf lx lj md ln me lr mf lv nh mh mi mj bi translated">将给定数组的值分成两半</li><li id="f84b" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv nh mh mi mj bi translated">继续分割，直到达到单一值的基本情况</li><li id="9648" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv nh mh mi mj bi translated">通过比较值，以排序的方式合并两半。</li><li id="17ed" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv nh mh mi mj bi translated">用排序后的一半弹出调用栈，继续划分、合并和排序。</li></ol><p id="1862" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面显示了使用合并排序的示例输入的图表和步骤。</p><figure class="nj nk nl nm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/06f89ceeb2f1968fecc9857ec6b45d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XB4P42h0PS1vF0NkO_oJbw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.programiz.com/dsa/merge-sort" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/dsa/merge-sort</a></figcaption></figure><p id="0fe1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">步骤 1、2、3 我们将阵列进行分割，直到达到基本情况。基本情况是，当我们到达一个点，我们不能再划分数组的值。数组中只有一个值。与步骤 5、6、7 相同，我们递归地划分数组，直到我们达到基本情况并弹出调用堆栈。第 8 步合并左半部分和右半部分以排序的方式合并，一旦合并，我们从调用堆栈中弹出这个返回值，这是第 9 步的右半部分。步骤 9 以排序的方式合并左半部分和右半部分。步骤 10 现在再次重复相同的递归过程。</p><h1 id="d41a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这个算法是什么样子的？</h1><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="6699" class="ns kb in no b gy nt nu l nv nw">const mergeSort = function (array) {<br/>  if (array.length &lt;= 1) {<br/>    return array;<br/>  }<br/>  let mid = Math.floor(array.length / 2);<br/>  let left = mergeSort(array.slice(0, mid));<br/>  let right = mergeSort(array.slice(mid));<br/>  return merge(left, right);<br/>};</span></pre><p id="3842" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">merge sort 函数接受一组值。这个数组被递归分割，直到它达到长度为 1 的基本情况。一旦这些子数组被返回并弹出调用堆栈，该函数继续并合并左右子数组。在合并函数中，它将返回一个合并排序数组。每次使用 merge 函数时，左侧和右侧的子数组已经被排序。因此，我们合并排序后的数组。</p><p id="c2c7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面如果合并功能。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="a2de" class="ns kb in no b gy nt nu l nv nw">const merge = function (left, right) {<br/>  let sorted = [];</span><span id="3cff" class="ns kb in no b gy nx nu l nv nw">  while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {<br/>    if (left[0] &lt; right[0]) {<br/>      sorted.push(left.shift());<br/>    } else {<br/>    sorted.push(right.shift());<br/>    }<br/>  }</span><span id="075c" class="ns kb in no b gy nx nu l nv nw">  if (left.length &gt; 0) {<br/>    sorted = sorted.concat(left);<br/>  }<br/>  if (right.length &gt; 0) {<br/>    sorted = sorted.concat(right);<br/>  }<br/>  return sorted;<br/>};</span></pre><p id="7836" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">merge 函数接受两个排序的数组。该函数将使用一个简单的 while 循环合并这些排序后的数组，比较每个数组中的第一个值，然后将它们弹出并添加到新的排序后的数组中。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="6d18" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">希望这有助于您更好地理解合并排序。检查所有其他排序技术，我知道我需要。</p><p id="bccc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我刚刚完成了黑客反应堆训练营的初级阶段。在上周末进行了 6 个小时的技术评估。兴奋地进入我的高级阶段，并开始实际建设一些非常酷的项目！</p></div></div>    
</body>
</html>