<html>
<head>
<title>Getting Started with WebSockets and JSON Data in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 中的 WebSockets 和 JSON 数据入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-websockets-and-json-data-in-rust-84434ddbfc21?source=collection_archive---------1-----------------------#2022-02-03">https://blog.devgenius.io/getting-started-with-websockets-and-json-data-in-rust-84434ddbfc21?source=collection_archive---------1-----------------------#2022-02-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6c4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本指南涵盖了设置一个简单的 WebSocket 客户端，从服务器传输 JSON 数据，并使用<a class="ae ki" href="https://docs.rs/tungstenite/latest/tungstenite/" rel="noopener ugc nofollow" target="_blank">wong tenite</a>&amp;<a class="ae ki" href="https://serde.rs/" rel="noopener ugc nofollow" target="_blank">Serde</a>将数据解析回 Rust。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/5f857f34131ecd49dae729a10f9db380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ImOl2rH013HiR7JC"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae ki" href="https://unsplash.com/@camadams?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cam Adams </a>在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="529b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">WebSockets 在 web 服务应用中已经变得越来越流行，当你的应用在 Rust 中运行时，你可以以闪电般的速度传输、解析和处理数据。</p><p id="d7fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个例子包括建立一个 Rust 项目，创建一个基本的 WebSocket 服务器(用 Python ),实现 JSON 格式数据的流式传输和反序列化，所有这些都在 Rust 中完成。</p><p id="9787" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">注意:在继续之前，请确保您已经安装了最新版本的 Rust </em>  <em class="kz">和 Python</em><em class="kz"/><a class="ae ki" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"><em class="kz">。</em></a></p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="85bb" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">设置 Rust 项目</h1><p id="73bb" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">让我们首先使用<code class="fe mk ml mm mn b">cargo new</code>命令创建 Rust 项目:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="7bfb" class="ms li in mn b gy mt mu l mv mw">$ cargo new hello_rs_ws_client</span></pre><p id="4812" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将创建一个类似如下的目录结构:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="2599" class="ms li in mn b gy mt mu l mv mw">|-Cargo.toml <br/>|-.gitignore <br/>|-src<br/>| |-main.rs</span></pre><p id="2ff6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们需要通过修改<code class="fe mk ml mm mn b">Cargo.toml</code>来设置项目依赖关系，使其看起来像这样:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="cc60" class="ms li in mn b gy mt mu l mv mw">[package]<br/>name = "hello_rs_ws_client"<br/>version = "0.1.0"<br/>edition = "2022"</span><span id="0481" class="ms li in mn b gy mx mu l mv mw"># See more keys and their definitions at <a class="ae ki" href="https://doc.rust-lang.org/cargo/reference/manifest.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/cargo/reference/manifest.html</a></span><span id="ca47" class="ms li in mn b gy mx mu l mv mw">[dependencies]<br/>tungstenite = "0.16.0"<br/>serde_json = "1.0.78"<br/>url = "2.2.2"</span></pre><p id="3d5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在如果你运行<code class="fe mk ml mm mn b">cargo run</code>，它将安装依赖项(钨、Serde 和 URL)并运行 Hello World 示例项目。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="e443" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">创建测试 WebSocket 服务器</h1><p id="450d" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">您可以使用您想要的 WebSocket 服务器(例如，一个公开可用的流)，但是对于本指南，我将用 Python 创建一个基本的 WebSocket 服务器，这样您就可以模拟从上游返回的数据——这在任何情况下对于测试您的应用程序都是有用的。</p><p id="572f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，在项目中创建一个名为<code class="fe mk ml mm mn b">testserver</code>的新目录，这样您的项目结构将看起来像这样:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="b27a" class="ms li in mn b gy mt mu l mv mw">|-Cargo.toml <br/>|-.gitignore<br/>|-testserver <br/>|-src<br/>| |-main.rs</span></pre><p id="c498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在<code class="fe mk ml mm mn b">testserver</code>目录中创建一个<code class="fe mk ml mm mn b">main.py</code>,并修改它的内容，看起来像这样:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="9790" class="ms li in mn b gy mt mu l mv mw">import asyncio<br/>import websockets<br/>import json</span><span id="0770" class="ms li in mn b gy mx mu l mv mw">async def echo(websocket):<br/>    async for message in websocket:<br/>        response = {<br/>            'error': None,<br/>            'result': message<br/>        }<br/>        await websocket.send(json.dumps(response))</span><span id="f3b3" class="ms li in mn b gy mx mu l mv mw">async def main():<br/>    async with websockets.serve(echo, "localhost", 8765):<br/>        await asyncio.Future()  # run forever</span><span id="c62b" class="ms li in mn b gy mx mu l mv mw">asyncio.run(main())</span></pre><p id="3021" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将创建一个服务器，该服务器将读取任何消息，将其包装在一个基本的 JSON 对象中，并将其发送回客户端。</p><p id="bf5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要运行这段 Python 代码，我们首先需要安装<code class="fe mk ml mm mn b">websockets</code>库，这可以通过在您的系统上全局安装:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="5c9f" class="ms li in mn b gy mt mu l mv mw">$ pip install websockets</span></pre><p id="5cc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">或可选的</em>在虚拟环境中完成这一切:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="3670" class="ms li in mn b gy mt mu l mv mw">$ python3 -m venv venv<br/>$ source venv/bin/activate<br/>(venv) $ pip3 install websockets</span></pre><p id="5321" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将仅在虚拟环境中本地安装依赖性。</p><p id="6ddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，您可以通过运行 python 脚本来运行服务器(如果您正在使用虚拟环境，请确保您已经在虚拟环境中获得了源代码)，即:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="8830" class="ms li in mn b gy mt mu l mv mw">$ python3 main.py</span></pre></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="a11e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">实现 WebSocket 客户端</h1><p id="b80c" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">现在您已经有了一个基本的服务器设置，您可以构建您的 Rust 客户机并检查通信是否按预期工作。</p><p id="fbd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以修改<code class="fe mk ml mm mn b">main.rs</code>文件，使其看起来像这样:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="1a8a" class="ms li in mn b gy mt mu l mv mw">use tungstenite::{connect, Message};<br/>use url::Url;<br/>use serde_json;</span><span id="886b" class="ms li in mn b gy mx mu l mv mw">fn main() {</span><span id="875e" class="ms li in mn b gy mx mu l mv mw">    // Connect to the WS server locally<br/>    let (mut socket, _response) = connect(Url::parse("ws://localhost:8765").unwrap()).expect("Can't connect");</span><span id="b502" class="ms li in mn b gy mx mu l mv mw">    // Write a message containing "Hello, Test!" to the server<br/>    socket.write_message(Message::Text("Hello, Test!".into())).unwrap();<br/>    <br/>    // Loop forever, handling parsing each message<br/>    loop {<br/>        let msg = socket.read_message().expect("Error reading message");<br/>        let msg = match msg {<br/>            tungstenite::Message::Text(s) =&gt; { s }<br/>            _ =&gt; { panic!() }<br/>        };<br/>        let parsed: serde_json::Value = serde_json::from_str(&amp;msg).expect("Can't parse to JSON");<br/>        println!("{:?}", parsed["result"]);<br/>    }<br/>}</span></pre><p id="fb52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就建立了一个 WebSocket 客户端，它连接到本地 web 服务器，发送<em class="kz">“你好，测试！”</em>并从返回的 JSON 对象中解析出<code class="fe mk ml mm mn b">result</code>键。</p><p id="05e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过首先在一个终端中运行 Python WebSocket 服务器来运行它并检查一切是否正常:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="5b7f" class="ms li in mn b gy mt mu l mv mw">$ cd testserver<br/>$ python3 main.py</span></pre><p id="75ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从另一个新终端运行:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="31e3" class="ms li in mn b gy mt mu l mv mw">$ cargo run</span></pre><p id="1277" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该看到 Rust 客户端打印出:</p><pre class="kk kl km kn gt mo mn mp mq aw mr bi"><span id="2481" class="ms li in mn b gy mt mu l mv mw">String("Hello, Test!")</span></pre></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="58b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！现在，您已经设法:</p><ul class=""><li id="d65c" class="my mz in jm b jn jo jr js jv na jz nb kd nc kh nd ne nf ng bi translated">创建 Rust 项目并设置与 Cargo 的依赖关系</li><li id="870b" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated">用 Python 构建一个可运行的轻量级 WebSocket 服务器进行测试</li><li id="82b9" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated">使用 JSON 反序列化构建并测试 Rust WebSocket 客户端</li></ul></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="d821" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">下一步是什么？</h1><p id="fccd" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">现在您已经有了一个工作设置，这里有一些后续的想法，让您的应用程序更进一步:</p><ul class=""><li id="f368" class="my mz in jm b jn jo jr js jv na jz nb kd nc kh nd ne nf ng bi translated">使用 Docker 部署您的客户端，并在云中运行 Rust 应用程序。</li><li id="c98d" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><a class="ae ki" href="https://docs.serde.rs/serde_json/" rel="noopener ugc nofollow" target="_blank">使用 Serde 处理更复杂的 JSON 对象类型。</a></li><li id="ba43" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/building-a-secure-websocket-server-with-rust-warp-in-docker-20e842d143af">使用 Rust WebSocket 服务器和 TLS 构建整个后端。</a></li></ul></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="75d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这个指南，看看我的其他 Rust 开发帖子:</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-secure-websocket-server-with-rust-warp-in-docker-20e842d143af"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">使用 Rust &amp; Warp 和 Docker 构建安全的 WebSocket 服务器</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">WebSocket 服务器 TLS 入门，使用 Rust 在云中部署安全的应用程序。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.devgenius.io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kt np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://awstip.com/rust-docker-helloworld-c38070c0dd9c" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">Rust &amp; Docker HelloWorld！</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Rust 和 Docker 中的 HTTP 服务器入门。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">awstip.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od kt np"/></div></div></a></div></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="1579" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想注册 medium，请查看我的推荐链接:</p><p id="1d33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">https://medium.com/@justanotherdev/membership</p></div></div>    
</body>
</html>