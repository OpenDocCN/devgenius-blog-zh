<html>
<head>
<title>JavaScript Basics — Scopes and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础—作用域和函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-basics-scopes-and-functions-103159cda1fb?source=collection_archive---------26-----------------------#2020-06-13">https://blog.devgenius.io/javascript-basics-scopes-and-functions-103159cda1fb?source=collection_archive---------26-----------------------#2020-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c4df8ba4e784dfbc6fd3aaea81e2d6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AoI3_CPM9FDAjs7s"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@tueio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kasia Wanner </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1e5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看变量的作用域，以及函数的定义和调用。</p><h1 id="020c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嵌套作用域</h1><p id="6d48" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">块和函数可以在JavaScript程序中创建自己的变量范围。</p><p id="24ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="097e" class="mn lc iq mj b gy mo mp l mq mr">const fn = () =&gt; {<br/>  let x = 1;<br/>}</span></pre><p id="02bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">x</code>在块内是可用的。</p><p id="d5b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以有函数范围的<code class="fe ms mt mu mj b">var</code>变量。</p><p id="04b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7964" class="mn lc iq mj b gy mo mp l mq mr">const fn = () =&gt; {<br/>  var x = 1;<br/>}</span></pre><p id="c46f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么函数中也有变量。</p><p id="79e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在另一个程序块中有变量，比如一个<code class="fe ms mt mu mj b">if</code>程序块。</p><p id="9d1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d80c" class="mn lc iq mj b gy mo mp l mq mr">const fn = () =&gt; {<br/>  let x = 1;<br/>  if (true) {<br/>    let y = 1;<br/>  }<br/>}</span></pre><p id="de7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">y</code>在<code class="fe ms mt mu mj b">if</code>街区之外就不可用了。</p><p id="5650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9ae" class="mn lc iq mj b gy mo mp l mq mr">const fn = () =&gt; {<br/>  let x = 1;<br/>  if (true) {<br/>    var y = 1;<br/>  }<br/>}</span></pre><p id="2625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">则<code class="fe ms mt mu mj b">y</code>可从<code class="fe ms mt mu mj b">if</code>块外部获得。</p><h1 id="cfd2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作为值的功能</h1><p id="7894" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数可以做其他值可以做的所有事情。</p><p id="e0d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在表达式中使用它们，而不仅仅是调用它。</p><p id="9030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将函数存储在一个变量中，并且可以将它们作为参数传入。</p><p id="e3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们之前的函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="10ec" class="mn lc iq mj b gy mo mp l mq mr">const fn = () =&gt; {<br/>  let x = 1;<br/>}</span></pre><p id="41c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被分配给<code class="fe ms mt mu mj b">fn</code>常量。</p><h1 id="35ae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">声明符号</h1><p id="56c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用更短的方式编写函数。</p><p id="8188" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用声明符号，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9b22" class="mn lc iq mj b gy mo mp l mq mr">function cube(x) {<br/>  return x ** 3;<br/>}</span></pre><p id="a827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该语句定义了<code class="fe ms mt mu mj b">cube</code>函数，并且在其后不需要分号。</p><p id="b681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在它们被定义之前使用它们。</p><p id="9abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6904" class="mn lc iq mj b gy mo mp l mq mr">const cubed = cube(2);</span><span id="c59f" class="mn lc iq mj b gy mv mp l mq mr">function cube(x) {<br/>  return x ** 3;<br/>}</span></pre><p id="e7a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在它被定义之前我们称之为。</p><p id="b1db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它会自动被拉到顶部。</p><p id="0d97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数声明不是常规的自顶向下流程控制的一部分。</p><h1 id="be86" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头功能</h1><p id="ab94" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">箭头函数就是我们之前看到的。它们由<code class="fe ms mt mu mj b">=&gt;</code>箭头表示。</p><p id="19d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头由带大于号的等号组成。</p><p id="9802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头位于参数列表之后，后面是函数体。</p><p id="7961" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样定义它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b655" class="mn lc iq mj b gy mo mp l mq mr">const cube = (x) =&gt; {<br/>  return x ** 3;<br/>}</span></pre><p id="3da9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="df86" class="mn lc iq mj b gy mo mp l mq mr">const cube = (x) =&gt; x ** 3;</span></pre><p id="c24e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是相同的，因为它们都隐式或显式地返回相同的值。</p><p id="8b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个示例使用关键字<code class="fe ms mt mu mj b">return</code>显式返回，第二个示例隐式返回。</p><p id="f40b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数用于以更短的方式编写JavaScript函数。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/77a68cee6cb7e50b8378bdf9f530ce1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CQOJyP5_b5MgUSgR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@alexharvey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·哈维拍摄🤙🏻</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="3123" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调用栈</h1><p id="bde6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">调用堆栈是为获得结果而调用的所有函数的记录。</p><p id="1aa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它存储在计算机的内存中。当堆栈变得太大时，计算机将抛出一个错误。</p><p id="c369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd5e" class="mn lc iq mj b gy mo mp l mq mr">const a = () =&gt; {<br/>  console.log('a');<br/>}</span><span id="e1f6" class="mn lc iq mj b gy mv mp l mq mr">const b = () =&gt; {<br/>  console.log('b');<br/>  a();<br/>}</span><span id="9c26" class="mn lc iq mj b gy mv mp l mq mr">const c = () =&gt; {<br/>  console.log('c');<br/>  b();<br/>}</span><span id="31a9" class="mn lc iq mj b gy mv mp l mq mr">c();</span></pre><p id="1f20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="77a2" class="mn lc iq mj b gy mo mp l mq mr">c<br/>b<br/>a</span></pre><p id="abf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自控制台日志。</p><p id="1501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数序列是所调用函数的堆栈，按照它们被调用的顺序排列。</p><p id="453c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从最晚到最早。</p><h1 id="8812" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可选参数</h1><p id="17ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数参数不必与函数的参数匹配。</p><p id="39ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将<code class="fe ms mt mu mj b">cube</code>称为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0c02" class="mn lc iq mj b gy mo mp l mq mr">const cubed = cube(2, 'foo');</span></pre><p id="e66b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数，但我们传入了两个参数。</p><p id="299f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将任何东西传递给JavaScript函数。不检查函数调用。</p><p id="4c49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多余的将被丢弃。</p><p id="dbf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有传入足够的参数来设置所有参数，那么那些没有传入的参数将被设置为<code class="fe ms mt mu mj b">undefined</code>。</p><p id="0e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们这样称呼<code class="fe ms mt mu mj b">cube</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="794d" class="mn lc iq mj b gy mo mp l mq mr">const cubed = cube(2);</span></pre><p id="aeab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">cubed</code>为<code class="fe ms mt mu mj b">NaN</code>，而<code class="fe ms mt mu mj b">x</code>为<code class="fe ms mt mu mj b">undefined</code>。</p><h1 id="2bda" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0091" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">变量的嵌套范围取决于如何声明变量以及它们位于何处。</p><p id="57f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用几种方法来定义函数。我们可以定义函数声明或箭头函数。</p><p id="25c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用堆栈是所调用函数的记录。</p></div></div>    
</body>
</html>