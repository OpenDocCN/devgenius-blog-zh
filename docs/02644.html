<html>
<head>
<title>Adapter Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的适配器设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/adapter-design-pattern-in-modern-c-32d92d56c4bf?source=collection_archive---------12-----------------------#2020-08-17">https://blog.devgenius.io/adapter-design-pattern-in-modern-c-32d92d56c4bf?source=collection_archive---------12-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/96087c072b57c8016f011ead1247aabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sifMzFau8d3WcM5KyuOyog.png"/></div></div></figure><p id="7873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在软件工程中，结构设计模式处理对象和类之间的关系，即对象和类如何以适合情况的方式交互或建立关系。结构设计模式通过识别关系来简化结构。在这篇关于结构设计模式的文章中，我们将了解一下现代C++中的适配器设计模式，其中<strong class="ka ir"> <em class="kw">用于将现有类的接口转换为客户端/API-用户期望的另一个接口</em> </strong>。适配器设计模式使得由于接口不兼容而无法协同工作的类能够协同工作。</p><blockquote class="kx ky kz"><p id="386f" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> /！\:本文已原创发表于我的</em> <a class="ae ld" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">博客</em> </a> <em class="iq">。如果你有兴趣接收我的最新文章，</em> <a class="ae ld" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="eccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，如果你还没有看过我关于结构设计模式的其他文章，下面是列表:</p><ol class=""><li id="75ec" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">适配器</strong> </a></li><li id="0a42" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/bridge-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">桥<strong class="ka ir">桥</strong>桥</a></li><li id="a500" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">复合</strong> </a></li><li id="884f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">装饰者</strong> </a></li><li id="9a8c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/facade-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">立面</strong> </a></li><li id="660c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/flyweight-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">飞锤</strong> </a></li><li id="04a5" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/proxy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代理</strong> </a></li></ol><p id="86dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ls lt lu lv b">override</code>、<code class="fe ls lt lu lv b">final</code>、<code class="fe ls lt lu lv b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消费(大多数时候)在单一标准屏幕尺寸。我也更喜欢<code class="fe ls lt lu lv b">struct</code>而不是<code class="fe ls lt lu lv b">class</code>，只是为了节省代码行，有时不写<code class="fe ls lt lu lv b">public:</code>，还会故意忽略<a class="ae ld" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae ld" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ls lt lu lv b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="8947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">注:</em> </strong></p><ul class=""><li id="acce" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae ld" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="6f59" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">您在本系列文章中遇到的所有这些代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17之前的现代C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了boost库的<a class="ae ld" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="cec8" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">目的</h1><blockquote class="kx ky kz"><p id="ac0b" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">从你拥有的界面中获取你想要的界面。</em>T24】</strong></p></blockquote><ul class=""><li id="4eb4" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">适配器允许两个不兼容的类一起工作，方法是将一个类的接口转换成客户机/API用户期望的接口，而不改变它们。基本上，添加中间类，即适配器。</li><li id="3ccf" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">如果你发现自己处于使用适配器的情况，那么你可能正在处理库、模块、插件等之间的兼容性。如果没有，那么你可能会有严重的设计问题，因为如果你在设计的早期就遵循了<a class="ae ld" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>。使用适配器设计模式就不是这样了。</li></ul><h1 id="133c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">C++中的适配器设计模式示例</h1><ul class=""><li id="ab3e" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">实现适配器设计模式很容易，只需确定您拥有的API和您需要的API。创建一个组件，该组件聚合(具有对…的引用)适配器。</li></ul><h1 id="d7cd" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">经典适配器</h1><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="9d68" class="ni ly iq lv b gy nj nk l nl nm">struct Point {<br/>    int32_t     m_x;<br/>    virtual void draw(){ cout&lt;&lt;"Point\n"; }<br/>};</span><span id="11b4" class="ni ly iq lv b gy nn nk l nl nm">struct Point2D : Point {<br/>    int32_t     m_y;<br/>    void draw(){ cout&lt;&lt;"Point2D\n"; }<br/>};</span><span id="8bd5" class="ni ly iq lv b gy nn nk l nl nm">void draw_point(Point &amp;p) {<br/>    p.draw();<br/>}</span><span id="fb33" class="ni ly iq lv b gy nn nk l nl nm">struct Line {<br/>    Point2D     m_start;<br/>    Point2D     m_end;<br/>    void draw(){ cout&lt;&lt;"Line\n"; }<br/>};</span><span id="636a" class="ni ly iq lv b gy nn nk l nl nm">struct LineAdapter : Point {<br/>    Line&amp;       m_line;<br/>    LineAdapter(Line &amp;line) : m_line(line) {}<br/>    void draw(){ m_line.draw(); }<br/>};</span><span id="c56d" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    Line l;<br/>    LineAdapter lineAdapter(l);<br/>    draw_point(lineAdapter);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="7b87" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">您还可以通过利用<a class="ae ld" href="http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/" rel="noopener ugc nofollow" target="_blank"> C++模板</a>创建一个通用适配器，如下所示:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="9b8a" class="ni ly iq lv b gy nj nk l nl nm">template&lt;class T&gt;<br/>struct GenericLineAdapter : Point {<br/>    T&amp;      m_line;<br/>    GenericLineAdapter(T &amp;line) : m_line(line) {}<br/>    void draw(){ m_line.draw(); }<br/>};</span></pre><ul class=""><li id="6da1" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">当你考虑到当你需要做其他事情时，非泛型方法很快变得非常多余，那么泛型方法的有用性有望变得更加明显。</li></ul><h1 id="3401" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用现代C++的可插拔适配器设计模式</h1><ul class=""><li id="e658" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">适配器应该使用客户机/API用户已知的相同的旧目标接口来支持被适配器(它们是不相关的并且具有不同的接口)。下面的例子通过使用C++11的<a class="ae ld" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank"> lambda函数</a> &amp;函数头来满足这个属性。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="2791" class="ni ly iq lv b gy nj nk l nl nm">/* Legacy code -------------------------------------------------------------- */<br/>struct Beverage {<br/>    virtual void getBeverage() = 0;<br/>};</span><span id="b033" class="ni ly iq lv b gy nn nk l nl nm">struct CoffeeMaker : Beverage {<br/>    void Brew() { cout &lt;&lt; "brewing coffee" &lt;&lt; endl;}<br/>    void getBeverage() { Brew(); }<br/>};</span><span id="ba2c" class="ni ly iq lv b gy nn nk l nl nm">void make_drink(Beverage &amp;drink){<br/>    drink.getBeverage();                // Interface already shipped &amp; known to client<br/>}<br/>/* --------------------------------------------------------------------------- */</span><span id="7ea1" class="ni ly iq lv b gy nn nk l nl nm">struct JuiceMaker {                     // Introduced later on<br/>    void Squeeze() { cout &lt;&lt; "making Juice" &lt;&lt; endl; }<br/>};</span><span id="a022" class="ni ly iq lv b gy nn nk l nl nm">struct Adapter : Beverage {              // Making things compatible<br/>    function&lt;void()&gt;    m_request;</span><span id="2719" class="ni ly iq lv b gy nn nk l nl nm">    Adapter(CoffeeMaker* cm) { m_request = [cm] ( ) { cm-&gt;Brew(); }; }<br/>    Adapter(JuiceMaker* jm) { m_request = [jm] ( ) { jm-&gt;Squeeze(); }; }</span><span id="5177" class="ni ly iq lv b gy nn nk l nl nm">    void getBeverage() { m_request(); }<br/>};</span><span id="ce21" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    Adapter adp1(new CoffeeMaker());<br/>    make_drink(adp1);</span><span id="1d1a" class="ni ly iq lv b gy nn nk l nl nm">    Adapter adp2(new JuiceMaker());<br/>    make_drink(adp2);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="72f3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">可插拔适配器会找出当时插入的是哪个对象。一旦一个对象被插入，并且它的方法被分配给委托对象(在我们的例子中就是<code class="fe ls lt lu lv b">m_request</code>),这个关联就一直持续到另一组方法被分配。</li><li id="fdc9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">可插拔适配器的特点是，它将为它所适应的每种类型都提供构造函数。在每一个方法中，它执行委托<a class="ae ld" href="http://www.vishalchovatiya.com/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">分配</a>(一个，或者多个，如果有更多的方法用于重新路由)。</li><li id="b000" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">可插拔适配器提供了以下两个主要优势:</li></ul><ol class=""><li id="65bf" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">你可以绑定一个接口(在构造函数参数中绕过lambda函数)，不像我们在上面例子中做的对象。</li><li id="4a50" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">当适配器和被适配器具有不同数量的参数时，这也很有帮助。</li></ol><h1 id="c180" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">适配器设计模式的好处</h1><ol class=""><li id="ddda" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">开闭原则</a>:适配器模式的一个优点是你不需要改变现有的类或接口。通过引入一个新的类，它充当接口和类之间的适配器，可以避免对现有代码进行任何更改。</li><li id="cda6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">这也限制了您对软件组件的更改范围，并避免了其他组件或应用程序中的任何更改和副作用。</li><li id="10ce" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">通过以上两点，即单独的类(即<a class="ae ld" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>)对于特殊功能&amp;更少的副作用，很明显我们确实需要更少的维护，学习曲线&amp;测试。</li><li id="2cf6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">AdapterDesing模式还遵循<a class="ae ld" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>，因此您可以在多个版本之间保持二进制兼容性。</li></ol><h1 id="d24b" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">常见问题汇总</h1><p id="9e03" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated"><strong class="ka ir">何时使用适配器设计模式？</strong></p><p id="c734" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—当您想要使用一些现有的类，但其接口与您的代码的其余部分不兼容时，请使用适配器类。<br/> —当你想要重用一些现有的子类，这些子类缺少一些不能添加到超类中的公共功能。<br/> —例如，假设您有一个函数接受天气对象&amp;以摄氏度为单位打印温度。但是现在你需要打印华氏温度。在这种不兼容的情况下，您可以使用适配器设计模式。</p><p id="d1c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">现实生活中&amp;适配器设计模式的实际例子？</strong></p><p id="29b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—在STL中，堆栈、队列和优先级队列是来自队列和向量的适配器。当stack执行<a class="ae ld" href="https://en.cppreference.com/w/cpp/container/stack" rel="noopener ugc nofollow" target="_blank">stack</a>:push()时，底层vector做<code class="fe ls lt lu lv b">vector::push_back()</code>。<br/> -作为存储卡和笔记本电脑之间适配器的读卡器。<br/> -您的移动&amp;笔记本电脑充电器是一种适配器，它将标准电压&amp;电流转换为您的设备所需的电压。</p><p id="5846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">桥接&amp;适配器设计模式有什么区别？</strong></p><p id="283d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—适配器通常与现有的应用程序一起使用，以使一些原本不兼容的类很好地协同工作。<br/> — <a class="ae ld" href="http://www.vishalchovatiya.com/bridge-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> Bridge </a>通常是预先设计好的，允许你独立开发应用程序的各个部分。</p><p id="f081" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">装饰器&amp;适配器设计模式有什么区别？</strong></p><p id="54f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—适配器将一个接口转换为另一个接口，而不增加额外的功能\ <br/> — <a class="ae ld" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">装饰器</a>将新功能添加到现有的接口中。</p><p id="0dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代理&amp;适配器设计模式有什么区别？</strong></p><p id="e14f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—适配器设计模式将一个类的接口转换为兼容但不同的接口。代理提供相同但简单的接口，或者有时作为唯一的包装器。</p></div></div>    
</body>
</html>