<html>
<head>
<title>!! vs. Boolean()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">！！vs .布尔()</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/vs-boolean-cd502fbd6101?source=collection_archive---------1-----------------------#2020-06-05">https://blog.devgenius.io/vs-boolean-cd502fbd6101?source=collection_archive---------1-----------------------#2020-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="112f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">回答“对还是错”这个问题的最好方法是什么在JavaScript中</h1><h2 id="5851" class="ki jl in bd jm kj kk dn jq kl km dp ju kn ko kp jy kq kr ks kc kt ku kv kg kw bi translated">JavaScript在类型上不会给你带来太多麻烦(起初)，这既是一件好事也是一件坏事。但是我们都知道布尔型。布尔变量可以是<code class="fe kx ky kz la b">true</code>或<code class="fe kx ky kz la b">false</code>。是或不是。</h2></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><p id="3d1c" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">JavaScript中的每个值都可以被翻译成布尔值、<code class="fe kx ky kz la b">true</code>或<code class="fe kx ky kz la b">false</code>。翻译成<code class="fe kx ky kz la b">true</code>的值是真的，翻译成<code class="fe kx ky kz la b">false</code>的值是假的。简单。</p><p id="e868" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">这是两种翻译的方法。</p><h1 id="185e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">！！和布尔()</h1><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="c66a" class="ki jl in la b gy ml mm l mn mo">const value = 'hello world';<br/><br/>Boolean(value); // true - the boolean function<br/>!!value; // true - double bang / double negation</span></pre><p id="07e3" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">哪个最好？</p><h1 id="3bca" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">真理和谬误</h1><p id="cb10" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">从任意值到<code class="fe kx ky kz la b">true</code>或<code class="fe kx ky kz la b">false</code>的转换由ECMAScript语言规范的<a class="ae mu" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.2" rel="noopener ugc nofollow" target="_blank">章节9.2 </a>中的抽象操作<code class="fe kx ky kz la b">ToBoolean</code>描述。</p><p id="253d" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">所有的价值都是真实的，除非它们是虚假的。所以我们只要知道假的就能知道真的。</p><p id="fc7d" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">Falsy值(<code class="fe kx ky kz la b">ToBoolean</code>结果为<code class="fe kx ky kz la b">false</code>):</p><ul class=""><li id="2a45" class="mv mw in lk b ll lm lp lq kn mx kq my kt mz mc na nb nc nd bi translated"><code class="fe kx ky kz la b">false</code></li><li id="1236" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">undefined</code></li><li id="ab8c" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">null</code></li><li id="d0f8" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">''</code> -空字符串</li><li id="4c00" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">0</code>、<code class="fe kx ky kz la b">-0</code>和<code class="fe kx ky kz la b">0n</code> -零</li><li id="69e4" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">NaN</code>(不是数字)</li></ul><p id="2212" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">所以真实的例子是(<code class="fe kx ky kz la b">ToBoolean</code>结果是<code class="fe kx ky kz la b">true</code>):</p><ul class=""><li id="a5c0" class="mv mw in lk b ll lm lp lq kn mx kq my kt mz mc na nb nc nd bi translated"><code class="fe kx ky kz la b">true</code></li><li id="e8d1" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">{}</code></li><li id="1c11" class="mv mw in lk b ll ne lp nf kn ng kq nh kt ni mc na nb nc nd bi translated"><code class="fe kx ky kz la b">"false"</code></li></ul><p id="1194" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">在某些操作中(比如在if/else语句中)，JavaScript会使用这些truthy/falsy规则自动将值转换成<code class="fe kx ky kz la b">true</code>或<code class="fe kx ky kz la b">false</code>。这是类型强制。在<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a>中了解更多信息。</p><p id="19c5" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">一个例子:</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="461e" class="ki jl in la b gy ml mm l mn mo">const student = {<br/>  answer: 'correct'<br/>};<br/><br/>// student.answer is truthy, <br/>// so we get true and the answer is verified.<br/>if (student.answer) {<br/>  verifyAnswer();<br/>}</span></pre><p id="4fd2" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">让我们仔细看看<code class="fe kx ky kz la b">Boolean()</code>和<code class="fe kx ky kz la b">!!</code>。</p><h1 id="514b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">布尔()</h1><p id="7498" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">总是使用布尔作为函数。所以这样做:</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="1759" class="ki jl in la b gy ml mm l mn mo">const trueOrFalse = Boolean('yes'); // true</span></pre><p id="c9a4" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">不要这样做！</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="cb96" class="ki jl in la b gy ml mm l mn mo">const trueOrFalse = new Boolean('yes');</span></pre><p id="17cc" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated"><code class="fe kx ky kz la b">trueOrFalse</code>现在变成了布尔对象，而不是布尔值！我们知道<code class="fe kx ky kz la b">{}</code>不是假的，所以<code class="fe kx ky kz la b">new Boolean()</code>总是真的。这可能导致意想不到的行为。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="9c05" class="ki jl in la b gy ml mm l mn mo">typeof new Boolean(false); // object - {...}<br/>typeof Boolean(false); // boolean - false<br/><br/>if (new Boolean(false)) {<br/>  // This will run! Because the Boolean {} is coerced to true.<br/>}<br/><br/>if (Boolean(false)) {<br/>  // This will not run! Which is probably what you want.<br/>}</span></pre><p id="da29" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">关于布尔对象的更多信息，请参见<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>。</p><h1 id="606d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi">!!</h1><p id="a846" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated"><code class="fe kx ky kz la b">!</code>逻辑非运算符，感叹号，也叫“砰”。它将真值翻译成<code class="fe kx ky kz la b">false</code>，将假值翻译成<code class="fe kx ky kz la b">true</code>。明白了吗？</p><p id="355b" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">这样做两次会将真值转换为<code class="fe kx ky kz la b">true</code>，将假值转换为<code class="fe kx ky kz la b">false</code>。</p><p id="58d1" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">这是双重否定。如果一个陈述是真的，那么这个陈述是<em class="nj">而不是</em>真的。很复杂，但是请记住<code class="fe kx ky kz la b">!!</code>的结果是一个布尔型。<code class="fe kx ky kz la b">true</code>为真值，<code class="fe kx ky kz la b">false</code>为假值。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="ecc9" class="ki jl in la b gy ml mm l mn mo">const value = 'hello';<br/><br/>// Step 1. First bang.<br/>const step1 = !value; // step1 = false (NOT truthy = false)<br/><br/>// Step 2. Second bang.<br/>const step2 = !step1; // step2 = true (NOT false = true) <br/><br/>// Thus<br/>console.log(step1, !value); // false<br/>console.log(step2, !!value); // true</span></pre><h1 id="4cd5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">专家怎么说？</h1><p id="a43c" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">优秀的<a class="ae mu" href="https://airbnb.io/javascript/#coercion--booleans" rel="noopener ugc nofollow" target="_blank"> Airbnb风格指南</a>偏爱双bang / <code class="fe kx ky kz la b">!!</code>。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="52c9" class="ki jl in la b gy ml mm l mn mo">// good<br/>const hasAge = Boolean(age);<br/><br/>// best<br/>const hasAge = !!age;</span></pre><p id="891e" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">在凯尔·辛普森的《你不知道的JS》一书的第四章中，两种选择都被认为是好的。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="9693" class="ki jl in la b gy ml mm l mn mo">const a = "42";<br/><br/>// bad (will fail!):<br/>if (a == true) {<br/>	// ..<br/>}<br/><br/>// also bad (will fail!):<br/>if (a === true) {<br/>	// ..<br/>}<br/><br/>// good enough (works implicitly):<br/>if (a) {<br/>	// ..<br/>}<br/><br/>// better (works explicitly):<br/>if (!!a) {<br/>	// ..<br/>}<br/><br/>// also great (works explicitly):<br/>if (Boolean( a )) {<br/>	// ..<br/>}</span></pre><h1 id="1ba1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么显式转换比隐式转换好？</h1><p id="54d9" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">比起隐式转换，显式转换更受青睐有多种原因。</p><p id="1e75" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">首先，更容易看出意图是什么。好的代码让你假设更少，理解更多。通过使用<code class="fe kx ky kz la b">Boolean()</code>或<code class="fe kx ky kz la b">!!</code>，很明显<code class="fe kx ky kz la b">ToBoolean</code>转换是有意的。</p><p id="34f3" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">它防止意外的结果，例如使用<code class="fe kx ky kz la b">||</code>和<code class="fe kx ky kz la b">&amp;&amp;</code>操作符。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="ac9a" class="ki jl in la b gy ml mm l mn mo">// isValid becomes 'yup', not true as with for example PHP.<br/>const isValid = 'yes' &amp;&amp; 'yup'; </span><span id="a434" class="ki jl in la b gy nk mm l mn mo">// isValid becomes 'yes', not true.<br/>const isValid = 'yes' || 'no';</span></pre><p id="1e84" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">更好:</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="f1de" class="ki jl in la b gy ml mm l mn mo">// isValid becomes true! Probably what we want.<br/>const isValid = Boolean('yes' &amp;&amp; 'yup'); </span><span id="a7e6" class="ki jl in la b gy nk mm l mn mo">// isValid becomes true!<br/>const isValid = Boolean('yes' || 'no');</span></pre><p id="9868" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated"><code class="fe kx ky kz la b">||</code>和<code class="fe kx ky kz la b">&amp;&amp;</code>操作符产生两个变量中的一个，不一定是布尔值。通过使用<code class="fe kx ky kz la b">Boolean()</code>,我们明确了这一点，少了一件需要考虑的事情！</p><p id="f4d5" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">也有可能伴随着一声巨响🔫 🔫。</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="06b1" class="ki jl in la b gy ml mm l mn mo">!!('yes' &amp;&amp; 'yup'); // results in true</span></pre><h1 id="f72b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">表演</h1><p id="8155" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">我做了一个快速的jsperf测试。我认为这两种操作都是基本的，因此对于大多数用例来说“足够快”。可读性和清晰性对我来说更重要。看到结果还是很有趣的。</p><p id="3a1d" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">我一直认为双爆炸是性能方面的出路。虽然你必须进行两次转换(假/真-&gt;布尔-&gt;布尔)。但是不管怎样，也许浏览器内置了一些优化。</p><p id="c2ba" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">游猎，<code class="fe kx ky kz la b">!!</code>获胜。</p><figure class="md me mf mg gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nl"><img src="../Images/661e0b0f63fab6da0b401c97c2e26b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LO21WV4ovLu4shp41wQ4Q.png"/></div></div></figure><p id="9e37" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">火狐，平局。</p><figure class="md me mf mg gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/09409867facc477d03d689ceb119708d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPBL2UjKvN1e9gg2_kP61g.png"/></div></div></figure><p id="70f8" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">铬，<code class="fe kx ky kz la b">Boolean()</code>胜(略)。</p><figure class="md me mf mg gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nu"><img src="../Images/630d3cc2958de96d388a74251465877c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ao5GwyzUQGXZ5m3JlKhwHw.png"/></div></div></figure><p id="2edf" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">没有明显的赢家。检查您的网络浏览器使用份额。🙃</p><h1 id="e6e8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="b6e8" class="pw-post-body-paragraph li lj in lk b ll mp ln lo lp mq lr ls kn mr lu lv kq ms lx ly kt mt ma mb mc ig bi translated">随便挑一个！😁</p><p id="9c96" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">我个人更喜欢<code class="fe kx ky kz la b">Boolean()</code>。我喜欢这样说:“给我一个布尔值”。大多数开发人员会立即理解这一点，<code class="fe kx ky kz la b">!!</code>不太清楚(但很容易记住)。</p><p id="6922" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">就性能而言，这并不重要，但是你可以更快地输入<code class="fe kx ky kz la b">!!</code>。懒人的有效论据。</p><p id="2b1c" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">还有一个<code class="fe kx ky kz la b">Boolean()</code>的加分点，是功能。所以你可以这样做:</p><pre class="md me mf mg gt mh la mi mj aw mk bi"><span id="08e4" class="ki jl in la b gy ml mm l mn mo">const answers = ['', 'correct', '', 'good'];<br/>const completedAnswers = answers.filter(Boolean);</span></pre><p id="13aa" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated">如果你想阅读更多关于JavaScript中的类型，我可以强烈推荐第一本书<a class="ae mu" href="https://github.com/getify/You-Dont-Know-JS/tree/1st-ed/types%20%26%20grammar" rel="noopener ugc nofollow" target="_blank">你不知道的JS，类型&amp;语法</a>。</p><figure class="md me mf mg gt nm gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0a1735503215afbad5bc2254544ab177.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*8AcIyzgCiPl6P7-nKGLOGw.png"/></div></figure></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><p id="f441" class="pw-post-body-paragraph li lj in lk b ll lm ln lo lp lq lr ls kn lt lu lv kq lw lx ly kt lz ma mb mc ig bi translated"><em class="nj">最初发布于</em><a class="ae mu" href="https://gist.github.com/arthurvi/66cb1e2bcfc92f99f465e0db04264367" rel="noopener ugc nofollow" target="_blank"><em class="nj">http://github.com</em></a><a class="ae mu" href="https://gist.github.com/arthurvi/66cb1e2bcfc92f99f465e0db04264367" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Arthur VI/66 cb1e 2 bcfc 92 f 99 f 465 E0 db 04264367</a><em class="nj">。</em></p></div></div>    
</body>
</html>