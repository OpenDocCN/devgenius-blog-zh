<html>
<head>
<title>Understanding the Constraint Layout in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Android中的约束布局</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-the-constraint-layout-in-android-3b1528f8ca9?source=collection_archive---------4-----------------------#2020-06-06">https://blog.devgenius.io/understanding-the-constraint-layout-in-android-3b1528f8ca9?source=collection_archive---------4-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4b86ce7b473cd52d967b22da3a260eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7GOqKAaPwgMPQpvB.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:谷歌</figcaption></figure><p id="5397" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于原生android应用程序开发者社区来说，在原生Android中创建一个具有嵌套视图组的响应式UI一直是一个挑战。</p><p id="ca02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">约束布局大大缓解了上述问题。谷歌在<strong class="ke ir"> 2016的谷歌I/O </strong>上公布了布局。约束布局或多或少类似于相对布局，但更灵活，更好地适应屏幕大小的变化，更容易与Android Studio的布局编辑器一起使用。根据官方文件"<em class="la">，所有约束布局的功能都可以直接从布局编辑器的可视化工具中获得，因为布局API和布局编辑器是专门为彼此构建的。因此，您可以完全通过拖放而不是编辑XML来构建带有约束布局的布局。</em>”</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cb6a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是约束？</h1><p id="096a" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">约束是这种布局的基本构件。它将一个小部件的锚点与另一个小部件或父部件连接起来。有各种各样的约束被操作来创建一个响应性的UI，它也能更好地适应不同的屏幕尺寸。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3582" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">各种约束:</h1><p id="7d3f" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">相对定位</em></strong><em class="la"/><strong class="ke ir"><em class="la">:</em></strong>这些约束允许您相对于任何其他小部件或相对于父视图组水平或垂直地定位小部件的给定侧。</p><p id="81ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用于相对定位的属性:<code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constraint[source side]_to[target side]="[target id or parent]"</strong></code></p><p id="ec35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">居中定位</em> </strong> <em class="la"> : </em>该约束用于在两个目标之间水平或垂直居中小部件。目标可以是另一个小部件的锚点或父对象的锚点。两个相反的约束就像两个相反的力，使小部件在目标之间居中。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c64235980c29bfca16c8ca3755f0b63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*Khfc5xkn7gzbh8ty.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">小部件的中心定位(图片来源:谷歌的Android开发者文档)</figcaption></figure><p id="f8d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">偏差:</em> </strong>每次我们尝试创建布局时，小部件的中心定位可能并不理想。有时，小部件可能需要更倾向于某一方面。为了实现这个用例，我们被提供了偏差约束。我们可以有一个小部件的水平和垂直偏差。</p><p id="d315" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用于偏差约束的属性:</p><p id="9437" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constraintHorizontal_bias="[float value ranging from 0 to 1]"</strong></code></p><p id="dd4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constraintVertical_bias="[float value ranging from 0 to 1]"</strong></code></p><p id="6179" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">浮点值决定偏差的百分比。</p><p id="c1db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于水平偏移，它决定了小工具需要从左侧偏移的百分比，例如:<br/> <code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constraintHorizontal_bias="0.3"</strong></code></p><p id="16f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上述属性将保持小部件的左侧有30%的偏差，而不是默认的50%。下面是该示例的图示。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/86796afbda68d8f92a06f43126eb0094.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*inl1fYm6nUzCCxa2.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">水平偏差，图片来源:谷歌的Android开发者文档</figcaption></figure><p id="f1f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于垂直偏移，浮动值决定了小部件需要离开顶部的百分比，例如，</p><p id="7333" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constraintVertical_bias="0.2"</strong></code></p><p id="8d2d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上述属性将保持小部件的顶部有20%的偏差，而不是默认的50%。下面是该示例的图示。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/11d5fe2919dac3679a26340a1b9c750a.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*0ElQHJExlHNr2BOQiid3JQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自Android Studio的屏幕截图</figcaption></figure><p id="c540" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">圆形定位:</em> </strong>这有助于将一个小部件<em class="la">(假设为小部件‘A’)</em>的中心约束到另一个小部件<em class="la">(假设为小部件‘B’)</em>的中心，处于特定的角度和特定的距离。该角度是相对于从小部件a的中心向上画出的垂直假想线来提供的</p><p id="9343" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实现循环位置所需的属性</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="6bc4" class="mz lj iq mo b gy na nb l nc nd"><strong class="mo ir">app:layout_constraintCircle="[reference to another widget Id]"<br/>app:layout_constraintCircleRadius="[distance in dp]"<br/>app:layout_constraintCircleAngle="[the angle ranging from 0 to 360]"</strong></span></pre><p id="ca69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面给出了圆形定位的图示。</p><div class="mq mr ms mt gt ab cb"><figure class="ne jr nf ng nh ni nj paragraph-image"><img src="../Images/628a581f3825a243eb56da1890ab2f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/0*EZk-M0gZgeIf9vb8.png"/></figure><figure class="ne jr nf ng nh ni nj paragraph-image"><img src="../Images/bd3db072a1a518608f7a215c9ca4f3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/0*PEhKeF1nhSxmpg4f.png"/><figcaption class="jy jz gj gh gi ka kb bd b be z dk nk di nl nm translated">圆形定位。图片来源:谷歌的Android开发者文档。</figcaption></figure></div><p id="8710" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"/></p><p id="2898" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">b) WRAP_CONTENT:维设置为WRAP_CONTENT的小部件只占用所需的空间。但是在使用WRAP_CONTENT时，有时小部件不能遵循约束。</p><p id="201d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如类似下面的内容</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f9d4ef20c0107ffaf83501089c05e773.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*FIwZVHPcdfpywWTHzrfwQw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:截图来自Android Studio</figcaption></figure><p id="1e1f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的例子中，材质文本视图被赋予了以下属性</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="f66d" class="mz lj iq mo b gy na nb l nc nd">android:layout_height="wrap_content"<br/>app:layout_constraintBottom_toTopOf="@+id/appCompatSpinner"</span></pre><p id="ae01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是尽管有约束，文本视图完全与微调器重叠。</p><p id="5fa2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，为了应对这种情况，谷歌为我们提供了两个非常有用的属性，它们如下:</p><ul class=""><li id="16da" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constrainedWidth=”[boolean]”</strong></code></li><li id="d443" class="no np iq ke b kf nx kj ny kn nz kr oa kv ob kz nt nu nv nw bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">app:layout_constrainedHeight=”[boolean]”</strong></code></li></ul><p id="d091" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上述属性使小部件无论是垂直还是水平都遵循约束。</p><p id="b362" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在与WRAP_CONTENT连用时，我们还有以下常用修饰语</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="bb36" class="mz lj iq mo b gy na nb l nc nd">android:minWidth="[value in dp]"<br/>android:minHeight="[value in dp]"<br/>android:maxHeight="[value in dp]"<br/>android:maxWidth="[value in dp]"</span></pre><p id="dd74" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些修饰符仅对WRAP_CONTENT有效。</p><p id="3db4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">c) MATCH_CONSTRAINT:为MATCH_CONSTRAINT指定其维度的小部件将占用所有可用空间。我们用0 dp来表示约束布局中的MATCH_CONSTRAINT。</p><p id="8f43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">MATCH_CONSTRAINT使用以下修饰符:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="7273" class="mz lj iq mo b gy na nb l nc nd">app:layout_constraintWidth_max="[value in dp]"<br/>app:layout_constraintWidth_min="[value in dp]"<br/>app:layout_constraintHeight_max="[value in dp]"<br/>app:layout_constraintHeight_min="[value in dp]"</span></pre><p id="7925" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:在约束布局中，不鼓励使用MATCH_PARENT，因为它不会考虑应用在小部件上的约束。</p><p id="8645" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">比率:</em> </strong>你也可以定义一个widget的一个维度作为另一个的比率。为此，您需要将至少一个受约束的维度设置为0 dp(即MATCH_CONSTRAINT)，并将属性<code class="fe ml mm mn mo b"><strong class="ke ir">layout_constraintDimensionRatio</strong></code>设置为给定的比率。例如:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="eee8" class="mz lj iq mo b gy na nb l nc nd"><strong class="mo ir">&lt;Button android:layout_width="wrap_content"<br/>                   android:layout_height="0dp"<br/>                   app:layout_constraintDimensionRatio="1:1" /&gt;</strong></span></pre><p id="4503" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的代码会将按钮的高度设置为与其宽度相同。</p><p id="5a59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该比率可以表示为:</p><ul class=""><li id="44d4" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">一个浮点值，表示宽度和高度之间的比率</li><li id="228a" class="no np iq ke b kf nx kj ny kn nz kr oa kv ob kz nt nu nv nw bi translated">“宽度:高度”形式的比率</li></ul><p id="3135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果两个尺寸都设置为匹配约束(0 dp)，也可以使用比率。在这种情况下，系统设置满足所有约束的最大尺寸，并保持指定的纵横比。若要根据另一边的尺寸约束某一边，可以预先附加“W”或“H”，分别约束宽度或高度。</p><p id="1425" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，如果一个尺寸受到两个目标的约束(如宽度为0 dp，并以父尺寸为中心)，您可以通过在比率前添加字母W(用于约束宽度)或<code class="fe ml mm mn mo b"><strong class="ke ir">H</strong></code>(用于约束高度)，并用逗号分隔，来指明应约束哪一侧:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="b424" class="mz lj iq mo b gy na nb l nc nd"><strong class="mo ir">&lt;Button android:layout_width="0dp"<br/>                   android:layout_height="0dp"<br/>                   app:layout_constraintDimensionRatio="H,16:9"<br/>                   app:layout_constraintBottom_toBottomOf="parent"<br/>                   app:layout_constraintTop_toTopOf="parent"/&gt;</strong></span></pre><p id="820b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将按照16:9的比例设置按钮的高度，而按钮的宽度将匹配对parent的约束。</p><p id="fcae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">链:</em> </strong>用于创建两个或多个小部件之间的双向连接。根据我的观察，链基本上是线性布局的替代方案。有3种不同的链条可供选择:</p><p id="f4dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">a)扩展:窗口小部件之间以及与边距之间的距离相等。</p><p id="8bbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">b)内部展开:小部件之间的距离相等，而不是边距。</p><p id="8768" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">c)打包:小部件将紧密地打包在一起。</p><p id="15fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用于上述链的属性:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="a27d" class="mz lj iq mo b gy na nb l nc nd">app:layout_constraintHorizontal_chainStyle = "[spread/spread_inside/packed]"</span><span id="b3d7" class="mz lj iq mo b gy oc nb l nc nd">app:layout_constraintVertical_chainStyle = "[spread/spread_inside/packed]"</span></pre><p id="c03e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">加权链:我们也可以有加权链，类似于线性布局中的加权小部件。为此，我们需要根据需要将宽度/高度设置为0 dp。</p><p id="d09a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用于加权链的属性:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="841f" class="mz lj iq mo b gy na nb l nc nd">app:layout_constraintHorizontal_weight = "[value in int]"</span><span id="7f93" class="mz lj iq mo b gy oc nb l nc nd">app:layout_constraintVertical_weight = "[value in int]"</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/19fa629a01a146344ff78cc272fa7816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2egxvU6-8Z_yJ247.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">链约束的图示，图片来源:Google的Android开发者文档。</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3976" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">虚拟助手对象:</h1><p id="a0ab" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">虚拟助手对象(vho)是不在设备上显示的视图，仅用于创建更好的布局。有3种基本vho:</p><p id="f728" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">a) <strong class="ke ir"> <em class="la">指引:</em> </strong>它是一个辅助视图，用来完美对齐其他视图。有两种指导方针:垂直指导方针和水平指导方针。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/92239b543f4cdf78904c97e1614d73ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*_NV7bSrYYCwodpQa12ohZA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对齐三视图的指南，图片来源:来自Android Studio的截图</figcaption></figure><p id="bf88" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">b) <strong class="ke ir"> <em class="la"> Barrier : </em> </strong>这个辅助视图引用多个小部件作为输入，并基于指定边上最极端的小部件创建虚拟指引线。</p><p id="31a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如:</p><p id="1101" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们有两个按钮，@id/button1和@id/button2。将Barrier设置为start，我们将得到以下结果。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5e4bb6c10cd721febd48dcef3da953c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*HP9uPUpkoCNndAJY.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:谷歌的Android开发者文档。</figcaption></figure><p id="a89e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b">Barrier</code>和<code class="fe ml mm mn mo b">Guideline</code>的唯一区别是<code class="fe ml mm mn mo b">Barrier</code>的位置是灵活的，并且总是基于其中包含的多个UI元素的大小，而<code class="fe ml mm mn mo b">Guideline</code>的位置总是固定的。</p><p id="4f24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">c) <strong class="ke ir"> <em class="la">组:</em> </strong>组是一个VHO，用来控制一起引用的一组视图的可见性。</p><p id="3c06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如:</p><pre class="mq mr ms mt gt mv mo mw mx aw my bi"><span id="0e96" class="mz lj iq mo b gy na nb l nc nd">&lt;androidx.constraintlayout.widget.Group<br/>              android:id="@+id/group"<br/>              android:layout_width="wrap_content"<br/>              android:layout_height="wrap_content"<br/>              android:visibility="visible"<br/>              app:constraint_referenced_ids="button4,button9" /&gt;</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="470a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论:</h1><p id="4678" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">约束布局解决了布局创建的许多问题。用它构建的布局，如果遵循适当的规则，布局实际上适应不同的屏幕尺寸。它还简化了大型复杂布局的创建。约束布局的主要优点是它有助于创建平面视图层次。在性能分析中，平面视图层次结构非常有用。</p><p id="0537" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如需了解更多详情，请查看<a class="ae og" href="https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout" rel="noopener ugc nofollow" target="_blank">开发人员文档中的</a>约束布局文档。</p></div></div>    
</body>
</html>