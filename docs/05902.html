<html>
<head>
<title>Go To: good at a low level, generally bad at a high level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转到:低水平良好，高水平一般不好</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-to-good-at-a-low-level-generally-bad-at-a-high-level-43d1e850ac10?source=collection_archive---------5-----------------------#2021-11-18">https://blog.devgenius.io/go-to-good-at-a-low-level-generally-bad-at-a-high-level-43d1e850ac10?source=collection_archive---------5-----------------------#2021-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f75aa5adb39c343319e2dfb5f038260d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L5exY0nY5uw8wFfS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@tarikul_islam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shardar Tarikul Islam </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5eb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">早在1968年，Edsger Dijkstra给ACM 的<em class="lb">通讯编辑写了一封现在很有名的信，通常被总结为“去发表被认为有害的声明”。该出版物是计算机械协会(ACM)的时事通讯。</em></p><p id="9a55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一定意味着Go To总是不好的，你永远不应该使用它。如果你真的读了这封信(我在最后提供了几个副本的链接)，你会发现Dijkstra写的要比这微妙得多。</p><h1 id="d51b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">背景</h1><p id="7a4a" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">您可能已经知道，Go To语句是从程序中的一行到另一行的无条件转移。在Go To的早期，目标行是由其行号指定的。举个例子，</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b2c3" class="mo ld iq mk b gy mp mq l mr ms">140 GOTO 210<br/>210 FOR N = 1 TO 10<br/>220 C etc.</span></pre><p id="e62e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当计算机运行到第140行时，程序执行将跳转到第210行。为了使线路140有价值，需要在线路140和线路210之间有一些线路，比如线路150到200。否则我们可以删除第140行。</p><p id="fa1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为了让140和210之间的代码行有价值，它们必须在程序执行的某个路径上运行。大概是这样的:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="713c" class="mo ld iq mk b gy mp mq l mr ms">130 IF CONDITION GOTO 150<br/>140 GOTO 210<br/>150 C something to do if CONDITION is true<br/>160 C etc. to 200<br/>210 FOR N = 1 TO 10<br/>220 C etc.</span></pre><p id="353a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们要这样做，我们也可以重构一个if块:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="982c" class="mo ld iq mk b gy mp mq l mr ms">130 IF CONDITION THEN<br/>150 C something to do if CONDITION is true<br/>160 C etc. to 200<br/>209 END IF<br/>210 FOR N = 1 TO 10<br/>220 C etc.</span></pre><p id="861f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根本不需要去。</p><p id="9cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这是假设我们使用的语言允许多行If块。如果语言不允许这样的块，第130行可能必须重写为</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a57b" class="mo ld iq mk b gy mp mq l mr ms">130 IF NOT CONDITION THEN GOTO 210</span></pre><p id="014e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且必须删除第209行。与带有两个Go To语句的示例相比，这仍然是一个改进。一般来说，如果你必须使用Go To，最好尽可能少地使用它们。</p><p id="743a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些BASIC方言既允许“<code class="fe mt mu mv mk b">GOTO</code>”，也允许“<code class="fe mt mu mv mk b">GO TO</code>”。其他当代编程语言已经去，但称之为别的东西。效果是一样的:它提供了一个简单的方法来解决眼前的困难，通常会在以后制造另一个困难。</p><p id="9a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go To的一个问题，尽管肯定不是最紧迫的，是行号被认为是神秘的。</p><p id="8ec5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">行号是什么是显而易见的，但是当回顾一个程序时，你实际上必须向上或向下滚动到目标行才能看到它是什么。在那之后，你可能想回到目的地，但是你可能已经失去了你的思路。</p><p id="586b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以单词标签被引入，允许你给一个目标标上更有意义的东西，比如“<code class="fe mt mu mv mk b">existing</code>”或者“<code class="fe mt mu mv mk b">error</code>”。</p><p id="e9eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">QBasic和Visual Basic都有标签。大概90年代以来基本的所有方言都有标签。与FORTRAN类似，是FORTRAN 90添加了标签。我觉得C++从来不用行号，总是用标签做目的行。</p><h1 id="1353" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">限制范围</h1><p id="a6b1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">程序员似乎更关心Go To语句被用来跳转到整个长程序的可能性。所以在某些语言中，Go To的范围在某种程度上是有限的。</p><p id="4f78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在C++中，Go To语句可以跳转到定义它们的函数中的任何地方，但是在任何情况下都不允许跳转到另一个函数。</p><p id="e979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go To语句不得调用跳过必要初始化的跳转。例如，这不会编译:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="158e" class="mo ld iq mk b gy mp mq l mr ms">goto label;<br/>Fraction oneHalf (1, 2);<br/>label: cout &lt;&lt; oneHalf;</span></pre><p id="9040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跳过<code class="fe mt mu mv mk b">oneHalf</code>的初始化意味着计算机不知道当它到达标记行时<code class="fe mt mu mv mk b">oneHalf</code>应该是什么。所以即使其他都检查过了，这个也不会编译。</p><p id="fb37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译器必须跟踪常量和变量的声明时间。你们中的一些人可能会想，编译器必须对任何流控制结构进行检查。这是真的。</p><p id="a50d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你，作为程序员，也需要意识到这些事情，而Go会让你更难跟踪这些事情，更难理解由于这些错误而出现的错误和警告。</p><p id="16f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于C++中的其他流控制结构，您可以使用大括号和缩进对齐来帮助您理解这些事情。以C++中的Try-Catch为例，在这个玩具例子中，假设<code class="fe mt mu mv mk b">level</code>是一个已经在适当的范围内事先声明的<code class="fe mt mu mv mk b">int</code>，</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6b36" class="mo ld iq mk b gy mp mq l mr ms">try {<br/>    int a = 2 * level;<br/>    if (level &lt; MINIMUM) throw level;<br/>    int b = level / a;<br/>} catch (int e) {<br/>    cout &lt;&lt; (a + b);<br/>}</span></pre><p id="f032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，你可以在C++里抛出任何东西。但这是另一天的咆哮。今天这里的重点是<code class="fe mt mu mv mk b">a</code>和<code class="fe mt mu mv mk b">b</code>都在Catch块的范围之外。如果您希望它们都在Catch块的范围内，您必须将它们的声明增加到更低的缩进级别。</p><p id="14db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何缩进定位语句？我猜你不知道。所以你没有缩进的视觉线索来帮助你理解作用域和初始化。</p><h1 id="b97c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Java视角</h1><p id="27b9" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Java语言承诺“编写一次，在任何地方运行”也就是说，在安装了Java运行时环境(JRE)的任何地方运行。</p><p id="4c05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java开发工具包(JDK)中的编译器获取Java语言源代码，并将其编译成“字节码”，不是针对任何特定的物理芯片，而是针对Java虚拟机(JVM)，它是JRE的一部分。</p><p id="b8b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java语言是一种高级语言，能够用几行代码表达像Intel 8086或Motorola 68000这样的芯片需要几十行汇编语言才能表达的东西。</p><p id="054a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JVM指令集比任何物理芯片的指令集都要复杂，但它仍然是相当低级的。以Java语言中的这个简单函数为例:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="607e" class="mo ld iq mk b gy mp mq l mr ms">    public static double circleArea(double radius) {<br/>        return Math.PI * radius * radius;<br/>    }</span></pre><p id="2b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为那是正确的。如果将它加载到文本编辑器中，它会编译成看起来像乱码的JVM字节码。使用javap工具(JDK的一部分)，您可以对字节码有所了解:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4a5b" class="mo ld iq mk b gy mp mq l mr ms">public static double circleArea(double);<br/>    Code:<br/>       0: ldc2_w #3 // double 3.141592653589793d<br/>       3: dload_0<br/>       4: dmul<br/>       5: dload_0<br/>       6: dmul<br/>       7: dreturn</span></pre><p id="3708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有我想象的那么长。不过，有点神秘。</p><p id="d3d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在考虑这样的事情:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e329" class="mo ld iq mk b gy mp mq l mr ms">    while (counter &gt; 0) {<br/>        // TODO: Whatever needs to be done with counter<br/>        counter--;<br/>    }</span></pre><p id="bacb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可能会编译成这样:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e50f" class="mo ld iq mk b gy mp mq l mr ms">       <strong class="mk ir">3:</strong> iload_1<br/>       4: <strong class="mk ir">ifle          89</strong><br/>       7: // the stuff called for by the TODO<br/>      81: iinc          1, -1<br/>      85: <strong class="mk ir">goto          3</strong><br/>      <strong class="mk ir">89:</strong> // maybe some kind of return</span></pre><p id="ac9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第4行的<code class="fe mt mu mv mk b">ifle</code>指令是条件跳转:如果栈顶的值小于等于0，程序执行会跳转到第89行。否则，它前进到第7行。</p><p id="79dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第85行，有一个到第3行的无条件跳转，它加载了一个局部变量(高层源代码中的<code class="fe mt mu mv mk b">counter</code>),这样它就可以与0进行比较，以确定是否再次迭代While循环。</p><p id="025e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以本质上，While循环的右花括号被转换成了一个<code class="fe mt mu mv mk b">goto</code>,它导致了While循环条件的测试。</p><p id="cad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JVM指令集也有<code class="fe mt mu mv mk b">goto_w</code>操作码，可以进行比<code class="fe mt mu mv mk b">goto</code>更远的跳转。然而，如果您注意不要在Java源代码中编写过长的“方法”，编译器可能永远都不需要使用<code class="fe mt mu mv mk b">goto_w</code>，因为<code class="fe mt mu mv mk b">goto</code>可以走得很远。</p><p id="8049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dijkstra呼吁从所有“高级”编程语言中消除Go To语句，他解释说这意味着“除了普通的机器代码之外的一切”。</p><p id="1bae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dijkstra不喜欢Java，他认为它“一团糟”，“需要广泛的广告宣传和积极的推销才能被商业接受”，并认为Haskell是一种更好的语言。</p><p id="b1dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不知道他是否意识到或者欣赏Java的创造者是如何注意到他1968年关于Go To语句的信的(很不幸他在2002年去世，那时Scala还没有发明)。</p><p id="9075" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我假设Dijkstra会认为Java虚拟机(JVM)的操作码足够接近“普通机器码”,不会像高级语言那样受到Go的限制。</p><p id="7ada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<code class="fe mt mu mv mk b">goto</code>在JVM指令集中有一个操作码，并且在Java语言中是一个保留字，但是它没有任何与之相关联的语法。</p><p id="b3c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许Java的更高版本会有Go To语句。然而，更有可能的是，在Java语言中声明<code class="fe mt mu mv mk b">goto</code>为保留字的意图是表明Java永远不会有Go To语句。</p><p id="c837" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的集成开发环境(IDE)，如IntelliJ IDEA或Apache NetBeans，会将一个“<code class="fe mt mu mv mk b">goto</code>”(不在注释或<code class="fe mt mu mv mk b">String</code>文字中)识别为保留字，并将其样式化为与其他保留字相同，例如<code class="fe mt mu mv mk b">for</code>、<code class="fe mt mu mv mk b">while</code>或<code class="fe mt mu mv mk b">try</code>。</p><p id="64dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是IDE也会将“<code class="fe mt mu mv mk b">goto</code>”标记为编译错误，下面有一条红色的曲线，表示源文件无法编译。</p><p id="c2f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我想起了运算符重载，这是另一个没有被纳入Java的C++特性(除了在非常有限的特殊情况下的<code class="fe mt mu mv mk b">String</code>连接)。</p><p id="8700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java的创始人认为操作符重载容易被滥用，使得程序可读性更差。例如，<code class="fe mt mu mv mk b">operator*()</code>对于一个<code class="fe mt mu mv mk b">URLConnection</code>对象可能意味着什么？</p><p id="b230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运算符重载的支持者反驳说，仅仅使用ASCII字符，例如<code class="fe mt mu mv mk b">zsedrcxft()</code>，给函数起一个没有意义或者反直觉的名字也是一样容易的。</p><p id="b176" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的，有人说应该由程序员来决定何时以及如何使用这个特性。Java的创造者剥夺了Java程序员在这个问题上的选择权。</p><p id="5c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写了Java 1.3编译器并发明了Scala的Martin Odersky在Scala中加入了运算符重载，但没有转到。然而，如果你真的想在Scala中使用，你可以使用第三方库。去想想。</p><h1 id="6131" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一般化</h1><p id="db55" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">高级语言中Go To的主要问题是它模糊了程序流程。这在底层并不是一个大问题，因为程序流已经被大量小的、底层的细节以及对标志、寄存器、堆栈等的考虑所掩盖。</p><p id="bd36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，在一碗意大利面中，有一个spaghetto的颜色不同于其他所有的spaghetto。然后，在其他意大利面中追踪一个spaghetto的路径就变得容易了。</p><p id="413f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果没有那一个不同颜色的spaghetto，你真的无法追踪任何特定spaghetto的路径，因为它在被吃掉之前与其他spaghetto在一起，而不打扰它，也许让它变冷。</p><p id="3816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有人确切地知道谁首先使用了术语“意大利面条式代码”，这可能是几乎同时出现在几个不同的人身上的想法之一。</p><p id="e54e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想到了另一个形象的比喻:纠结的电线。假设您有一个电源板，除了一个插座外，其他每个插座都插有设备。但是现在你需要拔掉其中一个设备。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e58378fa26f7dd8fde060a71f6336423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SKx0JPWcjMqpKNkr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@miracleday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃琳娜·莫日维洛</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8e55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是，电源线都缠在一起了。似乎只有两个选择:拔掉所有东西，理顺电缆，这可能是太多的工作了；或者只拔掉一个设备，如果你能找出它的插头是什么，让它的电源线与其他设备纠缠在一起，这可能会在以后引起很多问题。</p><p id="96ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甚至像BASIC这样简单的高级编程语言也提供了几乎在所有情况下都更好的选择。</p><p id="ee3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">早在1995年，我用微软QBasic编写了一个简单的小行星导航游戏。今天回过头来看，我震惊地发现里面有三个<code class="fe mt mu mv mk b">GOTO</code>的实例。今天早些时候看了几分钟后，我意识到我用Go To语句写的实际上是一个不透明的If-Else块。</p><p id="c3e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能我以为QBasic不允许多行If-Else块。但是后来在同一个程序中，我写了多行If-Else块。这显然是年轻的重构失败。</p><p id="3c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对Go To的使用实际上相当平淡:在一个将近八百行的程序中只有三行。但是他们出现得早，也许会立刻给人一种不优雅的印象。</p><p id="0936" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在网上，我找到了一个更老的游戏的源代码，这是一个由迈克·梅菲尔德用HP Basic语言编写的<em class="lb">星际旅行</em>主题游戏。那个游戏里很多跳跃都没那么远。然而，我发现了一个Go-Of语句，它似乎比普通的Go-Of语句更糟糕。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="de03" class="mo ld iq mk b gy mp mq l mr ms">1270  PRINT "COMMAND:";<br/>1280  INPUT A<br/>1290  GOTO A + 1 OF 1410, 1260, 2330, 2530, 2800, 3460, 3560, 4630</span></pre><p id="0f12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<code class="fe mt mu mv mk b">A + 1</code>的值，程序执行分支到选定的行号。QBasic有一些类似的东西，On-Go To，但是参考手册推荐使用Select-Case(这显然很像Java中的Switch-Case)。</p><p id="5cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许在高级语言中，唯一真正需要Go To语句的时候是在跳出深度嵌套循环的时候。但是如果你正在处理深度嵌套的循环，那么Go可能是你最不需要考虑的问题。</p><h1 id="bc60" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">最后</h1><p id="5f2a" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">你需要从底层入手，甚至包括JVM(Java、Scala等)。)和公共语言运行库(CLR，for C#，Visual Basic等。)，这两种芯片都比任何物理芯片都高，如英特尔8086或摩托罗拉68000。</p><p id="b1f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在更高的层次上，像编译成JVM字节码或CLR通用中间语言的语言，甚至像GW-BASIC和HP BASIC这样的BASIC老方言，Go To几乎总是以一种笨拙的方式编写语言已经提供的控制结构。</p><p id="66d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">If，For，While，Select-Case等。，这些都提供了更清晰的构建程序的方法，这样当程序变成“遗留代码”时，就不会引起维护的噩梦</p><p id="417b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后编译器(或解释器，如果适用的话)可以将这些复杂的程序流控制结构翻译成运行时或芯片可以理解的必要的条件和无条件跳转指令，从而使程序员能够看到全局。</p><h1 id="769e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">外部链接</h1><ul class=""><li id="c1a8" class="mx my iq kf b kg ma kk mb ko mz ks na kw nb la nc nd ne nf bi translated"><a class="ae kc" href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf" rel="noopener ugc nofollow" target="_blank">迪杰斯特拉书信的正文</a>。那不是你现在能找到它的唯一地方，但是它在结果上是相当高的。</li><li id="8cae" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html" rel="noopener ugc nofollow" target="_blank">迪杰斯特拉的信</a>由亚利桑那大学再版。</li><li id="8e09" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="https://docs.oracle.com/javase/specs/" rel="noopener ugc nofollow" target="_blank">Java语言和Java虚拟机从Java 6到Java 17的规范</a>。</li></ul></div></div>    
</body>
</html>