<html>
<head>
<title>A crash course on integers in two’s complement in a computer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中二进制补码整数速成班</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4?source=collection_archive---------4-----------------------#2020-10-03">https://blog.devgenius.io/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4?source=collection_archive---------4-----------------------#2020-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2b5dfdf6a9b4d0b17c862eef9d870b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kQwEGus47CueDoLO"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@crissyjarvis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Crisy Jarvis</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unplash</a>上拍摄的照片</figcaption></figure><p id="4cc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">负整数，如 108 和 32768，总是给人类带来一些概念上的障碍，从我们不知道如何理解它们的远祖，到今天试图理解整数是如何被计算机表示的学生。</p><p id="c842" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于本文，我假设您知道整数算术(加法和乘法)的基础知识，并且您知道零和正整数的二进制表示的基础知识。</p><p id="b907" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在计算机中，“原始”整数数据类型的宽度是固定的，例如，八位，组成一个字节。因此，一个无符号字节可以代表从 0 到 0000(0000 0000；这个空格只是为了方便我们快速阅读)改为 255 (as 1111 1111)。</p><p id="3562" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像在十进制中，十进制数字按顺序乘以 10 的幂，所以在二进制中，比特按顺序乘以 2 的幂。因此 255 as 1111 1111 是 2⁷ + 2⁶ + 2⁵ + 2⁴ + 2 + 2 + 2 + 2⁰(记住<em class="ky"> x </em> ⁰始终= 1)。</p><p id="83d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，八位可以代表 2⁸ = 256 个不同的整数。但是，我们如何用八位数字表示像 47 这样的负整数呢？</p><p id="c079" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的符号中，我们使用减号作为前缀。在等间距字体中，我们几乎总是使用破折号，因为它几乎无法与正确的减号区分开来。</p><p id="28b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了清楚起见，有时我们用加号作为正数的前缀。但是因为它被认为是默认的，所以通常被省略。负号或其替代符号必须用于负数。</p><p id="4c61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在计算机芯片上，没有单独的符号可以用作减号，它都是 0 和 1。</p><p id="f57a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不知道是谁想出了这个标志位的主意。这是一个非常简单的想法:你取最左边的一位，用它作为一个布尔标志来判断这个数字是不是负数。</p><p id="3f2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，有符号字节中的 47 将是 0010 1111，就像无符号字节一样，47 将是 1010 1111。很简单。</p><p id="2e94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过，这有几个问题。首先，这为 0 提供了两种不同的表示:明显的表示为 0000 0000，而“负零”表示为 1000 0000。</p><p id="2491" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">扩大转换不一致。为了将一个有符号的字节扩大到一个有符号的 16 位“字”，我们不能仅仅复制位模式并填充额外的位，我们必须潜在地改变原始的位模式。</p><p id="6b50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，0010 1111 将扩展到 0000 0000 0010 1111，这将保持原始位模式不变，但 1010 1111 将扩展到 1000 0000 0010 1111，这将改变原始位模式的最左边位。</p><p id="4f52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无符号整数的扩大转换将不同于有符号整数的扩大转换。收缩转换也有类似的问题。</p><p id="b522" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个更严重的问题是算术变得有多复杂。加法初看起来很容易。例如，47 + 53 = 100 将是 0010 1111 + 0011 0101 = 0110 0100。就像十进制一样。</p><p id="fedd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是看看 4753 = 6，这将是 0010 1111 0011 0101 = 1000 1010。计算机芯片是如何得到那个结果的？或者 53+6 = 47 as 1011 0101+0000 1010 = 1010 1111 怎么样？</p><p id="5698" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的问题是有符号值和一些无符号值的方向相反，因此大大增加了加法和减法的复杂性。例如:</p><ul class=""><li id="cc49" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">1010 1110 是无符号的 174，但应该是有符号的 46？</li><li id="d94a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010 1111 是无符号的 175，但应该是有符号的 47？</li><li id="92f0" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011 0000 是无符号的 176，但应该是有符号的 48？</li></ul><p id="9d7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无符号数和有符号数的绝对值都在上升，但有符号数的值在下降。</p><p id="4430" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果数值方向一致就好了，因为这样芯片就可以执行加法和减法，而不用考虑数字是有符号的还是无符号的。</p><p id="c320" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比较也有问题。明明 175&lt; 176, but how does the chip determine that −47 &gt;48？知道数字是有符号的还是无符号的可能是一个高层次的细节，不应该关心芯片。</p><p id="dc99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是二进制补码的用武之地。基本上，我们所做的是将最大的无符号值(字节为 255)指定为有符号值 1，次大的无符号值为 2，次大的为 3，依此类推，直到没有前导 1 的最大无符号值为止；作为有符号的值，该数字仍然是正的。因此:</p><ul class=""><li id="93c3" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">1010 1110 是无符号 174，有符号 82</li><li id="7ff3" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010 1111 是无符号 175，有符号 81</li><li id="9bd8" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011 0000 是无符号 176，有符号 80</li></ul><p id="d5ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，无符号数的绝对值在上升，有符号数的绝对值在下降，但重要的是，它们的值都在上升，这使得加法和减法更容易，涉及相同符号数的比较也更容易。</p><p id="ad0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，有一个不连续性:</p><ul class=""><li id="e9ba" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">0111 1110 是无符号的 126 和有符号的 126</li><li id="bbc2" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0111 1111 是无符号 127 和有符号 127</li><li id="167f" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000 0000 是无符号 128 和有符号 128</li><li id="77e3" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000 0001 是无符号的 129 和有符号的 127</li></ul><p id="9fa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有不对称:一个有符号的字节可以代表 128 个负整数中的一个，也可以代表 127 个正整数中的一个，也可以代表 0，现在可以说是稍微“偏离中心”了。</p><p id="f2c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于算术运算的简单性来说，这是一个很小的代价。例如，42 + 5 = 47 是 0010 1010 + 0000 0101 = 0010 1111，42+5 = 37 是 1101 0110 + 0000 0101 = 1101 1011，就像无符号字节中的 214 + 5 = 219 一样。</p><p id="06f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再来看看 4753 = 6，加上二进制补码，它就是 0010 1111 0011 0101 = 1111 1010。芯片是如何得到那个结果的？</p><p id="a9f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不确定。我知道一个人可以得到这个结果的方法:想象被减数在左边有一个“额外的”1 位，减数在左边有一个“额外的”0 位。</p><p id="0b29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么示例减法就是 1 0010 1111 0 0011 0101 = 0 1111 1010。作为大于字节的值，这实际上是 30353 = 250，然后作为有符号字节的 250 被理解为 6，它通过从无符号的 255 向后计数为有符号的 1 来检验。</p><p id="1fc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有必要从被减数的“额外”1 中“借用”,我们应该简单地丢弃它。我强烈怀疑这是芯片进行计算的方式。</p><p id="cb03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更有可能的情况是，芯片将减数乘以 1，然后与被减数相加。说到底，减法只是反过来的加法。</p><p id="2209" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我需要解释如何在二进制补码中乘以 1。其实挺简单的，真的。你切换所有的位(0 变成 1，1 变成 0)，然后加 1。</p><p id="4421" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，要获得 53×(1)= 53，我们从 53 开始，将 0011 0101 转换为 1100 1010。这当然有错误的平价。但是我们很容易通过加 1 得到 1100 1011 来解决这个问题。作为一个无符号字节，那就是 203，比 256 少了 53。</p><p id="c27f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将加法运算 47+(53)= 6 表示为 0010 1111 + 1100 1011 = 1111 1010，它是无符号 250，有符号 6。一切都核实了。</p><p id="dac2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而且“负零”也没有问题我们看到，当我们取 0000 0000 时，0×(1)= 0，将所有位切换到 1111 1111，然后加上 1，溢出到 1 0000 0000。由于字节是一个 Procrustes 床，有效的 1 被砍掉，我们只剩下 0000 0000。</p><p id="a3f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二进制补码中正负之间的不对称确实会导致一个恼人的小问题，即最小负值(对于有符号字节为 128)。</p><p id="0bbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以 128 是 1000 0000。切换，我们得到 0111 1111，加上 1 我们得到 1000 0000。我们又回到了起点。</p><p id="20b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再做一个减法练习:47 67 = 47+(67)= 114。我们有 1101 0001 + 1011 1101 = 1 1000 1110。作为无符号字节 209 和 189 的总和，这将溢出，398 将被重新解释为 142，即 256114。</p><p id="8892" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在二进制补码中，这就很好了:如果我们取 1000 1110，将这些位切换到 0111 0001 并加上 1，我们得到 0111 0010，也就是，你猜对了… 114。</p><p id="1034" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有符号字节乘法中的一些溢出也是可以接受的，即使它们对于与无符号数相同的字节来说可能是不可接受的。以 253 × 5 = 1265 为例。</p><p id="5e92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不管有符号还是无符号，我们都可以用和十进制乘法几乎一样的方式来做二进制乘法:200×5+50×5+3×5 = 1000+250+15 = 1265。</p><p id="c8b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样在二进制中，1111 1101×0000 0101 = 1111 1101×0000 0100+1111 1101×0000 0001 = 11 1111 0100+1111 1101 = 100 1111 0001。这肯定溢出了字节。</p><p id="8d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是对于 3×5 = 15，我们有 1111 1101×0000 0101 = 1111 1101×0000 0100+1111 1101×0000 0001 = 11 1111 0100+1111 1101 = 100 1111 0001。去掉前面的 100，我们剩下 1111 0001。切换给出 0000 1110 的位并加 1 得到 0000 1111，也就是 15。结果证明，溢出根本不是问题。</p><p id="bb96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即便如此，字节，不管是有符号的还是无符号的，对于我们几乎所有的实际计算需求来说都太小了。然后我们取两个字节，把它们变成一个“单词”16 位字可以代表 2 ⁶ = 65536 个不同的整数。</p><p id="2389" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两个“字”组成一个“双字”,表示 2 = 4294967296 个不同的整数。这听起来很多，但不足以计算 Unix 操作系统存在的毫秒数。即使没有签署，它也会从 1970 年开始，到 1970 年结束。</p><p id="402d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以两个“双字”组成一个“四字”，可以表示 2⁶⁴ = 18446744073709551616 个不同的整数。尽管这对于强大的加密技术来说还不够，但足以计算从 1970 年到未来数百万年的毫秒数。</p><p id="1e39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为永远不会有 128 位芯片被普遍使用。在某些时候，这就像给剃须刀增加刀片:除了第四个或第五个刀片，额外的刀片并不能真正增加你真正需要的任何东西。</p><p id="b829" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你真的需要使用大于 2⁶⁴的整数时，许多编程语言，比如 Java，提供了某种“大整数”,它可以由程序可用的字节数组成。</p><p id="5374" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在书籍和像本文这样的文章中，用二进制写出数字通常是不切实际的，尤其是对于宽度超过一个字节的数据类型。并且以十进制书写的数字的位模式对于人眼来说通常不明显。</p><p id="e10e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这个原因，八进制(基数 8)和十六进制(基数 16)经常在需要传递位模式时使用，因为人们写和读所有这些 0 和 1 是令人厌倦的。</p><p id="55bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">八进制的一位对应三位，十六进制的一位对应四位，非常容易辨别位模式。在十六进制中，我们看到:</p><ul class=""><li id="488f" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">0000 当然是 0</li><li id="13de" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0001 当然是 1</li><li id="d54a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0010 是 2</li><li id="38fc" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0011 是 3</li><li id="a2d4" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0100 是 4</li><li id="9b4e" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0101 是 5</li><li id="3c2f" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0110 是 6</li><li id="a1b7" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0111 是 7</li><li id="93cb" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000 是 8</li><li id="7f5a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1001 是 9</li><li id="7029" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010 是一个(十进制的 10)</li><li id="338c" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011 是 B(十进制的 11)</li><li id="2fac" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1100 是 C(十进制的 12)</li><li id="4ba6" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1101 是 D(十进制的 13)</li><li id="cdbf" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1110 是 E(十进制的 14)并且</li><li id="9cca" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1111 是 F(十进制 15)。</li></ul><p id="a537" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于十六进制，很容易理解 1 是带符号字节中的 FF，FFFF 是“字”，FFFF·FFFF 是“双字”，FFFF·FFFF·FFFF·FFFF 是“四字”</p><p id="094d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用二进制补码进行扩展转换很容易:只需使额外的位与符号位相同。因此，有符号字节 3F 扩展到 003F，0000 003F，0000 0000 0000 003F，有符号字节 D1 扩展到 FFD1，FFFF FFD1，FFFF FFFF FFFF FFD1。与无符号字节相同。</p><h1 id="ba0d" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">主要计算机编程语言中的整数</h1><p id="00a5" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">Java 中，四种原始整数数据类型，都有符号:<code class="fe mq mr ms mt b">byte</code>、<code class="fe mq mr ms mt b">short</code>、<code class="fe mq mr ms mt b">int</code>和<code class="fe mq mr ms mt b">long</code>。它们对应的对象包装器分别是<code class="fe mq mr ms mt b">Byte</code>、<code class="fe mq mr ms mt b">Short</code>、<code class="fe mq mr ms mt b">Integer</code>和<code class="fe mq mr ms mt b">Long</code>，它们各自都有方便的静态常量<code class="fe mq mr ms mt b">MIN_VALUE</code>和<code class="fe mq mr ms mt b">MAX_VALUE</code>。</p><p id="3d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，我想你可以把代表基本多语言平面的 Unicode 字符的<code class="fe mq mr ms mt b">char</code>看作一个无符号整数类型。</p><p id="6e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Scala 和 Kotlin 中也有相同的类型。在 Scala 中它们是<code class="fe mq mr ms mt b">Byte</code>、<code class="fe mq mr ms mt b">Short</code>、<code class="fe mq mr ms mt b">Int</code>和<code class="fe mq mr ms mt b">Long</code>。Java 对象包装器可以通过以“<code class="fe mq mr ms mt b">java.lang.</code>”开头的完全限定名来访问。我想科特林也是这样，我得查一下。</p><p id="8ff0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为 Java 虚拟机编写时，我们认为这些数据类型是理所当然的。在 C++的黄金时代，你不能指望“<code class="fe mq mr ms mt b">signed int</code>”在你能编译 C++的每台计算机上都有相同的含义。</p><p id="ea92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 C#中，有基本的有符号和无符号整数类型。我的理解是，这些在使用公共语言运行库的编程语言中都是一致的。</p><p id="5fb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript 只有一种内置的数字类型，而且是浮点型。浮点运算有一大堆令人头疼的问题。但这是另一篇文章的主题，一篇更长的文章。</p></div></div>    
</body>
</html>