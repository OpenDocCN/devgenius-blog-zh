<html>
<head>
<title>A crash course on integers in two’s complement in a computer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中二进制补码整数速成班</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4?source=collection_archive---------4-----------------------#2020-10-03">https://blog.devgenius.io/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4?source=collection_archive---------4-----------------------#2020-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2b5dfdf6a9b4d0b17c862eef9d870b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kQwEGus47CueDoLO"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@crissyjarvis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Crisy Jarvis</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unplash</a>上拍摄的照片</figcaption></figure><p id="4cc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">负整数，如108和32768，总是给人类带来一些概念上的障碍，从我们不知道如何理解它们的远祖，到今天试图理解整数是如何被计算机表示的学生。</p><p id="c842" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于本文，我假设您知道整数算术(加法和乘法)的基础知识，并且您知道零和正整数的二进制表示的基础知识。</p><p id="b907" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在计算机中，“原始”整数数据类型的宽度是固定的，例如，八位，组成一个字节。因此，一个无符号字节可以代表从0到0000(0000 0000；这个空格只是为了方便我们快速阅读)改为255 (as 1111 1111)。</p><p id="3562" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像在十进制中，十进制数字按顺序乘以10的幂，所以在二进制中，比特按顺序乘以2的幂。因此255 as 1111 1111是2⁷ + 2⁶ + 2⁵ + 2⁴ + 2 + 2 + 2 + 2⁰(记住<em class="ky"> x </em> ⁰始终= 1)。</p><p id="83d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，八位可以代表2⁸ = 256个不同的整数。但是，我们如何用八位数字表示像47这样的负整数呢？</p><p id="c079" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的符号中，我们使用减号作为前缀。在等间距字体中，我们几乎总是使用破折号，因为它几乎无法与正确的减号区分开来。</p><p id="28b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了清楚起见，有时我们用加号作为正数的前缀。但是因为它被认为是默认的，所以通常被省略。负号或其替代符号必须用于负数。</p><p id="4c61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在计算机芯片上，没有单独的符号可以用作减号，它都是0和1。</p><p id="f57a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不知道是谁想出了这个标志位的主意。这是一个非常简单的想法:你取最左边的一位，用它作为一个布尔标志来判断这个数字是不是负数。</p><p id="3f2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，有符号字节中的47将是0010 1111，就像无符号字节一样，47将是1010 1111。很简单。</p><p id="2e94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过，这有几个问题。首先，这为0提供了两种不同的表示:明显的表示为0000 0000，而“负零”表示为1000 0000。</p><p id="2491" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">扩大转换不一致。为了将一个有符号的字节扩大到一个有符号的16位“字”，我们不能仅仅复制位模式并填充额外的位，我们必须潜在地改变原始的位模式。</p><p id="6b50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，0010 1111将扩展到0000 0000 0010 1111，这将保持原始位模式不变，但1010 1111将扩展到1000 0000 0010 1111，这将改变原始位模式的最左边位。</p><p id="4f52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无符号整数的扩大转换将不同于有符号整数的扩大转换。收缩转换也有类似的问题。</p><p id="b522" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个更严重的问题是算术变得有多复杂。加法初看起来很容易。例如，47 + 53 = 100将是0010 1111 + 0011 0101 = 0110 0100。就像十进制一样。</p><p id="fedd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是看看4753 = 6，这将是0010 1111 0011 0101 = 1000 1010。计算机芯片是如何得到那个结果的？或者53+6 = 47 as 1011 0101+0000 1010 = 1010 1111怎么样？</p><p id="5698" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的问题是有符号值和一些无符号值的方向相反，因此大大增加了加法和减法的复杂性。例如:</p><ul class=""><li id="cc49" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">1010 1110是无符号的174，但应该是有符号的46？</li><li id="d94a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010 1111是无符号的175，但应该是有符号的47？</li><li id="92f0" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011 0000是无符号的176，但应该是有符号的48？</li></ul><p id="9d7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无符号数和有符号数的绝对值都在上升，但有符号数的值在下降。</p><p id="4430" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果数值方向一致就好了，因为这样芯片就可以执行加法和减法，而不用考虑数字是有符号的还是无符号的。</p><p id="c320" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比较也有问题。明明175&lt; 176, but how does the chip determine that −47 &gt;48？知道数字是有符号的还是无符号的可能是一个高层次的细节，不应该关心芯片。</p><p id="dc99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是二进制补码的用武之地。基本上，我们所做的是将最大的无符号值(字节为255)指定为有符号值1，次大的无符号值为2，次大的为3，依此类推，直到没有前导1的最大无符号值为止；作为有符号的值，该数字仍然是正的。因此:</p><ul class=""><li id="93c3" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">1010 1110是无符号174，有符号82</li><li id="7ff3" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010 1111是无符号175，有符号81</li><li id="9bd8" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011 0000是无符号176，有符号80</li></ul><p id="d5ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，无符号数的绝对值在上升，有符号数的绝对值在下降，但重要的是，它们的值都在上升，这使得加法和减法更容易，涉及相同符号数的比较也更容易。</p><p id="ad0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，有一个不连续性:</p><ul class=""><li id="e9ba" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">0111 1110是无符号的126和有符号的126</li><li id="bbc2" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0111 1111是无符号127和有符号127</li><li id="167f" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000 0000是无符号128和有符号128</li><li id="77e3" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000 0001是无符号的129和有符号的127</li></ul><p id="9fa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有不对称:一个有符号的字节可以代表128个负整数中的一个，也可以代表127个正整数中的一个，也可以代表0，现在可以说是稍微“偏离中心”了。</p><p id="f2c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于算术运算的简单性来说，这是一个很小的代价。例如，42 + 5 = 47是0010 1010 + 0000 0101 = 0010 1111，42+5 = 37是1101 0110 + 0000 0101 = 1101 1011，就像无符号字节中的214 + 5 = 219一样。</p><p id="06f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再来看看4753 = 6，加上二进制补码，它就是0010 1111 0011 0101 = 1111 1010。芯片是如何得到那个结果的？</p><p id="a9f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不确定。我知道一个人可以得到这个结果的方法:想象被减数在左边有一个“额外的”1位，减数在左边有一个“额外的”0位。</p><p id="0b29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么示例减法就是1 0010 1111 0 0011 0101 = 0 1111 1010。作为大于字节的值，这实际上是30353 = 250，然后作为有符号字节的250被理解为6，它通过从无符号的255向后计数为有符号的1来检验。</p><p id="1fc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有必要从被减数的“额外”1中“借用”,我们应该简单地丢弃它。我强烈怀疑这是芯片进行计算的方式。</p><p id="cb03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更有可能的情况是，芯片将减数乘以1，然后与被减数相加。说到底，减法只是反过来的加法。</p><p id="2209" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我需要解释如何在二进制补码中乘以1。其实挺简单的，真的。你切换所有的位(0变成1，1变成0)，然后加1。</p><p id="4421" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，要获得53×(1)= 53，我们从53开始，将0011 0101转换为1100 1010。这当然有错误的平价。但是我们很容易通过加1得到1100 1011来解决这个问题。作为一个无符号字节，那就是203，比256少了53。</p><p id="c27f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将加法运算47+(53)= 6表示为0010 1111 + 1100 1011 = 1111 1010，它是无符号250，有符号6。一切都核实了。</p><p id="dac2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而且“负零”也没有问题我们看到，当我们取0000 0000时，0×(1)= 0，将所有位切换到1111 1111，然后加上1，溢出到1 0000 0000。由于字节是一个Procrustes床，有效的1被砍掉，我们只剩下0000 0000。</p><p id="a3f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二进制补码中正负之间的不对称确实会导致一个恼人的小问题，即最小负值(对于有符号字节为128)。</p><p id="0bbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以128是1000 0000。切换，我们得到0111 1111，加上1我们得到1000 0000。我们又回到了起点。</p><p id="20b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再做一个减法练习:47 67 = 47+(67)= 114。我们有1101 0001 + 1011 1101 = 1 1000 1110。作为无符号字节209和189的总和，这将溢出，398将被重新解释为142，即256114。</p><p id="8892" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在二进制补码中，这就很好了:如果我们取1000 1110，将这些位切换到0111 0001并加上1，我们得到0111 0010，也就是，你猜对了… 114。</p><p id="1034" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有符号字节乘法中的一些溢出也是可以接受的，即使它们对于与无符号数相同的字节来说可能是不可接受的。以253 × 5 = 1265为例。</p><p id="5e92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不管有符号还是无符号，我们都可以用和十进制乘法几乎一样的方式来做二进制乘法:200×5+50×5+3×5 = 1000+250+15 = 1265。</p><p id="c8b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样在二进制中，1111 1101×0000 0101 = 1111 1101×0000 0100+1111 1101×0000 0001 = 11 1111 0100+1111 1101 = 100 1111 0001。这肯定溢出了字节。</p><p id="8d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是对于3×5 = 15，我们有1111 1101×0000 0101 = 1111 1101×0000 0100+1111 1101×0000 0001 = 11 1111 0100+1111 1101 = 100 1111 0001。去掉前面的100，我们剩下1111 0001。切换给出0000 1110的位并加1得到0000 1111，也就是15。结果证明，溢出根本不是问题。</p><p id="bb96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即便如此，字节，不管是有符号的还是无符号的，对于我们几乎所有的实际计算需求来说都太小了。然后我们取两个字节，把它们变成一个“单词”16位字可以代表2 ⁶ = 65536个不同的整数。</p><p id="2389" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两个“字”组成一个“双字”,表示2 = 4294967296个不同的整数。这听起来很多，但不足以计算Unix操作系统存在的毫秒数。即使没有签署，它也会从1970年开始，到1970年结束。</p><p id="402d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以两个“双字”组成一个“四字”，可以表示2⁶⁴ = 18446744073709551616个不同的整数。尽管这对于强大的加密技术来说还不够，但足以计算从1970年到未来数百万年的毫秒数。</p><p id="1e39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为永远不会有128位芯片被普遍使用。在某些时候，这就像给剃须刀增加刀片:除了第四个或第五个刀片，额外的刀片并不能真正增加你真正需要的任何东西。</p><p id="b829" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你真的需要使用大于2⁶⁴的整数时，许多编程语言，比如Java，提供了某种“大整数”,它可以由程序可用的字节数组成。</p><p id="5374" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在书籍和像本文这样的文章中，用二进制写出数字通常是不切实际的，尤其是对于宽度超过一个字节的数据类型。并且以十进制书写的数字的位模式对于人眼来说通常不明显。</p><p id="e10e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这个原因，八进制(基数8)和十六进制(基数16)经常在需要传递位模式时使用，因为人们写和读所有这些0和1是令人厌倦的。</p><p id="55bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">八进制的一位对应三位，十六进制的一位对应四位，非常容易辨别位模式。在十六进制中，我们看到:</p><ul class=""><li id="488f" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">0000当然是0</li><li id="13de" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0001当然是1</li><li id="d54a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0010是2</li><li id="38fc" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0011是3</li><li id="a2d4" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0100是4</li><li id="9b4e" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0101是5</li><li id="3c2f" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0110是6</li><li id="a1b7" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">0111是7</li><li id="93cb" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1000是8</li><li id="7f5a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1001是9</li><li id="7029" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1010是一个(十进制的10)</li><li id="338c" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1011是B(十进制的11)</li><li id="2fac" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1100是C(十进制的12)</li><li id="4ba6" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1101是D(十进制的13)</li><li id="cdbf" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1110是E(十进制的14)并且</li><li id="9cca" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">1111是F(十进制15)。</li></ul><p id="a537" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于十六进制，很容易理解1是带符号字节中的FF，FFFF是“字”，FFFF·FFFF是“双字”，FFFF·FFFF·FFFF·FFFF是“四字”</p><p id="094d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用二进制补码进行扩展转换很容易:只需使额外的位与符号位相同。因此，有符号字节3F扩展到003F，0000 003F，0000 0000 0000 003F，有符号字节D1扩展到FFD1，FFFF FFD1，FFFF FFFF FFFF FFD1。与无符号字节相同。</p><h1 id="ba0d" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">主要计算机编程语言中的整数</h1><p id="00a5" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">Java中，四种原始整数数据类型，都有符号:<code class="fe mq mr ms mt b">byte</code>、<code class="fe mq mr ms mt b">short</code>、<code class="fe mq mr ms mt b">int</code>和<code class="fe mq mr ms mt b">long</code>。它们对应的对象包装器分别是<code class="fe mq mr ms mt b">Byte</code>、<code class="fe mq mr ms mt b">Short</code>、<code class="fe mq mr ms mt b">Integer</code>和<code class="fe mq mr ms mt b">Long</code>，它们各自都有方便的静态常量<code class="fe mq mr ms mt b">MIN_VALUE</code>和<code class="fe mq mr ms mt b">MAX_VALUE</code>。</p><p id="3d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，我想你可以把代表基本多语言平面的Unicode字符的<code class="fe mq mr ms mt b">char</code>看作一个无符号整数类型。</p><p id="6e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Scala和Kotlin中也有相同的类型。在Scala中它们是<code class="fe mq mr ms mt b">Byte</code>、<code class="fe mq mr ms mt b">Short</code>、<code class="fe mq mr ms mt b">Int</code>和<code class="fe mq mr ms mt b">Long</code>。Java对象包装器可以通过以“<code class="fe mq mr ms mt b">java.lang.</code>”开头的完全限定名来访问。我想科特林也是这样，我得查一下。</p><p id="8ff0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为Java虚拟机编写时，我们认为这些数据类型是理所当然的。在C++的黄金时代，你不能指望“<code class="fe mq mr ms mt b">signed int</code>”在你能编译C++的每台计算机上都有相同的含义。</p><p id="ea92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在C#中，有基本的有符号和无符号整数类型。我的理解是，这些在使用公共语言运行库的编程语言中都是一致的。</p><p id="5fb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript只有一种内置的数字类型，而且是浮点型。浮点运算有一大堆令人头疼的问题。但这是另一篇文章的主题，一篇更长的文章。</p></div></div>    
</body>
</html>