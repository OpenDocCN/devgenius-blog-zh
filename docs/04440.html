<html>
<head>
<title>[Docker] Quick-Tips: 4 Easy Steps to get the most out of Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Docker]快速提示:充分利用容器的4个简单步骤</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-quick-tips-dcc5d9a97256?source=collection_archive---------6-----------------------#2021-03-17">https://blog.devgenius.io/docker-quick-tips-dcc5d9a97256?source=collection_archive---------6-----------------------#2021-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/10d12b573cc15f20d3842aeb10d5605e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9ELHKj_6za2vvXiwgHzKg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在任何地方运行您的项目，并随时进行优化</figcaption></figure><p id="1c66" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每个人都同意集装箱是未来的发展方向。从开发环境<strong class="kb io">到生产</strong>。从小团队到大团队的协作和跨团队更顺畅的工作流程。即插即用系统的不同组件，交换版本，扩展…这样的例子不胜枚举。</p><p id="d6eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">希望下面的技巧可以帮助您解决问题，或者想出改善开发环境的好方法。例如，一些安全的公司网络不允许您的构建工具从公共网络获取映像，在其他情况下，您可能需要调整映像的初始化，安装插件，或者修改环境变量可能不可用的默认配置。此外，本文旨在为您提供一些基本的技巧，可能有助于您提高性能、解决部署问题，甚至减小图像的大小。</p><p id="2b0f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设对不同的操作系统发行版有一些基本的了解，对docker上的基本网络设置有一个概念。如果没有，你可以遵循官方图片和博客上的简单指南，这最终会让你对幕后发生的事情有一个更好的了解。</p><h1 id="a9f1" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.从简单开始，收集信息。</h1><p id="be2f" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">首先从<strong class="kb io">的小变化</strong>开始，不要破坏你当前的开发&amp;部署过程。一个通用的网上搜索:“<em class="ma"> &lt;工程构件&gt;码头工</em>”，会带你走多远。除非你正在开始一个新项目，那么你所需要的，就是挑选一个对你来说更有意义的完整指南，并开始在它的基础上进行构建。</p><p id="eb28" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将会有大量的博客或官方帖子讲述如何将项目的一个组件(例如，节点服务器、测试套件、数据库)容器化，回顾它们，尽可能多地理解它们，并记住在它变得对你来说太难应付之前后退一步。</p><p id="4919" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">关注<em class="ma">官方</em> <em class="ma">图片</em>和官方<em class="ma">最佳实践</em>，经常检查日期，并快速查看源代码(如果提供的话)。请记住，有些图像只是其他图像的包装。你更喜欢<em class="ma">接近源代码，</em>这将有助于你以后保持所有的东西都是最新版本。</p><h2 id="a569" class="mb ky in bd kz mc md dn ld me mf dp lh kk mg mh ll ko mi mj lp ks mk ml lt mm bi translated">你会发现有用的东西:</h2><ul class=""><li id="4121" class="mn mo in kb b kc lv kg lw kk mp ko mq ks mr kw ms mt mu mv bi translated"><a class="ae mw" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> docker-desktop </a></li><li id="9251" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw ms mt mu mv bi translated">我发现这是定制脚本的一个很好的替代品，你最终可能会创建这些脚本来构建、旋转和推送图像。使用docker-compose文件，您可以描述每个容器将如何运行。例如，设置不会在映像中固定的<em class="ma">环境变量</em>，或者向其传递<em class="ma">参数</em>，卷挂载、网络配置等等。</li><li id="1a1c" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw ms mt mu mv bi translated"><a class="ae mw" href="https://docs.docker.com/engine/reference/builder/#usage" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a> <br/>在你开始玩它之前，先对:<a class="ae mw" href="https://www.google.com/search?sxsrf=ALeKk03-RkcEIeXRlUedNFxFkaU1aX07sw%3A1615033407929&amp;ei=P3RDYIufOI-dgQb9zqj4CQ&amp;q=dockerfile+CMD+vs+ENTRYPOINT&amp;oq=dockerfile+CMD+vs+ENTRYPOINT&amp;gs_lcp=Cgdnd3Mtd2l6EAMyAggAMgYIABAHEB4yBggAEAUQHjIECAAQHjoHCAAQRxCwAzoICAAQCBAHEB46CAgAEA0QBRAeOgQIABANOgYIABANEB46CAgAEAgQDRAeOggIABAHEAUQHlCnJ1iSL2CwMWgBcAJ4AIABuwKIAcQIkgEIMTAuMS4wLjGYAQCgAQGqAQdnd3Mtd2l6yAEIwAEB&amp;sclient=gws-wiz&amp;ved=0ahUKEwjLutGk1JvvAhWPTsAKHX0nCp8Q4dUDCA0&amp;uact=5" rel="noopener ugc nofollow" target="_blank"> CMD vs ENTRYPOINT </a>有个基本的了解。<br/>还要确保你了解图层是如何工作的，以及如何保持最终图像的最小尺寸。不需要尝试达到完美的设置，只是让一些东西开始运行。</li></ul><blockquote class="nc nd ne"><p id="b090" class="jz ka ma kb b kc kd ke kf kg kh ki kj nf kl km kn ng kp kq kr nh kt ku kv kw ig bi translated">每当你注意到一项任务让你“走得太远”并且开始变得不那么容易理解…确保你<strong class="kb io">放弃它</strong>，阅读替代的博客资源。<em class="in">部署世界是巨大的，如果你正在阅读这篇文章，很可能你不是运营部的主要角色。<br/>把黑魔法留给他们，保证不踩到他们的脚趾；)</em></p></blockquote><h1 id="fcad" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.Dockerfile文件、层和步骤</h1><p id="3687" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">您可能已经猜到，理解Dockerfile很重要，它创建可以缓存和重用的层的方式。最重要的是，<a class="ae mw" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>将帮助你为你的图像定义和重用一系列层。</p><blockquote class="nc nd ne"><p id="d3dc" class="jz ka ma kb b kc kd ke kf kg kh ki kj nf kl km kn ng kp kq kr nh kt ku kv kw ig bi translated">始终考虑构建和运行项目所采取的手动步骤，注意模式，并尝试分别迁移/构建每组步骤。类似于你如何构建软件，拆分功能和重用代码。如果你需要复制粘贴太多东西，当然有更好的方法。</p></blockquote><p id="f97c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">解释这一部分的最好方法是举例。这是一个<strong class="kb io">节点服务</strong>伴随着一个<strong class="kb io">反应CRA </strong>。Dockerfile文件应该描述构建，分阶段安装每个项目的依赖项，构建客户端包，运行测试，最后为应用程序提供服务。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">NodeJS和ReactJS应用程序的多阶段docker文件示例</figcaption></figure><h2 id="c1ec" class="mb ky in bd kz mc md dn ld me mf dp lh kk mg mh ll ko mi mj lp ks mk ml lt mm bi translated">分析</h2><p id="de0d" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在上面的例子中:</p><ol class=""><li id="9f09" class="mn mo in kb b kc kd kg kh kk no ko np ks nq kw nr mt mu mv bi translated">每个阶段的L <strong class="kb io">层</strong>将成为<strong class="kb io">缓存友好的</strong>。我们试图保持内容预期改变的层，不同于更静态的层(例如，源代码复制与npm模块安装)</li><li id="1ff5" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw nr mt mu mv bi translated">阶段也是如此。我们拆分了<strong class="kb io">步骤</strong>，我们期望某些部分<strong class="kb io">是缓存友好的</strong>。例如，如果我们只更新源代码，每个项目的node_modules安装更有可能保持不变。另一方面，如果我们只更新npm_module的<em class="ma"/>(非中断)更改，源代码阶段将来自缓存。把它想成<em class="ma">帮手，临时工，形象。</em></li><li id="2593" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw nr mt mu mv bi translated">本例中的阶段5是一个<em class="ma">占位符</em>，用于与webclient项目保持一致。如果你用传送钳的话，会放在那里。</li><li id="ea68" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw nr mt mu mv bi translated">最后的<strong class="kb io">阶段</strong>是我们需要<em class="ma">部署</em>的图像。安装npm_modules所需的所有先前的层没有作为最终映像的<strong class="kb io">大小</strong>添加。换句话说，我们创建一个虚拟环境，提供所有工具来构建我们的源代码，测试它，然后我们在一个较小的图像库中复制最终结果。</li><li id="b67c" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw nr mt mu mv bi translated"><strong class="kb io">考验，</strong> <em class="ma">第四阶段。在自动化设置的某些阶段，你可能会发现把东西放在一个地方很有用。我发现在我建立自动化过程的中途，运行我的小测试套件真的很方便。一旦我们有了想要测试的图像层。我们在单独的<strong class="kb io">阶段</strong>使用它作为基础，并运行测试。如果测试失败，映像构建也将被丢弃。</em></li></ol><h1 id="b619" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.想想资源</h1><p id="22c4" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">首先你需要理解Dockerfile文件的层次，以及。dockerignore</p><ul class=""><li id="781c" class="mn mo in kb b kc kd kg kh kk no ko np ks nq kw ms mt mu mv bi translated">“build”文件夹(流程输出)应该在。为了避免在映像中复制不必要的数据，这些数据将在构建过程中被替换或者不会被使用。<br/>同样，生成的报表、单据等文件。有一段时间，您会回过头来开始最小化创建和部署映像所花费的<strong class="kb io">时间</strong>，以及它们的<strong class="kb io">大小</strong></li></ul><h2 id="3f86" class="mb ky in bd kz mc md dn ld me mf dp lh kk mg mh ll ko mi mj lp ks mk ml lt mm bi translated">边注</h2><p id="9d14" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">我们用定义和源代码定义<strong class="kb io">阶段</strong>，以便<strong class="kb io">构建测试</strong>和<strong class="kb io">运行</strong>项目。<br/>有些情况下，在迁移过程中，您可能很难找到最适合您项目的基础映像。您可以定义映像来从您的环境中复制现成的项目。这在某些情况下可能行得通，但是要确保你理解不同操作系统及其运行环境之间的差异，以及这给你的项目的可移植性带来的潜在风险。</p><h1 id="3c32" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.图像</h1><p id="a168" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">有许多公共注册中心有您可以使用的图像。有些需要你<strong class="kb io">登录</strong>(例如<a class="ae mw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> dockerhub </a>中的一些图片)或者你可能需要使用<strong class="kb io">私人注册</strong>。记住，你的自动化工具也需要访问它。</p><blockquote class="nc nd ne"><p id="be1c" class="jz ka ma kb b kc kd ke kf kg kh ki kj nf kl km kn ng kp kq kr nh kt ku kv kw ig bi translated">您可能会发现有时只需<strong class="kb io">包装另一个注册表中的现有图像</strong>，并将其上传到您的注册表中会很有用。确保，在这种情况下，保持在更新版本的顶部，也许开始“观察”他们的github repo的新版本，并在内部控制你的包装图像的版本。</p></blockquote><h2 id="0101" class="mb ky in bd kz mc md dn ld me mf dp lh kk mg mh ll ko mi mj lp ks mk ml lt mm bi translated">选择并查看图像</h2><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/cdd73ff93f8900b4fe9cd63347fccbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKIYZrTTnziwkBNpRrXPpw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Dockerhub屏幕:识别官方图像</figcaption></figure><p id="6471" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在dokerhub中，需要寻找以下主要关键部分:</p><ul class=""><li id="1bf7" class="mn mo in kb b kc kd kg kh kk no ko np ks nq kw ms mt mu mv bi translated">已验证的图像或发布者<br/>如果图像或发布者已通过<strong class="kb io">验证</strong>，您将在右侧看到徽章。否则，请确保您检查了将显示为“image by <em class="ma"> X </em>的配置文件”</li><li id="8750" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw ms mt mu mv bi translated">描述<br/>通常，相关的Github main Readme.md会显示为<strong class="kb io">描述</strong>来给你一些关于如何使用图像的信息，以及它真正的作用。</li><li id="6452" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw ms mt mu mv bi translated">有时人们可以评论和评价一张图片的质量，但是你也可以了解它有多活跃，或者有多受欢迎。</li><li id="8d35" class="mn mo in kb b kc mx kg my kk mz ko na ks nb kw ms mt mu mv bi translated">标签<br/>发布的不仅仅是图像包含的内容，还有正在使用的<strong class="kb io">图层和基础图像</strong>。请务必快速浏览，并可能注意到您将要使用的版本的<strong class="kb io">尺寸</strong>。</li></ul><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/ff23d017a60167f84150d51456cd79c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wNsnkNIfbl3GFHjML5zgA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图像标签部分和图层大小</figcaption></figure><ul class=""><li id="2abb" class="mn mo in kb b kc kd kg kh kk no ko np ks nq kw ms mt mu mv bi translated">图像层<strong class="kb io">描述</strong> <br/>在这里，您可以完整地了解构建步骤，每个命令如何影响您的图像大小，但更重要的是，您可以查看初始化脚本和可能被覆盖的默认配置。</li></ul><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/5c399acf56af84d9b0f8f57d04521205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zT8btSoU0ffvHacNdHOq2w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图像层回顾:构建过程中运行的命令</figcaption></figure><h1 id="4c90" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.清理本地并测试</h1><p id="ce54" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">“docker”命令可以用参数触发，以便在运行或构建失败后进行清理。继续学习这个部分会变得非常复杂。</p><p id="bcb4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可以运行“docker system prune -a”来清理docker服务下的所有内容。当你还在学习的时候，你会觉得有太多的东西被缓存，你可能不会使用，或者你看到随机的容器和图像被放在一边，这就很方便了。</p><h1 id="7b21" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">外卖食品</h1><p id="0229" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">你不必成为一个专家来理解T2 docker上的官方文档。但是在采取这一步骤之前，您需要了解什么最适合您，什么是过度杀伤，以及如何以敏捷的方式制定一个好的攻击计划。将你的工作流程向一个更好的设置过渡，在不久的将来，你肯定会对此心存感激。<br/>感谢您的阅读，</p><p id="872f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">享受乐趣<br/></p></div></div>    
</body>
</html>