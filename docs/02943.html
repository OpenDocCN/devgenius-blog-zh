<html>
<head>
<title>Decorator Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的装饰设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/decorator-design-pattern-in-modern-c-4af9053ccc7f?source=collection_archive---------7-----------------------#2020-09-14">https://blog.devgenius.io/decorator-design-pattern-in-modern-c-4af9053ccc7f?source=collection_archive---------7-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9f8162b049eaa7e9daff02e73874e724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLXhr9oje26bp3q8czoRjw.png"/></div></div></figure><p id="a767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在软件工程中，结构设计模式处理对象和类之间的关系，即对象和类如何以适合情况的方式交互或建立关系。结构设计模式通过识别关系来简化结构。在这篇关于结构设计模式的文章中，我们将看一看并不复杂但微妙的设计模式，它是现代C++中的装饰设计模式，因为它具有可扩展性和可测试性。也就是<strong class="ka ir"> <em class="kw">被称为</em> </strong>。</p><blockquote class="kx ky kz"><p id="c9ea" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> /！\:本文已原创发表于我的</em> <a class="ae ld" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">博客</em> </a> <em class="iq">。如果你有兴趣接收我的最新文章，</em> <a class="ae ld" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="ed98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，如果你还没有看过我关于结构设计模式的其他文章，下面是列表:</p><ol class=""><li id="04fc" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">适配器</strong> </a></li><li id="7369" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/bridge-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">桥<strong class="ka ir">桥</strong>桥</a></li><li id="c030" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">复合</strong> </a></li><li id="b6a5" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">装饰者</strong> </a></li><li id="9cf9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/facade-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">立面</strong> </a></li><li id="b938" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/flyweight-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">飞锤</strong> </a></li><li id="6032" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/proxy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代理</strong> </a></li></ol><p id="0b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ls lt lu lv b">override</code>、<code class="fe ls lt lu lv b">final</code>、<code class="fe ls lt lu lv b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ls lt lu lv b">struct</code>而不是<code class="fe ls lt lu lv b">class</code>，只是为了节省代码行，有时不写<code class="fe ls lt lu lv b">public:</code>，还会故意忽略<a class="ae ld" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae ld" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ls lt lu lv b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="1fae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">注:</em> </strong></p><ul class=""><li id="9817" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae ld" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="8535" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">您在本系列文章中遇到的所有这些代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17之前的现代C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了boost库的<a class="ae ld" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="814a" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">目的</h1><blockquote class="kx ky kz"><p id="9c25" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">给物体增加附加功能。</strong></p></blockquote><ul class=""><li id="5c03" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">有时我们不得不在不重写或改变现有代码的情况下增加现有对象的功能，只是为了坚持<a class="ae ld" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">开闭原则</a>。这也保留了<a class="ae ld" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>以获得额外的功能。</li></ul><h1 id="ef26" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">C++中的装饰设计模式示例</h1><ul class=""><li id="4f8e" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">为了实现这一点，我们在C++中有两种不同的装饰设计模式:</li></ul><ol class=""><li id="156d" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">动态装饰器</strong>:通过引用或指针聚集被装饰的对象。</li><li id="811e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">静态装饰器</strong>:从被装饰对象继承。</li></ol><h1 id="15fa" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">动态装饰器</h1><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="9763" class="ni ly iq lv b gy nj nk l nl nm">struct Shape {<br/>    virtual operator string() = 0;<br/>};</span><span id="bbfb" class="ni ly iq lv b gy nn nk l nl nm">struct Circle : Shape {<br/>    float   m_radius;</span><span id="1721" class="ni ly iq lv b gy nn nk l nl nm">    Circle(const float radius = 0) : m_radius{radius} {}<br/>    void resize(float factor) { m_radius *= factor; }<br/>    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; "A circle of radius " &lt;&lt; m_radius;<br/>        return oss.str();<br/>    }<br/>};</span><span id="c0af" class="ni ly iq lv b gy nn nk l nl nm">struct Square : Shape {<br/>    float   m_side;</span><span id="4985" class="ni ly iq lv b gy nn nk l nl nm">    Square(const float side = 0) : m_side{side} {}<br/>    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; "A square of side " &lt;&lt; m_side;<br/>        return oss.str();<br/>    }<br/>};</span></pre><ul class=""><li id="cfd8" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">因此，我们有一个由两个不同的<code class="fe ls lt lu lv b">Shape</code>组成的层级(即<code class="fe ls lt lu lv b">Square</code> &amp; <code class="fe ls lt lu lv b">Circle</code> ) &amp;我们希望通过添加颜色来增强这一层级。现在我们突然不打算创建另外两个类，例如彩色圆圈&amp;一个彩色正方形。那太多了&amp;不是一个可扩展的选项。</li><li id="1a48" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">相反，我们可以有如下的<code class="fe ls lt lu lv b">ColoredShape</code>。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="40bf" class="ni ly iq lv b gy nj nk l nl nm">struct ColoredShape : Shape {<br/>    const Shape&amp;    m_shape;<br/>    string          m_color;</span><span id="d272" class="ni ly iq lv b gy nn nk l nl nm">    ColoredShape(const Shape &amp;s, const string &amp;c) : m_shape{s}, m_color{c} {}<br/>    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; string(const_cast&lt;Shape&amp;&gt;(m_shape)) &lt;&lt; " has the color " &lt;&lt; m_color;<br/>        return oss.str();<br/>    }<br/>};</span><span id="7558" class="ni ly iq lv b gy nn nk l nl nm">// we are not changing the base class of existing objects<br/>// cannot make, e.g., ColoredSquare, ColoredCircle, etc.</span><span id="209c" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    Square square{5};<br/>    ColoredShape green_square{square, "green"};    <br/>    cout &lt;&lt; string(square) &lt;&lt; endl &lt;&lt; string(green_square) &lt;&lt; endl;<br/>    // green_circle.resize(2); // Not available<br/>    return EXIT_SUCCESS;<br/>}</span></pre><p id="ab31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">为什么这是一个动态装饰器？</em> </strong> <br/>因为你可以通过提供需要的参数在运行时实例化<code class="fe ls lt lu lv b">ColoredShape</code>。换句话说，您可以在运行时决定哪个<code class="fe ls lt lu lv b">Shape</code>(即<code class="fe ls lt lu lv b">Circle</code>或<code class="fe ls lt lu lv b">Square</code>)将被着色。</p><ul class=""><li id="854e" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">您甚至可以像下面这样混合装饰器:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="0ebd" class="ni ly iq lv b gy nj nk l nl nm">struct TransparentShape : Shape {<br/>    const Shape&amp;    m_shape;<br/>    uint8_t         m_transparency;</span><span id="2d29" class="ni ly iq lv b gy nn nk l nl nm">    TransparentShape(const Shape&amp; s, const uint8_t t) : m_shape{s}, m_transparency{t} {}</span><span id="1925" class="ni ly iq lv b gy nn nk l nl nm">    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; string(const_cast&lt;Shape&amp;&gt;(m_shape)) &lt;&lt; " has "<br/>            &lt;&lt; static_cast&lt;float&gt;(m_transparency) / 255.f * 100.f<br/>            &lt;&lt; "% transparency";<br/>        return oss.str();<br/>    }<br/>};</span><span id="ab45" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    TransparentShape TransparentShape{ColoredShape{Square{5}, "green"}, 51};<br/>    cout &lt;&lt; string(TransparentShape) &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h2 id="138c" class="ni ly iq bd lz no np dn md nq nr dp mh kj ns nt ml kn nu nv mp kr nw nx mt ny bi translated">动态装饰器的局限性</h2><p id="1cd7" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj nz kl km kn oa kp kq kr ob kt ku kv ij bi translated">如果看一下<code class="fe ls lt lu lv b">Circle</code>的定义，可以看到圆有一个方法叫<code class="fe ls lt lu lv b">resize()</code>。我们不能像聚合基于接口<code class="fe ls lt lu lv b">Shape</code> &amp;那样使用这个方法，因为它只被其中暴露的方法所绑定。</p><h1 id="9070" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">静态装饰器</h1><ul class=""><li id="0491" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">如果你不知道你要装饰哪个对象，你想在运行时选择它们，动态装饰器是很棒的，但是有时候你知道你在编译时想要的装饰器，在这种情况下你可以使用C++模板继承的组合。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="bae1" class="ni ly iq lv b gy nj nk l nl nm">template &lt;class T&gt;  // Note: `class`, not typename<br/>struct ColoredShape : T {<br/>    static_assert(is_base_of&lt;Shape, T&gt;::value, "Invalid template argument"); // Compile time safety</span><span id="ddf9" class="ni ly iq lv b gy nn nk l nl nm">    string      m_color;</span><span id="9531" class="ni ly iq lv b gy nn nk l nl nm">    template &lt;typename... Args&gt;<br/>    ColoredShape(const string &amp;c, Args &amp;&amp;... args) : m_color(c), T(std::forward&lt;Args&gt;(args)...) { }</span><span id="6d37" class="ni ly iq lv b gy nn nk l nl nm">    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; T::operator string() &lt;&lt; " has the color " &lt;&lt; m_color;<br/>        return oss.str();<br/>    }<br/>};</span><span id="5eba" class="ni ly iq lv b gy nn nk l nl nm">template &lt;typename T&gt;<br/>struct TransparentShape : T {<br/>    uint8_t     m_transparency;</span><span id="b6bf" class="ni ly iq lv b gy nn nk l nl nm">    template &lt;typename... Args&gt;<br/>    TransparentShape(const uint8_t t, Args... args) : m_transparency{t}, T(std::forward&lt;Args&gt;(args)...) { }</span><span id="3f14" class="ni ly iq lv b gy nn nk l nl nm">    operator string() {<br/>        ostringstream oss;<br/>        oss &lt;&lt; T::operator string() &lt;&lt; " has "<br/>            &lt;&lt; static_cast&lt;float&gt;(m_transparency) / 255.f * 100.f<br/>            &lt;&lt; "% transparency";<br/>        return oss.str();<br/>    }<br/>};</span><span id="aa5c" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    ColoredShape&lt;Circle&gt; green_circle{"green", 5};<br/>    green_circle.resize(2);<br/>    cout &lt;&lt; string(green_circle) &lt;&lt; endl;</span><span id="cb14" class="ni ly iq lv b gy nn nk l nl nm">    // Mixing decorators<br/>    TransparentShape&lt;ColoredShape&lt;Circle&gt;&gt; green_trans_circle{51, "green", 5};<br/>    green_trans_circle.resize(2);<br/>    cout &lt;&lt; string(green_trans_circle) &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="e1b4" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如你所见，我们现在可以调用<code class="fe ls lt lu lv b">resize()</code>方法，这是动态装饰器的限制。你甚至可以像我们之前做的那样混合装饰者。</li><li id="8c34" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">所以本质上，这个例子所展示的是，如果你准备放弃装饰器的动态组合特性，如果你准备在编译时定义所有的装饰器，你将获得使用继承的额外好处。</li><li id="01cc" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">这样，你就可以通过装饰器&amp;混合装饰器来访问你正在装饰的任何对象的成员。</li></ul><h1 id="5612" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">用现代C++实现装饰设计模式的函数方法</h1><ul class=""><li id="27e9" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">到目前为止，我们一直在谈论装饰者设计模式，它装饰了一个类，但是你也可以对函数做同样的事情。以下是一个典型的日志记录器示例:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="167b" class="ni ly iq lv b gy nj nk l nl nm">// Need partial specialization for this to work<br/>template &lt;typename T&gt;<br/>struct Logger;</span><span id="0f21" class="ni ly iq lv b gy nn nk l nl nm">// Return type and argument list<br/>template &lt;typename R, typename... Args&gt;<br/>struct Logger&lt;R(Args...)&gt; {<br/>    function&lt;R(Args...)&gt;    m_func;<br/>    string                  m_name;</span><span id="a05b" class="ni ly iq lv b gy nn nk l nl nm">    Logger(function&lt;R(Args...)&gt; f, const string &amp;n) : m_func{f}, m_name{n} { }</span><span id="1a58" class="ni ly iq lv b gy nn nk l nl nm">    R operator()(Args... args) {<br/>        cout &lt;&lt; "Entering " &lt;&lt; m_name &lt;&lt; endl;<br/>        R result = m_func(args...);<br/>        cout &lt;&lt; "Exiting " &lt;&lt; m_name &lt;&lt; endl;<br/>        return result;<br/>    }<br/>};</span><span id="af1a" class="ni ly iq lv b gy nn nk l nl nm">template &lt;typename R, typename... Args&gt;<br/>auto make_logger(R (*func)(Args...), const string &amp;name) {<br/>    return Logger&lt;R(Args...)&gt;(std::function&lt;R(Args...)&gt;(func), name);<br/>}</span><span id="d84f" class="ni ly iq lv b gy nn nk l nl nm">double add(double a, double b) { return a + b; }</span><span id="7ef7" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    auto logged_add = make_logger(add, "Add");<br/>    auto result = logged_add(2, 3);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="0744" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">上面的例子对你来说可能有点复杂，但是如果你对variadic temple有一个清晰的了解，那么它不会花超过30秒来理解这里发生了什么。</li></ul><h1 id="6d40" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">装饰设计模式的好处</h1><ol class=""><li id="5850" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lj lk ll lm bi translated">Decorator有助于在运行时和编译时增加现有对象的功能。</li><li id="054f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Decorator还提供了以任何顺序添加任意数量装饰器的灵活性&amp;混合使用。</li><li id="326c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">装饰器是解决排列问题的好办法，因为你可以用任意数量的装饰器包装一个组件。</li><li id="5569" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">对已经发布的代码应用装饰设计模式是一个明智的选择。因为它支持应用程序的向后兼容性&amp;更少的单元级测试，因为更改不会影响代码的其他部分。</li></ol><h1 id="0e70" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">常见问题汇总</h1><p id="42ce" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj nz kl km kn oa kp kq kr ob kt ku kv ij bi translated">什么时候使用装饰设计模式？</p><p id="865f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—当您需要能够在运行时向对象分配额外的行为，而不破坏使用这些对象的代码时，请使用装饰设计模式。<br/> —当类有<a class="ae ld" href="https://en.cppreference.com/w/cpp/keyword/final" rel="noopener ugc nofollow" target="_blank"> final </a>关键字时，这意味着该类不能被进一步继承。在这种情况下，装饰设计模式可能会有所帮助。</p><p id="71fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用装饰设计模式有什么弊端？</strong></p><p id="a783" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—decorator可能会使组件的实例化过程变得复杂，因为您不仅要实例化组件，还要将它包装在许多decorator中。<br/> —装饰设计模式的过度使用可能会使系统在两方面变得复杂，即维护&amp;学习曲线。</p><p id="3224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">适配器&amp;装饰器设计模式的区别？</strong></p><p id="2216" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">— <strong class="ka ir">适配器更改现有对象的接口</strong><br/>—<strong class="ka ir">装饰器增强现有对象的接口</strong></p><p id="2b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">Proxy&amp;Decorator设计模式的区别？</strong></p><p id="a488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">— <strong class="ka ir">代理</strong>提供了一个有些相同或者<strong class="ka ir">简单的接口</strong>T21—<strong class="ka ir">装饰</strong>提供了<strong class="ka ir">增强的接口</strong></p></div></div>    
</body>
</html>