<html>
<head>
<title>DOM Manipulation — Scripts and DOM Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DOM 操作—脚本和 DOM 元素</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dom-manipulation-scripts-and-dom-elements-32bbfd40ba1a?source=collection_archive---------19-----------------------#2020-06-19">https://blog.devgenius.io/dom-manipulation-scripts-and-dom-elements-32bbfd40ba1a?source=collection_archive---------19-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f290aeffc285d628e96725049273834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ae3fms0anDe4TjZe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@clyde_he?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱德何</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="47cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何加载脚本，以及如何将事件侦听器附加到 DOM 元素。</p><h1 id="bde8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">推迟脚本下载</h1><p id="87b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">脚本标签可以使用<code class="fe me mf mg mh b">defer</code>属性来推迟脚本的下载。</p><p id="b994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它被推迟，直到浏览器解析了结束的<code class="fe me mf mg mh b">html</code>节点。</p><p id="aca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将浏览器遇到脚本节点时发生的事情推迟到遇到最终的<code class="fe me mf mg mh b">html</code>时。</p><p id="5325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4fe9" class="mq lc iq mh b gy mr ms l mt mu">&lt;script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" defer&gt;&lt;/script&gt;</span></pre><h1 id="bc9a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步加载外部 JavaScript 文件</h1><p id="ef11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">async</code>属性加载外部 JavaScript 文件。</p><p id="f9d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当 DOM 已经创建了浏览器时，<code class="fe me mf mg mh b">async</code>属性将覆盖脚本元素的顺序阻塞特性。</p><p id="dc6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们告诉浏览器不要阻止其他动作，比如解析 DOM、下载资源等。</p><p id="1215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">async</code>，脚本被并行下载，并按照下载的顺序进行解析。</p><p id="7ca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也是类似<code class="fe me mf mg mh b">defer</code>的布尔值。例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="910e" class="mq lc iq mh b gy mr ms l mt mu">&lt;script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" async&gt;&lt;/script&gt;</span></pre><h1 id="1bbc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用动态脚本元素强制异步下载脚本</h1><p id="5888" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过动态创建来创建动态脚本元素。</p><p id="fd47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc48" class="mq lc iq mh b gy mr ms l mt mu">const script = document.createElement("script");<br/>script.src = "https://code.jquery.com/jquery-3.4.1.slim.min.js";<br/>document.body.appendChild(script);</span></pre><p id="2445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态加载 jQuery 脚本。</p><p id="ac9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态创建脚本元素意味着它们可能会被无序解析。</p><p id="2aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能保证所有的依赖都是可用的。</p><h1 id="6d17" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 onload 回调异步脚本加载</h1><p id="36ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将脚本加载代码放在<code class="fe me mf mg mh b">onload</code>回调函数中。</p><p id="c394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来附加一个<code class="fe me mf mg mh b">onload</code>监听器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3ecb" class="mq lc iq mh b gy mr ms l mt mu">const script = document.createElement("script");<br/>script.src = "https://code.jquery.com/jquery-3.4.1.slim.min.js";<br/>script.onload = () =&gt; {<br/>  console.log('loaded');<br/>}</span></pre><p id="e902" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们就知道它什么时候上膛了。</p><h1 id="06b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">HTML 中的脚本放置</h1><p id="8205" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">默认情况下，脚本元素按顺序同步加载。</p><p id="f526" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4f7c" class="mq lc iq mh b gy mr ms l mt mu">&lt;script&gt;<br/>  console.log(document.querySelector('p').innerHTML);<br/>&lt;/script&gt;</span><span id="d3f6" class="mq lc iq mh b gy mv ms l mt mu">&lt;body&gt;<br/>  &lt;p&gt;<br/>    foo<br/>  &lt;/p&gt;<br/>&lt;/body&gt;</span></pre><p id="3dde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到“未捕获的类型错误:无法读取 null 的属性“innerHTML ”,因为主体尚未加载。</p><p id="c90c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6c21" class="mq lc iq mh b gy mr ms l mt mu">&lt;body&gt;<br/>  &lt;p&gt;<br/>    foo<br/>  &lt;/p&gt;<br/>&lt;/body&gt;</span><span id="d0c7" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>  console.log(document.querySelector('p').innerHTML);<br/>&lt;/script&gt;</span></pre><p id="2b05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">'foo'</code>日志，因为主体已经被加载。</p><p id="9b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们必须小心脚本标签的放置。</p><h1 id="d4d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取 DOM 中的脚本</h1><p id="204d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了获取 DOM 中的脚本标签，我们可以使用<code class="fe me mf mg mh b">document.scripts</code>属性来获取它们。</p><p id="3141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d72c" class="mq lc iq mh b gy mr ms l mt mu">&lt;script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"&gt;&lt;/script&gt;</span></pre><p id="a288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来获取脚本元素:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1164" class="mq lc iq mh b gy mr ms l mt mu">for (const s of document.scripts) {<br/>  console.log(s);<br/>}</span></pre><p id="63dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">document.scripts</code>是一个类似数组的对象，所以我们可以在 for-of 循环中使用它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/0d4525e4ae0afa62e1db345f56dc526e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M039GxgfnHExwaei"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@alelmes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alasdair Elmes </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="795c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DOM 事件</h1><p id="4a2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">DOM 元素可以监听用户触发的事件。</p><p id="4b6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了监听它们，我们可以在 DOM 元素上调用<code class="fe me mf mg mh b">addEventListener</code>。</p><p id="8d6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将回调设置为事件处理程序的属性值。</p><p id="0945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e38e" class="mq lc iq mh b gy mr ms l mt mu">&lt;button&gt;<br/>  click me<br/>&lt;/button&gt;</span></pre><p id="4f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来附加一个点击监听器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f944" class="mq lc iq mh b gy mr ms l mt mu">const button = document.querySelector('button');<br/>button.addEventListener('click', () =&gt; {<br/>  console.log('clicked');<br/>}, false);</span></pre><p id="502d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是事件名称，第二个是回调，第三个是指示我们是否要使用捕获模式。</p><p id="4efb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">捕获模式意味着事件从父节点传播到子节点，而不是通常的子节点到父节点。</p><p id="ff44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以设置一个事件监听器回调到<code class="fe me mf mg mh b">onclick</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1d4b" class="mq lc iq mh b gy mr ms l mt mu">const button = document.querySelector('button');<br/>button.onclick = () =&gt; {<br/>  console.log('clicked');<br/>};</span></pre><p id="a1fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者的缺点是我们一次只能给它分配一个事件侦听器。</p><p id="aac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">function</code>关键字来定义我们的事件处理函数，作用域也可能会产生冲突。</p><p id="14aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">function</code>，那么点击处理程序将把这个元素作为<code class="fe me mf mg mh b">this</code>的值。</p><p id="8b53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">window</code>处理对主体或框架集的事件。</p><h1 id="4e18" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0fb6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以加载带有<code class="fe me mf mg mh b">defer</code>或<code class="fe me mf mg mh b">async</code>属性的脚本，以便在后台加载它们。</p><p id="ba2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以将事件侦听器附加到 DOM 对象，以侦听对它们所做的操作，并相应地运行代码。</p></div></div>    
</body>
</html>