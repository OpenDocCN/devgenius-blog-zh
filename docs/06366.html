<html>
<head>
<title>Build a REST API with Golang and MongoDB — Gorilla/Mux Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang和MongoDB构建REST API—Gorilla/Mux版本</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-rest-api-with-golang-and-mongodb-gorilla-mux-version-cf9fd843c787?source=collection_archive---------7-----------------------#2022-01-03">https://blog.devgenius.io/build-a-rest-api-with-golang-and-mongodb-gorilla-mux-version-cf9fd843c787?source=collection_archive---------7-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b4ac4c8a4264bc7a24c9b88d4b64eba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-etsUwETp_YAU2JGJcsb_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">封面照片</figcaption></figure><p id="31be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">表述性状态转移(REST)是一种指导应用程序编程接口(API)设计和开发的架构模式。REST APIs已经成为产品的服务器部分和它的客户机之间的通信标准，以提高性能、可伸缩性、简单性、可修改性、可见性、可移植性和可靠性。</p><p id="6f8e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章将讨论用Golang使用<a class="ae kx" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Mux </a>包和<a class="ae kx" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>构建一个用户管理应用程序。在本教程的最后，我们将学习如何构建一个Mux应用程序，构建一个REST API，并使用MongoDB持久化我们的数据。</p><p id="5632" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Gorilla/Mux，俗称<strong class="kb io"> Mux </strong>，是一个强大的HTTP路由器和URL匹配器，用于构建Go web服务器。</p><p id="cb14" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">MongoDB是一个基于文档的数据库管理程序，用作关系数据库的替代方案。MongoDB支持处理大型分布式数据集，并提供无缝存储或检索信息的选项。</p><p id="5713" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以在这个<a class="ae kx" href="https://github.com/Mr-Malomz/mux-mongo-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到完整的源代码。</p><h1 id="a747" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="cfbd" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这篇文章中的以下步骤需要Golang经验。使用MongoDB的经验不是必需的，但是拥有它是很好的。</p><p id="9676" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要以下物品:</p><ul class=""><li id="d983" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">一个<a class="ae kx" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB帐户</a>来托管数据库。<a class="ae kx" href="https://www.mongodb.com/cloud/atlas/register" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">报名</strong> </a> <strong class="kb io">完全免费</strong>。</li><li id="a0bc" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或者你选择的任何API测试应用</li></ul><h1 id="c82d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们编码</h1><h2 id="d473" class="mp kz in bd la mq mr dn le ms mt dp li kk mu mv lm ko mw mx lq ks my mz lu na bi translated">入门指南</h2><p id="0b99" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行下面的命令</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2dd5" class="mp kz in ng b gy nk nl l nm nn">mkdir mux-mongo-api &amp;&amp; cd mux-mongo-api</span></pre><p id="718e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令创建一个<code class="fe no np nq ng b">mux-mongo-api</code>文件夹，并导航到项目目录。</p><p id="b28b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要通过运行以下命令来初始化Go模块以管理项目依赖关系:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c05b" class="mp kz in ng b gy nk nl l nm nn">go mod init mux-mongo-api</span></pre><p id="bc45" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令将创建一个<code class="fe no np nq ng b">go.mod</code>文件，用于跟踪项目依赖关系。</p><p id="079a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们继续安装所需的依赖项:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7df3" class="mp kz in ng b gy nk nl l nm nn">go get -u github.com/gorilla/mux go.mongodb.org/mongo-driver/mongo github.com/joho/godotenv github.com/go-playground/validator/v10</span></pre><p id="d113" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/gorilla/mux</code>是一个用于构建网络服务器的软件包。</p><p id="86ca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">go.mongodb.org/mongo-driver/mongo</code>是连接MongoDB的驱动。</p><p id="e176" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/joho/godotenv</code>是一个管理环境变量的库。</p><p id="6820" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">github.com/go-playground/validator/v10</code>是用于验证结构和字段的库。</p><h1 id="57b4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">应用程序入口点</h1><p id="9635" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">安装了项目依赖项后，我们需要在根目录下创建<code class="fe no np nq ng b">main.go</code>文件，并在下面添加代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6ac2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行以下操作:</p><ul class=""><li id="2700" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="aefa" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">NewRouter</code>功能初始化多路路由器。</li><li id="66d1" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用将<code class="fe no np nq ng b">net/http</code>包作为参数路由到<code class="fe no np nq ng b">/</code>路径的<code class="fe no np nq ng b">HandleFunc</code>函数，以及使用<code class="fe no np nq ng b">encoding/json</code>包将头类型设置为<strong class="kb io"> JSON </strong>并返回<code class="fe no np nq ng b">Hello from Mux &amp; mongoDB</code>的JSON的处理函数。我们还将HTTP方法附加到这个函数上</li><li id="4163" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">http.ListenAndServe</code>功能在端口<code class="fe no np nq ng b">6000</code>上运行应用程序。</li></ul><p id="2273" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们可以通过在终端中运行下面的命令来启动开发服务器，从而测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="958a" class="mp kz in ng b gy nk nl l nm nn">go run main.go</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/73f9fc18155588b4856dc046a7e74dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KkXxZQzNFbD3bXdb.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">测试应用程序</figcaption></figure><h1 id="a56c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">戈朗的模块化</h1><p id="7181" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">对于我们的项目来说，有一个好的文件夹结构是至关重要的。良好的项目结构简化了我们在应用程序中处理依赖关系的方式，并使我们和其他人更容易阅读我们的代码库。</p><p id="8e1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们需要在项目目录中创建<code class="fe no np nq ng b">configs</code>、<code class="fe no np nq ng b">controllers</code>、<code class="fe no np nq ng b">models</code>、<code class="fe no np nq ng b">responses</code>和<code class="fe no np nq ng b">routes</code>文件夹。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8a0864a7a81d8431225ca2a396d09de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*0b5WvqcjEeRwCbcD.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">更新了文件夹结构</figcaption></figure><p id="eb84" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">PS</strong>:<em class="nv"/><code class="fe no np nq ng b"><em class="nv">go.sum</em></code><em class="nv">文件包含所有的依赖校验和，由go工具管理。我们不必担心它。</em></p><p id="5936" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">configs</code>用于项目配置文件的模块化</p><p id="a73e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">controllers</code>用于应用逻辑的模块化。</p><p id="74c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">models</code>用于数据和数据库逻辑的模块化。</p><p id="1afc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">responses</code>用于模块化描述我们希望我们的API给出的响应的文件。这将在以后变得更加清晰。</p><p id="0f3e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">routes</code>用于模块化URL模式和处理程序信息。</p><h1 id="6295" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置MongoDB</h1><p id="998b" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">完成后，我们需要登录或注册我们的<a class="ae kx" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>账户。点击项目下拉菜单，点击<strong class="kb io">新建项目</strong>按钮。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/9988d8e4c6748045a6fb2a6b7e511f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9_gsSmnz-x386be8.png"/></div></div></figure><p id="4816" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入<code class="fe no np nq ng b">goland-api</code>作为项目名称，点击下的<strong class="kb io">，点击<strong class="kb io">创建项目。</strong></strong></p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/e91e2d034eb7b8dc873d4f5e7bd80c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oNSAn-6fs_d2iUmb.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/03816a381c1fa0844dbd0c87e5521fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LVAn3mZjuaCs3tme.png"/></div></div></figure><p id="09c6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">建立数据库</strong></p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/44a5ecb824fa315627d0da7fa58b4bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RyGDL8uwQ-dPNnAv.png"/></div></div></figure><p id="66cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">选择<strong class="kb io">共享</strong>作为数据库类型。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/1904585faf9df2ae69542d6a95c2756f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JI8apH2IeRJzuhq7.png"/></div></div></figure><p id="a62a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">创建</strong>以设置集群。这可能需要一些时间来设置。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/51640f3f5ca538912ef21d743d0ac0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uu2rZpPRPEjQh0tF.png"/></div></div></figure><p id="184e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要创建一个用户，通过输入<strong class="kb io">用户名</strong>、<strong class="kb io">密码</strong>，然后点击<strong class="kb io">创建用户</strong>，从外部访问数据库。我们还需要添加我们的IP地址，以便通过点击<strong class="kb io">添加我当前的IP地址</strong>按钮安全地连接到数据库。然后点击<strong class="kb io">完成并关闭</strong>保存更改。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/44e0947da796557590cce6fca9a78b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YIQ4nOiRSsItGtJe.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/10259814e28f3fe085e5586eca711dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7DVySXXgDyUJXq54.png"/></div></div></figure><p id="bbd2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">保存更改后，我们应该会看到一个数据库部署屏幕，如下所示:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/44cbc6a75a6c909a5479194562e8789a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UIRG3zU__guFJMDQ.png"/></div></div></figure><h1 id="175f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将我们的应用程序连接到MongoDB</h1><p id="a978" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">配置完成后，我们需要将应用程序与创建的数据库连接起来。为此，点击<strong class="kb io">连接</strong>按钮</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/89ce6de722015a086fd97234af5de845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YKSS9vrIppBvkuGv.png"/></div></div></figure><p id="3e1a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">连接你的应用</strong>，改变<strong class="kb io">驱动</strong>和<strong class="kb io">版本</strong>，如下图所示。然后点击复制<strong class="kb io">图标</strong>复制连接字符串。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/89ace11598110960b4844d0a28fcd8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ccvojYeOQPuCAhO8.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/b094533eb5d8235f47d7d0b4e62cd9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cNShsBAAslbIT0tt.png"/></div></div></figure><p id="8448" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">设置环境变量</strong></p><p id="6a05" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们必须用之前创建的用户密码修改复制的连接字符串，并更改数据库名称。为此，首先，我们需要在根目录中创建一个<code class="fe no np nq ng b">.env</code>文件，并在该文件中添加下面的代码片段:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5785" class="mp kz in ng b gy nk nl l nm nn">MONGOURI=mongodb+srv://&lt;YOUR USERNAME HERE&gt;:&lt;YOUR PASSWORD HERE&gt;@cluster0.e5akf.mongodb.net/myFirstDatabese?retryWrites=true&amp;w=majority</span></pre><p id="d680" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是正确填充的连接字符串示例:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="25d1" class="mp kz in ng b gy nk nl l nm nn">MONGOURI=mongodb+srv://malomz:malomzPassword@cluster0.e5akf.mongodb.net/golangDB?retryWrites=true&amp;w=majority</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/97535478d225754aad2002806f616911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*zYp2HPM9-2gX9mkm.png"/></div></figure><p id="0808" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">加载环境变量</strong></p><p id="691f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，我们需要创建一个助手函数，使用我们之前安装的github.com/joho/godotenv库来加载环境变量。为此，我们需要导航到configs文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">env.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="54b5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="5468" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="17d5" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个EnvMongoURI函数，该函数检查环境变量是否正确加载并返回环境变量。</li></ul><p id="ae53" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">连接到MongoDB </strong></p><p id="b436" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要从我们的应用程序连接到MongoDB数据库，首先，我们需要导航到configs文件夹，在这个文件夹中，创建一个setup.go文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1f7e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="8330" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="56e6" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">ConnectDB</code>函数，首先配置客户端使用正确的URI并检查错误。其次，我们定义了一个10秒的超时，我们希望在尝试连接时使用。第三，检查连接到数据库时是否有错误，如果连接时间超过10秒，则取消连接。最后，我们pinged数据库来测试我们的连接，并返回了<code class="fe no np nq ng b">client</code>实例。</li><li id="df35" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">ConnectDB</code>的<code class="fe no np nq ng b">DB</code>变量实例。这将在创建收藏时派上用场。</li><li id="8cd6" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">GetCollection</code>函数来检索并在数据库上创建<code class="fe no np nq ng b">collections</code>。</li></ul><p id="c279" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要在应用程序启动时连接到数据库。为此，我们需要修改<code class="fe no np nq ng b">main.go</code>,如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="748b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置API路由处理程序和回应类型</h1><p id="44bb" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated"><strong class="kb io">路线处理程序<br/> </strong>完成后，我们需要在<code class="fe no np nq ng b">routes</code>文件夹中创建一个user_route.go文件来管理应用程序中所有与用户相关的路线，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9366" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要将新创建的路由附加到<strong class="kb io"> http。通过修改服务器<code class="fe no np nq ng b">main.go</code>中的</strong>，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="46db" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要创建一个可重用的结构来描述我们的API的响应。为此，导航到<code class="fe no np nq ng b">responses</code>文件夹，在该文件夹中，创建一个<code class="fe no np nq ng b">user_response.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f5ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段创建了一个UserResponse结构，它具有<code class="fe no np nq ng b">Status</code>、<code class="fe no np nq ng b">Message</code>和<code class="fe no np nq ng b">Data</code>属性来表示API响应类型。</p><p id="a0d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> PS </strong> : <code class="fe no np nq ng b">json:"status"</code> <em class="nv">，</em> <code class="fe no np nq ng b"><em class="nv">json:"message”</em></code> <em class="nv">，</em> <code class="fe no np nq ng b"><em class="nv">json:”data”</em></code> <em class="nv">称为</em> <strong class="kb io"> <em class="nv"> struct标签</em> </strong> <em class="nv">。结构标签允许我们将元信息附加到相应的结构属性上。换句话说，我们使用它们来重新格式化API返回的JSON响应。</em></p><h1 id="c89d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后，创建REST API</h1><p id="8be3" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">接下来，我们需要一个模型来表示我们的应用程序数据。为此，我们需要导航到<code class="fe no np nq ng b">models</code>文件夹，在该文件夹中，创建一个<code class="fe no np nq ng b">user_model.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="939a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="c390" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="d836" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个具有所需属性的结构。我们在struct，tag中添加了<code class="fe no np nq ng b">omitempty</code>和<code class="fe no np nq ng b">validate:”required”</code>,分别告诉纤程忽略空字段并使字段成为必填字段。</li></ul><p id="7f58" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">创建用户端点<br/> </strong>有了模型设置，我们现在可以创建一个函数来创建用户。为此，我们需要导航到<code class="fe no np nq ng b">controllers</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">user_controller.go</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="eef7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="fba3" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="5592" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建<code class="fe no np nq ng b">userCollection</code>和<code class="fe no np nq ng b">validate</code>变量，分别使用我们之前安装的<code class="fe no np nq ng b">github.com/go-playground/validator/v10</code>库来创建集合和验证模型。</li><li id="c753" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个返回<code class="fe no np nq ng b">net/http</code>处理程序的<code class="fe no np nq ng b">CreateUser</code>函数。在返回的处理程序中，当将用户插入到文档中时，我们首先定义了一个10秒的超时，使用验证器库来验证请求体和必填字段。我们使用之前创建的<code class="fe no np nq ng b">UserResponse</code>结构返回了适当的消息和状态代码。其次，我们创建了一个<code class="fe no np nq ng b">newUser</code>变量，使用<code class="fe no np nq ng b">userCollection.InsertOne</code>函数插入它，并检查是否有错误。最后，如果插入成功，我们返回正确的响应。</li></ul><blockquote class="nx ny nz"><p id="74bf" class="jz ka nv kb b kc kd ke kf kg kh ki kj oa kl km kn ob kp kq kr oc kt ku kv kw ig bi translated"><code class="fe no np nq ng b">w.WriteHeader</code>功能用于设置API状态码。</p><p id="8d59" class="jz ka nv kb b kc kd ke kf kg kh ki kj oa kl km kn ob kp kq kr oc kt ku kv kw ig bi translated"><code class="fe no np nq ng b">json.NewDecoder‘s</code>解码和编码方法用于将<strong class="kb io"> JSON </strong>转换为<strong class="kb io"> Go </strong>值，反之亦然。</p></blockquote><p id="7077" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要用路由API URL和相应的控制器更新user_routes.go，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9fe1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">获取用户端点<br/> </strong>要获取用户的详细信息，我们需要修改user_controller.go，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f321" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="baa0" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项。</li><li id="67e2" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个返回一个<code class="fe no np nq ng b">net/http</code>处理程序的<code class="fe no np nq ng b">GetAUser</code>函数。在返回的处理程序中，我们首先定义了在文档中查找用户时10秒的超时时间、从URL参数中获取用户Id的userId变量和一个用户变量。我们将<code class="fe no np nq ng b">userId</code>从字符串转换为<code class="fe no np nq ng b">primitive.ObjectID</code>类型，即MongoDB使用的<strong class="kb io"> BSON </strong>类型。其次，我们使用<code class="fe no np nq ng b">userCollection.FindOne</code>搜索用户，将<code class="fe no np nq ng b">objId</code>作为过滤器传递，并使用<code class="fe no np nq ng b">Decode</code>属性方法获取相应的对象。最后，我们返回解码的响应。</li></ul><p id="2f79" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要用路由API URL和相应的控制器更新<code class="fe no np nq ng b">user_routes.go</code>，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3409" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> PS: </strong> <em class="nv">我们还将一个userId作为参数传递给了URL路径。指定的参数必须与我们在控制器中指定的参数相匹配。</em></p><p id="2952" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">编辑用户端点<br/> </strong>要编辑用户，我们需要修改user_controller.go如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9d09" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的<code class="fe no np nq ng b">EditAUser</code>功能与<code class="fe no np nq ng b">CreateUser</code>功能的作用相同。然而，我们包含了一个<code class="fe no np nq ng b">update</code>变量来获取更新的字段，并使用<code class="fe no np nq ng b">userCollection.UpdateOne</code>更新了集合。最后，我们搜索更新后的用户详细信息，并返回解码后的响应。</p><p id="f192" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要用路由API URL和相应的控制器更新<code class="fe no np nq ng b">user_routes.go</code>,如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4904" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">删除一个用户端点<br/> </strong>要删除一个用户，我们需要修改user_controller.go如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4086" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">DeleteAUser</code>功能遵循前面的步骤，使用<code class="fe no np nq ng b">userCollection.DeleteOne</code>删除匹配的记录。我们还检查一个项目是否被成功删除，并返回适当的响应。</p><p id="b0a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要用路由API URL和相应的控制器更新<code class="fe no np nq ng b">user_routes.go</code>,如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d85e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">获取用户列表端点<br/> </strong>要获取用户列表，我们需要修改user_controller.go，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5a35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">GetAllUsers</code>功能遵循前面的步骤，使用<code class="fe no np nq ng b">userCollection.Find</code>获取用户列表。我们还使用<code class="fe no np nq ng b">Next</code>属性方法遍历返回的用户列表，以最佳方式读取返回的列表。</p><p id="f075" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要用路由API URL和相应的控制器更新<code class="fe no np nq ng b">user_routes.go</code>,如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9707" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">完成user_controller.go </strong></p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fd63" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">完成user_route.go </strong></p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="657e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，我们可以通过在终端中运行下面的命令启动开发服务器来测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="00e5" class="mp kz in ng b gy nk nl l nm nn">go run main.go</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/0a4f593957747883fe7bc390ccc73b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yl9YUvNEOZzQ1Eds.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/945db39fe3a3e59430263b8640ae5473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kpfyJKuNayShQZwW.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/c28142bb197724d6501793be6aee7e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZW2gxboCjPQoG7Ld.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/7eb72f2e8d994a09a38b6ab2fb42a96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xfwFXJcKGpQlpf5M.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/3240e3f155cc4a43f2e70fc70760936c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9oBuXdfFmbK_XnNs.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/68228f37b057b6b5ea5a6c56866e1da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9m66CpVXawfD6NUj.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/1dcc9ed3bb796701b0137a94124ba54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9WVppgvzynTIIFum.png"/></div></div></figure><h1 id="b1ab" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="08bd" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这篇文章讨论了如何构建Gin-gonic应用程序，构建REST API，以及使用MongoDB持久化我们的数据。</p><p id="d9e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可能会发现这些资源很有帮助:</p><ul class=""><li id="2ec7" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated"><a class="ae kx" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank">大猩猩/多路复用器</a></li><li id="d826" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://docs.mongodb.com/drivers/go/current/" rel="noopener ugc nofollow" target="_blank"> MongoDB Go驱动</a></li><li id="9086" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://github.com/go-playground/validator" rel="noopener ugc nofollow" target="_blank"> Go验证器</a></li><li id="68b6" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank">转到环境加载器</a></li></ul></div></div>    
</body>
</html>