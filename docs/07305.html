<html>
<head>
<title>CS50 Runoff Elections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CS50 决选</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cs50-runoff-elections-36a0f37808c3?source=collection_archive---------1-----------------------#2022-03-14">https://blog.devgenius.io/cs50-runoff-elections-36a0f37808c3?source=collection_archive---------1-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f808e2429373ce9f31679a4b0591de1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItGLVlhCC-cuCxqCANxV2w.jpeg"/></div></div></figure><p id="76cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直接进入<a class="ae kt" href="#0a0f" rel="noopener ugc nofollow"> <strong class="jx io">功能</strong> </a>。</p><p id="c7e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗨，这是我对 CS50 问题集 3 中给出的径流程序的解决方案，因为在所有的编码中，可能还有很多其他更好的方法来解决这个问题。</p><p id="7b77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从最上面开始看代码，我们必须包含 string.h 库，然后为我们定义 MAX _ 选民和 MAX _ 候选者，它们是宏定义<code class="fe ku kv kw kx b">#define</code>允许它们的定义，它们被用作常数，不能被我们的代码改变</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a4e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里声明了二维数组、每个候选对象的结构、数组候选对象、投票者计数和候选对象计数。可视化 2D 阵列对我来说有点困难，它们基本上是行和列，我是这样理解的:</p><p id="10b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们有 3 名候选人和 3 名选民。[MAX _ 选民]这是行数，[MAX _ 候选者]是列数</p><pre class="ky kz la lb gt lf kx lg lh aw li bi"><span id="582b" class="lj lk in kx b gy ll lm l ln lo">VOTERS  | CANDIDATES<br/>voter[0]|[0][1][2]<br/>voter[1]|[2][0][1]<br/>voter[2]|[1][2][0]</span></pre><p id="07ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这之后，我们有了我们的功能原型和主要开始。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="5caa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里主要是开始，当我们编译我们的程序时，我们需要输入候选人，我们输入的候选人数量将存储在<code class="fe ku kv kw kx b">argc</code>中，候选人的名字将存储在数组<code class="fe ku kv kw kx b">argv[]</code>中。如果我们没有输入任何候选人或者候选人数量大于最大值，前两次<code class="fe ku kv kw kx b">if</code>检查中的一次将失败。如果这些都通过了，我们就开始填充候选人的数组。</p><p id="b604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">循环中的<code class="fe ku kv kw kx b">for</code>将迭代每个候选项，添加到<code class="fe ku kv kw kx b">struct</code>并将其附加到候选项的数组中，名称的分配类似于<code class="fe ku kv kw kx b">argv[i + 1]</code>，因为当我们运行程序时<code class="fe ku kv kw kx b">argv</code>也将我们的<code class="fe ku kv kw kx b">./runoff</code>添加到数组中，所以我们需要跳过它。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="6a31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果投票人数超过 100 人，我们就返回。</p><p id="8eda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们有我们的嵌套,<code class="fe ku kv kw kx b">for loops</code>第一个迭代通过投票者的数量，第二个迭代通过候选人的数量，并且它用<code class="fe ku kv kw kx b">vote</code>存储投票，我们下面要做的一个功能是:[i]是投票者，[j]是用户选择作为<code class="fe ku kv kw kx b">n</code>等级的候选人。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="6250" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后的循环</p><p id="5a2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个循环一直运行到，<code class="fe ku kv kw kx b">print_winner </code>或<code class="fe ku kv kw kx b">is_tie </code>返回 true，为了让<code class="fe ku kv kw kx b">is_tie</code>打破这个循环，剩下的所有候选人需要有相等的票数，<code class="fe ku kv kw kx b">Tabulate</code>计算每个候选人的票数。在所有的函数运行之后，每个候选人的票数被重置为零，并且调用<code class="fe ku kv kw kx b">tabulate</code>函数重新开始计数。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="0a0f" class="lw lk in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">功能</strong></h1><p id="ef61" class="pw-post-body-paragraph jv jw in jx b jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks ig bi translated">我们的第一个函数是<code class="fe ku kv kw kx b">vote</code>函数。该函数有三个参数，<code class="fe ku kv kw kx b">i</code>作为投票者，<code class="fe ku kv kw kx b">j</code>作为等级，而<code class="fe ku kv kw kx b">name </code>是适当等级的候选人。</p><p id="d166" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">for</code>循环遍历候选人数组中的每个候选人，它使用函数<code class="fe ku kv kw kx b">srtcmp</code>将用户输入的姓名与候选人数组中的<code class="fe ku kv kw kx b">candidates[i]</code>进行比较。如果它们相等，它就用用户选择候选人的投票人和排名索引更新 preferences 数组。</p><p id="a07e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我打印了每个程序要求候选人的投票人和每个候选人的排名，只是为了看看它如何以更好的方式工作。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="20db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果候选人在上一轮循环中没有被淘汰，则<code class="fe ku kv kw kx b">tabulate</code>函数会增加每个候选人的票数。它通过在嵌套的<code class="fe ku kv kw kx b">for</code>循环中遍历每个投票者和候选人来完成，然后我们得到在<code class="fe ku kv kw kx b">c</code>等级上的候选人，检查它是否被淘汰，如果没有，给该候选人添加投票，我们跳出循环，继续同一个投票者</p><p id="0cb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重要的是要理解，如果这个候选人被淘汰，例如，如果只有一个投票人将其作为等级 1，则等级 2 现在变成等级 1，以此类推，则只有等级 1 的候选人的票数增加。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="9e1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了<code class="fe ku kv kw kx b">print_winner</code>功能，我认为这是最简单的一个，在我看来，其他的都很难。</p><p id="08f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要记住，要在决选中宣布获胜者，获胜者必须赢得至少一半的选票，这是我们在这里实现的。</p><p id="fa48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们遍历每个候选人，检查他们的票数是否大于候选人总数除以二(一半)，如果是这样，函数打印获胜者并返回<code class="fe ku kv kw kx b">true</code>，否则返回<code class="fe ku kv kw kx b">false</code>。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="8cf7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<code class="fe ku kv kw kx b">find_min</code>函数，我们创建了一个包含两个数字的数组。你也可以用一个数字变量，我只是觉得这样更容易理解，我们迭代每个候选人，如果<code class="fe ku kv kw kx b">smallest[0]</code>大于当前候选人的票数，并且还没有被淘汰，就把<code class="fe ku kv kw kx b">smallest[0]</code>的值改成那个数。该函数遍历所有候选人，然后返回票数最少的候选人。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b7c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">is_tie</code>函数对我来说是最难理解的，下面是我对它的解构；当 while 循环运行并且还没有赢家时，我们用<code class="fe ku kv kw kx b">is_tie</code>检查。在函数中，我们创建两个变量，一个存储有多少候选人拥有最低票数，另一个存储有多少候选人仍在竞选，然后我们编写一个<code class="fe ku kv kw kx b">for</code>循环遍历每个候选人。如果候选人尚未被淘汰，并且拥有最低票数，我们递增这两个变量，<code class="fe ku kv kw kx b">else if</code>候选人尚未被淘汰，但没有最低票数，这意味着候选人仍在竞选，因此我们递增<code class="fe ku kv kw kx b">onRun</code>变量。</p><p id="02e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，如果<code class="fe ku kv kw kx b">tie_count</code>与<code class="fe ku kv kw kx b">onRun</code>的数量相同，则函数返回 true，否则返回 false。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e21b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要排除得票最少的候选人，并考虑选民选择的第二个候选人，这模拟了如果得票最少的候选人一开始就没有参加选举会发生什么。</p><p id="5f14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数遍历每个候选项，如果候选项的票数最少，它将被删除，切换我们的 struct 候选项所具有的 bool <code class="fe ku kv kw kx b">eliminated</code>。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="0fae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，如果您有任何疑问，请告诉我，我会尽力帮助您！！</p><pre class="ky kz la lb gt lf kx lg lh aw li bi"><span id="f368" class="lj lk in kx b gy ll lm l ln lo">:) runoff.c exists<br/>:) runoff compiles<br/>:) vote returns true when given name of candidate<br/>:) vote returns false when given name of invalid candidate<br/>:) vote correctly sets first preference for first voter<br/>:) vote correctly sets third preference for second voter<br/>:) vote correctly sets all preferences for voter<br/>:) tabulate counts votes when all candidates remain in election<br/>:) tabulate counts votes when one candidate is eliminated<br/>:) tabulate counts votes when multiple candidates are eliminated<br/>:) tabulate handles multiple rounds of preferences<br/>:) print_winner prints name when someone has a majority<br/>:) print_winner returns true when someone has a majority<br/>:) print_winner returns false when nobody has a majority<br/>:) print_winner returns false when leader has exactly 50% of vote<br/>:) find_min returns minimum number of votes for candidate<br/>:) find_min returns minimum when all candidates are tied<br/>:) find_min ignores eliminated candidates<br/>:) is_tie returns true when election is tied<br/>:) is_tie returns false when election is not tied<br/>:) is_tie returns false when only some of the candidates are tied<br/>:) is_tie detects tie after some candidates have been eliminated<br/>:) eliminate eliminates candidate in last place<br/>:) eliminate eliminates multiple candidates in tie for last<br/>:) eliminate eliminates candidates after some already eliminated</span></pre><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure></div></div>    
</body>
</html>