<html>
<head>
<title>Road to Genius: superior #64</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:优越#64</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-superior-64-e818e35af2c9?source=collection_archive---------16-----------------------#2020-08-21">https://blog.devgenius.io/road-to-genius-superior-64-e818e35af2c9?source=collection_archive---------16-----------------------#2020-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6264da5fad525853dc0df04dc4914d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4eSeK4g6cKUxBKNw.png"/></div></div></figure><p id="17a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d962" class="lc ld in ky b gy le lf l lg lh">function threeSum(nums) {<br/>  if (nums.length &lt; 3) return [];<br/>  const list = [];<br/>  nums.sort((a, b) =&gt; a - b);<br/>  for (let i = 0; i &lt; nums.length; i++) {<br/>    if (nums[i] &gt; 0) break;<br/>    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;<br/>    let left = i;<br/>    let right = nums.length - 1;<br/>    while (left &lt; right) {<br/>      if (left === i) {<br/>        left++;<br/>      } else if (right === i) {<br/>        right--;<br/>      } else if (nums[left] + nums[right] + nums[i] === 0) {<br/>        list.push([nums[left], nums[right], nums[i]]);<br/>        while(nums[left] === nums[left + 1]) {<br/>          left++;<br/>        }<br/>        left++;<br/>        while(nums[right] === nums[right - 1]) {<br/>          right--;<br/>        }<br/>        right--;<br/>        continue;<br/>      } else if (nums[left] + nums[right] + nums[i] &gt; 0) {<br/>        right--;<br/>      } else {<br/>        left++;<br/>      }<br/>    }<br/>  }<br/>  return list;<br/>};</span><span id="5589" class="lc ld in ky b gy li lf l lg lh">let A = threeSum([-0,1,-1,1,-0,0]);<br/>A = A.length;</span><span id="3c72" class="lc ld in ky b gy li lf l lg lh">// A = ? (number)</span></pre><p id="c550" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在今天的挑战中，我们正在处理一个函数<code class="fe lj lk ll ky b">threeSum</code>，我不知道它是做什么的，但它与三和有关。</p><p id="3153" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">挑战希望我们解决<code class="fe lj lk ll ky b">A</code>，它是<code class="fe lj lk ll ky b">threeSum</code>输出的<code class="fe lj lk ll ky b">length</code>。这个函数返回一个数组<code class="fe lj lk ll ky b">list</code>。</p><p id="3d54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不知道这个函数做什么，但是我们知道它的输出。让我们弄清楚这个<code class="fe lj lk ll ky b">list</code>数组是如何被填充的。我们发现向该数组添加项目的唯一地方是这里:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d945" class="lc ld in ky b gy le lf l lg lh">} else if (nums[left] + nums[right] + nums[i] === 0) {<br/>   list.push([nums[left], nums[right], nums[i]]);<br/>   ...<br/>}</span></pre><p id="632e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所见，当来自<code class="fe lj lk ll ky b">nums</code>(输入)的三个数之和等于零时，它将一个项(数组)推入<code class="fe lj lk ll ky b">list</code>。简而言之，该算法旨在寻找总和为零的三元组。</p><p id="258d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们全面分析代码时，我们看到输入数组<code class="fe lj lk ll ky b">nums</code>是按升序排序的；最外层的for循环遍历由<code class="fe lj lk ll ky b">i</code>索引的<code class="fe lj lk ll ky b">nums</code>中的每个数字；其后是位于<code class="fe lj lk ll ky b">i</code>右侧的<code class="fe lj lk ll ky b">left</code>和<code class="fe lj lk ll ky b">right</code>指针。以这种方式，该算法仅搜索总和为零的唯一三元组。这里有一些伪代码来说明这个过程:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8d72" class="lc ld in ky b gy le lf l lg lh">nums = [-0, 1, -1, 1, -0, 0]<br/>-&gt; sort<br/>nums = [-1, -0, -0, 0, 1, 1]</span><span id="5f5d" class="lc ld in ky b gy li lf l lg lh">----------<br/>    i = 0<br/> left = 0<br/>right = 5<br/>...<br/>(-0) + 1 + (-1) = 0  --&gt; push<br/>    i = 0<br/> left = 1<br/>right = 5<br/>----------<br/>    i = 1<br/> left = 1<br/>right = 5<br/>...<br/>(-0) + 0 + (-0) = 0  --&gt; push<br/>    i = 1<br/> left = 2<br/>right = 3<br/>----------</span><span id="ff29" class="lc ld in ky b gy li lf l lg lh">for all other attempts:<br/>i + left + right !== 0</span><span id="37fc" class="lc ld in ky b gy li lf l lg lh">list.length == 2</span></pre><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/71623862e4ee72d2967eb3ecb0a5de26.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/0*HEJB1bBh2mve06ZN.png"/></div></figure><p id="6624" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。今天就在<a class="ae ln" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>开始行动，成为一名认证Codr</p></div></div>    
</body>
</html>