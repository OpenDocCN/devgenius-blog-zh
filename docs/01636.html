<html>
<head>
<title>Ruby Basics: Local Variable Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby 基础:局部变量范围</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-basics-local-variable-scope-3e98cc3d2a37?source=collection_archive---------18-----------------------#2020-07-08">https://blog.devgenius.io/ruby-basics-local-variable-scope-3e98cc3d2a37?source=collection_archive---------18-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ddd0a9e4095ad2bc3b4a5b26c9294be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UoLSNFjmvD8A2sTG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e337" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我想谈谈 Ruby 中的局部变量作用域。这是一个经常让初学者(包括我自己)感到困惑的话题，但是对于能够编写和调试 Ruby 程序来说却是至关重要的。首先，我们来定义一下什么是局部变量作用域。变量的作用域定义了该变量在程序中的可访问位置。所以当我们谈论局部变量作用域时，我们谈论的是定义局部变量在程序中何处可访问的规则。其他变量，如全局变量、类变量和实例变量，有不同的作用域规则。在这篇文章中，我只会提到变量；要知道这意味着局部变量。但是说够了，让我们看一些例子！你认为这段代码会输出什么？</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="ab30" class="lj lk in lf b gy ll lm l ln lo">Output: <strong class="lf io">undefined local variable or method `a’ for main:Object (NameError)</strong></span></pre><p id="e8ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">乍一看，它似乎会输出 1，但我们得到的是 NameError。这是为什么呢？因为循环方法(是的，它是一个<a class="ae jz" href="https://docs.ruby-lang.org/en/2.6.0/Kernel.html#method-i-loop" rel="noopener ugc nofollow" target="_blank">方法</a>)接受了一个块，并且这个块创建了自己的作用域。变量是在块内初始化的，所以我们不能在块外访问它。我们如何修正我们的代码？像这样！</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="09b3" class="lj lk in lf b gy ll lm l ln lo">Output: 1</span></pre><p id="593f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们在初始化变量<strong class="kc io">的块中调用了变量</strong>的 puts，所以我们可以访问它。这个也行。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="6a56" class="lj lk in lf b gy ll lm l ln lo">Output: 1</span></pre><p id="c4ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为内部循环可以访问外部循环的范围，但反之则不行。另一种方法是这样的。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="1fbd" class="lj lk in lf b gy ll lm l ln lo">Output: 1</span></pre><p id="6e38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，我们在循环外初始化<strong class="kc io"> a </strong>，在循环内将其重新赋值给<strong class="kc io"> a + 1 </strong>，在循环外输出<strong class="kc io"> a </strong>。这表明当一个块创建一个新的作用域时，它仍然可以访问在外部作用域中初始化的变量，但是在块内部初始化的变量在块外部是不可访问的。迭代数组和哈希方法也是如此。例如:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="9dd4" class="lj lk in lf b gy ll lm l ln lo">Output: <strong class="lf io">undefined local variable or method `a’ for main:Object (NameError)</strong></span></pre><p id="fa31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像在循环例子中一样，我们得到一个错误，因为我们在一个块中初始化了一个变量，并试图在它定义的范围之外调用它。修复这段代码的方法类似于我们处理循环的方法。如果你好奇，可以在 IRB 或文本编辑器中尝试一下。在这一点上，你可能会像我一样认为，每当我们使用一个块时，就会创建一个新的作用域，就像这样。</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="5948" class="lj lk in lf b gy ll lm l ln lo">do. . .end or { #code }</span></pre><p id="492d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是真的，但有时外表可能具有欺骗性。例如，下面的代码可以工作。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="dd0a" class="lj lk in lf b gy ll lm l ln lo">Output: 1</span></pre><p id="4387" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为<strong class="kc io">而</strong>被归类为<a class="ae jz" href="https://docs.ruby-lang.org/en/2.6.0/syntax/control_expressions_rdoc.html" rel="noopener ugc nofollow" target="_blank">控制表达式</a>，而不是方法。<strong class="kc io"> do…end </strong>部分看起来仍然可疑地像一个块，但是如果你检查文档，你会发现<strong class="kc io"> do </strong>关键字是可选的。这意味着当您使用 while 循环时，您实际上并没有创建新的作用域，因为从技术上讲，您并没有使用块。这同样适用于其他控制表达式，如 if 语句的<strong class="kc io">和 for </strong>循环的<strong class="kc io">。语法使它变得混乱，因为看起来你在创建一个新的作用域，但你没有。如果您不确定是否正在创建一个新的作用域，请在 IRB 中尝试一下，或者查看文档，看看您是否正在使用一个方法或一个控制表达式。我们已经讨论了很多，但是还有一件事要讨论，就是使用方法时的局部变量范围。</strong></p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="e01d" class="lj lk in lf b gy ll lm l ln lo">Output: <strong class="lf io">undefined method `+’ for nil:NilClass (NoMethodError)</strong></span></pre><p id="57ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生了什么事？首先，我们将变量<strong class="kc io"> a </strong>初始化为 0。然后我们定义一个方法，<strong class="kc io"> add_two </strong>，给<strong class="kc io"> a 加二</strong>之后我们调用方法<strong class="kc io"> add_two </strong>，最后我们输出<strong class="kc io"> a </strong>。然而，在我们能够输出<strong class="kc io"> a </strong>之前，出现了一个错误。这是因为方法有自己的作用域规则。在方法内部不能访问在方法外部初始化的变量，在方法外部也不能访问在方法内部初始化的变量。一个例外是，如果您将变量作为参数传递给方法。例如，我们可以通过这样做来修复我们的代码。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="58e0" class="lj lk in lf b gy ll lm l ln lo">Output: 2</span></pre><p id="56c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们在我们的方法中使用了一个名为<strong class="kc io"> num </strong>的参数，并给它加了 2。因为<strong class="kc io"> num += 2 </strong>是该方法的最后一行，所以该表达式的值被自动返回。然后，我们将<strong class="kc io"> a </strong>设置为等于<strong class="kc io"> add_two(a) </strong>的返回值，该返回值具有作为参数传入的<strong class="kc io"> a </strong>。最后，我们输出<strong class="kc io">一个</strong>，它现在等于 2。</p><p id="2ebf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望您喜欢这篇关于可变作用域的介绍。这可能是一个棘手的概念，但学习它有助于编写更好的程序，并在我出错时更快地调试。感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>