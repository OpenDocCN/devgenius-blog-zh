<html>
<head>
<title>Python — Threading In Python3, Part Two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python——python 3 中的线程，第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-threading-in-python3-part-two-c711c17409ce?source=collection_archive---------12-----------------------#2022-11-26">https://blog.devgenius.io/python-threading-in-python3-part-two-c711c17409ce?source=collection_archive---------12-----------------------#2022-11-26</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="47b2" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Python3 线程游戏攻略</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/e5cf45ab603dd9e25c253bb7f4e15ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*jplBqMrlhQP4RIy1.png"/></div></figure><h1 id="9743" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">竞态条件</h1><p id="7a01" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">上接“<a class="ae mc" href="https://medium.com/@tonylixu/python-threading-in-python3-part-one-cfadc174ceb8" rel="noopener">Python—Python 3 中的线程化，第一部分</a>”，你认为有了“ThreadPoolExecutor”就足以管理 Python 线程了吗？编写线程代码时经常会遇到的一个常见问题是:竞争条件！</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/310d445f0c8dbc37d20897b412e946c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*qm7jZ0f_29gLVOkn.png"/></div></figure><p id="cf4b" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">“竞争条件”是软件或其他系统的条件，其中系统的实质性行为取决于其他不可控事件的顺序或时间。在 Python 中，当两个或多个线程访问一个共享资源时，会发生争用情况。让我们首先创建一个竞争条件:</p><pre class="kh ki kj kk gu mi mj mk bn ml mm bi"><span id="7843" class="mn kp ir mj b be mo mp l mq mr">import concurrent.futures<br/>import time<br/><br/>class ShoppingCart:<br/>    def __init__(self):<br/>        self.items = 0<br/>        # self._lock = threading.Lock()<br/><br/>    def update(self, name):<br/>        print(f'Customer-{name}: starting update')<br/>        # with self._lock:<br/>        #    print(f'Customer-{name} has lock')<br/>        local_cart = self.items<br/>        local_cart += 1<br/>        time.sleep(1)<br/>        self.items = local_cart<br/>        #    print(f'Customer-{name} releases lock')<br/>        print(f'Customer-{name}: finishing update')<br/><br/>def main():<br/>    print(f'Main: Before starting shopping')<br/>    shopping_cart = ShoppingCart()<br/>    print(f'Start shopping, the cart is {shopping_cart.items}')<br/>    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as customer:<br/>        customer.map(shopping_cart.update, range(2))<br/>    print(f'Finish shopping, the cart is {shopping_cart.items}')<br/>    print(f'Main: After finishing shopping')<br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="d2cd" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">如果运行上述代码，您将看到以下输出:</p><pre class="kh ki kj kk gu mi mj mk bn ml mm bi"><span id="0883" class="mn kp ir mj b be mo mp l mq mr">Main: Before starting shopping<br/>Start shopping, the cart is 0<br/>Customer-0: starting update<br/>Customer-1: starting update<br/>Customer-0: finishing update<br/>Customer-1: finishing update<br/>Finish shopping, the cart is 1<br/>Main: After finishing shopping</span></pre><p id="a494" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">那么，这到底是怎么回事！？我们有三个顾客在我们的网站上购物，都购买了 1 件商品，但是为什么购买的商品总数仍然是 1 件！！！这意味着一个顾客丢失了他/她购买的物品，这是不好的。现在让我们更深入地看看发生了什么。</p><h1 id="70d3" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">有根据的猜测</h1><p id="d45e" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">首先，我想让你根据事实猜测一下为什么其中一位顾客丢失了他们购买的物品？一个提示是 Python3 中的线程不会同时运行，即使它们有时看起来是同时运行的。其次，每个线程都有自己的变量本地副本，当一个线程运行时，它不知道另一个线程在它们自己的空间里有什么。比如下图:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ms"><img src="../Images/46fb4e36a8305efa81186266850c7c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*VNc5aZR8-URSr64K.png"/></div></figure><p id="a0d4" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">两个线程都引用同一个 shopping_cart 对象。很有可能，thread1 和 thread2 被同一个对象的“self.items”值覆盖。</p><h1 id="1307" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">详细解释:</h1><p id="fc7a" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">现在我来说明一下真实情况。当两个线程被初始化时，它们都有自己的“local_cart”版本，但是都引用同一个 ShoppingCart 对象，如上图所示。</p><p id="0551" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">现在让我们假设“线程 1”首先运行，它将自己版本的“local_cart”初始化为“shopping_cart”对象“self.items”，此时，“local _ cart”=“self . items”= 0</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/02e73677379712915016905f95c29aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*6CORtlr5WsXxZglH.png"/></div></figure><p id="6e63" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">现在“线程 1”将“local_cart”从 0 增加到 1，然后休眠 1 秒钟。然后“线程 2”开始运行，类似于“线程 1”，它将自己版本的“local_cart”初始化为“shopping_cart”对象“self.items”，此时，“local _ cart”=“self . items”= 0</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/173574cb36a0c6e0d9bed5adfc305857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*NOgnxUF6Xd9k61FA.png"/></div></figure><p id="affa" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">现在“线程 2”进入睡眠，“线程 1”醒来并将其“local_cart”的副本写入“self.items”，现在“shopping_cart”对象“self.items”为 1。然后“线程 1”完成它的运行。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/49d83eb5535261d4c2f3669805010e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*j7LANMWsbaAbPikF.png"/></div></figure><p id="914a" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">“线程 2”再次醒来，现在是有趣的部分，“线程 2”不知道“线程 1”刚刚将“self.items”更新为 1，它将自己版本的“local_cart”存储到同一对象的“self.items”中。“self.items”值保持为 1。</p><p id="9eca" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">这两个线程交叉访问单个共享对象，覆盖彼此的结果。当一个线程在另一个线程完成访问之前释放内存或关闭文件句柄时，也会出现类似的争用情况。</p><h1 id="5c35" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">如何解决竞态？</h1><p id="6ad4" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">解决竞态条件有几种不同的方法。但是它们背后的思想都是一次只允许一个线程共享资源。我们将在本文中重点讨论<code class="fe mt mu mv mj b">Lock</code>。</p><h2 id="74dc" class="mw kp ir bd kq mx my dn ku mz na dp ky lp nb nc la lt nd ne lc lx nf ng le nh bi translated">锁</h2><p id="a6bd" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这里的想法是实现对资源的“锁定”,并且一次只允许一个线程进入代码的读取/更新部分。在 Python3 线程中，完成这项工作的基本函数是<code class="fe mt mu mv mj b">.acquire()</code>和<code class="fe mt mu mv mj b">.release()</code>。<code class="fe mt mu mv mj b">.acquire()</code>被调用以获取锁，如果锁已经被给定，请求线程将等待直到它被释放。在某些情况下，这可能导致一个<code class="fe mt mu mv mj b">deadlock</code>的情况，如果一个线程由于某种原因没有返回锁，你的线程将被卡住。为了避免<code class="fe mt mu mv mj b">deadlock</code>，请始终使用<code class="fe mt mu mv mj b">with</code>上下文管理器。</p><p id="576e" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">现在回到我们的程序，让我们删除注释并启用锁:</p><pre class="kh ki kj kk gu mi mj mk bn ml mm bi"><span id="b520" class="mn kp ir mj b be mo mp l mq mr">import concurrent.futures<br/>import threading<br/>import time<br/><br/>class ShoppingCart:<br/>    def __init__(self):<br/>        self.items = 0<br/>        self._lock = threading.Lock()<br/>    def update(self, name):<br/>        print(f'Customer-{name}: starting update')<br/>        with self._lock:<br/>            print(f'Customer-{name} has lock')<br/>            local_cart = self.items<br/>            local_cart += 1<br/>            time.sleep(1)<br/>            self.items = local_cart<br/>            print(f'Customer-{name} releases lock')<br/>        print(f'Customer-{name}: finishing update')<br/><br/>def main():<br/>    print(f'Main: Before starting shopping')<br/>    shopping_cart = ShoppingCart()<br/>    print(f'Start shopping, the cart is {shopping_cart.items}')<br/>    with concurrent.futures.ThreadPoolExecutor(max_workers=2) as customer:<br/>        customer.map(shopping_cart.update, range(2))<br/>    print(f'Finish shopping, the cart is {shopping_cart.items}')<br/>    print(f'Main: After finishing shopping')<br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="c5a7" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">运行它:</p><pre class="kh ki kj kk gu mi mj mk bn ml mm bi"><span id="f257" class="mn kp ir mj b be mo mp l mq mr">Main: Before starting shopping<br/>Start shopping, the cart is 0<br/>Customer-0: starting update<br/>Customer-0 has lock<br/>Customer-1: starting update<br/>Customer-0 releases lock<br/>Customer-0: finishing update<br/>Customer-1 has lock<br/>Customer-1 releases lock<br/>Customer-1: finishing update<br/>Finish shopping, the cart is 2<br/>Main: After finishing shopping</span></pre><p id="f753" class="pw-post-body-paragraph lg lh ir li b lj md js ll lm me jv lo lp mf lr ls lt mg lv lw lx mh lz ma mb ik bi translated">由于我们使用了<code class="fe mt mu mv mj b">with</code>上下文管理器:<code class="fe mt mu mv mj b">with self._lock</code>，锁将在解锁状态下初始化，并自动锁定/释放。始终建议使用上下文管理器，以避免<code class="fe mt mu mv mj b">deadlock</code>。</p></div></div>    
</body>
</html>