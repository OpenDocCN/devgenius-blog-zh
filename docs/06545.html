<html>
<head>
<title>Using RabbitMQ with Golang and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 RabbitMQ 与 Golang 和 Docker 一起使用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-rabbitmq-with-golang-and-docker-e674831c959c?source=collection_archive---------0-----------------------#2022-01-16">https://blog.devgenius.io/using-rabbitmq-with-golang-and-docker-e674831c959c?source=collection_archive---------0-----------------------#2022-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/20f3b34bc8e6b3df42f41e93a0b97b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*152qGG29jv135B3O146svA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">故事预览图像</figcaption></figure><h1 id="d64a" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="37a2" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在这篇博客中，我将介绍如何在 Golang 中创建 RabbitMQ 生产者和消费者，并使用 docker-compose 将 RabbitMQ 部署到我们的服务中。</p><h2 id="3e40" class="lv ka in bd kb lw lx dn kf ly lz dp kj li ma mb kn lm mc md kr lq me mf kv mg bi translated">兔子 q</h2><p id="4c77" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">RabbitMQ 是最受欢迎的消息代理之一。RabbitMQ 是轻量级的，易于在内部和云中部署。</p><p id="18dc" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">各种服务之间的可靠通信是任何应用程序的基础构件之一。RabbitMQ 支持各种通信模型，如消息队列、发布/订阅等。</p><blockquote class="mn mo mp"><p id="c596" class="kx ky mq kz b la mi lc ld le mj lg lh mr mk lk ll ms ml lo lp mt mm ls lt lu ig bi translated">生产者是将消息放入消息队列的服务。</p><p id="8b87" class="kx ky mq kz b la mi lc ld le mj lg lh mr mk lk ll ms ml lo lp mt mm ls lt lu ig bi translated">消费者是一种服务，当消息队列中的消息可用时，它会使用该消息。一旦消息被消费，消费者服务就可以执行为消息指定的任务。</p></blockquote></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><h1 id="9593" class="jz ka in bd kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw bi translated">运行 RabbitMQ</h1><p id="e427" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在创建生产者和消费者服务之前，让我们使用 Docker 构建一个独立的 RabbitMQ 实例。</p><p id="ea42" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">首先，让我们创建一个基本的<code class="fe ng nh ni nj b">rabbitmq.conf</code>文件作为 RabbitMQ 配置的占位符。从 RabbitMQ 3.9 开始，不赞成通过 Docker 特定环境变量进行配置，因此需要创建一个配置文件。更多详情，请参考<a class="ae mh" href="https://www.rabbitmq.com/configure.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ 文档</a>。</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="0fc7" class="lv ka in nj b gy ns nt l nu nv">listeners.tcp.default = 5673</span></pre><p id="3445" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里，我们只是改变默认的 TCP 端口，但是可以根据需要在这个文件中添加更多的配置。</p><p id="d496" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">现在让我们为 RabbitMQ 服务创建 docker-compose 文件。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6438" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">在这里，我们将本地的<code class="fe ng nh ni nj b">rabbitmq.conf</code>文件挂载到<code class="fe ng nh ni nj b">/etc/rabbitmq/rabbitmq.conf</code>中。</p><p id="68cf" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">我们使用了<code class="fe ng nh ni nj b">rabbitmq:3-management</code>镜像，它包含了管理 RabbitMQ 实例的附加插件。对于我们的开发环境，我们将 5673 端口作为 5000，将 15672 端口作为 8080，用于 RabbitMQ 管理 UI <code class="fe ng nh ni nj b">(http://localhost:8080)</code>。</p><p id="6779" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">此外，我们正在创建一个桥接网络<code class="fe ng nh ni nj b">rabbitmq-example</code>，稍后我们将使用它来部署我们的生产者和消费者容器。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><h1 id="8f5f" class="jz ka in bd kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw bi translated">生产者</h1><p id="4c65" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">让我们创建一个基本的生产者服务，它将在消息队列中发布消息。我将使用我的<a class="ae mh" href="https://github.com/lakhinsu/gin-boilerplate" rel="noopener ugc nofollow" target="_blank"> REST API 样板代码</a>来创建一个 REST 服务，它将在收到 POST 请求时在队列中发布一条消息。</p><p id="b190" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里有一些发布消息的关键代码片段，查看我的<a class="ae mh" href="https://github.com/lakhinsu/rabbitmq-go-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>获取完整代码。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="179a" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">在这段代码中，我们创建了一个包含队列名称和连接字符串字段的 RMQProducer 结构，可以根据需要在这里添加更多的字段。</p><p id="0dba" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">我们的代码正在使用<a class="ae mh" href="https://github.com/streadway/amqp" rel="noopener ugc nofollow" target="_blank">https://github.com/streadway/amqp</a>rabbit MQ 客户端库。这个库非常成熟，甚至出现在官方的<a class="ae mh" href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ 教程</a>中。</p><p id="d3ab" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">我们的 REST 处理程序将使用<code class="fe ng nh ni nj b">PublishMessage</code>方法在<em class="mq">示例</em>队列中发布消息。</p><p id="4a17" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">由<code class="fe ng nh ni nj b">PublishMessage</code>方法执行的步骤，</p><ol class=""><li id="20ea" class="ny nz in kz b la mi le mj li oa lm ob lq oc lu od oe of og bi translated">使用指定的连接字符串通过 RabbitMQ 拨号。</li><li id="9494" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">打开一个频道。</li><li id="8df2" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">声明一个队列来发布消息。声明一个队列是幂等的，一个新的队列只有在它不存在时才会被创建，否则，将使用现有的队列。</li><li id="f3b7" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">在指定的队列上发布消息。</li></ol><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="52be" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">我们将发布一条内容类型为“text/plain”的新消息，并在 POST 请求中接收有效负载。</p><p id="3447" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">在这里，下面这段代码创建了一个新的<code class="fe ng nh ni nj b">RMQProducer</code>,将队列名和连接字符串作为参数。</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="0667" class="lv ka in nj b gy ns nt l nu nv">connectionString := utils.GetEnvVar("RMQ_URL")</span><span id="e30a" class="lv ka in nj b gy om nt l nu nv">rmqProducer := utils.RMQProducer{</span><span id="6ffe" class="lv ka in nj b gy om nt l nu nv">consts.EXAMPLE_QUEUE,</span><span id="bd97" class="lv ka in nj b gy om nt l nu nv">connectionString,</span><span id="869a" class="lv ka in nj b gy om nt l nu nv">}</span></pre></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><h1 id="7db9" class="jz ka in bd kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw bi translated">消费者</h1><p id="bb6f" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">接下来，让我们创建一个 Go 服务，它将不断地监听指定队列上的消息，并在收到消息后执行一些操作。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="eb51" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里，我们定义了一个具有字段<code class="fe ng nh ni nj b">Queue</code>(监听消息的队列的名称)<code class="fe ng nh ni nj b">ConnectionString</code> (RabbitMQ 连接字符串)和<code class="fe ng nh ni nj b">MsgHandler</code>(一旦接收到消息就会调用的函数)的结构。</p><p id="c2ca" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">由<code class="fe ng nh ni nj b">Consume</code>方法执行的步骤，</p><ol class=""><li id="fb7e" class="ny nz in kz b la mi le mj li oa lm ob lq oc lu od oe of og bi translated">用 RabbitMQ 拨号。</li><li id="0bc6" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">打开一个频道。</li><li id="fbc0" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">用指定的名称声明队列。注意，我们还在消费者中声明了队列，因为当消费者启动时，队列可能不存在。RabbitMQ 中的队列声明是幂等的。</li><li id="6574" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu od oe of og bi translated">开始使用消息，一旦收到消息，就用消息有效负载调用<code class="fe ng nh ni nj b">MsgHandler</code>函数。</li></ol><p id="aec7" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">现在让我们创建一个基本的消息处理函数。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6f09" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">一旦在<em class="mq">示例</em>队列中收到消息，我们的<code class="fe ng nh ni nj b">HandleExample</code>函数将被调用。这里，我们只是记录消息，但是这可以用所需的业务逻辑来代替。</p><p id="b27c" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">现在让我们初始化我们的消费者服务。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ea3f" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里，我们使用<code class="fe ng nh ni nj b">RMQConsumer</code>声明了一个新的消费者，并开始使用<code class="fe ng nh ni nj b">Consume()</code>方法监听消息。</p><p id="635f" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这些是创建消费者的关键代码片段，完整代码请参考我的<a class="ae mh" href="https://github.com/lakhinsu/rabbitmq-go-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="5d93" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">让我们测试我们的生产者和消费者服务，</p><ol class=""><li id="696a" class="ny nz in kz b la mi le mj li oa lm ob lq oc lu od oe of og bi translated">调用 REST API 来生成消息</li></ol><figure class="nk nl nm nn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/7b6d82416011840175d73b0ad0b62972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HI8j4QJqE2272B2kRwnZQA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用失眠症 REST 客户端调用 REST API</figcaption></figure><p id="de05" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">2.让我们检查我们的消费者控制台的日志消息</p><figure class="nk nl nm nn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oo"><img src="../Images/8939e877058948b5c4c65a586e53c12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjvJoRsBed7RTNm_vJmqpQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">消费者收到的消息</figcaption></figure><p id="51b7" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">在控制台中，我们可以看到消息被消费者成功接收。</p><p id="ebc0" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">既然我们已经测试了生产者和消费者服务的工作情况，让我们使用 docker-compose 来部署这些服务。</p><h1 id="7f5a" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">部署这些服务</h1><p id="c498" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">为了部署这些服务，我们将修改之前创建的 docker-compose.yaml 文件。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d401" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里，我们已经指定了我们的生产者和消费者服务依赖于 RabbitMQ 实例，并且还为我们的 RabbitMQ 实例指定了<code class="fe ng nh ni nj b">healthcheck</code>。</p><p id="8d23" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">使用<code class="fe ng nh ni nj b">docker-compose up</code>命令部署我们的服务。</p><figure class="nk nl nm nn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/20f3b34bc8e6b3df42f41e93a0b97b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*152qGG29jv135B3O146svA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">RabbitMQ 实例、生产者和消费者服务的 Docker 容器。</figcaption></figure><p id="48f9" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">我们的 RabbitMQ 实例、生产者和消费者服务已成功部署。</p><p id="0cd6" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">这里，我们已经添加了生产者和消费者服务以及必要的环境变量。我们可以使用 5050 端口访问 REST 服务。</p><p id="ac70" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated">让我们通过调用部署的 REST 服务来验证我们的配置，让我们检查 docker 容器中的消费者服务日志。</p><figure class="nk nl nm nn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/c7017f61220ec66350bc9c31c132b717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFDCoDFMwwH1Pyv3kwKnrQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">消费者在 docker 容器中收到的消息</figcaption></figure><h1 id="b693" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">闭幕词</h1><p id="ba9f" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这是一个使用 RabbitMQ 作为 Golang 的消息队列并创建一个<code class="fe ng nh ni nj b">docker-compose.yaml</code>文件来部署我们的服务的基本例子。在 my <a class="ae mh" href="https://github.com/lakhinsu/rabbitmq-go-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>查看完整代码。此外，您可以随意以任何方式和能力使用示例代码。</p><h1 id="219f" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><ul class=""><li id="c954" class="ny nz in kz b la lb le lf li oq lm or lq os lu ot oe of og bi translated"><a class="ae mh" href="https://www.rabbitmq.com/#getstarted" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/#getstarted</a></li><li id="689d" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://hub.docker.com/_/rabbitmq" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/rabbitmq</a></li><li id="15bc" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/</a></li><li id="b637" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://www.rabbitmq.com/configure.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/configure.html</a></li><li id="b7b1" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/tutorials/tutorial-one-go.html</a></li><li id="53fe" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://www.rabbitmq.com/devtools.html#go-dev" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/devtools.html#go-dev</a></li><li id="21ee" class="ny nz in kz b la oh le oi li oj lm ok lq ol lu ot oe of og bi translated"><a class="ae mh" href="https://github.com/lakhinsu/gin-boilerplate" rel="noopener ugc nofollow" target="_blank">https://github.com/lakhinsu/gin-boilerplate</a></li></ul><p id="9c2e" class="pw-post-body-paragraph kx ky in kz b la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu ig bi translated"><strong class="kz io">感谢您的阅读！</strong></p></div></div>    
</body>
</html>