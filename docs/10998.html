<html>
<head>
<title>Data Unit Testing With Great Expectations and Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大期望和云功能的数据单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-unit-testing-with-great-expectations-and-cloud-functions-f739cee0bc95?source=collection_archive---------16-----------------------#2022-12-12">https://blog.devgenius.io/data-unit-testing-with-great-expectations-and-cloud-functions-f739cee0bc95?source=collection_archive---------16-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4bfc161fcadc13f1d4f371b241d73020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CoAoEcLGxlNWYy978AkAYg.jpeg"/></div></div></figure><p id="fc31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 AirQo，我们每天从部署在非洲大陆各地的低成本监视器中收集大量数据，其中大部分位于乌干达，此外还有来自我们的合作伙伴(如坎帕拉首都城市管理局)的数据，这些数据每小时都在流动，这导致我们收集的信息呈指数级增长。</p><p id="2656" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理想情况下，在将数据存储到数据仓库之前，应该对其进行质量检查，这可以通过数据单元测试来完成。</p><p id="48fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在数据工程领域，数据单元测试是一个相对较新的概念，它对组织存储的数据进行质量检查。测试可以在数据管道的任何阶段进行，也可以在数据存储之后进行。这些测试有助于检测错误，如超出范围的值、丢失的数据和不正确的数据类型。</p><p id="0e1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本教程的目标是解释如何在数据管道的任何阶段建立数据单元测试。我们将使用一个名为<a class="ae kt" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank">远大前程</a>的 Python 开源库。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ku"><img src="../Images/ba01f4bd03e7de39b7aa79e4f5d35328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q_OJt4Ojl6y9DRvP"/></div></div></figure><p id="0294" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">《远大前程》提供了名为<strong class="jx io">期望</strong>的预先编写的测试，我们需要做的就是指定他们需要的测试，并为他们提供参数，我们将在本教程中看到</p><p id="47ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它还生成人们可读的文档，称为数据文档，总结可能在数据中发现的任何问题。</p><p id="be5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还将利用 Google Cloud 函数作为数据测试的触发器，并使用从数据管道中捕获的数据</p><h1 id="9e2f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">本教程的先决条件:</h1><ul class=""><li id="f9cb" class="lx ly in jx b jy lz kc ma kg mb kk mc ko md ks me mf mg mh bi translated">谷歌云项目平台中的 2 个数据桶</li><li id="6a13" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">本地运行的机器</li><li id="b7a3" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">本地安装的 gcloud SDK。</li></ul><p id="43a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还将使用来自<a class="ae kt" href="https://www.sciencedirect.com/science/article/pii/S2352340922007065" rel="noopener ugc nofollow" target="_blank"> AirQo </a>数据的样本数据集，但是您可以自由使用您选择的任何样本数据集，因为概念保持不变。</p><p id="0071" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">下面是我们将要使用的数据集的屏幕截图。</strong></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/e8600b9107e24858449e4ac26bf941bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OsqmivdLxWfB4Jrl"/></div></div></figure><p id="1014" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这项任务可以分为 3 个主要步骤:</p><ul class=""><li id="bf0e" class="lx ly in jx b jy jz kc kd kg ms kk mt ko mu ks me mf mg mh bi translated">设置 Great_expectations 并在本地进行配置。</li><li id="c9df" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">将配置上传到 GCP</li><li id="e751" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">创建并上传云功能到 GCP</li></ul><p id="5eb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用<code class="fe mn mo mp mq b">great_expectations</code>时，我们将使用三个主要概念:</p><ul class=""><li id="9879" class="lx ly in jx b jy jz kc kd kg ms kk mt ko mu ks me mf mg mh bi translated"><strong class="jx io">期望</strong> —这些是关于数据的可验证的断言，即我们将测试什么。这些可以一起保存在一个称为期望套件的文件中</li><li id="3b09" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated"><strong class="jx io">一个数据环境</strong> —一个远大前程部署的主要入口点，包含所有支持组件的配置和方法。</li><li id="c6a8" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated"><strong class="jx io">检查点</strong> —这是在高期望值的生产部署中验证数据的主要方法。</li></ul><p id="9d14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多概念在<a class="ae kt" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank">远大前程</a>网站上有详细介绍。他们还提供了一个很棒的<a class="ae kt" href="https://docs.greatexpectations.io/docs/tutorials/getting_started/tutorial_overview" rel="noopener ugc nofollow" target="_blank">入门教程</a>，我建议你在继续之前查看一下，快速了解一下这个库。本教程是一个用例，其中一个文件存储在谷歌云平台上，我们将从本地配置我们的数据上下文开始，然后上传到 GCP。</p><p id="f10d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧。我们继续吗？</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5499c3d7effbca15605f90350673481b.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*lfhipPUA5gleeCwK27LM8g.gif"/></div></figure><h1 id="c0ba" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第一步</h1><p id="ab50" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">在您的计算机上创建一个新目录，并运行以下命令:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="64ac" class="nd la in mq b be ne nf l ng nh">$ python3 -m venv venv $ source venv/bin/activate<br/>$ source venv/bin/activate</span></pre><p id="fbff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这创造了我们将要工作的虚拟环境。根据您机器的 python 安装，第一条指令也可以写成如下形式:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="b83b" class="nd la in mq b be ne nf l ng nh">$ python -m venv venv<br/>$ source venv/bin/activate</span></pre><h1 id="d82c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第二步</h1><p id="6128" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">安装 great expectations 并创建一个数据环境和一个期望套件。</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="375b" class="nd la in mq b be ne nf l ng nh">$ python3 -m pip install great_expectations<br/>$ great_expectations –-version</span></pre><p id="1b9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一行在我们的环境中安装 great_expectations，第二行验证它是否已经安装。您应该会收到来自终端的如下输出:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="5a33" class="nd la in mq b be ne nf l ng nh">&gt; great_expectations, version 0.15.34</span></pre><h1 id="c26e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第三步</h1><p id="7792" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">首先在你的本地机器上初始化和配置数据上下文，然后我们将它上传到 GCP。</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="978b" class="nd la in mq b be ne nf l ng nh">$ great_expectations init<br/>$ great_expectations suite new</span></pre><p id="cb9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一行创建我们将在其中工作的数据上下文，而第二行返回创建期望时可用选项的提示。<strong class="jx io">选项包括:</strong></p><ol class=""><li id="1ec4" class="lx ly in jx b jy jz kc kd kg ms kk mt ko mu ks ni mf mg mh bi translated">在没有样本数据的情况下手动创建期望值</li><li id="55d2" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks ni mf mg mh bi translated">根据一批样本数据创建预期，以快速验证您的预期</li><li id="5d87" class="lx ly in jx b jy mi kc mj kg mk kk ml ko mm ks ni mf mg mh bi translated">自动使用数据助理。在这里，框架自动分析您的数据，并创建一些期望，您可以在以后轻松地进行配置。</li></ol><p id="3b5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于本教程，我们将使用选项 1，因为我们的数据不是存储在本地，而是存储在 GCP。</p><p id="bff3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择选项 1 后，将创建一个 Jupyter 笔记本，您将使用它来创建套件，并请求为套件命名，我们将使用 airqo_data_tests。</p><h1 id="aafe" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第四步</h1><p id="19d0" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">删除第一个单元格的内容，并替换为以下内容:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="2d57" class="nd la in mq b be ne nf l ng nh">import great_expectations as ge<br/>import great_expectations.jupyter_ux<br/>from great_expectations.core.expectation_configuration import ExpectationConfiguration<br/><br/>context = ge.data_context.DataContext()<br/>suite = context.create_expectation_suite(<br/>expectation_suite_name="airqo_data_tests", overwrite_existing=True<br/>)<br/><br/>print(f'Created ExpectationSuite "{suite.expectation_suite_name}".')</span></pre><p id="7e26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就创建了您的期望套件。你可以把这个期望套件命名为你认为合适的名称。</p><h1 id="3ba0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第五步</h1><p id="fe89" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">创建表和列期望。这些本质上是对数据的测试或验证。我将使用两个示例来让您对它们的结构有一个总体的了解。你在 Jupyter 笔记本的单元格中写下下面的语句并保存它:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="8e2b" class="nd la in mq b be ne nf l ng nh">python<br/>expectation_configuration = ExpectationConfiguration(<br/>expectation_type="expect_table_column_count_to_equal",<br/>kwargs={"value": 10},<br/>suite.add_expectation(expectation_configuration=expectation_configuration<br/>)</span></pre><p id="53ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的目的是创建一个期望，声明表应该具有在<code class="fe mn mo mp mq b">kwargs</code>参数中提供的列数。对于这个例子，我们首先在<code class="fe mn mo mp mq b">expectation_type</code>参数中指定期望，因为我们期望该表有 10 列，所以我们将值 10 传递给<code class="fe mn mo mp mq b">kwargs</code>参数。</p><p id="7772" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有你可以利用的期望都列在<a class="ae kt" href="https://greatexpectations.io/expectations" rel="noopener ugc nofollow" target="_blank">远大前程网站</a>上，所以你可以在网站上搜索你想利用的期望。</p><p id="e93f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建另一个期望，这个期望针对特定的列，而不是整个表。在笔记本中创建一个新单元格，并添加以下内容:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="afcb" class="nd la in mq b be ne nf l ng nh">expectation_configuration = ExpectationConfiguration(<br/>expectation_type="expect_column_min_to_be_between",<br/>kwargs={<br/>    "column": "latitude",<br/>    "min_value": -90,<br/>    "max_value":90,<br/>},<br/>)<br/>suite.add_expectation(expectation_configuration=expectation_configuration)</span></pre><p id="1714" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像前一个一样，结构是相似的，先传递<code class="fe mn mo mp mq b">expectation_type</code>，然后传递<code class="fe mn mo mp mq b">kwargs</code>，后者设置纬度列中的值。该值应大于或等于-90 且小于或等于 90</p><h1 id="e588" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第六步</h1><p id="e444" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">创建期望后，添加最后一个单元格，内容如下:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="a419" class="nd la in mq b be ne nf l ng nh">with open("../expectations/airqo_data_tests.json", "w") as expectation_store:<br/>import json<br/>json.dump(suite.to_json_dict(), expectation_store)</span></pre><p id="3d65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步将您的配置保存到一个 JSON 文件中，并构建数据文档</p><h1 id="3add" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第七步</h1><p id="5862" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">接下来，我们将在<code class="fe mn mo mp mq b">great_expectations</code>目录中创建一个名为<code class="fe mn mo mp mq b">loading_args</code>的目录。我们将在那里保存一个名为<code class="fe mn mo mp mq b">airqo_data_tests.yaml.</code> <strong class="jx io">(它应该与期望套件文件同名)</strong>。</p><p id="388d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们将添加一些我们想传递给熊猫<code class="fe mn mo mp mq b">pd.read_csv()</code>的论点。这是必要的，因为 Great Expectations 使用 pandas 作为这些测试的执行引擎。你可以在官方文件中找到更多相关信息。</p><p id="ffe3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在同一文件中，添加以下内容:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="1908" class="nd la in mq b be ne nf l ng nh">reader_options:<br/> index_col: False</span></pre><h1 id="46db" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第八步</h1><p id="64c6" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">我们继续配置 great_expectations 文件夹中的<code class="fe mn mo mp mq b">great_expectations.yaml</code>文件。该文件用于设置目标数据的位置以及存储其他信息的位置，如期望值、验证结果和数据文档。</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="7b38" class="nd la in mq b be ne nf l ng nh">yaml<br/>config_version: 3<br/><br/>datasources:<br/>  my_gcs_datasource:<br/>    class_name: Datasource<br/>    module_name: "great_expectations.datasource"<br/>    execution_engine:<br/>        class_name: PandasExecutionEngine<br/>    data_connectors:<br/>        default_runtime_data_connector_name:<br/>            class_name: RuntimeDataConnector<br/>            batch_identifiers:<br/>                - default_identifier_name<br/><br/>expectations_store_name: expectations_GCS_store<br/>validations_store_name: validations_GCS_store<br/>evaluation_parameter_store_name: "evaluation_parameter_store"<br/><br/>stores:<br/>    expectations_GCS_store:<br/>        class_name: ExpectationsStore<br/>        store_backend:<br/>            class_name: TupleGCSStoreBackend<br/>            project: ${PROJECT}<br/>            bucket: ${VALIDATION_BUCKET}<br/>            prefix: 'expectations'<br/><br/>    validations_GCS_store:<br/>        class_name: ValidationsStore<br/>        store_backend:<br/>            class_name: TupleGCSStoreBackend<br/>            project: ${PROJECT}<br/>            bucket: ${VALIDATION_BUCKET}<br/>            prefix: 'validations'<br/><br/>    evaluation_parameter_store:<br/>      class_name: EvaluationParameterStore<br/><br/>data_docs_sites:<br/>  gs_site:<br/>    class_name: SiteBuilder<br/>    store_backend:<br/>      class_name: TupleGCSStoreBackend<br/>      project: ${PROJECT}<br/>      bucket: ${VALIDATION_BUCKET}<br/>      prefix:<br/>    site_index_builder:<br/>      class_name: DefaultSiteIndexBuilder<br/><br/>validation_operators:<br/>  action_list_operator:<br/>    class_name: ActionListValidationOperator<br/>    action_list:<br/>    - name: store_validation_result<br/>      action:<br/>        class_name: StoreValidationResultAction<br/>    - name: store_evaluation_params<br/>      action:<br/>        class_name: StoreEvaluationParametersAction<br/>    - name: update_data_docs<br/>      action:<br/>        class_name: UpdateDataDocsAction<br/><br/>anonymous_usage_statistics:<br/>  enabled: False</span></pre><p id="4f65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面代码含义的快速总结:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="5d04" class="nd la in mq b be ne nf l ng nh">datasources:<br/>  my_gcs_datasource:<br/>    class_name: Datasource<br/>    module_name: "great_expectations.datasource"<br/>    execution_engine:<br/>        class_name: PandasExecutionEngine<br/>    data_connectors:<br/>        default_runtime_data_connector_name:<br/>            class_name: RuntimeDataConnector<br/>            batch_identifiers:<br/>                - default_identifier_name</span></pre><p id="d602" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这定义了 Great Expectations 可以在哪里找到数据，以及使用什么执行引擎。它提供熊猫和 PySpark。</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="2ac0" class="nd la in mq b be ne nf l ng nh">stores:<br/>    expectations_GCS_store:<br/>        class_name: ExpectationsStore<br/>        store_backend:<br/>            class_name: TupleGCSStoreBackend<br/>            project: ${PROJECT}<br/>            bucket: ${VALIDATION_BUCKET}<br/>            prefix: 'expectations'<br/><br/>    validations_GCS_store:<br/>        class_name: ValidationsStore<br/>        store_backend:<br/>            class_name: TupleGCSStoreBackend<br/>            project: ${PROJECT}<br/>            bucket: ${VALIDATION_BUCKET}<br/>            prefix: 'validations'</span></pre><p id="e6b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这定义了<code class="fe mn mo mp mq b">VALIDATION BUCKET</code>将保存我们定义的期望以及在一个名为<code class="fe mn mo mp mq b">validations</code>的目录中完成的检查的结果</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="87f0" class="nd la in mq b be ne nf l ng nh">data_docs_sites:<br/>  gs_site:<br/>    class_name: SiteBuilder<br/>    store_backend:<br/>      class_name: TupleGCSStoreBackend<br/>      project: ${PROJECT}<br/>      bucket: ${VALIDATION_BUCKET}<br/>      prefix:<br/>    site_index_builder:<br/>      class_name: DefaultSiteIndexBuilder</span></pre><p id="4d86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这定义了关于已经验证的数据的文档存储在哪里。</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="dfe2" class="nd la in mq b be ne nf l ng nh">validation_operators:<br/>  action_list_operator:<br/>    class_name: ActionListValidationOperator<br/>    action_list:<br/>    - name: store_validation_result<br/>      action:<br/>        class_name: StoreValidationResultAction<br/>    - name: store_evaluation_params<br/>      action:<br/>        class_name: StoreEvaluationParametersAction<br/>    - name: update_data_docs<br/>      action:<br/>        class_name: UpdateDataDocsAction</span></pre><p id="67dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，这告诉大期望存储结果，并更新数据文件。</p><p id="70cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mn mo mp mq b">$PROJECT</code>和<code class="fe mn mo mp mq b">$VALIDATION_BUCKET</code>的值可以在终端中配置为环境变量。例如<code class="fe mn mo mp mq b">$VALIDATION_BUCKET= "gs://validation_bucket"</code>其中<strong class="jx io">项目</strong>是 GCP 项目名称，<strong class="jx io"> VALIDATION_BUCKET </strong>是一个存储验证、数据文档以及期望的存储桶。</p><p id="f55e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:确保在值前包含 gs://。</strong></p><p id="15b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，当我们安装了 gcloud 之后，我们将这些配置上传到 GCP，在那里进行测试。</p><p id="eebf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可以使用以下命令来完成:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="1744" class="nd la in mq b be ne nf l ng nh">gsutil -m rsync -r -x 'uncommitted/*|.gitignore|plugins/*' great_expectations $VALIDATION_BUCKET</span></pre><p id="e57e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将编写云函数的代码。每次创建或修改 bucket 中的文件时，都会触发该函数。<br/>首先，我们将创建一个带有子目录<code class="fe mn mo mp mq b">data_validation.</code>的<code class="fe mn mo mp mq b">cloud_functions</code>文件夹，导航到<code class="fe mn mo mp mq b">data_validation</code>文件夹<br/>，在这里，我们将创建 3 个文件和 1 个目录，如下所示:</p><ol class=""><li id="fc38" class="lx ly in jx b jy jz kc kd kg ms kk mt ko mu ks ni mf mg mh bi translated"><code class="fe mn mo mp mq b">requirements.txt</code> -包含云功能所需的库，如下所示:</li></ol><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="15ab" class="nd la in mq b be ne nf l ng nh">google-cloud-storage<br/>great-expectations==0.15.28<br/>fsspec<br/>gcsfs</span></pre><p id="bb08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.env . YAML——它保存了关于项目的私有细节的文件，存储桶和填充如下所示:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="fd2d" class="nd la in mq b be ne nf l ng nh">PROJECT: &lt;PROJECT_NAME&gt;<br/>BUCKET: &lt;BUCKET_NAME&gt;<br/>VALIDATION_BUCKET: &lt;VALIDATION_BUCKET_NAME&gt;</span></pre><p id="ec98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.接下来，我们将用一个空的<code class="fe mn mo mp mq b">__init__.py</code>文件创建一个<code class="fe mn mo mp mq b">src</code>目录，以及一个<code class="fe mn mo mp mq b">gcs.py</code>文件。用以下内容填充<code class="fe mn mo mp mq b">gcs.py</code>文件:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="635c" class="nd la in mq b be ne nf l ng nh">import logging<br/>from typing import Any<br/><br/>import ruamel.yaml as yaml<br/>from google.cloud import storage<br/><br/>logger = logging.getLogger(__name__)<br/>logger.setLevel(logging.DEBUG)<br/>ch = logging.StreamHandler()<br/>ch.setLevel(logging.DEBUG)<br/>formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")<br/>ch.setFormatter(formatter)<br/>logger.addHandler(ch)<br/><br/><br/>def read_yml_from_gcs(<br/>    bucket_name: str,<br/>    blob_name: str,<br/>    template: dict[str, Any],<br/>    client: storage.Client = storage.Client(),<br/>) -&gt; dict[str, Any]:<br/>    bucket: storage.Bucket = client.bucket(bucket_name)<br/>    content: bytes = bucket.blob(blob_name).download_as_string()<br/>    decoded: str = content.decode("utf-8")<br/><br/>    for k, v in template.items():<br/>        decoded = decoded.replace(k, v)<br/><br/>    return yaml.safe_load(decoded)<br/><br/><br/>def move_blob(<br/>    bucket_name: str,<br/>    blob_name: str,<br/>    prefix: str,<br/>    client: storage.Client = storage.Client(),<br/>) -&gt; None:<br/><br/>    bucket = client.bucket(bucket_name)<br/>    blob = bucket.blob(blob_name)<br/><br/>    new_name = "/".join([prefix] + blob_name.split("/")[1:])<br/>    new_blob = bucket.rename_blob(blob, new_name)<br/><br/>    logger.info(f"Blob {blob.name} has been renamed to {new_blob.name}")<br/><br/><br/>def check_trigger_file_path(blob_name: str, trigger_prefix: str) -&gt; bool:<br/>    return blob_name.startswith(trigger_prefix)<br/><br/><br/>def extract_dataset_name(blob_name) -&gt; str:<br/>    return blob_name.split("/")[1]</span></pre><p id="bb1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.最后，导航回父目录<code class="fe mn mo mp mq b">data_validation</code>创建一个<a class="ae kt" href="http://main.py" rel="noopener ugc nofollow" target="_blank"> main.py </a>文件，该文件将用于触发云函数，如下所示:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="e48c" class="nd la in mq b be ne nf l ng nh">import logging<br/>import os<br/>from typing import Any, Dict<br/><br/>from great_expectations.checkpoint import SimpleCheckpoint<br/>from great_expectations.checkpoint.types.checkpoint_result import CheckpointResult<br/>from great_expectations.core.batch import RuntimeBatchRequest<br/>from great_expectations.data_context import BaseDataContext<br/>from great_expectations.data_context.types.base import DataContextConfig<br/>from src.gcs import (<br/>    check_trigger_file_path,<br/>    extract_dataset_name,<br/>    move_blob,<br/>    read_yml_from_gcs,<br/>)<br/><br/>logger = logging.getLogger(__name__)<br/>logger.setLevel(logging.DEBUG)<br/>ch = logging.StreamHandler()<br/>ch.setLevel(logging.DEBUG)<br/>formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")<br/>ch.setFormatter(formatter)<br/>logger.addHandler(ch)<br/><br/>PROJECT = os.environ["PROJECT"]<br/>VALIDATION_BUCKET = os.environ["VALIDATION_BUCKET"]<br/>YAML_TEMPLATE = {"$PROJECT": PROJECT, "$VALIDATION_BUCKET": VALIDATION_BUCKET}<br/><br/><br/>class ValidationError(Exception):<br/>    """Validation Unsuccessful Exception"""<br/><br/><br/>def build_data_context_config(config: dict[str, Any]) -&gt; DataContextConfig:<br/>    return DataContextConfig(**config)<br/><br/><br/>def build_data_context(config: DataContextConfig) -&gt; BaseDataContext:<br/>    return BaseDataContext(config)<br/><br/><br/>def build_batch_request(<br/>    gcs_uri: str, batch_spec_passthrough: dict[str, Any]<br/>) -&gt; RuntimeBatchRequest:<br/><br/>    return RuntimeBatchRequest(<br/>        datasource_name="my_gcs_datasource",<br/>        data_connector_name="default_runtime_data_connector_name",<br/>        data_asset_name=gcs_uri,<br/>        runtime_parameters={"path": gcs_uri},<br/>        batch_identifiers={"default_identifier_name": "default_identifier"},<br/>        batch_spec_passthrough=batch_spec_passthrough,<br/>    )<br/><br/><br/>def build_checkpoint(<br/>    checkpoint_name: str,<br/>    expectation_suite_name: str,<br/>    context: BaseDataContext,<br/>    batch_request: RuntimeBatchRequest,<br/>) -&gt; SimpleCheckpoint:<br/><br/>    file_name = "-".join(batch_request.data_asset_name.split("/")[3:])<br/><br/>    checkpoint_config = {<br/>        "config_version": 1.0,<br/>        "class_name": "Checkpoint",<br/>        "run_name_template": f"%Y%m%d-%H%M%S-{file_name}",<br/>        "validations": [<br/>            {<br/>                "batch_request": batch_request.to_json_dict(),<br/>                "expectation_suite_name": expectation_suite_name,<br/>            },<br/>        ],<br/>    }<br/><br/>    return SimpleCheckpoint(<br/>        name=checkpoint_name, data_context=context, **checkpoint_config<br/>    )<br/><br/><br/>def run_validation(<br/>    dataset_name: str,<br/>    gcs_uri: str,<br/>    project_config: Dict[str, Any],<br/>    batch_spec_passthrough: Dict[str, Any],<br/>) -&gt; CheckpointResult:<br/><br/>    logger.info("Building great expectations configs")<br/><br/>    context_config = build_data_context_config(project_config)<br/>    context = build_data_context(context_config)<br/>    batch_request = build_batch_request(gcs_uri, batch_spec_passthrough)<br/>    checkpoint = build_checkpoint(<br/>        checkpoint_name=dataset_name,<br/>        expectation_suite_name=dataset_name,<br/>        context=context,<br/>        batch_request=batch_request,<br/>    )<br/><br/>    logger.info(f"Starting Validation for {gcs_uri}")<br/>    return checkpoint.run()<br/><br/><br/>def main(data, context): <br/><br/>    if not check_trigger_file_path(data["name"], "landing_zone"):<br/>        return<br/><br/>    dataset_name = extract_dataset_name(data["name"])<br/>    data_uri = f"gs://{data['bucket']}/{data['name']}"<br/>    project_config = read_yml_from_gcs(<br/>        bucket_name=VALIDATION_BUCKET,<br/>        blob_name="great_expectations.yml",<br/>        template=YAML_TEMPLATE,<br/>    )<br/>    batch_spec_passthrough = read_yml_from_gcs(<br/>        bucket_name=VALIDATION_BUCKET,<br/>        blob_name=f"loading_args/{dataset_name}.yml",<br/>        template=YAML_TEMPLATE,<br/>    )<br/><br/>    checkpoint_result = run_validation(<br/>        dataset_name, data_uri, project_config, batch_spec_passthrough<br/>    )<br/><br/>    if checkpoint_result["success"]:<br/>        logger.info("Validation successful")<br/>        move_blob(<br/>            bucket_name=data["bucket"], blob_name=data["name"], prefix="validated"<br/>        )<br/>    else:<br/>        logger.error("Validation unsuccessful")<br/>        raise ValidationError</span></pre><p id="76a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.我们快到了！所以我们会把云功能上传到 Google Cloud。<strong class="jx io">需要云功能管理员权限才能做到这一点。</strong>我们可以创建一个名为<a class="ae kt" href="http://upload.sh" rel="noopener ugc nofollow" target="_blank"> upload.sh </a>的 bash 脚本来实现它，如下所示。我将添加注释来解释每个参数的含义:</p><pre class="kv kw kx ky gt mz mq na bn nb nc bi"><span id="2de3" class="nd la in mq b be ne nf l ng nh">##This tutorial uses v1 cloud functions. <br/>gcloud functions deploy  data_unit_test \<br/>    --source cloud_functions/data_validation \ #local path to the cloud function<br/>    --entry-point main \ #main.py file. Runs on function trigger<br/>    --project $PROJECT \ #The GCP project name<br/>    --region europe-west \ #Region where to deploy the function<br/>    --env-vars-file cloud_functions/data_validation/env.yaml \ <br/>    --runtime python310 \ #python version<br/>    --memory 512MB \ #how much memory the function is allocated<br/>    --trigger-resource $BUCKET \ # bucket that triggers the function<br/>    --trigger-event google.storage.object.finalize #event that causes func to run</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/780dc451529feeabe18444fcff3951ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*-7NOXwRcYYyp2S_R-R2U9A.gif"/></div></figure><p id="cb8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住将您要验证的文件添加到一个标有<code class="fe mn mo mp mq b">landing_zone</code>的目录和一个与您的期望套件同名的子目录中。每次创建文件或修改现有文件时，都会触发该功能。您可以将数据添加到未测试的数据桶中，作为触发该功能的测试。要查看功能的运行状态，请查看云功能的日志。</p><p id="c69c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">validated data 文件夹还包含一个名为<code class="fe mn mo mp mq b">validations</code>的子目录，其中包含给定触发器结果的详细信息，这些信息由 great_expectations 汇总在一个 html 文件或 JSON 文件中，如下所示:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/3339dc02bc525cf5011b19f69995c0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l5_7gk8i4UsD6GIh"/></div></div></figure><p id="bb36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作者:<a class="ae kt" href="https://ug.linkedin.com/in/mutabazi-noble-062994236" rel="noopener ugc nofollow" target="_blank">穆塔巴兹贵族</a></p><blockquote class="nl nm nn"><p id="3702" class="jv jw no jx b jy jz ka kb kc kd ke kf np kh ki kj nq kl km kn nr kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">如果您是需要项目数据的开发人员或学生，我们是您空气质量数据的一站式来源。只需点击这里</em> </strong> <em class="in"> </em> <a class="ae kt" href="https://airqo.net" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="in">即可注册</em> </strong> </a> <strong class="jx io"> <em class="in">。</em>T15】</strong></p></blockquote></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="c19c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="no">最初发布于</em><a class="ae kt" href="https://airqoengineering.hashnode.dev/data-unit-testing-with-great-expectations-and-cloud-functions" rel="noopener ugc nofollow" target="_blank"><em class="no">https://airqoengineering . hashnode . dev</em></a><em class="no">。</em></p></div></div>    
</body>
</html>