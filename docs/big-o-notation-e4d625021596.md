# 大 O 符号的基础解释

> 原文：<https://blog.devgenius.io/big-o-notation-e4d625021596?source=collection_archive---------6----------------------->

带有代码示例的大 O 符号摘要。

![](img/55de5b203434726cb8f1480e63efb8c4.png)

# 什么是大 O？

大 O 符号是计算机科学中常用的数学工具，用于测量计算机算法的运行时间和描述它们的复杂性。它经常被用来确定解决问题的特定方法的效率。更具体地说，随着输入大小的增长，大 O 决定了算法的运行时和空间的“最坏情况”是什么。

# 时间复杂度

我们使用时间复杂度来代替测量算法的实际时间，时间复杂度是确定算法语句运行次数的方法。

# 最常见的时间复杂性

*O()中的 n 代表输入尺寸。*

**O(1)** —常数运行时。这意味着代码立即执行。无论输入大小如何，它都在相同的时间内执行。例如，如果一群程序员都决定说 *Hello World！与此同时，这将花费与只有一个程序员说 hello world 相同的时间。以下代码在常数时间内执行:*

**O(n)** —线性运行时。线性意味着执行 n 次。举例来说，如果你能想象一长串的程序员排队等候面试。说你需要找出他们所有人的名字。你可以去单独询问每个程序员的名字。以下代码以线性时间执行:

**O(n )** —二次时间。二次方意味着运行时的执行次数相对于 n 的平方根增加。这不是一个理想的运行时，因为它只会随着输入大小的增加而增加。代码中的一个示例是嵌套的 for 循环，如下所示:

**O(log n)** —对数时间。这意味着运行时间将随着 n(输入大小)的对数而增加。这个运行时的一个真实例子是在电话簿中搜索一个特定的号码。你把电话簿打开一半，然后如果你没有找到它，重复这个过程，只把需要检查的部分的页数减半，直到你最终找到你要找的号码。这将被认为是[二分搜索法](https://en.wikipedia.org/wiki/Binary_search_algorithm)，这是一种在对数时间内运行的常见算法。*点击* 了解更多关于对数的信息[](https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs)

*二进位检索*

# *去掉常量和非主导项*

*当确定一个大 O 符号运行时，常量应该被删除。例如，如果您有一个特定的运行时表达式 *O(n + 1 + 1 + 1)* ，这将归结为 *O(n)* ，因为大 O 只描述了最坏的情况，包括常数不会产生足够大的差异。此外，非主导项应该从表达式中删除，例如， *O(n + n)* 将变成 *O(n )**

# *空间复杂性*

*在大 O 空间中，复杂度描述了由算法的输入大小 n 决定的算法所使用的内存空间总量。这也可以表示为时间复杂度，例如，大小为 n 的元素的数组可以表示为 *O(n)* 空间。*

# *分析空间复杂性*

*为了确定这段代码的空间复杂度，我们可以列出所用变量的字节大小。
*int = 4 字节，double = 8 字节**

*这个示例代码的空间可以用 4n + 4 + 8 + 4 来度量。因为 n 是主要的，这将向下评估到 O(n)空间。*在这里* 阅读更多关于空间复杂性的[](https://www.baeldung.com/cs/space-complexity)*

## **其他大 O 资源**

*   **[大 O 符号(维基百科)](https://en.wikipedia.org/wiki/Big_O_notation)**
*   **[大 O 为什么重要(FreeCodeCamp)](https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/)**
*   **[理解时间复杂性(极客对极客)](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/)**