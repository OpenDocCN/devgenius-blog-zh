<html>
<head>
<title>RediSearch — A developer’s guide to production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再研究——开发者生产指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redisearch-e6aac3fed2d5?source=collection_archive---------6-----------------------#2022-06-30">https://blog.devgenius.io/redisearch-e6aac3fed2d5?source=collection_archive---------6-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7f94cc3fad06d5d009c3a03512cc5000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpfkS3hEno43C8fBDoYM6Q.png"/></div></div></figure><p id="040b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，你是一名开发人员，你来到这里是为了了解如何在你的生产应用程序中使用 RediSearch。目前，有一些资源可以帮助您熟悉 RediSearch( <a class="ae kt" href="https://redis.io/docs/stack/" rel="noopener ugc nofollow" target="_blank">一个 Redistack 产品</a>)，但是关于如何在生产应用程序中部署和使用它，还没有太多的资源。</p><p id="4af1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章的目的是让你的产品准备好重新搜索功能。本文的目标读者是 python 开发人员。然而，我还将讨论如何首先在生产就绪的 linux 环境中安装 RediSearch &amp; RedisJSON 模块。开始了-</p><h1 id="3208" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是再研究？</h1><p id="c747" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">根据<a class="ae kt" href="https://redis.io/docs/stack/search/#overview" rel="noopener ugc nofollow" target="_blank"><em class="lx">research 官方文件</em> </a> <em class="lx"> - </em></p><blockquote class="ly lz ma"><p id="d222" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">RediSearch 为 Redis 提供了二级索引、全文搜索和一种查询语言。这些功能支持多字段查询、聚合、精确短语匹配和文本查询数字过滤。</p></blockquote><p id="8608" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对开发者来说，这意味着你现在可以在 redis 上运行类似 SQL 的文本搜索等等。</p><h1 id="1e33" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">装置</h1><blockquote class="ly lz ma"><p id="d0e8" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">如果您使用的托管 redis 已经安装了推荐的模块，例如- Redis cloud，那么您可以跳过这一部分。</p></blockquote><p id="b201" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">RediSearch 作为一个模块安装在 redis 部署中。要使用 RediSearch 的一些高级功能，您还需要安装 RedisJSON。基本上有三种方法可以安装和使用它们。</p><ol class=""><li id="0a35" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/search/quick_start/#redis-cloud" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">使用 Redis Cloud </strong> </a> —提供完全免费的托管数据库，容量高达 30MB。已经包括推荐的模块，如 RediSearch、RedisJSON、RedisGraph、RedisTimeSeries 和 RedisBloom。玩一玩，让自己熟悉再搜索功能。</li><li id="6fc8" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/search/quick_start/#running-with-docker" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">与 docker 一起运行</strong> </a> —如果您是 Docker 爱好者，并且想要将您的部署进行 Docker 化。</li><li id="08d9" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/search/quick_start/#building-and-running-from-source" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">建筑再研究从源头</strong></a>——<strong class="jx io">首选生产方式</strong> <strong class="jx io">应用方式</strong>。因为这篇文章关注的是产品化，我们将会继续讨论这个问题。</li></ol><h2 id="c7e2" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">从源代码构建重新搜索模块</h2><p id="0ded" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，克隆 git repo(确保不要省略<code class="fe ne nf ng nh b">--recursive</code>选项，以便正确地克隆子模块)</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5bf7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行以上 4 个命令后，在位置<code class="fe ne nf ng nh b">~/RediSearch/bin/linux-x64-release/search</code>应该有一个名为<code class="fe ne nf ng nh b">redisearch.so</code>的文件</p><blockquote class="ly lz ma"><p id="e6d6" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">将文件<code class="fe ne nf ng nh b">redisearch.so</code>移动到<code class="fe ne nf ng nh b">/etc/redis</code> —这样做是为了防止 redis 服务器重启时出现权限被拒绝的错误</p></blockquote><p id="d695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，你也可以从<a class="ae kt" href="https://redis.com/redis-enterprise-software/download-center/modules/" rel="noopener ugc nofollow" target="_blank">这里</a>下载预编译版本。</p><h2 id="6cd1" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">从源代码构建 RedisJSON 模块</h2><p id="433d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">克隆 repo 并安装一些必需的依赖项到<code class="fe ne nf ng nh b">make</code>项目中。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fbdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行以上 4 个命令后，您应该在位置<code class="fe ne nf ng nh b">~/RedisJSON/bin/linux-x64-release</code>有一个名为<code class="fe ne nf ng nh b">rejson.so</code>的文件</p><blockquote class="ly lz ma"><p id="5941" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">将文件<code class="fe ne nf ng nh b"><em class="in">rejson.so</em></code>移动到<code class="fe ne nf ng nh b"><em class="in">/etc/redis</em></code> —这样做是为了防止 redis 服务器重启期间出现权限被拒绝的错误</p></blockquote><h2 id="0b0b" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">在 redis 中安装 RediSearch 和 RedisJSON 模块</h2><p id="8577" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">一旦准备好了<code class="fe ne nf ng nh b">redisearch.so</code> &amp; <code class="fe ne nf ng nh b">rejson.so</code>文件，就需要将它们加载到 redis 中。您应该已经部署了独立或集群模式的 redis。查看我以前的博客，了解如何创建 redis 集群。</p><p id="a7b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有两种方法可以在 redis 部署中加载模块</p><ol class=""><li id="3680" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><strong class="jx io">在发出<code class="fe ne nf ng nh b">redis-server</code>命令时使用 CLI 选项-</strong><code class="fe ne nf ng nh b"> --loadmodule</code>(<strong class="jx io">不建议生产</strong>)</li></ol><p id="f3c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">使用</strong> <code class="fe ne nf ng nh b"><strong class="jx io">redis.conf</strong></code> <strong class="jx io">文件— </strong>在<code class="fe ne nf ng nh b">/etc/redis/redis.conf</code>中添加以下行(<strong class="jx io">推荐生产</strong>)</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b1ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后使用— <code class="fe ne nf ng nh b">sudo service redis-server restart</code>重新启动服务</p><p id="fffb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如何检查模块是否加载成功？</strong></p><p id="044a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 redis-cli 中运行<code class="fe ne nf ng nh b">module list</code>。这将返回关于加载到服务器中的模块的信息。这是我的机器截图。我们可以看到两个模块都已成功加载。</p><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/01b8dd6e23167599782736fb4f358f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*zGXCbDMbc9fzMtGQWdhArQ.png"/></div></figure><blockquote class="ly lz ma"><p id="5429" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">您现在已经完成了安装。是时候写些代码了。</p></blockquote><h1 id="92b0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">通过客户端库进行编程访问</h1><p id="fe92" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以，有很多 python 库我们可以用来和 redis 交互，其中一些是-</p><ol class=""><li id="54e0" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><code class="fe ne nf ng nh b"><a class="ae kt" href="https://github.com/redis/redis-py" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">redis-py</strong></a></code> —广泛使用。如果您在应用程序中使用 redis，那么您可能已经在使用这个库了。</li><li id="fdc0" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><code class="fe ne nf ng nh b"><a class="ae kt" href="https://github.com/redis/redis-om-python" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">redis-om</strong></a></code> ( <strong class="jx io">推荐</strong> ) —一个更新的库，它提供了高级抽象，使得使用现代 Python 应用程序在 Redis 中建模和查询数据变得容易。<code class="fe ne nf ng nh b">redis-om</code>中的 OM 代表对象建模。</li></ol><blockquote class="ly lz ma"><p id="c88a" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">尽管如此，我推测阅读本文的大多数开发人员一定已经在应用程序中使用了<code class="fe ne nf ng nh b">redis-py</code>，并且您可以继续为现有的工作负载这样做。然而，<code class="fe ne nf ng nh b">redis-om</code>是超级棒的，在尝试使用 RediSearch 来充分发挥它的潜力时应该首选它。<code class="fe ne nf ng nh b">redis-om</code>为您提供更大的灵活性和更简洁的代码。由于对象建模功能<strong class="jx io"> redis-om 被推荐用于生产</strong>，因此我将展示如何在生产应用中使用它。</p></blockquote><h2 id="e91d" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated"><strong class="ak">让我们从</strong>开始吧<code class="fe ne nf ng nh b"><strong class="ak">redis-om</strong></code></h2><p id="2192" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">作为展示 redis-om 功能的一种方式，我开发了一个示例应用程序。参见此处—<a class="ae kt" href="https://github.com/iamvishalkhare/redisearch-product-catalog" rel="noopener ugc nofollow" target="_blank">https://github . com/iamvishalkhare/rede search-product-catalog</a></p><blockquote class="ly lz ma"><p id="eaa5" class="jv jw lx jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">这是一个应用程序，客户/客户可以注册自己获得一个令牌，然后使用该令牌，他们可以摄取他们的产品目录。然后，他们将公开一些搜索 API 来搜索他们的产品目录记录。如果你熟悉的话，它就像是一个非常基础的版本。</p></blockquote><p id="4818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">数据建模</strong></p><p id="1e6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个应用程序处理 2 个实体/模型。<code class="fe ne nf ng nh b">Customer</code>模型，具有以下 JSON 表示:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="de72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<code class="fe ne nf ng nh b">Skus</code>模型，用以下 JSON 表示:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0eb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将让 Redis OM 处理惟一 id 的生成，这是通过使用<a class="ae kt" href="https://github.com/ulid/spec" rel="noopener ugc nofollow" target="_blank"> ULIDs </a>来完成的。Redis OM 还将为我们处理创建惟一的 Redis 键名，以及从存储在 Redis Stack 数据库中的 JSON 文档中保存和检索实体。</p><p id="739a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">要求</strong></p><p id="4f98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要运行此应用程序，您需要:</p><ol class=""><li id="f59b" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><a class="ae kt" href="https://git-scm.com/download" rel="noopener ugc nofollow" target="_blank"> git </a> —将回购克隆到您的机器上。</li><li id="f32d" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python 3.7 以上</a>。</li><li id="346c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">一个<a class="ae kt" href="https://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis 栈</a>数据库，或者安装了 RediSearch 和 RedisJSON 模块的 Redis。您还可以<a class="ae kt" href="https://redis.com/try-free/" rel="noopener ugc nofollow" target="_blank">注册</a>一个免费的 30Mb Redis 企业云数据库——在创建您的云数据库时，一定要检查 Redis 堆栈选项。</li><li id="f43a" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>或<a class="ae kt" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a> —向应用程序发送 HTTP 请求。我们将在本文中提供使用 curl 的例子。</li><li id="3bea" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">可选:<a class="ae kt" href="https://redis.com/redis-enterprise/redis-insight/" rel="noopener ugc nofollow" target="_blank"> RedisInsight </a>，Redis 的免费数据可视化和数据库管理工具。下载 RedisInsight 时，一定要选择 2.x 版或者使用 Redis Stack 自带的版本。</li></ol><p id="acbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">获取源代码</strong></p><p id="63f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从 GitHub 克隆存储库:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6d27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">启动 Redis 堆栈数据库，或者配置您的 Redis 企业云凭据</strong></p><p id="04a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将启动并运行一个 Redis 堆栈数据库。您可以按照本文前面的说明安装 RediSearch 和 redisJSON 模块来设置自己的 Redis 集群，或者如果您使用的是 Redis Enterprise Cloud，您将需要数据库的主机名、端口号和密码。使用这些来设置<code class="fe ne nf ng nh b">REDIS_OM_URL</code>环境变量，如下所示:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9061" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您的 Redis 企业云数据库位于主机<code class="fe ne nf ng nh b">enterprise.redis.com</code>的端口<code class="fe ne nf ng nh b">9139</code>，并且您的密码是<code class="fe ne nf ng nh b">5uper53cret</code>，那么您应该如下设置<code class="fe ne nf ng nh b">REDIS_OM_URL</code>:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8aad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">创建一个 Python 虚拟环境并安装依赖关系</strong></p><p id="e6c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建 Python 虚拟环境，并安装项目依赖项</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9092" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">启动烧瓶应用</strong></p><p id="ada1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以开发模式启动 Flask 应用程序，这样每当您在<code class="fe ne nf ng nh b">app.py</code>中保存代码更改时，Flask 将为您重新启动服务器:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6589" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切顺利，您应该会看到类似如下的输出:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c36d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您现在已经启动并运行了，并且准备好使用 Redis、RediSearch、RedisJSON 和 Redis OM for Python 对数据执行 CRUD 操作了！为了确保服务器正在运行，将您的浏览器指向<code class="fe ne nf ng nh b"><a class="ae kt" href="http://127.0.0.1:5000/`" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a>,</code>，在那里您可以看到应用程序的基本主页:</p><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/e788b002931473996d237e70470fd97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S75WYAQ-xK5wIGL_kz7QPw.png"/></div></div></figure><p id="5d8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">加载样本数据</strong></p><p id="c851" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经提供了少量的样本数据。<br/>客户数据在<code class="fe ne nf ng nh b">data/customer_data</code>中，sku(库存单位)数据在<code class="fe ne nf ng nh b">data/sku_data </code>(该数据是使用<a class="ae kt" href="https://fakejson.com/" rel="noopener ugc nofollow" target="_blank"> Fakejson </a>生成的)<br/>有一个端点可以将该数据加载到 redis 中。像这样使用它-</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c0f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">问题？</strong> <br/>如果你已经设置了<code class="fe ne nf ng nh b">REDIS_OM_URL</code>环境变量，并且在启动时出现如下代码错误:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6bd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后你需要检查你在设置<code class="fe ne nf ng nh b">REDIS_OM_URL</code>时使用了正确的主机名、端口、密码和格式。</p><p id="0e89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果 dataloader 端点无法将样本数据发送到应用程序中，请确保 Flask 应用程序在**运行 data loader 之前* *运行。</p><h2 id="b7ea" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">理解和操作数据</h2><p id="1bba" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们在 Redis 中创建和操作一些数据模型的实例。这里我们将看看如何用 curl 调用 Flask API(您也可以使用 Postman)，代码如何工作，以及数据如何存储在 Redis 中。</p><p id="339e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">利用 Redis OM 建立客户&amp;SKU 模型</strong></p><p id="fa88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redis OM 允许我们使用 Python 类对实体建模。我们的客户模型包含在文件<code class="fe ne nf ng nh b">models/customer.py</code>中。以下是关于它如何工作的一些注意事项:</p><ul class=""><li id="8a4f" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">我们声明一个类<code class="fe ne nf ng nh b">Customer</code>，它扩展了一个 Redis OM 类<code class="fe ne nf ng nh b">JsonModel</code>。这告诉 Redis OM 我们希望将这些实体作为 JSON 文档存储在 Redis 中。</li><li id="e9b8" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks nq mk ml mm bi translated">然后，我们在模型中声明每个字段，指定数据类型以及是否要对该字段进行索引。下面是<code class="fe ne nf ng nh b">Customer</code>类的样子。<code class="fe ne nf ng nh b">Optional</code>关键字告诉 Redis 这个字段可以在部分或全部记录中不存在。</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6551" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的 SKU 模型包含在文件<code class="fe ne nf ng nh b">models/Skus.py</code>中。以下是关于它如何工作的一些注意事项:</p><ul class=""><li id="5e54" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">我们声明了一个类<code class="fe ne nf ng nh b">Skus</code>，它也有一个名为<code class="fe ne nf ng nh b">price</code>的嵌套对象</li><li id="0b47" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks nq mk ml mm bi translated"><code class="fe ne nf ng nh b">Price</code>与其他字段的工作方式不同。注意，在模型的 JSON 表示中，价格是一个对象，而不是字符串或数字字段。在 Redis OM 中，这被建模为另一个类，它扩展了 Redis OM <code class="fe ne nf ng nh b">EmbeddedJsonModel</code>类。</li><li id="4fb8" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks nq mk ml mm bi translated"><code class="fe ne nf ng nh b">EmbeddedJsonModel</code>只能在扩展了<code class="fe ne nf ng nh b">JsonModel</code>的类中使用。假设类 SKU 扩展了<code class="fe ne nf ng nh b">HashModel</code>而不是<code class="fe ne nf ng nh b">JsonModel</code>，那么你就不能使用<code class="fe ne nf ng nh b">EmbeddedJsonModel</code>了。</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="fec5" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">我们也可以像存储<code class="fe ne nf ng nh b">tags</code>字段一样存储<code class="fe ne nf ng nh b">lists</code>的值</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="12dc" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">对于<code class="fe ne nf ng nh b">title</code>和<code class="fe ne nf ng nh b">description</code>字段，我们不想索引字段的值，因为它是一个自由文本句子，而不是一个单词或数字。为此，我们将告诉 Redis OM，我们希望能够对值执行全文搜索:</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="188e" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">我们为每个 SKU 记录存储一个字段<code class="fe ne nf ng nh b">token</code>。此令牌唯一标识 SKU 记录所属的客户。</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="e43e" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated">我们还可以为字段设置默认值。假设<code class="fe ne nf ng nh b">title</code>应为“测试 SKU ”,除非另有说明:</li></ul><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5fc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">增加新客户</strong></p><p id="8107" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ne nf ng nh b">managers/customer_manager.py</code>中的函数<code class="fe ne nf ng nh b">register_customer</code>处理 Redis 中新客户的创建。它需要一个符合客户模型模式的 JSON 对象。然后用该数据创建一个新的 Customer 对象并保存在 Redis 中的代码很简单:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e683" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个功能也确保没有两个客户有相同的电子邮件 ID。</p><p id="cb97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当创建一个新的客户实例时，Redis OM 为它分配一个惟一的 ULID 主键，我们可以用<code class="fe ne nf ng nh b">.pk</code>来访问它。我们将其返回给调用者，以便他们知道他们刚刚创建的对象的 ID。</p><p id="2498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将对象持久化到 Redis 只是简单地对其调用<code class="fe ne nf ng nh b">.save()</code>。</p><p id="05ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试一下…在服务器运行的情况下，使用 curl 添加一个新客户:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="58ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行上面的 curl 命令将返回分配给新创建的客户的唯一 ULID ID。比如说-</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2d3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将使用此令牌上传该客户的 sku 数据。</p><p id="5e21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">添加 SKU 数据</strong></p><p id="86c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用令牌上传 sku 数据。类似这样的-</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9289" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">检查 Redis 中的数据</strong></p><p id="0d8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看我们刚刚在 Redis 中保存了什么。使用 RedisInsight 或 redis-cli，连接到数据库并查看存储在键<code class="fe ne nf ng nh b">:models.skus.Skus:01G6GPP23TAFG5FJJ8TXG3E64R</code>中的值。这在 Redis 中存储为 JSON 文档，因此如果使用 redis-cli，您将需要以下命令:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1702" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在使用 RedisInsight，当您单击密钥名称时，浏览器将为您呈现密钥值:</p><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/a324dc10d41c3be9d0821c270705720d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBO3IR6XZoebGUo80l5uoQ.png"/></div></div></figure><p id="d1ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当在 Redis 中将数据存储为 JSON 时，我们可以更新和检索整个文档，或者只是部分文档。例如，要仅检索 sku 的标题和第一个标签，请使用以下命令(RedisInsight 用户应该使用内置的 redis-cli 来执行此操作):</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6964" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有关用于在 Redis 中查询 JSON 文档的 JSON 路径语法的更多信息，请参见<a class="ae kt" href="https://oss.redis.com/redisjson/path/" rel="noopener ugc nofollow" target="_blank"> RedisJSON 文档</a>。</p><h2 id="ed41" class="ms kv in bd kw mt mu dn la mv mw dp le kg mx my li kk mz na lm ko nb nc lq nd bi translated">探索更多 API 和 redis-om 特性</h2><p id="cdeb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><strong class="jx io">获取客户详细信息</strong> <br/>客户可以通过将他们的唯一令牌作为路径变量来查看他们的详细信息。类似这样的-</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fbc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面这段代码搜索给定令牌的<code class="fe ne nf ng nh b">all</code>客户</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">通过</strong> <code class="fe ne nf ng nh b"><strong class="jx io">sku_id</strong></code> <br/>获取 sku 的详细信息给定作为路径变量传递的唯一的<code class="fe ne nf ng nh b">token</code>和<code class="fe ne nf ng nh b">sku_id</code>，客户可以请求先前获取的 SKU 记录</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a3dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意我们如何<code class="fe ne nf ng nh b">and</code>客户提供的条件<code class="fe ne nf ng nh b">token</code>必须与记录中的内容相匹配。这将确保一定程度的安全性，因为顾客只能查看属于他们的那些 SKU 的详细信息。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="218d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">更新 SKU 的折扣价</strong> <br/>客户可以选择更新<code class="fe ne nf ng nh b">discounted_price</code>字段。<br/>这是一个补丁端点，请求有效负载应该包含唯一的客户端<code class="fe ne nf ng nh b">token</code>、<code class="fe ne nf ng nh b">sku_id</code>，其<code class="fe ne nf ng nh b">discounted_price</code>必须被更新，以及折扣价格的新值</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bc56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我们如何首先获得记录的<code class="fe ne nf ng nh b">pk</code>(主键)，然后设置新值。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="762a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对<code class="fe ne nf ng nh b">title</code>和<code class="fe ne nf ng nh b">description</code>字段<br/>进行全文搜索由于<code class="fe ne nf ng nh b">title</code>和<code class="fe ne nf ng nh b">description</code>字段<code class="fe ne nf ng nh b">full_text_search=True</code>已设置，我们可以对这些字段进行全文搜索。<br/>端点将接受令牌作为路径变量，搜索词作为查询参数。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6850" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意我们如何使用<code class="fe ne nf ng nh b">OR</code>条件在两个不同的字段中进行搜索，即在<code class="fe ne nf ng nh b">title</code>和<code class="fe ne nf ng nh b">description</code>中。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6b46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">范围搜索—搜索</strong> <code class="fe ne nf ng nh b"><strong class="jx io">discounted_price</strong></code> <strong class="jx io">值在范围</strong> <br/>内的记录客户可以搜索<code class="fe ne nf ng nh b">discounted_price</code>在范围内的 sku 记录。<br/>端点接受<code class="fe ne nf ng nh b">token</code>作为路径变量，接受<code class="fe ne nf ng nh b">discounted_price</code>的<code class="fe ne nf ng nh b">min</code>和<code class="fe ne nf ng nh b">max</code>值作为查询参数。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用标准和<code class="fe ne nf ng nh b">&amp;</code>操作来执行这个动作。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5dc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">稍微复杂的范围查询</strong> <br/>返回评级大于 min_rating 或者<code class="fe ne nf ng nh b">discounted_price</code>大于 max_price 的记录。</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2fa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用 OR <code class="fe ne nf ng nh b">|</code>结合 AND <code class="fe ne nf ng nh b">&amp;</code>操作来执行这个动作。<br/>我们还可以根据字段对响应进行排序。(<code class="fe ne nf ng nh b">ratings</code>本例中)</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c02f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">搜索记录中的列表</strong> <br/>返回其标签字段包含作为查询参数传递的任何标签的所有记录</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1b87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以传递一个标签列表，下面这段代码将返回所有在<code class="fe ne nf ng nh b">tag</code>列表中有这些值的记录</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b10d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<code class="fe ne nf ng nh b">&lt;&lt;</code>符用来表示<code class="fe ne nf ng nh b">in</code>或<code class="fe ne nf ng nh b">contains</code>。</p><p id="ed21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使记录到期</strong> <br/>使记录到期，给定其<code class="fe ne nf ng nh b">sku_id</code>的 ttl 秒<br/>该端点接受<code class="fe ne nf ng nh b">sku_id</code>到期和<code class="fe ne nf ng nh b">ttl_in_sec</code>(记录到期后的时间)</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8569" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe ne nf ng nh b">.expire()</code>函数来终止记录</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1094" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe ne nf ng nh b">redis</code> -cli，您可以使用 Redis <code class="fe ne nf ng nh b">expire</code>命令检查 sku 现在是否设置了 TTL:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3e93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这表明 Redis 将在 102 秒后使密钥过期。</p><p id="0ab4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当您想要运行较低级别的 redis 命令时，您可以在您的模型类上使用<code class="fe ne nf ng nh b">.db()</code>函数来获得底层的 redis-py 连接。更多详情，参见<a class="ae kt" href="https://redis-py.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">再发行文档</a>。</p><h1 id="17e8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="c31c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">redis-om 提供了对 redis 上现有 JSON 数据结构的全文搜索能力。我个人开发了一些基于搜索的应用程序，使用 Elasticsearch 来提高搜索能力。再搜索可以作为一个更快的缓存层介于两者之间。毕竟 redis 的表现比 Elasticsearch 更好更快。参见<a class="ae kt" href="https://redis.com/blog/search-benchmarking-redisearch-vs-elasticsearch/" rel="noopener ugc nofollow" target="_blank">基准测试:再研究与弹性研究</a></p><p id="a395" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，在我的下一篇文章中，我将会谈到<code class="fe ne nf ng nh b">redis-om</code>的一些更好的特性，以及如何充分发挥再搜索的潜力。我将讨论诸如分页之类的主题，这在构建生产应用程序时是必不可少的。</p><h1 id="d900" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考</h1><ol class=""><li id="c451" class="me mf in jx b jy ls kc lt kg ns kk nt ko nu ks mj mk ml mm bi translated"><a class="ae kt" href="https://github.com/redis-developer/redis-om-python-flask-skeleton-app" rel="noopener ugc nofollow" target="_blank">https://github . com/redis-developer/redis-om-python-flask-skeleton-App</a>—我的应用建立在这个骨架应用之上</li><li id="6af4" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/search/" rel="noopener ugc nofollow" target="_blank">https://redis.io/docs/stack/search/</a>—再研究</li><li id="dc67" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/json/" rel="noopener ugc nofollow" target="_blank">https://redis.io/docs/stack/json/</a>—雷迪森</li><li id="e406" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.io/docs/stack/get-started/tutorials/stack-python/" rel="noopener ugc nofollow" target="_blank">https://Redis . io/docs/stack/get-started/tutorials/stack-python/</a>—Redis OM python</li><li id="5757" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://redis.com/blog/search-benchmarking-redisearch-vs-elasticsearch/" rel="noopener ugc nofollow" target="_blank">https://redis . com/blog/Search-Benchmarking-rede Search-vs-elastic Search/</a>—搜索基准:RediSearch vs. Elasticsearch</li><li id="d513" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><a class="ae kt" href="https://fakejson.com/" rel="noopener ugc nofollow" target="_blank">https://fakejson.com/</a>—用于生成 SKU 数据的 FakeJSON。</li></ol><p id="dc76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">这篇文章是与 Redis 合作的。</em></p></div></div>    
</body>
</html>