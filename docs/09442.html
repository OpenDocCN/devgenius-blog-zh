<html>
<head>
<title>Coercion in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的强制</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/coercion-in-javascript-47ba133d7ce9?source=collection_archive---------3-----------------------#2022-08-21">https://blog.devgenius.io/coercion-in-javascript-47ba133d7ce9?source=collection_archive---------3-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ed869fa03e32102a9f12445e484d53e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFBvdntofJ-oHZEq2UCUyA.png"/></div></div></figure><p id="47c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">强制是 Javascript 中最重要的概念之一。作为一名 Javascript 开发人员，这是你必须知道和学会的事情之一。因为说实话。如果你不熟悉强制，它会破坏你的程序。你可能会得到不可预知的结果。那么，到底什么是强制？将变量从一种类型更改为另一种类型称为强制。这就是我们在其他编程语言中所说的类型转换。强制和类型转换这两个词意思相同，可以互换使用。</p><p id="c453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当谈到在 Javascript 中改变变量类型时，也就是执行强制。有两种类型。这些是:</p><ul class=""><li id="24ed" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">隐性强制</li><li id="f83d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">显性胁迫</li></ul><h1 id="4d1c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">隐性强制</h1><p id="232b" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated"><strong class="jx io">含蓄胁迫</strong>并非有意。这种强制是由 Javascript 本身完成的。一些例子是:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="09d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这些例子中，我们正在执行数学运算。当 Javascript 遇到一个不是 number 类型的操作数时，它不是给出错误或警告，而是自己把它转换成一个数字。</p><h1 id="3939" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">显性胁迫</h1><p id="7be8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">另一方面，显式强制是我们开发人员有意为之的。这种类型的强制在代码中很明显。让我们把隐式强制的例子变成显式强制。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4bb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，任何看到这段代码的人都会明白，类型强制是用来执行数学运算的。如代码所示，这是显而易见的。我们利用 Javascript 中的<code class="fe mq mr ms mt b">Number()</code>工具将操作数显式转换为数字。为了显式转换成字符串或布尔值，我们在 Javascript 中使用了<code class="fe mq mr ms mt b">String()</code>和<code class="fe mq mr ms mt b">Boolean()</code>工具。</p><h1 id="5899" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">抽象操作</h1><p id="b1a8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">根据 ECMAScript 规范，抽象操作不是语言规范的一部分，但它们负责在 Javascript 中执行强制。这些只是决定强制的最终输出的算法。在这篇文章中，我将交替使用<code class="fe mq mr ms mt b">abstract operation</code>和<code class="fe mq mr ms mt b">algorithm</code>这两个词。Javascript 中有许多不同的抽象操作。但在本帖中，我们将讨论这四个抽象操作:</p><ul class=""><li id="39c6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">原始的</li><li id="dc49" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">ToString</li><li id="2a6e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">ToNumber</li><li id="bd9b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">托布勒安</li></ul><p id="d68f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论是隐式强制还是显式强制，这些操作都是在幕后起作用，决定最终的输出。</p><h2 id="9123" class="mu li in bd lj mv mw dn ln mx my dp lr kg mz na lv kk nb nc lz ko nd ne md nf bi translated">1-top 本原</h2><p id="74fa" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">当我们有一个<strong class="jx io">非原语</strong>值，比如一个对象、数组或函数，并且我们需要<strong class="jx io">将其转换成一个原语值</strong>时，就会涉及到<strong class="jx io">原语抽象操作</strong>。那么，这个算法是如何工作的呢？这个算法需要一个提示。这个提示就是我们要转换成的原语类型。例如，如果我有一个数组，我希望它是一个字符串。在这种情况下，我可以提供一个<code class="fe mq mr ms mt b">string</code>作为对 ToPrimitive 算法的提示。</p><p id="74ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，如果我们用非原语执行一些<code class="fe mq mr ms mt b">numeric operation</code>，比如减去两个数组或对象，发送给这个算法的提示是一个<code class="fe mq mr ms mt b">number</code>。toPrimitive 算法会在执行数值运算之前先将非基元转换成数字。</p><p id="bcb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于本原算法的另一件事是它只能接受两种类型的提示。该提示可以是类型<code class="fe mq mr ms mt b">string</code>或<code class="fe mq mr ms mt b">number</code>。这个提示是可选的。如果没有提供提示，则使用<code class="fe mq mr ms mt b">default</code>提示调用 toPrimitive。</p><p id="1c1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有非基本对象、数组和函数都定义了这些方法:</p><ul class=""><li id="a8c9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">的值()</li><li id="e1af" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">toString()</li></ul><p id="7f50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我试图用提示<strong class="jx io">号</strong>将一个<strong class="jx io">非原语</strong>转换成一个<strong class="jx io">原语</strong>。<br/>top primitive 算法将调用非原语类型的<code class="fe mq mr ms mt b">valueOf()</code>方法。如果输出是原始的。我们完了。而如果输出不是原语，那么就调用非原语类型的<code class="fe mq mr ms mt b">toString()</code>方法。</p><p id="d871" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，如果提示是一个<strong class="jx io">字符串</strong>。在这种情况下，首先调用<code class="fe mq mr ms mt b">toString()</code>，如果它没有返回原语，则调用<code class="fe mq mr ms mt b">valueOf()</code>方法。</p><p id="b135" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里需要注意的是，如果<code class="fe mq mr ms mt b">toString()</code>和<code class="fe mq mr ms mt b">valueOf()</code>都没有返回原语，那么就会产生一个错误。下面是一个流程图来总结本原算法:</p><figure class="mk ml mm mn gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0c765662c427c706894dca1b74af3916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*D5ZB1u0dGWUULdqdNBrMdw.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">图片来源:来自 dev.to 的 Amandeep Singh</figcaption></figure><h2 id="8a42" class="mu li in bd lj mv mw dn ln mx my dp lr kg mz na lv kk nb nc lz ko nd ne md nf bi translated">双 ToString</h2><p id="3a60" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">当任何<strong class="jx io">非字符串值</strong>被强制转换为<strong class="jx io">字符串表示</strong>时，转换由<strong class="jx io"> ToString 抽象操作处理。</strong>让我们看看将不同的<strong class="jx io">原语类型</strong>转换为<strong class="jx io">字符串</strong>的结果:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2996" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，如果我们想将<strong class="jx io">非原语，即数组或对象</strong>转换为<strong class="jx io">字符串</strong>。<em class="nl">在这种情况下，toString 操作用提示字符串</em>调用 toPrimitive 算法。这将调用为非原始类型定义的默认<strong class="jx io"> toString() </strong>方法。</p><p id="11b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当将数组转换为类型字符串时，数组的默认<strong class="jx io"> toString() </strong>方法会给出以下强制结果:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7dea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于对象，<strong class="jx io"> toString() </strong>方法的输出如下:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8a9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于对象，无论是否为空，将其转换为字符串的输出都是<code class="fe mq mr ms mt b">[object Object]</code></p><p id="0bad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，我们可以通过覆盖对象的默认<strong class="jx io"> toString() </strong>方法来改变这种行为。因此，<strong class="jx io"> toString() </strong>的输出将是我们从这个方法返回的任何值。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="a35c" class="mu li in bd lj mv mw dn ln mx my dp lr kg mz na lv kk nb nc lz ko nd ne md nf bi translated">三位数</h2><p id="4c3d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">如果任何<strong class="jx io">非数字</strong>值的使用方式要求它是一个<strong class="jx io">数字</strong>，例如一个数学运算，这种情况下的转换由<strong class="jx io">到数字抽象运算</strong>处理。</p><p id="ad03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将不同的<strong class="jx io">原始值</strong>转换为<strong class="jx io">数字</strong>的结果如下:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="eeed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nl">另一方面，当将</em> <strong class="jx io"> <em class="nl">非原语</em> </strong> <em class="nl">值转换为</em> <strong class="jx io"> <em class="nl">数字</em> </strong> <em class="nl">时，toNumber 抽象操作调用带有数字提示的 toPrimitive 算法。<br/> </em>结果，非原语的默认<strong class="jx io"> valueOf() </strong>方法被调用。数组和对象的默认<strong class="jx io"> valueOf() </strong>方法如下所示:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4092" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于数组和对象的<strong class="jx io"> valueOf() </strong>方法最终返回自身，如<code class="fe mq mr ms mt b">return this</code>所示。这导致忽略 valueOf()方法并遵从默认的<strong class="jx io"> toString() </strong>方法。</p><p id="24c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，将非原语转换为数字会导致首先将它们转换为<strong class="jx io">字符串</strong>。这将使非本原成为本原即<code class="fe mq mr ms mt b">string</code>。然后这个原语<code class="fe mq mr ms mt b">string</code>被进一步强制为一个<code class="fe mq mr ms mt b">number</code>。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d6d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对象也是如此:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a1e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将对象转换为字符串会返回<code class="fe mq mr ms mt b">[object Object]</code>字符串作为输出。现在，当我们将这个字符串转换成一个数字时，输出将是一个<code class="fe mq mr ms mt b">NaN</code>值。</p><p id="ee9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要改变这种行为，我们可以覆盖对象的默认值 Of()方法。这将导致最终输出是我们从 valueOf()方法返回的任何内容。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="6a8c" class="mu li in bd lj mv mw dn ln mx my dp lr kg mz na lv kk nb nc lz ko nd ne md nf bi translated">4-ToBoolean</h2><p id="c93d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">toBoolean 抽象操作负责任何与布尔相关的转换。这种抽象操作不太像算法，更像查找。<br/>对于一组值，布尔转换将始终返回 false 作为输出。我们称这些价值观为虚假价值观。这个简短而有限的错误值列表是:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b645" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，每当我们执行布尔类型转换时，toBoolean 抽象操作只是在上面的 falsy 值列表中查找。如果要强制的值在列表中，则返回<code class="fe mq mr ms mt b">false</code>作为输出。另一方面，如果值不在 falsy 列表中，我们将返回<code class="fe mq mr ms mt b">true</code>。</p><p id="a1b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章对你有所帮助。感谢阅读。:)</p><p id="87ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面连线:<br/><a class="ae nm" href="https://www.linkedin.com/in/rabi-siddique-b6b4971a0/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae nm" href="https://twitter.com/rabisiddique234" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>