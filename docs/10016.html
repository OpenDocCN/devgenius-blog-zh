<html>
<head>
<title>Generic custom hook “useForm” with “Yup” validation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中带有“是”验证的通用自定义挂钩“useForm”</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/type-safe-useform-hook-with-yup-validation-in-react-27e74c936cbe?source=collection_archive---------1-----------------------#2022-09-30">https://blog.devgenius.io/type-safe-useform-hook-with-yup-validation-in-react-27e74c936cbe?source=collection_archive---------1-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="236b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时，我们正在做一个项目，其中只有很少的表单，我们不想使用任何第三方库来处理这些简单用例的表单。但是，如果我们不使用任何库，那么我们将不得不分别手动处理每个表单，这也不是一个好方法。</p><p id="a926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，我们该怎么办呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d523d837455bf9636fdb3edcc2ba7137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ead53Qs5kWokCPIa"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ws_coda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> W.S. Coda </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="81bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你猜对了。👍创建一个通用的定制钩子，并用它来处理每个表单。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="bebe" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated"><strong class="ak">先决条件:</strong></h2><p id="b311" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这将是一个类型安全的钩子。所以你要对<em class="me"> TypeScript </em>有适当的了解。</p><p id="d1f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是本文中使用的<em class="me"> TypeScript </em>特性的链接。如果你还不知道这些，我强烈建议你先学习一下，然后再进一步。</p><ol class=""><li id="3b25" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">仿制药</a></li><li id="8f55" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">公用事业类型</a></li><li id="2253" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">使用类型谓词的类型收缩</a></li><li id="a092" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">键入操作符的键</a></li></ol><h1 id="6920" class="mt lh in bd li mu mv mw ll mx my mz lo na nb nc lr nd ne nf lu ng nh ni lx nj bi translated"><strong class="ak">实施:</strong></h1><p id="6aa6" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">在开始之前，看看我们钩子的最终接口，以了解我们将要实现什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用表单挂钩 API</figcaption></figure><h2 id="1fde" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated"><strong class="ak">状态管理:</strong></h2><p id="6470" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">让我们从定义状态开始。我们将在这个钩子中管理四个不同的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">挂钩状态代码段</figcaption></figure><p id="2a41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，前三个状态是不言自明的，关于第四个状态，我们管理它是为了检测一个字段是否被触摸，因为我们将只在被触摸的字段上显示错误。它将在<code class="fe nm nn no np b">onBlur</code>事件中使用，每当模糊事件在任何字段上触发，则<code class="fe nm nn no np b">true</code>将针对该字段设置为状态。</p><h2 id="44c6" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated"><strong class="ak">验证:</strong></h2><p id="2bf3" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">正如标题中提到的，我们将使用一个非常流行的名为<strong class="jm io">“Yup”</strong>的库来验证用户输入。</p><p id="2c43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">验证对象类型:<br/> </strong>你可以在上面看到，我们接受<code class="fe nm nn no np b">validationSchema</code>作为钩子的第三个参数。我们需要这个模式是类型安全的，也就是说，所有的表单字段都应该在模式对象中定义，它不应该接受任何不属于表单的字段。让我们为它定义类型。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="da15" class="lg lh in np b gy nu nv l nw nx"><em class="me">import</em> { AnySchema} <em class="me">from</em> "yup";</span><span id="f67e" class="lg lh in np b gy ny nv l nw nx">export <em class="me">type</em> YupSchemaObject&lt;T&gt; = Record&lt;keyof T, AnySchema&gt;;</span></pre><p id="2114" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，“T”是一个通用值，它的类型将取决于消费者传递的<code class="fe nm nn no np b">initialValues</code>。<code class="fe nm nn no np b">AnySchema</code>是验证对象的类型，从<code class="fe nm nn no np b">yup</code>导入。通过使用类型<code class="fe nm nn no np b">YupSchemaObject</code>,我们的模式将只接受在<code class="fe nm nn no np b">initialValues</code>对象中定义的所有键，并且该模式中的所有值将根据<code class="fe nm nn no np b">AnySchema</code>类型。例如:</p><p id="92b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们的初始值是这些:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="c159" class="lg lh in np b gy nu nv l nw nx">const initialValues = {<br/>  name: '',<br/>  email: ''<br/>}</span></pre><p id="c79b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们的<code class="fe nm nn no np b">validationSchema</code>中必须有<code class="fe nm nn no np b">name</code>和<code class="fe nm nn no np b">email</code>作为键，并且它不应该包含任何其他键。为了更好地理解，请参见下面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">验证模式示例</figcaption></figure><p id="0f9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">验证功能:<br/> </strong>希望你已经了解了验证对象的类型。现在，是时候创建验证函数了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">验证功能代码片段</figcaption></figure><p id="2e80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为，<code class="fe nm nn no np b">validationSchema</code>是一个可选参数，我们首先检查它是否存在，然后将它传入从<code class="fe nm nn no np b">yup</code>库导入的<code class="fe nm nn no np b">yupObject</code>。接下来，我们只是传递<code class="fe nm nn no np b">schema.validate</code>函数中的<code class="fe nm nn no np b">values</code>和<code class="fe nm nn no np b">options</code>。请注意，<code class="fe nm nn no np b">{ abortEarly: false }</code>在这里很重要，因为它的默认值是<code class="fe nm nn no np b">true</code>,如果为真，它将只返回第一个错误字段，但我们需要它返回所有错误字段。</p><p id="96fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">验证错误序列化器:<br/> </strong>我还想在本节中添加一个实用函数，因为它是验证的一部分，但将在本教程的<strong class="jm io">模糊</strong>和<strong class="jm io">提交</strong>处理程序中使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="dae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数接受两个参数，第一个是由<code class="fe nm nn no np b">yup</code>返回的<code class="fe nm nn no np b">err</code>对象，第二个是可选的<code class="fe nm nn no np b">touchedFields</code>。为了理解这个函数的实现，我们需要知道 yup 的错误对象的形状。这就是了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c25c9a365d8ae7a4f1ed562c1a2f11b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*df7cBzuj34t7gNbM8jlTRw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">截图取自“是”文档</figcaption></figure><p id="0097" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些属性都是<code class="fe nm nn no np b">ValidationError</code>类型的一部分。由于我们已经将<code class="fe nm nn no np b">abortEarly</code>选项设置为<code class="fe nm nn no np b">false</code>，我们将获得作为<code class="fe nm nn no np b">ValidationError</code>数组的<code class="fe nm nn no np b">inner</code>属性，这意味着<code class="fe nm nn no np b">inner</code>数组的每个元素都将有一个<code class="fe nm nn no np b">ValidationError</code>类型的对象，并包含上述所有属性。</p><p id="1e48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道了错误对象的形状，让我们开始理解我们的序列化器的实现。</p><p id="c2bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要转换<code class="fe nm nn no np b">inner</code>属性，它是一个对象数组，转换成简单的线性对象，key 为<code class="fe nm nn no np b">Keyof Values</code>，value 为<code class="fe nm nn no np b">string</code>。在 yup error 对象中，<code class="fe nm nn no np b">path</code>属性将具有发生错误的字段的名称，<code class="fe nm nn no np b">message</code>属性将具有<code class="fe nm nn no np b">string</code>中的错误文本。我们只需要将<code class="fe nm nn no np b">path</code>属性设置为错误对象的键，将<code class="fe nm nn no np b">message</code>属性设置为值。在将每个字段的错误值设置到我们的状态对象之前，我们还需要检查可选的<code class="fe nm nn no np b">touchedFields</code>参数。如果存在，那么我们需要检查每个字段的触摸状态，如果字段的触摸状态被设置为<code class="fe nm nn no np b">true</code>，那么我们将设置该字段的错误状态，否则我们将忽略该特定字段的错误。</p><h2 id="3b1b" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">事件处理程序:</h2><p id="c9eb" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">事件处理程序是表单最重要的部分。我们在表单中经常用到的三个常用处理程序是<em class="me">修改</em>、<em class="me">模糊</em>和<em class="me">提交处理程序</em>。</p><p id="ef76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">更改处理程序:<br/> </strong>因为我们正在制作一个可以用于不同类型输入的通用钩子，所以我们需要确保我们的更改处理程序可以处理每一种输入类型。为此，我们应该创建一个基于输入类型处理值的效用函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在这个函数中传递<code class="fe nm nn no np b">event.currentTarget</code>对象，它将根据输入类型返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更改处理程序代码段</figcaption></figure><p id="98b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个处理程序可以在<em class="me">输入</em>、<em class="me">文本区域</em>和<em class="me">选择</em>字段中传递，因此我们创建了一个名为<code class="fe nm nn no np b">InputTypes</code>的类型，并使其成为三者的联合。但是这个联合类型产生了一个问题，我们不能访问<code class="fe nm nn no np b">event.currentTarget</code>的<code class="fe nm nn no np b">files</code>和<code class="fe nm nn no np b">checked</code>属性，因为这些属性在<code class="fe nm nn no np b">textarea</code>和<code class="fe nm nn no np b">select</code>字段中不存在，并且三个的联合使得它对于 TypeScript 不可用。为了解决这个问题，我们将类型<code class="fe nm nn no np b">currentTarget</code>转换为<code class="fe nm nn no np b">EventTarget &amp; HTMLInputElement</code>,因为我们确信如果类型是“文件”或“复选框”,那么它将是<strong class="jm io">输入</strong>字段，而不是<strong class="jm io">文本区域</strong>或<strong class="jm io">选择</strong>字段。最后，我们通过使用之前创建的用于处理不同输入类型的实用函数来设置状态中的输入值。</p><p id="c0d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">模糊处理程序:<br/> </strong>这个处理程序会有两个职责。一个是设置触摸状态(当字段第一次失去焦点时),另一个是调用验证函数(在验证部分定义),并在发生任何错误时设置字段的错误状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">模糊处理程序代码片段</figcaption></figure><p id="c165" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们检查字段的值在我们的<code class="fe nm nn no np b">touched</code>状态对象中是否已经为真，如果不是，那么我们将它设置为<code class="fe nm nn no np b">true</code>，然后我们调用<code class="fe nm nn no np b">validate</code>函数。因为它是一个<code class="fe nm nn no np b">async</code>函数并返回<code class="fe nm nn no np b">Promise</code>，所以我们通过<code class="fe nm nn no np b">then/catch</code>块来处理它。如果它拒绝，那么我们通过我们的<code class="fe nm nn no np b">serializeYupError</code>函数序列化<code class="fe nm nn no np b">yup</code>错误，并在我们的状态中设置错误，否则我们在错误状态中设置空对象。</p><p id="feb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提交处理程序:<br/> </strong>它的职责是验证表单的所有值，然后调用<code class="fe nm nn no np b">submitHandler</code>函数(钩子的第二个参数)，用<code class="fe nm nn no np b">values</code>作为它的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">提交处理程序代码片段</figcaption></figure><p id="ea9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe nm nn no np b">try</code>块中，我们调用<code class="fe nm nn no np b">validate</code>函数和<code class="fe nm nn no np b">awaited</code>，因为它是一个异步函数。如果我们所有的验证都通过了，并且这个函数没有抛出错误，那么我们的<code class="fe nm nn no np b">isSubmitting</code>状态将是<code class="fe nm nn no np b">true</code>，并且<code class="fe nm nn no np b">submitHandler</code>函数将被调用。<br/>这个<code class="fe nm nn no np b">submitHandler</code>的实现完全取决于这个钩子的消费者，要么他们想调用 API，要么在其中做任何其他操作。但有一点是肯定的，他们必须按照这个参数的类型定义要求，从这个函数返回<code class="fe nm nn no np b">Promise</code>。因为它将总是返回<code class="fe nm nn no np b">Promise</code>，所以我们正在等待它，如果它解决了，那么我们将把<code class="fe nm nn no np b">isSubmitting</code>状态设置为<code class="fe nm nn no np b">false</code>。</p><p id="a244" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe nm nn no np b">catch</code>块中，首先我们将<code class="fe nm nn no np b">isSubmitting</code>状态设置为<code class="fe nm nn no np b">false</code>，然后我们需要检查是否有验证错误发生，如果有，我们将把它们设置为状态。由于我们在<code class="fe nm nn no np b">try</code>块中调用了两个不同的函数，错误可以是不同的类型，要么是由<code class="fe nm nn no np b">validate</code>函数抛出的验证错误，要么是由<code class="fe nm nn no np b">submitHandler</code>函数抛出的未知错误。<br/>为了区分验证错误和未知错误，我们使用了名为<code class="fe nm nn no np b">isValidationError</code>的类型保护函数。此函数正在使用<em class="me"> TypeScript 的类型谓词功能。</em>我们正在检查<code class="fe nm nn no np b">inner</code>属性是否存在于错误对象中，并返回类型谓词<code class="fe nm nn no np b">err is ValidationError</code>。它在编译时和运行时都能工作。在编译时，它将把<code class="fe nm nn no np b">err</code>对象类型从<code class="fe nm nn no np b">any</code>缩小到<code class="fe nm nn no np b">ValidationError</code>，在运行时，它将检查<code class="fe nm nn no np b">err</code>对象中是否存在<code class="fe nm nn no np b">inner</code>属性，我们的条件语句将基于此工作。这里需要注意的一点是，我们没有在<code class="fe nm nn no np b">serializeYupErrors</code>函数的第二个参数中传递<code class="fe nm nn no np b">touchedFields</code>,因为我们希望在表单提交时设置每个字段的错误，而不仅仅是接触字段的错误。<br/>在处理验证之后，我们只是在<code class="fe nm nn no np b">touched</code>状态下将所有字段设置为<code class="fe nm nn no np b">true</code>，因为如果我们不这样做，那么一旦任何字段发生模糊事件，我们的验证函数将运行，并且由于在模糊事件中我们只设置被触摸字段的错误，未被触摸字段的错误将消失。</p><h2 id="1fd0" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">助手功能:</h2><p id="f7c8" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">最后，我们制作了一些助手函数，当这个钩子的消费者想要显式地设置值或错误时，这些函数非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0935" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇长文到此结束。我希望我把每一点都讲清楚了。如果你发现有什么难以理解的地方，请随时提问。</p><p id="a630" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这个<a class="ae ky" href="https://codesandbox.io/s/useform-hook-ml6vdt?file=/src/hooks/useForm.ts" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中找到完整的代码和用法示例。</p><h2 id="e266" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">最终想法:</h2><p id="3a78" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">我为我的一个项目制作了这个钩子，在这个项目中，我决定尽可能少地使用第三方库。这个钩子是为一些简单的用例设计的。它只支持数据的线性形状，不支持嵌套对象结构或对象数组。请根据您的需要随意扩展它的功能。但是我建议只有当你是出于学习的目的时才这么做，否则如果你的用例更复杂，最好使用流行的库，如<strong class="jm io"> React-Hook-Form </strong>或<strong class="jm io"> Formik </strong>。</p></div></div>    
</body>
</html>