<html>
<head>
<title>What Even Is a Mux?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Mux 到底是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-even-is-a-mux-c8b4d16de55?source=collection_archive---------18-----------------------#2022-04-11">https://blog.devgenius.io/what-even-is-a-mux-c8b4d16de55?source=collection_archive---------18-----------------------#2022-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1791" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">"工程师不擅长给事物命名。"</p><p id="7bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这适用于很多事情。奇怪的术语，时髦的词语，完全相同的东西有十个不同的名字…名单还在继续。承认这一点有点尴尬，但我认为学习围棋最讨厌的部分之一是我必须习惯的行话和术语。当你一开始什么都不知道，决定一头扎进一个新的话题时，你必须经历这些。</p><p id="a2b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是 mux？什么是处理程序？什么是中间件？手柄类型和手柄功能有什么区别？HandleFunc 和 HandlerFunc？苹果是橘子吗？生存还是毁灭？我喜欢游泳，有七个小矮人，怎么计算到月亮的距离？我到底在说什么？</p><p id="f7c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没关系。我知道迷失在文档丛林中的感觉。这将是我试图帮助初学者 Go web 开发人员的系列文章的第 1 部分。在这篇文章中，我将解释什么是 mux，它是如何工作的，以及如何编写自己的 mux。</p><h1 id="ce01" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是 mux？</h1><p id="4631" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">多路复用器。这不是一个很常见的词，这是肯定的。Mux 是<em class="ll">复用器</em>的简称。什么是多路复用器？</p><blockquote class="lm ln lo"><p id="1529" class="jk jl ll jm b jn jo jp jq jr js jt ju lp jw jx jy lq ka kb kc lr ke kf kg kh ig bi translated"><em class="in">复用器。一种能够在一个通信信道上同时传输多个信息或信号的设备。—Dictionary.com</em></p></blockquote><p id="5d05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Go 中，当我们说 mux 时，通常指的是 HTTP 请求多路复用器。它的主要工作是将传入的请求 URL 与一组预定义的路由进行匹配，并在匹配时做一些事情。简而言之，mux 充当进入应用程序的网关。</p><h1 id="e293" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">创建自定义多路复用器</h1><p id="fff4" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这在您的代码中会是什么样子？让我们一步一步来。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="836a" class="mb kj in lx b gy mc md l me mf">package main</span><span id="4537" class="mb kj in lx b gy mg md l me mf">import (<br/>    "log"<br/>    "net/http"<br/>)</span><span id="c9f6" class="mb kj in lx b gy mg md l me mf">func homeHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("This is the home page."))<br/>}</span><span id="105a" class="mb kj in lx b gy mg md l me mf">func aboutHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("This is the about page."))<br/>}</span><span id="fd13" class="mb kj in lx b gy mg md l me mf">func main() {<br/>    mux := http.NewServeMux()</span><span id="3ced" class="mb kj in lx b gy mg md l me mf">    mux.HandleFunc("/", homeHandler)<br/>    mux.HandleFunc("/about", aboutHandler)</span><span id="8dda" class="mb kj in lx b gy mg md l me mf">    log.Fatal(http.ListenAndServe(":8080", mux))<br/>}</span></pre><p id="8809" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个非常简单的后端应用程序的例子。它通过运行相应的<code class="fe mh mi mj lx b">homeHandler</code>和<code class="fe mh mi mj lx b">aboutHandler</code>处理函数来处理对<code class="fe mh mi mj lx b">/</code>和<code class="fe mh mi mj lx b">/about</code>端点的请求。先看主函数。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a248" class="mb kj in lx b gy mc md l me mf">mux := http.NewServeMux()</span></pre><p id="5869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将创建一个新的<code class="fe mh mi mj lx b">ServeMux</code>实例。<code class="fe mh mi mj lx b">ServeMux</code>是 mux 在<code class="fe mh mi mj lx b">net/http</code>代码中的定义方式。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="d29c" class="mb kj in lx b gy mc md l me mf">mux.HandleFunc("/", homeHandler)<br/>mux.HandleFunc("/about", aboutHandler)</span></pre><p id="25c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe mh mi mj lx b">ServeMux</code>有一个方法叫做<code class="fe mh mi mj lx b">HandleFunc</code>。这需要两个参数:目标端点和一个处理程序。<code class="fe mh mi mj lx b">HandleFunc</code>将向目标端点注册这个处理程序。每当请求到达端点时，我们的<code class="fe mh mi mj lx b">ServeMux</code>将检查该端点是否有注册的处理程序。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="161f" class="mb kj in lx b gy mc md l me mf">func homeHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("This is the home page."))<br/>}</span><span id="8c00" class="mb kj in lx b gy mg md l me mf">func aboutHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("This is the about page."))<br/>}</span></pre><p id="45cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是负责人。当到达一个端点时，处理程序实际上做了一些事情。他们有两个可以使用的参数:响应和请求。它可以从请求中读取任何数据，比如请求头和请求体。它还可以向响应中写入任何数据，无论是字节文本、简单的 HTML 还是 JSON 数据。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5ad3" class="mb kj in lx b gy mc md l me mf">log.Fatal(http.ListenAndServe(":8080"), mux)</span></pre><p id="bed1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一行是启动 web 服务器的代码。<code class="fe mh mi mj lx b">ListenAndServe</code>将在指定的端口监听，在本例中是 8080。您还可以选择使用哪个 mux，传入一个<code class="fe mh mi mj lx b">nil</code>值将使它使用<code class="fe mh mi mj lx b">DefaultServeMux</code>。请注意，不推荐使用默认的 mux，因为它是作为全局变量存储的，其他包可以修改它。</p><h1 id="90c2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">多路复用器是如何工作的？</h1><p id="8d31" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">因此，我们对多路复用器的工作原理有了较高的理解。让我们更深入一点，因为了解一些东西在引擎盖下是如何工作的是一件有趣的事情。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b609" class="mb kj in lx b gy mc md l me mf">type ServeMux struct {<br/>    mu    sync.RWMutex<br/>    m     map[string]muxEntry<br/>    es    []muxEntry<br/>    hosts bool<br/>}</span><span id="1e8d" class="mb kj in lx b gy mg md l me mf">type muxEntry struct {<br/>    h       Handler<br/>    pattern string<br/>}</span></pre><p id="a561" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以忽略<code class="fe mh mi mj lx b">sync.RWMutex</code>，因为这是一种防止并发请求处理期间出现任何问题的措施。这超出了本教程的范围。</p><p id="ada1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我上面提到的，mux 在 Go 中被定义为一种<code class="fe mh mi mj lx b">ServeMux</code>类型，这是一种保存两种不同数据的结构。</p><ul class=""><li id="dfb7" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><code class="fe mh mi mj lx b">ServeMux.m</code>保存与<code class="fe mh mi mj lx b">muxEntry</code>配对的 URL 模式的映射，T6 是保存处理程序和 URL 模式的结构。</li><li id="7560" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><code class="fe mh mi mj lx b">ServeMux.es</code>是用于模式匹配的<code class="fe mh mi mj lx b">muxEntry</code>对象的有序列表。</li><li id="97b1" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><code class="fe mh mi mj lx b">ServeMux.hosts</code>用于匹配基于主机的 URL，在 URL 中包含完整的主机名。</li></ul><h1 id="26f3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="da5c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">希望这篇文章对想要从事后端 web 开发的 Go web 初学者来说是一个有用的起点。同样，这只是后端 web 开发系列的第 1 部分，所以请关注下一组帖子！我们还没有涵盖 Go 为我们提供的所有内容。在下一篇文章中，我们将更详细地看看处理程序。</p><p id="dd2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读！你也可以在<a class="ae my" href="https://dev.to/jpoly1219/what-even-is-a-mux-4fng" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae my" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank"> my personal site </a>上查看这个帖子。</p></div></div>    
</body>
</html>