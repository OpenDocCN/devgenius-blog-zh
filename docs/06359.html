<html>
<head>
<title>Best way to speed up a bulk of HTTP requests in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中加速大量 HTTP 请求的最佳方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-way-to-speed-up-a-bulk-of-http-requests-in-python-4ec75badabed?source=collection_archive---------0-----------------------#2022-01-03">https://blog.devgenius.io/best-way-to-speed-up-a-bulk-of-http-requests-in-python-4ec75badabed?source=collection_archive---------0-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ce70" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何尽可能快地抓取网页，而不被禁止使用 Asyncio？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4dee0e233223e5f5d0b10cebb9bb667e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O0op0XnjFOEQE8h8"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图为<a class="ae ks" href="https://unsplash.com/@alternateskate?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的轮滑</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的 Unsplash </a>上</figcaption></figure><h2 id="6958" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">内容:</h2><p id="bf65" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">A.背景故事和一个用例</p><p id="ab04" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">B.理论+ <a class="ae ks" href="#e862" rel="noopener ugc nofollow">本文范围</a></p><p id="b9e7" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">C.<a class="ae ks" href="#df95" rel="noopener ugc nofollow">代码和解释</a></p><p id="6b22" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">D.参考</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="94c4" class="mu ku in bd kv mv mw mx ky my mz na lb jt nb ju lf jw nc jx lj jz nd ka ln ne bi translated">A.背景故事和一个用例</h1><p id="0590" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我有一个编程项目，需要每天从<a class="ae ks" href="https://www.sec.gov/os/accessing-edgar-data" rel="noopener ugc nofollow" target="_blank">sec.gov</a>读取大量内幕交易(表格 4s ),并建立一个美国最成功的内幕人士的排名列表。因此，我需要建立一个 Python 脚本，可以有效地处理数百万个 URL 请求，删除不必要的表单 4，并将剩余的数据作为 Pandas DataFrame 进行评估。<strong class="lr io">在本文中，我将只专注于下载器编程部分。</strong></p><p id="5a57" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">程序员需要考虑以下因素:</p><ul class=""><li id="b0b5" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">通过检查服务条款和<a class="ae ks" href="https://www.sec.gov/robots.txt" rel="noopener ugc nofollow" target="_blank"> robots.txt </a>抓取特定网站的<strong class="lr io">合法性</strong>(如:http://example.com/robots.txt)</li><li id="84cc" class="nf ng in lr b ls no lv np lc nq lg nr lk ns mh nk nl nm nn bi translated"><strong class="lr io">最大请求速率/限制</strong>和所需的<a class="ae ks" href="#02d9" rel="noopener ugc nofollow">报头</a>。例如，<a class="ae ks" href="https://www.sec.gov/os/accessing-edgar-data" rel="noopener ugc nofollow" target="_blank">sec.gov</a>有自己的网页抓取器访问其网站的指南:</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5276f211543e9b2e1f799344abab8656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*FYi3gRxtF927Tr1Zirq_8Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:<a class="ae ks" href="https://www.sec.gov/os/accessing-edgar-data" rel="noopener ugc nofollow" target="_blank">https://www.sec.gov/os/accessing-edgar-data</a></figcaption></figure></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="5479" class="mu ku in bd kv mv mw mx ky my mz na lb jt nb ju lf jw nc jx lj jz nd ka ln ne bi translated"><strong class="ak"> B .理论</strong></h1><h2 id="e862" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">本文的范围:</h2><ul class=""><li id="fc6b" class="nf ng in lr b ls lt lv lw lc nu lg nv lk nw mh nk nl nm nn bi translated"><a class="ae ks" href="#3505" rel="noopener ugc nofollow"> B.1 </a>如何<strong class="lr io">使用<code class="fe nx ny nz oa b">Asyncio</code>高效地创建一个脚本定期发出百万请求</strong>？</li><li id="8a61" class="nf ng in lr b ls no lv np lc nq lg nr lk ns mh nk nl nm nn bi translated"><a class="ae ks" href="#4f50" rel="noopener ugc nofollow"> B.2 </a>如何对<strong class="lr io">速率限制</strong>请求使用<code class="fe nx ny nz oa b">Aiolimiter</code>？</li><li id="91d0" class="nf ng in lr b ls no lv np lc nq lg nr lk ns mh nk nl nm nn bi translated"><a class="ae ks" href="#9da8" rel="noopener ugc nofollow"> B.3 </a>如何<strong class="lr io">使用<code class="fe nx ny nz oa b">asyncio.Semaphore</code>设置活动请求</strong>的最大数量？为什么有必要？</li></ul><h2 id="3505" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">B.1 C <strong class="ak">使用<code class="fe nx ny nz oa b">Asyncio</code>创建一个脚本来有规律地</strong>高效地发出百万个请求</h2><h2 id="26b5" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">为什么用</strong> <code class="fe nx ny nz oa b"><strong class="ak">Asyncio</strong></code> <strong class="ak">？</strong></h2><p id="1ac5" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在回答这个问题之前，读者应该先了解</p><p id="6093" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">a)CPU 绑定的任务<em class="ob">和 I/O 绑定的任务</em>之间的区别</p><p id="80a7" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">Python 中的并发编程。</p><p id="526e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><em class="ob">我建议读者好好阅读下面这篇</em> <a class="ae ks" href="https://leimao.github.io/blog/Python-Concurrency-High-Level/" rel="noopener ugc nofollow" target="_blank"> <em class="ob">写得好的文章</em> </a> <em class="ob">，因为它很好地解释了以上几点。因此，我在这里只写简短的总结和一些关于线程和异步的额外信息。</em></p><div class="oc od gp gr oe of"><a href="https://leimao.github.io/blog/Python-Concurrency-High-Level/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">Python 中的多处理 VS 线程 VS 异步</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在现代计算机编程中，经常需要并发来加速解决问题。在 Python 编程中…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">雷猫. github.io</p></div></div><div class="oo l"><div class="op l oq or os oo ot km of"/></div></div></a></div><p id="6be4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">a)CPU 受限和 I/O 受限任务之间的区别:</strong></p><p id="f51f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io"> CPU 受限任务</strong>:完成速度由你的处理器速度决定的一类任务。如果有两台计算机具有相同的 Python 安装和硬件规格(除了它的 CPU)，那么具有更快时钟频率 CPU 的计算机将更快地完成 CPU 受限的任务。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/fb021b8161ba12cec7df8d2c40dfd734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_72kWwNBiAMkSIQn"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@caioguijarro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡伊奥·吉哈罗</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄:摩托车最终会超过自行车，尽管自行车开始得更早。</figcaption></figure><p id="3f1e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io"> I/O-Bound task </strong>:一种任务，其完成速度取决于等待输入/输出操作完成的时间。例如，HTML-请求速度取决于您的网络、内存、服务器速度等。在 I/O 操作期间，您的 CPU 只会等待直到它完成。因此，升级您的 CPU 不会提高性能。HTML-Request 就属于这一类。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/94f59e4884876bd390c04175a83527cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U2oEL2vq6ajvorIs"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@pkprasad1996?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prasad Panchakshari </a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄:在交通堵塞的情况下，超级跑车不可能超越其他汽车。</figcaption></figure><p id="7124" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io"> b)并发编程的概念:</strong></p><p id="25b0" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">并发编程是一种计算形式，其中多个任务将同时执行。Python 有三个主要的并发编程库:<code class="fe nx ny nz oa b">Multiprocessing,</code> <code class="fe nx ny nz oa b">Threading</code>和<code class="fe nx ny nz oa b">Asyncio</code>。</p><p id="e72b" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">a.<code class="fe nx ny nz oa b">Multiprocessing</code>模块<strong class="lr io">可以利用所有可用的 CPU 内核</strong>并发执行不同的任务。它更适合执行 CPU 受限的任务，因为它能够充分利用 CPU。</p><p id="8e13" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">b.<code class="fe nx ny nz oa b">Threading</code>模块仅使用一个 CPU 内核，但它仍然可以通过为每个任务分配一个线程来同时执行多个任务。例如用于 5 个下载器的 5 个线程。操作系统(OS)将继续<strong class="lr io">为每个线程分配<em class="ob">相同的</em> CPU 时间，而不管线程是否准备好执行下一个任务</strong>(例如，线程是否仍在等待来自 HTML-Request 的响应)。换句话说，每个线程都<em class="ob">保证</em>获得相同数量的资源，不管它是否准备好做下一个任务或者任务本身是否已经完成。除了在分配资源时不够灵活之外，使用线程时还有另一个额外的成本:在线程可以启动之前，<strong class="lr io"> OS 需要管理&amp;调度所有线程</strong>，随着更多线程的创建，这将产生更大的开销。最后但同样重要的是，当不同的线程需要访问相同的资源(例如文件、共享内存等)时，可能会发生<strong class="lr io">竞争情况</strong>。)同时。这会使程序结构变得复杂。</p><p id="467a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi">___________________________________________________________________</p><h2 id="8f37" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是竞态条件？</h2><p id="aa7c" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">下面的场景将有助于理解什么是竞争条件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/1d882b1b8e0b3c8331b4a4323c1984e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*qTH3rTZu6rB-bIDQe9bKQQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">5 个快乐的僧侣会因为种族状况而挨饿。</figcaption></figure><p id="7b1f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">假设有 5 个和尚围坐在一张圆形桌子旁，每对和尚之间有一根筷子。要吃端上来的面条，每个和尚需要在他旁边放两只筷子。当所有的僧侣同时开始抓住筷子时，一场竞赛状态将会发生。在这种情况下，没有人可以吃他的面条，他们基本上是互相阻碍。</p><p id="ce27" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi">___________________________________________________________________</p><p id="a491" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">c.<code class="fe nx ny nz oa b">Asyncio</code>模块<strong class="lr io">只利用一个线程来同时执行多个任务</strong>(这里是多个 HTML 请求)。因为它只使用一个线程，<strong class="lr io">操作系统不需要在启动程序之前创建一个调度器</strong>(开销更少)。此外，有了 Asyncio，我们可以<strong class="lr io">防止竞态条件</strong>。为了 100%正确，竞态条件仍然可能发生，但是你必须非常努力才能得到它。</p><p id="4554" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">回到我们的用例</strong>进行多个 HTML 请求，<code class="fe nx ny nz oa b">Asyncio</code>将在 0.0007 秒发起第一个请求(pep-8015)。<code class="fe nx ny nz oa b">Asyncio</code>将在 0.0127 秒时启动下一个 HTML 请求(pep-8012 及其他)，而不是等待响应。在发起请求后，<code class="fe nx ny nz oa b">Asyncio</code>不会切换回例如 pep-8015，直到它收到请求的响应并准备好下一个任务/步骤。这个场景假设没有应用速率限制器。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/004ee88405b6a530a6f7673e437cee1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZ4E7lzy2DUNYt3MYifEiw.png"/></div></div></figure><p id="ee65" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">使用<code class="fe nx ny nz oa b">Threading</code>，CPU 将切换回 pep-8015，当时间表显示轮到 pep-8015 时，尽管请求仍然没有响应。在这种情况下，CPU 将保持空闲，直到另一个 HTML 请求出现，并且已经得到响应。</p><h2 id="4f50" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">B.2 使用<code class="fe nx ny nz oa b">Aiolimiter</code>对请求进行速率限制</h2><p id="c377" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">为了限制请求的速率，我们将使用<code class="fe nx ny nz oa b">aiolimiter</code>中的<code class="fe nx ny nz oa b">AsyncLimiter</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="341d" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">两个示例都允许每秒 8 个请求，但互不相同:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/eb7ed51cfa91d46980cbc4429a3f1b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dM63SdG2Q8SLrTApM7d6jA.png"/></div></div></figure><p id="faee" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">示例 A </strong>:该限制器将严格地每 0.125 秒启动一个任务。</p><p id="ae14" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">示例 B </strong>:有了这个限制器，前 8 个任务可以快速连续启动，因为有足够的容量可用。一旦达到容量，限制器将启动，下一个请求将不得不等待足够的时间来释放容量，这是上一个请求后的 1/8 秒。(参考下图)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/1ede0f72b890dad93241cc3e88d7e915.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*3vVyMEru-6pzzINE05s4aA.png"/></div></figure><p id="4b5f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">一些读者可能会问，为什么我不使用简单的<code class="fe nx ny nz oa b">sleep</code>命令呢？坦率地说，如果您只需要执行一次一千个请求，那么下面的争论都无关紧要。这是一个完全不同的故事，如果你有一个脚本，需要每天执行数百万次请求。在这种情况下，您确实需要一种有效的方法来请求 HTMLs，评估下载的内容，过滤，组合所有必要的内容，并以可读的格式显示为 Pandas DataFrame。</p><h2 id="76f4" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">为什么用</strong> <code class="fe nx ny nz oa b"><strong class="ak">Aiolimiter</strong></code> <strong class="ak">而不是</strong> <code class="fe nx ny nz oa b"><strong class="ak">sleep</strong></code> <strong class="ak">命令？</strong></h2><p id="2926" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated"><strong class="lr io">差速方式限制#1 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c70b" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">命令<code class="fe nx ny nz oa b">time.sleep(0.125)</code>不应该和<code class="fe nx ny nz oa b">Asyncio</code>一起使用，除非你对此有很好的理由。原因是在<code class="fe nx ny nz oa b">time.sleep</code>命令完成之前，它会阻塞所有其他的东西。如果你的脚本只是从所有的 URL 下载，而对下载的内容不做任何处理，那也不是很糟糕。理想情况下，在空闲时间，脚本应该执行另一个任务，例如评估从过去的请求下载的内容。</p><p id="c197" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">速率限制#2 的不良方式</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e1df" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">有人可能会说上面的代码“足够好”，事实也的确如此。这肯定比前一个代码好，然后在<code class="fe nx ny nz oa b">await asyncio.sleep(0.125)</code>期间，代码可以切换到另一个任务。不过这段代码的一个小问题是，无论前面的命令行持续多长时间，函数总是等待 0.125 秒。与<code class="fe nx ny nz oa b">Aiolimiter</code>相比，这种时间差异是很小的(见下一个截图)，但是如果你把它累积到数百万次，并经常这样做，它将会有所不同。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bc0a66fa1aecdac2d85140035c76c7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*GY9TTXoCbeDVzLYopkjMlg.png"/></div></figure><h2 id="9da8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">使用<code class="fe nx ny nz oa b">Semaphore</code>设置活动请求的最大数量</h2><blockquote class="pd pe pf"><p id="a6da" class="lp lq ob lr b ls mi jo lu lv mj jr lx pg mk lz ma ph ml mc md pi mm mf mg mh ig bi translated">同时做 3 个请求很酷，但是做 5000 个就不那么好了。来源:<a class="ae ks" href="https://compiletoi.net/fast-scraping-in-python-with-asyncio/#bonustrackdonthammertheserver" rel="noopener ugc nofollow" target="_blank">链接</a></p></blockquote><p id="85f5" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">假设我们有以下速率限制:</p><p id="51c4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">limiter = AsyncLimiter(1, 0.125)</code></p><p id="a94a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在此限制下，每秒将启动 8 个请求。假设不管是什么原因，2 秒后仍然没有响应(16 个主动请求)。随着时间的推移，更多的主动请求将被发起，这是没有帮助的，也是不必要的。因此，我们需要使用<code class="fe nx ny nz oa b">Semaphore</code>来限制活动请求的最大数量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/c8c9cfffbef22bf61a92d1ffd462bc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*7_cptA2Rsz-h9ibf5-FnmA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">只有两个制作桌子的任务可以同时发生，因为只有两个锤子可用。</figcaption></figure><p id="d703" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我们用上面的截图来了解一下<code class="fe nx ny nz oa b">Semaphore</code>是如何工作的。</p><ul class=""><li id="6ba5" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">有两把锤子可以用来做桌子。在 Python 中:</li></ul><p id="67eb" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">semaphore = asyncio.Semaphore(value=2)</code></p><ul class=""><li id="4788" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">x 想借一把锤子做桌子:</li></ul><p id="4871" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">await semaphore.acquire()</code>。之后，只有<strong class="lr io">1‘信号量’可用</strong>。</p><ul class=""><li id="d25b" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">y 还想借一把锤子:</li></ul><p id="8f10" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">await semaphore.acquire()</code>。之后<strong class="lr io">0‘信号量’可用</strong>。</p><ul class=""><li id="28f5" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">下一个人也想借一把锤子:</li></ul><p id="c957" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">await semaphore.acquire()</code>。因此，商店经理告诉他，他有<strong class="lr io">等待 X 或 Y 归还一把锤子</strong>。</p><ul class=""><li id="947b" class="nf ng in lr b ls mi lv mj lc nh lg ni lk nj mh nk nl nm nn bi translated">x 不需要锤子，把它还给它的主人:</li></ul><p id="3f7b" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe nx ny nz oa b">semaphore.release()</code>。<strong class="lr io">现在下一个人可以借一把锤子</strong>。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="df95" class="mu ku in bd kv mv mw mx ky my mz na lb jt nb ju lf jw nc jx lj jz nd ka ln ne bi translated">C.代码和解释:</h1><h2 id="3471" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">必备 Python 库:</h2><ul class=""><li id="d8f3" class="nf ng in lr b ls lt lv lw lc nu lg nv lk nw mh nk nl nm nn bi translated"><code class="fe nx ny nz oa b"><a class="ae ks" href="https://pypi.org/project/asyncio/" rel="noopener ugc nofollow" target="_blank">Asyncio</a></code> : Python 有 3 个主库，允许<a class="ae ks" href="#7124" rel="noopener ugc nofollow">并发编程</a>。其中之一就是<code class="fe nx ny nz oa b"><a class="ae ks" href="#a491" rel="noopener ugc nofollow">Asyncio</a></code>。</li><li id="de20" class="nf ng in lr b ls no lv np lc nq lg nr lk ns mh nk nl nm nn bi translated"><code class="fe nx ny nz oa b"><a class="ae ks" href="https://pypi.org/project/aiohttp/" rel="noopener ugc nofollow" target="_blank">Aiohttp</a></code>:该库与 Asyncio 兼容，将用于执行异步 HTML 请求。</li><li id="e876" class="nf ng in lr b ls no lv np lc nq lg nr lk ns mh nk nl nm nn bi translated"><code class="fe nx ny nz oa b"><a class="ae ks" href="https://pypi.org/project/aiolimiter/" rel="noopener ugc nofollow" target="_blank">Aiolimiter</a></code>:请求<a class="ae ks" href="#4f50" rel="noopener ugc nofollow">速率限制</a>(例如 max。10 个请求/秒)可以用<code class="fe nx ny nz oa b">Aiolimiter</code>控制。</li></ul><h2 id="472f" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">使用 Asyncio 同时发出多个 HTML 请求并使用 Aiolimiter 对其进行速率限制的过程</h2><p id="0a17" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated"><strong class="lr io">第 1 部分:设置 Python 库</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="64d3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">第 2 部分:定义最大请求速率限制(例如每秒 8 个请求)</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="23aa" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">上述限制器仅允许 1 个请求/0.125 秒。<a class="ae ks" href="#4f50" rel="noopener ugc nofollow">解释。</a></p><p id="f1c3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">第 3 部分:创建一个“异步定义”函数来下载</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="87c0" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">看起来像一个普通的函数，但它实际上是一个协程。一个非常简单的解释:协程是一个能够被挂起(在<code class="fe nx ny nz oa b">await</code>关键字)并在完成前从挂起的地方恢复的函数。换句话说，<code class="fe nx ny nz oa b">await</code>关键字是<code class="fe nx ny nz oa b"><a class="ae ks" href="#7124" rel="noopener ugc nofollow">Asyncio</a></code>可以将执行控制权转移给另一个例程/任务的点。<code class="fe nx ny nz oa b">Await</code>关键字被应用在例如第 8 行，因为这是命令行，在那里 CPU 将不得不等待空闲。使用<code class="fe nx ny nz oa b">await</code>可以恢复或启动另一个准备好的任务，而不是等待空闲。但是要小心，由于兼容性问题，不是每个操作都与<code class="fe nx ny nz oa b">await</code>结合。例如<code class="fe nx ny nz oa b">Pandas</code>操作与<code class="fe nx ny nz oa b">Asyncio</code>不兼容。(因此，当我必须进行 Pandas 操作时，例如在每次下载后合并新的和现有的内容，我必须使用<code class="fe nx ny nz oa b">asyncio.Queue</code>临时保存结果。)</p><p id="6008" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">基本上，上面的代码所做的是</strong>发出一个 HTML 请求，当有一个<a class="ae ks" href="#9da8" rel="noopener ugc nofollow">信号量</a>可用并且速率限制允许的时候。在<code class="fe nx ny nz oa b">content = await resp.read()</code>期间等待响应时，Asyncio 将寻找另一个准备启动或恢复的任务。</p><p id="d385" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">第 4 部分:将每个下载的内容写入一个新文件</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="508e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">这段代码创建了一个文件，并将每个下载的内容写入其中。该函数被创建为协程，尽管其中没有<code class="fe nx ny nz oa b">await</code>。它以这种方式创建，以便在下一部分的后面与<code class="fe nx ny nz oa b">await</code>组合在一起。</p><p id="92b6" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">第 5 部分:将第 3 部分和第 4 部分合并成一个协程</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="21d3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">第 3 部分和第 4 部分中的协同程序被合并成一个协同程序。目的是将每个 URL 需要执行的两个步骤(下载和写入文件)组合在一起。</p><p id="a9d4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">第六部分:主协程</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="d0a7" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在<code class="fe nx ny nz oa b">main</code>协程中，将创建一个为 10 的<code class="fe nx ny nz oa b"><a class="ae ks" href="#9da8" rel="noopener ugc nofollow">Semaphore</a></code>，这意味着任何时候允许的最大活动请求数为 10 个。之后，将为从 8010 到 8016 的每个号码“创建”(而不是开始)一个<code class="fe nx ny nz oa b">web_scrape_task</code>任务，并将其添加到一个<code class="fe nx ny nz oa b">tasks</code>列表中。接下来<code class="fe nx ny nz oa b">tasks</code>列表中的所有任务都将通过关键字<code class="fe nx ny nz oa b">await</code>启动。</p><p id="5b4a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">要开始执行一个协程函数，例如<code class="fe nx ny nz oa b">main</code>协程，您需要执行:<code class="fe nx ny nz oa b">asyncio.run(main())</code>。如果您改为使用<code class="fe nx ny nz oa b">main()</code>，那么将显示以下错误:<code class="fe nx ny nz oa b">RuntimeWarning: coroutine ‘main’ was never awaited</code>。</p><p id="02d9" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">HTML-Request 的标题是什么？</strong></p><p id="6836" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">如果您返回到上方的<a class="ae ks" href="#84cc" rel="noopener ugc nofollow">第二个屏幕截图，sec.gov 需要您也为您的请求声明标题。在这种情况下，您的请求代码应该是:</a></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6e44" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><strong class="lr io">组合代码:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="4a9c" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我希望你能从本教程中受益。如果你有什么问题或者有什么改进建议(这是我的第一篇中篇文章)，可以在 commentar 版块联系我:-) <em class="ob">如果你读到这里并且喜欢，请为这篇文章鼓掌。</em></p><h1 id="5d5a" class="mu ku in bd kv mv pk mx ky my pl na lb jt pm ju lf jw pn jx lj jz po ka ln ne bi translated"><strong class="ak"> D .参考</strong></h1><p id="5e4b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated"><a class="ae ks" href="https://leimao.github.io/blog/Python-Concurrency-High-Level/" rel="noopener ugc nofollow" target="_blank">1 . https://lei Mao . github . io/blog/Python-Concurrency-High-Level/</a>:这篇网文很好的解释了并发编程的概念。我强烈建议读者阅读它，尤其是如果你正在考虑应用这个概念。</p><p id="7083" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">2.课本<a class="ae ks" href="https://www.amazon.de/Using-Asyncio-Python-Understanding-Asynchronous/dp/1492075337/ref=sr_1_1?__mk_de_DE=ÅMÅŽÕÑ&amp;keywords=using+asyncio&amp;qid=1640883364&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">《在 Python 中使用 Asyncio:理解 Python 的异步编程特性》</a>:这本书的第 1 章和第 2 章确实固化了我对三个并发模块之间区别的理解。尤其是 Threadbots 经营的餐馆的例子。</p><p id="4820" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">3.快乐和尚图片复制自:<a class="ae ks" href="https://www.deviantart.com/mondspeer/art/happy-monk-506670247" rel="noopener ugc nofollow" target="_blank">https://www . deviantart . com/monds peer/art/happy-monk-506670247</a></p><p id="df6a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">4.面条图片抄袭自:<a class="ae ks" href="https://pngimg.com/image/44276" rel="noopener ugc nofollow" target="_blank">https://pngimg.com/image/44276</a></p><p id="a6ce" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">披露:我没有从建议任何外部材料中获得任何好处。</p></div></div>    
</body>
</html>