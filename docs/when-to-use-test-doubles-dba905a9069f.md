# 何时使用测试替身

> 原文：<https://blog.devgenius.io/when-to-use-test-doubles-dba905a9069f?source=collection_archive---------3----------------------->

测试双打是工具，以简化我们的测试，他们也可以用来设计代码还没有写。定义或多或少独立于其他单元的粒度单元。但它们不是生产代码，它们是双精度的。

![](img/f79a646310e71939f9aadbe7d48bc913.png)

[Pixabay](https://pixabay.com/es/photos/br%c3%bajula-mapa-direcci%c3%b3n-grados-2946959/)

测试替身是简化我们测试的工具，通常使用它们你需要修改你的代码。您需要引入合作者来帮助您提取一些逻辑，您想要独立测试的逻辑，以便为使用您的合作者的上层逻辑引入一个替身。

一些定义摘自[马丁的福勒博客](https://martinfowler.com/bliki/TestDouble.html):

*   **虚拟物品被传来传去，但从未真正使用过。通常它们只是用来填充参数表。**
*   **假的**对象实际上有工作的实现，但是通常采取一些捷径，这使得它们不适合生产(一个 [InMemoryTestDatabase](https://martinfowler.com/bliki/InMemoryTestDatabase.html) 就是一个很好的例子)。
*   存根为测试期间的呼叫提供固定的答案，通常对测试程序之外的任何事情都不作出回应。
*   **间谍**是存根，也根据他们被调用的方式记录一些信息。其中一种形式可能是记录发送了多少条消息的电子邮件服务。
*   **模拟**是预编程的预期，形成了它们预期接收的呼叫的规范。如果他们收到一个他们不期望的调用，他们可以抛出一个异常，并在验证过程中进行检查，以确保他们得到了他们期望的所有调用。

正如我们之前所说的，我们必须修改代码来使用它们。我的测试服务(SUT)将会做更少的事情，承担更少的责任。我将一些职责委托给我的测试所代表的生产实现。如果我的代码基本上是在玩第三方库、框架或任何我不能轻易改变的东西，以产生任何副作用，我真正想检查的是我的代码使用那个库有多好。
在这种情况下，我的代码与库耦合得如此紧密，以至于实际上我只是在使用它，在这种情况下，我不认为将库改变两倍是个好主意。

> 只嘲笑你所拥有的，因为嘲笑别人是粗鲁的。
> [https://twitter.com/hynek/status/1478384282766913548](https://twitter.com/hynek/status/1478384282766913548)

我想说的是，作为一个通用规则，不要通过任何类型的测试来改变库或框架。

让我们想象一下，我想在我的组织之外调用一个 rest 端点，并且我想为正在做最后工作的那个薄层创建一个测试。
我知道我不能在测试中调用真正的 rest 端点，所以我需要在某个点使用某种 double。
按照上面描述的规则，我需要使用真实的库来调用 rest 端点，所以我唯一能做的就是伪造服务器。这很好，因为我将测试我是否真的正确使用了该库，我是否真的调用了正确的终结点，以便在任何情况下都能管理来自该库的错误。基本上，我正在测试与该库的集成。
那个假服务器只是一组预定义的 rest json 对一组请求的答案，但会强制我们的代码与库以及我们想要测试的所有情况正确交互。

这些假设只是合约的一部分，是的，test-doubles 定义了客户端、被测服务(SUT)和我们的服务器(在本例中是假服务器)之间的合约。

## 服务器端合约

可以这样说，如果服务器发生更改，则合约将被破坏，这里有两种情况:

*   如果示例中的服务器由组织中的其他团队开发，并且团队之间有良好的沟通，则由您控制服务器。在这种情况下，可以使用合约测试来检查服务器是否不能破坏合约(例如，使用 [Pact](https://docs.pact.io/) )。
*   如果不控制服务器，则只能确定监视服务器的情况正在发生变化。如果可以访问登台环境，则可以监视该环境以确保情况不会发生变化(基于您的集成需要)，如果不能，则可以在生产环境中监视服务器，以便获得有关正在发生的情况的早期反馈并尽快做出反应。

如果不控制服务器，则通过在管道中执行的 e2e 测试来检查客户端和服务器之间的集成没有多大价值。e2e 测试往往测试很多不同的方面:

*   应用程序的前端部分。
*   数据库中的数据。
*   与服务器的集成。
*   整个应用程序的逻辑。

如果一个测试失败了，而它的大范围又无法告诉你失败的地方，那就很难验证了，devs 不喜欢一次又一次地重复调查。
监控两个系统集成过程中发生的事情要容易得多，也有效得多。

## 投入和产出

请不要在一般情况下对输入数据和输出结果使用 doubles(假人除外)。如果您正在创建它们，这尤其糟糕，因为这些输入和输出很难创建。这就是为什么[我不喜欢构建器模式](/why-i-dont-like-the-builder-pattern-e05423698a9a?sk=ab3e214029e33109be6c2157f66b5dfa)的相同症状，它通常意味着我们没有遵守实体的[界面分离原则。
那些值可能不是我们感兴趣的东西，我们只是在使用它们，因为它们已经在过去被创造了，我们也懒得创造新的抽象。](https://en.wikipedia.org/wiki/Interface_segregation_principle)

## 双倍的风险

测试替身伴随着风险(在软件中，一切都是交易)。当您在测试中引入测试 double 时，您是在假设产品代码将如何运行。
正如我所说的，如果您在创建生产代码时通过测试 double 来控制您正在更改的生产代码，您必须强制生产代码的行为与使用 double 的测试中描述的输入的 double 相同。
风险是在未来改变产品代码而不改变你的 double，那么我们的测试将通过，但是我们的代码将在产品中被破坏。我通常会考虑到这种风险，所以为了最小化它，我会尝试在布局之间的边界使用 doubless，在特殊情况下，如果它们支付账单的话，我会在布局内部使用 double(逻辑非常复杂，所以我降低了测试的复杂性)。仅在布局之间的边界使用它们帮助我识别它们，在某种意义上定义布局，进行设计。
如前所述，还有可能使用[契约测试](https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests)来验证契约在双精度和您的生产代码之间没有丢失。

## 何时使用它们

如果您还不知道使用什么 db 或者最终的 rest-endpoint 是什么，那么可以使用 test doubles 来委托将来的决策。Doubles 将帮助您创建这些概念的包装器，这些概念将您(在一定程度上)与所有对构建您的业务逻辑不重要的特定决策隔离开来。

使用 doubles 来降低生产代码的复杂性，从而减少您必须在 SUT 中创建的测试数量。

有些开发者试图避免使用测试替身，他们试图用真正的库和基础设施来测试一切。我不喜欢这种方法，因为大量集成或 e2e 测试的结果是低反馈环路(非常慢的管道)。当测试反馈循环缓慢时，人们倾向于制造大批量的。