<html>
<head>
<title>Why and how to start an API project in Typescript with nodeJS?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何用 nodeJS 在 Typescript 中启动一个 API 项目？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-and-how-to-start-an-api-project-in-typescript-with-nodejs-5aa1855bb507?source=collection_archive---------9-----------------------#2022-02-02">https://blog.devgenius.io/why-and-how-to-start-an-api-project-in-typescript-with-nodejs-5aa1855bb507?source=collection_archive---------9-----------------------#2022-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/630e9ed5e517d72f78f197f391fe0a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFdEvPBxL57TFAEhfs9o-w.jpeg"/></div></div></figure><div class=""/><p id="aebb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你开始一个项目的时候有很多事情要做:<strong class="jx iz">选择合适的技术</strong>和语言，<strong class="jx iz">选择合适的框架</strong>(或者从头开始)，初始化框架(或者你的第一个代码文件)并编译第一个 hello world，开始学习它是如何工作的最后编码…</p><p id="4768" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个过程的每一步，你都可能失败:选择错误的技术，选择错误的框架，等等。…没有人能事先告诉你什么是好什么是错。因为它必须在技术方面满足你的需求，当然，也要在资源(我的开发人员拥有哪些语言)、约束(可能是客户约束)等方面满足你的需求。…</p><p id="d8ac" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的工作和公司中，我使用 JSON 为<strong class="jx iz">应用程序后端</strong>开发了许多<strong class="jx iz">REST API，这篇文章将向你揭示为什么我使用这些技术(Typescript 和我将描述的所有库)来构建它们。我将展示我使用的文件夹结构，并建议看一看我构建的<a class="ae kt" href="https://github.com/cecric/hexapinod" rel="noopener ugc nofollow" target="_blank">bootstrap skeleton project Hexapinod</a>(也可以称为框架)。</strong></p><p id="30e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你已经知道为什么选择这项技术，跳转到技术细节可以直接跳转到段落“<strong class="jx iz">如何在 Typescript 中开始一个项目？</strong>”。</p><h1 id="cf48" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">首先，为什么是 NodeJS 和 Typescript？</h1><p id="3356" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">大约 15 年前，我开始用 javascript 进行开发，像许多开发人员一样，为浏览器环境编写 JQuery 脚本。当 NodeJS 出来的时候，我没有看到这项技术的真正优势。我只是告诉自己，这是另一种简单的语言工具，可以做伟大的事情。现在我可以说，我错了。<strong class="jx iz">NodeJS 的优点是多重的</strong>，缺点也是多重的。很多文章都谈到了这个问题(在媒体上也有很多)，所以我只用这句话来继续:如果你构建了一个解决方案，它有<strong class="jx iz">大量的 IO </strong>(“输入/输出”，比如在数据库、文件或队列上的“读/写”)，<strong class="jx iz">而不需要大量的处理器计算</strong>(我指的是需要大量时间的复杂算法)，并且应该在同一个平台上用相同的技术与其他独立项目一起运行，那么<strong class="jx iz"> NodeJS 可能是一个好的解决方案【T19 在许多从数据库中提供文件或结果的 web 后端服务器中，这是一个非常好的解决方案。</strong></p><p id="b5e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从它的名字可以看出，<strong class="jx iz"> NodeJS 读 JS </strong>的意思是 Javascript 文件。Javascript 是一种很棒的语言，但是它缺乏在大中型团队中使用的特性(比如“类型”)。例如，由于缺少这些特性，您无法指定函数的 in 和 out，也无法定义一些接口。这就是创建<strong class="jx iz">打字稿</strong>的原因。它<strong class="jx iz">带来了“类型”</strong>、接口和许多其他特性来更好地指定您的代码。它避免了开发过程中的错误，也有助于代码架构师和测试人员与开发人员合作。<strong class="jx iz"> Typescript 会产生 Javascript </strong>。Javascript 已经是一种脚本语言，我的意思是它没有被编译成可执行文件，而是直接由浏览器 Ecmascript 引擎解释，或者像我们的例子一样，由 NodeJS 解释。所以我们会用脚本语言来产生脚本代码。</p><h1 id="710a" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">哪个框架？</h1><p id="5395" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">组合 Typescript/NodeJS 的主要问题就在这里，你会找到一些库来制作 RESTAPIs 并使用 Javascript 和 Typescript，例如著名的<a class="ae kt" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> ExpressJS </a>。你会发现很多图书馆。但是我没有找到一个真正的用 Typescript 构建的后端框架，就像你可以在用<a class="ae kt" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank">哈比神</a>或<a class="ae kt" href="http://restify.com/" rel="noopener ugc nofollow" target="_blank"> Restify </a>的 Javascript 中找到的那样。<a class="ae kt" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> NestJS </strong> </a> <strong class="jx iz">和</strong><a class="ae kt" href="https://adonisjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">AdonisJS</strong></a><strong class="jx iz">可能是很好的玩家</strong>，但是它们有太多的特性，你不能像构建一个经典的前端网站那样构建一个 REST API。框架<a class="ae kt" href="https://docs.feathersjs.com/" rel="noopener ugc nofollow" target="_blank">羽毛</a>是最接近我们所考虑的如果你想要一个经典的方法，但是因为它完全基于 ExpressJS，如果明天我不想再使用这个库，我将被迫改变所有的框架。我不会列举所有可用的项目和框架，我会让您发现一些新的。</p><p id="1dee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看完所有这些项目并考虑到我之前所说的，我现在有了我为什么在这里开始创建自己的<strong class="jx iz"/><a class="ae kt" href="https://github.com/cecric/hexapinod" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">框架</strong> </a>的理由。也可以构建其他库，比如 ExpressJS，但不要依赖它们。</p><h1 id="b81f" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何在 Typescript 中启动一个项目？</h1><p id="3524" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">要启动一个 Typescript 项目，在我们的例子中，它几乎是一个 NodeJS 项目。首先，我们将执行此命令来初始化 NodeJS 项目:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0f96" class="mg kv iy mc b gy mh mi l mj mk">npm init</span></pre><p id="b7c1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在许多帖子中，你会看到在那之后在全局中安装了 typescript。我避免这种做法，因为我使用不同版本的库，甚至不同版本的 typescript 来处理许多项目。我更喜欢将它作为开发依赖项安装到我的项目的本地。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2617" class="mg kv iy mc b gy mh mi l mj mk">npm install --save-dev typescript<br/>npx tsc --init</span></pre><p id="793f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将通过在项目的根目录下创建一个 tsconfig.json 文件来初始化您的 typescript 环境。这个配置文件将告诉 ts 命令您想要将编译后的代码部署到哪里，在<strong class="jx iz">中您想要部署哪个版本的 EcmaScript】，在 typescript 中激活了哪些特性。我不会描述所有的参数，因为这是一个令人头疼的问题，但我会根据我的设想解释最重要的。</strong></p><p id="2c7d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个是您将在其中编译的 EcmaScript 版本。默认情况下，它可能已经在 ES6 中设置好了，因为所有浏览器都支持它，但是我们通过 NodeJS 运行它。这在很大程度上取决于您将在服务器上使用哪个版本的 NodeJS。在我开始的项目中，我喜欢所有东西的最后版本，所以，在我写这几行的时候，是这个选项:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d640" class="mg kv iy mc b gy mh mi l mj mk">"lib": ["es2021"],<br/>"target": "es2021",</span></pre><p id="c42c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您希望每次都在 NodeJS 的最新版本上，也可以编写 ESNext。下面是 EcmaScript 的<strong class="jx iz">版本和符号的概述:</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b2c0" class="mg kv iy mc b gy mh mi l mj mk">es6 =&gt; es2015<br/>es7 =&gt; es2016<br/>es8 =&gt; es2017<br/>es9 =&gt; es2018<br/>es10 =&gt; es2019<br/>es11 =&gt; es2020<br/>es12 =&gt; es2021<br/>es13 =&gt; es2022</span></pre><p id="6595" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件的一个重要参数是加载器的选择:<a class="ae kt" href="https://nodejs.org/api/modules.html" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">CommonJS</strong></a><strong class="jx iz">【CJS】</strong>或<a class="ae kt" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> EcmaScript 模块</strong> </a> <strong class="jx iz"> (ESM) </strong>是 NodeJS 的两个主要选项。<strong class="jx iz"> esM 在 CJS </strong>上有很多优势，但我建议你用 ESM 开始你的新项目，原因很简单，两个模块一起工作会更容易:完整的 ESM 模块和 CJS 模块(你会在许多帖子上找到差异和比较，这些帖子对优势有一些很好的解释:<a class="ae kt" href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1" rel="noopener ugc nofollow" target="_blank">战争中的节点模块:为什么 CommonJS 和 ES 模块不能相处</a>，<a class="ae kt" href="https://webreflection.medium.com/cjs-vs-esm-5f8b90a4511a" rel="noopener"> CJS vs ESM </a>，<a class="ae kt" href="https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm" rel="noopener ugc nofollow" target="_blank">CJS，AMD，UMD，到底是什么</a>)。ESM 也应该更有效率，但是凭经验，我可以告诉你，你应该看不出区别。这取决于您在“tsconfig.json”中选择正确的配置，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c79e" class="mg kv iy mc b gy mh mi l mj mk">"module": "commonjs",<br/>or<br/>"module": "esm",</span></pre><p id="183f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ml">注意，你应该在你的“package.json”中定义相应的类型(对于 ESM 项目，用 value 模块设置 key 类型，而不是为 CJS 项目设置这个 key)。</em></p><p id="def1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您在代码中抛出错误时，为了能够找到您的类型脚本中的问题，您应该<strong class="jx iz">激活源映射</strong>以让命令 Tsc 在生成的 JS 文件和类型脚本文件之间生成源映射。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a256" class="mg kv iy mc b gy mh mi l mj mk">"sourceMap": true</span></pre><p id="9963" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将在 NodeJS 命令中由一个参数调用(我建议只在开发执行中这样做，您可以避免使用在执行中有一些问题的 ts-node):</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="96e9" class="mg kv iy mc b gy mh mi l mj mk">node --enable-source-maps  ./dist/mycompiledapp.js</span></pre><p id="d718" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 typescript 中，为了避免导入中的复杂路径(例如这样的路径:<code class="fe mm mn mo mc b">import '../../../../MyLibFolder/MyAwesomeLibFile';</code>)，您可以<strong class="jx iz">定义主文件夹的别名</strong>(例如代码将改为:<code class="fe mm mn mo mc b">import '@dependencies/MyLibFolder/MyAwesomeLibFile';</code>)。你会发现很多帖子都在谈论化名，有利有弊。我会这样继续:<strong class="jx iz">它使代码更容易调试，但是在编译过程中你会遇到很多路径问题</strong>。我的建议是使用别名，即使在开始项目时编译过程可能很难构建。因为您的代码更容易调试，也更容易被新开发人员理解。当你在团队中工作时，考虑这一点是非常重要的。为此，您应该将路径声明到“tsconfig.json”文件中，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e663" class="mg kv iy mc b gy mh mi l mj mk">"paths": {<br/>     "*": [<br/>          "node_modules/*",<br/>          "lib/types/*",<br/>     ],<br/>     "@core/*": [<br/>          "src/core/*"<br/>     ]<br/>}</span></pre><p id="c8d7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，您可以看到我们声明了 core 用于您的导入路径。所以用这个你会导入会变成:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bbd0" class="mg kv iy mc b gy mh mi l mj mk">import { MyAwesomeLib } from '@core/MyAwesomeLib';</span></pre><p id="6870" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个问题是你的 lib 应该以“.”结尾。js”当你导入的时候。如果您像上面那样编写导入，它将会失败。我认为，当你用 Typescript 编写代码来实现这一点时，真的很令人不安，因为文件以“.”结尾。js”是一个编译后的文件。这不是您创建的文件。为了避免这种情况，我建议使用<a class="ae kt" href="https://github.com/justkey007/tsc-alias" rel="noopener ugc nofollow" target="_blank"> Tsc 别名</a>或<a class="ae kt" href="https://github.com/dividab/tsconfig-paths" rel="noopener ugc nofollow" target="_blank"> Tsconfig 路径</a>。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/06b5d0ddd02d9ed15782ad501b8033ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfbamN9fOuK0UGVwtgrP1g.jpeg"/></div></div></figure><h1 id="ef80" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我的项目六足动物</h1><p id="7b5f" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">每次我为客户或我自己开始一个新的 API 项目时，我都使用相同的堆栈。相同的产品包、相同的入口点、相同的需求。在最流行的 NestJS 上构建它对我来说并不是一个好的解决方案，因为它附带了很多 API 不需要的函数。我认为这就像用火箭筒消灭一只苍蝇。</p><p id="3f94" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我创建<a class="ae kt" href="https://github.com/cecric/hexapinod" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> Hexapinod </strong> </a>的主要原因:用<strong class="jx iz">最小的引导</strong>来启动一个项目，这个项目<strong class="jx iz">包括创建一个 API </strong>的所有需求，例如 OpenAPI 规范、数据库支持、对象序列化、测试过程等通用特性</p><p id="e4f0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个项目，旨在通过支持一些</p><p id="b710" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与第三方工具的其他链接(例如 Jest 或 RabbitMQ)，但<strong class="jx iz">不会变得更复杂</strong>，也不会包含对大多数 API 项目不通用的工具。即使您不在项目中使用它，您也可以了解如何在 typescript 中概述如何启动项目，并从中获得一些灵感来构建自己的项目。</p><div class="im in gp gr io mq"><a href="https://github.com/cecric/hexapinod" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iz gy z fp mv fr fs mw fu fw ix bi translated">GitHub - cecric/hexapinod:六边形架构 API 框架/使用…</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">TypeScript 中的六边形体系结构 API 框架/骨架，并通过 expressJS 使用 nodeJS。因为我在…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne iu mq"/></div></div></a></div></div></div>    
</body>
</html>