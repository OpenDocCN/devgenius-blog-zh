<html>
<head>
<title>React Tips — Handler Arguments, Navigation, and Children</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—处理程序参数、导航和子级</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-handler-arguments-navigation-and-children-3daec4690c92?source=collection_archive---------28-----------------------#2020-07-18">https://blog.devgenius.io/react-tips-handler-arguments-navigation-and-children-3daec4690c92?source=collection_archive---------28-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e5770a3ce38a83fd48082a6cf35a5fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wtkN25Ao6WnwAXoR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@vidarnm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维达尔·诺德里-马西森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="87dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React 是一个用于创建 web 应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的 React 应用程序的技巧。</p><h1 id="4fa6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 react-router 以编程方式导航</h1><p id="9dc1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe me mf mg mh b">useHistory</code>钩子有计划地使用 React Router。</p><p id="a0b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be28" class="mq lc iq mh b gy mr ms l mt mu">import { useHistory } from "react-router-dom";</span><span id="f1cc" class="mq lc iq mh b gy mv ms l mt mu">function HomeButton() {<br/>  const history = useHistory();</span><span id="8dcb" class="mq lc iq mh b gy mv ms l mt mu">  const goHome = () =&gt; {<br/>    history.push("/home");<br/>  }</span><span id="d914" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;button type="button" onClick={goHome}&gt;<br/>      go home<br/>    &lt;/button&gt;<br/>  );<br/>}</span></pre><p id="82ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">useHistory</code>钩子来获取我们的<code class="fe me mf mg mh b">Button</code>组件中的历史对象。</p><p id="b01d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">history.push</code>导航。</p><p id="9d09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是使用历史 API 来进行导航。</p><h1 id="a66b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">循环内部反应 JSX</h1><p id="1ffc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只能在 JSX 写 JavaScript 表达式，所以我们不能用常规循环遍历所有的条目。</p><p id="6243" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确的做法是将所有的项目放入一个数组，并放入我们的 JSX。</p><p id="2ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a180" class="mq lc iq mh b gy mr ms l mt mu">let rows = [];<br/>for (let i = 0; i &lt; numRows; i++) {<br/>  rows.push(&lt;TableRow key={i} row={rows[i]} /&gt;);<br/>}<br/>return &lt;tbody&gt;{rows}&lt;/tbody&gt;;</span></pre><p id="733b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将所有的条目都推入<code class="fe me mf mg mh b">rows</code>，并将其嵌入我们的 JSX 代码中。</p><p id="660c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使它更简短，我们也可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6d5b" class="mq lc iq mh b gy mr ms l mt mu">&lt;tbody&gt;<br/>  {arr.map((a, i) =&gt; &lt;TableRow row={a} key={i} /&gt;)}<br/>&lt;/tbody&gt;</span></pre><h1 id="c48c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应中的三个点</h1><p id="b339" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在 React 中使用三个点来将对象属性扩展到道具中。</p><p id="726e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4138" class="mq lc iq mh b gy mr ms l mt mu">&lt;Modal {...this.props} title='Modal heading' animation={false}&gt;</span></pre><p id="fab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">展开<code class="fe me mf mg mh b">this.props</code>物体作为<code class="fe me mf mg mh b">Modal</code>的道具。</p><p id="8e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键是属性名，值是它们的值。</p><h1 id="f052" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把道具传给 this.props .孩子们</h1><p id="1a53" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">cloneElement</code>方法将道具传递给<code class="fe me mf mg mh b">this.props.children</code>。</p><p id="97e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="489b" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>    {React.cloneElement(this.props.children, { foo: this.state.foo })}<br/>&lt;/div&gt;</span></pre><p id="1a70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是用<code class="fe me mf mg mh b">React.cloneElement</code>方法将<code class="fe me mf mg mh b">foo</code>道具传递给<code class="fe me mf mg mh b">this.props.children</code>。</p><p id="afa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想将道具传递给多个子元素，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="42f3" class="mq lc iq mh b gy mr ms l mt mu">import React, { Children, isValidElement, cloneElement } from 'react';</span><span id="2ae5" class="mq lc iq mh b gy mv ms l mt mu">const Child = ({ foo }) =&gt; (<br/>  &lt;div&gt;{foo}&lt;/div&gt;<br/>);</span><span id="4772" class="mq lc iq mh b gy mv ms l mt mu">function Parent({ children }) {</span><span id="8111" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    const childrenWithProps = Children.map(children, child =&gt; {<br/>      if (isValidElement(child)) {<br/>        return cloneElement(child, { foo })<br/>      }<br/>      return child;<br/>    });</span><span id="210f" class="mq lc iq mh b gy mv ms l mt mu">    return &lt;div&gt;{childrenWithProps}&lt;/div&gt;<br/>  }<br/>};</span><span id="704a" class="mq lc iq mh b gy mv ms l mt mu">ReactDOM.render(<br/>  &lt;Parent&gt;<br/>    &lt;Child value="1" /&gt;<br/>    &lt;Child value="2" /&gt;<br/>  &lt;/Parent&gt;,<br/>  document.getElementById('container')<br/>);</span></pre><p id="8231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">Children.map</code>来用<code class="fe me mf mg mh b">cloneElement</code>填充道具。</p><p id="8d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们调用它之前，我们检查<code class="fe me mf mg mh b">child</code>是否是一个带有<code class="fe me mf mg mh b">isValidElement</code>的有效元素。</p><p id="99f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以将道具传递给多个元素。</p><h1 id="7873" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">强制 React 组件在不调用 setState 的情况下重新呈现</h1><p id="2a77" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">this.forceUpdate</code>来强制渲染，但是应该避免，因为我们应该使用<code class="fe me mf mg mh b">setState</code>或者状态改变函数来更新我们的组件。</p><h1 id="fb90" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Redux 中的异步流中间件</h1><p id="75d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 redux-thunk 中间件通过我们的操作运行异步代码。</p><p id="2a6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="85ea" class="mq lc iq mh b gy mr ms l mt mu">function loadUserProfile(userId) {<br/>  return dispatch =&gt; fetch(`http://example.com/${userId}`)<br/>    .then(res =&gt; res.json())<br/>    .then(<br/>      data =&gt; dispatch({<br/>        type: 'EXAMPLE_LOADED',<br/>        data<br/>      }),<br/>      err =&gt; dispatch({<br/>        type: 'EXAMPLE_LOAD_FAILED',<br/>        err<br/>      })<br/>    );<br/>}</span></pre><p id="a73e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取数据以调用调度具有给定动作类型的动作的动作。</p><p id="0985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1517" class="mq lc iq mh b gy mr ms l mt mu">&lt;div onClick={e =&gt; dispatch(actions.loadExample(123)}&gt;load&lt;/div&gt;</span></pre><p id="3db6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用 invoke 操作来运行异步代码。</p><h1 id="9247" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React 中数组子项的唯一键</h1><p id="613f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要 React 组件中数组子元素的唯一键。</p><p id="2f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为他们让 React 通过 ID 跟踪条目。</p><p id="b37b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可能会得到意想不到的结果。</p><p id="3566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">key</code>属性中为每个条目添加了一个唯一的 ID。</p><p id="1e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="10b8" class="mq lc iq mh b gy mr ms l mt mu">&lt;tbody&gt;<br/>  {rows.map((row, i) =&gt; {<br/>    return &lt;ObjectRow key={row.id} /&gt;;<br/>  })}<br/>&lt;/tbody&gt;</span></pre><p id="9f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入<code class="fe me mf mg mh b">row</code>的<code class="fe me mf mg mh b">id</code>，这是<code class="fe me mf mg mh b">key</code>道具独有的。</p><p id="c8d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个唯一的 ID 会给我们带来预期的结果，不管它在什么位置。</p><h1 id="540f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将值传递给事件处理程序方法</h1><p id="da96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用箭头函数传递一个值。</p><p id="b172" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e787" class="mq lc iq mh b gy mr ms l mt mu">&lt;button onClick={() =&gt; this.handleSort(column)}&gt;{column}&lt;/button&gt;</span></pre><p id="2716" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们直接将值传递给 arrow 函数。</p><p id="2071" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将其提取到一个子组件中。</p><p id="8fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c43" class="mq lc iq mh b gy mr ms l mt mu">class Button extends Component {<br/>  handleClick = () =&gt; {<br/>    this.props.onHeaderClick(this.props.value);<br/>  }</span><span id="05e8" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;button onClick={this.handleClick}&gt;<br/>        {this.props.column}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="c657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过道具将值传递给<code class="fe me mf mg mh b">handleClick</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5c8f50697e804b03eb4a44085ad865d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d1aBJrjwKDa4oQn5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@veverkolog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Duan Smetana</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1b4a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b554" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在 JSX 总是有表达方式。</p><p id="50e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使用<code class="fe me mf mg mh b">useHistory</code>来导航 React 路由器。</p><p id="f08e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一键应该在数组中。</p><p id="2039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过各种方式将参数传递给处理函数。</p></div></div>    
</body>
</html>