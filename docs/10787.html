<html>
<head>
<title>Rest API to upload images Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rest API 上传图片 Golang</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rest-api-to-upload-images-go-2316de61db82?source=collection_archive---------2-----------------------#2022-11-29">https://blog.devgenius.io/rest-api-to-upload-images-go-2316de61db82?source=collection_archive---------2-----------------------#2022-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d4a80feafb10652116f83a4f321af826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XD0ddTVnwI_B9QTjbKBsEA.png"/></div></div></figure><p id="6b90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将了解如何创建 rest api 来上传图像，我们还将确保我们的 api 也将处理多个图像上传，我们还将设置文件上传限制，这样就不会使我们的系统不稳定，因为长时间的文件上传会导致系统故障问题，所以最好为文件添加一个限制。 我们将确保我们只接受图像，因此我们还需要为我们的 api 添加文件类型检查，如果您希望图像和文档来自同一个 api，您可以删除类型检查过滤器，api 已准备好处理多种类型的文件。</p><p id="9c85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们的 rest api 上传图片需要遵循的步骤。</p><ul class=""><li id="1791" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">创建存储库。</li><li id="6bd8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Setup go.mod</li><li id="46fd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">创建 main.go 文件</li><li id="6585" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用 gorilla mux 包设置 http 服务器。</li><li id="bdcf" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">创建 api。</li><li id="df38" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">用 http 处理程序连接 rest api。</li><li id="1398" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">测试 api。</li></ul><p id="8d0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一步一步地创建成功的 rest api 来上传图像。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="8a59" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">1.为我们的 rest api 创建一个存储库</h1><p id="2bd0" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">首先，我们需要创建一个文件夹，在那里我们可以设置我们的代码库。</p><p id="9aab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个名为<em class="mr"> upload-images-rest-api </em>的文件夹。下面是创建目录/文件夹的命令。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="e3af" class="nb lp in mx b be nc nd l ne nf">$ mkdir upload-images-rest-api</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="99a8" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">2.Setup go.mod</h1><p id="4610" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">我们还需要在<em class="mr"> upload-images-rest-api </em>文件夹中设置 go.mod 文件，这样我们就可以将我们的代码作为一个包/模块使用，下面是生成 go.mod 文件的命令。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="8d75" class="nb lp in mx b be nc nd l ne nf">$ go mod init upload-images-rest-api</span></pre><p id="8d09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您是 go 新手，那么您可能需要首先了解 Go 打包，以理解这个命令的作用。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="ae7e" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">3.创建 main.go 文件</h1><p id="eae6" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">在你的<em class="mr"> upload-images-rest-api </em>文件夹中创建另一个名为<em class="mr"> main.go. </em>的文件</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="2c5b" class="nb lp in mx b be nc nd l ne nf">$ touch main.go</span></pre><p id="408a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经创建了我们的<em class="mr"> main.go </em>文件，现在我们可以开始开发我们的 http 服务器了。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="47f0" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">4.使用 gorilla mux 包设置 http 服务器</h1><p id="6e05" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">为了创建服务器，我们将使用<a class="ae ng" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> <em class="mr"> gorilla mux </em> </a>包，所以首先我们需要先下载包，然后我们可以开始开发。</p><p id="ac4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是下载 gorilla mux 包的命令。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="b10b" class="nb lp in mx b be nc nd l ne nf">$ go get -u github.com/gorilla/mux </span></pre><p id="5e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装 gorilla mux 后，我们可以开始开发我们的代码。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="422f" class="nh lp in bd lq ni nj dn lu nk nl dp ly kg nm nn mc kk no np mg ko nq nr mk ns bi translated">1.创建主函数。</h2><p id="5b8d" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">首先我们需要编写 Go 的锅炉板代码，下面是代码。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="f35c" class="nb lp in mx b be nc nd l ne nf">package main<br/><br/>func main() {<br/><br/>}</span></pre><p id="3dc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">截至目前，这是一个锅炉板代码，这就是为什么我们还没有任何包加载。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="2a92" class="nh lp in bd lq ni nj dn lu nk nl dp ly kg nm nn mc kk no np mg ko nq nr mk ns bi translated">2.创建 HTTP 服务器。</h2><p id="abbf" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">下面是 http 服务器的代码。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="b79f" class="nb lp in mx b be nc nd l ne nf">package main<br/><br/>import (<br/>    "log"<br/>    "net/http"<br/><br/>    "github.com/gorilla/mux"<br/>)<br/><br/>const PORT = "8080"<br/><br/>func main() {<br/>    r := mux.NewRouter()<br/>    r.HandleFunc("/ping", nil).Methods("GET")<br/>    r.HandleFunc("/upload", nil).Methods("POST")<br/><br/>    log.Printf("Server is running on http://localhost:%s", PORT)<br/>    log.Println(http.ListenAndServe(":"+PORT, r))<br/>}</span></pre><p id="fd3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们添加了希望服务器运行的端口变量<code class="fe nt nu nv mx b">8080</code>，在我们调用了<code class="fe nt nu nv mx b">gorilla mux</code>包的<code class="fe nt nu nv mx b">mux.NewRouter</code>函数的主函数中，然后我们创建了代码中提到的路由，还附加了它们的方法，正如你看到的，我们有两个 API， 第一个<code class="fe nt nu nv mx b">/ping</code>是检查我们的服务器是否运行，第二个<code class="fe nt nu nv mx b">/upload</code>是我们上传图像的主要工作，然后我们将我们的 mux 路由器传递给<code class="fe nt nu nv mx b">http.ListenAndServe</code>函数，同时传递我们希望我们的服务器运行的端口。</p><p id="6e86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您尝试运行服务器并测试任何 api，您会得到这样的错误，因为我们只是传递了路径，但对于提供的路径，没有处理程序可以读取并处理该请求。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="c184" class="nb lp in mx b be nc nd l ne nf">2022/11/27 19:16:00 http: panic serving [::1]:56663: runtime error: invalid memory address or nil pointer dereference<br/>goroutine 18 [running]:<br/>net/http.(*conn).serve.func1()<br/>        C:/Program Files/Go/src/net/http/server.go:1850 +0xbf<br/>panic({0xe08000, 0x1025de0})<br/>        C:/Program Files/Go/src/runtime/panic.go:890 +0x262<br/>net/http.HandlerFunc.ServeHTTP(0xc000148000?, {0xebd248?, 0xc0001360e0?}, 0x800?)<br/>        C:/Program Files/Go/src/net/http/server.go:2109 +0x1e<br/>github.com/gorilla/mux.(*Router).ServeHTTP(0xc000130000, {0xebd248, 0xc0001360e0}, 0xc000096100)<br/>        C:/Users/KDSINGH/go/pkg/mod/github.com/gorilla/mux@v1.8.0/mux.go:210 +0x1cf<br/>net/http.serverHandler.ServeHTTP({0xc000088120?}, {0xebd248, 0xc0001360e0}, 0xc000096100)<br/>        C:/Program Files/Go/src/net/http/server.go:2947 +0x30c<br/>net/http.(*conn).serve(0xc00009e000, {0xebd680, 0xc000073320})<br/>        C:/Program Files/Go/src/net/http/server.go:1991 +0x607<br/>created by net/http.(*Server).Serve<br/>        C:/Program Files/Go/src/net/http/server.go:3102 +0x4db</span></pre><p id="13b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，让我们为我们的<code class="fe nt nu nv mx b">/ping</code> api 创建一个 http 处理程序，它将被用作 api 心跳来检查服务器是否正在运行。</p><p id="30a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们为<code class="fe nt nu nv mx b">/ping</code>路线添加处理程序:</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="d7f5" class="nb lp in mx b be nc nd l ne nf">func Ping(w http.ResponseWriter, r *http.Request) {<br/>    answer := map[string]interface{}{<br/>        "messageType": "S",<br/>        "message":     "",<br/>        "data":        "PONG",<br/>    }<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.WriteHeader(200)<br/>    json.NewEncoder(w).Encode(answer)<br/>}</span></pre><p id="297c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们添加了<code class="fe nt nu nv mx b">Ping</code>函数来处理<code class="fe nt nu nv mx b">/ping</code>路由，在<code class="fe nt nu nv mx b">Ping</code>函数中，我们添加了响应结构<code class="fe nt nu nv mx b">map[string]interface</code>，这样我们就可以根据需要添加动态响应，我们不依赖于 struct。我们已经添加了<code class="fe nt nu nv mx b">messageType, message</code>和<code class="fe nt nu nv mx b">data</code>作为我们的响应，我们将为我们的<code class="fe nt nu nv mx b">/upload</code> api 使用相同的响应 json，预计<code class="fe nt nu nv mx b">data</code>将会转到具有多个字段的结构。</p><p id="6ae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将编写头部内容类型和 http 代码，然后进行编码，并以 json 形式直接返回我们的响应。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="de71" class="nh lp in bd lq ni nj dn lu nk nl dp ly kg nm nn mc kk no np mg ko nq nr mk ns bi translated">3.将<code class="fe nt nu nv mx b">Ping</code>功能添加到处理器中</h2><p id="c402" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">现在我们有了我们的<code class="fe nt nu nv mx b">Ping</code>函数，让我们把它添加到我们的<code class="fe nt nu nv mx b">/ping</code>处理程序中。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="a753" class="nb lp in mx b be nc nd l ne nf">r.HandleFunc("/ping", Ping).Methods("GET")</span></pre><p id="3eee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经添加了我们的<code class="fe nt nu nv mx b">Ping</code>处理程序，让我们测试 API。<br/>你可以使用 postman 或者你的浏览器来测试 api，因为 ping 不接受任何参数，所以它也可以在浏览器上测试。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="6663" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">邮递员:</strong></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/78257860d7b3f5f104e061f554e2de71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*tC5HzSTCDZEEqlpSC5q_Wg.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">ping API-邮递员</figcaption></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8de8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">浏览器:</strong></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/c0786ea45c2cbad49f6f2776942da8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fax8f1sa6pT3b3yTIrT1gA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">ping api 浏览器</figcaption></figure><p id="b14d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工作正常，现在是时候实现我们的主处理程序了。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="3dbb" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">4.创建 api 来上传图像</h1><p id="b287" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">下面是上传图像 rest api 的完整代码</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="2e53" class="nb lp in mx b be nc nd l ne nf">// handler to handle the image upload<br/>func UploadImages(w http.ResponseWriter, r *http.Request) {<br/>    // 32 MB is the default used by FormFile() function<br/>    if err := r.ParseMultipartForm(BULK_FILE_SIZE); err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/><br/>    // Get a reference to the fileHeaders.<br/>    // They are accessible only after ParseMultipartForm is called<br/>    files := r.MultipartForm.File["file"]<br/><br/>    var errNew string<br/>    var http_status int<br/><br/>    for _, fileHeader := range files {<br/>        // Open the file<br/>        file, err := fileHeader.Open()<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusInternalServerError<br/>            break<br/>        }<br/><br/>        defer file.Close()<br/><br/>        buff := make([]byte, 512)<br/>        _, err = file.Read(buff)<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusInternalServerError<br/>            break<br/>        }<br/><br/>        // checking the content type<br/>        // so we don't allow files other than images<br/>        filetype := http.DetectContentType(buff)<br/>        if filetype != "image/jpeg" &amp;&amp; filetype != "image/png" &amp;&amp; filetype != "image/jpg" {<br/>            errNew = "The provided file format is not allowed. Please upload a JPEG,JPG or PNG image"<br/>            http_status = http.StatusBadRequest<br/>            break<br/>        }<br/><br/>        _, err = file.Seek(0, io.SeekStart)<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusInternalServerError<br/>            break<br/>        }<br/><br/>        err = os.MkdirAll("./uploads", os.ModePerm)<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusInternalServerError<br/>            break<br/>        }<br/><br/>        f, err := os.Create(fmt.Sprintf("./uploads/%d%s", time.Now().UnixNano(), filepath.Ext(fileHeader.Filename)))<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusBadRequest<br/>            break<br/>        }<br/><br/>        defer f.Close()<br/><br/>        _, err = io.Copy(f, file)<br/>        if err != nil {<br/>            errNew = err.Error()<br/>            http_status = http.StatusBadRequest<br/>            break<br/>        }<br/>    }<br/>    message := "file uploaded successfully"<br/>    messageType := "S"<br/><br/>    if errNew != "" {<br/>        message = errNew<br/>        messageType = "E"<br/>    }<br/><br/>    if http_status == 0 {<br/>        http_status = http.StatusOK<br/>    }<br/><br/>    resp := map[string]interface{}{<br/>        "messageType": messageType,<br/>        "message":     message,<br/>    }<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.WriteHeader(http_status)<br/>    json.NewEncoder(w).Encode(resp)<br/>}</span></pre><p id="ec5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经添加了新的处理程序<code class="fe nt nu nv mx b">UploadImages</code>，并为我们的<code class="fe nt nu nv mx b">/upload</code>端点添加了对有限大小数据上传的检查，我们正在将<code class="fe nt nu nv mx b">BULK_FILE_SIZE</code>传递给<code class="fe nt nu nv mx b">r.ParseMultipartForm</code>函数。</p><p id="7d2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一步中，我们使用<code class="fe nt nu nv mx b">r.MultipartForm.File["file"]</code>获取所有上传的文件，它给了我们<code class="fe nt nu nv mx b">map[string][]*multipart.FileHeader</code>，我们在上面依次迭代我们的循环。</p><p id="6c29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在循环内部，我们首先使用<code class="fe nt nu nv mx b">fileHeader.Open()</code>打开文件并处理返回的信息<code class="fe nt nu nv mx b">file</code>，接下来我们使用<code class="fe nt nu nv mx b">file.Read(buff)</code>函数读取块<code class="fe nt nu nv mx b">buff := make([]byte, 512)</code>中打开的文件信息:我们将打开的<code class="fe nt nu nv mx b">file</code>传递给<code class="fe nt nu nv mx b">Read</code>方法，同时传递我们需要从打开的<code class="fe nt nu nv mx b">file</code>中读取的<code class="fe nt nu nv mx b">bytes</code>。</p><p id="a175" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从文件中读取小块后，我们传递块<code class="fe nt nu nv mx b">http.DetectContentType</code>函数，它返回文件类型，下一步我们检查文件类型，我们只接受 JPEG，JPG 和 PNG 图像。</p><p id="3a9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一步中，我们调用<code class="fe nt nu nv mx b">file.Seek(0, io.SeekStart)</code>从给定的偏移位置查找图像数据，然后我们在项目的根级别创建<code class="fe nt nu nv mx b">uploads</code>文件夹，在创建文件夹后，我们创建一个文件来保存我们打开的图像数据，接下来我们调用<code class="fe nt nu nv mx b">io.Copy(f, file)</code>并将数据<code class="fe nt nu nv mx b">file</code>传递到我们新创建的文件<code class="fe nt nu nv mx b">f</code>。</p><p id="9b63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在函数的最后，我们只是处理请求，如果函数在处理图像时有任何错误，它将返回错误，否则它将返回 json 响应类型的成功消息。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="3faf" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">5.用 http 处理程序连接 rest api</h1><p id="aa68" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">现在我们有了用于<code class="fe nt nu nv mx b">/upload</code> api 的处理程序，但是它还没有连接，所以让我们连接它，然后测试我们的代码，我们只需要将<code class="fe nt nu nv mx b">UploadImages</code>函数作为第二个参数添加到我们的<code class="fe nt nu nv mx b">/upload</code> handlefunc 中。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="0c9b" class="nb lp in mx b be nc nd l ne nf">r.HandleFunc("/upload", UploadImages).Methods("POST")</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="5c13" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">6.测试 API。</h1><p id="88f4" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">我们已经将处理器与路由器连接起来，现在是测试<code class="fe nt nu nv mx b">/upload</code>路由的时候了:</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/eba4fa3d897cb51c4c613ba62c4f832b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXN-b2CCdYN9XJHUClC5sA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">上传图像 api</figcaption></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi od"><img src="../Images/72a21d156f2d51a743c4c32df3afccea.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*bNZlTWOP7C_Klx8Uj4-RVA.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">上传的文件</figcaption></figure><p id="8f71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mr">本文原贴于</em><a class="ae ng" href="https://programmingeeksclub.com/rest-api-to-upload-image-in-golang/" rel="noopener ugc nofollow" target="_blank"><em class="mr">【programmingeeksclub.com】</em></a></p><p id="3d16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mr">我的个人博客网址:</em> <a class="ae ng" href="https://programmingeeksclub.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">编程极客俱乐部</em> </a> <br/> <em class="mr">我的脸书页面:</em> <a class="ae ng" href="https://www.facebook.com/profile.php?id=100086258693659" rel="noopener ugc nofollow" target="_blank"> <em class="mr">编程极客俱乐部</em> </a> <br/> <em class="mr">我的电报频道:</em> <a class="ae ng" href="https://t.me/dpgcl" rel="noopener ugc nofollow" target="_blank"> <em class="mr">编程极客俱乐部</em> </a> <br/> <em class="mr">我的推特账号:</em> <a class="ae ng" href="https://twitter.com/kusinghofficial" rel="noopener ugc nofollow" target="_blank"> <em class="mr">库尔迪普辛格</em> </a> <br/> <em class="mr">我的</em></p></div></div>    
</body>
</html>