<html>
<head>
<title>Exchange messages with IBM MQ using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Rust 与 IBM MQ 交换消息</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/exchange-messages-with-ibm-mq-using-rust-50984e568d76?source=collection_archive---------7-----------------------#2022-03-09">https://blog.devgenius.io/exchange-messages-with-ibm-mq-using-rust-50984e568d76?source=collection_archive---------7-----------------------#2022-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/341767947fe2608de44e3c4f4abf2d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0dkZG_HnzdwB1gJzTazyA.png"/></div></div></figure><h1 id="01de" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">简介:</h1><p id="a3fd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在本教程中，您将学习如何使用带有 Rust 的 IBM MQ Rest API 来与 IBM MQ 队列交换消息。</p><p id="a81f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">本教程使用<a class="ae lw" href="https://doc.rust-lang.org/cargo/index.html" rel="noopener ugc nofollow" target="_blank"> Cargo </a>作为 Rust 的构建系统和包管理器。Cargo 通过动态下载应用程序运行所需的依赖包，简化了 Rust 应用程序的构建。</p><p id="35ad" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">下载完依赖 Rust 包后，Cargo 会编译该包，并将编译单元存储为 Cargo“Crate”。这确保了一旦 Cargo 第一次发现了新的依赖项，相同项目的后续执行会更快，因为依赖项箱在 Cargo 的缓存存储中是可用的。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h1 id="a793" class="jv jw in bd jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks bi translated">认证警告:</h1><p id="2737" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">此示例允许使用自签名证书，允许 web 服务器提供的任何证书。参见<a class="ae lw" href="https://docs.rs/reqwest/0.11.9/reqwest/blocking/struct.ClientBuilder.html#method.danger_accept_invalid_certs" rel="noopener ugc nofollow" target="_blank">‘danger _ accept _ invalid _ certs’</a>函数的使用。</p><p id="862d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这种做法对于代码示例来说是可以接受的，但对于一般的或实际的使用来说是不可以接受的。使用无效的证书会增加攻击和病毒的可能性，同时会使您的加密和相互身份验证面临风险。</p><p id="e444" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">先决条件:</strong></p><p id="df9a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">要完成本教程，您需要以下内容:</p><p id="972c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">- <a class="ae lw" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">生锈</a></p><p id="2aad" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">- <a class="ae lw" href="https://curl.se/download.html" rel="noopener ugc nofollow" target="_blank">卷曲</a></p><p id="86cb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">- <a class="ae lw" href="https://github.com/git-guides/install-git" rel="noopener ugc nofollow" target="_blank"> Git </a></p><h1 id="d8a5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">步骤:</strong></h1><h2 id="28a2" class="mj jw in bd jx mk ml dn kb mm mn dp kf le mo mp kj li mq mr kn lm ms mt kr mu bi translated"><strong class="ak">步骤 1:设置&amp;配置您的队列管理器</strong></h2><p id="569c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们开始使用 Rust 之前，我们首先需要设置一个队列管理器。下面的链接包含了详细的操作说明。</p><p id="63bb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">本教程中的步骤 1 和 2 将帮助您设置队列管理器:<a class="ae lw" href="https://developer.ibm.com/series/mq-ready-set-connect/" rel="noopener ugc nofollow" target="_blank">https://developer.ibm.com/series/mq-ready-set-connect/</a></p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="b3eb" class="mj jw in bd jx mk ml dn kb mm mn dp kf le mo mp kj li mq mr kn lm ms mt kr mu bi translated"><strong class="ak">第二步:创造一个可靠的防锈环境</strong></h2><p id="4e48" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">一旦您的队列管理器被设置和配置好，让我们获取代码并开始使用 Rust。</p><p id="ba00" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">储存库:</strong></p><p id="9a89" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这个存储库包含 IBM MQ 的所有当前示例。通过克隆它，您将可以访问其他几种不同语言的样本，以供测试和使用。</p><p id="332f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在本教程中，我们主要关注这个库的/Rust-REST/部分。</p><p id="4c7f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">点击此链接后，点击屏幕上显示的代码按钮。在这里，您可以使用三种不同的方法克隆这个存储库。(插入截图)</p><p id="6568" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，我们将使用代码中的 HTTPS 选项卡来克隆存储库。</p><p id="875e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">打开命令行界面，导航到您的桌面，这是我们将要克隆存储库的目录。</p><p id="3b6a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">git 克隆<a class="ae lw" href="https://github.com/ibm-messaging/mq-dev-patterns.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ibm-messaging/mq-dev-patterns.git</a></p><p id="3465" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">使用 Finder 或其他文件浏览工具导航到您的 mq-dev-patterns 目录，在完成克隆后，您应该会看到类似如下的列表:</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/cfe7cb8cadc9ea5e30960d0b1ddedf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*JgrTxFqQ07chhpOLQzKncg.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">显示克隆的 GitHub 存储库</figcaption></figure><p id="2f9a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">太好了！您已经完成了将存储库克隆到桌面上的第一步。现在是时候使用前面的终端窗口导航到 Rust-REST 文件夹了。</p><p id="41e0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在终端窗口中，通过发出 cd 命令将目录更改为克隆的存储库目录。</p><p id="cdc2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">一旦进入存储库目录，在 macOS 上运行' ls '命令或在 Windows 上运行' dir ',您应该会看到如下所示的列表。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/647aa23cf4a699a1e7d2efb2aeb388de.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*_7gr0DLIkG-_TgX-xr4UCw.png"/></div></figure><p id="e06c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在开始执行一些代码之前，我们的最终任务是找到它！</p><p id="6dfc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行以下命令:</p><p id="38bd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">' cd 生锈-休息'</p><p id="b4bc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您已经成功地在桌面上为克隆的存储库创建了一个目录，并使用命令行找到了正确的示例。现在是时候运行这个文件夹中的 Rust 示例程序了。</p><p id="d3d9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> <em class="nf">认证更改为连接到一个已经存在的 IBM MQ 队列管理器:</em> </strong></p><p id="81ce" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果您想使用这个 Rust 示例连接到任何预先存在的 IBM MQ 队列管理器，首先需要做一些更改。</p><p id="0926" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Rust-REST 目录包含一个名为 envrest.json 的 JSON 文件，用于连接到您的队列管理器。其中包含 APP_USER 和 APP_PASSWORD，以及您希望示例使用的主机和端口。</p><p id="c19c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你在 IBM Cloud 上使用队列管理器，你可以在这里找到一些说明。</p><p id="0270" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><em class="nf">现在您已经准备好通过 IBM MQ REST API 发送带有 Rust 示例的 MQ 消息。</em></p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="56b0" class="mj jw in bd jx mk ml dn kb mm mn dp kf le mo mp kj li mq mr kn lm ms mt kr mu bi translated">步骤 3:理解和运行脚本文件</h2><p id="8dac" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">脚本文件将连续执行在克隆的存储库中找到的发送者和接收者示例。</p><p id="760f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">该文件本身包含以下代码:</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/43c447d1f959422dc3ea6e54eb93178b.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*RsWHQ-tK2rLaW4fPxj-how.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">RUNME.sh</figcaption></figure><p id="514a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">可以运行 RUNME.sh 来检查您的队列管理器是否成功地处理了消息。但是，您可以自己手动使用这些示例，如何使用的细节将在步骤 4 和 5 中解释。</p><p id="ce35" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">要运行脚本文件，请在克隆的存储库的 Rust-REST 部分中，在命令行界面上执行该命令。</p><p id="0cc9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Mac/Linux:</p><p id="f34f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">。/RUNME.sh</p><p id="f33c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">窗口:</p><p id="bd26" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">bash RUNME.sh</p><p id="7952" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">POST 示例将向队列管理器发送消息，而 DELETE 示例从队列管理器获取消息并使用它。</p><p id="4fe8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行这个脚本文件的结果可以在下面看到。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/827ed1549ca5906d29ee4d1e6dd6bc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*aDPIUoVrvtSskObIypX7IQ.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><em class="ni">运行 Rust_REST_POST (Post) </em></figcaption></figure><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1dd0cb047cbc03f0307be6bb7ad9e8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*hNiEy8k_oo5zBZmGGEjHmg.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><em class="ni">运行 Rust_REST_Delete(获取)</em></figcaption></figure><p id="4e9e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在成功执行两个 POST/GET 程序后，将为 POST 示例显示 HTTP 状态代码 201，为 DELETE 示例显示 200。这些是基于请求的结果。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="985e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">第四步:把你自己的信息放到你的队列中</strong></p><p id="1925" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当仍然在 Rust-REST 中时，将目录切换到 Rust-REST-Post 并发出运行程序的命令</p><p id="bdb4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Mac/Linux:</p><ul class=""><li id="0bb7" class="nj nk in kv b kw lr la ls le nl li nm lm nn lq no np nq nr bi translated">CD/防锈支架/防锈支架柱</li><li id="73e9" class="nj nk in kv b kw ns la nt le nu li nv lm nw lq no np nq nr bi translated">货物运输</li></ul><p id="1167" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">窗口:</p><ul class=""><li id="fa50" class="nj nk in kv b kw lr la ls le nl li nm lm nn lq no np nq nr bi translated">cd \锈托\锈托-柱\</li><li id="8e7d" class="nj nk in kv b kw ns la nt le nu li nv lm nw lq no np nq nr bi translated">货物运输</li></ul><p id="f4d0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在执行时，Cargo 将开始处理 Cargo.toml 文件中的所有依赖项。</p><p id="e324" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Cargo 通过访问依赖库(如 crates.io)下载运行您的程序所需的 crates 来实现这一点。您选择的依赖库存储在 Cargo 目录下的 Cargo.lock 文件中。</p><p id="44c2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第一次执行程序时，Crates.io 索引将开始更新。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/058cdaeb76ecd266ade84a86749d6c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*BMpF2Vxyv9kRq1USLkhIBw.png"/></div></div></figure><p id="5ab0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">应用程序将提示用户输入文本，如下图所示。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d77d508c79777ecbdc3a60a0ca93411c.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*kuIlv5_vJmMbtDqBMRDq2g.png"/></div></figure><p id="5d4a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">一旦板条箱被下载，程序将开始编译和运行。此后，程序将输出一个 HTTP 状态代码，显示请求的状态。对于成功的 POST 请求，返回的状态代码应该是 201。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/076c19919c65e5aa8d8c67208cc27076.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*DXkVrOmZR8qUoh_xc43-xA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">有效负载学习的 POST 请求的成功结果</figcaption></figure><p id="428f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">恭喜你！如果您返回的状态代码是 201，那么您已经成功地使用 Rust 和 Cargo 向您的队列发送了一条消息。如果没有，也不要慌。Rust 出色的错误处理会在输出控制台中通知您问题。</p><p id="5ca7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，我们将看看您是否可以通过使用 DELETE 程序从队列中获得相同的消息。</p><p id="f233" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">解题:</strong></p><p id="dd40" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行时的常见错误有:</p><p id="8d36" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">-您的容器没有运行</p><p id="b6ac" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">-不正确地修改 envrest.json 变量</p><p id="03f4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">控制台也可能返回完全不同的 HTTP 状态代码。有关如何理解和识别状态代码问题的信息，请单击<a class="ae lw" href="https://www.ibm.com/docs/en/ibm-mq/8.0?topic=transfer-http-respo%E2%80%A6" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="8f21" class="mj jw in bd jx mk ml dn kb mm mn dp kf le mo mp kj li mq mr kn lm ms mt kr mu bi translated"><strong class="ak">第五步:从队列中获取自己的消息</strong></h2><p id="f3af" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，导航到目录中的 Delete 文件夹，发出 run 命令。</p><ul class=""><li id="310b" class="nj nk in kv b kw lr la ls le nl li nm lm nn lq no np nq nr bi translated">CD MQ-开发-模式/Rust-REST/Rust-REST-删除</li><li id="9cbe" class="nj nk in kv b kw ns la nt le nu li nv lm nw lq no np nq nr bi translated">货物运输</li></ul><p id="e509" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">将打印一个状态代码，显示当前请求的状态以及响应返回的标题。对于 GET 请求，消息体将打印在“返回的数据”部分。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fa47f1d759bf216ba66992a152611244.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*i6oBTEqT60YK5PjzB9xCqA.png"/></div></figure><p id="7c4a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您已经成功地获得了使用 Rust 通过 IBM MQ REST API 发送和接收消息的示例。恭喜你！</p><p id="a363" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">总结和后续步骤:</strong></p><p id="3044" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在本教程中，您使用了一个脚本文件来初步运行程序、特性和功能，并通过自己运行程序、在队列管理器中输入和检索您自己的有效负载，采取了一种更实际的方法。</p><p id="b0d9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在您应该明白在 MQ 中使用 Rust 需要采取什么步骤。使用这里学到的知识，您可以在您的克隆存储库中使用我们的其他语言样本，在您的队列管理器中实现相同的结果。</p><p id="d930" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为什么不看看我们使用 IBM MQ API 的其他语言示例呢，它们可以在同一个存储库中找到。</p></div></div>    
</body>
</html>