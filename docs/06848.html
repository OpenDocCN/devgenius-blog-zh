<html>
<head>
<title>The first principles of any DFS algorithms.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">任何 DFS 算法的首要原则。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-first-principles-of-any-dfs-algorithms-232610953ce6?source=collection_archive---------16-----------------------#2022-02-07">https://blog.devgenius.io/the-first-principles-of-any-dfs-algorithms-232610953ce6?source=collection_archive---------16-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ebc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用迭代和递归来实现 DFS 算法面试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/609070a77f06e065dc5fb5532c07a424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrSXt45rlyBmfzCawpS8XQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="069f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">说到编码，我喜欢寻找模式。<strong class="kx ir">模式揭示第一原则，从第一原则思考任何问题都会更清晰。</strong></p><p id="d200" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一些在编码面试中经常出现的首要原则。</p><ol class=""><li id="ba1b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae ma" href="https://www.ocf.berkeley.edu/~shidi/cs61a/wiki/Iteration_vs._recursion" rel="noopener ugc nofollow" target="_blank">递归可以转化为迭代(反之亦然)</a>。</li><li id="4108" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">递归类似于深度优先搜索(DFS)。</li><li id="5c90" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">对于迭代方法，DFS 使用堆栈和 while 循环。旁注，DFS 的堂兄，BFS，使用队列和 while 循环。</li><li id="d828" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">如果你看到一个采用嵌套数据结构的算法问题，你可能需要 DFS。</li></ol><p id="0402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这些首要原则出发，许多 DFS 练习变得直观且易于理解。</p><p id="0cd2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我用一些例子向你展示我的思考过程。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c5fe" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">例 1:“把狗放出来！”</h1><p id="8bff" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">让我们写我们的算法把狗放出来！这相当于展平嵌套数组。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="1e79" class="np mo iq nl b gy nq nr l ns nt">Input: [["corgi", "husky"], [["pug","shiba inu",["labrador"]]]]<br/>Output: ["corgi", "husky", "pug", "shiba inu", "labrador"]</span></pre><p id="a2a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为这是 DFS 的问题，因为我们试图搜索数组中的数组，直到找到叶子，即一个非数组项(本例中为整数)。</p><p id="4b76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于 DFS，我发现递归比迭代更容易理解，但是迭代更容易解释。因此，让我从迭代开始，然后递归会变得非常直观。</p><p id="06ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="nu">第一原理:DFS 使用堆栈和 while 循环。</em>T15】</strong></p><p id="d73f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于迭代方法，算法的主干应该具有以下结构:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="49cd" class="np mo iq nl b gy nq nr l ns nt">function flattenIterative(arr) {<br/>  const items = [];<br/>  const stack = [];<br/>  while (stack.length &gt; 0) {<br/>    const currentEl = stack.pop();</span><span id="b6a7" class="np mo iq nl b gy nv nr l ns nt">  }<br/>  return items;<br/>}</span></pre><p id="86c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用堆栈来跟踪元素，在 while 循环中，我们需要向<code class="fe nw nx ny nl b">items</code>添加元素。</p><p id="36f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">返回的<code class="fe nw nx ny nl b">items</code>是我们展平的数组。</p><p id="abb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，这个主干功能还不做任何事情。现在，下一个问题是:</p><ol class=""><li id="9a00" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">堆栈最初应该是什么样子？</li><li id="7b72" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">何时添加到堆栈？</li><li id="9e3f" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">何时添加到项目？</li></ol><p id="950d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一个问题很简单。如果<code class="fe nw nx ny nl b">currentEl</code>不是一个数组，我们可以把它添加到<code class="fe nw nx ny nl b">items</code>列表中。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="5cea" class="np mo iq nl b gy nq nr l ns nt">function flattenIterative(arr) {<br/>  const items = [];<br/>  const stack = [];<br/>  while (stack.length &gt; 0) {<br/>    const currentEl = stack.pop();</span><span id="258a" class="np mo iq nl b gy nv nr l ns nt">    // if the currentEl is not an array, add it to the items list<br/>    if (!Array.isArray(currentEl)) {<br/>      items.push(currentEl);</span><span id="7158" class="np mo iq nl b gy nv nr l ns nt">    }<br/>  }<br/>  return items;<br/>}</span></pre><p id="8cdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个问题也很简单。假设输入只是一个普通的、非嵌套的 1D 数组。在 while 循环中，我们需要弹出堆栈并将元素添加到<code class="fe nw nx ny nl b">items</code>列表中。因此，算法工作的唯一方式是堆栈是输入数组本身的副本！</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="7d84" class="np mo iq nl b gy nq nr l ns nt">function flattenIterative(arr) {<br/>  const items = [];<br/>  const stack = [...arr];<br/>  while (stack.length &gt; 0) {<br/>    const currentEl = stack.pop();</span><span id="0e2f" class="np mo iq nl b gy nv nr l ns nt">    // if the currentEl is not an array, add it to the items list<br/>    if (!Array.isArray(currentEl)) {<br/>      items.push(currentEl);</span><span id="2aa7" class="np mo iq nl b gy nv nr l ns nt">    }<br/>  }<br/>  return items;<br/>}</span></pre><p id="529d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，第二个问题也变得简单明了。如果<code class="fe nw nx ny nl b">currentEl</code>是一个数组，我们需要将<code class="fe nw nx ny nl b">currentEl</code>中的每个元素添加到堆栈中，这样它们就可以在后面的迭代中添加到<code class="fe nw nx ny nl b">items</code>中。</p><p id="d665" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终的迭代算法如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a446" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只剩下一个问题了。这种算法会展平，但会反转输入的顺序。这是因为我们从输入的后面弹出，但是推到了<code class="fe nw nx ny nl b">items</code>。因此，要解决这个问题，我们可以将<strong class="kx ir">从</strong>列表中移除。</p><p id="295e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是 DFS 迭代方法的总结。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/fe877c518f7c0368924fac62cdb68500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0da6LeALGDLjraGYsKFCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="9642" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们继续讨论递归。</p><p id="187b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归的原理很简单:</p><p id="1015" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们遍历输入数组中的每个元素，如果当前元素不是一个数组，我们将它添加到<code class="fe nw nx ny nl b">items</code>列表中。如果它是一个数组，我们用当前元素中的每一项来调用函数本身。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7986" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个算法中，当你用一个内部数组元素调用<code class="fe nw nx ny nl b">flattenRecursive</code>时，最终，<code class="fe nw nx ny nl b">Array.isArray(item)</code>将为假，所以它被添加到<code class="fe nw nx ny nl b">items</code>列表中。</p><p id="f623" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归的工作方式类似于迭代，但是递归使用调用堆栈本身，而不是手动管理“堆栈”。</p><h1 id="4501" class="mn mo iq bd mp mq oc ms mt mu od mw mx jw oe jx mz jz of ka nb kc og kd nd ne bi translated">示例 2:解析嵌套的 DOM 树。</h1><p id="1037" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">DFS 通常用在树和图的上下文中。所以让我们看另一个例子，我们使用 DFS 来解析 DOM 树。</p><p id="aa42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们给定了两个结构相同的 DOM 树(树 A 和树 B ),以及树 A 中的一个目标节点。我们希望在树 B 中找到相应的目标节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/2e6692c134ca56116bd522a9098c37b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-80UcyI-_zbySicRVSq3ng.png"/></div></div></figure><p id="4b09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">策略是找到从 rootA 到 targetA 的“路径”。然后我们走同样的路到达我们的目标 b。为了找到这条路径，我们需要做 DFS。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6e6e" class="np mo iq nl b gy nq nr l ns nt">function findCorrespondingNode(rootA, rootB, targetA) {<br/>   if (!targetA || !rootA || !rootB) return null;</span><span id="7a6e" class="np mo iq nl b gy nv nr l ns nt">   const childrenIndices = findPath(rootA, targetA);<br/>    <br/>   let currentNode = rootB;<br/>  <br/>   childrenIndices.forEach((idx) =&gt; {<br/>      const children = Array.prototype.slice.call(currentNode.children);</span><span id="5f71" class="np mo iq nl b gy nv nr l ns nt">      currentNode = children[idx];<br/>   });<br/>  <br/>   return currentNode;<br/>}</span></pre><p id="0e92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的路径基本上是一个子索引列表，它将我们从根索引引导到目标索引。所以在上面的 html 结构中，我们的目标<code class="fe nw nx ny nl b">&lt;p id="targetB"&gt;</code>是<code class="fe nw nx ny nl b">rootB</code>的第二个子节点(索引 1)的第一个子节点(索引 0)。因此路径是[1，0]。</p><p id="02ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了找到路径，我们可以使用迭代或递归。这个稍微复杂一点的例子的基本前提与我们的数组展平练习相同。</p><p id="8838" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在下面的 Github 要点中找到这两种方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a858" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在迭代方法中，我们使用堆栈来跟踪我们的路径。一旦我们找到正确的路径，我们就返回。在递归方法中，我们用每个子节点调用函数本身，传递路径。一旦我们找到目标，我们返回路径。</p><h1 id="8191" class="mn mo iq bd mp mq oc ms mt mu od mw mx jw oe jx mz jz of ka nb kc og kd nd ne bi translated">迭代与递归的利弊</h1><p id="598e" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">递归需要更多的内存，因为每个递归函数调用都必须存储在调用堆栈中。这也会导致堆栈溢出的问题。</p><p id="ebf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的理念是迭代应该是生产环境中的首选，尤其是当应用程序的性能是一个关注点时。</p><p id="a56a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查看这篇文章，了解更多关于递归利弊的细节:<a class="ae ma" href="https://medium.com/@williambdale/recursion-the-pros-and-cons-76d32d75973a" rel="noopener">https://medium . com/@ William dale/recursion-the-pros-and-cons-76d 32d 75973 a</a></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="5b5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你遇到一个新的挑战，或者一个需要解决的复杂问题时，从基本原则开始总是一个好主意。就 DFS 而言，首要原则很简单:使用堆栈和 while 循环进行迭代。在递归中用“内部”元素调用函数本身。</p></div></div>    
</body>
</html>