<html>
<head>
<title>Cracking the Heap Algorithms in the FAANG Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解 FAANG 访谈中的堆算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-methodology-to-ace-the-heap-algorithms-question-c7063b2ba7fd?source=collection_archive---------0-----------------------#2020-08-12">https://blog.devgenius.io/a-methodology-to-ace-the-heap-algorithms-question-c7063b2ba7fd?source=collection_archive---------0-----------------------#2020-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5598" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过方法、示例问题和解决方案…..</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4e0de789d06ddb318599707db4b01ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SuOw8C9_DNakq9h2"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d6d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 FAANG 公司面试中，应聘者总是会遇到一大堆问题。他们确实喜欢问一个问题——Top k。因为这些公司有一个庞大的数据集，他们不可能总是检查所有的数据。寻找 tope 数据总是一个好的选择。在这篇文章中，我想分享我处理堆面试问题的方法。另外，我将分享 2 个典型的堆算法问题——前 K 个频繁，合并 K 个数组。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f5d0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是堆？</h1><p id="c7c4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">堆是一个完整的树状数据结构。它有一个父节点、左子节点和右子节点。对于面试来说，最小堆和最大堆是很常见的。</p><p id="9e0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Max-Heap </strong>:在 Max-Heap 中，父节点上的值必须是所有子节点上的值中最大的。</p><p id="629e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Min-Heap :在 Min-Heap 中，父节点上的值必须是所有子节点上的值中最小的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a143" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">堆积方法学</h1><p id="f673" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是帮助思考解决方案的方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/f8a121fed18ef939e9e9f4715b236550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRTRDkYKSbxUyX62mcm2Ww.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="mx">作者图片</em></figcaption></figure><p id="8d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大多数流行的数据结构问题。这个特性是共同的:我们必须做类似排序的步骤。我们可以对所有元素排序:heapsort。我们可以只对几个元素进行排序:top-k。这些元素应该是可比较的。否则，我们可能不得不将一些可比较的值与元素一起推出。</p><p id="11e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Push </strong>:我们推送一些类似 int 的元素。有时我不得不推一个可比的物体。无论我们推动什么，我们都是为了比较和健康。</p><p id="a913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Heapify </strong> : Heapify 是通过将二叉树中的节点重新排列成最大堆或最小堆，将二叉树转换成堆数据结构的过程。</p><p id="a354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万一你的面试问题之一是实现 heapify，这里我附上代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c0b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们必须将节点推到堆中。因为堆的表示是一个数组。它将新节点附加到末尾，并将其堆化。下面是最大堆的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每次插入，堆化节点需要 O (log K)时间，K 是堆的大小。</p><p id="1d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Pop </strong>:现在是时候得到我们想要的了。这里我们有两种情况:</p><ul class=""><li id="b062" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">我们使用堆根上的值。如果需要的话，我们可以使用<strong class="ky ir"> heap[0] </strong>来检查最上面的一个，如果我们在问题中有一些额外的条件。在我们得到值之后，我们可以把它放在一个数组中，或者按照问题的要求做额外的工作。</li><li id="6626" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">在其他情况下，我们需要堆中的其余值。我们可以遍历堆并返回它。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="17de" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">练习</h1><p id="52d7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这里我用 python 提供解决方案。对于大多数算法问题，它不仅仅是一个解。最好给出不同的解决方案，分析时间/空间复杂性，然后选择最佳方案。</p><p id="614f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 python 中，我们有<a class="ae kv" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank"> heapq </a>库来帮助我们正确地操作堆。它有<em class="no">n 最大的</em>和<em class="no">n 最小的</em>，我们可以用一行代码解决 top-k 类型的问题。但是，为了确保您能够更好地理解 Heap，让我们一步步来。</p><h2 id="8ab8" class="np ma iq bd mb nq nr dn mf ns nt dp mj lf nu nv ml lj nw nx mn ln ny nz mp oa bi translated">前 K 名频繁</h2><p id="e544" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面是 leetcode 上的参考<a class="ae kv" href="https://leetcode.com/problems/top-k-frequent-elements/" rel="noopener ugc nofollow" target="_blank">题</a>。我们只需找到数组中前 K 个频繁值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="05fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是代码中的步骤:</p><ul class=""><li id="9805" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">将数组转换为一个新数组，其中的元素是一个具有值和频率的元组。</li><li id="7725" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">将元组元素推到 k 大小的堆中。每当有新节点被推入时，堆就自动堆积。</li><li id="c9f2" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">在我们遍历完堆中的所有元素后，我们循环堆的其余部分来找到我们的目标值。</li></ul><p id="8416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在推一个物体，你必须确保这个物体是可比较的。如果你推一个 tuple，堆比较第一个元素，同时做 heapify <em class="no">，</em>如果发生 ties，它将比较下一个值<em class="no">。</em></p><h2 id="b12c" class="np ma iq bd mb nq nr dn mf ns nt dp mj lf nu nv ml lj nw nx mn ln ny nz mp oa bi translated">合并 K 个数组</h2><p id="630b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面是 leetcode 上的参考<a class="ae kv" href="https://leetcode.com/problems/merge-k-sorted-lists/" rel="noopener ugc nofollow" target="_blank">问题</a>。我们必须合并 k 个排序链表，并将其作为一个排序链表返回。下面是使用堆的解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是代码中的步骤:</p><ul class=""><li id="3ed1" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">我们用列表中每个 ListNode 的第一个节点及其值构建一个数组。然后我们把它堆成一个小堆。</li><li id="ad67" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">我们使用堆中的 peek 节点来构建输出 ListNode。</li><li id="a118" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">如果节点没有结束，我们使用 heapreplace，这意味着我们从<em class="no">堆</em>中弹出并返回最小的项目，并且也推送新的<em class="no">项目</em>。</li></ul><p id="df08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我想用优先级队列来解释这个问题的另一个解决方案。</p><p id="7ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优先级队列是抽象的数据结构，其中队列中的每个数据/值都有特定的优先级。<br/>优先级队列是队列的扩展，具有以下属性。<br/> 1、优先级高的元素在优先级低的元素之前出队。<br/> 2、如果两个元素具有相同的优先级，则按照它们在队列中的顺序被服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是代码中的步骤:</p><ul class=""><li id="e0c6" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">从列表中的每个元素中，我们在 ListNode 中找到第一个节点及其值，将其放入优先级队列。我们需要节点值，因为我们需要它在优先级队列中进行比较。</li><li id="7814" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">然后，我们从优先级队列中获取元素(具有最小值的元素)，将其链接到输出 ListNode。</li><li id="c889" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">我们将节点移动到下一个，如果它存在，我们将它放入优先级队列。在所有这些步骤之后，我们返回输出 ListNode，它是 head.next。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="96e2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的话</h1><p id="9f9c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">读完这篇文章后，您可能会认为使用这种方法堆并没有您想象的那么难。然而，我们可能有其他的数据结构，比如 LinkedList。因此，我们仍然需要用您喜欢的语言练习和掌握基本的数据结构 API。</p><p id="030a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你能从这篇文章中学到一些东西。如果你有兴趣阅读我的其他文章，欢迎查看我的个人资料。祝你求职顺利！</p></div></div>    
</body>
</html>