<html>
<head>
<title>The Zen of grinding LeetCode problems: Day 15–Doing math</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">研磨 LeetCode 问题的禅:第 15 天-做数学</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-zen-of-grinding-leetcode-problems-day-15-doing-math-8094400c137b?source=collection_archive---------10-----------------------#2022-06-20">https://blog.devgenius.io/the-zen-of-grinding-leetcode-problems-day-15-doing-math-8094400c137b?source=collection_archive---------10-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好，我看到你又回来了更多的<a class="ae ki" href="https://medium.com/@matei.danut.dm/the-zen-of-grinding-leetcode-problems-day-0-motivation-681842565166" rel="noopener"> <strong class="jm io"> LeetCode 日常练习系列</strong> </a> <strong class="jm io">。</strong>今天我做了<strong class="jm io"> 2 道中等</strong>题，在<strong class="jm io">总共 10 行代码下</strong>。<br/>什么给了？让我们来了解一下！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f358b6c298461b2c62d6af0ab8e9dfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pknlHfAi_H01XHhQ"/></div></div></figure><h1 id="bd5e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">孤独寂寞的数字</h1><div class="lt lu gp gr lv lw"><a href="https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd io gy z fp mb fr fs mc fu fw im bi translated">查找数组中所有的孤立数字- LeetCode</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">给你一个整数数组 nums。当一个数 x 只出现一次，并且没有相邻的数(即 x +…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">leetcode.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kt lw"/></div></div></a></div><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a800" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">见解</strong>:</p><ul class=""><li id="fd66" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">这是一个令人惊讶的简单问题，你所要做的就是按照描述中的说明去做，你就完成了，<em class="mw">不需要优化</em></li><li id="554d" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">为了谨慎起见，我使用了一个<strong class="jm io">集合</strong>来代替原来的<em class="mw"> nums </em> <strong class="jm io"> list </strong>，以降低从<strong class="jm io"> O(n) </strong>到<strong class="jm io"> O(1) </strong>的<em class="mw">搜索操作</em>(即使用关键字中的<strong class="jm io">)的复杂度。</strong></li></ul><h1 id="5477" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">我们用数学解决的问题</h1><div class="lt lu gp gr lv lw"><a href="https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd io gy z fp mb fr fs mc fu fw im bi translated">有两个蛋和 N 层的蛋蛋- LeetCode</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">给你两个相同的鸡蛋，你可以进入一个有 n 层楼的建筑，从 1 到 n。你知道…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">leetcode.com</p></div></div><div class="mf l"><div class="nc l mh mi mj mf mk kt lw"/></div></div></a></div><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">见解</strong>:</p><ul class=""><li id="9fb3" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">这一次，只是阅读我的解决方案将<em class="mw">不会帮助你太多</em>。对于这样的数学问题，不仅需要<strong class="jm io">的解释</strong>，还需要<strong class="jm io">的思维过程</strong>引导你去解决它</li><li id="2870" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">必要的投掷总数为:<br/>number =<em class="mw">number _ of _ intact _ drops</em>+<em class="mw">(broken _ floor—prev _ floor)</em></li><li id="d2c5" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io">完整滴数</strong>是解决方案的第一部分。每次你扔出第一个鸡蛋而它没有打破，你就可以想上多少层楼就上多少层。显然，上去太慢有它的缺点，想象一下，如果你一层一层地上去，鸡蛋在最后一层上破了！</li><li id="15ad" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io">(broken _ floor—prev _ floor)</strong>是解决方案的第二部分。一旦你的第一个鸡蛋在特定的楼层被打破，你别无选择，只能一层一层地爬上去。这种情况最糟糕的情况是第二层楼板在<strong class="jm io"> (broken_floor — 1) </strong>楼板上断裂。</li><li id="29b0" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">让我们想一想，当我们有两个鸡蛋的时候，我们要上几层楼。如果我们总是增加相同的数量，我们就没有真正正确地分配可用的操作数量。例如，如果我们有 100 层，我们向上 10 乘 10，如果鸡蛋在 10 层打破，我们还有 9 层要检查，总共有 10 个操作。如果它在 100 层坏了，我们还有 9 个要检查，总共 19 个操作！</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8bbda6ca3edf57e6a037d29bd009e401.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/0*gHttA4PRPeaCJJDd"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">这里有一个可爱的杰尼龟能走到这一步</figcaption></figure><ul class=""><li id="c2ed" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">这让我们想到了解决方案背后的<strong class="jm io">关键思想:我们应该在开始时跳得更多，在接近结尾时跳得更少。因为每次跳跃都算作一次操作，我们可以<strong class="jm io">通过总是比上次少跳 1 层来补偿</strong></strong></li><li id="1d8b" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">假设在<em class="mw">最坏情况</em>中，我们必须在打破第一个鸡蛋之前进行<strong class="jm io"> d </strong>跳跃，我们从大小为<strong class="jm io">k</strong>的跳跃开始，然后，我们应该能够使用像这样越来越小的跳跃爬上整个建筑:</li><li id="7e08" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io">k+(k-1)+(k-2)+…+(k-d+1)≥n</strong></li><li id="4ffe" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">我们有≥因为我们最终可能会<em class="mw">越过</em>建筑一点</li><li id="47bf" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">该等式相当于:</li><li id="acbe" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io"> d * k — (d * (d-1)) / 2 ≥ n </strong></li><li id="6681" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">哪个是</li><li id="d8f0" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io"> d * (2*k — d + 1) ≥ 2n </strong></li><li id="dad0" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">如果参照我们之前的公式，<strong class="jm io"> d </strong>是<strong class="jm io">完好数下降数</strong>，而<strong class="jm io"> k </strong>是<strong class="jm io">(破损数—预防数)</strong>。为了获得整体最小的运算次数，我们必须确保 d 和 k 是平衡的，所以我们将认为它们相等。</li><li id="e0b8" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">因此，我们有</li><li id="74e1" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io"> d * (2 * d — d + 1) ≥ 2n </strong></li><li id="1cef" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><strong class="jm io"> d * (d + 1) ≥ 2n </strong></li><li id="7cf2" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">此时，解(因为 k 和 d 相等)是前一个等式适用的<em class="mw">最小的 d</em>。</li><li id="035e" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">所以它要么是 int(sqrt(2n))要么是它上面的下一个整数。</li></ul></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="8f46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结束语:</p><ul class=""><li id="6f46" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">我不打算撒谎，我并不是第一次看问题就自己想出了解决办法。</li><li id="dea1" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">事实上，有人不得不<strong class="jm io">向我解释</strong>，然后一段时间过去了，然后我不得不<strong class="jm io">再次理解它</strong>，然后过了一段时间我试图<strong class="jm io">开发我自己的解决方案</strong>，最后我明白了</li><li id="ccee" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">但这并不意味着我<em class="mw">这次记住了它</em>。我对采取什么样的<strong class="jm io">方向</strong>有一些模糊的想法，但是在纸上得到实际的<em class="mw">数学公式</em>需要一点时间。</li><li id="f32b" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">在这种情况下，人们可能会怀疑我是否真的<strong class="jm io">掌握了</strong>解决方案，或者我只是<strong class="jm io">模糊地回忆起</strong>它。或者作为一个更普遍的问题，<strong class="jm io">阅读大量 LeetCode 问题的解决方案</strong>与<strong class="jm io">亲自实施它们</strong>之间会有什么不同？</li><li id="6b74" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">嗯，<em class="mw">首先是</em>，如果你<strong class="jm io">只是读而不写一行</strong>，你<strong class="jm io">将不会有肌肉记忆</strong>成为一个快速编码者。当我试图学习像<strong class="jm io"> K8S </strong>或<strong class="jm io"> AWS CLI </strong>或<strong class="jm io"> ArgoCD </strong>这样的基于 CLI 的工具时，我经常看到这种情况。我会阅读大量的教程和视频，我理解概念，但是我会努力记住语法。</li><li id="384a" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">这表明你缺乏经验，不管你有多快找到解决方案。面试官会希望<strong class="jm io">看到你编码</strong>，所以弄清楚算法只是第一步。</li><li id="58c5" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated"><em class="mw">其次是</em>，这是更微妙的方式，如果你总是<strong class="jm io">阅读解决方案</strong>，然后<strong class="jm io">休息一下</strong>，然后<strong class="jm io">实施你所记得的</strong>那还是<strong class="jm io"> <em class="mw">而不是</em> </strong>。</li><li id="1083" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">如果你总是<strong class="jm io">就你熟悉的</strong>问题接受采访，这种方法很管用，但是在一个完全<strong class="jm io">新的</strong> <strong class="jm io">场景</strong>，<strong class="jm io">中，你会惊慌失措</strong>。</li><li id="b103" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">那是因为你没有<strong class="jm io">的信心</strong>到<em class="mw">知道你可以从零开始，建立一个粗略的解决方案，然后改进它</em>。</li><li id="85c1" class="mn mo in jm b jn mx jr my jv mz jz na kd nb kh ms mt mu mv bi translated">所以我给你的建议是，在阅读任何东西之前，先试着自己解决问题。然后，当你对结果感到<em class="mw">满意的时候，一定要<strong class="jm io">好好读一读，看看有没有一种方法可以改进</strong>你甚至都没有想到。</em></li></ul></div></div>    
</body>
</html>