<html>
<head>
<title>A brief introduction to Action Cable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动作索简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-brief-introduction-to-action-cable-cfc230c33367?source=collection_archive---------19-----------------------#2020-06-17">https://blog.devgenius.io/a-brief-introduction-to-action-cable-cfc230c33367?source=collection_archive---------19-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="247b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着网站开始变得越来越复杂，用户交互的需求也越来越大，网络早期的问题之一就是它的单向性。用户能够检索信息，但发送消息，更不用说实时交互了，是一个非常困难的挑战。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a4ff1a0a46ea6fceff80923c0afe2416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_UnR2LT3dN0c7B58Fm2mw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">信用:<a class="ae lb" href="https://sulmanweb.com" rel="noopener ugc nofollow" target="_blank">sulmanweb.com</a></figcaption></figure><p id="afd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早期的web以java小应用程序的形式实现了一些解决方案，这些小应用程序是在网页内运行的完整程序，但是它们也很慢并且需要大量资源。然后通过javascript进行轮询，每隔几秒钟就向服务器请求任何变化，并相应地刷新，但不切实际的是相同的。在websockets出现之前，业界使用了一些解决方案，如DHTML、微软的XMLHTTP(XMLHttpRequest的基础)和ajax，都取得了不同程度的成功。</p><h1 id="7c32" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是websockets？</h1><p id="63da" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Websockets是一种位于TCP/IP之上的协议，允许单个全双工连接。这意味着，与regulat HTTP不同，在regulat HTTP中，客户端请求，服务器提供并关闭连接，使用websockets，我们可以随时打开连接，等待来自任何一方的请求或响应，而不必进行昂贵的页面重新加载或诉诸怪异的技巧来呈现数据。</p><h1 id="a2b5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我们能用websockets做什么？</h1><p id="f9d3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">几乎任何涉及改变页面上已经呈现的内容的事情。金融行情、消息通知、在线聊天、体育比赛结果，应有尽有！</p><h1 id="b006" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">酷，我如何在Rails中使用它？</h1><p id="ecdb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">幸运的是，我们在Rails中使用Websockets所需要的一切都是现成的，并且非常容易设置。首先，我们有一个数据存储，在我们的例子中是<a class="ae lb" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>，它将充当发送和接收消息的服务器。然后我们有一系列的<strong class="jp ir">频道</strong>，我们的用户<strong class="jp ir">订阅</strong>。这些订阅是实际的websockets。值得注意的是，除了初始设置之外，我们不会直接与Redis交互，因为Rails会处理所有的事情。我们开始吧！</p><h2 id="203c" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">初始设置</h2><p id="6598" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先我们需要安装Redis。发出<code class="fe mr ms mt mu b">brew install redis</code>就可以通过Homebrew安装在Mac上。如果你在Arch Linux上，你可以运行<code class="fe mr ms mt mu b">sudo pacman -Syu redis</code>，如果你在Ubuntu上，你可以运行<code class="fe mr ms mt mu b">sudo apt install redis-server</code>。Windows用户可以用一个<a class="ae lb" href="https://github.com/dmajkic/redis/downloads" rel="noopener ugc nofollow" target="_blank">非常过时的端口</a>或者<a class="ae lb" href="https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100" rel="noopener ugc nofollow" target="_blank">微软自己的spin </a>试试运气，这也是过时的，所以我会建议运行WSL，为Ubuntu安装。安装Redis后，您可以保留所有的默认值，但是如果您想看一看或者改变一些东西，请登录<code class="fe mr ms mt mu b">/etc/redis.conf</code>。</p><p id="d17d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建一个新的Rails应用程序，启动我们的代码编辑器，检查<code class="fe mr ms mt mu b">./config/cable.yml</code>，并更改<code class="fe mr ms mt mu b">adapter</code>和<code class="fe mr ms mt mu b">url</code>的开发值:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="f53c" class="mf ld iq mu b gy mz na l nb nc">development:<br/>  adapter: redis<br/>    url: redis://localhost:6379/1</span></pre><p id="854f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要生成一个通道，所以键入<code class="fe mr ms mt mu b">rails g channel general</code>。这将创建一些文件，但我们感兴趣的是:</p><ul class=""><li id="1280" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated"><code class="fe mr ms mt mu b">./app/channels/general_channel.rb</code>:这个文件告诉Rails当用户订阅和取消订阅一个频道时该做什么。</li><li id="f686" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">这是我们将要定义通道前端逻辑的地方。如果你想测试你的设置，你可以在<code class="fe mr ms mt mu b">connected()</code>方法中<code class="fe mr ms mt mu b">console.log</code>一个消息。请注意，直到下一步它才会起作用，但是当您打开一个页面时，它应该会立即显示出来。</li></ul><p id="17e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成设置，我们转到<code class="fe mr ms mt mu b">./app/channels/general_channel.rb</code>并将<code class="fe mr ms mt mu b">subscribed</code>方法改为包含<code class="fe mr ms mt mu b">stream_from "general_channel"</code>。这样，我们的聊天就设置好了，现在只需要将所有东西连接在一起。</p><p id="84a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是我们的路线，我们只需要其中的三条:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="b2ba" class="mf ld iq mu b gy mz na l nb nc">get '/', to: 'chat#index'<br/>  post '/messages', to: 'chat#create'<br/>  get '/messages/new', to: 'chat#new'</span></pre><p id="785e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要一种方法来保存我们的消息，因此键入<code class="fe mr ms mt mu b">rails g model Message content:text</code>我们还需要一个用于我们的动作的控制器，因此键入<code class="fe mr ms mt mu b">rails g controller chat</code>并在其中定义以下方法:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="3e15" class="mf ld iq mu b gy mz na l nb nc">def index<br/>        @messages = Message.all<br/>        @message = Message.new<br/>    end</span><span id="2434" class="mf ld iq mu b gy nr na l nb nc">    def show<br/>        @messages = Message.all<br/>    end</span><span id="b4ae" class="mf ld iq mu b gy nr na l nb nc">    def create<br/>        @message = Message.create(msg_params)<br/>        if @message.save<br/>            ActionCable.server.broadcast "general_channel", content: @message.content<br/>        end<br/>    end</span><span id="d910" class="mf ld iq mu b gy nr na l nb nc">    def new<br/>        @message = Message.new<br/>    end</span><span id="8a68" class="mf ld iq mu b gy nr na l nb nc">    private  def msg_params<br/>        params.require(:message).permit(:content)<br/>    end</span></pre><p id="e5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了我们的create方法之外，这里没有什么新东西。第一部分创建一条新消息，如果保存了该消息，则触发第二部分，即向<code class="fe mr ms mt mu b">general</code>频道广播消息正文。</p><p id="c2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要一个视图来使用我们的新超能力，所以去<code class="fe mr ms mt mu b">./views/chat</code>创建一个新的<code class="fe mr ms mt mu b">index.html.erb</code>。在内部，我们将构建一个简单的表单:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="88bc" class="mf ld iq mu b gy mz na l nb nc">&lt;h1&gt;Chat&lt;/h1&gt;</span><span id="27f6" class="mf ld iq mu b gy nr na l nb nc">&lt;div id="chat-container"&gt;<br/>&lt;ul id="message-list"&gt;<br/>&lt;% @messages.each do |message| %&gt;<br/>    &lt;li&gt;&lt;%= message.content %&gt;&lt;/li&gt;<br/>&lt;% end %&gt;<br/>&lt;/ul&gt;<br/>&lt;/div&gt;<br/>&lt;hr&gt;<br/>&lt;%= form_with model: @message, html: {class: "message-form"} do |f| %&gt;<br/>&lt;%= f.text_field :content, class:'message-input' %&gt;<br/>&lt;%= f.submit "Send message!", class: "send-button" %&gt;<br/>&lt;% end %&gt;</span></pre><p id="e940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你发送一条信息，什么也不会发生。我知道你很兴奋，但是你发的任何东西都被保存到数据库里了！如果你刷新页面，你可以看到你的消息，所以我们现在需要做的就是更新我们在<code class="fe mr ms mt mu b">./app/javascript/general_channel.js</code>的dom:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="1051" class="mf ld iq mu b gy mz na l nb nc">consumer.subscriptions.create("GeneralChannel", {<br/>  connected() {<br/>    // Called when the subscription is ready for use on the server<br/>    console.log("Connected to General channel");<br/>  },</span><span id="4152" class="mf ld iq mu b gy nr na l nb nc">  disconnected() {<br/>    // Called when the subscription has been terminated by the server<br/>  },</span><span id="c2ef" class="mf ld iq mu b gy nr na l nb nc">  received(data) {<br/>    // Called when there's incoming data on the websocket for this channel<br/>    console.log(data);<br/>    addMessage(data.content);<br/>  }<br/>});</span><span id="4579" class="mf ld iq mu b gy nr na l nb nc">function addMessage(message) {<br/>  const messageList = document.getElementById("message-list");<br/>  const containerDiv = document.getElementById("chat-container");<br/>  let newComment = document.createElement("li");<br/>  const messageInput = document.getElementsByClassName("message-input")[0];<br/>  newComment.innerText = message;<br/>  messageList.appendChild(newComment);<br/>  messageInput.value = '';<br/>  containerDiv.scrollTop = containerDiv.scrollHeight;<br/>}</span></pre><p id="069f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在定义一个名为<code class="fe mr ms mt mu b">addMessage()</code>的函数，它将一条消息作为参数，然后用我们的消息内容更新dom。现在我们只需要几种风格:</p><pre class="km kn ko kp gt mv mu mw mx aw my bi"><span id="347b" class="mf ld iq mu b gy mz na l nb nc">body {<br/>    box-sizing: border-box;<br/>}</span><span id="5ffa" class="mf ld iq mu b gy nr na l nb nc">.chat-container {<br/>    width: 700px;<br/>    margin: 0 auto;<br/>    height: 500px;<br/>    border: 1px solid #ddd;<br/>}</span><span id="98a4" class="mf ld iq mu b gy nr na l nb nc">h1 {<br/>    text-align: center;<br/>}</span><span id="0181" class="mf ld iq mu b gy nr na l nb nc">hr {<br/>    border-top: 1px solid #ddd;<br/>    border-bottom: none;<br/>    width: 700px;<br/>    margin: 0 30px 0 30px  auto;<br/>}</span><span id="5d3e" class="mf ld iq mu b gy nr na l nb nc">#chat-container {<br/>    width: 700px;<br/>    margin: 0 auto;<br/>    height: 500px;<br/>    overflow-y: auto;<br/>    border: 1px solid #ddd;<br/>}</span><span id="6dd2" class="mf ld iq mu b gy nr na l nb nc">.message-form {<br/>    display: flex;<br/>    flex-flow: row wrap;<br/>    align-items: center;<br/>    width: 700px;<br/>    margin: 0 auto;</span><span id="c4ce" class="mf ld iq mu b gy nr na l nb nc">}</span><span id="5c4d" class="mf ld iq mu b gy nr na l nb nc">.message-input {<br/>    vertical-align: middle;<br/>    height: 28px;<br/>    width: 530px;<br/>}</span><span id="3ede" class="mf ld iq mu b gy nr na l nb nc">.send-button {<br/>    border: none;<br/>    background-color: #0086c3;<br/>    color: #fff;<br/>    padding: 8px 16px;<br/>    margin-left: 16px;<br/>    // width: 80px;<br/>}</span><span id="6e73" class="mf ld iq mu b gy nr na l nb nc">.send-button:hover {<br/>    background-color: #29b6f6;<br/>    cursor: pointer;<br/>}</span></pre><p id="b409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在去聊天吧！</p></div></div>    
</body>
</html>