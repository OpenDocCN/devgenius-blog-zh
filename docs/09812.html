<html>
<head>
<title>Multi-threading in AWS-Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS-Lambda 中的多线程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multi-threading-in-aws-lambda-11acbc1d85b7?source=collection_archive---------2-----------------------#2022-09-15">https://blog.devgenius.io/multi-threading-in-aws-lambda-11acbc1d85b7?source=collection_archive---------2-----------------------#2022-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/02e84708ed5940e89d04faac97c040c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*tm_N-3MDWhwY1nZkHDg7Ig.png"/></div></figure><p id="0b1d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">AWS lambda 是一种无服务器、事件驱动的计算服务。所以我们不必考虑和管理使用 AWS Lambda 的服务器。这只是部署和运行的问题。</p><p id="3b55" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">参考这个关于<a class="ae kp" href="https://www.sentinelone.com/blog/aws-lambda-java-simple-introduction-examples/" rel="noopener ugc nofollow" target="_blank"> <em class="kq">如何在 AWS 中使用 Java lambda</em></a><em class="kq">。</em></p><p id="8f3a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面例子的源代码可以在 GitHub 上找到。T9】</p><h2 id="e5b6" class="kr ks in bd kt ku kv dn kw kx ky dp kz kc la lb lc kg ld le lf kk lg lh li lj bi translated"><strong class="ak">要求</strong></h2><p id="3972" class="pw-post-body-paragraph jr js in jt b ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko ig bi translated">需要从第三方 API 下载大量数据，并将其保存在 S3 桶中以备将来使用。API 中允许分页。由于数据集有点大，所以要检索多个页面。</p><h2 id="f11b" class="kr ks in bd kt ku kv dn kw kx ky dp kz kc la lb lc kg ld le lf kk lg lh li lj bi translated"><strong class="ak">解决方案</strong></h2><p id="56cd" class="pw-post-body-paragraph jr js in jt b ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko ig bi translated">根据要求，它不是一个阻塞任务。它可以用异步方式实现。</p><p id="273f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以解决方案是</p><ul class=""><li id="f3cd" class="lp lq in jt b ju jv jy jz kc lr kg ls kk lt ko lu lv lw lx bi translated">主程序将向 AWS 队列发送一条消息。那么队列将触发一个 AWS lambda 函数。</li><li id="56ac" class="lp lq in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">lambda 函数由一个 java 程序组成，该程序将下载大型数据集并将其存储在 S3 桶中。</li><li id="e466" class="lp lq in jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">为了提高程序的性能，<strong class="jt io">多线程</strong>将处理数据下载部分。每个页面将由一个单独的线程下载。</li></ul><h2 id="58b5" class="kr ks in bd kt ku kv dn kw kx ky dp kz kc la lb lc kg ld le lf kk lg lh li lj bi translated"><strong class="ak">实施</strong></h2><p id="d628" class="pw-post-body-paragraph jr js in jt b ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko ig bi translated">让我们看看上面解决方案的 java 实现。注意 handleRequest()是 lambda 函数中程序的入口点(可以配置)。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2b00" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这只是在该解决方案中应该做的模拟。让我们运行它，看看输出。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/7c1ad4e91b73dae20383d5eec9b5cf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3d2l6WGH2W2pQ9rM8mf7Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">本地机器中的程序输出</figcaption></figure><p id="f9b6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以这很好。所有线程完成任务后，程序终止。</p><p id="d370" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们把这个上传到 AWS lambda 函数，看看输出。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/dafb72faae1ddddaccd1070ad2eaa228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*IBbA2PKIsnT_cp10R6wZNQ.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">AWS lambda 中的程序输出(第一次调用)</figcaption></figure><p id="a1c5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">AWS Lambda 的行为似乎很不一样。数据下载器线程的日志不存在。现在我们有一个问题。数据下载线程发生了什么变化？</p><p id="5a76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我将让主线程休眠 3000 ms，并查看 lambda 中的输出。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">增加了线程睡眠</figcaption></figure><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/9ad5af70a5adb288eb0b894a5136ae8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1opI5CTQXbX52n7c_o_BaQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">主线程休眠后的 Lambda 输出(第二次调用)</figcaption></figure><p id="6966" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里我们可以看到数据下载器线程的输出。<em class="kq">线程 0、线程 1、线程 2 </em>已启动，下载也正在进行。但没有完成。让我们在短暂等待后再次调用 lambda 函数。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/d99ce5c2cca83a7dbb75c5a49f1cda53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2hzjtZ9YdGOOGzIz5Ccyg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Lambda 函数第三次调用</figcaption></figure><p id="43b0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们有一点困惑。在第三次调用中还有另外 3 个新线程在运行(<em class="kq"> Thread-3，Thread-4，Thread-5 </em>)。此外，先前调用中的线程也在运行。但是以前线程的日志也显示当前时间。而不是之前的调用时间。这里发生了什么？</p><h2 id="eec4" class="kr ks in bd kt ku kv dn kw kx ky dp kz kc la lb lc kg ld le lf kk lg lh li lj bi translated"><strong class="ak">结论</strong></h2><p id="4df7" class="pw-post-body-paragraph jr js in jt b ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko ig bi translated">当我们触发 lambda 函数时，<em class="kq"> handleRequest() </em>将开始执行。因此，它将创建 3 个新线程用于数据下载，并立即从<em class="kq"> handleRequest() </em>返回。</p><p id="22e2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为在第一次调用中，从<em class="kq"> handleRequest() </em>方法立即返回；即使创建了 3 个数据下载线程，这些线程也没有足够的时间来执行。因此没有数据下载线程的迹象。</p><p id="94e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是在第二次调用中，我们让主线程休眠 3000 毫秒，因此 lambda 函数必须等待 3000 毫秒才能从<em class="kq"> handleRequest() </em>返回，因为主线程处于休眠状态。因此，现在数据下载器线程有机会运行 3000 毫秒，这就是为什么有来自这些线程的日志。但是这些线程没有足够的时间来完成它们的任务。</p><blockquote class="mv mw mx"><p id="44bc" class="jr js kq jt b ju jv jw jx jy jz ka kb my kd ke kf mz kh ki kj na kl km kn ko ig bi translated">从请求返回后，Lambda 冻结执行环境。当函数再次被调用时，lambda 抛出环境进行重用。</p></blockquote><p id="10a9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以上解释可以从<a class="ae kp" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html" rel="noopener ugc nofollow" target="_blank"> <em class="kq"> AWS Lambda 文档</em> </a>中找到。</p><p id="4f0f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">根据上面的解释和第三次调用的输出，我们可以看到在第二次调用中没有足够时间完成的线程也在第三次调用中被执行。这就是为什么有 6 个数据下载线程在进行中。</p><p id="00e7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这可能发生在后续的 lambda 调用中(<strong class="jt io">热启动</strong>)。但是在 lambda 函数超时(最大 15 分钟)后，我们不能期望这种情况发生。因为在超时之后，如果发生新的调用，这将是一个<strong class="jt io">冷启动。因此 lambda 将为此创建一个新的执行环境。</strong></p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="673d" class="ni ks in bd kt nj nk nl kw nm nn no kz np nq nr lc ns nt nu lf nv nw nx li ny bi translated">解决办法</h1><p id="a09d" class="pw-post-body-paragraph jr js in jt b ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko ig bi translated">为了避免 AWS Lambda 中的上述问题，我们必须等待数据下载线程在从<em class="kq"> handleRequest()返回之前完成它们的任务。</em></p><p id="60a7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将使用一个<strong class="jt io"> CountDownLatch </strong>来克服这个问题。让我们看看修改后的源代码。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="nz">带有 CountDownLatch 变化的 handle request()</em></figcaption></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="nz">DataDownloader.java 与 CountDownLatch 的变化</em></figcaption></figure><p id="c282" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们把这个上传到 AWS lambda，看看输出。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oa"><img src="../Images/f0739ac714f6f7d941fe4085047d578e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTr-mt_GvG_UHtqgJY3BAA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">最新变更的 AWS lambda 输出</figcaption></figure><p id="7fc2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">问题已解决。由于我们使用的是 CountDownLatch，它将一直等到数据下载器线程完成它们的任务，之后它才会从<em class="kq"> handleRequest()返回。</em></p><p id="76fb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是我如何克服我在 AWS lambda 中遇到的多线程问题。但这不是唯一的解决方案。</p><p id="3686" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">感谢阅读。编码快乐！🙂。</p></div></div>    
</body>
</html>