<html>
<head>
<title>SOLID Principles in Swift — Interface Segregation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的固体原理——界面分离原理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/solid-principles-in-swift-interface-segregation-principle-d15a4804b4ae?source=collection_archive---------10-----------------------#2022-05-03">https://blog.devgenius.io/solid-principles-in-swift-interface-segregation-principle-d15a4804b4ae?source=collection_archive---------10-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0edd07fafdd279795e302625129db26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HKcbJNnldgwNX0Su"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯里德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="2d97" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">背景</h1><p id="908e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这一系列的帖子中，我们将涉及软件开发的坚实原则。这些是一组原则/指导方针，当开发软件系统时遵循这些原则/指导方针，使得系统随着时间的推移更容易扩展和维护。让我们来看看他们寻求解决的问题:</p><ul class=""><li id="9d2c" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">脆弱性:一个变化可能会破坏意想不到的部分，如果你没有一个好的测试覆盖率，这是很难检测到的</li><li id="3fa9" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">不可移动性:一个组件很难在另一个项目或同一个项目的多个地方重用，因为它有太多耦合的依赖关系</li><li id="298f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">刚性:变更需要大量的努力，因为它影响到项目的几个部分</li></ul><p id="6d65" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">那么坚实的原则是什么呢？</p><ul class=""><li id="e9f1" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">单一责任原则——一个类应该只有一个责任/只有一个改变的理由</li><li id="acf0" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">开闭原则——软件应该对扩展开放，但对修改关闭</li><li id="e6fc" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">Liskov 替换原则——程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性</li><li id="a6cb" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">接口分离原则——许多特定于客户端的接口比一个通用接口要好</li><li id="b6cf" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">依赖倒置原则——高级模块不应该依赖低级模块。两者都应该依赖于抽象</li></ul><p id="39e0" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在本文中，我们将关注接口分离原则。</p><h1 id="a17a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">这是什么意思？</h1><p id="f0e6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">该原理的概要如下:</p><blockquote class="ms mt mu"><p id="9de1" class="lb lc mv ld b le mb lg lh li mc lk ll mw mp lo lp mx mq ls lt my mr lw lx ly ij bi translated"><em class="iq">许多客户端专用接口比一个通用接口更好</em></p></blockquote><p id="71f3" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在 Swift 中，我们使用<a class="ae kc" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank">协议</a>而不是 Java 等语言中的接口，因此从现在开始我们将把接口称为协议。</p><p id="f0f6" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这条规则的目的，与《坚实原理》中的其他一些规则相比，是非常直接的。这意味着创建较小的协议比创建一个定义了许多方法的大协议要好。</p><h1 id="a42a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">有什么问题吗</h1><p id="7c2e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">那么，为什么拥有一个大型协议会带来问题呢？让我们检查一个经典的 Cocoa Touch 协议，看看为什么这是一个问题。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b12c" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我确信你们中的许多人在过去的某个时候已经实现了这个协议；)我稍微修改了源代码，使其更容易阅读和理解，那么我们为什么要看这个呢？</p><ol class=""><li id="b438" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly nf mh mi mj bi translated">在前两个方法中，您只需要实现两个方法。</li><li id="8fad" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">其余的方法都是可选的，您可以实现您想使用的任何方法。</li></ol><p id="45c3" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">现在，这个协议已经植根于<a class="ae kc" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" rel="noopener ugc nofollow" target="_blank">目标 C </a>帮助它在某种程度上掩盖了这个问题。在 Objective C 中，你可以在上面的代码中看到，可以将某些函数标记为可选的。这意味着你可以实现它们，如果你想的话，但不是必须的，这允许这个协议声明包含太多的方法，而不会给实现类带来问题。</p><p id="cb47" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在 Swift 中，不可能将功能标记为可选，所有功能都需要实施。让我们把上面的协议更新得更快一些，看看会给我们带来什么问题。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="29fc" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">现在我们已经将我们的协议转换得更快了，当我们试图使一个类符合这个协议时，这会导致什么问题呢？让我们看一个例子。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="57be" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我们上面的类现在必须实现每一个协议方法。即使我们不打算使用它。在协议的 objective c 实现中，我们可以选择只实现我们需要的方法，而现在我们必须实现每一个方法。想象一下，为了符合这个协议，世界上所有的视图控制器都充满了空方法！</p><p id="7753" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">该协议打破了接口隔离原则。</p><h1 id="9992" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">更好的解决方案</h1><p id="4cbd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了改进解决方案，我们可以将一个大的接口分解成更小的协议。这样，我们可以只遵循我们感兴趣的协议来实现我们的功能。这可能看起来像:</p><ol class=""><li id="712e" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly nf mh mi mj bi translated">UITableViewDataSource —对于我们熟悉的两个强制方法</li><li id="9304" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">uitableviewssectionsdatasource—用于与多节方法相关的方法</li><li id="ea04" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">UITableViewSectionTitles —用于与节中的页眉和页脚相关的方法</li><li id="7255" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">UITableViewEditable —用于与编辑和移动单元格相关的方法</li></ol><p id="696b" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">通过这种方式，我们可以选择我们想要的方法，而不是一个大的接口，我们可能只想要方法的一个小的子集。</p><h1 id="8a5e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一个好例子</h1><p id="1fd5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">iOS SDK 中接口分离的一个很好的例子是 Codable。可编码的定义如下:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5258" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">基本上，Codable 是另外两个协议的组合:可解码和可编码。这是如何进行接口分离的一个很好的例子。如果您正在构建一个 JSON 解析结构，您可能希望只遵循 Decodable，这样您就可以解码 JSON。如果将来您想要序列化数据存储之类的结构，您可以在以后需要时遵循编码。</p><h1 id="5f7a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="191f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我看来，接口分离原则是最容易理解的原则。基本上，这意味着不要创建一个包含许多方法的大协议，这些方法并不总是需要根据实现需求来实现。</p><p id="6093" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">取而代之的是，将协议分成更小的协议，只包含单个功能工作所需的方法。这不仅避免了许多冗余的方法，而且通过允许将功能分解到不同的类中，有助于简化单一责任原则。例如，您可以用不同的类来处理不同的活动，而不是用一个包含所有功能的大类。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="b1e3" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><em class="mv">原载于 2022 年 5 月 3 日</em><a class="ae kc" href="https://pyartez.github.io/architecture/solid-principles-in-swift-interface-segragation-principle.html" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://pyartez . github . io</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>