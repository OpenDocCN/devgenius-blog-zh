<html>
<head>
<title>Angular deep copy vs shallow copy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的深拷贝与浅拷贝</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-deep-copy-vs-shallow-copy-685511e43b42?source=collection_archive---------0-----------------------#2021-11-03">https://blog.devgenius.io/angular-deep-copy-vs-shallow-copy-685511e43b42?source=collection_archive---------0-----------------------#2021-11-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="84a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是克隆的实际方面，不会对 TypeScript 应用程序的性能产生影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5694db73e0d94b097740d181a572b94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qYd6i3Gxljw8kuIBc3oEg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">莫斯科“西南剧院”上演“拿破仑戏剧”</figcaption></figure><p id="747c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像上图中的单元格一样，Angular 应用程序有很多对象和属性。根据 1 组件中 UI 变化的逻辑，我们经常需要更新嵌套组件并应用新值。但是在使用 deepcopy()方法的情况下，这可能会花费时间并降低性能。深度副本会以 100%的概率更新相似的对象，但这和<em class="ky">孙子</em>说的“向麻雀开炮”是一样的。</p><p id="2947" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一、理论部分。</strong></p><p id="90d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们在进行深层复制、浅层复制或对象赋值之间进行选择。</p><ol class=""><li id="fd36" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">任务。A = B。它只是对对象进行引用，而不是复制。</li><li id="d523" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">浅拷贝意味着某些子值仍然连接到原始变量。扩展运算符表示的符号。</li></ol><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6354" class="ls lt in lo b gy lu lv l lw lx">private rack: BilliardRack[];</span><span id="6606" class="ls lt in lo b gy ly lv l lw lx">get BilliardRack(): BilliardRack[] {<br/>  return this.rack.map(ball =&gt; ({ ...ball }) );<br/>}</span></pre><p id="4c1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.深度复制意味着新变量的所有值都被复制并与原始变量断开连接。可能有不同的深度拷贝库，我更喜欢使用来自<code class="fe lz ma mb lo b">/node_modules/deep-copy-ts</code>的标准</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="fbd3" class="ls lt in lo b gy lu lv l lw lx">export declare function deepCopy&lt;T&gt;(target: T): T;</span></pre><p id="c67a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">复制对象的不同和最广泛的变体:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="5e95" class="ls lt in lo b gy lu lv l lw lx">const billiard = {<br/>  type1: "Snooker",<br/>  type2: "Russian Pyramid",<br/>  type3: "American Pool",<br/>  players: ["Ronnie O'Sullivan", "Aleksandr Palamar", "etc"],<br/>};</span><span id="62c3" class="ls lt in lo b gy ly lv l lw lx">// use shallow copy with spread operator of 3 dots<br/>const billiardGame = { ...billiard };<br/>// the most fast method of copy<br/>const billiardGame = Object.assign({}, billiard);<br/>const billiardGame = Object.assign(obj, { type3: "Finnish Kaisa"} );</span><span id="a51d" class="ls lt in lo b gy ly lv l lw lx">// or make deep copy<br/>const billiardGame = JSON.parse(JSON.stringify(billiard));<br/>const billiardGame = deepCopy(billiard);<br/></span><span id="5e60" class="ls lt in lo b gy ly lv l lw lx">billiardGame.type3 = "French caromball";<br/>console.log(billiard.type3);<br/>console.log(billiardGame.type3);        //new value will be applied<br/></span><span id="ea9a" class="ls lt in lo b gy ly lv l lw lx">// You can also use shallow copy to merge many objects together:<br/>const billiardTotal = { ...billiard, ...billiardGame};<br/>console.log(billiardTotal);</span></pre><p id="2411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果您直接赋值，它就不起作用:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="2e06" class="ls lt in lo b gy lu lv l lw lx">const obj = {<br/>   item1: 1,<br/>   item2: 2<br/>};<br/><br/><strong class="lo io">const newObj = obj;         // assignment</strong></span><span id="b4ba" class="ls lt in lo b gy ly lv l lw lx">const newObj.newItem = 3;<br/>console.log(newObj);        // {item1: 1, item2: 2, newItem: 3}</span><span id="6657" class="ls lt in lo b gy ly lv l lw lx">// and incorrect behavior:<br/>// we expect the old variable to have the original values, not the changed ones, but it doesn't.</span><span id="0447" class="ls lt in lo b gy ly lv l lw lx">console.log(obj);           // {item1: 1, item2: 2, newItem: 3}</span></pre><p id="49ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组也是对象，所以复制方法的行为相同:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="9fdb" class="ls lt in lo b gy lu lv l lw lx">const gamers = ["Ronnie O'Sullivan", "Aleksandr Palamar"];<br/>let players = gamers.map(el =&gt; el);<br/>players[2] = "John Higgins";</span><span id="fe1d" class="ls lt in lo b gy ly lv l lw lx">console.log(players[2]); // shows new value<br/>console.log(gamers[2]);  // keep the old original</span></pre><p id="5bfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二。实用部分。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/8368bb587b5f45dda2a1d311f6b6ea33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7lUz_KOzCsXDogRJb57fA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">像国际象棋中的细胞一样的对象属性</figcaption></figure><p id="13aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还是实际一点吧。angular 应用程序可能很复杂，一个 HTML 页面由许多相互绑定的组件组成。</p><p id="6711" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们在<code class="fe lz ma mb lo b">updateCharges()</code>方法的子组件中获得了新的值，需要更新正确的父组件对象。<strong class="jm io">输出</strong>注释帮助我们将数据发送出去。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e5e6" class="ls lt in lo b gy lu lv l lw lx">@Output()<br/>chargeTermsEvent = new <strong class="lo io"><em class="ky">EventEmitter</em></strong>&lt;ChargeTerms&gt;();</span><span id="edd1" class="ls lt in lo b gy ly lv l lw lx">private updateCharges(charges: ChargeTerms) {<br/>  console.log("get new charges, send to parent"); <br/>  this.chargeTermsEvent.emit(charges);<br/>}</span></pre><p id="b81c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在另一个组件中，在 HTML 层，我们从方法<code class="fe lz ma mb lo b">chargeTermsEvent </code>获取数据，并将新数据发送给方法<code class="fe lz ma mb lo b">handleChargeTerms</code></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="aacf" class="ls lt in lo b gy lu lv l lw lx">&lt;charges-tariff class="sub-row"<br/>               [tariffs]="<strong class="lo io"><em class="ky">item</em></strong>"<br/>               (chargeTermsEvent)="handleChargeTerms(<strong class="lo io"><em class="ky">$event</em></strong>)"<br/>               /&gt;</span></pre><p id="4f07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并在类型脚本级别使用该方法。现在我们可以处理新收到的数据。在浅拷贝的情况下，我们使用基于 3 个点的扩展操作符。新值将应用于该组件中声明的局部对象。</p><p id="1455" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">角度变化检测机制几乎立即检测到变化，并提前发送数据。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="c817" class="ls lt in lo b gy lu lv l lw lx">private chargeTerms: ChargeTerms;</span><span id="c528" class="ls lt in lo b gy ly lv l lw lx">handleChargeTerms($event: ChargeTerms) {<br/>  this.chargeTerms = $event;<br/>  this.chargeTerms = { ...this.chargeTerms}; // use shallow copy<br/>  this.hasLeastChargesAdded();<br/>}<br/><br/>isChargesAdded(): boolean {<br/>  return this.chargeTerms !== undefined;<br/>}</span></pre><p id="7b7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们也可以使用<strong class="jm io">深度拷贝</strong>来明确地重新分配对象的每个属性。我使用 Angular 的标准库。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="ab25" class="ls lt in lo b gy lu lv l lw lx">import { deepCopy } from "deep-copy-ts";</span><span id="29d2" class="ls lt in lo b gy ly lv l lw lx">this.chargeTerms = deepCopy(this.chargeTerms);</span></pre><p id="031d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，最后，我们的父组件用新数据更新，你可以处理它——将数据发送到另一个子组件的方法<code class="fe lz ma mb lo b">chargeTermsDisabled </code>,并在 HTML 端显示它。方法<code class="fe lz ma mb lo b">isChargesAdded() </code>将根据<code class="fe lz ma mb lo b">chargeTerms</code>返回布尔值。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="c80c" class="ls lt in lo b gy lu lv l lw lx">&lt;charges-tariff-request #t<strong class="lo io"><em class="ky">ariffComponent</em></strong><br/>  [chargeTermsDisabled]="isChargesAdded"<br/>  /&gt;</span></pre><p id="c966" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用复制方法的最实际的方面——确保所有新的对象属性将被重新分配给一个局部变量。</p><p id="ac4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在父/子组件之间传输新数据，并更新将在当前页面的 HTML 侧呈现值的某些对象。因此，对象的每个单元格、每个属性都会更新。</p><p id="4e42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">增补 1。</strong></p><p id="1dbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Spread 运算符从<code class="fe lz ma mb lo b">obj </code>获取所有字段，并将其分布在<code class="fe lz ma mb lo b">result</code>上。</p><pre class="kj kk kl km gt ln lo md bn me mf bi"><span id="77e0" class="mg lt in lo b be mh mi l mj lx">const obj = { param: "value", param2: "abrakadabra" };<br/>const result = { ...obj, param2: "new real value" }; // add new value to existing param2<br/>console.log(result);</span></pre><p id="11db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">增补 2。</strong></p><p id="0439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从对象中删除一个属性。析构将帮助我们创建一个浅层拷贝。</p><pre class="kj kk kl km gt ln lo md bn me mf bi"><span id="9f34" class="mg lt in lo b be mh mi l mj lx">type CruiseMissile = {<br/>  color: string<br/>  technicalData: {<br/>    distance: number;<br/>    ageOfManufactured: number;<br/>  }<br/>}<br/><br/>const missile: CruiseMissile = {<br/>  color: 'white',<br/>  technicalData: {<br/>    distance: 4000,<br/>    ageOfManufactured: 1979<br/>  }<br/>}<br/><br/>const { distance, ...technicalData} = missile.technicalData;<br/>const result = {<br/>    ...missile, technicalData // 'distance' property will be missed.<br/>}<br/>console.log(result);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/df58e55b6ce97c48f7f8923a52199c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDxumbnhJimsXPvYdYBv7Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我喜欢象棋细胞</figcaption></figure><p id="341c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="46cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于应用程序性能而言，使用浅层拷贝是比深层拷贝更便宜的解决方案，但使用情况取决于某些情况。更新嵌套组件可能有不同的方法。最大的错误是从标准角度生命周期的 ngOnChanges()方法调用 deepCopy()。</p><p id="5222" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="ml mm gp gr mn mo"><a href="https://frontbackend.com/javascript/what-is-the-the-fastest-way-to-deep-clone-an-object-in-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd io gy z fp mt fr fs mu fu fw im bi translated">【已解决】在 JavaScript 中深度克隆一个对象最好最高效的方法是什么？</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">在每种编程语言中，有时都需要一个对象的精确副本。忠实的复制…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">frontbackend.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ks mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd io gy z fp mt fr fs mu fu fw im bi translated">如何在 JavaScript 中区分深层和浅层拷贝</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">如何在 JavaScriptPhoto 中区分深层和浅层拷贝？</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.freecodecamp.org</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc ks mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://bobbyhadz.com/blog/javascript-cannot-assign-to-read-only-property-of-object" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd io gy z fp mt fr fs mu fu fw im bi translated">无法在 JavaScript | bobbyhadz 中为对象的只读属性赋值</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">当我们试图改变一个具有…的对象的属性时，出现错误“不能分配给对象的只读属性”</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">bobbyhadz.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc ks mo"/></div></div></a></div><p id="a774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">奖励链接</strong>。我在莫斯科“西南剧院”最喜欢的戏。</p><div class="ml mm gp gr mn mo"><a href="https://teatr-uz.ru/igra-v-napoleona" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd io gy z fp mt fr fs mu fu fw im bi">Игра в Наполеона</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk">Название: Игра в Наполеона Автор: Стефан Брюлотт, перевод Ларисы Овадис Жанр: Шахматный детектив Количество действий: 2…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">teatr-uz.ru</p></div></div><div class="mx l"><div class="nf l mz na nb mx nc ks mo"/></div></div></a></div></div></div>    
</body>
</html>