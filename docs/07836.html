<html>
<head>
<title>New startTransition API in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中的新 startTransition API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/new-starttransition-api-in-react-9d407c86eec1?source=collection_archive---------11-----------------------#2022-04-26">https://blog.devgenius.io/new-starttransition-api-in-react-9d407c86eec1?source=collection_archive---------11-----------------------#2022-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fa2519eb022af6a471273dec6c5c3468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gV2nmVSQDfT0XAml.png"/></div></div></figure><h1 id="456e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是过渡？</h1><p id="9055" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">转换是 React 中的一个新概念，用于区分紧急更新和非紧急更新。</p><ul class=""><li id="643e" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><strong class="kv io">紧急更新</strong>反映直接交互，比如打字、点击、按压等等。</li><li id="117d" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated"><strong class="kv io">转换更新</strong>将用户界面从一个视图转换到另一个视图。</li></ul><p id="d942" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">像打字、点击、按键这样的紧急更新需要<strong class="kv io">即时</strong>响应，以符合我们对物理对象行为的直觉。否则他们会觉得<strong class="kv io">【不对】</strong>。然而，<strong class="kv io">转换</strong>是不同的，因为用户不期望在屏幕上看到每个中间值。</p><p id="7ffb" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">例如，当您在搜索框中键入内容时，您希望输入字段本身做出响应，并在您按键时立即显示键入的字符<strong class="kv io"/>。然而，实际结果可能会分别过渡到<strong class="kv io">和</strong>，通常会有小的延迟。如果您在结果渲染完成之前再次更改搜索词，您只需要查看最新的<strong class="kv io">结果。</strong></p><p id="0c3d" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">在 React 18 中，我们可以使用<code class="fe mk ml mm mn b">startTransition</code> API 将任何状态更新标记为非紧急。</p><p id="7a02" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">在下面的代码块中，有两个状态更新——一个是紧急的，另一个被标记为非紧急的，因为它被包装在<code class="fe mk ml mm mn b">startTransition</code>回调中:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1e79" class="mw jw in mn b gy mx my l mz na">import {startTransition} from 'react';<br/><br/>// Urgent: Show what was typed<br/>setInputValue(input);<br/><br/>// Mark any state updates inside as transitions (non-urgent)<br/>startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setResults(input);<br/>});</span></pre><p id="c0c4" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">如果更紧急的更新，如点击或按键，非紧急更新将被<strong class="kv io">中断</strong>。如果一个过渡被用户打断(例如，在一行中输入多个字符)，React 将丢弃没有完成的<strong class="kv io">陈旧的</strong>渲染工作，只渲染<strong class="kv io">最新的</strong>更新。</p><h1 id="f26c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">演示应用程序:有无 startTransition 的性能</h1><p id="9f5a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们构建了一个简单的应用程序来展示新的<code class="fe mk ml mm mn b">startTransition</code> API 的威力。</p><p id="ec94" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">这个应用程序基本上是一个“文本搜索”特性，它为用户提供了在一个很长的文本块(在我们的例子中大约有 60000 个字符)中搜索一个术语的能力。</p><p id="71b1" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们的应用程序需要提供两个特性:</p><ul class=""><li id="8cd0" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">呈现一个<strong class="kv io">输入</strong>，允许用户键入一个<strong class="kv io">搜索</strong>项。</li><li id="e071" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">对<strong class="kv io">突出显示</strong>任何与输入的搜索词匹配(不区分大小写)的字符。</li></ul><p id="8787" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们用来获得匹配项的简单算法是:</p><ol class=""><li id="37cf" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq nb lz ma mb bi translated">从<strong class="kv io">搜索词</strong>构建一个正则表达式，它将匹配任何字符(不区分大小写)。</li><li id="d5e0" class="lr ls in kv b kw mc la md le me li mf lm mg lq nb lz ma mb bi translated">将<code class="fe mk ml mm mn b">highlight</code>类添加到匹配字符的所有<em class="nc">跨度</em>中。</li></ol><p id="db8a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><code class="fe mk ml mm mn b">applyFilter</code>功能的代码如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="71ad" class="mw jw in mn b gy mx my l mz na">const applyFilter = (query, setFilteredNode) =&gt; {<br/>  setFilteredNode(() =&gt; {<br/>    if (!query || query.trim().length === 0) {<br/>      return INITIAL_VALUE;<br/>    }<br/><br/>    const regex = new RegExp(<br/>      query.trim().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&amp;"),<br/>      "ig"<br/>    );<br/><br/>    const node = TEXT.replaceAll(regex, (s) =&gt; `##${s}##`)<br/>      .split("##")<br/>      .map((s, i) =&gt; (<br/>        &lt;span key={i} className={i % 2 === 1 ? "highlight" : ""}&gt;<br/>          {s}<br/>        &lt;/span&gt;<br/>      ));<br/><br/>    return node;<br/>  });<br/>};</span></pre><p id="c2c5" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">显然，我们可以提出更优化的算法——这个正则表达式严重影响了性能——但是我们在这里的任务是“创建”一个导致大量 React 状态更新的高成本函数，以便我们可以看到<code class="fe mk ml mm mn b">startTransition</code> API 是否会改善这种情况。</p><p id="11b6" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><strong class="kv io">你可以在这里</strong>  <strong class="kv io">找到 app </strong> <a class="ae nd" href="https://codesandbox.io/s/react-18-starttransition-demo-s2bvxy?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">的所有代码。</strong></a></p><h1 id="5271" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第一次实施:未优化，没有开始过渡</h1><p id="777e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们的第一个实现是一个具有两个简单状态更新的组件，一个用于输入值，另一个将应用过滤后的结果。每当输入值改变时，函数<code class="fe mk ml mm mn b">applyFilter</code>将被调用。默认情况下，两种状态更新都标记为紧急:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7bf9" class="mw jw in mn b gy mx my l mz na">import {useState} from 'react';<br/><br/>const Unoptimized = () =&gt; {<br/>  const [query, setQuery] = useState("");<br/>  const [filteredNode, setFilteredNode] = useState(INITIAL_VALUE);<br/><br/>  const onInputChange = (e) =&gt; setQuery(e.target.value);<br/><br/>  useEffect(() =&gt; {<br/>    applyFilter(query, setFilteredNode);<br/>  }, [query]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className="input"&gt;<br/>        &lt;input onChange={onInputChange} /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="text"&gt;{filteredNode}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="9a9f" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><strong class="kv io">未优化</strong></p><p id="3a91" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">您可以看到字符没有立即显示在输入字段中，用户界面感觉有点“慢”:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/e274526fa1303d24999708c6bf04f0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2xWBYLTtS05Rg5eYmlDYEA.gif"/></div></div></figure><p id="fee2" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><strong class="kv io">未优化，CPU 速度降低 4 倍</strong></p><p id="2a51" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们应用了 4 倍的 CPU 减速(来自 Chrome dev tools)来更好地模拟普通 CPU 或移动设备。我们可以看到，用户界面肯定感觉很慢，一点也不流畅:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/efd1ace0723630fc26014d18115e9a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U5w_4VR0kI5_T4e2.png"/></div></div></figure><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/ffc7aefd0cb1bbd97d749ef99fcddf3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMGUDLsoZVlQoEIJ.gif"/></div></div></figure><h1 id="311b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第二次实施:使用 startTransition 优化</h1><p id="5a35" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们的第二个实现中，我们利用了<code class="fe mk ml mm mn b">startTransition</code> API。具体来说，我们使用了返回一个<code class="fe mk ml mm mn b">pending</code>状态的<code class="fe mk ml mm mn b">useTransition</code>钩子——我们使用该状态通过模糊屏幕向用户表明一个转换仍在处理中(我们也可以显示一个加载程序)。</p><p id="4dfe" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们通过将结果的状态更新封装在一个<code class="fe mk ml mm mn b">startTransition</code>回调中，将它标记为非紧急:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="be93" class="mw jw in mn b gy mx my l mz na">import {useState, useTransition} from 'react';<br/><br/>const Optimized = () =&gt; {<br/>  const [query, setQuery] = useState("");<br/>  const [filteredNode, setFilteredNode] = useState(INITIAL_VALUE);<br/>  const [pending, startTransition] = useTransition();<br/><br/>  const onInputChange = (e) =&gt; setQuery(e.target.value);<br/><br/>  useEffect(() =&gt; {<br/>    startTransition(() =&gt; {<br/>      applyFilter(query, setFilteredNode);<br/>    });<br/>  }, [query, startTransition]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      {pending &amp;&amp; &lt;div className="fade" /&gt;}<br/>      &lt;div className="input"&gt;<br/>        &lt;input onChange={onInputChange} /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="text"&gt;{filteredNode}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="adbc" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><strong class="kv io">优化后的</strong></p><p id="f456" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">看看字符在输入屏幕上显示得多快；它感觉自然、光滑，是用户所期望的。当<code class="fe mk ml mm mn b">pending</code>变量为真时，我们模糊屏幕，以向用户指示转换仍在进行中。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/9f8724508522ab0ebfa89ebecddfbdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s8F_6qAOauSUqrE0eamE7Q.gif"/></div></div></figure><p id="f762" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><strong class="kv io">优化了 CPU 4x 减速</strong></p><p id="28c6" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们甚至应用了 4 倍的 CPU 减速来检查 UI 如何响应。看起来<strong class="kv io">不错</strong>，甚至在<strong class="kv io">那种场景下</strong>！</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/cb63645fc54f5e894e2acb99ae63f29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6HQ-GHumZJ18kOwy.gif"/></div></div></figure><h1 id="e759" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">React 18 之前的替代解决方案？</h1><p id="9a42" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在 React 18 之前我们没有<code class="fe mk ml mm mn b">startTransition</code> API，那么我们如何在早期 React 版本中修复它呢？</p><p id="7025" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">面对此类问题并避免大量重复状态更新的最常见解决方案是利用<strong class="kv io">去抖</strong>或<strong class="kv io">节流</strong>技术。</p><p id="1a50" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">例如，我们可以利用这个棒极了的<a class="ae nd" href="https://www.npmjs.com/package/use-debounce" rel="noopener ugc nofollow" target="_blank"> use-debounce </a>库，将结果的重状态更新封装在一个<strong class="kv io">de bounce 回调</strong>中，如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="e8ab" class="mw jw in mn b gy mx my l mz na">import {useState} from 'react';<br/>import {useDebouncedCallback} from 'use-debounce';<br/><br/>const Debounced = () =&gt; {<br/>  const [query, setQuery] = useState("");<br/>  const [filteredNode, setFilteredNode] = useState(INITIAL_VALUE);<br/>   <br/>  const onInputChange = (e) =&gt; setQuery(e.target.value);<br/><br/>  const debounced = useDebouncedCallback(<br/>    (query, setFilteredNode) =&gt; {<br/>       applyFilter(value, setFilteredNode);<br/>    },<br/>    100 // debounce 100 ms<br/>  );  <br/><br/>  useEffect(() =&gt; {<br/>    debounced(query, setFilteredNode);<br/>  }, [query, startTransition]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      {pending &amp;&amp; &lt;div className="loader" /&gt;}<br/>      &lt;div className="input"&gt;<br/>        &lt;input onChange={onInputChange} /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="text"&gt;{filteredNode}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="4799" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">但是这种方法仍然有一些问题。</p><p id="21c1" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">首先，<code class="fe mk ml mm mn b">applyFilter</code>函数不能在用户完成输入后的 100 毫秒内被调用(或者你选择的任何时间)。另一方面，通过使用<code class="fe mk ml mm mn b">startTransition</code> API，结果的繁重处理尽快开始<strong class="kv io"/>，而不必等待任意长的时间。</p><p id="75ab" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">其次，即使我们使用节流而不是去抖来尝试解决第一个问题，处理结果的工作也是<strong class="kv io">不可中断的</strong>。这意味着如果在结果还在处理的时候有新的紧急更新进来(比如按键), UI 不可避免地会<strong class="kv io">无响应</strong>。而使用<code class="fe mk ml mm mn b">startTransition</code> API，当紧急更新到来时，处理工作将被<strong class="kv io">中断</strong>，以这种方式保持输入域的响应。</p><h1 id="8713" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结束了</h1><p id="349c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我希望你发现这篇文章内容丰富。</p><p id="6c58" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">回头见。🙂</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="fcb1" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><em class="nc">原载于</em><a class="ae nd" href="https://tasoskakour.com/blog/react-18-new-api-start-transition" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://tasoskakour.com</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>