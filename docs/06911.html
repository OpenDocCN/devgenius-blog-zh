<html>
<head>
<title>Golang Memory Escape In-Depth Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 记忆逃逸深度解析</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/in-depth-analysis-of-golang-memory-escape-edfbfb856913?source=collection_archive---------0-----------------------#2022-02-11">https://blog.devgenius.io/in-depth-analysis-of-golang-memory-escape-edfbfb856913?source=collection_archive---------0-----------------------#2022-02-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b1f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你必须掌握 Golang 记忆逃生知识点</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8cc307793f5323096f5f5a50191eafed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkEwHfHVAmMOz_CekjhliA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alesiaskaz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alesia Kazantceva </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="f8d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近一个朋友正在学习 Golang，他说他遇到了一个问题，下面的代码居然不报错，以他写 C 语言的经验，这个代码应该不会被编译。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="fa52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码对于 Golang 来说真的没问题，下面我们来看看 C 代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="b2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们执行<code class="fe lb lc ld le b">gcc demo.c</code>时，将会返回一个警告。</p><pre class="kj kk kl km gt lf le lg lh aw li bi"><span id="360f" class="lj lk in le b gy ll lm l ln lo">demo.c:6:13: warning: address of stack memory associated with local variable 'data' returned [-Wreturn-stack-address]</span><span id="46e3" class="lj lk in le b gy lp lm l ln lo">return &amp;data;</span><span id="7b35" class="lj lk in le b gy lp lm l ln lo">1 warning generated.</span></pre><p id="8753" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提示说返回一个堆栈内存，这是不允许的。朋友很好奇为什么 Golang 中允许这种行为，这就引出了我们今天要分析的问题:<strong class="jm io"> Golang 的内存逃逸行为</strong>。</p><p id="92de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">程序中的内存分为两个区域，一个用于堆栈，一个用于堆。堆栈区有特定的结构和寻址方法，寻址速度很快，开销很小。另一方面，堆是一个没有特定结构和固定大小的内存区域，可以根据需要进行调整。</p><p id="253c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全局变量、占用大量内存的局部变量以及在函数调用后不能立即回收的局部变量都存储在堆中。在堆上分配和回收变量的开销比在堆栈上多得多。</p><p id="0eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，函数调用中请求的内存存储在堆栈中，在函数结束时，这些内存会立即返回给系统。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="ffe4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，函数内部应用的变量<code class="fe lb lc ld le b">data</code>会在函数结束后被回收，不会持久。它们都存储在堆栈区。因为存在时间短，栈区分配速度快，编译器会确认这是最佳选择。</p><p id="6d52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看另一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="c8e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，变量<code class="fe lb lc ld le b">data</code>在函数结束后不会被释放，因为返回的是指向该变量的指针，编译器会认为该变量在函数结束后被用在了别处，所以会保留这个内存，同时，应用到堆中，因为堆中的内存不会被立即回收，栈中的内存会被立即回收。</p><p id="1482" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用<code class="fe lb lc ld le b">go tool compile -m</code>来分析初始代码:</p><pre class="kj kk kl km gt lf le lg lh aw li bi"><span id="6ed9" class="lj lk in le b gy ll lm l ln lo">$ go tool compile -m demo.go</span><span id="926a" class="lj lk in le b gy lp lm l ln lo">demo.go:3:6: can inline demoFunction</span><span id="b4cc" class="lj lk in le b gy lp lm l ln lo">demo.go:8:6: can inline main</span><span id="3901" class="lj lk in le b gy lp lm l ln lo">demo.go:9:31: inlining call to demoFunction</span><span id="6bfa" class="lj lk in le b gy lp lm l ln lo">demo.go:4:9: moved to heap: data</span></pre><p id="2718" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据分析结果，我们可以看到，<code class="fe lb lc ld le b">moved to heap: data</code>表示<code class="fe lb lc ld le b">datathe </code>变量已经转义到堆内存中。</p><p id="6a30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Golang 官网 FAQ 上有关于变量赋值问题的说明:</p><blockquote class="lq lr ls"><p id="b98a" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated">从正确性的角度来看，你不需要知道。Go 中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。</p><p id="160e" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated">存储位置确实对编写高效的程序有影响。如果可能的话，Go 编译器会在函数的堆栈框架中分配函数的局部变量。</p><p id="8237" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated">但是，如果编译器无法证明函数返回后变量未被引用，则编译器必须在垃圾回收堆上分配变量，以避免悬空指针错误。此外，如果局部变量非常大，将其存储在堆中可能比存储在堆栈中更有意义。</p><p id="04cd" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated">在当前的编译器中，如果一个变量的地址被占用，那么这个变量就是堆上分配的候选变量。然而，一个基本的逸出分析认识到，在某些情况下，这样的变量不能活过函数的返回，而是可以驻留在堆栈上。</p></blockquote><p id="f1fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总结一下:如果一个变量被取地址，那么它可能被分配在堆上。但是，这些只能在对变量执行转义分析操作后才能确认。如果函数返回后变量不再被引用，它将被分配到堆栈中。</p><p id="9c37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看内存逃逸的场景。</p><p id="a1b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。指针转义</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="b112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变量<code class="fe lb lc ld le b">p</code>是局部变量，但是因为是引用返回的，所以会转义到堆内存。查看编译分析，如下所示:</p><pre class="kj kk kl km gt lf le lg lh aw li bi"><span id="7ea7" class="lj lk in le b gy ll lm l ln lo">$ go tool compile -m person.go</span><span id="3041" class="lj lk in le b gy lp lm l ln lo">person.go:7:6: can inline SetPerson</span><span id="82ba" class="lj lk in le b gy lp lm l ln lo">person.go:13:6: can inline main</span><span id="02fb" class="lj lk in le b gy lp lm l ln lo">person.go:14:11: inlining call to SetPerson</span><span id="af41" class="lj lk in le b gy lp lm l ln lo">person.go:7:16: leaking param: name</span><span id="484d" class="lj lk in le b gy lp lm l ln lo">person.go:8:10: new(Person) escapes to heap // [Escape happens here]</span><span id="2109" class="lj lk in le b gy lp lm l ln lo">person.go:14:11: new(Person) does not escape</span></pre><p id="fefb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。堆栈空间不足，无法转义</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="8a27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分析执行如下:</p><pre class="kj kk kl km gt lf le lg lh aw li bi"><span id="bf5d" class="lj lk in le b gy ll lm l ln lo">$ go tool compile -m index.go</span><span id="f17f" class="lj lk in le b gy lp lm l ln lo">index.go:4:11: make([]int, 10000, 10000) escapes to heap</span></pre><p id="c5b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。动态类型转义</strong></p><p id="824b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多函数的参数类型是<code class="fe lb lc ld le b">interface</code>类型，在编译时很难确定参数的具体类型，这种类型的情况也会产生转义。例如内置函数<code class="fe lb lc ld le b">Println</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="96fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分析执行如下:</p><pre class="kj kk kl km gt lf le lg lh aw li bi"><span id="0312" class="lj lk in le b gy ll lm l ln lo">$ go tool compile -m hello.go</span><span id="6e08" class="lj lk in le b gy lp lm l ln lo">hello.go:5:6: can inline main</span><span id="4ef9" class="lj lk in le b gy lp lm l ln lo">hello.go:6:13: inlining call to fmt.Println</span><span id="0970" class="lj lk in le b gy lp lm l ln lo">hello.go:6:14: "hello golang" escapes to heap // [Escape happens here]</span><span id="9133" class="lj lk in le b gy lp lm l ln lo">hello.go:6:13: []interface {}{...} does not escape</span><span id="c380" class="lj lk in le b gy lp lm l ln lo">&lt;autogenerated&gt;:1: leaking param content: .this</span></pre><p id="2847" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">程序编译时会有内存逸出分析，内存逸出分析有 2 个好处:</p><ul class=""><li id="7f02" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">经过转义分析，可以确认具体变量是分配在堆内存还是堆栈内存，提高了程序性能。</li><li id="4104" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">降低 GC 压力，没有逸出的变量可以及时回收。</li></ul><p id="0a96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终总结:</p><ul class=""><li id="e985" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">对于小数据，使用按值传递而不是指针</li><li id="95b6" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">避免热数据长度不确定的<code class="fe lb lc ld le b">slice</code></li><li id="b754" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">避免将参数传递给<code class="fe lb lc ld le b">interface</code>，尽量使用显式类型</li><li id="8afa" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">在逸出分析之后，变量的分配被确认。Golang 官方确定了这一切，以便开发人员可以专注于业务逻辑本身，而不必过于关注内存。</li></ul><p id="78e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读本文，如果您发现文章中有任何错误，请随时发表评论。</p><p id="f0de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">祝你有愉快的一天。</p></div></div>    
</body>
</html>